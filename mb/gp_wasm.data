module main
author unknown
version 1 0 
description ''

  spec ' ' 'part A' 'part A'
  spec ' ' 'part A2' 'part A1'
  spec ' ' 'part A3' 'part A2'

to 'part A' {
  'play tone' 'C' 2 250
  'play tone' 'D' 2 250
  'play tone' 'D#' 2 400
  waitMillis 100
  'play tone' 'D' 2 250
  'play tone' 'C' 2 250
  'play tone' 'B' 1 400
  waitMillis 100
  'play tone' 'C' 2 250
  'play tone' 'D' 2 250
  'play tone' 'G' 1 400
  waitMillis 100
  'play tone' 'A' 1 250
  'play tone' 'B' 1 250
  'play tone' 'C' 2 400
  waitMillis 100
  'play tone' 'A#' 1 250
  'play tone' 'G#' 1 250
  'play tone' 'G' 1 400
  waitMillis 100
}

to 'part A2' {
  'play tone' 'F' 1 250
  'play tone' 'D#' 1 250
  'play tone' 'D' 1 400
  waitMillis 100
  'play tone' 'D#' 1 250
  'play tone' 'F' 1 250
  'play tone' 'G' 1 250
  'play tone' 'F' 1 250
  'play tone' 'D#' 1 250
  'play tone' 'D' 1 250
  'play tone' 'C' 1 400
  waitMillis 100
}

to 'part A3' {
  'play tone' 'F' 1 250
  'play tone' 'D#' 1 250
  'play tone' 'D' 1 350
  waitMillis 100
  'play tone' 'D#' 1 125
  'play tone' 'D' 1 125
  repeat 4 {
    'play tone' 'D#' 1 70
    'play tone' 'D' 1 55
  }
  waitMillis 25
  'play tone' 'D#' 1 200
  waitMillis 100
  'play tone' 'D#' 1 1000
}

script 50 50 {
whenStarted
comment 'On a micro:bit, attach a piezo speaker between pin 0 and ground'
comment 'This will use the built-in speaker on boards that have one
such as the Circuit Playground Express, ED1, or M5Stack.'
'part A'
'part A2'
'part A'
'part A3'
}

script 179 189 {
comment 'To see what each "part" block does, right click
on it and select "show block definition..."'
'part A'
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''

script 54 50 {
whenStarted
comment 'On a micro:bit, attach a piezo speaker between pin 0 and ground'
comment 'This will use the built-in speaker on boards that have one
such as the Circuit Playground Express, ED1, or M5Stack.'
local 'eigth' 150
local 'quarter' (2 * eigth)
local 'half' (2 * quarter)
repeat 2 {
  'play tone' 'C' 1 quarter
  'play tone' 'D' 1 quarter
  'play tone' 'E' 1 quarter
  'play tone' 'C' 1 quarter
}
repeat 2 {
  'play tone' 'E' 1 quarter
  'play tone' 'F' 1 quarter
  'play tone' 'G' 1 half
}
repeat 2 {
  'play tone' 'G' 1 eigth
  'play tone' 'A' 1 eigth
  'play tone' 'G' 1 eigth
  'play tone' 'F' 1 eigth
  'play tone' 'E' 1 quarter
  'play tone' 'C' 1 quarter
}
repeat 2 {
  'play tone' 'C' 1 quarter
  'play tone' 'G' 0 quarter
  'play tone' 'C' 1 half
}
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''

  spec ' ' 'happy-birthday' 'happy-birthday'
  spec ' ' 'and-many-more' 'and-many-more'

to 'and-many-more' {
  local 'third' 266
  local 'whole' (3 * third)
  'play tone' 'D' 1 third
  'play tone' 'E' 1 third
  'play tone' 'D' 1 third
  'play tone' 'F' 1 whole
}

to 'happy-birthday' {
  local 'eigth' 200
  local 'quarter' (2 * eigth)
  local 'half' (2 * quarter)
  comment 'happy birthday part 1'
  'play tone' 'D' 1 eigth
  'play tone' 'D' 1 eigth
  'play tone' 'E' 1 quarter
  'play tone' 'D' 1 quarter
  'play tone' 'G' 1 quarter
  'play tone' 'F#' 1 half
  comment 'happy birthday part 2'
  'play tone' 'D' 1 eigth
  'play tone' 'D' 1 eigth
  'play tone' 'E' 1 quarter
  'play tone' 'D' 1 quarter
  'play tone' 'A' 1 quarter
  'play tone' 'G' 1 half
  comment 'happy birthday part 3'
  'play tone' 'D' 1 eigth
  'play tone' 'D' 1 eigth
  'play tone' 'D' 2 quarter
  'play tone' 'B' 1 quarter
  'play tone' 'G' 1 quarter
  'play tone' 'F#' 1 quarter
  'play tone' 'E' 1 quarter
  comment 'happy birthday part 4'
  'play tone' 'C' 2 eigth
  'play tone' 'C' 2 eigth
  'play tone' 'B' 1 quarter
  'play tone' 'G' 1 quarter
  'play tone' 'A' 1 quarter
  'play tone' 'G' 1 half
  waitMillis half
}

script 55 50 {
whenButtonPressed 'A'
comment 'On a micro:bit, attach a piezo speaker between pin 0 and ground'
comment 'This will use the built-in speaker on boards that have one
such as the Circuit Playground Express, ED1, or M5Stack.'
sendBroadcast 'show message'
'happy-birthday'
'and-many-more'
}

script 267 181 {
comment 'To see what each of these block does, right click
on it and select "show block definition..."'
'happy-birthday'
'and-many-more'
}

script 438 250 {
whenBroadcastReceived 'show message'
scroll_text 'HAPPY BIRTHDAY!'
}

script 55 301 {
whenStarted
comment 'Works out of the box on the Adafruit Circuit Playground Express.

For other boards, you''ll need to attach a NeoPixel strip and a buzzer, and
set their pin configurations in the following two blocks:'
'attach buzzer to pin' ''
neoPixelAttach 10 ''
setNeoPixelColor 1 (colorSwatch 35 190 30 255)
setNeoPixelColor 2 (colorSwatch 187 7 191 255)
setNeoPixelColor 3 (colorSwatch 191 149 2 255)
forever {
  waitMillis 400
  rotateNeoPixelsBy 3
}
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}


module NeoPixel Output
author MicroBlocks
version 1 6 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if ((boardType) == 'M5Atom-Matrix') {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'Mbits') {
    neoPixelAttach 25 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'r' ((rgb >> 16) & 255)
    local 'g' ((rgb >> 8) & 255)
    local 'b' (rgb & 255)
    local 'brightness' (maximum r g b)
    if (delta > 0) {
      delta = (minimum delta (255 - brightness))
    } else {
      delta = (maximum delta (42 - brightness))
    }
    r = (maximum 0 (minimum (r + delta) 255))
    g = (maximum 0 (minimum (g + delta) 255))
    b = (maximum 0 (minimum (b + delta) 255))
    atPut i _np_pixels (colorFromRGB r g b)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_update' {
  '[display:neoPixelSend]' _np_pixels
  waitMicros 100
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  hasWhite = false
  if ((pushArgCount) > 2) {
    hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  fillList _np_pixels 0
  '[display:neoPixelSetPin]' pinNumber hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels color
  '_NeoPixel_update'
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' (n > 0)
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''
variables e h 'h.' q 'q.' 

  spec ' ' 'part' 'part1'
  spec ' ' 'part2' 'part2'
  spec ' ' 'part3' 'part3'
  spec ' ' 'part4' 'part4'

to part {
  waitMillis q
  'play tone' 'B' 0 q
  'play tone' 'E' 1 q.
  'play tone' 'G' 1 e
  'play tone' 'F#' 1 q
  'play tone' 'E' 1 h
  'play tone' 'B' 1 q
  'play tone' 'A' 1 h.
  'play tone' 'F#' 1 h.
  'play tone' 'E' 1 q.
  'play tone' 'G' 1 e
  'play tone' 'F#' 1 q
  'play tone' 'D' 1 h
  'play tone' 'F' 1 q
  'play tone' 'B' 0 h.
}

to part2 {
  waitMillis q
  'play tone' 'B' 0 q
  'play tone' 'E' 1 q.
  'play tone' 'G' 1 e
  'play tone' 'F#' 1 q
  'play tone' 'E' 1 h
  'play tone' 'B' 1 q
  'play tone' 'D' 2 h
  'play tone' 'C#' 2 q
  'play tone' 'C' 2 h
  'play tone' 'G#' 1 q
  'play tone' 'C' 2 q.
  'play tone' 'B' 1 e
  'play tone' 'A#' 1 q
  'play tone' 'F#' 1 h
  'play tone' 'G' 1 q
  'play tone' 'E' 1 h.
}

to part3 {
  waitMillis q
  'play tone' 'E' 1 q
  'play tone' 'G' 1 q
  'play tone' 'B' 1 h
  'play tone' 'G' 1 q
  'play tone' 'B' 1 h
  'play tone' 'G' 1 q
  'play tone' 'C' 2 h
  'play tone' 'B' 1 q
  'play tone' 'A#' 1 h
  'play tone' 'F#' 1 q
  'play tone' 'G' 1 q.
  'play tone' 'B' 1 e
  'play tone' 'A#' 1 q
  'play tone' 'A#' 0 h
  'play tone' 'B' 0 q
  'play tone' 'B' 1 h.
}

to part4 {
  waitMillis q
  'play tone' 'E' 1 q
  'play tone' 'G' 1 q
  'play tone' 'B' 1 h
  'play tone' 'G' 1 q
  'play tone' 'B' 1 h
  'play tone' 'G' 1 q
  'play tone' 'D' 2 h
  'play tone' 'C#' 2 q
  'play tone' 'C' 2 h
  'play tone' 'G#' 1 q
  'play tone' 'C' 2 q.
  'play tone' 'B' 1 e
  'play tone' 'A#' 1 q
  'play tone' 'F#' 1 h
  'play tone' 'G' 1 q
  'play tone' 'E' 1 h.
}

script 50 50 {
whenStarted
comment 'On a micro:bit, attach a piezo speaker between pin 0 and ground'
comment 'This will use the built-in speaker on boards that have one
such as the Circuit Playground Express, ED1, or M5Stack.'
e = 150
q = (2 * e)
q. = (3 * e)
h = (4 * e)
h. = (6 * e)
w = (8 * e)
part
part2
part3
part4
}

script 279 199 {
comment 'To see what each "part" block does, right click
on it and select "show block definition..."'
part
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''
variables eighth quarter whole 

script 50 50 {
whenStarted
comment 'On a micro:bit, attach a piezo speaker between pin 0 and ground'
comment 'This will use the built-in speaker on boards that have one
such as the Circuit Playground Express, ED1, or M5Stack.'
whole = 320
quarter = (whole / 2)
eighth = (whole / 8)
'play tone' 'F' 1 whole
waitMillis quarter
'play tone' 'C' 2 (whole + eighth)
waitMillis (quarter - eighth)
'play tone' 'C' 1 quarter
'play tone' 'D' 1 quarter
'play tone' 'E' 1 quarter
forever {
  repeat 2 {
    'play tone' 'F' 1 whole
    'play tone' 'G#' 1 quarter
    'play tone' 'F' 1 whole
    'play tone' 'G#' 1 quarter
    'play tone' 'G' 1 quarter
    'play tone' 'F' 1 quarter
    'play tone' 'E' 1 quarter
  }
  'play tone' 'F' 1 whole
  repeat 2 {
    'play tone' 'G#' 1 quarter
    'play tone' 'G' 1 (quarter - eighth)
    waitMillis eighth
    'play tone' 'G' 1 quarter
    'play tone' 'G#' 1 quarter
    'play tone' 'A#' 1 (quarter - eighth)
    waitMillis eighth
    'play tone' 'A#' 1 quarter
    'play tone' 'G#' 1 quarter
    'play tone' 'G' 1 whole
    'play tone' 'C' 2 quarter
    'play tone' 'C' 1 whole
  }
  'play tone' 'G#' 1 quarter
  'play tone' 'G' 1 quarter
  'play tone' 'G#' 1 quarter
  'play tone' 'A#' 1 quarter
  repeat 7 {
    'play tone' 'C' 2 (quarter - eighth)
    waitMillis eighth
  }
  'play tone' 'A#' 1 quarter
  'play tone' 'G#' 1 quarter
  'play tone' 'G' 1 quarter
  'play tone' 'G#' 1 quarter
  'play tone' 'G' 1 quarter
}
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''

script 52 50 {
comment 'Start the project, then shake your BBC micro:bit or CPX for some magic glitter!'
}

script 52 124 {
whenCondition (('[sensors:tiltX]') > 50)
'[display:mbPlot]' (random 1 5) (random 1 5)
'[display:mbUnplot]' (random 1 5) (random 1 5)
setNeoPixelColor (random 1 10) (randomColor)
setNeoPixelColor (random 1 10) (colorSwatch 0 0 0 255)
}

script 423 128 {
whenStarted
neoPixelAttach 10 ''
}

script 62 327 {
whenCondition (('[sensors:tiltX]') < 50)
'[display:mbUnplot]' (random 1 5) (random 1 5)
setNeoPixelColor (random 1 10) (colorSwatch 0 0 0 255)
}


module 'Basic Sensors' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor 
choices accelerometerRange '1' '2' '4' '8' 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[sensors:acceleration]' 'acceleration'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (Â°C)'
  spec ' ' '_setAccelRange' 'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to '_setAccelRange' n {
  '[sensors:setAccelerometerRange]' (0 + n)
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}


module NeoPixel Output
author MicroBlocks
version 1 6 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if ((boardType) == 'M5Atom-Matrix') {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'Mbits') {
    neoPixelAttach 25 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'r' ((rgb >> 16) & 255)
    local 'g' ((rgb >> 8) & 255)
    local 'b' (rgb & 255)
    local 'brightness' (maximum r g b)
    if (delta > 0) {
      delta = (minimum delta (255 - brightness))
    } else {
      delta = (maximum delta (42 - brightness))
    }
    r = (maximum 0 (minimum (r + delta) 255))
    g = (maximum 0 (minimum (g + delta) 255))
    b = (maximum 0 (minimum (b + delta) 255))
    atPut i _np_pixels (colorFromRGB r g b)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_update' {
  '[display:neoPixelSend]' _np_pixels
  waitMicros 100
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  hasWhite = false
  if ((pushArgCount) > 2) {
    hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  fillList _np_pixels 0
  '[display:neoPixelSetPin]' pinNumber hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels color
  '_NeoPixel_update'
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' (n > 0)
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}

module main
author Bernat
version 1 1 
description ''
variables 'current index' sequence 

  spec 'r' 'correct guess' 'correct guess at _' 'auto' '10'
  spec ' ' 'play note at' 'play note at _' 'auto' '10'
  spec 'r' 'wrong guess' 'wrong guess at _' 'auto' '10'
  spec ' ' 'setup' 'setup'

to 'correct guess' index {
  return (or (and (buttonA) ((at index sequence) == 0)) (and (buttonB) ((at index sequence) == 1)))
}

to 'play note at' index {
  local 'half_pixel_count' ((size _np_pixels) / 2)
  clearNeoPixels
  if ((at index sequence) == 0) {
    for i half_pixel_count {
      setNeoPixelColor i (colorSwatch 0 83 83 255)
    }
    'play tone' 'D' 2 200
  } else {
    for i half_pixel_count {
      setNeoPixelColor (i + half_pixel_count) (colorSwatch 101 103 1 255)
    }
    'play tone' 'G' 2 200
  }
  clearNeoPixels
}

to setup {
  'play tone' 'C' 1 100
  'play tone' 'E' 1 100
  'play tone' 'G' 1 100
  'play tone' 'C' 2 100
  if (sequence == 0) {
    sequence = (newList 20)
  }
  for i (size sequence) {
    atPut i sequence (random 0 1)
  }
  'current index' = 1
}

to 'wrong guess' index {
  return (or (and (buttonA) ((at index sequence) == 1)) (and (buttonB) ((at index sequence) == 0)))
}

script 50 50 {
comment 'This is the "Simon" memory game for the
Adafruit Circuit Playground Express.'
}

script 750 124 {
whenBroadcastReceived 'play sequence'
if ((v 'current index') > 10) {
  clearNeoPixels
  for i 6 {
    setNeoPixelColor (i + 2) (colorSwatch 198 0 1 255)
  }
  setNeoPixelColor 1 (colorSwatch 6 191 107 255)
  setNeoPixelColor 10 (colorSwatch 6 191 107 255)
  'play tone' 'C' 2 100
  'play tone' 'E' 1 100
  'play tone' 'C' 2 100
  'play tone' 'E' 1 100
  'play tone' 'C' 1 100
  'play tone' 'G' 1 100
  'play tone' 'C' 2 200
  waitMillis 1000
  clearNeoPixels
  sendBroadcast 'go!'
} else {
  for i (v 'current index') {
    'play note at' i
  }
  sendBroadcast 'player turn'
}
}

script 344 128 {
whenBroadcastReceived 'player turn'
local 'index' 1
repeatUntil (index > (v 'current index')) {
  if ('correct guess' index) {
    'play note at' index
    index += 1
    waitUntil (and (not (buttonA)) (not (buttonB)))
  } ('wrong guess' index) {
    neoPixelSetAllToColor (colorSwatch 177 36 37 255)
    'play tone' 'G' 1 250
    'play tone' 'F#' 1 250
    'play tone' 'F' 1 250
    'play tone' 'E' 1 250
    waitMillis 500
    clearNeoPixels
    sendBroadcast 'go!'
    stopTask
  }
}
waitMillis 500
'current index' += 1
sendBroadcast 'play sequence'
}

script 50 130 {
whenStarted
neoPixelAttach 10 ''
sendBroadcast 'go!'
}

script 51 234 {
whenBroadcastReceived 'go!'
setup
waitMillis 1000
sendBroadcast 'play sequence'
}

script 51 362 {
whenBroadcastReceived 'go!'
neoPixelSetAllToColor (colorSwatch 0 0 0 255)
for i 5 {
  setNeoPixelColor i (colorSwatch 3 0 150 255)
}
repeat 10 {
  rotateNeoPixelsBy -1
  waitMillis 50
}
neoPixelSetAllToColor (colorSwatch 0 0 0 255)
}


module NeoPixel Output
author MicroBlocks
version 1 6 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if ((boardType) == 'M5Atom-Matrix') {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'Mbits') {
    neoPixelAttach 25 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'r' ((rgb >> 16) & 255)
    local 'g' ((rgb >> 8) & 255)
    local 'b' (rgb & 255)
    local 'brightness' (maximum r g b)
    if (delta > 0) {
      delta = (minimum delta (255 - brightness))
    } else {
      delta = (maximum delta (42 - brightness))
    }
    r = (maximum 0 (minimum (r + delta) 255))
    g = (maximum 0 (minimum (g + delta) 255))
    b = (maximum 0 (minimum (b + delta) 255))
    atPut i _np_pixels (colorFromRGB r g b)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_update' {
  '[display:neoPixelSend]' _np_pixels
  waitMicros 100
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  hasWhite = false
  if ((pushArgCount) > 2) {
    hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  fillList _np_pixels 0
  '[display:neoPixelSetPin]' pinNumber hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels color
  '_NeoPixel_update'
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' (n > 0)
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''
variables full half quarter 

script 50 50 {
whenStarted
comment 'On a micro:bit, attach a piezo speaker between pin 0 and ground'
comment 'This will use the built-in speaker on boards that have one
such as the Circuit Playground Express, ED1, or M5Stack.'
full = 360
half = (full / 2)
quarter = (full / 4)
repeat 2 {
  'play tone' 'G' 2 quarter
  'play tone' 'F' 2 quarter
  'play tone' 'G' 2 full
  'play tone' 'C' 2 full
  waitMillis (full + half)
  'play tone' 'G#' 2 quarter
  'play tone' 'G' 2 quarter
  'play tone' 'G#' 2 half
  'play tone' 'G' 2 half
  'play tone' 'F' 2 full
  waitMillis (full + half)
  'play tone' 'G#' 2 quarter
  'play tone' 'G' 2 quarter
  'play tone' 'G#' 2 full
  'play tone' 'C' 2 full
  'play tone' 'D' 2 full
  waitMillis half
  'play tone' 'F' 2 quarter
  'play tone' 'D#' 2 quarter
  'play tone' 'F' 2 half
  'play tone' 'D#' 2 half
  'play tone' 'D' 2 half
  'play tone' 'F' 2 half
  'play tone' 'D#' 2 full
  waitMillis half
}
'play tone' 'D' 2 quarter
'play tone' 'D#' 2 quarter
'play tone' 'F' 2 (full + half)
'play tone' 'D#' 2 quarter
'play tone' 'F' 2 quarter
'play tone' 'G' 2 half
'play tone' 'F' 2 half
'play tone' 'D#' 2 half
'play tone' 'D' 2 half
'play tone' 'C' 2 full
'play tone' 'G#' 2 full
'play tone' 'G' 2 (full * 3)
waitMillis quarter
'play tone' 'G' 2 quarter
'play tone' 'G#' 2 quarter
'play tone' 'G' 2 quarter
'play tone' 'F' 2 quarter
'play tone' 'G' 2 (full * 2)
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''

  spec ' ' 'part A' 'part A'
  spec ' ' 'part A2' 'part A1'
  spec ' ' 'part A3' 'part A2'

to 'part A' {
  'play tone' 'C' 2 250
  'play tone' 'D' 2 250
  'play tone' 'D#' 2 400
  waitMillis 100
  'play tone' 'D' 2 250
  'play tone' 'C' 2 250
  'play tone' 'B' 1 400
  waitMillis 100
  'play tone' 'C' 2 250
  'play tone' 'D' 2 250
  'play tone' 'G' 1 400
  waitMillis 100
  'play tone' 'A' 1 250
  'play tone' 'B' 1 250
  'play tone' 'C' 2 400
  waitMillis 100
  'play tone' 'A#' 1 250
  'play tone' 'G#' 1 250
  'play tone' 'G' 1 400
  waitMillis 100
}

to 'part A2' {
  'play tone' 'F' 1 250
  'play tone' 'D#' 1 250
  'play tone' 'D' 1 400
  waitMillis 100
  'play tone' 'D#' 1 250
  'play tone' 'F' 1 250
  'play tone' 'G' 1 250
  'play tone' 'F' 1 250
  'play tone' 'D#' 1 250
  'play tone' 'D' 1 250
  'play tone' 'C' 1 400
  waitMillis 100
}

to 'part A3' {
  'play tone' 'F' 1 250
  'play tone' 'D#' 1 250
  'play tone' 'D' 1 350
  waitMillis 100
  'play tone' 'D#' 1 125
  'play tone' 'D' 1 125
  repeat 4 {
    'play tone' 'D#' 1 70
    'play tone' 'D' 1 55
  }
  waitMillis 25
  'play tone' 'D#' 1 200
  waitMillis 100
  'play tone' 'D#' 1 1000
}

script 50 50 {
whenStarted
comment 'On a micro:bit, attach a piezo speaker between pin 0 and ground'
comment 'This will use the built-in speaker on boards that have one
such as the Circuit Playground Express, ED1, or M5Stack.'
'part A'
'part A2'
'part A'
'part A3'
}

script 179 189 {
comment 'To see what each "part" block does, right click
on it and select "show block definition..."'
'part A'
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''
variables x y 

script 50 50 {
whenStarted
x = 1
y = 1
forever {
  if (and (('[sensors:tiltX]') < -10) (x > 1)) {x += -1}
  if (and (('[sensors:tiltX]') > 10) (x < 5)) {x += 1}
  if (and (('[sensors:tiltY]') < -10) (y > 1)) {y += -1}
  if (and (('[sensors:tiltY]') > 10) (y < 5)) {y += 1}
  '[display:mbDisplayOff]'
  '[display:mbPlot]' x y
  waitMillis 70
}
}


module 'Basic Sensors' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor 
choices accelerometerRange '1' '2' '4' '8' 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[sensors:acceleration]' 'acceleration'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (Â°C)'
  spec ' ' '_setAccelRange' 'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to '_setAccelRange' n {
  '[sensors:setAccelerometerRange]' (0 + n)
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''

script 50 50 {
whenStarted
'[display:mbDisplayOff]'
forever {
  setUserLED true
  waitMillis 200
  setUserLED false
  waitMillis 200
}
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author 'Victor Casado'
version 1 0 
description ''
variables coordX coordY 

script 50 50 {
whenStarted
'[display:mbDisplayOff]'
forever {
  coordX = (((('[sensors:tiltX]') + 100) * ('[tft:getWidth]')) / 200)
  coordY = (((('[sensors:tiltY]') + 100) * ('[tft:getHeight]')) / 200)
  '[tft:circle]' coordX coordY 5 (colorSwatch 255 255 255 255)
  waitMillis 20
  '[tft:circle]' coordX coordY 5 (colorSwatch 0 0 0 255)
}
}


module 'Basic Sensors' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor 
choices accelerometerRange '1' '2' '4' '8' 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[sensors:acceleration]' 'acceleration'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (Â°C)'
  spec ' ' '_setAccelRange' 'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to '_setAccelRange' n {
  '[sensors:setAccelerometerRange]' (0 + n)
}


module TFT Output
author MicroBlocks
version 1 5 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  space
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

module main
author unknown
version 1 0 
description ''

  spec ' ' 'dice' 'draw die _' 'auto' 6
  spec ' ' 'draw dot x' 'draw dot x _ y _' 'auto auto' 10 '10'

to dice num {
  '[tft:roundedRect]' 16 16 96 96 8 -1 true
  if (num <= 6) {
    if (or (or (num == 1) (num == 3)) (num == 5)) {'draw dot x' 64 64}
    if (num >= 2) {
      'draw dot x' 96 32
      'draw dot x' 32 96
    }
    if (num >= 4) {
      'draw dot x' 32 32
      'draw dot x' 96 96
    }
    if (num == 6) {
      'draw dot x' 32 64
      'draw dot x' 96 64
    }
  }
}

to 'draw dot x' x y {
  '[tft:circle]' x y 10 0 true
}

script 169 50 {
comment '    By JosÃ© GarcÃ­a Yeste - Citilab
===========================
Motion and TFT library demo.

Wait for the ED1 to say "Shake!", then
shake it to roll a die.'
}

script 50 113 {
whenStarted
repeat 12 {
  local 'ignore' (motion)
}
forever {
  '[display:mbDisplayOff]'
  dice 0
  '[tft:text]' 'Shake!' 32 56 0 2 false
  waitUntil ((motion) > 12)
  local 'tilt' 0
  repeat 10 {
    tilt = (maximum tilt (absoluteValue (motion)))
    waitMillis 30
  }
  tilt = (minimum 60 (tilt / 2))
  if (tilt > 5) {
    repeatUntil (tilt <= 0) {
      local 'delay' (('[misc:sin]' (100 * (60 - tilt))) / 100)
      dice (random 1 6)
      waitMillis delay
      'play frequency' 261 5
      tilt += -1
    }
  } else {
    dice 0
  }
  waitMillis 2000
}
}


module Motion Input
author MicroBlocks
version 1 1 
tags acceleration steps motion accelerometer 
description 'Count steps and detect motion in boards with a built-in accelerometer, such as the micro:bit, the Calliope, the Citilab ED1 or the Circuit Playground Express.'
variables _motionSamples _stepCount _stepThreshold _stepMotionHigh 

  spec ' ' 'startStepCounter' 'start step counter'
  spec 'r' 'stepCount' 'step count'
  spec ' ' 'clearStepCount' 'clear step count'
  spec ' ' 'setStepThreshold' 'set step threshold _ (0-50)' 'auto' 10
  spec 'r' 'motion' 'motion'
  spec ' ' '_addSample' '_addSample _' 'auto' '10'
  spec 'r' '_recentAverage' '_recentAverage'
  spec ' ' '_stepCounterLoop' '_stepCounterLoop'

to '_addSample' s {
  if (0 == _motionSamples) {_motionSamples = (newList 12)}
  for i ((size _motionSamples) - 1) {
    atPut i _motionSamples (at (i + 1) _motionSamples)
  }
  atPut (size _motionSamples) _motionSamples s
}

to '_recentAverage' {
  if (0 == _motionSamples) {return 0}
  local 'count' (size _motionSamples)
  local 'total' 0
  for i count {
    total += (at i _motionSamples)
  }
  return (total / count)
}

to '_stepCounterLoop' {
  if (_stepThreshold == 0) {_stepThreshold = 15}
  forever {
    local 'n' (motion)
    if (n > _stepThreshold) {
      if (not _stepMotionHigh) {
        _stepMotionHigh = (booleanConstant true)
        _stepCount += 1
        sendBroadcast 'step'
      }
    } (n < -3) {
      _stepMotionHigh = (booleanConstant false)
    }
    waitMillis 10
  }
}

to clearStepCount {
  _stepCount = 0
}

to motion {
  comment 'Return the change in acceleration since the last call.'
  comment 'Details: The value is the difference between the current
acceleration and the average value of the last N samples.
The result is zero when there are no changes of acceleration.
It goes positive momentarily when the acceleration decreases
(e.g. because the microcontroller is in free fall) and positive
when the acceleration increases (e.g. when the falling micro-
controller is caught).'
  local 'current' ('[sensors:acceleration]')
  local 'result' (current - ('_recentAverage'))
  '_addSample' current
  if ((absoluteValue result) < 3) {
    comment 'Suppress sensor noise'
    result = 0
  }
  return result
}

to setStepThreshold threshold {
  comment 'The lower the threshold, the more sensitive the
step counter is. If the threshold is too low, it will
count extra steps. If it is too high, it will miss steps.'
  _stepThreshold = (threshold + 5)
}

to startStepCounter {
  comment 'Reset the step count to zero and start the
step counter loop.'
  _stepCount = 0
  sendBroadcast '_stepCounterLoop'
}

to stepCount {
  return _stepCount
}


module TFT Output
author MicroBlocks
version 1 5 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  space
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''
variables deco 

  spec ' ' 'polygon' 'polygon _ _ _' 'auto auto auto' 5 100 0
  spec ' ' 'decoration' 'decoration _' 'auto' 0

to decoration num {
  local 'x' (_turtleX >> 14)
  local 'y' (_turtleY >> 14)
  if (num == 1) {
    '[tft:circle]' x y 4 _turtleColor true
  } (num == 2) {
    '[tft:rect]' (x - 4) (y - 4) 8 8 _turtleColor true
  } (num == 3) {
    '[tft:text]' '@' (x - 4) (y - 4) _turtleColor 2 false
  }
}

to polygon sides size xoffset {
  local 'd' ((('[misc:sin]' (360 / sides)) * size) / ('[misc:sin]' 120))
  'pen up'
  setHeading 0
  'go to x' (xoffset - (d / 2)) (size / 2)
  'pen down'
  repeat sides {
    move d
    turnBy (360 / sides)
    decoration deco
  }
  'pen up'
}

script 498 50 {
whenCondition (('[sensors:tiltZ]') < -140)
deco += 1
deco = (deco % 4)
waitMillis 200
}

script 50 54 {
comment '    By JosÃ© GarcÃ­a Yeste - Citilab
===========================
A cool Turtle library demo!

Draws polygons on the ED1 display.
Tilt the board to change the sides of
the shape. Shake it to cycle between
node styles. Press the OK button to
change the polygon color.'
}

script 503 209 {
whenCondition ('OK button')
setPenToRandomColor
}

script 50 231 {
whenStarted
deco = 1
'set pen color to' (colorSwatch 195 188 254 255)
forever {
  local 'sides' (maximum 3 ((('[sensors:tiltY]') / 5) + 6))
  local 'side length' (('[tft:getWidth]') / 2)
  local 'xOffset' ((('[sensors:tiltX]') * ('[tft:getWidth]')) / 50)
  polygon sides (v 'side length') xOffset
  waitMillis 40
  '[display:mbDisplayOff]'
  waitMillis 1
}
}

script 503 306 {
whenButtonPressed 'A'
setPenToRandomColor
}


module 'Basic Sensors' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor 
choices accelerometerRange '1' '2' '4' '8' 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[sensors:acceleration]' 'acceleration'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (Â°C)'
  spec ' ' '_setAccelRange' 'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to '_setAccelRange' n {
  '[sensors:setAccelerometerRange]' (0 + n)
}


module 'ED1 Buttons' Input
author MicroBlocks
version 1 0 
tags button capacitive ed1 
description 'Provides blocks for the six capacitive buttons in the Citilab ED1 board.'
variables _ED1_buttons_init '_capacitive threshold' 

  spec ' ' '_ED1_buttons_init' '_ED1_buttons_init' 'any any any'
  spec 'r' 'OK button' 'button OK'
  spec 'r' 'cancel button' 'button X'
  spec 'r' 'up button' 'button up'
  spec 'r' 'down button' 'button down'
  spec 'r' 'left button' 'button left'
  spec 'r' 'right button' 'button right'
  spec ' ' 'set capacitive threshold to' 'set capacitive threshold to _' 'auto' 16

to 'OK button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 15) < (v '_capacitive threshold'))
}

to '_ED1_buttons_init' {
  if (_ED1_buttons_init == 0) {
    if ((v '_capacitive threshold') == 0) {'_capacitive threshold' = 16}
    _ED1_buttons_init = (booleanConstant true)
  }
}

to 'cancel button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 14) < (v '_capacitive threshold'))
}

to 'down button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 13) < (v '_capacitive threshold'))
}

to 'left button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 2) < (v '_capacitive threshold'))
}

to 'right button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 27) < (v '_capacitive threshold'))
}

to 'set capacitive threshold to' threshold {
  '_capacitive threshold' = threshold
}

to 'up button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 4) < (v '_capacitive threshold'))
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}


module TFT Output
author MicroBlocks
version 1 5 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  space
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}


module Turtle Output
author MicroBlocks
version 1 3 
depends TFT 
tags tft graphics draw 
description 'Draw with turtle geometry on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.
'
variables _turtleX _turtleY _turtleHeading _turtlePenIsDown _turtleColor 

  spec ' ' 'home' 'home'
  spec ' ' 'move' 'move _' 'auto' '10'
  spec ' ' 'turnBy' 'turn _ degrees' 'auto' 90
  spec ' ' 'turnFraction' 'turn _ / _ of circle' 'auto auto' 1 4
  spec ' ' 'pen down' 'pen down'
  spec ' ' 'pen up' 'pen up'
  spec ' ' 'set pen color to' 'set pen color to _' 'color'
  spec ' ' 'setPenToRandomColor' 'set pen to random color'
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' 'clearDisplay' 'fill display with _' 'color'
  spec ' ' 'go to x' 'go to x _ y _' 'auto auto' '10' '10'
  spec ' ' 'setHeading' 'point in direction _' 'auto' 0
  spec ' ' '_turtleNotes' '_turtleNotes'

to '_turtleNotes' {
  comment 'Representation:
  _turtleHeading is in hundreths of a degree  (e.g. 4500 means 45 degrees)
  _turtleX and _turtleY are scaled by 16384 (2^14)

The sine function takes an angle in hundreds of a degree and returns a
number scaled by 16384. _turtleX and _turtleY are also scaled by 16384.
Those numbers are shifted right by 14 bits to get pixel locations.'
}

to clearDisplay color {
  '[tft:rect]' 0 0 ('[tft:getWidth]') ('[tft:getHeight]') color true
  comment 'Give the display controller time to finish this operation'
  waitMillis 1
}

to 'go to x' x y {
  local 'startX' (_turtleX >> 14)
  local 'startY' (_turtleY >> 14)
  _turtleX = (((('[tft:getWidth]') / 2) + x) << 14)
  _turtleY = (((('[tft:getHeight]') / 2) - y) << 14)
  local 'endX' (_turtleX >> 14)
  local 'endY' (_turtleY >> 14)
  if _turtlePenIsDown {
    '[tft:line]' startX startY endX endY _turtleColor
  }
}

to home {
  if (0 == _turtlePenIsDown) {
    'set pen color to' (colorSwatch 7 255 1 255)
    '[display:mbDisplayOff]'
    'pen up'
  }
  'go to x' 0 0
  setHeading 0
}

to move n {
  local 'startX' (_turtleX >> 14)
  local 'startY' (_turtleY >> 14)
  comment 'The cosine is just the sine shifted by 90 degrees.'
  _turtleX += (n * ('[misc:sin]' (_turtleHeading + 9000)))
  _turtleY += (n * ('[misc:sin]' _turtleHeading))
  local 'endX' (_turtleX >> 14)
  local 'endY' (_turtleY >> 14)
  if _turtlePenIsDown {
    '[tft:line]' startX startY endX endY _turtleColor
  }
}

to 'pen down' {
  _turtlePenIsDown = (booleanConstant true)
}

to 'pen up' {
  _turtlePenIsDown = (booleanConstant false)
}

to 'set pen color to' color {
  _turtleColor = color
}

to setHeading a {
  _turtleHeading = ((a * 100) % 36000)
}

to setPenToRandomColor {
  local 'c1' (random 150 220)
  local 'c2' (random 0 ((3 * c1) / 4))
  local 'c3' (random 0 ((3 * c1) / 4))
  local 'which' (random 1 3)
  if (1 == which) {
    _turtleColor = ((c1 << 16) | ((c2 << 8) | c3))
  } (2 == which) {
    _turtleColor = ((c2 << 16) | ((c3 << 8) | c1))
  } else {
    _turtleColor = ((c3 << 16) | ((c1 << 8) | c2))
  }
}

to turnBy a {
  _turtleHeading += (a * 100)
  _turtleHeading = (_turtleHeading % 36000)
}

to turnFraction num denom {
  _turtleHeading += ((num * 36000) / denom)
  _turtleHeading = (_turtleHeading % 36000)
}

module main
author unknown
version 2 0 
description ''
variables 'player x' 'player y' playing 'stone x' 'stone y' 

script 417 49 {
whenStarted
'player x' = 3
'player y' = 5
forever {
  if playing {
    if (and (buttonA) ((v 'player x') > 1)) {'player x' += -1}
    if (and (buttonB) ((v 'player x') < 5)) {'player x' += 1}
    '[display:mbDisplayOff]'
    '[display:mbPlot]' (v 'stone x') (v 'stone y')
    '[display:mbPlot]' (v 'player x') (v 'player y')
    waitMillis 100
  }
}
}

script 47 65 {
comment 'Game written by David SÃ¡nchez MarÃ­n
============================

Use the two buttons in the micro:bit to
try to avoid the falling stones.

Have fun!'
}

script 50 218 {
whenStarted
playing = (booleanConstant true)
'stone x' = (random 1 5)
'stone y' = 0
forever {
  if playing {
    repeatUntil ((v 'stone y') == 5) {
      'stone y' += 1
      waitMillis 200
    }
    'stone x' = (random 1 5)
    'stone y' = 0
  }
}
}

script 55 586 {
whenCondition (and ((v 'player x') == (v 'stone x')) ((v 'player y') == (v 'stone y')))
playing = (booleanConstant false)
scroll_text 'GAME OVER'
'[display:mbDisplayOff]'
waitMillis 1000
playing = (booleanConstant true)
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''

script 54 50 {
whenStarted
comment 'On a micro:bit, attach a piezo speaker between pin 0 and ground'
comment 'This will use the built-in speaker on boards that have one
such as the Circuit Playground Express, ED1, or M5Stack.'
local 'eigth' 150
local 'quarter' (2 * eigth)
local 'half' (2 * quarter)
repeat 2 {
  'play tone' 'C' 1 quarter
  'play tone' 'D' 1 quarter
  'play tone' 'E' 1 quarter
  'play tone' 'C' 1 quarter
}
repeat 2 {
  'play tone' 'E' 1 quarter
  'play tone' 'F' 1 quarter
  'play tone' 'G' 1 half
}
repeat 2 {
  'play tone' 'G' 1 eigth
  'play tone' 'A' 1 eigth
  'play tone' 'G' 1 eigth
  'play tone' 'F' 1 eigth
  'play tone' 'E' 1 quarter
  'play tone' 'C' 1 quarter
}
repeat 2 {
  'play tone' 'C' 1 quarter
  'play tone' 'G' 0 quarter
  'play tone' 'C' 1 half
}
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''
variables responses 

  spec ' ' 'initializeResponses' 'initializeResponses'

to initializeResponses {
  responses = ('[data:makeList]' ('[data:makeList]' '/' '<h1>Hello!</h1>
<p>This is the MicroBlocks HTTP server.</p>
<p>You can test the following URLs:</p>
<ul>
<li>/test</li>
<li>/foo</li>
<li>/bar</li>
</ul>') ('[data:makeList]' '/test' '<p>This is a <strong>test</strong> URL</p>') ('[data:makeList]' '/foo' '<p>Just a page that says</p>
<h1>FOO</h1>') ('[data:makeList]' '/bar' '<p>Just a page that says</p>
<h1>BAR</h1>
<img src="https://microblocks.fun/assets/img/logos/MicroBlocks.svg"/>'))
}

script 50 50 {
comment 'This is an example HTTP server written in MicroBlocks.
It responds to the following URLs:
  /
  /test
  /foo
  /bar

You can also try a random URL and get back a 404 page.

The server responds to all request methods in the same way,
but you can easily add checks for other methods (like POST)
by using the ( method of request [ ] ) block.

You can also extract the body of a request (when it has one)
by using the ( body of request [ ] ) block.

Enjoy!'
}

script 52 347 {
whenStarted
comment 'Remember to use your network name (SSID) and password below'
wifiConnect 'Network_Name' ''
initializeResponses
local 'request' ''
forever {
  request = ('[net:httpServerGetRequest]')
  if (request != '') {
    for response responses {
      if (('path of request' request) == (at 1 response)) {'[net:respondToHttpRequest]' '200 OK' (at 2 response)}
    }
    '[net:respondToHttpRequest]' '404 Not Found' '<h1>404 Not Found</h1><p>I''m sorry, this page does not exist :(</p>'
  }
  waitMillis 10
}
}


module 'HTTP server' Comm
author MicroBlocks
version 1 3 
depends WiFi 
tags http network 
description 'Create an HTTP server in MicroBlocks. You can use this library to allow remote control for your Wifi-enabled board.'

  spec 'r' '[net:httpServerGetRequest]' 'HTTP server request : binary data _' 'bool' false
  spec 'r' 'request method' 'method of request _' 'str' ''
  spec 'r' 'path of request' 'path of request _' 'str' ''
  spec 'r' 'headers of request' 'headers of request _' 'str' ''
  spec 'r' 'body of request' 'body of request _' 'str' ''
  spec 'r' 'content length of request' 'content length of request _' 'str' ''
  spec ' ' '[net:respondToHttpRequest]' 'respond _ to HTTP request : with body _ : and headers _ : keepAlive _' 'str str str bool' '200 OK' 'Welcome to the MicroBlocks HTTP server' 'Content-Type: text/plain' false
  spec 'r' '_endOfHeaders' '_end of headers _' 'str'
  spec 'r' '_toString' '_toString _' 'auto' 'abc'

to '_endOfHeaders' request {
  return ('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) request)
}

to '_toString' aStringOrByteArray {
  comment 'If argument is a byte array, convert it to a string. '
  if (not (isType aStringOrByteArray 'string')) {
    aStringOrByteArray = ('[data:join]' '' aStringOrByteArray)
  }
  return aStringOrByteArray
}

to 'body of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('[data:copyFromTo]' request (i + 4))
}

to 'content length of request' request {
  local 'i' ('_endOfHeaders' request)
  if (i < 0) {
    return 0
  }
  local 'j' ('[data:find]' 'Content-Length: ' request)
  if (j < 0) {
    comment 'Try alternate capitalization'
    j = ('[data:find]' 'Content-length: ' request)
  }
  if (or (j < 0) (j > i)) {
    return 0
  }
  j += 16
  local 'k' ('[data:find]' ('[data:unicodeString]' 13) request j)
  return (('[data:copyFromTo]' request j (k - 1)) + 0)
}

to 'headers of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('_toString' ('[data:copyFromTo]' request 1 (i - 1)))
}

to 'path of request' request {
  return ('_toString' ('[data:copyFromTo]' request (('[data:find]' ' ' request) + 1) (('[data:find]' ' HTTP' request) - 1)))
}

to 'request method' request {
  return ('_toString' ('[data:copyFromTo]' request 1 (('[data:find]' ' ' request) - 1)))
}


module WiFi Comm
author MicroBlocks
version 1 6 
tags communication network 
description 'Connect to a WiFi network. Used in conjunction with other network libraries, such as HTTP client, HTTP server or Web Thing.
'

  spec ' ' 'wifiConnect' 'wifi connect to _ password _ : IP _ gateway _ subnet _' 'str str auto auto auto' 'Network_Name' '' '192.168.1.42' '192.168.1.1' '255.255.255.0'
  spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
  spec 'r' 'getIPAddress' 'IP address'
  spec 'r' '[net:myMAC]' 'MAC address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to wifiConnect ssid password fixedIP gatewayIP subnetIP {
  if (not ('[net:hasWiFi]')) {return}
  '[net:stopWiFi]'
  if ((pushArgCount) < 5) {
    '[net:startWiFi]' ssid password
  } else {
    '[net:startWiFi]' ssid password false fixedIP gatewayIP subnetIP
  }
  local 'startMSecs' (millisOp)
  repeatUntil (('[net:myIPAddress]') != '0.0.0.0') {
    comment 'Timeout after N seconds'
    if (((millisOp) - startMSecs) > 30000) {
      sayIt 'Could not connect'
      return 0
    }
    comment 'Slow blink while trying to connect'
    setUserLED true
    waitMillis 300
    setUserLED false
    waitMillis 300
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  if ('Connected' != ('[net:wifiStatus]')) {
    sayIt 'Could not create hotspot'
    return 0
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

module main
author unknown
version 1 0 
description ''

script 50 50 {
whenButtonPressed 'A'
'[display:mbDisplay]' 15237450
waitMillis 1000
'[display:mbDisplayOff]'
}

script 50 262 {
whenButtonPressed 'B'
'[display:mbDisplay]' 18284874
waitMillis 1000
'[display:mbDisplayOff]'
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''

  spec ' ' 'happy-birthday' 'happy-birthday'
  spec ' ' 'and-many-more' 'and-many-more'

to 'and-many-more' {
  local 'third' 266
  local 'whole' (3 * third)
  'play tone' 'D' 1 third
  'play tone' 'E' 1 third
  'play tone' 'D' 1 third
  'play tone' 'F' 1 whole
}

to 'happy-birthday' {
  local 'eigth' 200
  local 'quarter' (2 * eigth)
  local 'half' (2 * quarter)
  comment 'happy birthday part 1'
  'play tone' 'D' 1 eigth
  'play tone' 'D' 1 eigth
  'play tone' 'E' 1 quarter
  'play tone' 'D' 1 quarter
  'play tone' 'G' 1 quarter
  'play tone' 'F#' 1 half
  comment 'happy birthday part 2'
  'play tone' 'D' 1 eigth
  'play tone' 'D' 1 eigth
  'play tone' 'E' 1 quarter
  'play tone' 'D' 1 quarter
  'play tone' 'A' 1 quarter
  'play tone' 'G' 1 half
  comment 'happy birthday part 3'
  'play tone' 'D' 1 eigth
  'play tone' 'D' 1 eigth
  'play tone' 'D' 2 quarter
  'play tone' 'B' 1 quarter
  'play tone' 'G' 1 quarter
  'play tone' 'F#' 1 quarter
  'play tone' 'E' 1 quarter
  comment 'happy birthday part 4'
  'play tone' 'C' 2 eigth
  'play tone' 'C' 2 eigth
  'play tone' 'B' 1 quarter
  'play tone' 'G' 1 quarter
  'play tone' 'A' 1 quarter
  'play tone' 'G' 1 half
  waitMillis half
}

script 55 50 {
whenButtonPressed 'A'
comment 'On a micro:bit, attach a piezo speaker between pin 0 and ground'
comment 'This will use the built-in speaker on boards that have one
such as the Circuit Playground Express, ED1, or M5Stack.'
sendBroadcast 'show message'
'happy-birthday'
'and-many-more'
}

script 267 181 {
comment 'To see what each of these block does, right click
on it and select "show block definition..."'
'happy-birthday'
'and-many-more'
}

script 438 250 {
whenBroadcastReceived 'show message'
scroll_text 'HAPPY BIRTHDAY!'
}

script 55 301 {
whenStarted
comment 'Works out of the box on the Adafruit Circuit Playground Express.

For other boards, you''ll need to attach a NeoPixel strip and a buzzer, and
set their pin configurations in the following two blocks:'
'attach buzzer to pin' ''
neoPixelAttach 10 ''
setNeoPixelColor 1 (colorSwatch 35 190 30 255)
setNeoPixelColor 2 (colorSwatch 187 7 191 255)
setNeoPixelColor 3 (colorSwatch 191 149 2 255)
forever {
  waitMillis 400
  rotateNeoPixelsBy 3
}
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}


module NeoPixel Output
author MicroBlocks
version 1 6 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if ((boardType) == 'M5Atom-Matrix') {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'Mbits') {
    neoPixelAttach 25 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'r' ((rgb >> 16) & 255)
    local 'g' ((rgb >> 8) & 255)
    local 'b' (rgb & 255)
    local 'brightness' (maximum r g b)
    if (delta > 0) {
      delta = (minimum delta (255 - brightness))
    } else {
      delta = (maximum delta (42 - brightness))
    }
    r = (maximum 0 (minimum (r + delta) 255))
    g = (maximum 0 (minimum (g + delta) 255))
    b = (maximum 0 (minimum (b + delta) 255))
    atPut i _np_pixels (colorFromRGB r g b)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_update' {
  '[display:neoPixelSend]' _np_pixels
  waitMicros 100
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  hasWhite = false
  if ((pushArgCount) > 2) {
    hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  fillList _np_pixels 0
  '[display:neoPixelSetPin]' pinNumber hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels color
  '_NeoPixel_update'
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' (n > 0)
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''
variables e h 'h.' q 'q.' 

  spec ' ' 'part' 'part1'
  spec ' ' 'part2' 'part2'
  spec ' ' 'part3' 'part3'
  spec ' ' 'part4' 'part4'

to part {
  waitMillis q
  'play tone' 'B' 0 q
  'play tone' 'E' 1 q.
  'play tone' 'G' 1 e
  'play tone' 'F#' 1 q
  'play tone' 'E' 1 h
  'play tone' 'B' 1 q
  'play tone' 'A' 1 h.
  'play tone' 'F#' 1 h.
  'play tone' 'E' 1 q.
  'play tone' 'G' 1 e
  'play tone' 'F#' 1 q
  'play tone' 'D' 1 h
  'play tone' 'F' 1 q
  'play tone' 'B' 0 h.
}

to part2 {
  waitMillis q
  'play tone' 'B' 0 q
  'play tone' 'E' 1 q.
  'play tone' 'G' 1 e
  'play tone' 'F#' 1 q
  'play tone' 'E' 1 h
  'play tone' 'B' 1 q
  'play tone' 'D' 2 h
  'play tone' 'C#' 2 q
  'play tone' 'C' 2 h
  'play tone' 'G#' 1 q
  'play tone' 'C' 2 q.
  'play tone' 'B' 1 e
  'play tone' 'A#' 1 q
  'play tone' 'F#' 1 h
  'play tone' 'G' 1 q
  'play tone' 'E' 1 h.
}

to part3 {
  waitMillis q
  'play tone' 'E' 1 q
  'play tone' 'G' 1 q
  'play tone' 'B' 1 h
  'play tone' 'G' 1 q
  'play tone' 'B' 1 h
  'play tone' 'G' 1 q
  'play tone' 'C' 2 h
  'play tone' 'B' 1 q
  'play tone' 'A#' 1 h
  'play tone' 'F#' 1 q
  'play tone' 'G' 1 q.
  'play tone' 'B' 1 e
  'play tone' 'A#' 1 q
  'play tone' 'A#' 0 h
  'play tone' 'B' 0 q
  'play tone' 'B' 1 h.
}

to part4 {
  waitMillis q
  'play tone' 'E' 1 q
  'play tone' 'G' 1 q
  'play tone' 'B' 1 h
  'play tone' 'G' 1 q
  'play tone' 'B' 1 h
  'play tone' 'G' 1 q
  'play tone' 'D' 2 h
  'play tone' 'C#' 2 q
  'play tone' 'C' 2 h
  'play tone' 'G#' 1 q
  'play tone' 'C' 2 q.
  'play tone' 'B' 1 e
  'play tone' 'A#' 1 q
  'play tone' 'F#' 1 h
  'play tone' 'G' 1 q
  'play tone' 'E' 1 h.
}

script 50 50 {
whenStarted
comment 'On a micro:bit, attach a piezo speaker between pin 0 and ground'
comment 'This will use the built-in speaker on boards that have one
such as the Circuit Playground Express, ED1, or M5Stack.'
e = 150
q = (2 * e)
q. = (3 * e)
h = (4 * e)
h. = (6 * e)
w = (8 * e)
part
part2
part3
part4
}

script 279 199 {
comment 'To see what each "part" block does, right click
on it and select "show block definition..."'
part
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''

script 50 50 {
whenButtonPressed 'A'
repeatUntil (not (buttonA)) {
  '[display:mbDisplay]' 145728
  waitMillis 250
  '[display:mbDisplay]' 4685802
  waitMillis 250
  '[display:mbDisplayOff]'
  waitMillis 300
}
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''
variables 'ball speed' 'ball y' 'pipe height' 'pipe x' playing 'previous ball y' score 'ball radius' 'pipe width' gap 'ball acceleration' 

  spec ' ' 'check buttons' 'check buttons'
  spec ' ' 'check collision' 'check collision'
  spec ' ' 'draw ball' 'draw ball'
  spec ' ' 'draw pipes' 'draw pipe'
  spec ' ' 'game over' 'game over'
  spec ' ' 'new game' 'new game'
  spec ' ' 'step ball' 'step ball'
  spec ' ' 'step pipe' 'step pipe'
  spec ' ' 'welcome screen' 'welcome screen'
  spec 'r' 'button pressed' 'button pressed'
  spec ' ' 'write' 'write _ centered at scale _ y _ color _' 'str auto auto color' 'Hello!' 3 '10'

to 'button pressed' {
  return (or (or (buttonA) (buttonB)) (or ('OK button') ('cancel button')))
}

to 'check buttons' {
  if (and playing ('button pressed')) {
    'ball speed' = 0
    'ball y' += ((v 'ball acceleration') * -10)
  }
}

to 'check collision' {
  if (and ((v 'pipe x') <= (v 'pipe width')) (or ((((v 'ball y') / 10) + (v 'ball radius')) >= ((v 'pipe height') + gap)) ((((v 'ball y') / 10) - (v 'ball radius')) <= (v 'pipe height')))) {playing = (booleanConstant false)}
}

to 'draw ball' {
  '[tft:circle]' (v 'ball radius') ((v 'previous ball y') / 10) ((v 'ball radius') + 1) 0 true
  '[tft:circle]' (v 'ball radius') ((v 'ball y') / 10) (v 'ball radius') 65535 true
}

to 'draw pipes' {
  '[tft:rect]' ((v 'pipe x') + (v 'pipe width')) 0 (v 'pipe width') (v 'pipe height') 0 true
  '[tft:rect]' (v 'pipe x') 0 (v 'pipe width') (v 'pipe height') 65280 true
  '[tft:rect]' ((v 'pipe x') + (v 'pipe width')) ((v 'pipe height') + gap) (v 'pipe width') (('[tft:getHeight]') - ((v 'pipe height') + gap)) 0 true
  '[tft:rect]' (v 'pipe x') ((v 'pipe height') + gap) (v 'pipe width') (('[tft:getHeight]') - ((v 'pipe height') + gap)) 65280 true
}

to 'game over' {
  '[display:mbDisplayOff]'
  write 'GAME' (('[tft:getHeight]') / 30) (('[tft:getHeight]') / 15) (colorSwatch 255 255 255 255)
  write 'OVER' (('[tft:getHeight]') / 30) (('[tft:getHeight]') / 3) (colorSwatch 255 255 255 255)
  write ('[data:join]' 'SCORE:' score) (('[tft:getHeight]') / 80) (('[tft:getHeight]') - (('[tft:getHeight]') / 3)) (colorSwatch 255 255 255 255)
}

to 'new game' {
  '[display:mbDisplayOff]'
  score = 0
  comment 'ball y is multiplied by 10 for precision'
  'ball y' = ((('[tft:getHeight]') / 2) * 10)
  playing = (booleanConstant true)
  'ball acceleration' = (('[tft:getHeight]') / 60)
  'ball speed' = (('[tft:getHeight]') / 60)
  'ball radius' = (('[tft:getHeight]') / 15)
  gap = (random ((v 'ball radius') * 4) ((v 'ball radius') * 7))
  'pipe x' = (('[tft:getWidth]') - (('[tft:getWidth]') / 5))
  'pipe height' = (random ((v 'ball radius') * 2) ((v 'ball radius') * 10))
  'pipe width' = ((v 'ball radius') * 2)
}

to 'step ball' {
  'ball speed' += (v 'ball acceleration')
  if ((v 'ball y') < 0) {
    'ball y' = ((v 'ball y') * (v 'ball speed'))
  }
  'previous ball y' = (v 'ball y')
  'ball y' += (v 'ball speed')
  if ((v 'ball y') > (('[tft:getHeight]') * 10)) {
    playing = (booleanConstant false)
  }
  'check buttons'
}

to 'step pipe' {
  'pipe x' += ((score / -10) - (('[tft:getWidth]') / 120))
  if ((v 'pipe x') < (((v 'pipe width') * -1) - 2)) {
    'pipe x' = ('[tft:getWidth]')
    'pipe height' = (random ((v 'ball radius') * 2) ((v 'ball radius') * 10))
    score += 1
  }
}

to 'welcome screen' {
  '[display:mbDisplayOff]'
  write 'JUMPY' (('[tft:getHeight]') / 30) (('[tft:getHeight]') / 15) (colorSwatch 244 36 215 255)
  write 'BALL' (('[tft:getHeight]') / 30) (('[tft:getHeight]') / 3) (colorSwatch 244 36 215 255)
  write 'Press OK or A' (('[tft:getHeight]') / 120) (('[tft:getHeight]') - (('[tft:getHeight]') / 4)) (colorSwatch 255 255 255 255)
  write 'to play' (('[tft:getHeight]') / 120) (('[tft:getHeight]') - (('[tft:getHeight]') / 8)) (colorSwatch 255 255 255 255)
}

to write text scale y color {
  local 'width' (((scale * 6) * (size text)) - scale)
  '[tft:text]' text ((('[tft:getWidth]') - width) / 2) y color scale false
}

script 94 52 {
whenStarted
'welcome screen'
forever {
  waitUntil ('button pressed')
  'new game'
  repeatUntil (not playing) {
    'step ball'
    'draw ball'
    'step pipe'
    'draw pipes'
    'check collision'
    waitMillis 10
  }
  'game over'
  waitUntil (not ('button pressed'))
}
}


module 'ED1 Buttons' Input
author MicroBlocks
version 1 0 
tags button capacitive ed1 
description 'Provides blocks for the six capacitive buttons in the Citilab ED1 board.'
variables _ED1_buttons_init '_capacitive threshold' 

  spec ' ' '_ED1_buttons_init' '_ED1_buttons_init' 'any any any'
  spec 'r' 'OK button' 'button OK'
  spec 'r' 'cancel button' 'button X'
  spec 'r' 'up button' 'button up'
  spec 'r' 'down button' 'button down'
  spec 'r' 'left button' 'button left'
  spec 'r' 'right button' 'button right'
  spec ' ' 'set capacitive threshold to' 'set capacitive threshold to _' 'auto' 16

to 'OK button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 15) < (v '_capacitive threshold'))
}

to '_ED1_buttons_init' {
  if (_ED1_buttons_init == 0) {
    if ((v '_capacitive threshold') == 0) {'_capacitive threshold' = 16}
    _ED1_buttons_init = (booleanConstant true)
  }
}

to 'cancel button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 14) < (v '_capacitive threshold'))
}

to 'down button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 13) < (v '_capacitive threshold'))
}

to 'left button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 2) < (v '_capacitive threshold'))
}

to 'right button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 27) < (v '_capacitive threshold'))
}

to 'set capacitive threshold to' threshold {
  '_capacitive threshold' = threshold
}

to 'up button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 4) < (v '_capacitive threshold'))
}


module TFT Output
author MicroBlocks
version 1 5 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  space
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

module main
author unknown
version 1 0 
description ''
variables eighth quarter whole 

script 50 50 {
whenStarted
comment 'On a micro:bit, attach a piezo speaker between pin 0 and ground'
comment 'This will use the built-in speaker on boards that have one
such as the Circuit Playground Express, ED1, or M5Stack.'
whole = 320
quarter = (whole / 2)
eighth = (whole / 8)
'play tone' 'F' 1 whole
waitMillis quarter
'play tone' 'C' 2 (whole + eighth)
waitMillis (quarter - eighth)
'play tone' 'C' 1 quarter
'play tone' 'D' 1 quarter
'play tone' 'E' 1 quarter
forever {
  repeat 2 {
    'play tone' 'F' 1 whole
    'play tone' 'G#' 1 quarter
    'play tone' 'F' 1 whole
    'play tone' 'G#' 1 quarter
    'play tone' 'G' 1 quarter
    'play tone' 'F' 1 quarter
    'play tone' 'E' 1 quarter
  }
  'play tone' 'F' 1 whole
  repeat 2 {
    'play tone' 'G#' 1 quarter
    'play tone' 'G' 1 (quarter - eighth)
    waitMillis eighth
    'play tone' 'G' 1 quarter
    'play tone' 'G#' 1 quarter
    'play tone' 'A#' 1 (quarter - eighth)
    waitMillis eighth
    'play tone' 'A#' 1 quarter
    'play tone' 'G#' 1 quarter
    'play tone' 'G' 1 whole
    'play tone' 'C' 2 quarter
    'play tone' 'C' 1 whole
  }
  'play tone' 'G#' 1 quarter
  'play tone' 'G' 1 quarter
  'play tone' 'G#' 1 quarter
  'play tone' 'A#' 1 quarter
  repeat 7 {
    'play tone' 'C' 2 (quarter - eighth)
    waitMillis eighth
  }
  'play tone' 'A#' 1 quarter
  'play tone' 'G#' 1 quarter
  'play tone' 'G' 1 quarter
  'play tone' 'G#' 1 quarter
  'play tone' 'G' 1 quarter
}
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''

script 52 50 {
comment 'Start the project, then shake your BBC micro:bit or CPX for some magic glitter!'
}

script 52 124 {
whenCondition (('[sensors:tiltX]') > 50)
'[display:mbPlot]' (random 1 5) (random 1 5)
'[display:mbUnplot]' (random 1 5) (random 1 5)
setNeoPixelColor (random 1 10) (randomColor)
setNeoPixelColor (random 1 10) (colorSwatch 0 0 0 255)
}

script 423 128 {
whenStarted
neoPixelAttach 10 ''
}

script 62 327 {
whenCondition (('[sensors:tiltX]') < 50)
'[display:mbUnplot]' (random 1 5) (random 1 5)
setNeoPixelColor (random 1 10) (colorSwatch 0 0 0 255)
}


module 'Basic Sensors' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor 
choices accelerometerRange '1' '2' '4' '8' 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[sensors:acceleration]' 'acceleration'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (Â°C)'
  spec ' ' '_setAccelRange' 'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to '_setAccelRange' n {
  '[sensors:setAccelerometerRange]' (0 + n)
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}


module NeoPixel Output
author MicroBlocks
version 1 6 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if ((boardType) == 'M5Atom-Matrix') {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'Mbits') {
    neoPixelAttach 25 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'r' ((rgb >> 16) & 255)
    local 'g' ((rgb >> 8) & 255)
    local 'b' (rgb & 255)
    local 'brightness' (maximum r g b)
    if (delta > 0) {
      delta = (minimum delta (255 - brightness))
    } else {
      delta = (maximum delta (42 - brightness))
    }
    r = (maximum 0 (minimum (r + delta) 255))
    g = (maximum 0 (minimum (g + delta) 255))
    b = (maximum 0 (minimum (b + delta) 255))
    atPut i _np_pixels (colorFromRGB r g b)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_update' {
  '[display:neoPixelSend]' _np_pixels
  waitMicros 100
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  hasWhite = false
  if ((pushArgCount) > 2) {
    hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  fillList _np_pixels 0
  '[display:neoPixelSetPin]' pinNumber hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels color
  '_NeoPixel_update'
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' (n > 0)
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}

module main
author unknown
version 1 0 
description ''
variables screen obstacles obsOK prevObs heliX heliY gameOver toggleOn 

  spec ' ' 'clearC5' 'clearC5'
  spec ' ' 'dispScreen' 'dispLEDs'
  spec ' ' 'genObstacle' 'genObstacle'
  spec 'r' 'screenPtr2RC' 'screenPtr2RC _' 'auto' 10
  spec ' ' 'shiftScreen' 'shiftScreen'
  spec ' ' 'toggleHeli' 'toggleHeli'
  spec 'r' 'crashHeli' 'crashHeli _ _' 'auto auto' 2 3
  spec ' ' 'directions' 'directions'
  spec ' ' 'gameOver' 'gameOver'

to clearC5 {
  comment 'Clear col5'
  atPut 5 screen (booleanConstant true)
  atPut 10 screen (booleanConstant false)
  atPut 15 screen (booleanConstant false)
  atPut 20 screen (booleanConstant false)
  atPut 25 screen (booleanConstant false)
}

to crashHeli x y {
  local 'screenPtr' (((y - 1) * 5) + x)
  if (at screenPtr screen) {
    return (booleanConstant true)
  } else {
    return (booleanConstant false)
  }
}

to directions {
  local 'ms' 200
  '[display:mbDisplayOff]'
  repeat 2 {
    '[display:mbDisplay]' 66624
    waitMillis ms
    '[display:mbDisplay]' 0
    waitMillis ms
  }
  '[display:mbDisplay]' 4347332
  waitMillis 1000
  repeat 2 {
    '[display:mbDisplay]' 278784
    waitMillis ms
    '[display:mbDisplay]' 0
    waitMillis ms
  }
  '[display:mbDisplay]' 4674692
  waitMillis 3000
}

to dispScreen {
  for pos (size screen) {
    comment 'In: 1-25
Out: LED on/off'
    local 'r' ((screenPtr2RC pos) / 10)
    local 'c' ((screenPtr2RC pos) % 10)
    if (at pos screen) {
      '[display:mbPlot]' c r
    } else {
      '[display:mbUnplot]' c r
    }
  }
}

to gameOver {
  gameOver = (booleanConstant true)
  toggleOn = (booleanConstant false)
  local 'ms' 100
  repeat 3 {
    '[display:mbDisplay]' 8554664
    waitMillis ms
    '[display:mbDisplay]' 0
    waitMillis ms
  }
  scroll_text 'GAME Over'
  '[display:mbDisplay]' 2269696
}

to genObstacle {
  comment 'Makes 0-3 down obstacles
at col 5 of screen randomly
0    1    2    3
x    x    x    x
.     .     x   x
.     .     .    x
.     x    .    .
x    x    x    .
Transitions of 1->3 and 3->1
are not allowed'
  local 'obsOK' (booleanConstant false)
  repeatUntil obsOK {
    comment 'Gens obs = 0 - 3'
    local 'obs' ((random 1 10) % 4)
    if (and (prevObs == 1) (obs == 3)) {
      comment 'Not allowed'
    } (and (prevObs == 3) (obs == 1)) {
      comment 'Not allowed'
    } else {
      prevObs = obs
      obsOK = (booleanConstant true)
    }
  }
  clearC5
  for i obs {
    atPut (i * 5) screen (booleanConstant true)
  }
  if (obs == 1) {
    atPut 20 screen (booleanConstant true)
    atPut 25 screen (booleanConstant true)
  } (obs == 2) {
    atPut 25 screen (booleanConstant true)
  }
}

to screenPtr2RC screenPtr {
  comment 'In: 1-25

Out: rc'
  local 'c' (screenPtr % 5)
  local 'r' (screenPtr / 5)
  local 'rc' 0
  if (c == 0) {
    c = 5
  } (c > 0) {
    r += 1
  }
  rc = ((r * 10) + c)
  return rc
}

to shiftScreen {
  comment 'Shift left by 1 col'
  for row 5 {
    for col 4 {
      local 'c' (((row - 1) * 5) + col)
      atPut c screen (at (c + 1) screen)
    }
  }
}

to toggleHeli {
  local 'ms' 50
  forever {
    repeatUntil (not toggleOn) {
      '[display:mbPlot]' heliX heliY
      waitMillis ms
      '[display:mbUnplot]' heliX heliY
      if (buttonA) {
        waitMillis ms
        heliY += -1
      } (buttonB) {
        waitMillis ms
        heliY += 1
      }
      if (crashHeli heliX heliY) {
        gameOver
      }
      waitMillis ms
    }
  }
}

script 47 43 {
comment 'Game contributed by Turgut Guneysu
============================

microHELI:

This is the micro version of the popular Helicopter game.
One flies the Heli through a corridor of obstacles hanging
from the ceiling and rising from the ground.

Use buttonA to RAISE the Heli
Use button B to LOWER the Heli

That''s it !

Have Fun.'
}

script 52 312 {
whenStarted
screen = (newList 25)
atPut 'all' screen (booleanConstant false)
prevObs = 0
heliX = 2
heliY = 3
gameOver = (booleanConstant false)
toggleOn = (booleanConstant false)
directions
'[display:mbDisplayOff]'
toggleOn = (booleanConstant true)
repeatUntil gameOver {
  genObstacle
  shiftScreen
  clearC5
  dispScreen
  waitMillis 400
}
}

script 371 312 {
whenStarted
toggleHeli
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''
variables hours minutes seconds server 

  spec ' ' 'draw time' 'draw time'
  spec ' ' 'fetch current time from server' 'fetch current time from server _' 'auto' 'microblocks.fun'
  spec 'r' 'online time' 'online time from server _' 'auto' 'microblocks.fun'
  spec ' ' 'tick' 'tick'
  spec 'r' 'twoDigits' 'twoDigits _' 'auto' 5

to 'draw time' {
  local 'y' (('[tft:getHeight]') / 3)
  local 'x' ((('[tft:getWidth]') - 145) / 2)
  if (x < 0) {
    x = 0
  }
  '[tft:rect]' x y 145 30 (colorSwatch 0 0 0 255)
  if (hours < 10) {
    '[tft:text]' '0' x y (colorSwatch 255 46 18 255) 3 false
    '[tft:text]' hours (x + 20) y (colorSwatch 255 46 18 255) 3 false
  } else {
    '[tft:text]' hours x y (colorSwatch 255 46 18 255) 3 false
  }
  '[tft:text]' ':' (x + 32) y (colorSwatch 255 46 18 255) 3 false
  if (minutes < 10) {
    '[tft:text]' '0' (x + 44) y (colorSwatch 255 46 18 255) 3 false
    '[tft:text]' minutes (x + 64) y (colorSwatch 255 46 18 255) 3 false
  } else {
    '[tft:text]' minutes (x + 44) y (colorSwatch 255 46 18 255) 3 false
  }
  '[tft:text]' ':' (x + 76) y (colorSwatch 255 46 18 255) 3 false
  if (seconds < 10) {
    '[tft:text]' '0' (x + 88) y (colorSwatch 255 46 18 255) 3 false
    '[tft:text]' seconds (x + 108) y (colorSwatch 255 46 18 255) 3 false
  } else {
    '[tft:text]' seconds (x + 88) y (colorSwatch 255 46 18 255) 3 false
  }
}

to 'fetch current time from server' url {
  local 'start ms' (millisOp)
  local 'current time' ('online time' url)
  hours = (('[data:copyFromTo]' (v 'current time') 1 2) + 0)
  minutes = (('[data:copyFromTo]' (v 'current time') 4 5) + 0)
  seconds = (('[data:copyFromTo]' (v 'current time') 7 8) - (((millisOp) - (v 'start ms')) / 1000))
  repeat 5 {
    '[tft:circle]' (('[tft:getWidth]') / 2) (('[tft:getHeight]') / 5) 5 (colorSwatch 255 242 71 255) true
    waitMillis 25
    '[tft:circle]' (('[tft:getWidth]') / 2) (('[tft:getHeight]') / 5) 5 (colorSwatch 0 0 0 255) true
    waitMillis 25
  }
}

to 'online time' server {
  local 'url' ('[data:join]' server '/nonExistentPage')
  local 'response' ('_request_url' url 'GET' '')
  local 'header' ('_http_header_text' response)
  return ('[data:copyFromTo]' header (('[data:find]' 'GMT' header) - 9) (('[data:find]' 'GMT' header) - 2))
}

to tick {
  seconds += 1
  if (seconds == 60) {
    seconds = 0
    minutes += 1
    if (minutes == 60) {
      minutes = 0
      hours += 1
    }
    if (hours == 24) {
      hours = 0
    }
  }
}

to twoDigits n {
  if (n < 10) {return ('[data:join]' '0' n)}
  return ('[data:join]' '' n)
}

script 50 50 {
comment 'This project fetches the current time (GMT) from
the microblocks.fun server. It does so by parsing
the headers of the HTTP response. After that, it
keeps time by itself and requests an update from
the server every minute.

Requires a board with Wifi and a TFT display.

Remember to enter your Wifi network name and
password.'
}

script 564 80 {
whenBroadcastReceived 'time received'
forever {
  sayIt ('[data:join]' hours ':' (twoDigits minutes) ':' (twoDigits seconds))
  'draw time'
  tick
  waitMillis 1000
}
}

script 52 238 {
whenStarted
server = 'microblocks.fun'
'[tft:text]' 'Connecting' 0 (('[tft:getHeight]') / 3) (colorSwatch 46 255 40 255) 2 true
wifiConnect 'Network_Name' ''
'[display:mbDisplayOff]'
'[tft:text]' 'Fetching time' 0 (('[tft:getHeight]') / 5) (colorSwatch 46 255 40 255) 2 true
'[tft:text]' server 0 (('[tft:getHeight]') / 2) (colorSwatch 46 255 40 255) 2 true
'fetch current time from server' server
'[display:mbDisplayOff]'
sendBroadcast 'time received'
}

script 564 260 {
whenButtonPressed 'A'
'fetch current time from server' server
}

script 567 365 {
whenCondition (and ((getIPAddress) != '0.0.0.0') (seconds == 0))
'fetch current time from server' server
waitUntil (seconds != 0)
}


module 'HTTP client' Comm
author MicroBlocks
version 1 4 
depends WiFi 
tags http network get post put delete 
description 'Send HTTP requests and get responses back. You can use this library to fetch or store data in online servers, or to control other Wifi-enabled boards.
'

  spec 'r' '_http_body_start' '_http_body_start _' 'auto' ''
  spec 'r' '_http_header_text' '_http_header_text _' 'auto' ''
  spec 'r' '_http_status_text' '_http_status_text _' 'auto' ''
  spec 'r' '_http_header' '_header _ of response _' 'auto auto' 'content-length' ''
  spec 'r' '_http_status' '_status of response _' 'auto' ''
  spec 'r' '_line_end' '_line_end'
  spec 'r' '_lowercase' '_lowercase _' 'auto' 'ABC Def gH'
  spec 'r' '_request_url' '_request_url _ method _ body _ : port _' 'str menu.requestTypes str num' '' 'GET' '' 80
  spec 'r' '_readHTTPResponse' '_readHTTPResponse'
  spec 'r' 'httpÜ//' 'httpÜ// _  : port _' 'auto num' 'microblocks.fun/example.txt' 80
  spec ' ' 'request' '_ data _ to httpÜ// _  : port _' 'menu.requestTypes str str num' 'POST' 'MicroBlocks is fun' 'microblocks.fun' 80

to '_http_body_start' response {
  return (('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) response) + 4)
}

to '_http_header' header response {
  local 'header text' ('_http_header_text' response)
  header = ('_lowercase' header)
  repeatUntil ((size (v 'header text')) < 3) {
    local 'key' ('[data:copyFromTo]' (v 'header text') 1 (('[data:find]' ':' (v 'header text')) - 1))
    if (('_lowercase' key) == header) {
      return ('[data:copyFromTo]' (v 'header text') (('[data:find]' ':' (v 'header text')) + 2) (('[data:find]' ('_line_end') (v 'header text')) - 1))
    }
    'header text' = ('[data:copyFromTo]' (v 'header text') (('[data:find]' ('_line_end') (v 'header text')) + 2))
  }
  return (booleanConstant false)
}

to '_http_header_text' response {
  local 'headersStart' (('[data:find]' ('_line_end') response) + 2)
  return ('[data:copyFromTo]' response headersStart (('_http_body_start' response) + 2))
}

to '_http_status' response {
  return (('[data:copyFromTo]' ('_http_status_text' response) 1 4) + 0)
}

to '_http_status_text' response {
  return ('[data:copyFromTo]' response ('[data:find]' ' ' response) ('[data:find]' ('_line_end') response))
}

to '_line_end' {
  return ('[data:unicodeString]' ('[data:makeList]' 13 10))
}

to '_lowercase' string {
  local 'lowercased' ''
  local 'char code' ''
  for c (size string) {
    'char code' = ('[data:unicodeAt]' c string)
    if (and ((v 'char code') >= 65) ((v 'char code') <= 90)) {
      'char code' = ((v 'char code') + 32)
    }
    lowercased = ('[data:join]' lowercased ('[data:unicodeString]' (v 'char code')))
  }
  return lowercased
}

to '_readHTTPResponse' {
  local 'response' ''
  local 'lastChunkTime' (millisOp)
  repeatUntil (not ('[net:httpIsConnected]')) {
    local 'chunk' ('[net:httpResponse]')
    if ((size chunk) > 0) {
      response = ('[data:join]' response chunk)
      lastChunkTime = (millisOp)
    } (((millisOp) - lastChunkTime) > 10000) {
      return response
    }
    waitMillis 20
  }
  response = ('[data:join]' response ('[net:httpResponse]'))
  return response
}

to '_request_url' url method body optionalPort {
  local 'port' 80
  if ((pushArgCount) > 3) {
    port = optionalPort
  }
  local 'host' ''
  local 'path' ''
  local 'slashPosition' ('[data:find]' '/' url)
  if (slashPosition > 0) {
    host = ('[data:copyFromTo]' url 1 (slashPosition - 1))
    path = ('[data:copyFromTo]' url (slashPosition + 1))
  } else {
    host = url
  }
  if (('[net:wifiStatus]') != 'Connected') {
    return ('[data:join]' '0 Not Connected' ('_line_end'))
  }
  '[net:httpConnect]' host port
  if (not ('[net:httpIsConnected]')) {
    return ('[data:join]' '0 Could not connect to server' ('_line_end'))
  }
  '[net:httpRequest]' method host path
  return ('_readHTTPResponse')
}

to 'httpÜ//' url optionalPort {
  local 'port' 80
  if ((pushArgCount) > 1) {
    port = optionalPort
  }
  local 'response' ('_request_url' url 'GET' '' port)
  if (response != '') {
    if (('_http_status' response) == 200) {
      return ('[data:copyFromTo]' response ('_http_body_start' response))
    } else {
      return ('_http_status_text' response)
    }
  } else {
    return 'Failed to get response'
  }
}

to request method data url optionalPort {
  local 'port' 80
  if ((pushArgCount) > 3) {
    port = optionalPort
  }
  local 'response' ('_request_url' url method data port)
  if (response != '') {
    local 'status' ('_http_status' response)
    local 'body start' ('_http_body_start' response)
    if (and (200 == status) ((v 'body start') > 0)) {
      sayIt ('[data:copyFromTo]' response (v 'body start'))
    } else {
      sayIt ('_http_status_text' response)
    }
  } else {
    sayIt 'Failed to get response'
  }
}


module TFT Output
author MicroBlocks
version 1 5 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  space
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}


module WiFi Comm
author MicroBlocks
version 1 6 
tags communication network 
description 'Connect to a WiFi network. Used in conjunction with other network libraries, such as HTTP client, HTTP server or Web Thing.
'

  spec ' ' 'wifiConnect' 'wifi connect to _ password _ : IP _ gateway _ subnet _' 'str str auto auto auto' 'Network_Name' '' '192.168.1.42' '192.168.1.1' '255.255.255.0'
  spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
  spec 'r' 'getIPAddress' 'IP address'
  spec 'r' '[net:myMAC]' 'MAC address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to wifiConnect ssid password fixedIP gatewayIP subnetIP {
  if (not ('[net:hasWiFi]')) {return}
  '[net:stopWiFi]'
  if ((pushArgCount) < 5) {
    '[net:startWiFi]' ssid password
  } else {
    '[net:startWiFi]' ssid password false fixedIP gatewayIP subnetIP
  }
  local 'startMSecs' (millisOp)
  repeatUntil (('[net:myIPAddress]') != '0.0.0.0') {
    comment 'Timeout after N seconds'
    if (((millisOp) - startMSecs) > 30000) {
      sayIt 'Could not connect'
      return 0
    }
    comment 'Slow blink while trying to connect'
    setUserLED true
    waitMillis 300
    setUserLED false
    waitMillis 300
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  if ('Connected' != ('[net:wifiStatus]')) {
    sayIt 'Could not create hotspot'
    return 0
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

module main
author unknown
version 1 0 
description ''

script 50 50 {
whenBroadcastReceived 'go!'
'[display:mbDisplayOff]'
local 'bufSize' 128
local 'buf' (newList bufSize)
local 'pin' 25
if ((boardType) == 'Citilab ED1') {
  pin = 26
}
for i bufSize {
  atPut i buf (128 + (random -127 127))
}
repeat 350 {
  for i (bufSize - 1) {
    local 'sample' (((at i buf) + (at (i + 1) buf)) / 2)
    '[tft:setPixel]' i ((at i buf) / 2) (colorSwatch 0 0 0 255)
    atPut i buf sample
    '[tft:setPixel]' i (sample / 2) (colorSwatch 255 255 255 255)
    analogWriteOp pin sample
    waitMicros 50
  }
  atPut bufSize buf (at 1 buf)
}
}

script 360 59 {
whenButtonPressed 'A'
stopAll
sendBroadcast 'go!'
}


module TFT Output
author MicroBlocks
version 1 5 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  space
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

module main
author unknown
version 1 0 
description ''
variables 'ball radius' 'delta x' 'delta y' 'paddle 1 x' 'paddle 2 x' 'paddle width' playing 'refresh rate' speed x y 

  spec ' ' 'bounce ball' 'bounce ball'
  spec ' ' 'bounce on paddle' 'bounce on paddle _' 'auto' 2
  spec ' ' 'clear ball' 'clear ball'
  spec ' ' 'game over' 'player  _ wins' 'auto' 1
  spec ' ' 'new game' 'new game'
  spec ' ' 'plot ball' 'draw ball'
  spec ' ' 'plot paddles' 'draw paddles'

to 'bounce ball' {
  if (or (x >= (128 - ((v 'ball radius') * 2))) (x <= ((v 'ball radius') * 2))) {
    'delta x' = ((v 'delta x') * -1)
    'play tone' 'D' 1 50
  }
  if (y <= 1) {
    'game over' 1
  } (y >= 126) {
    'game over' 2
  } (and (y <= 19) (and (x >= (v 'paddle 2 x')) (x <= ((v 'paddle 2 x') + (v 'paddle width'))))) {
    'bounce on paddle' 2
  } (and (y >= 113) (and (x >= (v 'paddle 1 x')) (x <= ((v 'paddle 1 x') + (v 'paddle width'))))) {
    'bounce on paddle' 1
  }
}

to 'bounce on paddle' n {
  'delta y' = ((v 'delta y') * -1)
  local 'paddle x' 0
  if (n == 1) {
    'paddle x' = (v 'paddle 1 x')
  } else {
    'paddle x' = (v 'paddle 2 x')
  }
  if (and (x >= (v 'paddle x')) (x <= ((v 'paddle x') + 10))) {
    'delta x' = (speed * -2)
    'play tone' 'G#' 1 50
  } (and (x >= ((v 'paddle x') + ((v 'paddle width') - 10))) (x <= ((v 'paddle x') + (v 'paddle width')))) {
    'delta x' = (speed * 2)
    'play tone' 'G#' 1 50
  } ((v 'delta x') > 0) {
    'delta x' = speed
    'play tone' 'D' 1 50
  } else {
    'delta x' = (speed * -1)
    'play tone' 'D' 1 50
  }
  speed += 10
}

to 'clear ball' {
  '[tft:circle]' x y (v 'ball radius') 0 true
}

to 'game over' n {
  playing = (booleanConstant false)
  '[display:mbDisplayOff]'
  '[tft:text]' 'GAME' 18 30 (hexToInt 'FF0000') 4 false
  '[tft:text]' 'OVER' 18 70 (hexToInt 'FF0000') 4 false
  if (n == 1) {
    '[tft:text]' 'v WINNER v' 38 110 (hexToInt '00FF00') 1 false
    '[tft:line]' 40 115 40 105 (hexToInt '00FF00')
    '[tft:line]' 94 115 94 105 (hexToInt '00FF00')
  } else {
    '[tft:text]' '^ WINNER ^' 38 10 (hexToInt '00FF00') 1 false
    '[tft:line]' 40 10 40 20 (hexToInt '00FF00')
    '[tft:line]' 94 10 94 20 (hexToInt '00FF00')
  }
  'play tone' 'E' 2 150
  'play tone' 'D#' 2 150
  'play tone' 'D' 2 150
  'play tone' 'C#' 2 150
  'play tone' 'C' 2 150
  'play tone' 'B' 1 300
  waitMillis 1000
  'new game'
}

to 'new game' {
  speed = 200
  'paddle 1 x' = (random 30 80)
  'paddle 2 x' = (random 30 80)
  x = (random 30 80)
  y = 63
  if ((random 1 2) == 1) {
    'delta x' = speed
  } else {
    'delta x' = (speed * -1)
  }
  if ((random 1 2) == 1) {
    'delta y' = speed
  } else {
    'delta y' = (speed * -1)
  }
  '[display:mbDisplayOff]'
  '[tft:text]' 'PONG' 18 40 (hexToInt 'FFFF00') 4 false
  '[tft:text]' 'Press OK to start' 15 80 (hexToInt 'FFFFFF') 1 false
  waitUntil ('OK button')
  '[display:mbDisplayOff]'
  '[tft:text]' 'GO!' 30 30 (hexToInt 'FFFF00') 5 false
  waitMillis 1000
  '[display:mbDisplayOff]'
  playing = (booleanConstant true)
}

to 'plot ball' {
  '[tft:circle]' x y (v 'ball radius') (hexToInt 'FF0000') true
}

to 'plot paddles' {
  '[tft:rect]' 0 6 128 8 0 true
  '[tft:roundedRect]' (v 'paddle 2 x') 6 (v 'paddle width') 8 4 (hexToInt 'FFFF00') true
  '[tft:rect]' 0 120 128 8 0 true
  '[tft:roundedRect]' (v 'paddle 1 x') 120 (v 'paddle width') 8 4 (hexToInt 'FFFF00') true
}

script 50 55 {
comment 'A rendition to one of the first videogames ever.
This one fits in your pocket!

Player 1 uses keys OK and X.
Player 2 uses â and â.'
}

script 55 163 {
whenStarted
'refresh rate' = 40
'ball radius' = 4
'paddle width' = 40
'new game'
forever {
  if playing {
    'clear ball'
    x += ((v 'delta x') / 100)
    y += ((v 'delta y') / 100)
    'plot ball'
    'bounce ball'
  }
  waitMillis (v 'refresh rate')
}
}

script 380 172 {
whenCondition ('OK button')
if ((v 'paddle 1 x') >= 4) {
  'paddle 1 x' += -2
}
'plot paddles'
}

script 382 369 {
whenCondition ('cancel button')
if ((v 'paddle 1 x') <= (126 - (v 'paddle width'))) {
  'paddle 1 x' += 2
}
'plot paddles'
}

script 388 570 {
whenCondition ('right button')
if ((v 'paddle 2 x') <= (126 - (v 'paddle width'))) {
  'paddle 2 x' += 2
}
'plot paddles'
}

script 60 576 {
whenCondition ('left button')
if ((v 'paddle 2 x') >= 4) {
  'paddle 2 x' += -2
}
'plot paddles'
}


module 'ED1 Buttons' Input
author MicroBlocks
version 1 0 
tags button capacitive ed1 
description 'Provides blocks for the six capacitive buttons in the Citilab ED1 board.'
variables _ED1_buttons_init '_capacitive threshold' 

  spec ' ' '_ED1_buttons_init' '_ED1_buttons_init' 'any any any'
  spec 'r' 'OK button' 'button OK'
  spec 'r' 'cancel button' 'button X'
  spec 'r' 'up button' 'button up'
  spec 'r' 'down button' 'button down'
  spec 'r' 'left button' 'button left'
  spec 'r' 'right button' 'button right'
  spec ' ' 'set capacitive threshold to' 'set capacitive threshold to _' 'auto' 16

to 'OK button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 15) < (v '_capacitive threshold'))
}

to '_ED1_buttons_init' {
  if (_ED1_buttons_init == 0) {
    if ((v '_capacitive threshold') == 0) {'_capacitive threshold' = 16}
    _ED1_buttons_init = (booleanConstant true)
  }
}

to 'cancel button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 14) < (v '_capacitive threshold'))
}

to 'down button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 13) < (v '_capacitive threshold'))
}

to 'left button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 2) < (v '_capacitive threshold'))
}

to 'right button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 27) < (v '_capacitive threshold'))
}

to 'set capacitive threshold to' threshold {
  '_capacitive threshold' = threshold
}

to 'up button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 4) < (v '_capacitive threshold'))
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''

script 50 50 {
whenButtonPressed 'A'
'[display:mbDisplayOff]'
waitMillis 600
local 'which' (random 1 3)
if (which == 1) {
  '[display:mbDisplay]' 473536
}
if (which == 2) {
  '[display:mbDisplay]' 16033071
}
if (which == 3) {
  '[display:mbDisplay]' 18157898
}
}

script 312 52 {
whenButtonPressed 'B'
'[display:mbDisplayOff]'
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''

script 331 52 {
whenButtonPressed 'B'
'[display:mbDisplayOff]'
}

script 70 54 {
whenCondition (('[sensors:acceleration]') > 140)
'[display:mbDisplayOff]'
waitMillis 500
local 'which' (random 1 3)
if (which == 1) {
  '[display:mbDisplay]' 473536
}
if (which == 2) {
  '[display:mbDisplay]' 16033071
}
if (which == 3) {
  '[display:mbDisplay]' 18157898
}
waitMillis 500
}


module 'Basic Sensors' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor 
choices accelerometerRange '1' '2' '4' '8' 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[sensors:acceleration]' 'acceleration'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (Â°C)'
  spec ' ' '_setAccelRange' 'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to '_setAccelRange' n {
  '[sensors:setAccelerometerRange]' (0 + n)
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''
variables _loop_overhead 'current index' sequence 

  spec ' ' 'initialize letters' 'initialize sequence'
  spec 'r' 'correct guess' 'correct guess at _' 'auto' '10'
  spec 'r' 'wrong guess' 'wrong guess at _' 'auto' '10'
  spec ' ' 'play note at' 'play note at _' 'auto' '10'
  spec ' ' 'triangle up' 'draw  _' 'auto' 1

to 'correct guess' index {
  return (or (or (and ('up button') ((at index sequence) == 1)) (and ('down button') ((at index sequence) == 2))) (or (and ('left button') ((at index sequence) == 3)) (and ('right button') ((at index sequence) == 4))))
}

to 'initialize letters' {
  'play tone' 'C' 1 100
  'play tone' 'E' 1 100
  'play tone' 'G' 1 100
  'play tone' 'C' 2 100
  if (sequence == 0) {
    sequence = (newList 20)
  }
  for i (size sequence) {
    atPut i sequence (random 1 4)
  }
}

to 'play note at' index {
  'triangle up' index
  if ((at index sequence) == 1) {
    'play tone' 'E' 1 200
  } ((at index sequence) == 2) {
    'play tone' 'F#' 1 200
  } ((at index sequence) == 3) {
    'play tone' 'D' 1 200
  } else {
    'play tone' 'G' 1 200
  }
}

to 'triangle up' index {
  '[display:mbDisplayOff]'
  if ((at index sequence) == 1) {
    '[tft:triangle]' 0 0 63 63 126 0 (hexToInt '00FF00') true
  } ((at index sequence) == 2) {
    '[tft:triangle]' 0 126 63 63 126 126 (hexToInt 'FF0000') true
  } ((at index sequence) == 3) {
    '[tft:triangle]' 0 0 63 63 0 126 (hexToInt '0000FF') true
  } else {
    '[tft:triangle]' 126 0 63 63 126 126 (hexToInt '00FFFF') true
  }
}

to 'wrong guess' index {
  return (or (or (and ('up button') ((at index sequence) != 1)) (and ('down button') ((at index sequence) != 2))) (or (and ('left button') ((at index sequence) != 3)) (and ('right button') ((at index sequence) != 4))))
}

script 51 50 {
comment 'This is the Simon memory game for the
Citilab ED1 board'
}

script 413 50 {
whenBroadcastReceived 'player turn'
local 'index' 1
repeatUntil (index > (v 'current index')) {
  if ('correct guess' index) {
    'play note at' index
    index += 1
    waitUntil (and (and (not ('up button')) (not ('down button'))) (and (not ('left button')) (not ('right button'))))
  } ('wrong guess' index) {
    '[display:mbDisplayOff]'
    '[tft:text]' 'Sorry' 30 45 (colorSwatch 189 191 3 255) 2 true
    '[tft:text]' 'Try again...' 25 70 (colorSwatch 184 184 184 255) 1 true
    'play tone' 'G' 1 250
    'play tone' 'F#' 1 250
    'play tone' 'F' 1 250
    'play tone' 'E' 1 250
    waitMillis 500
    sendBroadcast 'go!'
    stopTask
  }
}
waitMillis 500
'current index' += 1
sendBroadcast 'play sequence'
}

script 50 100 {
whenStarted
sendBroadcast 'go!'
}

script 202 105 {
whenBroadcastReceived 'go!'
'current index' = 1
'initialize letters'
waitMillis 1500
sendBroadcast 'play sequence'
}

script 51 234 {
whenBroadcastReceived 'play sequence'
if ((v 'current index') > 10) {
  '[display:mbDisplayOff]'
  '[tft:text]' 'You win!!' 15 45 (colorSwatch 189 8 191 255) 2 true
  repeat 2 {
    'play tone' 'C' 2 100
    'play tone' 'E' 1 100
  }
  'play tone' 'C' 1 100
  'play tone' 'G' 1 100
  'play tone' 'C' 2 200
  waitMillis 500
  sendBroadcast 'go!'
} else {
  for i (v 'current index') {
    'play note at' i
  }
  sendBroadcast 'player turn'
}
}


module 'ED1 Buttons' Input
author MicroBlocks
version 1 0 
tags button capacitive ed1 
description 'Provides blocks for the six capacitive buttons in the Citilab ED1 board.'
variables _ED1_buttons_init '_capacitive threshold' 

  spec ' ' '_ED1_buttons_init' '_ED1_buttons_init' 'any any any'
  spec 'r' 'OK button' 'button OK'
  spec 'r' 'cancel button' 'button X'
  spec 'r' 'up button' 'button up'
  spec 'r' 'down button' 'button down'
  spec 'r' 'left button' 'button left'
  spec 'r' 'right button' 'button right'
  spec ' ' 'set capacitive threshold to' 'set capacitive threshold to _' 'auto' 16

to 'OK button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 15) < (v '_capacitive threshold'))
}

to '_ED1_buttons_init' {
  if (_ED1_buttons_init == 0) {
    if ((v '_capacitive threshold') == 0) {'_capacitive threshold' = 16}
    _ED1_buttons_init = (booleanConstant true)
  }
}

to 'cancel button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 14) < (v '_capacitive threshold'))
}

to 'down button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 13) < (v '_capacitive threshold'))
}

to 'left button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 2) < (v '_capacitive threshold'))
}

to 'right button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 27) < (v '_capacitive threshold'))
}

to 'set capacitive threshold to' threshold {
  '_capacitive threshold' = threshold
}

to 'up button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 4) < (v '_capacitive threshold'))
}


module TFT Output
author MicroBlocks
version 1 5 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  space
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author MicroBlocks
version 1 0 
description ''
variables x lastY lastX draw 

  spec ' ' 'output sound sample' 'output sound sample _' 'auto' '10'
  spec ' ' 'displayWave' 'displayWave _' 'auto' '10'
  spec 'r' 'sineScaled' 'sine _ scale _' 'auto auto' 0 '10'
  spec ' ' 'start wave' 'draw wave'

to displayWave n {
  local 'x' (lastX + 2)
  local 'y' ((('[tft:getHeight]') - (5 * n)) - 10)
  '[tft:line]' lastX lastY x y (colorSwatch 255 255 255 255)
  if (x > ('[tft:getWidth]')) {
    draw = (booleanConstant false)
  } else {
    lastX = x
    lastY = y
  }
}

to 'output sound sample' n {
  if draw {
    displayWave n
  } else {
    waitUntil (('[io:dacWrite]' n) != 0)
  }
}

to sineScaled angle scale {
  local 'n' ((scale * ('[misc:sin]' (100 * angle))) >> 14)
  return (scale + n)
}

to 'start wave' {
  '[display:mbDisplayOff]'
  draw = (booleanConstant true)
  lastX = 0
  lastY = (('[tft:getHeight]') - 10)
}

script 50 50 {
whenStarted
comment 'Set the pin for your speaker (25 or 26).'
if ((boardType) == 'Citilab ED1') {
  pin = 26
}
'[io:dacInit]' 25 10000
}

script 50 246 {
comment 'Click the start button, then click on each example
to hear how it sounds. The waveform will shown
on the display. Can work on an ESP32 boards
without displays or speakers if you connect one
of the DAC pins (pin 25 or 26) to a piezo buzzer
or through a 4.7k to 10k resistor to a self-amplified
speaker. The DAC can''t drive a magnetic speaker
directly.'
}

script 60 467 {
comment 'Square Wave'
'start wave'
forever {
  repeat 10 {
    'output sound sample' 0
  }
  repeat 10 {
    'output sound sample' 20
  }
}
}

script 336 473 {
comment 'Triangle Wave'
'start wave'
forever {
  for i 10 {
    'output sound sample' (2 * i)
  }
  for i 10 {
    'output sound sample' (2 * (10 - i))
  }
}
}

script 62 704 {
comment 'Sawtooth Wave'
'start wave'
forever {
  for i 20 {
    'output sound sample' i
  }
}
}

script 335 746 {
comment 'Sine Wave'
'start wave'
forever {
  for i 20 {
    local 'n' (sineScaled (18 * i) 10)
    'output sound sample' n
  }
}
}

script 65 915 {
comment 'Pulse Train'
'start wave'
forever {
  'output sound sample' 20
  repeat 19 {
    'output sound sample' 0
  }
}
}

script 333 966 {
comment 'Noise (Hiss)'
'start wave'
forever {
  'output sound sample' (random 1 20)
}
}


module 'Sound Primitives' Output
author MicroBlocks
version 1 0 
tags tone sound music audio note speaker 
description 'Low level support for tone generation and DAC audio output on selected boards. You are probably looking for the Tone library in the folder above. The tone primitives use the Arduino tone library to provide smoother music output. The DAC primitives are currently supported only on ESP32 boards.'

  spec 'r' '[io:hasTone]' 'has tone support'
  spec ' ' '[io:playTone]' 'play tone pin _ frequency _' 'num num' 0 440
  spec ' ' '[io:dacInit]' 'init DAC pin _ sample rate _' 'num num' 25 11025
  spec 'r' '[io:dacWrite]' 'DAC write _ : starting at _' 'num num' 128 1

module TFT Output
author MicroBlocks
version 1 5 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  space
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

module main
author unknown
version 1 0 
description ''
variables 'changing sparsity' sparsity 

script 406 43 {
comment 'Generates symmetric patterns on the BBC micro:bit 5x5 LED display'
comment 'Use the A and B buttons to control the sparsity of dots in the patterns'
}

script 43 50 {
whenStarted
'changing sparsity' = (booleanConstant false)
sparsity = 4
forever {
  '[display:mbDisplayOff]'
  for x 3 {
    for y 3 {
      if (not (v 'changing sparsity')) {if ((random 1 sparsity) == 1) {
        '[display:mbPlot]' x y
        '[display:mbPlot]' y x
        '[display:mbPlot]' (6 - x) (6 - y)
        '[display:mbPlot]' (6 - y) (6 - x)
        '[display:mbPlot]' (6 - x) y
        '[display:mbPlot]' (6 - y) x
        '[display:mbPlot]' x (6 - y)
        '[display:mbPlot]' y (6 - x)
      }}
    }
  }
  waitMillis 250
}
}

script 407 116 {
whenButtonPressed 'A'
'changing sparsity' = (booleanConstant true)
if (sparsity > 1) {
  sparsity += -1
}
waitUntil (not (buttonA))
scroll_text sparsity
'changing sparsity' = (booleanConstant false)
}

script 407 369 {
whenButtonPressed 'B'
'changing sparsity' = (booleanConstant true)
sparsity += 1
waitUntil (not (buttonB))
scroll_text sparsity
'changing sparsity' = (booleanConstant false)
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author 'JosÃ© GarcÃ­a Yeste'
version 1 0 
description ''

  spec ' ' 'draw color' 'write color info _' 'auto' 0

to 'draw color' color {
  local 'r' ((color >> 16) & 31)
  local 'g' ((color >> 8) & 31)
  local 'b' (color & 31)
  '[tft:rect]' 4 2 52 52 (colorSwatch 255 255 255 255) false
  '[tft:rect]' 5 3 50 50 color true
  '[tft:text]' ('[data:join]' 'R:' r) 64 3 (colorSwatch 249 140 71 255) 2 true
  '[tft:text]' ('[data:join]' 'G:' g) 64 21 (colorSwatch 252 168 127 255) 2 true
  '[tft:text]' ('[data:join]' 'B:' b) 64 40 (colorSwatch 251 168 132 255) 2 true
  color = (color color)
  if (color == '') {
    color = '?'
  }
  '[tft:line]' 4 72 124 72 (colorSwatch 250 154 77 255)
  '[tft:text]' 'Color name' 4 64 (colorSwatch 251 148 91 255) 1 true
  '[tft:text]' color (64 - ((size color) * 6)) 79 (colorSwatch 251 140 69 255)
}

script 50 54 {
whenStarted
forever {
  local 'color' ('TCS34725 rgb')
  local 'luminance' ('[data:join]' '' ('TCS34725 luminance'))
  '[display:mbDisplayOff]'
  'draw color' color
  '[tft:line]' 4 106 124 106 (colorSwatch 240 168 145 255)
  '[tft:text]' 'Luminance ' 4 98 (colorSwatch 251 148 91 255) 1 true
  '[tft:text]' luminance (64 - (6 * (size luminance))) 112 (colorSwatch 251 148 91 255)
  waitMillis 100
}
}


module TCS34725 Input
author 'JosÃ© GarcÃ­a Yeste'
version 1 3 
tags sensor color 
description 'Support for the TCS34725 RGB color sensor.
'
variables '_TCS34725 initalized' 

  spec 'r' 'TCS34725 connected' 'TCS34725 connected'
  spec 'r' 'TCS34725 rgb' 'TCS34725 rgb'
  spec 'r' 'TCS34725 luminance' 'TCS34725 luminance'
  spec 'r' 'color' 'color _ name' 'color'
  spec ' ' '_TCS34725 setup' '_TCS34725 setup'
  spec 'r' '_TCS34725 raw' '_TCS34725 raw'

to 'TCS34725 connected' {
  return ((i2cGet (hexToInt '29') (hexToInt '92')) == (hexToInt '44'))
}

to 'TCS34725 luminance' {
  local 'crgb' ('_TCS34725 raw')
  local 'r' (at 2 crgb)
  local 'g' (at 3 crgb)
  local 'b' (at 4 crgb)
  comment '(-0.32466 * r) + (1.57837 * g) + (-0.73191 * b);'
  return (maximum 0 ((((r * -3246) + (g * 15784)) + (b * -7319)) / 10000))
}

to 'TCS34725 rgb' {
  local 'raw' ('_TCS34725 raw')
  local 'rgb' (newList 3)
  local 'c' (at 1 raw)
  if (c > 0) {
    for i 3 {
      atPut i rgb (((at (i + 1) raw) * 255) / c)
    }
    return (((at 1 rgb) << 16) | (((at 2 rgb) << 8) | (at 3 rgb)))
  } else {
    return 0
  }
}

to '_TCS34725 raw' {
  '_TCS34725 setup'
  comment 'read 8 bytes c,r,g,b'
  local 'crgb' (newList 8)
  if ('TCS34725 connected') {
    '[sensors:i2cWrite]' (hexToInt '29') (hexToInt '94')
    '[sensors:i2cRead]' (hexToInt '29') crgb
    waitMillis 1
    atPut 1 crgb (((at 2 crgb) << 8) | (at 1 crgb))
    atPut 2 crgb (((at 4 crgb) << 8) | (at 3 crgb))
    atPut 3 crgb (((at 6 crgb) << 8) | (at 5 crgb))
    atPut 4 crgb (((at 8 crgb) << 8) | (at 7 crgb))
  }
  return crgb
}

to '_TCS34725 setup' {
  if ((v '_TCS34725 initialized') == 0) {
    comment 'https://github.com/ControlEverythingCommunity/TCS34725/blob/master/C/TCS34725.c
// Select enable register(0x80)
// Power ON, crgbC enable, wait time disable(0x03)'
    i2cSet (hexToInt '29') (hexToInt '80') 3
    comment '// Select ALS time register(0x81)
// Atime = 700 ms(0x00)'
    i2cSet (hexToInt '29') (hexToInt '81') 0
    comment '// Select Wait Time register(0x83)
// WTIME : 0.154ms(0xC0)'
    i2cSet (hexToInt '29') (hexToInt '83') (hexToInt 'C0')
    comment '// Select control register(0x8F)
// AGAIN = 1x(0x00)'
    i2cSet (hexToInt '29') (hexToInt '8F') 0
    waitMillis 200
    '_TCS34725 initialized' = 1
  }
}

to color color {
  local 'r' ((color >> 16) & 255)
  local 'g' ((color >> 8) & 255)
  local 'b' (color & 255)
  if (and (r > (g + 30)) (r > (b + 30))) {
    return 'Red'
  }
  if (and (g > (b + 30)) (g > (r + 30))) {
    return 'Green'
  }
  if (and (b > (r + 30)) (b > (g + 30))) {
    return 'Blue'
  }
  if (and (r > (b + 15)) (g > (b + 15))) {
    return 'Yellow'
  }
  if (and (r > (g + 15)) (b > (g + 15))) {
    return 'Magenta'
  }
  if (and (g > (r + 15)) (b > (r + 15))) {
    return 'Cyan'
  }
  return ''
}


module TFT Output
author MicroBlocks
version 1 5 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  space
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

module main
author unknown
version 1 0 
description ''
variables full half quarter 

script 50 50 {
whenStarted
comment 'On a micro:bit, attach a piezo speaker between pin 0 and ground'
comment 'This will use the built-in speaker on boards that have one
such as the Circuit Playground Express, ED1, or M5Stack.'
full = 360
half = (full / 2)
quarter = (full / 4)
repeat 2 {
  'play tone' 'G' 2 quarter
  'play tone' 'F' 2 quarter
  'play tone' 'G' 2 full
  'play tone' 'C' 2 full
  waitMillis (full + half)
  'play tone' 'G#' 2 quarter
  'play tone' 'G' 2 quarter
  'play tone' 'G#' 2 half
  'play tone' 'G' 2 half
  'play tone' 'F' 2 full
  waitMillis (full + half)
  'play tone' 'G#' 2 quarter
  'play tone' 'G' 2 quarter
  'play tone' 'G#' 2 full
  'play tone' 'C' 2 full
  'play tone' 'D' 2 full
  waitMillis half
  'play tone' 'F' 2 quarter
  'play tone' 'D#' 2 quarter
  'play tone' 'F' 2 half
  'play tone' 'D#' 2 half
  'play tone' 'D' 2 half
  'play tone' 'F' 2 half
  'play tone' 'D#' 2 full
  waitMillis half
}
'play tone' 'D' 2 quarter
'play tone' 'D#' 2 quarter
'play tone' 'F' 2 (full + half)
'play tone' 'D#' 2 quarter
'play tone' 'F' 2 quarter
'play tone' 'G' 2 half
'play tone' 'F' 2 half
'play tone' 'D#' 2 half
'play tone' 'D' 2 half
'play tone' 'C' 2 full
'play tone' 'G#' 2 full
'play tone' 'G' 2 (full * 3)
waitMillis quarter
'play tone' 'G' 2 quarter
'play tone' 'G#' 2 quarter
'play tone' 'G' 2 quarter
'play tone' 'F' 2 quarter
'play tone' 'G' 2 (full * 2)
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''

script 50 50 {
whenStarted
home
'[display:mbDisplayOff]'
'pen down'
repeat 36 {
  repeat 4 {
    move (('[tft:getHeight]') / 3)
    turnBy 90
  }
  turnBy 10
}
}


module TFT Output
author MicroBlocks
version 1 5 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  space
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}


module Turtle Output
author MicroBlocks
version 1 3 
depends TFT 
tags tft graphics draw 
description 'Draw with turtle geometry on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.
'
variables _turtleX _turtleY _turtleHeading _turtlePenIsDown _turtleColor 

  spec ' ' 'home' 'home'
  spec ' ' 'move' 'move _' 'auto' '10'
  spec ' ' 'turnBy' 'turn _ degrees' 'auto' 90
  spec ' ' 'turnFraction' 'turn _ / _ of circle' 'auto auto' 1 4
  spec ' ' 'pen down' 'pen down'
  spec ' ' 'pen up' 'pen up'
  spec ' ' 'set pen color to' 'set pen color to _' 'color'
  spec ' ' 'setPenToRandomColor' 'set pen to random color'
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' 'clearDisplay' 'fill display with _' 'color'
  spec ' ' 'go to x' 'go to x _ y _' 'auto auto' '10' '10'
  spec ' ' 'setHeading' 'point in direction _' 'auto' 0
  spec ' ' '_turtleNotes' '_turtleNotes'

to '_turtleNotes' {
  comment 'Representation:
  _turtleHeading is in hundreths of a degree  (e.g. 4500 means 45 degrees)
  _turtleX and _turtleY are scaled by 16384 (2^14)

The sine function takes an angle in hundreds of a degree and returns a
number scaled by 16384. _turtleX and _turtleY are also scaled by 16384.
Those numbers are shifted right by 14 bits to get pixel locations.'
}

to clearDisplay color {
  '[tft:rect]' 0 0 ('[tft:getWidth]') ('[tft:getHeight]') color true
  comment 'Give the display controller time to finish this operation'
  waitMillis 1
}

to 'go to x' x y {
  local 'startX' (_turtleX >> 14)
  local 'startY' (_turtleY >> 14)
  _turtleX = (((('[tft:getWidth]') / 2) + x) << 14)
  _turtleY = (((('[tft:getHeight]') / 2) - y) << 14)
  local 'endX' (_turtleX >> 14)
  local 'endY' (_turtleY >> 14)
  if _turtlePenIsDown {
    '[tft:line]' startX startY endX endY _turtleColor
  }
}

to home {
  if (0 == _turtlePenIsDown) {
    'set pen color to' (colorSwatch 7 255 1 255)
    '[display:mbDisplayOff]'
    'pen up'
  }
  'go to x' 0 0
  setHeading 0
}

to move n {
  local 'startX' (_turtleX >> 14)
  local 'startY' (_turtleY >> 14)
  comment 'The cosine is just the sine shifted by 90 degrees.'
  _turtleX += (n * ('[misc:sin]' (_turtleHeading + 9000)))
  _turtleY += (n * ('[misc:sin]' _turtleHeading))
  local 'endX' (_turtleX >> 14)
  local 'endY' (_turtleY >> 14)
  if _turtlePenIsDown {
    '[tft:line]' startX startY endX endY _turtleColor
  }
}

to 'pen down' {
  _turtlePenIsDown = (booleanConstant true)
}

to 'pen up' {
  _turtlePenIsDown = (booleanConstant false)
}

to 'set pen color to' color {
  _turtleColor = color
}

to setHeading a {
  _turtleHeading = ((a * 100) % 36000)
}

to setPenToRandomColor {
  local 'c1' (random 150 220)
  local 'c2' (random 0 ((3 * c1) / 4))
  local 'c3' (random 0 ((3 * c1) / 4))
  local 'which' (random 1 3)
  if (1 == which) {
    _turtleColor = ((c1 << 16) | ((c2 << 8) | c3))
  } (2 == which) {
    _turtleColor = ((c2 << 16) | ((c3 << 8) | c1))
  } else {
    _turtleColor = ((c3 << 16) | ((c1 << 8) | c2))
  }
}

to turnBy a {
  _turtleHeading += (a * 100)
  _turtleHeading = (_turtleHeading % 36000)
}

to turnFraction num denom {
  _turtleHeading += ((num * 36000) / denom)
  _turtleHeading = (_turtleHeading % 36000)
}

module main
author unknown
version 1 0 
description ''

script 52 50 {
whenButtonPressed 'A'
repeatUntil (not (buttonA)) {
  '[display:mbPlot]' 1 3
  waitMillis 100
  '[display:mbUnplot]' 1 3
  waitMillis 100
}
}

script 50 258 {
whenButtonPressed 'B'
repeatUntil (not (buttonB)) {
  '[display:mbPlot]' 5 3
  waitMillis 100
  '[display:mbUnplot]' 5 3
  waitMillis 100
}
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 2 0 
description ''
variables 'reaction time' remark 'start time' 

script 152 50 {
whenButtonPressed 'A'
sayIt ''
waitMillis (random 500 2000)
setUserLED true
resetTimer
waitUntil (buttonA)
'reaction time' = (timer)
if ((v 'reaction time') < 150) {
  remark = 'Impressive!'
} ((v 'reaction time') < 200) {
  remark = 'Not bad...'
} ((v 'reaction time') < 350) {
  remark = 'Come on! My grandmother could do better than that.'
} else {
  remark = 'WAY too slow! Are you even awake?'
}
sayIt (v 'reaction time') 'msecs.' remark
waitUntil (not (buttonA))
setUserLED false
}

module main
author unknown
version 1 0 
description ''
variables worm direction apple 

  spec ' ' 'draw worm' 'draw worm'
  spec ' ' 'move worm' 'move worm'
  spec ' ' 'turn left' 'turn left'
  spec ' ' 'turn right' 'turn right'
  spec ' ' 'draw apple' 'draw new apple'
  spec ' ' 'grow worm' 'grow worm'
  spec 'r' 'touching apple' 'touching apple'
  spec ' ' 'new game' 'new game'
  spec 'r' 'worm contains apple' 'worm contains apple'
  spec 'r' 'worm should die' 'worm should die'

to 'draw apple' {
  comment 'needs to make sure apple is in free spot'
  apple = ('[data:makeList]' (random 1 5) (random 1 5))
  if ('worm contains apple') {
    repeatUntil (not ('worm contains apple')) {
      apple = ('[data:makeList]' (random 1 5) (random 1 5))
    }
  }
  '[display:mbPlot]' (at 1 apple) (at 2 apple)
}

to 'draw worm' {
}

to 'grow worm' {
  local 'tail' (at 1 worm)
  local 'new worm' ('[data:makeList]' '')
  for part worm {
    '[data:addLast]' part (v 'new worm')
  }
  'move worm'
  atPut 1 (v 'new worm') tail
  worm = (v 'new worm')
}

to 'move worm' {
  local 'head' (at 'last' worm)
  '[display:mbUnplot]' (at 1 (at 1 worm)) (at 2 (at 1 worm))
  for index ((size worm) - 1) {
    local 'next' 0
    atPut index worm (at (index + 1) worm)
  }
  atPut 'last' worm ('[data:makeList]' ((at 1 head) + (at 1 direction)) ((at 2 head) + (at 2 direction)))
  '[display:mbPlot]' (at 1 (at 'last' worm)) (at 2 (at 'last' worm))
}

to 'new game' {
  '[display:mbDisplayOff]'
  worm = ('[data:makeList]' ('[data:makeList]' 3 3))
  direction = ('[data:makeList]' 1 0)
}

to 'touching apple' {
  local 'head' (at 'last' worm)
  return (and ((at 1 head) == (at 1 apple)) ((at 2 head) == (at 2 apple)))
}

to 'turn left' {
  if ((at 1 direction) == 1) {
    direction = ('[data:makeList]' 0 -1)
  } ((at 2 direction) == -1) {
    direction = ('[data:makeList]' -1 0)
  } ((at 1 direction) == -1) {
    direction = ('[data:makeList]' 0 1)
  } else {
    direction = ('[data:makeList]' 1 0)
  }
}

to 'turn right' {
  if ((at 1 direction) == 1) {
    direction = ('[data:makeList]' 0 1)
  } ((at 2 direction) == 1) {
    direction = ('[data:makeList]' -1 0)
  } ((at 1 direction) == -1) {
    direction = ('[data:makeList]' 0 -1)
  } else {
    direction = ('[data:makeList]' 1 0)
  }
}

to 'worm contains apple' {
  for part worm {
    if (and ((at 1 part) == (at 1 apple)) ((at 2 part) == (at 2 apple))) {return (booleanConstant true)}
  }
  return (booleanConstant false)
}

to 'worm should die' {
  local 'head' (at 'last' worm)
  if (or (or ((at 1 head) > 5) ((at 2 head) > 5)) (or ((at 1 head) < 1) ((at 2 head) < 1))) {
    return (booleanConstant true)
  }
  for index ((size worm) - 1) {
    local 'part' (at index worm)
    if (and ((at 1 part) == (at 1 head)) ((at 2 part) == (at 2 head))) {
      return (booleanConstant true)
    }
  }
  return (booleanConstant false)
}

script 50 50 {
comment 'The classic Snake game, but in a smaller scale!'
}

script 50 107 {
whenStarted
'new game'
forever {
  'draw apple'
  repeatUntil ('touching apple') {
    'move worm'
    waitMillis 500
    if ('worm should die') {
      '[display:mbDisplay]' 18284874
      waitUntil (or (buttonA) (buttonB))
      'new game'
    } ((size worm) == 24) {
      '[display:mbDisplay]' 15237450
      waitUntil (or (buttonA) (buttonB))
      'new game'
    }
  }
  'grow worm'
}
}

script 452 109 {
whenButtonPressed 'A'
'turn left'
}

script 452 213 {
whenButtonPressed 'B'
'turn right'
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''
variables x y 

script 50 50 {
whenStarted
x = 1
y = 1
forever {
  if (and (('[sensors:tiltX]') < -10) (x > 1)) {x += -1}
  if (and (('[sensors:tiltX]') > 10) (x < 5)) {x += 1}
  if (and (('[sensors:tiltY]') < -10) (y > 1)) {y += -1}
  if (and (('[sensors:tiltY]') > 10) (y < 5)) {y += 1}
  '[display:mbDisplayOff]'
  '[display:mbPlot]' x y
  waitMillis 70
}
}


module 'Basic Sensors' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor 
choices accelerometerRange '1' '2' '4' '8' 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[sensors:acceleration]' 'acceleration'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (Â°C)'
  spec ' ' '_setAccelRange' 'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to '_setAccelRange' n {
  '[sensors:setAccelerometerRange]' (0 + n)
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''

script 50 50 {
whenStarted
'[display:mbDisplayOff]'
forever {
  setUserLED true
  waitMillis 200
  setUserLED false
  waitMillis 200
}
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 2 0 
description ''
variables 'player x' 'player y' playing 'stone x' 'stone y' 

script 417 49 {
whenStarted
'player x' = 3
'player y' = 5
forever {
  if playing {
    if (and (buttonA) ((v 'player x') > 1)) {'player x' += -1}
    if (and (buttonB) ((v 'player x') < 5)) {'player x' += 1}
    '[display:mbDisplayOff]'
    '[display:mbPlot]' (v 'stone x') (v 'stone y')
    '[display:mbPlot]' (v 'player x') (v 'player y')
    waitMillis 100
  }
}
}

script 47 65 {
comment 'Game written by David SÃ¡nchez MarÃ­n
============================

Use the two buttons in the micro:bit to
try to avoid the falling stones.

Have fun!'
}

script 50 218 {
whenStarted
playing = (booleanConstant true)
'stone x' = (random 1 5)
'stone y' = 0
forever {
  if playing {
    repeatUntil ((v 'stone y') == 5) {
      'stone y' += 1
      waitMillis 200
    }
    'stone x' = (random 1 5)
    'stone y' = 0
  }
}
}

script 55 586 {
whenCondition (and ((v 'player x') == (v 'stone x')) ((v 'player y') == (v 'stone y')))
playing = (booleanConstant false)
scroll_text 'GAME OVER'
'[display:mbDisplayOff]'
waitMillis 1000
playing = (booleanConstant true)
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''

script 50 50 {
whenButtonPressed 'A'
'[display:mbDisplay]' 15237450
waitMillis 1000
'[display:mbDisplayOff]'
}

script 50 262 {
whenButtonPressed 'B'
'[display:mbDisplay]' 18284874
waitMillis 1000
'[display:mbDisplayOff]'
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''

script 50 50 {
whenButtonPressed 'A'
repeatUntil (not (buttonA)) {
  '[display:mbDisplay]' 145728
  waitMillis 250
  '[display:mbDisplay]' 4685802
  waitMillis 250
  '[display:mbDisplayOff]'
  waitMillis 300
}
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''

script 52 50 {
comment 'Start the project, then shake your BBC micro:bit or CPX for some magic glitter!'
}

script 52 124 {
whenCondition (('[sensors:tiltX]') > 50)
'[display:mbPlot]' (random 1 5) (random 1 5)
'[display:mbUnplot]' (random 1 5) (random 1 5)
setNeoPixelColor (random 1 10) (randomColor)
setNeoPixelColor (random 1 10) (colorSwatch 0 0 0 255)
}

script 423 128 {
whenStarted
neoPixelAttach 10 ''
}

script 62 327 {
whenCondition (('[sensors:tiltX]') < 50)
'[display:mbUnplot]' (random 1 5) (random 1 5)
setNeoPixelColor (random 1 10) (colorSwatch 0 0 0 255)
}


module 'Basic Sensors' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor 
choices accelerometerRange '1' '2' '4' '8' 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[sensors:acceleration]' 'acceleration'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (Â°C)'
  spec ' ' '_setAccelRange' 'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to '_setAccelRange' n {
  '[sensors:setAccelerometerRange]' (0 + n)
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}


module NeoPixel Output
author MicroBlocks
version 1 6 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if ((boardType) == 'M5Atom-Matrix') {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'Mbits') {
    neoPixelAttach 25 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'r' ((rgb >> 16) & 255)
    local 'g' ((rgb >> 8) & 255)
    local 'b' (rgb & 255)
    local 'brightness' (maximum r g b)
    if (delta > 0) {
      delta = (minimum delta (255 - brightness))
    } else {
      delta = (maximum delta (42 - brightness))
    }
    r = (maximum 0 (minimum (r + delta) 255))
    g = (maximum 0 (minimum (g + delta) 255))
    b = (maximum 0 (minimum (b + delta) 255))
    atPut i _np_pixels (colorFromRGB r g b)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_update' {
  '[display:neoPixelSend]' _np_pixels
  waitMicros 100
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  hasWhite = false
  if ((pushArgCount) > 2) {
    hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  fillList _np_pixels 0
  '[display:neoPixelSetPin]' pinNumber hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels color
  '_NeoPixel_update'
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' (n > 0)
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}

module main
author unknown
version 1 0 
description ''
variables screen obstacles obsOK prevObs heliX heliY gameOver toggleOn 

  spec ' ' 'clearC5' 'clearC5'
  spec ' ' 'dispScreen' 'dispLEDs'
  spec ' ' 'genObstacle' 'genObstacle'
  spec 'r' 'screenPtr2RC' 'screenPtr2RC _' 'auto' 10
  spec ' ' 'shiftScreen' 'shiftScreen'
  spec ' ' 'toggleHeli' 'toggleHeli'
  spec 'r' 'crashHeli' 'crashHeli _ _' 'auto auto' 2 3
  spec ' ' 'directions' 'directions'
  spec ' ' 'gameOver' 'gameOver'

to clearC5 {
  comment 'Clear col5'
  atPut 5 screen (booleanConstant true)
  atPut 10 screen (booleanConstant false)
  atPut 15 screen (booleanConstant false)
  atPut 20 screen (booleanConstant false)
  atPut 25 screen (booleanConstant false)
}

to crashHeli x y {
  local 'screenPtr' (((y - 1) * 5) + x)
  if (at screenPtr screen) {
    return (booleanConstant true)
  } else {
    return (booleanConstant false)
  }
}

to directions {
  local 'ms' 200
  '[display:mbDisplayOff]'
  repeat 2 {
    '[display:mbDisplay]' 66624
    waitMillis ms
    '[display:mbDisplay]' 0
    waitMillis ms
  }
  '[display:mbDisplay]' 4347332
  waitMillis 1000
  repeat 2 {
    '[display:mbDisplay]' 278784
    waitMillis ms
    '[display:mbDisplay]' 0
    waitMillis ms
  }
  '[display:mbDisplay]' 4674692
  waitMillis 3000
}

to dispScreen {
  for pos (size screen) {
    comment 'In: 1-25
Out: LED on/off'
    local 'r' ((screenPtr2RC pos) / 10)
    local 'c' ((screenPtr2RC pos) % 10)
    if (at pos screen) {
      '[display:mbPlot]' c r
    } else {
      '[display:mbUnplot]' c r
    }
  }
}

to gameOver {
  gameOver = (booleanConstant true)
  toggleOn = (booleanConstant false)
  local 'ms' 100
  repeat 3 {
    '[display:mbDisplay]' 8554664
    waitMillis ms
    '[display:mbDisplay]' 0
    waitMillis ms
  }
  scroll_text 'GAME Over'
  '[display:mbDisplay]' 2269696
}

to genObstacle {
  comment 'Makes 0-3 down obstacles
at col 5 of screen randomly
0    1    2    3
x    x    x    x
.     .     x   x
.     .     .    x
.     x    .    .
x    x    x    .
Transitions of 1->3 and 3->1
are not allowed'
  local 'obsOK' (booleanConstant false)
  repeatUntil obsOK {
    comment 'Gens obs = 0 - 3'
    local 'obs' ((random 1 10) % 4)
    if (and (prevObs == 1) (obs == 3)) {
      comment 'Not allowed'
    } (and (prevObs == 3) (obs == 1)) {
      comment 'Not allowed'
    } else {
      prevObs = obs
      obsOK = (booleanConstant true)
    }
  }
  clearC5
  for i obs {
    atPut (i * 5) screen (booleanConstant true)
  }
  if (obs == 1) {
    atPut 20 screen (booleanConstant true)
    atPut 25 screen (booleanConstant true)
  } (obs == 2) {
    atPut 25 screen (booleanConstant true)
  }
}

to screenPtr2RC screenPtr {
  comment 'In: 1-25

Out: rc'
  local 'c' (screenPtr % 5)
  local 'r' (screenPtr / 5)
  local 'rc' 0
  if (c == 0) {
    c = 5
  } (c > 0) {
    r += 1
  }
  rc = ((r * 10) + c)
  return rc
}

to shiftScreen {
  comment 'Shift left by 1 col'
  for row 5 {
    for col 4 {
      local 'c' (((row - 1) * 5) + col)
      atPut c screen (at (c + 1) screen)
    }
  }
}

to toggleHeli {
  local 'ms' 50
  forever {
    repeatUntil (not toggleOn) {
      '[display:mbPlot]' heliX heliY
      waitMillis ms
      '[display:mbUnplot]' heliX heliY
      if (buttonA) {
        waitMillis ms
        heliY += -1
      } (buttonB) {
        waitMillis ms
        heliY += 1
      }
      if (crashHeli heliX heliY) {
        gameOver
      }
      waitMillis ms
    }
  }
}

script 47 43 {
comment 'Game contributed by Turgut Guneysu
============================

microHELI:

This is the micro version of the popular Helicopter game.
One flies the Heli through a corridor of obstacles hanging
from the ceiling and rising from the ground.

Use buttonA to RAISE the Heli
Use button B to LOWER the Heli

That''s it !

Have Fun.'
}

script 52 312 {
whenStarted
screen = (newList 25)
atPut 'all' screen (booleanConstant false)
prevObs = 0
heliX = 2
heliY = 3
gameOver = (booleanConstant false)
toggleOn = (booleanConstant false)
directions
'[display:mbDisplayOff]'
toggleOn = (booleanConstant true)
repeatUntil gameOver {
  genObstacle
  shiftScreen
  clearC5
  dispScreen
  waitMillis 400
}
}

script 371 312 {
whenStarted
toggleHeli
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''
variables 'delta x' 'delta y' 'paddle x' playing 'refresh rate' score x y 

  spec ' ' 'bounce on x' 'bounce on x'
  spec ' ' 'bounce ball' 'bounce ball'
  spec ' ' 'bounce on y' 'bounce on y'
  spec ' ' 'game over' 'game over'
  spec ' ' 'new game' 'new game'
  spec ' ' 'plot ball' 'plot ball'
  spec ' ' 'plot paddles' 'plot paddle'
  spec ' ' 'should bounce on paddle' 'random bounce'
  spec ' ' 'speed up' 'speed up'

to 'bounce ball' {
  if (or (x == 5) (x == 1)) {'bounce on x'}
  if (y == 1) {
    'bounce on y'
    'speed up'
  }
  if (and (y == 5) (x == (v 'paddle x'))) {
    'bounce on y'
    'should bounce on paddle'
    score += 1
  } (y == 5) {
    'game over'
  }
  x += (v 'delta x')
  y += (v 'delta y')
}

to 'bounce on x' {
  'delta x' = ((v 'delta x') * -1)
}

to 'bounce on y' {
  'delta y' = ((v 'delta y') * -1)
}

to 'game over' {
  playing = (booleanConstant false)
  scroll_text 'GAME OVER' 75
  scroll_text 'Score:' 75
  scroll_text score
  waitMillis 150
  'new game'
}

to 'new game' {
  score = 0
  'paddle x' = 3
  'refresh rate' = 500
  x = (random 2 4)
  y = 2
  'delta y' = 1
  if ((random 1 2) == 1) {
    'delta x' = 1
  } else {
    'delta x' = -1
  }
  scroll_text 'Go!' 100
  '[display:mbDisplayOff]'
  playing = (booleanConstant true)
}

to 'plot ball' {
  '[display:mbPlot]' x y
}

to 'plot paddles' {
  '[display:mbPlot]' (v 'paddle x') 5
}

to 'should bounce on paddle' {
  if (and (and (x > 1) (x < 5)) ((random 1 2) == 1)) {'bounce on x'}
  x = (random 2 4)
}

to 'speed up' {
  if ((v 'refresh rate') > 200) {'refresh rate' += -15}
}

script 47 43 {
comment 'A rendition to one of the first videogames ever.
It may have worse resolution than the original,
but this one fits in your pocket!'
}

script 315 131 {
whenCondition (buttonA)
if ((v 'paddle x') > 1) {
  'paddle x' += -1
}
waitUntil (not (buttonA))
}

script 52 146 {
whenStarted
'new game'
forever {
  if playing {
    '[display:mbDisplayOff]'
    'plot paddles'
    'plot ball'
    'bounce ball'
  }
  waitMillis (v 'refresh rate')
}
}

script 317 324 {
whenCondition (buttonB)
if ((v 'paddle x') < 5) {
  'paddle x' += 1
}
waitUntil (not (buttonB))
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''
variables msg2send letter alphabet 'sending-flag' 

  spec ' ' 'blink' 'blink'
  spec ' ' 'letters' 'letters'
  spec ' ' 'flash' 'flash'

to blink {
  setUserLED true
  waitMillis 500
  setUserLED false
  waitMillis 500
}

to flash {
  repeat 3 {
    '[display:mbDisplay]' 33554431
    waitMillis 500
    '[display:mbDisplayOff]'
    waitMillis 500
  }
}

to letters {
  alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ.!?:()&#+-*/=0123456789'
}

script 855 89 {
to flash {}
}

script 488 95 {
whenStarted
comment 'set to same 
number as the
person(s) you 
want to share
messages with'
'[radio:setGroup]' 0
}

script 226 99 {
whenCondition ('[radio:messageReceived]')
'[display:mbDisplayOff]'
comment 'blink = msg received
tilt face down a little to
display it on LEDs'
repeatUntil (('[sensors:tiltZ]') < -20) {
  blink
}
flash
scroll_text ('[radio:receivedString]')
}

script 689 99 {
to blink {}
}

script 78 104 {
whenStarted
msg2send = ''
letter = 1
letters
'[display:mbDisplay]' 4291652
}

script 472 273 {
whenCondition ('button pressed' 'B')
comment 'Add selected letter to message '
if (not sending-flag) {
  msg2send = ('[data:join]' msg2send (at letter alphabet))
  displayCharacter '+'
  waitMillis 500
  displayCharacter (at letter alphabet)
}
}

script 82 330 {
whenButtonPressed 'A'
comment 'Keep pushing until desired letter shown'
displayCharacter (at letter alphabet)
repeatUntil (not (buttonA)) {
  comment 'tilt left (-x) for backward selection'
  if (('[sensors:tiltX]') < 0) {
    comment 'tilt more to scroll letters faster'
    waitMillis (500 - ((absoluteValue ('[sensors:tiltX]')) * 5))
    letter += -1
  } else {
    comment 'tilt right (+x) for forward selection'
    waitMillis (500 - ((absoluteValue ('[sensors:tiltX]')) * 5))
    letter += 1
  }
  if (letter < 1) {
    letter = (size alphabet)
  } (letter > (size alphabet)) {
    letter = 1
  }
  displayCharacter (at letter alphabet)
}
}

script 477 548 {
whenCondition ('button double pressed' 'B')
comment 'Add a space'
msg2send = ('[data:join]' msg2send ' ')
displayCharacter '_'
waitMillis 500
displayCharacter (at letter alphabet)
}

script 478 761 {
whenCondition ('button long pressed' 'B')
'[display:mbDisplayOff]'
comment 'Preview message'
scroll_text msg2send
waitMillis 500
displayCharacter (at letter alphabet)
}

script 572 966 {
whenCondition (('[sensors:acceleration]') > 280)
comment 'Shake hard to clear 
message to send'
msg2send = ''
'[display:mbDisplay]' 4291652
}

script 82 977 {
to letters {}
}

script 280 1077 {
whenButtonPressed 'A+B'
sending-flag = (booleanConstant true)
'[display:mbDisplayOff]'
comment 'Send message'
'[radio:sendString]' msg2send
scroll_text msg2send
sending-flag = (booleanConstant false)
waitMillis 500
'[display:mbDisplay]' 2269696
}


module 'Basic Sensors' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor 
choices accelerometerRange '1' '2' '4' '8' 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[sensors:acceleration]' 'acceleration'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (Â°C)'
  spec ' ' '_setAccelRange' 'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to '_setAccelRange' n {
  '[sensors:setAccelerometerRange]' (0 + n)
}


module 'Button Events' Input
author MicroBlocks
version 1 0 
tags event button double long press 
description 'Provides blocks to detect press, long press and double press events on buttons.'
variables _buttons 

  spec 'r' 'button double pressed' 'button _ double pressed' 'auto' 'A'
  spec 'r' 'button long pressed' 'button _ long pressed' 'auto' 5
  spec 'r' 'button pressed' 'button _ pressed' 'auto' 5
  spec 'r' '_button' '_button _' 'auto' 10
  spec ' ' '_updateButtons' '_updateButtons'
  spec 'r' '_read button' '_read button _' 'auto' 10

to '_button' 'pin or name' {
  '_updateButtons'
  for 'each button' _buttons {
    if ((at 1 (v 'each button')) == (v 'pin or name')) {return (v 'each button')}
  }
  comment 'This button has not been initialized. Let''s add it.'
  local 'new button' ('[data:makeList]' (v 'pin or name') '' '' 'waiting')
  '[data:addLast]' (v 'new button') _buttons
  return (v 'new button')
}

to '_read button' 'pin or name' {
  if ((v 'pin or name') == 'A') {
    return (buttonA)
  } ((v 'pin or name') == 'B') {
    return (buttonB)
  } else {
    return (digitalReadOp (v 'pin or name'))
  }
}

to '_updateButtons' {
  if (_buttons == 0) {_buttons = ('[data:makeList]')}
  for button _buttons {
    local 'currently pressed' ('_read button' (at 1 button))
    local 'previous state' (at 4 button)
    if (and ((v 'previous state') == 'waiting') (v 'currently pressed')) {
      comment 'save state change time'
      atPut 2 button (millisOp)
      atPut 3 button (v 'currently pressed')
      atPut 4 button 'pressed'
    } (and ((v 'previous state') == 'pressed') (not (v 'currently pressed'))) {
      local 'press time' ((millisOp) - (at 2 button))
      comment 'There''s been a press. Let''s check how long it was.'
      if ((v 'press time') > 500) {
        atPut 4 button 'long press'
      } ((v 'press time') > 250) {
        atPut 4 button 'single press'
      } else {
        comment 'This is an internal intermediate state.
It could turn out to be a single press or a double press.'
        atPut 2 button (millisOp)
        atPut 4 button 'short press'
      }
    } (and ((v 'previous state') == 'short press') (v 'currently pressed')) {
      atPut 4 button 'double press'
    } (and (and ((v 'previous state') == 'short press') (not (v 'currently pressed'))) (((millisOp) - (at 2 button)) > 250)) {
      atPut 4 button 'single press'
    } (and ((v 'previous state') == 'double press handled') (not (v 'currently pressed'))) {
      comment 'We only go back to "waiting" after a double press if the event has been handled
and the user has released the button. Otherwise we''ll cause false "single press"
positives.'
      atPut 4 button 'waiting'
    }
  }
}

to 'button double pressed' 'pin or name' {
  local 'button' ('_button' (v 'pin or name'))
  local 'state' (at 4 button)
  if (state == 'double press') {
    comment 'We only go back to "waiting" after a double press if the event has been handled
and the user has released the button. Otherwise we''ll cause false "single press"
positives.'
    atPut 4 button 'double press handled'
    return (booleanConstant true)
  }
  return (booleanConstant false)
}

to 'button long pressed' 'pin or name' {
  local 'button' ('_button' (v 'pin or name'))
  local 'state' (at 4 button)
  if (state == 'long press') {
    atPut 4 button 'waiting'
    return (booleanConstant true)
  }
  return (booleanConstant false)
}

to 'button pressed' 'pin or name' {
  local 'button' ('_button' (v 'pin or name'))
  local 'state' (at 4 button)
  if (state == 'single press') {
    atPut 4 button 'waiting'
    return (booleanConstant true)
  }
  return (booleanConstant false)
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}


module Radio Comm
author MicroBlocks
version 1 2 
tags radio communication messaging network 
description 'Send and receive messages between micro:bit boards via their built-in radio system.'

  spec ' ' '[radio:sendInteger]' 'radio send number _' 'num' 123
  spec ' ' '[radio:sendString]' 'radio send string _' 'str' 'Hello!'
  spec ' ' '[radio:sendPair]' 'radio send pair _ = _' 'str num' 'light' 10
  spec 'r' '[radio:messageReceived]' 'radio message received?'
  spec 'r' '[radio:receivedInteger]' 'radio last number'
  spec 'r' '[radio:receivedString]' 'radio last string'
  spec ' ' '[radio:setGroup]' 'radio set group _ (0-255)' 'num' 0
  spec ' ' '[radio:setPower]' 'radio set power (0-7) _' 'num' 4
  spec 'r' '_signalStrength' '_radio last signal strength'
  spec 'r' '_radioLastSenderID' '_radio last sender ID'
  spec 'r' '_radioMyID' '_radio my ID'
  spec 'r' '_receivedMessageType' '_radio last message type'
  spec ' ' '_setChannel' '_radio set channel (0-83) _' 'num' 7

to '_radioLastSenderID' {
  return ('[radio:lastMessageID]')
}

to '_radioMyID' {
  return ('[radio:deviceID]')
}

to '_receivedMessageType' {
  return ('[radio:receivedMessageType]')
}

to '_setChannel' channel {
  '[radio:setChannel]' channel
}

to '_signalStrength' {
  return ('[radio:signalStrength]')
}

module main
author unknown
version 1 0 
description ''

script 50 50 {
whenButtonPressed 'A'
'[display:mbDisplayOff]'
waitMillis 600
local 'which' (random 1 3)
if (which == 1) {
  '[display:mbDisplay]' 473536
}
if (which == 2) {
  '[display:mbDisplay]' 16033071
}
if (which == 3) {
  '[display:mbDisplay]' 18157898
}
}

script 312 52 {
whenButtonPressed 'B'
'[display:mbDisplayOff]'
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''

script 331 52 {
whenButtonPressed 'B'
'[display:mbDisplayOff]'
}

script 70 54 {
whenCondition (('[sensors:acceleration]') > 140)
'[display:mbDisplayOff]'
waitMillis 500
local 'which' (random 1 3)
if (which == 1) {
  '[display:mbDisplay]' 473536
}
if (which == 2) {
  '[display:mbDisplay]' 16033071
}
if (which == 3) {
  '[display:mbDisplay]' 18157898
}
waitMillis 500
}


module 'Basic Sensors' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor 
choices accelerometerRange '1' '2' '4' '8' 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[sensors:acceleration]' 'acceleration'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (Â°C)'
  spec ' ' '_setAccelRange' 'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to '_setAccelRange' n {
  '[sensors:setAccelerometerRange]' (0 + n)
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 1 
description ''
variables 'current index' letters 

  spec ' ' 'initialize letters' 'initialize letters'
  spec 'r' 'correct guess' 'correct guess at _' 'auto' '10'
  spec 'r' 'wrong guess' 'wrong guess at _' 'auto' '10'
  spec ' ' 'map-to-display' 'map-to-display _' 'auto' '10'

to 'correct guess' index {
  return (or (and (buttonA) ((at index letters) == 'A')) (and (buttonB) ((at index letters) == 'B')))
}

to 'initialize letters' {
  if (letters == 0) {letters = (newList 20)}
  for i (size letters) {
    if ((random 1 2) == 1) {
      atPut i letters 'A'
    } else {
      atPut i letters 'B'
    }
  }
}

to 'map-to-display' letter {
  if (letter == 'A') {
    '[display:mbDisplay]' 7576807
    'play tone' 'D' 2 200
  } else {
    '[display:mbDisplay]' 30307228
    'play tone' 'G' 2 200
  }
}

to 'wrong guess' index {
  return (or (and (buttonA) ((at index letters) == 'B')) (and (buttonB) ((at index letters) == 'A')))
}

script 456 50 {
whenBroadcastReceived 'play'
local 'index' 1
repeatUntil (index > (v 'current index')) {
  if ('correct guess' index) {
    'map-to-display' (at index letters)
    index += 1
    waitUntil (and (not (buttonA)) (not (buttonB)))
    '[display:mbDisplayOff]'
  } ('wrong guess' index) {
    repeat 10 {
      '[display:mbDisplay]' 18157905
      waitMillis 50
      '[display:mbDisplayOff]'
      waitMillis 50
    }
    scroll_text 'FAIL' 100
    sendBroadcast 'go!'
  }
}
waitMillis 500
'current index' += 1
sendBroadcast 'draw sequence'
}

script 50 57 {
comment 'This is the "Simon" memory game for the
BBC micro:bit.'
}

script 53 106 {
whenStarted
sendBroadcast 'go!'
}

script 194 111 {
whenBroadcastReceived 'go!'
'initialize letters'
'current index' = 1
scroll_text 'GO!' 100
sendBroadcast 'draw sequence'
}

script 53 234 {
whenBroadcastReceived 'draw sequence'
if ((v 'current index') > 10) {
  '[display:mbDisplay]' 15237440
  waitMillis 1000
  '[display:mbDisplayOff]'
  scroll_text 'WIN!' 100
  sendBroadcast 'go!'
} else {
  for i (v 'current index') {
    'map-to-display' (at i letters)
    '[display:mbDisplayOff]'
    waitMillis 200
  }
  sendBroadcast 'play'
}
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''
variables 'changing sparsity' sparsity 

script 406 43 {
comment 'Generates symmetric patterns on the BBC micro:bit 5x5 LED display'
comment 'Use the A and B buttons to control the sparsity of dots in the patterns'
}

script 43 50 {
whenStarted
'changing sparsity' = (booleanConstant false)
sparsity = 4
forever {
  '[display:mbDisplayOff]'
  for x 3 {
    for y 3 {
      if (not (v 'changing sparsity')) {if ((random 1 sparsity) == 1) {
        '[display:mbPlot]' x y
        '[display:mbPlot]' y x
        '[display:mbPlot]' (6 - x) (6 - y)
        '[display:mbPlot]' (6 - y) (6 - x)
        '[display:mbPlot]' (6 - x) y
        '[display:mbPlot]' (6 - y) x
        '[display:mbPlot]' x (6 - y)
        '[display:mbPlot]' y (6 - x)
      }}
    }
  }
  waitMillis 250
}
}

script 407 116 {
whenButtonPressed 'A'
'changing sparsity' = (booleanConstant true)
if (sparsity > 1) {
  sparsity += -1
}
waitUntil (not (buttonA))
scroll_text sparsity
'changing sparsity' = (booleanConstant false)
}

script 407 369 {
whenButtonPressed 'B'
'changing sparsity' = (booleanConstant true)
sparsity += 1
waitUntil (not (buttonB))
scroll_text sparsity
'changing sparsity' = (booleanConstant false)
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''

script 52 50 {
whenButtonPressed 'A'
repeatUntil (not (buttonA)) {
  '[display:mbPlot]' 1 3
  waitMillis 100
  '[display:mbUnplot]' 1 3
  waitMillis 100
}
}

script 50 258 {
whenButtonPressed 'B'
repeatUntil (not (buttonB)) {
  '[display:mbPlot]' 5 3
  waitMillis 100
  '[display:mbUnplot]' 5 3
  waitMillis 100
}
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 2 0 
description ''
variables 'reaction time' remark 'start time' 

script 152 50 {
whenButtonPressed 'A'
sayIt ''
waitMillis (random 500 2000)
setUserLED true
resetTimer
waitUntil (buttonA)
'reaction time' = (timer)
if ((v 'reaction time') < 150) {
  remark = 'Impressive!'
} ((v 'reaction time') < 200) {
  remark = 'Not bad...'
} ((v 'reaction time') < 350) {
  remark = 'Come on! My grandmother could do better than that.'
} else {
  remark = 'WAY too slow! Are you even awake?'
}
sayIt (v 'reaction time') 'msecs.' remark
waitUntil (not (buttonA))
setUserLED false
}

module main
author unknown
version 1 0 
description ''
variables worm direction apple 

  spec ' ' 'draw worm' 'draw worm'
  spec ' ' 'move worm' 'move worm'
  spec ' ' 'turn left' 'turn left'
  spec ' ' 'turn right' 'turn right'
  spec ' ' 'draw apple' 'draw new apple'
  spec ' ' 'grow worm' 'grow worm'
  spec 'r' 'touching apple' 'touching apple'
  spec ' ' 'new game' 'new game'
  spec 'r' 'worm contains apple' 'worm contains apple'
  spec 'r' 'worm should die' 'worm should die'

to 'draw apple' {
  comment 'needs to make sure apple is in free spot'
  apple = ('[data:makeList]' (random 1 5) (random 1 5))
  if ('worm contains apple') {
    repeatUntil (not ('worm contains apple')) {
      apple = ('[data:makeList]' (random 1 5) (random 1 5))
    }
  }
  '[display:mbPlot]' (at 1 apple) (at 2 apple)
}

to 'draw worm' {
}

to 'grow worm' {
  local 'tail' (at 1 worm)
  local 'new worm' ('[data:makeList]' '')
  for part worm {
    '[data:addLast]' part (v 'new worm')
  }
  'move worm'
  atPut 1 (v 'new worm') tail
  worm = (v 'new worm')
}

to 'move worm' {
  local 'head' (at 'last' worm)
  '[display:mbUnplot]' (at 1 (at 1 worm)) (at 2 (at 1 worm))
  for index ((size worm) - 1) {
    local 'next' 0
    atPut index worm (at (index + 1) worm)
  }
  atPut 'last' worm ('[data:makeList]' ((at 1 head) + (at 1 direction)) ((at 2 head) + (at 2 direction)))
  '[display:mbPlot]' (at 1 (at 'last' worm)) (at 2 (at 'last' worm))
}

to 'new game' {
  '[display:mbDisplayOff]'
  worm = ('[data:makeList]' ('[data:makeList]' 3 3))
  direction = ('[data:makeList]' 1 0)
}

to 'touching apple' {
  local 'head' (at 'last' worm)
  return (and ((at 1 head) == (at 1 apple)) ((at 2 head) == (at 2 apple)))
}

to 'turn left' {
  if ((at 1 direction) == 1) {
    direction = ('[data:makeList]' 0 -1)
  } ((at 2 direction) == -1) {
    direction = ('[data:makeList]' -1 0)
  } ((at 1 direction) == -1) {
    direction = ('[data:makeList]' 0 1)
  } else {
    direction = ('[data:makeList]' 1 0)
  }
}

to 'turn right' {
  if ((at 1 direction) == 1) {
    direction = ('[data:makeList]' 0 1)
  } ((at 2 direction) == 1) {
    direction = ('[data:makeList]' -1 0)
  } ((at 1 direction) == -1) {
    direction = ('[data:makeList]' 0 -1)
  } else {
    direction = ('[data:makeList]' 1 0)
  }
}

to 'worm contains apple' {
  for part worm {
    if (and ((at 1 part) == (at 1 apple)) ((at 2 part) == (at 2 apple))) {return (booleanConstant true)}
  }
  return (booleanConstant false)
}

to 'worm should die' {
  local 'head' (at 'last' worm)
  if (or (or ((at 1 head) > 5) ((at 2 head) > 5)) (or ((at 1 head) < 1) ((at 2 head) < 1))) {
    return (booleanConstant true)
  }
  for index ((size worm) - 1) {
    local 'part' (at index worm)
    if (and ((at 1 part) == (at 1 head)) ((at 2 part) == (at 2 head))) {
      return (booleanConstant true)
    }
  }
  return (booleanConstant false)
}

script 50 50 {
comment 'The classic Snake game, but in a smaller scale!'
}

script 50 107 {
whenStarted
'new game'
forever {
  'draw apple'
  repeatUntil ('touching apple') {
    'move worm'
    waitMillis 500
    if ('worm should die') {
      '[display:mbDisplay]' 18284874
      waitUntil (or (buttonA) (buttonB))
      'new game'
    } ((size worm) == 24) {
      '[display:mbDisplay]' 15237450
      waitUntil (or (buttonA) (buttonB))
      'new game'
    }
  }
  'grow worm'
}
}

script 452 109 {
whenButtonPressed 'A'
'turn left'
}

script 452 213 {
whenButtonPressed 'B'
'turn right'
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''

script 52 50 {
comment 'Start the project, then shake your BBC micro:bit or CPX for some magic glitter!'
}

script 52 124 {
whenCondition (('[sensors:tiltX]') > 50)
'[display:mbPlot]' (random 1 5) (random 1 5)
'[display:mbUnplot]' (random 1 5) (random 1 5)
setNeoPixelColor (random 1 10) (randomColor)
setNeoPixelColor (random 1 10) (colorSwatch 0 0 0 255)
}

script 423 128 {
whenStarted
neoPixelAttach 10 ''
}

script 62 327 {
whenCondition (('[sensors:tiltX]') < 50)
'[display:mbUnplot]' (random 1 5) (random 1 5)
setNeoPixelColor (random 1 10) (colorSwatch 0 0 0 255)
}


module 'Basic Sensors' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor 
choices accelerometerRange '1' '2' '4' '8' 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[sensors:acceleration]' 'acceleration'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (Â°C)'
  spec ' ' '_setAccelRange' 'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to '_setAccelRange' n {
  '[sensors:setAccelerometerRange]' (0 + n)
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}


module NeoPixel Output
author MicroBlocks
version 1 6 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if ((boardType) == 'M5Atom-Matrix') {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'Mbits') {
    neoPixelAttach 25 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'r' ((rgb >> 16) & 255)
    local 'g' ((rgb >> 8) & 255)
    local 'b' (rgb & 255)
    local 'brightness' (maximum r g b)
    if (delta > 0) {
      delta = (minimum delta (255 - brightness))
    } else {
      delta = (maximum delta (42 - brightness))
    }
    r = (maximum 0 (minimum (r + delta) 255))
    g = (maximum 0 (minimum (g + delta) 255))
    b = (maximum 0 (minimum (b + delta) 255))
    atPut i _np_pixels (colorFromRGB r g b)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_update' {
  '[display:neoPixelSend]' _np_pixels
  waitMicros 100
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  hasWhite = false
  if ((pushArgCount) > 2) {
    hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  fillList _np_pixels 0
  '[display:neoPixelSetPin]' pinNumber hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels color
  '_NeoPixel_update'
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' (n > 0)
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}

module main
author unknown
version 1 0 
description ''
variables 'changing sparsity' sparsity 

script 406 43 {
comment 'Generates symmetric patterns on the BBC micro:bit 5x5 LED display'
comment 'Use the A and B buttons to control the sparsity of dots in the patterns'
}

script 43 50 {
whenStarted
'changing sparsity' = (booleanConstant false)
sparsity = 4
forever {
  '[display:mbDisplayOff]'
  for x 3 {
    for y 3 {
      if (not (v 'changing sparsity')) {if ((random 1 sparsity) == 1) {
        '[display:mbPlot]' x y
        '[display:mbPlot]' y x
        '[display:mbPlot]' (6 - x) (6 - y)
        '[display:mbPlot]' (6 - y) (6 - x)
        '[display:mbPlot]' (6 - x) y
        '[display:mbPlot]' (6 - y) x
        '[display:mbPlot]' x (6 - y)
        '[display:mbPlot]' y (6 - x)
      }}
    }
  }
  waitMillis 250
}
}

script 407 116 {
whenButtonPressed 'A'
'changing sparsity' = (booleanConstant true)
if (sparsity > 1) {
  sparsity += -1
}
waitUntil (not (buttonA))
scroll_text sparsity
'changing sparsity' = (booleanConstant false)
}

script 407 369 {
whenButtonPressed 'B'
'changing sparsity' = (booleanConstant true)
sparsity += 1
waitUntil (not (buttonB))
scroll_text sparsity
'changing sparsity' = (booleanConstant false)
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''

script 50 50 {
whenStarted
home
'[display:mbDisplayOff]'
'pen down'
repeat 36 {
  repeat 4 {
    move (('[tft:getHeight]') / 3)
    turnBy 90
  }
  turnBy 10
}
}


module TFT Output
author MicroBlocks
version 1 5 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  space
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}


module Turtle Output
author MicroBlocks
version 1 3 
depends TFT 
tags tft graphics draw 
description 'Draw with turtle geometry on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.
'
variables _turtleX _turtleY _turtleHeading _turtlePenIsDown _turtleColor 

  spec ' ' 'home' 'home'
  spec ' ' 'move' 'move _' 'auto' '10'
  spec ' ' 'turnBy' 'turn _ degrees' 'auto' 90
  spec ' ' 'turnFraction' 'turn _ / _ of circle' 'auto auto' 1 4
  spec ' ' 'pen down' 'pen down'
  spec ' ' 'pen up' 'pen up'
  spec ' ' 'set pen color to' 'set pen color to _' 'color'
  spec ' ' 'setPenToRandomColor' 'set pen to random color'
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' 'clearDisplay' 'fill display with _' 'color'
  spec ' ' 'go to x' 'go to x _ y _' 'auto auto' '10' '10'
  spec ' ' 'setHeading' 'point in direction _' 'auto' 0
  spec ' ' '_turtleNotes' '_turtleNotes'

to '_turtleNotes' {
  comment 'Representation:
  _turtleHeading is in hundreths of a degree  (e.g. 4500 means 45 degrees)
  _turtleX and _turtleY are scaled by 16384 (2^14)

The sine function takes an angle in hundreds of a degree and returns a
number scaled by 16384. _turtleX and _turtleY are also scaled by 16384.
Those numbers are shifted right by 14 bits to get pixel locations.'
}

to clearDisplay color {
  '[tft:rect]' 0 0 ('[tft:getWidth]') ('[tft:getHeight]') color true
  comment 'Give the display controller time to finish this operation'
  waitMillis 1
}

to 'go to x' x y {
  local 'startX' (_turtleX >> 14)
  local 'startY' (_turtleY >> 14)
  _turtleX = (((('[tft:getWidth]') / 2) + x) << 14)
  _turtleY = (((('[tft:getHeight]') / 2) - y) << 14)
  local 'endX' (_turtleX >> 14)
  local 'endY' (_turtleY >> 14)
  if _turtlePenIsDown {
    '[tft:line]' startX startY endX endY _turtleColor
  }
}

to home {
  if (0 == _turtlePenIsDown) {
    'set pen color to' (colorSwatch 7 255 1 255)
    '[display:mbDisplayOff]'
    'pen up'
  }
  'go to x' 0 0
  setHeading 0
}

to move n {
  local 'startX' (_turtleX >> 14)
  local 'startY' (_turtleY >> 14)
  comment 'The cosine is just the sine shifted by 90 degrees.'
  _turtleX += (n * ('[misc:sin]' (_turtleHeading + 9000)))
  _turtleY += (n * ('[misc:sin]' _turtleHeading))
  local 'endX' (_turtleX >> 14)
  local 'endY' (_turtleY >> 14)
  if _turtlePenIsDown {
    '[tft:line]' startX startY endX endY _turtleColor
  }
}

to 'pen down' {
  _turtlePenIsDown = (booleanConstant true)
}

to 'pen up' {
  _turtlePenIsDown = (booleanConstant false)
}

to 'set pen color to' color {
  _turtleColor = color
}

to setHeading a {
  _turtleHeading = ((a * 100) % 36000)
}

to setPenToRandomColor {
  local 'c1' (random 150 220)
  local 'c2' (random 0 ((3 * c1) / 4))
  local 'c3' (random 0 ((3 * c1) / 4))
  local 'which' (random 1 3)
  if (1 == which) {
    _turtleColor = ((c1 << 16) | ((c2 << 8) | c3))
  } (2 == which) {
    _turtleColor = ((c2 << 16) | ((c3 << 8) | c1))
  } else {
    _turtleColor = ((c3 << 16) | ((c1 << 8) | c2))
  }
}

to turnBy a {
  _turtleHeading += (a * 100)
  _turtleHeading = (_turtleHeading % 36000)
}

to turnFraction num denom {
  _turtleHeading += ((num * 36000) / denom)
  _turtleHeading = (_turtleHeading % 36000)
}

module main
author unknown
version 1 0 
description ''
variables x y 

script 50 50 {
whenStarted
x = 1
y = 1
forever {
  if (and (('[sensors:tiltX]') < -10) (x > 1)) {x += -1}
  if (and (('[sensors:tiltX]') > 10) (x < 5)) {x += 1}
  if (and (('[sensors:tiltY]') < -10) (y > 1)) {y += -1}
  if (and (('[sensors:tiltY]') > 10) (y < 5)) {y += 1}
  '[display:mbDisplayOff]'
  '[display:mbPlot]' x y
  waitMillis 70
}
}


module 'Basic Sensors' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor 
choices accelerometerRange '1' '2' '4' '8' 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[sensors:acceleration]' 'acceleration'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (Â°C)'
  spec ' ' '_setAccelRange' 'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to '_setAccelRange' n {
  '[sensors:setAccelerometerRange]' (0 + n)
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''

script 50 50 {
whenStarted
'[display:mbDisplayOff]'
forever {
  setUserLED true
  waitMillis 200
  setUserLED false
  waitMillis 200
}
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 2 0 
description ''
variables 'player x' 'player y' playing 'stone x' 'stone y' 

script 417 49 {
whenStarted
'player x' = 3
'player y' = 5
forever {
  if playing {
    if (and (buttonA) ((v 'player x') > 1)) {'player x' += -1}
    if (and (buttonB) ((v 'player x') < 5)) {'player x' += 1}
    '[display:mbDisplayOff]'
    '[display:mbPlot]' (v 'stone x') (v 'stone y')
    '[display:mbPlot]' (v 'player x') (v 'player y')
    waitMillis 100
  }
}
}

script 47 65 {
comment 'Game written by David SÃ¡nchez MarÃ­n
============================

Use the two buttons in the micro:bit to
try to avoid the falling stones.

Have fun!'
}

script 50 218 {
whenStarted
playing = (booleanConstant true)
'stone x' = (random 1 5)
'stone y' = 0
forever {
  if playing {
    repeatUntil ((v 'stone y') == 5) {
      'stone y' += 1
      waitMillis 200
    }
    'stone x' = (random 1 5)
    'stone y' = 0
  }
}
}

script 55 586 {
whenCondition (and ((v 'player x') == (v 'stone x')) ((v 'player y') == (v 'stone y')))
playing = (booleanConstant false)
scroll_text 'GAME OVER'
'[display:mbDisplayOff]'
waitMillis 1000
playing = (booleanConstant true)
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''
variables 'ball speed' 'ball y' 'pipe height' 'pipe x' playing 'previous ball y' score 'ball radius' 'pipe width' gap 'ball acceleration' 

  spec ' ' 'check buttons' 'check buttons'
  spec ' ' 'check collision' 'check collision'
  spec ' ' 'draw ball' 'draw ball'
  spec ' ' 'draw pipes' 'draw pipe'
  spec ' ' 'game over' 'game over'
  spec ' ' 'new game' 'new game'
  spec ' ' 'step ball' 'step ball'
  spec ' ' 'step pipe' 'step pipe'
  spec ' ' 'welcome screen' 'welcome screen'
  spec 'r' 'button pressed' 'button pressed'
  spec ' ' 'write' 'write _ centered at scale _ y _ color _' 'str auto auto color' 'Hello!' 3 '10'

to 'button pressed' {
  return (or (or (buttonA) (buttonB)) (or ('OK button') ('cancel button')))
}

to 'check buttons' {
  if (and playing ('button pressed')) {
    'ball speed' = 0
    'ball y' += ((v 'ball acceleration') * -10)
  }
}

to 'check collision' {
  if (and ((v 'pipe x') <= (v 'pipe width')) (or ((((v 'ball y') / 10) + (v 'ball radius')) >= ((v 'pipe height') + gap)) ((((v 'ball y') / 10) - (v 'ball radius')) <= (v 'pipe height')))) {playing = (booleanConstant false)}
}

to 'draw ball' {
  '[tft:circle]' (v 'ball radius') ((v 'previous ball y') / 10) ((v 'ball radius') + 1) 0 true
  '[tft:circle]' (v 'ball radius') ((v 'ball y') / 10) (v 'ball radius') 65535 true
}

to 'draw pipes' {
  '[tft:rect]' ((v 'pipe x') + (v 'pipe width')) 0 (v 'pipe width') (v 'pipe height') 0 true
  '[tft:rect]' (v 'pipe x') 0 (v 'pipe width') (v 'pipe height') 65280 true
  '[tft:rect]' ((v 'pipe x') + (v 'pipe width')) ((v 'pipe height') + gap) (v 'pipe width') (('[tft:getHeight]') - ((v 'pipe height') + gap)) 0 true
  '[tft:rect]' (v 'pipe x') ((v 'pipe height') + gap) (v 'pipe width') (('[tft:getHeight]') - ((v 'pipe height') + gap)) 65280 true
}

to 'game over' {
  '[display:mbDisplayOff]'
  write 'GAME' (('[tft:getHeight]') / 30) (('[tft:getHeight]') / 15) (colorSwatch 255 255 255 255)
  write 'OVER' (('[tft:getHeight]') / 30) (('[tft:getHeight]') / 3) (colorSwatch 255 255 255 255)
  write ('[data:join]' 'SCORE:' score) (('[tft:getHeight]') / 80) (('[tft:getHeight]') - (('[tft:getHeight]') / 3)) (colorSwatch 255 255 255 255)
}

to 'new game' {
  '[display:mbDisplayOff]'
  score = 0
  comment 'ball y is multiplied by 10 for precision'
  'ball y' = ((('[tft:getHeight]') / 2) * 10)
  playing = (booleanConstant true)
  'ball acceleration' = (('[tft:getHeight]') / 60)
  'ball speed' = (('[tft:getHeight]') / 60)
  'ball radius' = (('[tft:getHeight]') / 15)
  gap = (random ((v 'ball radius') * 4) ((v 'ball radius') * 7))
  'pipe x' = (('[tft:getWidth]') - (('[tft:getWidth]') / 5))
  'pipe height' = (random ((v 'ball radius') * 2) ((v 'ball radius') * 10))
  'pipe width' = ((v 'ball radius') * 2)
}

to 'step ball' {
  'ball speed' += (v 'ball acceleration')
  if ((v 'ball y') < 0) {
    'ball y' = ((v 'ball y') * (v 'ball speed'))
  }
  'previous ball y' = (v 'ball y')
  'ball y' += (v 'ball speed')
  if ((v 'ball y') > (('[tft:getHeight]') * 10)) {
    playing = (booleanConstant false)
  }
  'check buttons'
}

to 'step pipe' {
  'pipe x' += ((score / -10) - (('[tft:getWidth]') / 120))
  if ((v 'pipe x') < (((v 'pipe width') * -1) - 2)) {
    'pipe x' = ('[tft:getWidth]')
    'pipe height' = (random ((v 'ball radius') * 2) ((v 'ball radius') * 10))
    score += 1
  }
}

to 'welcome screen' {
  '[display:mbDisplayOff]'
  write 'JUMPY' (('[tft:getHeight]') / 30) (('[tft:getHeight]') / 15) (colorSwatch 244 36 215 255)
  write 'BALL' (('[tft:getHeight]') / 30) (('[tft:getHeight]') / 3) (colorSwatch 244 36 215 255)
  write 'Press OK or A' (('[tft:getHeight]') / 120) (('[tft:getHeight]') - (('[tft:getHeight]') / 4)) (colorSwatch 255 255 255 255)
  write 'to play' (('[tft:getHeight]') / 120) (('[tft:getHeight]') - (('[tft:getHeight]') / 8)) (colorSwatch 255 255 255 255)
}

to write text scale y color {
  local 'width' (((scale * 6) * (size text)) - scale)
  '[tft:text]' text ((('[tft:getWidth]') - width) / 2) y color scale false
}

script 94 52 {
whenStarted
'welcome screen'
forever {
  waitUntil ('button pressed')
  'new game'
  repeatUntil (not playing) {
    'step ball'
    'draw ball'
    'step pipe'
    'draw pipes'
    'check collision'
    waitMillis 10
  }
  'game over'
  waitUntil (not ('button pressed'))
}
}


module 'ED1 Buttons' Input
author MicroBlocks
version 1 0 
tags button capacitive ed1 
description 'Provides blocks for the six capacitive buttons in the Citilab ED1 board.'
variables _ED1_buttons_init '_capacitive threshold' 

  spec ' ' '_ED1_buttons_init' '_ED1_buttons_init' 'any any any'
  spec 'r' 'OK button' 'button OK'
  spec 'r' 'cancel button' 'button X'
  spec 'r' 'up button' 'button up'
  spec 'r' 'down button' 'button down'
  spec 'r' 'left button' 'button left'
  spec 'r' 'right button' 'button right'
  spec ' ' 'set capacitive threshold to' 'set capacitive threshold to _' 'auto' 16

to 'OK button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 15) < (v '_capacitive threshold'))
}

to '_ED1_buttons_init' {
  if (_ED1_buttons_init == 0) {
    if ((v '_capacitive threshold') == 0) {'_capacitive threshold' = 16}
    _ED1_buttons_init = (booleanConstant true)
  }
}

to 'cancel button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 14) < (v '_capacitive threshold'))
}

to 'down button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 13) < (v '_capacitive threshold'))
}

to 'left button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 2) < (v '_capacitive threshold'))
}

to 'right button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 27) < (v '_capacitive threshold'))
}

to 'set capacitive threshold to' threshold {
  '_capacitive threshold' = threshold
}

to 'up button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 4) < (v '_capacitive threshold'))
}


module TFT Output
author MicroBlocks
version 1 5 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  space
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

module main
author unknown
version 1 0 
description ''
variables screen obstacles obsOK prevObs heliX heliY gameOver toggleOn 

  spec ' ' 'clearC5' 'clearC5'
  spec ' ' 'dispScreen' 'dispLEDs'
  spec ' ' 'genObstacle' 'genObstacle'
  spec 'r' 'screenPtr2RC' 'screenPtr2RC _' 'auto' 10
  spec ' ' 'shiftScreen' 'shiftScreen'
  spec ' ' 'toggleHeli' 'toggleHeli'
  spec 'r' 'crashHeli' 'crashHeli _ _' 'auto auto' 2 3
  spec ' ' 'directions' 'directions'
  spec ' ' 'gameOver' 'gameOver'

to clearC5 {
  comment 'Clear col5'
  atPut 5 screen (booleanConstant true)
  atPut 10 screen (booleanConstant false)
  atPut 15 screen (booleanConstant false)
  atPut 20 screen (booleanConstant false)
  atPut 25 screen (booleanConstant false)
}

to crashHeli x y {
  local 'screenPtr' (((y - 1) * 5) + x)
  if (at screenPtr screen) {
    return (booleanConstant true)
  } else {
    return (booleanConstant false)
  }
}

to directions {
  local 'ms' 200
  '[display:mbDisplayOff]'
  repeat 2 {
    '[display:mbDisplay]' 66624
    waitMillis ms
    '[display:mbDisplay]' 0
    waitMillis ms
  }
  '[display:mbDisplay]' 4347332
  waitMillis 1000
  repeat 2 {
    '[display:mbDisplay]' 278784
    waitMillis ms
    '[display:mbDisplay]' 0
    waitMillis ms
  }
  '[display:mbDisplay]' 4674692
  waitMillis 3000
}

to dispScreen {
  for pos (size screen) {
    comment 'In: 1-25
Out: LED on/off'
    local 'r' ((screenPtr2RC pos) / 10)
    local 'c' ((screenPtr2RC pos) % 10)
    if (at pos screen) {
      '[display:mbPlot]' c r
    } else {
      '[display:mbUnplot]' c r
    }
  }
}

to gameOver {
  gameOver = (booleanConstant true)
  toggleOn = (booleanConstant false)
  local 'ms' 100
  repeat 3 {
    '[display:mbDisplay]' 8554664
    waitMillis ms
    '[display:mbDisplay]' 0
    waitMillis ms
  }
  scroll_text 'GAME Over'
  '[display:mbDisplay]' 2269696
}

to genObstacle {
  comment 'Makes 0-3 down obstacles
at col 5 of screen randomly
0    1    2    3
x    x    x    x
.     .     x   x
.     .     .    x
.     x    .    .
x    x    x    .
Transitions of 1->3 and 3->1
are not allowed'
  local 'obsOK' (booleanConstant false)
  repeatUntil obsOK {
    comment 'Gens obs = 0 - 3'
    local 'obs' ((random 1 10) % 4)
    if (and (prevObs == 1) (obs == 3)) {
      comment 'Not allowed'
    } (and (prevObs == 3) (obs == 1)) {
      comment 'Not allowed'
    } else {
      prevObs = obs
      obsOK = (booleanConstant true)
    }
  }
  clearC5
  for i obs {
    atPut (i * 5) screen (booleanConstant true)
  }
  if (obs == 1) {
    atPut 20 screen (booleanConstant true)
    atPut 25 screen (booleanConstant true)
  } (obs == 2) {
    atPut 25 screen (booleanConstant true)
  }
}

to screenPtr2RC screenPtr {
  comment 'In: 1-25

Out: rc'
  local 'c' (screenPtr % 5)
  local 'r' (screenPtr / 5)
  local 'rc' 0
  if (c == 0) {
    c = 5
  } (c > 0) {
    r += 1
  }
  rc = ((r * 10) + c)
  return rc
}

to shiftScreen {
  comment 'Shift left by 1 col'
  for row 5 {
    for col 4 {
      local 'c' (((row - 1) * 5) + col)
      atPut c screen (at (c + 1) screen)
    }
  }
}

to toggleHeli {
  local 'ms' 50
  forever {
    repeatUntil (not toggleOn) {
      '[display:mbPlot]' heliX heliY
      waitMillis ms
      '[display:mbUnplot]' heliX heliY
      if (buttonA) {
        waitMillis ms
        heliY += -1
      } (buttonB) {
        waitMillis ms
        heliY += 1
      }
      if (crashHeli heliX heliY) {
        gameOver
      }
      waitMillis ms
    }
  }
}

script 47 43 {
comment 'Game contributed by Turgut Guneysu
============================

microHELI:

This is the micro version of the popular Helicopter game.
One flies the Heli through a corridor of obstacles hanging
from the ceiling and rising from the ground.

Use buttonA to RAISE the Heli
Use button B to LOWER the Heli

That''s it !

Have Fun.'
}

script 52 312 {
whenStarted
screen = (newList 25)
atPut 'all' screen (booleanConstant false)
prevObs = 0
heliX = 2
heliY = 3
gameOver = (booleanConstant false)
toggleOn = (booleanConstant false)
directions
'[display:mbDisplayOff]'
toggleOn = (booleanConstant true)
repeatUntil gameOver {
  genObstacle
  shiftScreen
  clearC5
  dispScreen
  waitMillis 400
}
}

script 371 312 {
whenStarted
toggleHeli
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''
variables pattern guess difficulty 

  spec ' ' 'guess pattern' 'guess pattern'
  spec ' ' 'new pattern' 'new pattern'
  spec 'r' 'pattern contains' 'pattern contains _ , _' 'auto auto' 1 3
  spec ' ' 'show pattern' 'show pattern _' 'auto' '10'

to 'guess pattern' {
  guess = ('[data:makeList]')
  local 'x' 1
  local 'y' 1
  repeatUntil (y > 5) {
    'show pattern' guess
    '[display:mbPlot]' x y
    if (buttonA) {
      waitUntil (not (buttonA))
      x += 1
      if (x > 5) {
        x = 1
        y += 1
      }
    } (buttonB) {
      waitUntil (not (buttonB))
      '[data:addLast]' ('[data:makeList]' x y) guess
      if (not ('pattern contains' x y)) {
        sendBroadcast 'fail'
        stopTask
      }
    }
    waitMillis 100
  }
}

to 'new pattern' {
  pattern = ('[data:makeList]')
  repeat difficulty {
    '[data:addLast]' ('[data:makeList]' (random 1 5) (random 1 5)) pattern
  }
}

to 'pattern contains' x y {
  for led pattern {
    if (and (x == (at 1 led)) (y == (at 2 led))) {return (booleanConstant true)}
  }
  return (booleanConstant false)
}

to 'show pattern' pattern {
  '[display:mbDisplayOff]'
  for led pattern {
    '[display:mbPlot]' (at 1 led) (at 2 led)
  }
}

script 73 59 {
comment '         HOW TO PLAY
         ============

When the game begins,
you''re presented with a
pattern that you have to
memorize.

Now it''s your turn to enter
that pattern back.
Use the A button to move
the cursor one step, and
the B button to input the
current position.

Keep going until you
reach the end of the
screen.

If you fail, you''ll be shown
where you went wrong,
and if you win you''ll be
presented with a harder
pattern.

Good luck! :)'
}

script 378 59 {
whenStarted
difficulty = 3
sendBroadcast 'go!'
}

script 597 71 {
to 'new pattern' {}
}

script 381 177 {
whenBroadcastReceived 'go!'
forever {
  'new pattern'
  'show pattern' pattern
  waitMillis 1000
  'guess pattern'
  '[display:mbDisplay]' 15237440
  difficulty += 1
  waitMillis 1000
}
}

script 595 253 {
to 'guess pattern' {}
}

script 382 513 {
whenBroadcastReceived 'fail'
repeat 5 {
  'show pattern' guess
  waitMillis 250
  'show pattern' pattern
  waitMillis 250
}
waitMillis 1000
difficulty = 3
sendBroadcast 'go!'
}


module 'Basic Sensors' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor 
choices accelerometerRange '1' '2' '4' '8' 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[sensors:acceleration]' 'acceleration'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (Â°C)'
  spec ' ' '_setAccelRange' 'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to '_setAccelRange' n {
  '[sensors:setAccelerometerRange]' (0 + n)
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''
variables 'ball radius' 'delta x' 'delta y' 'paddle 1 x' 'paddle 2 x' 'paddle width' playing 'refresh rate' speed x y 

  spec ' ' 'bounce ball' 'bounce ball'
  spec ' ' 'bounce on paddle' 'bounce on paddle _' 'auto' 2
  spec ' ' 'clear ball' 'clear ball'
  spec ' ' 'game over' 'player  _ wins' 'auto' 1
  spec ' ' 'new game' 'new game'
  spec ' ' 'plot ball' 'draw ball'
  spec ' ' 'plot paddles' 'draw paddles'

to 'bounce ball' {
  if (or (x >= (128 - ((v 'ball radius') * 2))) (x <= ((v 'ball radius') * 2))) {
    'delta x' = ((v 'delta x') * -1)
    'play tone' 'D' 1 50
  }
  if (y <= 1) {
    'game over' 1
  } (y >= 126) {
    'game over' 2
  } (and (y <= 19) (and (x >= (v 'paddle 2 x')) (x <= ((v 'paddle 2 x') + (v 'paddle width'))))) {
    'bounce on paddle' 2
  } (and (y >= 113) (and (x >= (v 'paddle 1 x')) (x <= ((v 'paddle 1 x') + (v 'paddle width'))))) {
    'bounce on paddle' 1
  }
}

to 'bounce on paddle' n {
  'delta y' = ((v 'delta y') * -1)
  local 'paddle x' 0
  if (n == 1) {
    'paddle x' = (v 'paddle 1 x')
  } else {
    'paddle x' = (v 'paddle 2 x')
  }
  if (and (x >= (v 'paddle x')) (x <= ((v 'paddle x') + 10))) {
    'delta x' = (speed * -2)
    'play tone' 'G#' 1 50
  } (and (x >= ((v 'paddle x') + ((v 'paddle width') - 10))) (x <= ((v 'paddle x') + (v 'paddle width')))) {
    'delta x' = (speed * 2)
    'play tone' 'G#' 1 50
  } ((v 'delta x') > 0) {
    'delta x' = speed
    'play tone' 'D' 1 50
  } else {
    'delta x' = (speed * -1)
    'play tone' 'D' 1 50
  }
  speed += 10
}

to 'clear ball' {
  '[tft:circle]' x y (v 'ball radius') 0 true
}

to 'game over' n {
  playing = (booleanConstant false)
  '[display:mbDisplayOff]'
  '[tft:text]' 'GAME' 18 30 (hexToInt 'FF0000') 4 false
  '[tft:text]' 'OVER' 18 70 (hexToInt 'FF0000') 4 false
  if (n == 1) {
    '[tft:text]' 'v WINNER v' 38 110 (hexToInt '00FF00') 1 false
    '[tft:line]' 40 115 40 105 (hexToInt '00FF00')
    '[tft:line]' 94 115 94 105 (hexToInt '00FF00')
  } else {
    '[tft:text]' '^ WINNER ^' 38 10 (hexToInt '00FF00') 1 false
    '[tft:line]' 40 10 40 20 (hexToInt '00FF00')
    '[tft:line]' 94 10 94 20 (hexToInt '00FF00')
  }
  'play tone' 'E' 2 150
  'play tone' 'D#' 2 150
  'play tone' 'D' 2 150
  'play tone' 'C#' 2 150
  'play tone' 'C' 2 150
  'play tone' 'B' 1 300
  waitMillis 1000
  'new game'
}

to 'new game' {
  speed = 200
  'paddle 1 x' = (random 30 80)
  'paddle 2 x' = (random 30 80)
  x = (random 30 80)
  y = 63
  if ((random 1 2) == 1) {
    'delta x' = speed
  } else {
    'delta x' = (speed * -1)
  }
  if ((random 1 2) == 1) {
    'delta y' = speed
  } else {
    'delta y' = (speed * -1)
  }
  '[display:mbDisplayOff]'
  '[tft:text]' 'PONG' 18 40 (hexToInt 'FFFF00') 4 false
  '[tft:text]' 'Press OK to start' 15 80 (hexToInt 'FFFFFF') 1 false
  waitUntil ('OK button')
  '[display:mbDisplayOff]'
  '[tft:text]' 'GO!' 30 30 (hexToInt 'FFFF00') 5 false
  waitMillis 1000
  '[display:mbDisplayOff]'
  playing = (booleanConstant true)
}

to 'plot ball' {
  '[tft:circle]' x y (v 'ball radius') (hexToInt 'FF0000') true
}

to 'plot paddles' {
  '[tft:rect]' 0 6 128 8 0 true
  '[tft:roundedRect]' (v 'paddle 2 x') 6 (v 'paddle width') 8 4 (hexToInt 'FFFF00') true
  '[tft:rect]' 0 120 128 8 0 true
  '[tft:roundedRect]' (v 'paddle 1 x') 120 (v 'paddle width') 8 4 (hexToInt 'FFFF00') true
}

script 50 55 {
comment 'A rendition to one of the first videogames ever.
This one fits in your pocket!

Player 1 uses keys OK and X.
Player 2 uses â and â.'
}

script 55 163 {
whenStarted
'refresh rate' = 40
'ball radius' = 4
'paddle width' = 40
'new game'
forever {
  if playing {
    'clear ball'
    x += ((v 'delta x') / 100)
    y += ((v 'delta y') / 100)
    'plot ball'
    'bounce ball'
  }
  waitMillis (v 'refresh rate')
}
}

script 380 172 {
whenCondition ('OK button')
if ((v 'paddle 1 x') >= 4) {
  'paddle 1 x' += -2
}
'plot paddles'
}

script 382 369 {
whenCondition ('cancel button')
if ((v 'paddle 1 x') <= (126 - (v 'paddle width'))) {
  'paddle 1 x' += 2
}
'plot paddles'
}

script 388 570 {
whenCondition ('right button')
if ((v 'paddle 2 x') <= (126 - (v 'paddle width'))) {
  'paddle 2 x' += 2
}
'plot paddles'
}

script 60 576 {
whenCondition ('left button')
if ((v 'paddle 2 x') >= 4) {
  'paddle 2 x' += -2
}
'plot paddles'
}


module 'ED1 Buttons' Input
author MicroBlocks
version 1 0 
tags button capacitive ed1 
description 'Provides blocks for the six capacitive buttons in the Citilab ED1 board.'
variables _ED1_buttons_init '_capacitive threshold' 

  spec ' ' '_ED1_buttons_init' '_ED1_buttons_init' 'any any any'
  spec 'r' 'OK button' 'button OK'
  spec 'r' 'cancel button' 'button X'
  spec 'r' 'up button' 'button up'
  spec 'r' 'down button' 'button down'
  spec 'r' 'left button' 'button left'
  spec 'r' 'right button' 'button right'
  spec ' ' 'set capacitive threshold to' 'set capacitive threshold to _' 'auto' 16

to 'OK button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 15) < (v '_capacitive threshold'))
}

to '_ED1_buttons_init' {
  if (_ED1_buttons_init == 0) {
    if ((v '_capacitive threshold') == 0) {'_capacitive threshold' = 16}
    _ED1_buttons_init = (booleanConstant true)
  }
}

to 'cancel button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 14) < (v '_capacitive threshold'))
}

to 'down button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 13) < (v '_capacitive threshold'))
}

to 'left button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 2) < (v '_capacitive threshold'))
}

to 'right button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 27) < (v '_capacitive threshold'))
}

to 'set capacitive threshold to' threshold {
  '_capacitive threshold' = threshold
}

to 'up button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 4) < (v '_capacitive threshold'))
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''
variables 'delta x' 'delta y' 'paddle x' playing 'refresh rate' score x y 

  spec ' ' 'bounce on x' 'bounce on x'
  spec ' ' 'bounce ball' 'bounce ball'
  spec ' ' 'bounce on y' 'bounce on y'
  spec ' ' 'game over' 'game over'
  spec ' ' 'new game' 'new game'
  spec ' ' 'plot ball' 'plot ball'
  spec ' ' 'plot paddles' 'plot paddle'
  spec ' ' 'should bounce on paddle' 'random bounce'
  spec ' ' 'speed up' 'speed up'

to 'bounce ball' {
  if (or (x == 5) (x == 1)) {'bounce on x'}
  if (y == 1) {
    'bounce on y'
    'speed up'
  }
  if (and (y == 5) (x == (v 'paddle x'))) {
    'bounce on y'
    'should bounce on paddle'
    score += 1
  } (y == 5) {
    'game over'
  }
  x += (v 'delta x')
  y += (v 'delta y')
}

to 'bounce on x' {
  'delta x' = ((v 'delta x') * -1)
}

to 'bounce on y' {
  'delta y' = ((v 'delta y') * -1)
}

to 'game over' {
  playing = (booleanConstant false)
  scroll_text 'GAME OVER' 75
  scroll_text 'Score:' 75
  scroll_text score
  waitMillis 150
  'new game'
}

to 'new game' {
  score = 0
  'paddle x' = 3
  'refresh rate' = 500
  x = (random 2 4)
  y = 2
  'delta y' = 1
  if ((random 1 2) == 1) {
    'delta x' = 1
  } else {
    'delta x' = -1
  }
  scroll_text 'Go!' 100
  '[display:mbDisplayOff]'
  playing = (booleanConstant true)
}

to 'plot ball' {
  '[display:mbPlot]' x y
}

to 'plot paddles' {
  '[display:mbPlot]' (v 'paddle x') 5
}

to 'should bounce on paddle' {
  if (and (and (x > 1) (x < 5)) ((random 1 2) == 1)) {'bounce on x'}
  x = (random 2 4)
}

to 'speed up' {
  if ((v 'refresh rate') > 200) {'refresh rate' += -15}
}

script 47 43 {
comment 'A rendition to one of the first videogames ever.
It may have worse resolution than the original,
but this one fits in your pocket!'
}

script 315 131 {
whenCondition (buttonA)
if ((v 'paddle x') > 1) {
  'paddle x' += -1
}
waitUntil (not (buttonA))
}

script 52 146 {
whenStarted
'new game'
forever {
  if playing {
    '[display:mbDisplayOff]'
    'plot paddles'
    'plot ball'
    'bounce ball'
  }
  waitMillis (v 'refresh rate')
}
}

script 317 324 {
whenCondition (buttonB)
if ((v 'paddle x') < 5) {
  'paddle x' += 1
}
waitUntil (not (buttonB))
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''

script 50 50 {
whenButtonPressed 'A'
'[display:mbDisplayOff]'
waitMillis 600
local 'which' (random 1 3)
if (which == 1) {
  '[display:mbDisplay]' 473536
}
if (which == 2) {
  '[display:mbDisplay]' 16033071
}
if (which == 3) {
  '[display:mbDisplay]' 18157898
}
}

script 312 52 {
whenButtonPressed 'B'
'[display:mbDisplayOff]'
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''

script 331 52 {
whenButtonPressed 'B'
'[display:mbDisplayOff]'
}

script 70 54 {
whenCondition (('[sensors:acceleration]') > 140)
'[display:mbDisplayOff]'
waitMillis 500
local 'which' (random 1 3)
if (which == 1) {
  '[display:mbDisplay]' 473536
}
if (which == 2) {
  '[display:mbDisplay]' 16033071
}
if (which == 3) {
  '[display:mbDisplay]' 18157898
}
waitMillis 500
}


module 'Basic Sensors' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor 
choices accelerometerRange '1' '2' '4' '8' 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[sensors:acceleration]' 'acceleration'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (Â°C)'
  spec ' ' '_setAccelRange' 'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to '_setAccelRange' n {
  '[sensors:setAccelerometerRange]' (0 + n)
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author Bernat
version 1 1 
description ''
variables 'current index' sequence 

  spec 'r' 'correct guess' 'correct guess at _' 'auto' '10'
  spec ' ' 'play note at' 'play note at _' 'auto' '10'
  spec 'r' 'wrong guess' 'wrong guess at _' 'auto' '10'
  spec ' ' 'setup' 'setup'

to 'correct guess' index {
  return (or (and (buttonA) ((at index sequence) == 0)) (and (buttonB) ((at index sequence) == 1)))
}

to 'play note at' index {
  local 'half_pixel_count' ((size _np_pixels) / 2)
  clearNeoPixels
  if ((at index sequence) == 0) {
    for i half_pixel_count {
      setNeoPixelColor i (colorSwatch 0 83 83 255)
    }
    'play tone' 'D' 2 200
  } else {
    for i half_pixel_count {
      setNeoPixelColor (i + half_pixel_count) (colorSwatch 101 103 1 255)
    }
    'play tone' 'G' 2 200
  }
  clearNeoPixels
}

to setup {
  'play tone' 'C' 1 100
  'play tone' 'E' 1 100
  'play tone' 'G' 1 100
  'play tone' 'C' 2 100
  if (sequence == 0) {
    sequence = (newList 20)
  }
  for i (size sequence) {
    atPut i sequence (random 0 1)
  }
  'current index' = 1
}

to 'wrong guess' index {
  return (or (and (buttonA) ((at index sequence) == 1)) (and (buttonB) ((at index sequence) == 0)))
}

script 50 50 {
comment 'This is the "Simon" memory game for the
Adafruit Circuit Playground Express.'
}

script 750 124 {
whenBroadcastReceived 'play sequence'
if ((v 'current index') > 10) {
  clearNeoPixels
  for i 6 {
    setNeoPixelColor (i + 2) (colorSwatch 198 0 1 255)
  }
  setNeoPixelColor 1 (colorSwatch 6 191 107 255)
  setNeoPixelColor 10 (colorSwatch 6 191 107 255)
  'play tone' 'C' 2 100
  'play tone' 'E' 1 100
  'play tone' 'C' 2 100
  'play tone' 'E' 1 100
  'play tone' 'C' 1 100
  'play tone' 'G' 1 100
  'play tone' 'C' 2 200
  waitMillis 1000
  clearNeoPixels
  sendBroadcast 'go!'
} else {
  for i (v 'current index') {
    'play note at' i
  }
  sendBroadcast 'player turn'
}
}

script 344 128 {
whenBroadcastReceived 'player turn'
local 'index' 1
repeatUntil (index > (v 'current index')) {
  if ('correct guess' index) {
    'play note at' index
    index += 1
    waitUntil (and (not (buttonA)) (not (buttonB)))
  } ('wrong guess' index) {
    neoPixelSetAllToColor (colorSwatch 177 36 37 255)
    'play tone' 'G' 1 250
    'play tone' 'F#' 1 250
    'play tone' 'F' 1 250
    'play tone' 'E' 1 250
    waitMillis 500
    clearNeoPixels
    sendBroadcast 'go!'
    stopTask
  }
}
waitMillis 500
'current index' += 1
sendBroadcast 'play sequence'
}

script 50 130 {
whenStarted
neoPixelAttach 10 ''
sendBroadcast 'go!'
}

script 51 234 {
whenBroadcastReceived 'go!'
setup
waitMillis 1000
sendBroadcast 'play sequence'
}

script 51 362 {
whenBroadcastReceived 'go!'
neoPixelSetAllToColor (colorSwatch 0 0 0 255)
for i 5 {
  setNeoPixelColor i (colorSwatch 3 0 150 255)
}
repeat 10 {
  rotateNeoPixelsBy -1
  waitMillis 50
}
neoPixelSetAllToColor (colorSwatch 0 0 0 255)
}


module NeoPixel Output
author MicroBlocks
version 1 6 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if ((boardType) == 'M5Atom-Matrix') {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'Mbits') {
    neoPixelAttach 25 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'r' ((rgb >> 16) & 255)
    local 'g' ((rgb >> 8) & 255)
    local 'b' (rgb & 255)
    local 'brightness' (maximum r g b)
    if (delta > 0) {
      delta = (minimum delta (255 - brightness))
    } else {
      delta = (maximum delta (42 - brightness))
    }
    r = (maximum 0 (minimum (r + delta) 255))
    g = (maximum 0 (minimum (g + delta) 255))
    b = (maximum 0 (minimum (b + delta) 255))
    atPut i _np_pixels (colorFromRGB r g b)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_update' {
  '[display:neoPixelSend]' _np_pixels
  waitMicros 100
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  hasWhite = false
  if ((pushArgCount) > 2) {
    hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  fillList _np_pixels 0
  '[display:neoPixelSetPin]' pinNumber hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels color
  '_NeoPixel_update'
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' (n > 0)
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''
variables _loop_overhead 'current index' sequence 

  spec ' ' 'initialize letters' 'initialize sequence'
  spec 'r' 'correct guess' 'correct guess at _' 'auto' '10'
  spec 'r' 'wrong guess' 'wrong guess at _' 'auto' '10'
  spec ' ' 'play note at' 'play note at _' 'auto' '10'
  spec ' ' 'triangle up' 'draw  _' 'auto' 1

to 'correct guess' index {
  return (or (or (and ('up button') ((at index sequence) == 1)) (and ('down button') ((at index sequence) == 2))) (or (and ('left button') ((at index sequence) == 3)) (and ('right button') ((at index sequence) == 4))))
}

to 'initialize letters' {
  'play tone' 'C' 1 100
  'play tone' 'E' 1 100
  'play tone' 'G' 1 100
  'play tone' 'C' 2 100
  if (sequence == 0) {
    sequence = (newList 20)
  }
  for i (size sequence) {
    atPut i sequence (random 1 4)
  }
}

to 'play note at' index {
  'triangle up' index
  if ((at index sequence) == 1) {
    'play tone' 'E' 1 200
  } ((at index sequence) == 2) {
    'play tone' 'F#' 1 200
  } ((at index sequence) == 3) {
    'play tone' 'D' 1 200
  } else {
    'play tone' 'G' 1 200
  }
}

to 'triangle up' index {
  '[display:mbDisplayOff]'
  if ((at index sequence) == 1) {
    '[tft:triangle]' 0 0 63 63 126 0 (hexToInt '00FF00') true
  } ((at index sequence) == 2) {
    '[tft:triangle]' 0 126 63 63 126 126 (hexToInt 'FF0000') true
  } ((at index sequence) == 3) {
    '[tft:triangle]' 0 0 63 63 0 126 (hexToInt '0000FF') true
  } else {
    '[tft:triangle]' 126 0 63 63 126 126 (hexToInt '00FFFF') true
  }
}

to 'wrong guess' index {
  return (or (or (and ('up button') ((at index sequence) != 1)) (and ('down button') ((at index sequence) != 2))) (or (and ('left button') ((at index sequence) != 3)) (and ('right button') ((at index sequence) != 4))))
}

script 51 50 {
comment 'This is the Simon memory game for the
Citilab ED1 board'
}

script 413 50 {
whenBroadcastReceived 'player turn'
local 'index' 1
repeatUntil (index > (v 'current index')) {
  if ('correct guess' index) {
    'play note at' index
    index += 1
    waitUntil (and (and (not ('up button')) (not ('down button'))) (and (not ('left button')) (not ('right button'))))
  } ('wrong guess' index) {
    '[display:mbDisplayOff]'
    '[tft:text]' 'Sorry' 30 45 (colorSwatch 189 191 3 255) 2 true
    '[tft:text]' 'Try again...' 25 70 (colorSwatch 184 184 184 255) 1 true
    'play tone' 'G' 1 250
    'play tone' 'F#' 1 250
    'play tone' 'F' 1 250
    'play tone' 'E' 1 250
    waitMillis 500
    sendBroadcast 'go!'
    stopTask
  }
}
waitMillis 500
'current index' += 1
sendBroadcast 'play sequence'
}

script 50 100 {
whenStarted
sendBroadcast 'go!'
}

script 202 105 {
whenBroadcastReceived 'go!'
'current index' = 1
'initialize letters'
waitMillis 1500
sendBroadcast 'play sequence'
}

script 51 234 {
whenBroadcastReceived 'play sequence'
if ((v 'current index') > 10) {
  '[display:mbDisplayOff]'
  '[tft:text]' 'You win!!' 15 45 (colorSwatch 189 8 191 255) 2 true
  repeat 2 {
    'play tone' 'C' 2 100
    'play tone' 'E' 1 100
  }
  'play tone' 'C' 1 100
  'play tone' 'G' 1 100
  'play tone' 'C' 2 200
  waitMillis 500
  sendBroadcast 'go!'
} else {
  for i (v 'current index') {
    'play note at' i
  }
  sendBroadcast 'player turn'
}
}


module 'ED1 Buttons' Input
author MicroBlocks
version 1 0 
tags button capacitive ed1 
description 'Provides blocks for the six capacitive buttons in the Citilab ED1 board.'
variables _ED1_buttons_init '_capacitive threshold' 

  spec ' ' '_ED1_buttons_init' '_ED1_buttons_init' 'any any any'
  spec 'r' 'OK button' 'button OK'
  spec 'r' 'cancel button' 'button X'
  spec 'r' 'up button' 'button up'
  spec 'r' 'down button' 'button down'
  spec 'r' 'left button' 'button left'
  spec 'r' 'right button' 'button right'
  spec ' ' 'set capacitive threshold to' 'set capacitive threshold to _' 'auto' 16

to 'OK button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 15) < (v '_capacitive threshold'))
}

to '_ED1_buttons_init' {
  if (_ED1_buttons_init == 0) {
    if ((v '_capacitive threshold') == 0) {'_capacitive threshold' = 16}
    _ED1_buttons_init = (booleanConstant true)
  }
}

to 'cancel button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 14) < (v '_capacitive threshold'))
}

to 'down button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 13) < (v '_capacitive threshold'))
}

to 'left button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 2) < (v '_capacitive threshold'))
}

to 'right button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 27) < (v '_capacitive threshold'))
}

to 'set capacitive threshold to' threshold {
  '_capacitive threshold' = threshold
}

to 'up button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 4) < (v '_capacitive threshold'))
}


module TFT Output
author MicroBlocks
version 1 5 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  space
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 1 
description ''
variables 'current index' letters 

  spec ' ' 'initialize letters' 'initialize letters'
  spec 'r' 'correct guess' 'correct guess at _' 'auto' '10'
  spec 'r' 'wrong guess' 'wrong guess at _' 'auto' '10'
  spec ' ' 'map-to-display' 'map-to-display _' 'auto' '10'

to 'correct guess' index {
  return (or (and (buttonA) ((at index letters) == 'A')) (and (buttonB) ((at index letters) == 'B')))
}

to 'initialize letters' {
  if (letters == 0) {letters = (newList 20)}
  for i (size letters) {
    if ((random 1 2) == 1) {
      atPut i letters 'A'
    } else {
      atPut i letters 'B'
    }
  }
}

to 'map-to-display' letter {
  if (letter == 'A') {
    '[display:mbDisplay]' 7576807
    'play tone' 'D' 2 200
  } else {
    '[display:mbDisplay]' 30307228
    'play tone' 'G' 2 200
  }
}

to 'wrong guess' index {
  return (or (and (buttonA) ((at index letters) == 'B')) (and (buttonB) ((at index letters) == 'A')))
}

script 456 50 {
whenBroadcastReceived 'play'
local 'index' 1
repeatUntil (index > (v 'current index')) {
  if ('correct guess' index) {
    'map-to-display' (at index letters)
    index += 1
    waitUntil (and (not (buttonA)) (not (buttonB)))
    '[display:mbDisplayOff]'
  } ('wrong guess' index) {
    repeat 10 {
      '[display:mbDisplay]' 18157905
      waitMillis 50
      '[display:mbDisplayOff]'
      waitMillis 50
    }
    scroll_text 'FAIL' 100
    sendBroadcast 'go!'
  }
}
waitMillis 500
'current index' += 1
sendBroadcast 'draw sequence'
}

script 50 57 {
comment 'This is the "Simon" memory game for the
BBC micro:bit.'
}

script 53 106 {
whenStarted
sendBroadcast 'go!'
}

script 194 111 {
whenBroadcastReceived 'go!'
'initialize letters'
'current index' = 1
scroll_text 'GO!' 100
sendBroadcast 'draw sequence'
}

script 53 234 {
whenBroadcastReceived 'draw sequence'
if ((v 'current index') > 10) {
  '[display:mbDisplay]' 15237440
  waitMillis 1000
  '[display:mbDisplayOff]'
  scroll_text 'WIN!' 100
  sendBroadcast 'go!'
} else {
  for i (v 'current index') {
    'map-to-display' (at i letters)
    '[display:mbDisplayOff]'
    waitMillis 200
  }
  sendBroadcast 'play'
}
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''
variables 'snake body' 'cell size' apple score 'snake direction' 

  spec ' ' 'check collisions' 'check collisions'
  spec 'r' 'copy of position' 'copy of position _' 'auto' ''
  spec ' ' 'draw apple' 'draw apple'
  spec ' ' 'draw snake' 'draw snake _' 'bool' true
  spec ' ' 'eat apple' 'eat apple'
  spec ' ' 'game over' 'game over'
  spec ' ' 'initialize game' 'initialize game'
  spec ' ' 'randomize apple position' 'randomize apple position'
  spec ' ' 'turn' 'turn _' 'auto' 'left'
  spec ' ' 'update snake position' 'update snake position'
  spec ' ' 'write' 'write _ centered at scale _ y _ color _' 'str auto auto color' 'Hello!' 3 '10'

to 'check collisions' {
  local 'snake head' (at 1 (v 'snake body'))
  if (or (or ((at 1 (v 'snake head')) > (('[tft:getWidth]') - (v 'cell size'))) ((at 1 (v 'snake head')) < (v 'cell size'))) (or ((at 2 (v 'snake head')) > (('[tft:getHeight]') - (v 'cell size'))) ((at 2 (v 'snake head')) < (v 'cell size')))) {
    'game over'
  }
  for part ('[data:copyFromTo]' (v 'snake body') 2) {
    if (and ((at 1 (v 'snake head')) == (at 1 part)) ((at 2 (v 'snake head')) == (at 2 part))) {'game over'}
  }
  if (and ((at 1 (v 'snake head')) == (at 1 apple)) ((at 2 (v 'snake head')) == (at 2 apple))) {
    'eat apple'
  }
}

to 'copy of position' position {
  return ('[data:makeList]' (at 1 position) (at 2 position))
}

to 'draw apple' {
  '[tft:circle]' (at 1 apple) (at 2 apple) (((v 'cell size') / 2) - ((v 'cell size') / 8)) (colorSwatch 190 49 11 255)
}

to 'draw snake' 'not erasing' {
  if (v 'not erasing') {
    for part (v 'snake body') {
      '[tft:circle]' (at 1 part) (at 2 part) (((v 'cell size') / 2) - ((v 'cell size') / 8)) (colorSwatch 35 190 30 255)
    }
  } else {
    comment 'Just clear the tail'
    '[tft:circle]' (at 1 (at 'last' (v 'snake body'))) (at 2 (at 'last' (v 'snake body'))) ((((v 'cell size') / 2) - ((v 'cell size') / 8)) + 1) (colorSwatch 0 0 0 255)
  }
}

to 'eat apple' {
  'play tone' 'C' 0 10
  score += 1
  'randomize apple position'
  local 'snake tail' ('copy of position' (at 'last' (v 'snake body')))
  '[data:addLast]' (v 'snake tail') (v 'snake body')
  'draw apple'
}

to 'game over' {
  '[display:mbDisplayOff]'
  write 'GAME OVER' (maximum 1 (('[tft:getWidth]') / 60)) (('[tft:getHeight]') / 3) (colorSwatch 218 6 23 255)
  write ('[data:join]' 'SCORE: ' score) (maximum 1 (('[tft:getWidth]') / 120)) (('[tft:getHeight]') / 2) (colorSwatch 218 6 23 255)
  write 'Press A+B to try again' (maximum 1 (('[tft:getWidth]') / 240)) ((('[tft:getHeight]') * 3) / 4) (colorSwatch 26 218 63 255)
  stopAll
  'play ringtone' 'GameOver:d=16,o=2,b=60:f,e,d#,4c#'
  stopTask
}

to 'initialize game' {
  score = 0
  'snake direction' = ('[data:makeList]' 1 0)
  'cell size' = (('[tft:getWidth]') / 12)
  'snake body' = ('[data:makeList]' ('[data:makeList]' ((v 'cell size') * 3) ((v 'cell size') * 2)) ('[data:makeList]' ((v 'cell size') * 2) ((v 'cell size') * 2)) ('[data:makeList]' (v 'cell size') ((v 'cell size') * 2)))
  apple = ('[data:makeList]' ((v 'cell size') * 2) ((v 'cell size') * 2))
  'randomize apple position'
  '[tft:rect]' 0 0 ('[tft:getWidth]') ('[tft:getHeight]') (colorSwatch 190 35 4 255) true
  '[tft:rect]' ((v 'cell size') / 6) ((v 'cell size') / 6) (('[tft:getWidth]') - ((v 'cell size') / 3)) (('[tft:getHeight]') - ((v 'cell size') / 3)) (colorSwatch 0 0 0 255) true
}

to 'randomize apple position' {
  local 'snake head' (at 1 (v 'snake body'))
  local 'found a spot' (booleanConstant false)
  repeatUntil (v 'found a spot') {
    apple = ('[data:makeList]' ((random 1 ((('[tft:getWidth]') / (v 'cell size')) - 1)) * (v 'cell size')) ((random 1 ((('[tft:getHeight]') / (v 'cell size')) - 1)) * (v 'cell size')))
    'found a spot' = (booleanConstant true)
    for part (v 'snake body') {
      if (and ((at 1 part) == (at 1 apple)) ((at 2 part) == (at 2 apple))) {'found a spot' = (booleanConstant false)}
    }
  }
}

to turn 'turn direction' {
  comment 'Smart this up, with a lookup list, please'
  if ((v 'turn direction') == 'right') {
    if (('[data:joinStrings]' (v 'snake direction')) == '10') {
      'snake direction' = ('[data:makeList]' 0 1)
    } (('[data:joinStrings]' (v 'snake direction')) == '01') {
      'snake direction' = ('[data:makeList]' -1 0)
    } (('[data:joinStrings]' (v 'snake direction')) == '-10') {
      'snake direction' = ('[data:makeList]' 0 -1)
    } else {
      'snake direction' = ('[data:makeList]' 1 0)
    }
  } else {
    if (('[data:joinStrings]' (v 'snake direction')) == '10') {
      'snake direction' = ('[data:makeList]' 0 -1)
    } (('[data:joinStrings]' (v 'snake direction')) == '0-1') {
      'snake direction' = ('[data:makeList]' -1 0)
    } (('[data:joinStrings]' (v 'snake direction')) == '-10') {
      'snake direction' = ('[data:makeList]' 0 1)
    } else {
      'snake direction' = ('[data:makeList]' 1 0)
    }
  }
}

to 'update snake position' {
  for 'part index' ('[data:range]' (size (v 'snake body')) 2) {
    atPut (v 'part index') (v 'snake body') ('copy of position' (at ((v 'part index') - 1) (v 'snake body')))
  }
  local 'snake head' (at 1 (v 'snake body'))
  atPut 1 (v 'snake head') ((at 1 (v 'snake head')) + ((at 1 (v 'snake direction')) * (v 'cell size')))
  atPut 2 (v 'snake head') ((at 2 (v 'snake head')) + ((at 2 (v 'snake direction')) * (v 'cell size')))
}

to write text scale y color {
  local 'width' (((scale * 6) * (size text)) - scale)
  '[tft:text]' text ((('[tft:getWidth]') - width) / 2) y color scale false
}

script 80 50 {
whenStarted
sendBroadcast 'go!'
}

script 290 54 {
whenButtonPressed 'A'
turn 'left'
}

script 80 137 {
whenBroadcastReceived 'go!'
'initialize game'
'draw apple'
forever {
  'draw snake' false
  'update snake position'
  'draw snake' true
  'check collisions'
  waitMillis 200
}
}

script 293 150 {
whenButtonPressed 'B'
turn 'right'
}

script 296 259 {
whenButtonPressed 'A+B'
sendBroadcast 'go!'
}

script 89 387 {
whenBroadcastReceived 'go!'
forever {
  'play ringtone' 'Snake:d=16,o=5,b=112:d,8p.,8a,8a#,8c6,8c6,
8a#,8a,4c6,c,8p.,c,8p.,c,8p.,d,8p.,d,p,c6,d6,d,
8c6,a,8c6,8d6,c,8p.,c,8p.,c,8p.,c,8p.,d,8p.,8a,
8a#,8c6,8c6,8a#,8a,4c6,c,8p.,c,8p.,c,8p.,d,8p.,
d,p,c6,d6,d,8c6,a,8c6,8d6,c,8p.,c,8p.,c,8p.,c,
8p.,8d'
}
}


module Ringtone Output
author MicroBlocks
version 1 2 
depends Tone 
description 'Plays tunes in RTTTL (Ringtone Text Transfer Language) a language developed by Nokia to store ringtones.
Also known as Nokring.'
variables '_RTTTL default duration' '_RTTTL default octave' '_RTTTL bpm' '_RTTTL song name' 

  spec 'r' '_RTTTL parse control from' '_RTTTL parse control from _' 'str' ''
  spec ' ' 'play ringtone' 'play ringtone _' 'str' 'Pacman:d=16,o=6,b=140:
b5,b,f#,d#,8b,8d#,c,c7,g,f,8c7,8e,b5,b,f#,d#,8b,8d#,32d#,32e,f,32f,32f#,g,32g,32g#,a,8b'
  spec 'r' 'current song name' 'current song name'
  spec ' ' '_RTTTL play note' '_RTTTL play note _' 'str' '8c#'

to '_RTTTL parse control from' 'control section' {
  comment 'Extract control section'
  local 'd' 4
  local 'o' 6
  local 'b' 63
  repeatUntil ((size (v 'control section')) == 0) {
    local 'next separator' ('[data:find]' ',' (v 'control section'))
    if ((v 'next separator') == -1) {
      'next separator' = (size (v 'control section'))
    }
    local 'to process' ('[data:copyFromTo]' (v 'control section') 1 (v 'next separator'))
    'control section' = ('[data:copyFromTo]' (v 'control section') ((v 'next separator') + 1))
    'next separator' = ('[data:find]' ',' (v 'to process'))
    if ((v 'next separator') == -1) {
      'next separator' = ((size (v 'to process')) + 1)
    }
    if (('[data:find]' 'd' (v 'to process')) > 0) {
      d = ('[data:copyFromTo]' (v 'to process') (('[data:find]' '=' (v 'to process')) + 1) ((v 'next separator') - 1))
    } (('[data:find]' 'b' (v 'to process')) > 0) {
      b = ('[data:copyFromTo]' (v 'to process') (('[data:find]' '=' (v 'to process')) + 1) ((v 'next separator') - 1))
    } (('[data:find]' 'o' (v 'to process')) > 0) {
      o = ('[data:copyFromTo]' (v 'to process') (('[data:find]' '=' (v 'to process')) + 1) ((v 'next separator') - 1))
    }
  }
  return ('[data:makeList]' d o b)
}

to '_RTTTL play note' note {
  local 'duration' ''
  local 'note name' ''
  local 'octave' (v '_RTTTL default octave')
  local 'ms / whole note' (240000 / (v '_RTTTL bpm'))
  local 'isDotted' (('[data:find]' '.' note) > -1)
  note = ('_trimmedLowercase' note)
  if (note == '') {
    comment 'empty note string; skip'
    return 0
  }
  comment 'parse duration value, if there is one'
  repeatUntil (or (('[data:unicodeAt]' 1 note) < 48) (('[data:unicodeAt]' 1 note) > 57)) {
    duration = ('[data:join]' duration (at 1 note))
    note = ('[data:copyFromTo]' note 2)
  }
  if (duration == '') {
    duration = (v '_RTTTL default duration')
  }
  comment 'parse note name'
  if (or (('[data:find]' '#' note) > -1) (('[data:find]' '_' note) > -1)) {
    'note name' = ('[data:copyFromTo]' note 1 2)
  } else {
    'note name' = (at 1 note)
  }
  note = ('[data:copyFromTo]' note ((size (v 'note name')) + 1))
  comment 'deal with dotted notes'
  if isDotted {
    duration = ((((v 'ms / whole note') / duration) * 15) / 10)
  } else {
    duration = ((v 'ms / whole note') / duration)
  }
  comment 'parse octave, if there is one'
  if (note != '') {
    octave = (at 1 note)
  }
  'play tone' (v 'note name') (octave - 4) duration
}

to 'current song name' {
  return (v '_RTTTL song name')
}

to 'play ringtone' RTTTL {
  comment 'Initialize frequency map.'
  ignoreArgs ('_baseFreqForNote' 'c')
  comment 'Remove song name'
  '_RTTTL song name' = ('[data:copyFromTo]' RTTTL 1 (('[data:find]' ':' RTTTL) - 1))
  RTTTL = ('[data:copyFromTo]' RTTTL ((size (v '_RTTTL song name')) + 2))
  local 'control' ('_RTTTL parse control from' ('[data:copyFromTo]' RTTTL 1 (('[data:find]' ':' RTTTL) - 1)))
  '_RTTTL default duration' = (at 1 control)
  '_RTTTL default octave' = (at 2 control)
  '_RTTTL bpm' = (at 3 control)
  RTTTL = ('[data:copyFromTo]' RTTTL (('[data:find]' ':' RTTTL) + 1))
  repeatUntil ((size RTTTL) == 0) {
    local 'next separator' ('[data:find]' ',' RTTTL)
    if ((v 'next separator') == -1) {
      'next separator' = ((size RTTTL) + 1)
    }
    local 'next note' ('[data:copyFromTo]' RTTTL 1 ((v 'next separator') - 1))
    RTTTL = ('[data:copyFromTo]' RTTTL ((v 'next separator') + 1))
    '_RTTTL play note' (v 'next note')
  }
  '_RTTTL song name' = ''
}


module TFT Output
author MicroBlocks
version 1 5 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  space
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''
variables worm direction apple 

  spec ' ' 'draw worm' 'draw worm'
  spec ' ' 'move worm' 'move worm'
  spec ' ' 'turn left' 'turn left'
  spec ' ' 'turn right' 'turn right'
  spec ' ' 'draw apple' 'draw new apple'
  spec ' ' 'grow worm' 'grow worm'
  spec 'r' 'touching apple' 'touching apple'
  spec ' ' 'new game' 'new game'
  spec 'r' 'worm contains apple' 'worm contains apple'
  spec 'r' 'worm should die' 'worm should die'

to 'draw apple' {
  comment 'needs to make sure apple is in free spot'
  apple = ('[data:makeList]' (random 1 5) (random 1 5))
  if ('worm contains apple') {
    repeatUntil (not ('worm contains apple')) {
      apple = ('[data:makeList]' (random 1 5) (random 1 5))
    }
  }
  '[display:mbPlot]' (at 1 apple) (at 2 apple)
}

to 'draw worm' {
}

to 'grow worm' {
  local 'tail' (at 1 worm)
  local 'new worm' ('[data:makeList]' '')
  for part worm {
    '[data:addLast]' part (v 'new worm')
  }
  'move worm'
  atPut 1 (v 'new worm') tail
  worm = (v 'new worm')
}

to 'move worm' {
  local 'head' (at 'last' worm)
  '[display:mbUnplot]' (at 1 (at 1 worm)) (at 2 (at 1 worm))
  for index ((size worm) - 1) {
    local 'next' 0
    atPut index worm (at (index + 1) worm)
  }
  atPut 'last' worm ('[data:makeList]' ((at 1 head) + (at 1 direction)) ((at 2 head) + (at 2 direction)))
  '[display:mbPlot]' (at 1 (at 'last' worm)) (at 2 (at 'last' worm))
}

to 'new game' {
  '[display:mbDisplayOff]'
  worm = ('[data:makeList]' ('[data:makeList]' 3 3))
  direction = ('[data:makeList]' 1 0)
}

to 'touching apple' {
  local 'head' (at 'last' worm)
  return (and ((at 1 head) == (at 1 apple)) ((at 2 head) == (at 2 apple)))
}

to 'turn left' {
  if ((at 1 direction) == 1) {
    direction = ('[data:makeList]' 0 -1)
  } ((at 2 direction) == -1) {
    direction = ('[data:makeList]' -1 0)
  } ((at 1 direction) == -1) {
    direction = ('[data:makeList]' 0 1)
  } else {
    direction = ('[data:makeList]' 1 0)
  }
}

to 'turn right' {
  if ((at 1 direction) == 1) {
    direction = ('[data:makeList]' 0 1)
  } ((at 2 direction) == 1) {
    direction = ('[data:makeList]' -1 0)
  } ((at 1 direction) == -1) {
    direction = ('[data:makeList]' 0 -1)
  } else {
    direction = ('[data:makeList]' 1 0)
  }
}

to 'worm contains apple' {
  for part worm {
    if (and ((at 1 part) == (at 1 apple)) ((at 2 part) == (at 2 apple))) {return (booleanConstant true)}
  }
  return (booleanConstant false)
}

to 'worm should die' {
  local 'head' (at 'last' worm)
  if (or (or ((at 1 head) > 5) ((at 2 head) > 5)) (or ((at 1 head) < 1) ((at 2 head) < 1))) {
    return (booleanConstant true)
  }
  for index ((size worm) - 1) {
    local 'part' (at index worm)
    if (and ((at 1 part) == (at 1 head)) ((at 2 part) == (at 2 head))) {
      return (booleanConstant true)
    }
  }
  return (booleanConstant false)
}

script 50 50 {
comment 'The classic Snake game, but in a smaller scale!'
}

script 50 107 {
whenStarted
'new game'
forever {
  'draw apple'
  repeatUntil ('touching apple') {
    'move worm'
    waitMillis 500
    if ('worm should die') {
      '[display:mbDisplay]' 18284874
      waitUntil (or (buttonA) (buttonB))
      'new game'
    } ((size worm) == 24) {
      '[display:mbDisplay]' 15237450
      waitUntil (or (buttonA) (buttonB))
      'new game'
    }
  }
  'grow worm'
}
}

script 452 109 {
whenButtonPressed 'A'
'turn left'
}

script 452 213 {
whenButtonPressed 'B'
'turn right'
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 2 0 
description ''
variables 'reaction time' remark 'start time' 

script 152 50 {
whenButtonPressed 'A'
sayIt ''
waitMillis (random 500 2000)
setUserLED true
resetTimer
waitUntil (buttonA)
'reaction time' = (timer)
if ((v 'reaction time') < 150) {
  remark = 'Impressive!'
} ((v 'reaction time') < 200) {
  remark = 'Not bad...'
} ((v 'reaction time') < 350) {
  remark = 'Come on! My grandmother could do better than that.'
} else {
  remark = 'WAY too slow! Are you even awake?'
}
sayIt (v 'reaction time') 'msecs.' remark
waitUntil (not (buttonA))
setUserLED false
}

module main
author unknown
version 1 0 
description ''

script 50 50 {
whenButtonPressed 'A'
'[display:mbDisplay]' 15237450
waitMillis 1000
'[display:mbDisplayOff]'
}

script 50 262 {
whenButtonPressed 'B'
'[display:mbDisplay]' 18284874
waitMillis 1000
'[display:mbDisplayOff]'
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''

script 50 50 {
whenButtonPressed 'A'
repeatUntil (not (buttonA)) {
  '[display:mbDisplay]' 145728
  waitMillis 250
  '[display:mbDisplay]' 4685802
  waitMillis 250
  '[display:mbDisplayOff]'
  waitMillis 300
}
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author 'Roger Wagner'
version 1 0 
description ''
variables CharacterList CharacterNames TPin KeyboardOn folder IRCodeList IRNameList KeyPosition VolLevel ToneFreqList ToneNameList NeoPixelsOn NumberOfNeopixels PreviousPinTouched MenuNumber CharPosn MakerPortSpeakerOn MenuEnableOn MicrophoneConnected Mp3Volume ToneVolume MyFolderPresent TimeStart MyFolder ReadyForTasks DistanceSensorConnected ReleasedTPin PrevVolume IRCodeReceived 

  spec ' ' 'Initialize lists' 'Initialize lists'
  spec ' ' 'NeoPixel initialize' 'NeoPixel initialize'
  spec ' ' 'DoMenus' 'DoMenus'
  spec ' ' 'MenuAction1' 'MenuAction1'
  spec ' ' 'MenuAction2' 'MenuActionRing'
  spec ' ' 'MenuAction3' 'MenuActionServoTest'
  spec ' ' 'MenuAction4' 'MenuActionMicrophone'
  spec ' ' 'MenuAction5' 'MenuActionDistance'
  spec ' ' 'MenuAction6' 'MenuAction6'
  spec ' ' 'MakerPort Setup' 'MakerPort Setup'
  spec ' ' 'MicrophoneDetect' 'MicrophoneDetect'
  spec ' ' 'IsThereMyFolder' 'IsThereMyFolder'
  spec ' ' 'PinKeyTouched' 'PinKeyTouched'
  spec ' ' 'UpArrowVolume' 'UpArrowVolume'
  spec ' ' 'DownArrowVolume' 'DownArrowVolume'

to DoMenus {
  MenuNumber += 1
  if MakerPortSpeakerOn {
    makerport_setAudioSource 'Tone'
    makerport_beep 880 100 ToneVolume
    if (makerport_mp3_hasCard) {
      makerport_setAudioSource 'MP3'
    }
  }
  if (MenuNumber == 1) {
    LCD1602_write 'Menu1' 1
    LCD1602_write '(press again)' 2
    MenuAction1
  }
  if (MenuNumber == 2) {
    LCD1602_write 'Menu2' 1
    if DistanceSensorConnected {
      LCD1602_write 'Distance' 2
      MenuAction5
    } else {
      if NeoPixelsOn {
        LCD1602_write 'Ring Test' 2
        MenuAction2
      }
    }
  }
  if (MenuNumber == 3) {
    LCD1602_write 'Menu3' 1
    LCD1602_write 'Servo Test' 2
    MenuAction3
  }
  if (MenuNumber == 4) {
    if MicrophoneConnected {
      LCD1602_write 'Menu4' 1
      LCD1602_write 'Mic Test' 2
      MenuAction4
    } else {
      MenuNumber = 5
    }
  }
  if (MenuNumber == 5) {
    LCD1602_write 'Piano' 1
    LCD1602_write ' ' 2
    comment 'last menu item'
    MenuNumber = 0
    waitMillis 1000
  }
}

to DownArrowVolume {
  if (makerport_mp3_hasCard) {
    Mp3Volume += -5
    if (Mp3Volume < 0) {
      Mp3Volume = 0
    }
    mp3_setVolume Mp3Volume
    mp3_playTrack 1 51
    LCD1602_write_field ('[data:join]' 'V' Mp3Volume) 1 14 16
  } else {
    ToneVolume += -2
    if (ToneVolume < 0) {
      ToneVolume = 0
    }
    makerport_beep 392 100 ToneVolume
    LCD1602_write_field ('[data:join]' 'V' ToneVolume) 1 14 16
  }
}

to 'Initialize lists' {
  CharacterNames = ('[data:makeList]' 'left' 'up' 'right' 'down' 'space' 'click' 'w' 'a' 's' 'd' 'f' 'g')
  CharacterList = ('[data:makeList]' 216 218 215 217 ' ' 'click' 'w' 'a' 's' 'd' 'f' 'g')
  IRCodeList = ('[data:makeList]' 22 25 13 12 24 94 8 28 90 82 66 74 68 67 70 21 64)
  IRNameList = ('[data:makeList]' 1 2 3 4 5 6 7 8 9 0 '*' '#' 'left' 'right' 'up' 'down' 'OK')
  comment 'https://pages.mtu.edu/~suits/notefreqs.html'
  ToneFreqList = ('[data:makeList]' 262 294 330 349 392 440 494 523 587 659 698 784 880 988 1047 1175 1319)
  ToneNameList = ('[data:makeList]' 'C4' 'D4' 'E4' 'F4' 'G4' 'A4' 'B4' 'C5' 'D5' 'E5' 'F5' 'G5' 'A5' 'B5' 'C6' 'D6' 'E6')
}

to IsThereMyFolder {
  if (makerport_mp3_hasCard) {
    resetTimer
    TimeStart = (timer)
    mp3_playTrackUntilDone 99 MyFolder
    comment 'not present 420, present: >600, '
    if (((timer) - TimeStart) > 500) {
      MyFolderPresent = (booleanConstant true)
    } else {
      MyFolderPresent = (booleanConstant false)
    }
    waitMillis 1000
  } else {
    MyFolderPresent = (booleanConstant false)
  }
}

to 'MakerPort Setup' {
  if (LCD1602_isConnected) {
    LCD1602_clear
    LCD1602_write ' Welcome to the' 1
    LCD1602_write '   MakerPort!' 2
    MenuEnableOn = (booleanConstant true)
  } else {
    MenuEnableOn = (booleanConstant false)
  }
  if MakerPortSpeakerOn {
    if (makerport_mp3_hasCard) {
      mp3_setVolume Mp3Volume
      mp3_playTrack 3 99
      MicrophoneDetect
      waitMillis 3000
    } else {
      comment 'C4'
      makerport_beep 262 250
      comment 'G4'
      makerport_beep 392 250
      comment 'F4'
      makerport_beep 349 250
    }
  }
}

to MenuAction1 {
  comment 'nothing more to do here...'
}

to MenuAction2 {
  for i 12 {
    CharPosn = ('[misc:rescale]' i 1 12 6 16)
    LCD1602_write_field '.' 1 CharPosn CharPosn
    'NeoPixel initialize'
    waitMillis 250
  }
  LCD1602_write_field '(next)' 2 11 16
}

to MenuAction3 {
  repeat 3 {
    setServoAngle 16 0
    setServoAngle 17 0
    waitMillis 500
    setServoAngle 16 90
    setServoAngle 17 90
    waitMillis 500
    setServoAngle 16 0
    setServoAngle 17 0
    waitMillis 500
  }
  stopServo 16
  stopServo 17
  LCD1602_write_field '(next)' 2 11 16
}

to MenuAction4 {
  mp3_playTrack 1 99
  comment 'loop for 10 seconds @ 1/8 sec per loop'
  for i (8 * 10) {
    CharPosn = ('[misc:rescale]' i 1 (8 * 10) 6 16)
    LCD1602_write_field '.' 1 CharPosn CharPosn
    VolLevel = (makerport_timeAveragedLevel 13 64)
    setServoAngle 16 ('[misc:rescale]' VolLevel 0 50 0 90)
    LCD1602_write_field ('[data:join]' 'Vol:' VolLevel) 2 10 16
  }
  LCD1602_write_field '(next)' 2 10 16
}

to MenuAction5 {
  comment 'loop for 10 seconds @ 1/4 sec per loop'
  for i (10 * 4) {
    CharPosn = ('[misc:rescale]' i 1 (10 * 4) 6 16)
    LCD1602_write_field '.' 1 CharPosn CharPosn
    LCD1602_write_field ('[data:join]' 'Distance:' ('distance (cm)' 14 15)) 2 1 16
    waitMillis 250
  }
  LCD1602_write_field '(next)' 2 11 16
}

to MenuAction6 {
}

to MicrophoneDetect {
  MicrophoneConnected = (booleanConstant false)
  comment '1st sample to calibrate background sound level'
  PrevVolume = (makerport_timeAveragedLevel 13 125)
  repeat 10 {
    VolLevel = (absoluteValue (PrevVolume - (makerport_timeAveragedLevel 13 25)))
    printIt VolLevel
    if (10 < VolLevel) {
      comment 'difference > threshold?'
      MicrophoneConnected = (booleanConstant true)
      return MicrophoneConnected
    }
    PrevVolume = (makerport_timeAveragedLevel 13 25)
  }
}

to 'NeoPixel initialize' {
  comment 'P14 = Extra port'
  neoPixelAttach 24 14
  for i NumberOfNeopixels {
    setNeoPixelColor i (randomColor)
  }
}

to PinKeyTouched {
  if MakerPortSpeakerOn {
    if (makerport_mp3_hasCard) {
      if (TPin != 12) {sendBroadcast 'PlayTrack'}
    } else {
      makerport_beep (at TPin ToneFreqList) 100 ToneVolume
      digitalWriteOp TPin false
    }
    if (and (TPin == 12) (makerport_mp3_hasCard)) {
      folder += 1
      if (folder > 54) {
        folder = 51
      }
      LCD1602_write_field ('[data:join]' 'Folder:' folder) 2 8 16
      mp3_playTrack 99 folder
    }
  }
}

to UpArrowVolume {
  if (makerport_mp3_hasCard) {
    Mp3Volume += 5
    if (Mp3Volume > 30) {
      Mp3Volume = 30
    }
    mp3_setVolume Mp3Volume
    mp3_playTrack 1 51
    LCD1602_write_field ('[data:join]' 'V' Mp3Volume) 1 14 16
  } else {
    ToneVolume += 2
    if (ToneVolume > 10) {
      ToneVolume = 10
    }
    makerport_beep 392 100 ToneVolume
    LCD1602_write_field ('[data:join]' 'V' ToneVolume) 1 14 16
  }
}

script 53 50 {
whenStarted
comment 'MakerPort Startup Program v11.13.23'
ReadyForTasks = (booleanConstant false)
KeyboardOn = (booleanConstant true)
MakerPortSpeakerOn = (booleanConstant true)
MicrophoneConnected = (booleanConstant false)
DistanceSensorConnected = (booleanConstant false)
MyFolderPresent = (booleanConstant false)
MenuEnableOn = (booleanConstant true)
PreviousPinTouched = 0
MenuNumber = 0
Mp3Volume = 30
ToneVolume = 5
folder = 51
MyFolder = 1
'Initialize lists'
comment 'Neopixels OR ultrasonic in Extra port'
if (('distance (cm)' 14 15) == 0) {
  NeoPixelsOn = (booleanConstant true)
  DistanceSensorConnected = (booleanConstant false)
} else {
  NeoPixelsOn = (booleanConstant false)
  DistanceSensorConnected = (booleanConstant true)
}
NumberOfNeopixels = 24
makerport_initialize
'MakerPort Setup'
if NeoPixelsOn {
  'NeoPixel initialize'
}
IsThereMyFolder
ReadyForTasks = (booleanConstant true)
if (makerport_mp3_hasCard) {
  if MyFolderPresent {
    LCD1602_write ' Auto-Play Mode' 1
    LCD1602_write_field 'Ready...' 2 1 10
    makerport_setAllLEDs true
    mp3_repeatAllInFolder MyFolder
    sendBroadcast 'ServoLightShow'
  } else {
    LCD1602_write 'Ready...' 1
    LCD1602_write_field ('[data:join]' '       Folder:' folder) 2 1 16
  }
} else {
  LCD1602_write 'Ready...' 1
  LCD1602_write '' 2
}
sendBroadcast 'WatchForTouch'
sendBroadcast 'WatchForIRCommand'
}

script 684 195 {
to makerport_initialize {}
}

script 1028 202 {
whenBroadcastReceived 'WatchForIRCommand'
forever {
  waitMillis 5
  if (and (ir_code_received) ReadyForTasks) {
    stopAll
    digitalWriteOp TPin false
    IRCodeReceived = (ir_last_code)
    LCD1602_write ('[data:join]' 'IR code:' IRCodeReceived) 1
    KeyPosition = ('[data:find]' IRCodeReceived IRCodeList)
    if (KeyPosition <= 12) {
      TPin = KeyPosition
      digitalWriteOp TPin true
      PinKeyTouched
    } else {
      TPin = 0
    }
    if (KeyPosition == 15) {
      comment 'up arrow = increase volume'
      UpArrowVolume
    }
    if (KeyPosition == 16) {
      comment 'down arrow = decrease volume'
      DownArrowVolume
    }
    if (KeyPosition > 0) {
      LCD1602_write_field ('[data:join]' KeyPosition ',' (at KeyPosition IRNameList)) 2 1 7
    } else {
      LCD1602_write ('[data:join]' KeyPosition ', not found') 2
    }
    sendBroadcast 'WatchForTouch'
  }
}
}

script 1582 206 {
to UpArrowVolume {}
}

script 697 516 {
to 'MakerPort Setup' {}
}

script 1583 752 {
to DownArrowVolume {}
}

script 705 1153 {
to 'NeoPixel initialize' {}
}

script 51 1297 {
whenBroadcastReceived 'ServoLightShow'
comment 'servos respond to sound'
VolLevel = (makerport_timeAveragedLevel 13 125)
forever {
  comment 'servos respond to sound'
  VolLevel = (makerport_timeAveragedLevel 13 64)
  setServoAngle 16 ('[misc:rescale]' VolLevel 0 100 0 90)
  LCD1602_write_field ('[data:join]' 'Vol:' VolLevel) 2 10 16
  'NeoPixel initialize'
}
}

script 701 1329 {
to MicrophoneDetect {}
}

script 53 1607 {
to 'Initialize lists' {}
}

script 699 1815 {
whenBroadcastReceived 'WatchForRelease'
forever {
  if ReadyForTasks {
    if (touch_release_event) {
      ReleasedTPin = (touch_last_released_pin)
      if KeyboardOn {
        if (ReleasedTPin == 6) {
          '[hid:mouseRelease]'
        } else {
          '[hid:releaseKey]' (at ReleasedTPin CharacterList)
        }
      }
    }
    waitMillis 10
    sendBroadcast 'WatchForIRCommand'
  }
}
}

script 61 2058 {
whenBroadcastReceived 'WatchForTouch'
forever {
  waitMillis 5
  if (and (touch_touch_event) ReadyForTasks) {
    stopAll
    comment 'Cancel auto-play if a touchpoint is touched'
    MyFolderPresent = (booleanConstant false)
    TPin = (touch_last_touched_pin)
    makerport_setAllLEDs false
    if (TPin != 11) {
      MenuNumber = 0
    }
    if (and MenuEnableOn (and (TPin == 11) (PreviousPinTouched == 11))) {
      DoMenus
    }
    PreviousPinTouched = TPin
    if (MenuNumber == 0) {
      digitalWriteOp TPin true
      LCD1602_write_field ('[data:join]' 'Touch:' TPin) 1 1 16
      LCD1602_write_field (at TPin CharacterNames) 2 1 16
      comment 'KeyboardOn = true to output characters'
      if KeyboardOn {
        if (TPin == 6) {
          'mouse click' 'left'
        } else {
          '[hid:holdKey]' (at TPin CharacterList)
        }
      }
      PinKeyTouched
      sendBroadcast 'WatchForRelease'
    }
  }
}
}

script 787 2304 {
to IsThereMyFolder {}
}

script 793 2761 {
to PinKeyTouched {}
}

script 50 3083 {
whenBroadcastReceived 'PlayTrack'
makerport_setAudioSource 'MP3'
mp3_playTrackUntilDone TPin folder
makerport_setAllLEDs false
LCD1602_clear
LCD1602_write_field 'Ready...' 1 1 10
}

script 532 3275 {
to MenuAction1 {}
}

script 54 3290 {
to DoMenus {}
}

script 536 3390 {
to MenuAction5 {}
}

script 539 3701 {
to MenuAction2 {}
}

script 546 3944 {
to MenuAction3 {}
}

script 321 4322 {
sayIt DistanceSensorConnected
}

script 557 4350 {
to MenuAction4 {}
}


module 'Distance (HC-SR04)' Input
author 'Joan GuillÃ©n & Josep FerrÃ ndiz'
version 1 2 
tags sensor 'hc-sr04' distance ultrasound 
description 'Support for the HC-SR04 ultrasound distance sensor.'
variables _sr04_last 

  spec 'r' 'distance (cm)' 'distance (cm) trigger _ echo _' 'num num' 2 4
  spec 'r' 'sr04_distanceOnePin' 'distance (cm) pin _' 'num' 0

to 'distance (cm)' trig ech {
  comment 'Contributed by Joan GuillÃ©n and Josep FerrÃ ndiz'
  digitalWriteOp trig false
  waitMicros 2
  digitalWriteOp trig true
  waitMicros 50
  digitalWriteOp trig false
  local 'start' (microsOp)
  waitUntil (or (not (digitalReadOp ech)) (((microsOp) - start) > 23320))
  waitUntil (or (digitalReadOp ech) (((microsOp) - start) > 23320))
  if (((microsOp) - start) > 23320) {
    comment 'Distance sensor not ready; return the last distance reading'
    return _sr04_last
  }
  comment 'Pulse sent. Measure time until echo is detected.'
  start = (microsOp)
  waitUntil (or (not (digitalReadOp ech)) (((microsOp) - start) > 23320))
  _sr04_last = ((10 * ((microsOp) - start)) / 583)
  comment 'Leave some time for reverberations to die away.'
  waitMillis 10
  if (_sr04_last == 0) {
    zeroCount += 1
  }
  return _sr04_last
}

to sr04_distanceOnePin pin {
  return ('distance (cm)' pin pin)
}


module 'IR Remote' Comm
author MicroBlocks
version 1 5 
tags ir infrared remote 
description 'Sends and receives infrared remote control messages like the ones used for TV sets or air conditioners. Currently supports only the NEC protocol, which is quite common but not the only IR protocol in use. An NEC message consists of a one byte device number and a one byte command.

Note: Transmitting IR does not work on ESP8266 boards.

Receiving requires an IR receiver module, such as those built into the Circuit Playground Express and ED1 boards. Transmitting requires an IR transmitter LED, such as those built into the Circuit Playground Express and several M5 Stack products. Inexpensive IR LED transmitter and receivers are available for use with other boards.'
variables _ir_pin _ir_pulse_times _ir_last_code _ir_last_device _ir_transmit_pin 

  spec ' ' 'attachIR' 'attach IR receiver to pin _' 'num' 0
  spec 'r' 'ir_code_received' 'IR code received?'
  spec 'r' 'ir_last_code' 'IR code'
  space
  spec ' ' 'IR_Transmit' 'IR transmit device _ command _' 'num num' 48896 1
  spec ' ' 'attachIRTransmitter' 'attach IR transmitter to pin _' 'num' 0
  space
  spec 'r' 'receiveIR' 'receive IR code'
  space
  spec ' ' '_testIR' '_test IR'
  spec 'r' '_receiveIRFromDevice' '_receive IR code from device _' 'num' 48896
  space
  spec ' ' '_captureIRMessage' '_captureIRMessage' 'any'
  spec ' ' '_dumpIR' '_dumpIR' 'any'
  spec 'r' '_getIRByte' '_getIRByte _' 'auto any' 4
  spec 'r' '_got32Bits' '_got32Bits' 'any'
  spec ' ' '_IR_SendByte' '_IR_SendByte _' 'auto' '10'

to IR_Transmit device command {
  if (_ir_transmit_pin == 0) {if (or ((boardType) == 'CircuitPlayground') ((boardType) == 'M5Atom-Matrix')) {
    _ir_transmit_pin = 12
  } (or ((boardType) == 'M5StickC') ((boardType) == 'M5StickC+')) {
    _ir_transmit_pin = 9
  }}
  comment 'Message start pulse and space'
  '[io:playTone]' _ir_transmit_pin 38000
  waitMicros 9000
  '[io:playTone]' _ir_transmit_pin 0
  waitMicros 4500
  comment 'Send device and command and their inverses'
  '_IR_SendByte' (device & 255)
  '_IR_SendByte' ((device >> 8) & 255)
  '_IR_SendByte' command
  '_IR_SendByte' ('~' command)
  comment 'Send stop bit'
  '[io:playTone]' _ir_transmit_pin 38000
  waitMicros 562
  '[io:playTone]' _ir_transmit_pin 0
  comment 'Turn off IR transmit LED'
  if (or ((boardType) == 'M5StickC') ((boardType) == 'M5StickC+')) {
    comment 'IR pin is inverted so true means "off"'
    digitalWriteOp _ir_transmit_pin true
  } else {
    digitalWriteOp _ir_transmit_pin false
  }
}

to '_IR_SendByte' byte {
  local 'bit' 1
  repeat 8 {
    if (0 == (byte & bit)) {
      '[io:playTone]' _ir_transmit_pin 38000
      waitMicros 530
      '[io:playTone]' _ir_transmit_pin 0
      waitMicros 530
    } else {
      '[io:playTone]' _ir_transmit_pin 38000
      waitMicros 530
      '[io:playTone]' _ir_transmit_pin 0
      waitMicros 1630
    }
    bit = (bit << 1)
  }
}

to '_captureIRMessage' {
  if (_ir_pulse_times == 0) {
    _ir_pulse_times = (newList 200)
    if (_ir_pin == 0) {
      if ((boardType) == 'CircuitPlayground') {
        _ir_pin = 11
      } ((boardType) == 'Citilab ED1') {
        _ir_pin = 35
      } ((boardType) == 'D1-Mini') {
        _ir_pin = 2
      } ((boardType) == 'MakerPort') {
        _ir_pin = 18
      }
    }
  }
  fillList _ir_pulse_times 0
  local 'i' 1
  comment 'Wait for IR signal -- this is the start of a new message.
Note: THe pin goes low when an IR signal is detected.'
  waitUntil (not (digitalReadOp _ir_pin))
  local 'start' (microsOp)
  forever {
    comment 'Record the time until the end of the current IR pulse ("mark")'
    waitUntil (digitalReadOp _ir_pin)
    local 'end' (microsOp)
    atPut i _ir_pulse_times (end - start)
    i += 1
    start = end
    comment 'Record time until the start of the next IR pulse ("space")'
    repeatUntil (not (digitalReadOp _ir_pin)) {
      if (((microsOp) - start) > 5000) {
        comment 'No IR pulse for 5000 usecs means "end of message"'
        return 0
      }
    }
    local 'end' (microsOp)
    atPut i _ir_pulse_times (end - start)
    i += 1
    start = end
  }
}

to '_dumpIR' {
  comment 'Print raw pulse timings to the terminal.
Can be used to analyze new protocols.'
  local 'i' 1
  printIt '-----'
  repeat (size _ir_pulse_times) {
    local 'mark usecs' (at i _ir_pulse_times)
    local 'space usecs' (at (i + 1) _ir_pulse_times)
    printIt (v 'mark usecs') (v 'space usecs')
    i += 2
    if ((v 'space usecs') == 0) {
      printIt 'timing entries:' (i - 2)
      return 0
    }
  }
}

to '_getIRByte' position {
  local 'result' 0
  local 'i' position
  local 'bit' 1
  repeat 8 {
    if ((at i _ir_pulse_times) > 1000) {result = (result | bit)}
    bit = (bit << 1)
    i += 2
  }
  return result
}

to '_got32Bits' {
  return (and ((at 67 _ir_pulse_times) != 0) ((at 68 _ir_pulse_times) == 0))
}

to '_receiveIRFromDevice' deviceID {
  forever {
    '_captureIRMessage'
    if ('_got32Bits') {
      local 'id_lowByte' ('_getIRByte' 4 nil)
      local 'id_highByte' ('_getIRByte' 20 nil)
      if (and (id_highByte == (deviceID >> 8)) (id_lowByte == (deviceID & 255))) {
        return ('_getIRByte' 36 nil)
      }
    }
  }
}

to '_testIR' {
  forever {
    '_captureIRMessage'
    if ('_got32Bits') {
      comment 'Four byte message format:
<device low byte><device high byte><command><command, bit-inverted>'
      local 'b1' ('_getIRByte' 4 nil)
      local 'b2' ('_getIRByte' 20 nil)
      local 'b3' ('_getIRByte' 36 nil)
      local 'b4' ('_getIRByte' 52 nil)
      sayIt 'Device:' ((b2 << 8) | b1) 'code:' b3
    }
  }
}

to attachIR pin {
  _ir_pin = pin
}

to attachIRTransmitter pin {
  _ir_transmit_pin = pin
}

to ir_code_received {
  return ((receiveIR) >= 0)
}

to ir_last_code {
  return _ir_last_code
}

to receiveIR {
  forever {
    '_captureIRMessage'
    if ('_got32Bits') {
      local 'id_lowByte' ('_getIRByte' 4 nil)
      local 'id_highByte' ('_getIRByte' 20 nil)
      _ir_last_device = ((id_highByte << 8) | id_lowByte)
      _ir_last_code = ('_getIRByte' 36 nil)
      atPut 'all' _ir_pulse_times 0
      return _ir_last_code
    }
  }
}


module 'Keyboard and Mouse' Comm
author MicroBlocks
version 1 5 
choices keyModifiers Shift Control 'Alt / â¥' 'Logo / â' AltGr 
choices mouseButtons left right middle both 
choices specialKeys 'enter:10' 'return:13' 'tab:179' 'backspace:178' 'delete:212' 'insert:209' 'home:210' 'end:213' 'PgUp:211' 'PgDown:214' 'â:215' 'â:216' 'â:217' 'â:218' 'F1:194' 'F2:195' 'F3:196' 'F4:197' 'F5:198' 'F6:199' 'F7:200' 'F8:201' 'F9:202' 'F10:203' 'F11:204' 'F12:205' 'CapsLock:193' 'NumLock:219' 'ScrollLock:207' 'PrintScreen:206' 'ESC:177' 
description 'This library can send mouse and keyboard events to a computer over USB (i.e. it emulates a USB HID device) on boards with the necessary hardware. It currently works on RP2040 and SAMD21 boards such as the Adafruit Circuit Playground Express, Trinket M0, and Metro M0 Express. It also works on the MakerPort.

It is based on the Arduino Mouse and Keyboard libraries. The list of special, non-ascii keys and modifiers is here:

https://www.arduino.cc/reference/en/language/functions/usb/keyboard/keyboardmodifiers/
'

  spec ' ' 'press key' 'press key _ : while holding _' 'auto.specialKeys menu.keyModifiers' 'n' 'Shift'
  spec ' ' '[hid:holdKey]' 'hold key _' 'auto.specialKeys' 'A'
  spec ' ' '[hid:releaseKey]' 'release key _' 'auto.specialKeys' 'A'
  spec ' ' '[hid:releaseKeys]' 'release all keys'
  space
  spec ' ' 'mouse click' '_ mouse click' 'menu.mouseButtons' 'left'
  spec ' ' '[hid:mouseMove]' 'move mouse pointer by _ , _' 'num num' 10 -20
  spec ' ' '[hid:mouseScroll]' 'scroll mouse by _' 'num' -5
  spec ' ' 'mouse hold' 'hold _ mouse button' 'menu.mouseButtons' 'left'
  spec ' ' '[hid:mouseRelease]' 'release mouse buttons'

to 'mouse click' which {
  '[hid:mousePress]' ('[data:find]' which ('[data:makeList]' 'left' 'right' 'both' 'middle'))
  waitMillis 50
  '[hid:mouseRelease]'
}

to 'mouse hold' which {
  '[hid:mousePress]' ('[data:find]' which ('[data:makeList]' 'left' 'right' 'both' 'middle'))
}

to 'press key' key modifier {
  '[hid:pressKey]' key ('[data:find]' modifier ('[data:makeList]' 'Shift' 'Control' 'Alt / â¥' 'Logo / â' 'AltGr'))
}


module 'LCD Display' Output
author MicroBlocks
version 1 5 
description 'Library for 16x2 LCD text displays with 1602 controller I2C "backpack" like the ones from DFRobot, SunFounder, and others. These displays have two lines of sixteen characters.

Most of these displays require 5 volts to provide sufficient LCD contrast, so you will need an external power source for 3.3v boards like the micro:bit.'
variables _LCD1602_ADDR _LCD1602_LINE1 _LCD1602_LINE2 _LCD1602_LOCK_MSECS 

  spec ' ' 'LCD1602_write' 'write _ on LCD line _' 'str num num num' 'Hello, World!' 1 1 16
  spec ' ' 'LCD1602_write_field' 'write field _ on LCD line _ from _ to _' 'str num num num' 'Moon!' 1 8 12
  spec ' ' 'LCD1602_clear' 'clear LCD'
  spec 'r' 'LCD1602_isConnected' 'is LCD connected?'
  spec 'r' '_LCD1602 init' '_LCD1602 init'
  spec ' ' '_LCD1602 send' '_LCD1602 send byte _ mode _' 'num num' 10 1
  spec ' ' '_LCD1602 toggle enable' '_LCD1602 toggle enable _' 'num' 10

to LCD1602_clear {
  if (not ('_LCD1602 init')) {return}
  waitUntil (((millisOp) - _LCD1602_LOCK_MSECS) > 500)
  _LCD1602_LOCK_MSECS = (millisOp)
  _LCD1602_LINE1 = ('[data:newByteArray]' 16 32)
  _LCD1602_LINE2 = ('[data:newByteArray]' 16 32)
  '_LCD1602 send' 1 0
  _LCD1602_LOCK_MSECS = 0
}

to LCD1602_isConnected {
  return ('_LCD1602 init')
}

to LCD1602_write string line {
  LCD1602_write_field string line 1 16
}

to LCD1602_write_buffer line {
  local 'bytes' 0
  if (line == 1) {
    '_LCD1602 send' (hexToInt '80') 0
    bytes = _LCD1602_LINE1
  } else {
    '_LCD1602 send' (hexToInt 'C0') 0
    bytes = _LCD1602_LINE2
  }
  for b bytes {
    '_LCD1602 send' b 1
  }
}

to LCD1602_write_field string line start end {
  if (not ('_LCD1602 init')) {return}
  string = ('[data:join]' '' string)
  if (or (start < 1) (start > 16)) {
    return
  }
  if (or (end < start) (end > 16)) {
    return
  }
  if (line == 1) {
    bytes = _LCD1602_LINE1
  } else {
    bytes = _LCD1602_LINE2
  }
  waitUntil (((millisOp) - _LCD1602_LOCK_MSECS) > 500)
  _LCD1602_LOCK_MSECS = (millisOp)
  local 'count' ((end - start) + 1)
  for i count {
    local 'char' 32
    if (i <= (size string)) {
      char = ('[data:unicodeAt]' i string)
      if (char > 127) {
        char = 32
      }
    }
    atPut ((start - 1) + i) bytes char
  }
  LCD1602_write_buffer line
  _LCD1602_LOCK_MSECS = 0
}

to '_LCD1602 init' {
  comment 'Return true if already initialized'
  if (_LCD1602_ADDR != 0) {
    return true
  }
  comment 'Use slow I2C speed'
  '[sensors:i2cSetClockSpeed]' 100000
  comment 'Try two common I2C addresses and
use the one that gets a response'
  _LCD1602_ADDR = (hexToInt '27')
  if ((i2cGet _LCD1602_ADDR 0) < 0) {
    _LCD1602_ADDR = (hexToInt '3F')
  }
  if ((i2cGet _LCD1602_ADDR 0) < 0) {
    _LCD1602_ADDR = 0
    comment 'LCD panel not found'
    return false
  }
  _LCD1602_LINE1 = ('[data:newByteArray]' 16 32)
  _LCD1602_LINE2 = ('[data:newByteArray]' 16 32)
  comment 'Initialize display'
  '_LCD1602 send' (hexToInt '33') 0
  '_LCD1602 send' (hexToInt '32') 0
  '_LCD1602 send' (hexToInt '06') 0
  '_LCD1602 send' (hexToInt '0C') 0
  '_LCD1602 send' (hexToInt '28') 0
  '_LCD1602 send' (hexToInt '01') 0
  '[sensors:i2cSetClockSpeed]' 400000
  waitMillis 250
  return true
}

to '_LCD1602 send' bits mode {
  comment 'Use slow I2C speed'
  '[sensors:i2cSetClockSpeed]' 100000
  local '_LCD1602 BACKLIGHT' (hexToInt '8')
  local 'high bits' ((mode | (bits & (hexToInt 'F0'))) | (v '_LCD1602 BACKLIGHT'))
  local 'low bits' ((mode | ((bits << 4) & (hexToInt 'F0'))) | (v '_LCD1602 BACKLIGHT'))
  '[sensors:i2cWrite]' _LCD1602_ADDR (v 'high bits')
  '_LCD1602 toggle enable' (v 'high bits')
  '[sensors:i2cWrite]' _LCD1602_ADDR (v 'low bits')
  '_LCD1602 toggle enable' (v 'low bits')
  comment 'Revert to fast I2C speed'
  '[sensors:i2cSetClockSpeed]' 400000
  waitMillis 1
}

to '_LCD1602 toggle enable' bits {
  local '_LCD1602 ENABLE' 4
  waitMicros 5
  '[sensors:i2cWrite]' _LCD1602_ADDR (bits | (v '_LCD1602 ENABLE'))
  waitMicros 5
  '[sensors:i2cWrite]' _LCD1602_ADDR (bits & ('~' (v '_LCD1602 ENABLE')))
  waitMicros 5
}


module 'MP3 Player' Output
author MicroBlocks
version 1 10 
choices mp3PlayerType MakerPort 'MakerBit/HyperDuino' DFRobot Octopus 
description 'Support for Octopus (FN-M16P and YX6300 chips) and DFRobot/HyperDuino/MakerBit/MakerPort) MP3 Players (YX5300, A19HFA440, and GD3300B chips).

Sends commands to MP3 player using software serial via any digital pin on any board.

To use the "mp3 play ... until done" block, connect TX of MP3 player to a second pin and set that pin as the optional "rx pin" in the "mp3 initialize" block .
'
variables _mp3UseChecksum _mp3Pin _mp3RxPin 

  spec ' ' 'mp3_initialize' 'mp3 initialize _ pin _ : rx pin _' 'menu.mp3PlayerType num num' 'MakerPort' 20 21
  spec ' ' 'mp3_setVolume' 'mp3 set volume _ (0-30)' 'num' 20
  space
  spec ' ' 'mp3_playTrack' 'mp3 play track _ in folder _' 'num num' 1 1
  spec ' ' 'mp3_playTrackUntilDone' 'mp3 play track _ in folder _ until done' 'num num' 1 1
  space
  spec ' ' 'mp3_nextTrack' 'mp3 play next track'
  spec ' ' 'mp3_repeatAllInFolder' 'mp3 repeat all in folder _' 'num' 1
  space
  spec ' ' 'mp3_pause' 'mp3 pause'
  spec ' ' 'mp3_resume' 'mp3 resume'
  space
  spec ' ' '_mp3_sendMP3Cmd' '_mp3_sendMP3Cmd _ _ _' 'auto num num' '0x0C' 0 0
  spec ' ' '_mp3_waitForResponse' '_mp3_waitForResponse'

to '_mp3_sendMP3Cmd' cmd arg1 arg2 {
  if (_mp3UseChecksum == 0) {
    sayIt 'MP3 Player is not initialized'
    return 0
  }
  if _mp3UseChecksum {
    comment 'Include checksum (10 bytes total)'
    local 'msg' ('[data:makeList]' (hexToInt '7E') (hexToInt 'FF') 6 (hexToInt cmd) 0 arg1 arg2 0 0 (hexToInt 'EF'))
    local 'sum' 0
    for i 6 {
      sum += (at (i + 1) msg)
    }
    sum = (65536 - sum)
    atPut 8 msg ((sum >> 8) & 255)
    atPut 9 msg (sum & 255)
  } else {
    comment 'No checksum (8 bytes total)'
    local 'msg' ('[data:makeList]' (hexToInt '7E') (hexToInt 'FF') 6 (hexToInt cmd) 0 arg1 arg2 (hexToInt 'EF'))
  }
  comment 'Send the command'
  for byte msg {
    '[io:softWriteByte]' byte _mp3Pin 9600
  }
  waitMillis 100
}

to '_mp3_waitForResponse' {
  comment 'Wait for a response on _mp3RxPin.
Note: a low value on _mp3RxPin is the start of a response message.
We do not read the actual message but wait 20 bytes worth of time.'
  if (_mp3RxPin >= 0) {
    local 'endTime' ((millisOp) + 3000)
    repeatUntil (not (digitalReadOp _mp3RxPin)) {
      if ((millisOp) > endTime) {return 0}
    }
    waitMillis 21
  } else {
    comment 'RX pin not set so just wait a few seconds.'
    waitMillis 3000
  }
}

to mp3_initialize type pin optionalRxPin {
  _mp3UseChecksum = ('Octopus' != type)
  _mp3Pin = pin
  _mp3RxPin = -1
  if ((pushArgCount) > 2) {
    _mp3RxPin = optionalRxPin
  }
  comment 'Reset'
  '_mp3_sendMP3Cmd' '0x0C' 0 0
  if (_mp3RxPin >= 0) {
    '_mp3_waitForResponse'
  } else {
    waitMillis 1000
  }
}

to mp3_nextTrack {
  comment 'Skip to the next track in the current folder, wrapping back to the first track.'
  mp3_pause
  comment 'Disable folder repeat'
  '_mp3_sendMP3Cmd' '0x08' 0 0
  waitMillis 50
  '_mp3_sendMP3Cmd' '0x01' 0 0
}

to mp3_pause {
  '_mp3_sendMP3Cmd' '0x0E' 0 0
}

to mp3_playTrack trackNum folderNum {
  comment 'Play the given track in the given folder.
If folder is 0, play the given track at the top level of the SD card.
Folder names must start with two digits, 01-99.
Track names in a folder must start with three digits, 001-999.
Track names at the top level must start with four digits, 0001-9999.
This sets the folder for the "play next track in folder" command.'
  if (folderNum < 1) {
    comment 'Play top-level track (e.g. 0001)'
    '_mp3_sendMP3Cmd' '0x03' 0 trackNum
  } else {
    comment 'Play track in folder'
    '_mp3_sendMP3Cmd' '0x0F' folderNum trackNum
    comment 'Hack: Send command twice to increase reliability on MakerPort v1.00'
    '_mp3_sendMP3Cmd' '0x0F' folderNum trackNum
  }
}

to mp3_playTrackUntilDone trackNum folderNum {
  if (_mp3RxPin < 0) {sayIt 'To use this feature, set the RX pin in "mp3 initialize".'}
  mp3_playTrack trackNum folderNum
  if (_mp3RxPin >= 0) {
    waitUntil (not (digitalReadOp _mp3RxPin))
  } else {
    comment 'RX pin not set so just wait a few seconds.'
    waitMillis 5000
  }
}

to mp3_repeatAllInFolder folderNum {
  comment 'Repeatedly play all files in the given folder. Does not work for top level (folder 0).'
  '_mp3_sendMP3Cmd' '0x17' folderNum folderNum
  mp3_resume
}

to mp3_resume {
  '_mp3_sendMP3Cmd' '0x0D' 0 0
}

to mp3_setVolume level {
  comment 'Range is 0-30'
  '_mp3_sendMP3Cmd' '0x06' 0 level
}


module MakerPort Output
author MicroBlocks
version 1 9 
depends 'LCD Display' 'MP3 Player' Touch 'IR Remote' 
choices makerport_audioSource MP3 Tone 
description 'Support for MakerPort (https://makerport.fun)'
variables _makerport_microSDInserted _makerport_time_averages 

  spec ' ' 'makerport_initialize' 'MakerPort initialize'
  space
  spec ' ' 'makerport_beep' 'MakerPort tone _ Hz for _ msecs : volume _ (0-10)' 'num num num' 440 100 10
  spec ' ' 'makerport_setAudioSource' 'set MakerPort audio source to _' 'menu.makerport_audioSource' 'MP3'
  space
  spec ' ' 'makerport_setAllLEDs' 'set all MakerPort LEDs _' 'bool' false
  space
  spec ' ' 'makerport_typeString' 'type _ to computer' 'str' 'Hello from MakerPort!'
  space
  spec 'r' 'makerport_mp3_hasCard' 'mp3 player has Flash card'
  space
  spec 'r' 'makerport_loudness' 'loudness'
  space
  spec 'r' 'makerport_timeAveragedLevel' 'input level from _ with time sample _ ms' 'num num' 13 64
  spec 'r' '_makerport_compute_time_average' '_compute time average _ _ _' 'num num num' 13 64 0

to '_makerport_compute_time_average' pin timeSample timeAverage {
  local 'samples' 0
  local 'average' 0
  local 'endTime' ((millisOp) + timeSample)
  repeatUntil ((millisOp) >= endTime) {
    samples += 1
    average += (absoluteValue ((analogReadOp pin) - timeAverage))
  }
  return (average / (maximum samples 1))
}

to makerport_beep freq msecs optionalVolume {
  if (freq < 1) {return 0}
  local 'halfCycleTime' (500000 / freq)
  local 'cycles' ((500 * msecs) / halfCycleTime)
  local 'amplitude' (50 * (argOrDefault 3 10))
  amplitude = (maximum 0 (minimum amplitude 1023))
  digitalWriteOp 19 true
  repeat cycles {
    analogWriteOp 0 amplitude
    waitMicros halfCycleTime
    analogWriteOp 0 0
    waitMicros halfCycleTime
  }
}

to makerport_initialize {
  makerport_setAllLEDs false
  attachIR 18
  mp3_initialize 'MakerPort' 20 21
  if (makerport_mp3_hasCard) {
    makerport_setAudioSource 'MP3'
  } else {
    makerport_setAudioSource 'Tone'
  }
}

to makerport_loudness {
  local 'low' 10000
  local 'high' -10000
  for i 40 {
    comment 'Sample microphone connected to analog port for ~20 msecs at ~2000 samples/sec.'
    local 'sample' (analogReadOp 13)
    low = (minimum low sample)
    high = (maximum high sample)
    waitMicros 500
  }
  return (high - low)
}

to makerport_mp3_hasCard {
  comment 'Note: This command works only if MP3 player is
connected to the hardware serial pins.'
  if (isType _makerport_microSDInserted 'boolean') {
    comment 'return previously determined value'
    return _makerport_microSDInserted
  }
  '[serial:open]' 9600
  comment 'Send MP3 player initialization command'
  '[serial:write]' ('[data:makeList]' (hexToInt '7E') (hexToInt 'FF') 6 (hexToInt '0C') 0 0 0 254 239 (hexToInt 'EF'))
  local 'bytesRead' ('[data:newByteArray]' 0)
  repeat 60 {
    comment 'Loop for up to 3 seconds while waiting for a response'
    bytesRead = ('[data:join]' bytesRead ('[serial:read]'))
    if ((size bytesRead) >= 10) {
      comment 'Got a response message. Item 7 is 2 if
a Flash card is inserted in the player.'
      '[serial:close]'
      _makerport_microSDInserted = ((at 7 bytesRead) == 2)
      return _makerport_microSDInserted
    }
    waitMillis 50
  }
  '[serial:close]'
  _makerport_microSDInserted = (booleanConstant false)
  return _makerport_microSDInserted
}

to makerport_setAllLEDs bool {
  for pin 12 {
    digitalWriteOp pin bool
  }
}

to makerport_setAudioSource src {
  digitalWriteOp 19 (src != 'MP3')
}

to makerport_timeAveragedLevel pin timeSample {
  if (_makerport_time_averages == 0) {_makerport_time_averages = (newList 32 0)}
  pin = (maximum 1 (minimum pin 32))
  local 'average' ('_makerport_compute_time_average' pin timeSample (at pin _makerport_time_averages))
  if ((at pin _makerport_time_averages) == 0) {
    atPut pin _makerport_time_averages average
    average = 0
  }
  return average
}

to makerport_typeString s {
  for ch s {
    '[hid:pressKey]' ch -1
  }
}


module NeoPixel Output
author MicroBlocks
version 1 6 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if ((boardType) == 'M5Atom-Matrix') {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'Mbits') {
    neoPixelAttach 25 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'r' ((rgb >> 16) & 255)
    local 'g' ((rgb >> 8) & 255)
    local 'b' (rgb & 255)
    local 'brightness' (maximum r g b)
    if (delta > 0) {
      delta = (minimum delta (255 - brightness))
    } else {
      delta = (maximum delta (42 - brightness))
    }
    r = (maximum 0 (minimum (r + delta) 255))
    g = (maximum 0 (minimum (g + delta) 255))
    b = (maximum 0 (minimum (b + delta) 255))
    atPut i _np_pixels (colorFromRGB r g b)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_update' {
  '[display:neoPixelSend]' _np_pixels
  waitMicros 100
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  hasWhite = false
  if ((pushArgCount) > 2) {
    hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  fillList _np_pixels 0
  '[display:neoPixelSetPin]' pinNumber hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels color
  '_NeoPixel_update'
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' (n > 0)
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}


module Servo Output
author MicroBlocks
version 1 1 
tags servo motor angle rotation position 
description 'Control both positional (angle) and rotational servo motors.'
variables _servoPin _servoPulseWidth 

  spec ' ' 'setServoAngle' 'set servo _ to _ degrees (-90 to 90)' 'num num' 1 90
  spec ' ' 'setServoSpeed' 'set servo _ to speed _ (-100 to 100)' 'num num' 1 100
  spec ' ' 'stopServo' 'stop servo _' 'num' 1
  spec 'r' '_servoIndex' '_servoIndex _' 'num' 1
  spec ' ' '_servoPulse' '_servoPulse pin _ usecs _' 'num num' 1 1500
  spec ' ' '_servoUpdateLoop' '_servoUpdateLoop'

to '_servoIndex' which {
  if (_servoPin == 0) {
    _servoPin = ('[data:makeList]')
    _servoPulseWidth = ('[data:makeList]')
    sendBroadcast '_servoUpdateLoop'
  }
  local 'i' ('[data:find]' which _servoPin)
  if (i < 0) {
    comment 'Add new pin'
    '[data:addLast]' which _servoPin
    '[data:addLast]' '1500' _servoPulseWidth
    i = (size _servoPin)
  }
  return i
}

to '_servoPulse' pin usecs {
  if (usecs == 0) {
    comment 'Servo stopped; do nothing'
    return 0
  }
  usecs = (maximum 850 (minimum usecs 2150))
  comment 'Split wait into a long wait followed by a wait of <= 30 usecs for greater accuracy'
  local 'endTime' ((microsOp) + usecs)
  digitalWriteOp pin true
  waitMicros (usecs - 30)
  waitMicros (endTime - (microsOp))
  digitalWriteOp pin false
}

to '_servoUpdateLoop' {
  forever {
    if (_servoPin != 0) {
      comment 'If the _servoPin list is not 0, update the servos'
      for i (size _servoPin) {
        local 'pin' (at i _servoPin)
        local 'usecs' (at i _servoPulseWidth)
        if (and (pin >= 0) (usecs != 0)) {
          '_servoPulse' pin usecs
        }
      }
      waitMillis 15
    }
  }
}

to setServoAngle which degrees optionalReverse {
  local 'reversed' false
  if ((pushArgCount) > 2) {
    reversed = optionalReverse
  }
  if reversed {
    degrees = (0 - degrees)
  }
  local 'pulseWidth' (1500 - (10 * degrees))
  if ('[io:hasServo]') {
    '[io:setServo]' which pulseWidth
  } else {
    atPut ('_servoIndex' which) _servoPulseWidth pulseWidth
  }
}

to setServoSpeed which speed optionalReverse {
  local 'reversed' false
  if ((pushArgCount) > 2) {
    reversed = optionalReverse
  }
  if reversed {
    speed = (0 - speed)
  }
  local 'pulseWidth' (1500 - (10 * speed))
  if ((absoluteValue speed) < 2) {
    pulseWidth = 0
  }
  if ('[io:hasServo]') {
    '[io:setServo]' which pulseWidth
  } else {
    atPut ('_servoIndex' which) _servoPulseWidth pulseWidth
  }
}

to stopServo which {
  if ('[io:hasServo]') {
    '[io:setServo]' which 0
  } else {
    atPut ('_servoIndex' which) _servoPulseWidth 0
  }
}


module Touch Input
author MicroBlocks
version 1 8 
description 'Support for the MPR121 12-channel i2c touch sensor.'
variables _touch_state _touch_isTouched _touch_eventPending _touch_last_touched_pin _touch_last_released_pin 

  spec 'r' 'touch_isTouched' 'is pin _ touched?' 'menu.range:1-12' 1
  space
  spec 'r' 'touch_touch_event' 'pin touch event'
  spec 'r' 'touch_last_touched_pin' 'last touched pin'
  space
  spec 'r' 'touch_release_event' 'pin release event'
  spec 'r' 'touch_last_released_pin' 'last released pin'
  space
  spec 'r' 'touch_state_string' 'touch state string'
  space
  spec ' ' '_touch_init' '_touch_init'
  spec ' ' '_touch_update' '_touch_update'
  spec ' ' '_touch_setRegister' '_touch_setRegister _ to _' 'auto auto' 'hex register' 'hex value'

to '_touch_init' {
  if (isType _touch_isTouched 'list') {
    comment 'Already initialized.'
    return 0
  }
  _touch_isTouched = (newList 12 (booleanConstant false))
  _touch_eventPending = (newList 12 (booleanConstant false))
  _touch_last_touched_pin = -1
  _touch_last_released_pin = -1
  comment 'Soft reset -- sets all registers to defaults'
  '_touch_setRegister' '0x80' '0x63'
  comment 'Set filter parameters'
  '_touch_setRegister' '0x2B' '0x01'
  '_touch_setRegister' '0x2C' '0x01'
  '_touch_setRegister' '0x2D' '0x10'
  '_touch_setRegister' '0x2E' '0x20'
  '_touch_setRegister' '0x2F' '0x01'
  '_touch_setRegister' '0x30' '0x01'
  '_touch_setRegister' '0x31' '0x10'
  '_touch_setRegister' '0x32' '0x20'
  '_touch_setRegister' '0x33' '0x01'
  '_touch_setRegister' '0x34' '0x10'
  '_touch_setRegister' '0x35' '0xFF'
  comment 'Init debounce and config registers'
  '_touch_setRegister' '0x5B' '0x11'
  '_touch_setRegister' '0x5C' '0xFF'
  '_touch_setRegister' '0x5D' '0x30'
  comment 'Set touch/release thresholds'
  local 'touchThreshold' 40
  local 'releaseThreshold' 20
  for i 12 {
    local 'reg' ((hexToInt '40') + (2 * i))
    '_touch_setRegister' (reg - 1) touchThreshold
    '_touch_setRegister' reg releaseThreshold
  }
  comment 'Start tracking all 12 inputs (proximity detection disabled)'
  '_touch_setRegister' '0x5E' '0xCC'
}

to '_touch_setRegister' reg value {
  if (isType reg 'string') {reg = (hexToInt reg)}
  if (isType value 'string') {value = (hexToInt value)}
  i2cSet 90 reg value
}

to '_touch_update' {
  '_touch_init'
  _touch_state = (((i2cGet 90 1) << 8) | (i2cGet 90 0))
  if (_touch_state < 0) {
    comment 'i2c read operation failed'
    _touch_state = 0
  }
  for i 12 {
    local 'isTouchedNow' ((_touch_state & (1 << (i - 1))) != 0)
    if ((at i _touch_isTouched) != isTouchedNow) {
      atPut i _touch_isTouched isTouchedNow
      atPut i _touch_eventPending (booleanConstant true)
    }
  }
  comment 'Leave some time between updates'
  waitMillis 30
}

to touch_isTouched pin {
  if (or (pin < 1) (pin > 12)) {return (booleanConstant false)}
  '_touch_update'
  return ((_touch_state & (1 << (pin - 1))) != 0)
}

to touch_last_released_pin {
  comment 'Return the pin that triggered the last release event.'
  '_touch_init'
  return _touch_last_released_pin
}

to touch_last_touched_pin {
  comment 'Return the pin that triggered the last touch event.'
  '_touch_init'
  return _touch_last_touched_pin
}

to touch_release_event {
  '_touch_update'
  for i 12 {
    if (and (at i _touch_eventPending) ((_touch_state & (1 << (i - 1))) == 0)) {
      atPut i _touch_eventPending (booleanConstant false)
      _touch_last_released_pin = i
      return (booleanConstant true)
    }
  }
  _touch_last_released_pin = -1
  return (booleanConstant false)
}

to touch_state_string {
  '_touch_update'
  local 'pin states' ('[data:makeList]')
  for i 12 {
    if ((_touch_state & (1 << (i - 1))) != 0) {
      '[data:addLast]' '1' (v 'pin states')
    } else {
      '[data:addLast]' '0' (v 'pin states')
    }
  }
  return ('[data:joinStrings]' (v 'pin states'))
}

to touch_touch_event {
  '_touch_update'
  for i 12 {
    if (and (at i _touch_eventPending) ((_touch_state & (1 << (i - 1))) != 0)) {
      atPut i _touch_eventPending (booleanConstant false)
      _touch_last_touched_pin = i
      return (booleanConstant true)
    }
  }
  _touch_last_touched_pin = -1
  return (booleanConstant false)
}

module main
author 'Turgut Guneysu'
version 2 1 
depends 'OLED Graphics' 
description 'Demonstrates the use of  
PicoBricks board and sensors
'
variables valBut valLed valIsi valNem valRel valBuz valLdr valPot 

  spec ' ' 'Welcome' 'Welcome'
  spec ' ' 'buzzer' 'buzzer'
  spec ' ' 'neo' 'neo'
  spec ' ' 'reveal display buffer delay' 'reveal display buffer delay _ ms' 'auto' 0
  spec ' ' '_dispByte' '_disp byte value _ row _ col _' 'auto auto auto' 0 0 0

to Welcome {
  OLEDcontrast 4
  'defer display updates'
  OLEDwrite 'Welcome To' 0 8 false
  OLEDwrite 'PICOBRICKS' 24 32 false
  OLEDwrite 'Project' 70 56 false
  'reveal display buffer delay' 0
  waitMillis 1000
  '_OLEDcursorReset'
  RobotPIC
  for i 127 {
    OLEDdrawImage _imgData (127 - i) 0
    OLEDshowGDBuffer
  }
  BunnyPIC
  for i 52 {
    OLEDdrawImage _imgData (127 - i) 0
    OLEDshowGDBuffer
  }
  OLEDsetVideo 'Inverse'
  waitMillis 2000
  OLEDsetVideo 'Normal'
}

to '_dispByte' value row col {
  comment 'Copies a byte from _GDBuffer to Display

Values are DEC.'
  local '_cmdPrefix' ('[data:newByteArray]' 1 (hexToInt 'C0'))
  '_sendCmd' ('[data:join]' '22' _comma ('_dec2hex' row) _comma ('_dec2hex' row) _comma '21' _comma ('_dec2hex' col) _comma ('_dec2hex' col))
  if (_comMode == 'i2c') {
    '[sensors:i2cWrite]' OLEDi2cAddr ('[data:join]' _cmdPrefix ('[data:newByteArray]' 1 value))
  } else {
    '_SPIWriteData'
    spiSend value
  }
}

to buzzer {
  comment 'Buzzer / speaker
TÄ±klandÄ±ÄÄ±nda DO notasÄ± 500ms Ã§alar.'
  valBuz = 'on '
  pb_beep 300
  valBuz = 'off'
  digitalWriteOp _pb_pin_Buzzer true
}

to neo {
  comment 'RGB LED
Bu blok tÄ±klandÄ±ÄÄ±nda, 5  kere rasgele renk deÄiÅtirerek Ã§alÄ±ÅÄ±r.'
  local 'neoRGB' ('[data:makeList]' 16711680 65280 255)
  repeat 5 {
    pb_set_rgb_color (at (random 1 3) neoRGB)
    waitMillis 300
  }
  pb_turn_off_RGB
}

to 'reveal display buffer delay' {
  comment 'Display _GDBuffer content random bytes at a time with delay.'
  '_clearDisplay'
  local 'randNums' (newList 1024)
  local 'base' 128
  repeatUntil (-1 == ('[data:find]' 0 randNums)) {
    local 'num' (random 0 1023)
    if (0 == (at (num + 1) randNums)) {
      atPut (num + 1) randNums 1
      '_dispByte' (at (num + 1) _GDBuffer) (num / base) (num % base)
      waitMillis delay
    }
  }
}

script 80 50 {
whenStarted
comment 'Program baÅladÄ±ÄÄ±nda HELLO mesajÄ± yayÄ±mlanÄ±r. Bu mesajÄ± algÄ±layan blok da PICO
LED ini 9 kere yakÄ±p sÃ¶ndÃ¼rÃ¼r.'
sendBroadcast 'HELLO'
'_pb_init_pins'
OLEDInit_I2C 'OLED_0.96in' _pb_i2c_Addr 0
waitUntil OLEDReady
OLEDcontrast 4
OLEDclear
'defer display updates'
pbPIC
OLEDdrawImage _imgData 0 0
'reveal display buffer delay' 0
waitMillis 3000
OLEDclear
Welcome
waitMillis 3000
OLEDclear
'defer display updates'
OLEDwrite '   PICOBRICKS   ' 0 0 true
OLEDwrite 'But:' 0 16 false
valBut = 'off'
OLEDwrite 'Led:' 64 16 false
valLed = 'off'
OLEDwrite 'Isi:' 0 24 false
valIsi = 'off'
OLEDwrite 'Nem:' 64 24 false
valNem = 'off'
OLEDwrite 'Rel:' 0 32 false
valRel = 'off'
OLEDwrite 'Buz:' 64 32 false
valBuz = 'off'
OLEDwrite 'Ldr:' 0 40 false
valLdr = 'off'
OLEDwrite 'Pot:' 64 40 false
valPot = 'off'
OLEDwrite '   MICROBLOCKS  ' 0 56 true
OLEDshowGDBuffer
sendBroadcast 'display'
}

script 609 134 {
whenBroadcastReceived 'display'
local 'dCol' 33
forever {
  'defer display updates'
  OLEDwrite valBut dCol 16 false
  if (valLed == 'off') {
    OLEDwrite ' ' 95 16 false
  } else {
    OLEDdrawImage ('[data:asByteArray]' ('[data:makeList]' 126 126 126 126 126 126 126 126)) 95 16
  }
  OLEDwrite ('[data:join]' '' valIsi ' ') dCol 24 false
  OLEDwrite ('[data:join]' '' valNem ' ') 95 24 false
  if (valRel == 'on ') {
    OLEDdrawImage ('[data:asByteArray]' ('[data:makeList]' 126 126 126 126 126 126 126 126)) dCol 32
  } else {
    OLEDwrite ' ' dCol 32 false
  }
  OLEDwrite valBuz 95 32 false
  OLEDwrite ('[data:join]' '' valLdr ' ') dCol 40 false
  if (valPot > 75) {
    OLEDwrite ('[data:copyFromTo]' ('[data:join]' '' valPot ' ') 1 3) 95 40 false
  } else {
    OLEDwrite ('[data:join]' '' valPot '   ') 95 40 false
  }
  OLEDshowGDBuffer
  waitMillis 10
}
}

script 387 309 {
whenBroadcastReceived 'HELLO'
repeat 9 {
  setUserLED true
  digitalWriteOp 7 true
  waitMillis 50
  setUserLED false
  digitalWriteOp 7 false
  waitMillis 50
}
}

script 84 1029 {
whenCondition (pb_button)
comment 'BUTTON / LED:
Program baÅladÄ±ÄÄ±nda buton 10 devamlÄ± algÄ±lanÄ±r.
BasÄ±lmÄ±Åsa yanÄ±ndaki LED yanÄ±p sÃ¶nmeye baÅlar.'
valBut = 'on '
buzzer
if ((digitalReadOp _pb_pin_RedLED) == (booleanConstant true)) {
  valLed = 'off'
  valBut = 'off'
  pb_set_red_LED false
  waitMillis 1000
} else {
  valLed = 'on'
  valBut = 'on '
  pb_set_red_LED true
  waitMillis 1000
}
}

script 523 1191 {
comment 'If Neo is left lit, this will turn it off.'
pb_turn_off_RGB
}

script 918 1360 {
whenBroadcastReceived 'display'
comment 'POT READ
YukarÄ± menÃ¼deki graph ikonu tÄ±klayÄ±n IDE Ã¼zerine Ã§ekip bÄ±rakÄ±n.
SaÄ tÄ±klayÄ±p "zero at bottom" seÃ§in.
Alt kÃ¶Åesini ayarlayarak 100 deÄeri gÃ¶zÃ¼kÃ¼r hale getirin.
Graf penceresini herhangi bir yere koyun.
Blok grubuna tÄ±kladÄ±ÄÄ±nÄ±zda, POT deÄeri okunup grafÄ±
Ã§izilecektir.
POT ayarÄ±nÄ± deÄiÅtirerek deneyin.'
forever {
  valPot = ('[misc:rescale]' (pb_potentiometer) 0 1023 0 100)
  printIt valPot
  waitMillis 50
}
}

script 528 1363 {
whenBroadcastReceived 'display'
comment 'RELAY switch
Kayan ayarÄ± saÄa ayarlayÄ±p blok tÄ±klayÄ±n.
RÃ¶le Ã§alÄ±ÅÄ±r. Sola ayarlayÄ±p tÄ±klayÄ±n, RÃ¶le kapanÄ±r.'
forever {
  valRel = 'on '
  pb_set_relay true
  waitMillis 3000
  valRel = 'off'
  pb_set_relay false
  waitMillis 3000
}
}

script 69 1459 {
whenCondition ('_dhtReady')
comment 'DHT11
KartÄ±nÄ±zÄ±n Ä±sÄ± ve rutubet sensÃ¶rÃ¼nÃ¼n hazÄ±r olduÄu algÄ±landÄ±ÄÄ±nda
bu bloklar Ä±sÄ± ve rutubeti gÃ¶sterirler.'
valIsi = (pb_temperature)
valNem = (pb_humidity)
waitMillis 5000
}

script 75 1653 {
whenBroadcastReceived 'display'
forever {
  comment 'LDR Read
IÅÄ±k sensÃ¶r deÄerini gÃ¶sterir.'
  valLdr = (pb_light_sensor)
  waitMillis 1000
}
}

script 498 1658 {
whenBroadcastReceived 'display'
comment 'SERVO Control
Mikrosaniyeleri 500 - 3000
ayarlayÄ±p tÄ±klayÄ±n.
Servo 500 de sol 180 derece 
ucuna dÃ¶ner. 
3000 de saÄ ucuna dÃ¶ner.'
forever {
  setServoAngle _pb_pin_Motor1 -90
  setServoAngle _pb_pin_Motor2 -90
  waitMillis 1000
  setServoAngle _pb_pin_Motor1 90
  setServoAngle _pb_pin_Motor2 90
  waitMillis 1000
}
}

script 75 1851 {
whenBroadcastReceived 'display'
forever {
  neo
}
}

script 54 1969 {
to buzzer {}
}

script 50 2160 {
to Welcome {}
}


module BunnyLogo
author unknown
version 1 0 
description ''
variables _imgWidth _imgHeight _imgData timer _byteCount 

  spec ' ' 'B1' 'B1'
  spec ' ' 'BunnyPIC' 'BunnyPIC'

to B1 {
  comment 'Place this under P1'
  local '_imgHex' '344000000000003840603808F0000000000000000080C060201018D87880C0602030101808C8781800000000000000000000000000000000080808CB8A0E0E8BE90000000000F01C070100000000FE3FFE03000000000000C0FF000000000000000000000000000000000000000000386DCFCF4D3800000000003FE00000000000C0FF003FFC0000000000807F0000000000000000000000000000000000000002F2B292F29A9A92F200000000000007BCE00000000F0C0404070600000000070404040404080818102060C08000000000000000000001396D45C56D3900000000E0380E0300000000000000000000000000000000000000000000000000000001061CF0000000000000006F8C8C8C8CEC0000003EFF000000000000000000000000006070000000000000003030000000000000000000C1FF000000046660E4E4E525252400000000030C306080000000000000040810102020E00367FF03E06020101808040080C0701C0700000000000C0C0E0E0F0B1B190000000000000000000102060C08181010302020202121212131111018080C04060301000000000000'
  '_process image data' _imgHex
  _imgHex = ''
}

to BunnyPIC {
  comment 'Place this under PIC'
  _imgData = 0
  _byteCount = 0
  B1
}


module 'OLED Graphics' Output
author 'Turgut Guneysu'
version 1 13 
choices ModeMenu Horizontal Vertical 
choices OnOffMenu On Off 
choices VideoMenu Inverse Normal 
choices DispTypeMenu 'OLED_0.96in' 'OLED_2.42in' 
description 'Supports 0.96in and 2.42in OLED Displays with SD1306 and SD1309 chipsets. Comm mode is I2C or SPI.
Changes:
- always display buffer
- defer display updates block
- remove reveal
- switch to x (0-127), y (0-63)
- Pruned commands and vars
- textX and textY
- Text at any x and y
- handles newLines
- removed dependencies
- unified data format for chars, sprites, and images
- image draw at any x,y
- filled rectangle
- image draw bug fix
- stack overflow fix
'
variables OLEDReady OLEDi2cAddr _GDBuffer _begCol _begRow _cDecTBL _comma _cTABLE _comMode _dcPin _delayGDUpd _displayType _endCol _endRow _eol _resetPin _textX _textY _dataPrefix _byteCount _imgData _imgWidth _imgHeight 

  spec ' ' 'OLEDInit_I2C' 'initialize i2c _ address(hex) _ reset pin# _ flip _' 'str.DispTypeMenu auto auto bool' 'OLED_0.96in' '3C' '-' false
  spec ' ' 'OLEDInit_SPI' 'initialize spi _ d/c pin# _ reset pin# _ flip _' 'str.DispTypeMenu auto auto bool' 'OLED_2.42in' 16 8 false
  spec ' ' 'OLEDwrite' 'write _ at x _ y _ inverse _' 'auto auto auto bool' 'Hello!' 0 0 false
  spec ' ' 'OLEDshowGDBuffer' 'show display buffer'
  spec ' ' 'OLEDclear' 'clear'
  spec ' ' 'OLEDcontrast' 'set contrast (1-4) _' 'auto' 2
  spec ' ' 'OLEDdrawCircle' 'draw circle at x _ y _ radius _ erase _' 'auto auto auto bool' 64 32 '10' false
  spec ' ' 'OLEDdrawImage' 'draw image _ at x _ y _' 'auto auto auto' 0 0 0
  spec ' ' 'OLEDdrawLine' 'draw line from x _ y _ to x _ y _ erase _' 'auto auto auto auto bool' 0 0 127 63 false
  spec ' ' 'OLEDdrawRect' 'draw rectangle x _ y _ w _ h _ erase _ rounding(3-15) _' 'auto auto auto auto bool auto' 0 0 127 63 false 0
  spec ' ' 'OLEDfillRect' 'fill rectangle x _ y _ w _ h _ erase _' 'auto auto auto auto bool' 20 20 30 20 false
  spec ' ' 'OLEDflip' '_flip display top _' 'bool' false
  spec 'r' 'OLEDmakeImage' 'make image _' 'microbitDisplay' 33084991
  spec ' ' 'OLEDpixel' 'set pixel x _ y _ erase _' 'auto auto bool' 0 0 false
  spec ' ' 'OLEDsetVideo' 'set video _' 'str.VideoMenu' 'Inverse'
  spec 'r' 'OLEDwru' 'cursor location'
  spec ' ' 'defer display updates' 'defer display updates'
  spec ' ' '_GDDRAMoff' '_GDDRAMoff'
  spec ' ' '_GDDRAMon' '_GDDRAMon'
  spec ' ' '_OLEDcursorReset' '_cursor reset'
  spec ' ' '_OLEDsetDisplay' '_set display _' 'str.OnOffMenu' 'On'
  spec ' ' '_OLEDreset' '_set reset Pin# _' 'auto' '0'
  spec ' ' '_SPIWriteCmd' '_SPIWriteCmd'
  spec ' ' '_SPIWriteData' '_SPIWriteData'
  spec ' ' '_T1' '_T1'
  spec ' ' '_T2' '_T2'
  spec ' ' '_T3' '_T3'
  spec 'r' '_cBMP' '_cBMP _ InvYN _' 'auto bool' '' false
  spec ' ' '_clearDisplay' '_clearDisplay'
  spec ' ' '_corner' '_corner _ _ _ _ _' 'auto auto auto auto bool' 'TL' 32 1 0 true
  spec 'r' '_dec2hex' '_dec2hex _' 'auto' 0
  spec ' ' '_initChars' '_initChars'
  spec ' ' '_initCheck' '_initCheck'
  spec ' ' '_initDisplayHW' '_initDisplayHW'
  spec ' ' '_initLibrary' '_initLibrary'
  spec ' ' '_process image data' '_process image data _' 'auto' ' '
  spec ' ' '_sendCmd' '_sendCmd _' 'auto' ''
  spec ' ' '_verifyXY' '_verifyXY _ _' 'auto auto' 0 0

to OLEDInit_I2C dispType i2cAddr resetPin flip {
  comment 'Sets display type and interface and initializes HW settings.
Do NOT set a ResetPin# unless one exists on the display hardware.
NOTE:
Displays supported:
- OLED 0.96in (SD1306 chip) and
- OLED 2.42" (SD1309 chip)
Both displays are 128x64 pixels or 16x8 characters in size.
Displays come in dual mode version (i2c and spi) and pure i2c.
Pure i2c models do not have a Reset pin.

flip setting controls display hardware write direction:
- false: top to bottom
- true: bottom to top'
  _comma = ('[data:unicodeString]' 44)
  _comMode = 'i2c'
  OLEDi2cAddr = (hexToInt ('[data:join]' ('[data:unicodeString]' 32) i2cAddr))
  if (_displayType != 0) {
    return
  }
  if (dispType == 'OLED_0.96in') {
    _displayType = 6
    _resetPin = resetPin
  } else {
    _displayType = 9
    _resetPin = resetPin
  }
  '_initDisplayHW'
  if flip {
    OLEDflip true
  }
  '_initLibrary'
  OLEDclear
  OLEDcontrast 4
}

to OLEDInit_SPI dispType dcPin resetPin flip {
  comment 'Sets display type and interface and initializes HW settings.
SPI four wire in Mode-0 is supported. Max speed=10000000.

Do NOT set a ResetPin# unless one exists on the display hardware.
NOTE:
Displays supported:
- OLED 0.96in (SD1306 chip) and
- OLED 2.42" (SD1309 chip)
Both displays are 128x64 pixels or 16x8 characters in size.
Displays come in dual mode version (i2c and spi) and pure i2c.
Pure i2c models do not have a Reset pin.
flip setting controls display hardware write direction:
- false: top to bottom
- true: bottom to top'
  _comma = ('[data:unicodeString]' 44)
  _comMode = 'spi'
  _dcPin = dcPin
  if (_displayType != 0) {
    return
  }
  if (dispType == 'OLED_0.96in') {
    _displayType = 6
    _resetPin = resetPin
  } else {
    _displayType = 9
    _resetPin = resetPin
  }
  '[sensors:spiSetup]' 10000000
  '_initDisplayHW'
  if flip {
    OLEDflip true
  }
  '_initLibrary'
  OLEDclear
  OLEDcontrast 4
}

to OLEDclear {
  comment 'Set bounds to FullScreen and CLEARs display
and GDBuffer.'
  _GDBuffer = ('[data:newByteArray]' 1024)
  '_initCheck'
  '_OLEDcursorReset'
  OLEDshowGDBuffer
}

to OLEDcontrast contrast {
  comment 'Sets the brightness control of the display to one of four values.
1 is the least bright, 4 is the brightest setting.'
  '_initCheck'
  local 'cLevels' ('[data:makeList]' 0 '1F' '2F' 'F0')
  if (and (contrast >= 1) (contrast <= 4)) {
    local 'i2cCmd' ('[data:join]' '81' _comma (at contrast cLevels))
    '_sendCmd' i2cCmd
  } else {
    sayIt 'Error in CONTRAST Level'
  }
}

to OLEDdrawCircle cx cy r erase {
  comment 'Bresenham Circle:
Draws circles, even partially bigger than the display.
x: 0-127
y: 0-63
void plotCircle(int xm, int ym, int r)
{
   int x = -r, y = 0, err = 2-2*r; /* II. Quadrant */
   do {
      setPixel(xm-x, ym+y); /*   I. Quadrant */
      setPixel(xm-y, ym-x); /*  II. Quadrant */
      setPixel(xm+x, ym-y); /* III. Quadrant */
      setPixel(xm+y, ym+x); /*  IV. Quadrant */
      r = err;
      if (r <= y) err += ++y*2+1;           /* e_xy+e_y < 0 */
      if (r > x || err > y) err += ++x*2+1; /* e_xy+e_x > 0 or no 2nd y-step */
   } while (x < 0);
}'
  '_initCheck'
  local 'x' (-1 * r)
  local 'y' 0
  local 'err' (2 - (2 * r))
  repeatUntil (x >= 0) {
    OLEDpixel (cx - x) (cy + y) erase
    OLEDpixel (cx - y) (cy - x) erase
    OLEDpixel (cx + x) (cy - y) erase
    OLEDpixel (cx + y) (cy + x) erase
    r = err
    if (r <= y) {
      y += 1
      err = (err + ((y * 2) + 1))
    }
    if (or (r > x) (err > y)) {
      x += 1
      err = (err + ((x * 2) + 1))
    }
  }
  if (not _delayGDUpd) {
    OLEDshowGDBuffer
  }
}

to OLEDdrawImage image x y {
  comment '_imgHeight has to be mod8 or 1-8'
  for row# (maximum 1 ((minimum _imgHeight (64 - y)) / 8)) {
    local 'GDidx' ((((y / 8) * 128) + x) + 1)
    local 'imgDispl' ((row# - 1) * _imgWidth)
    for byte# (minimum _imgWidth (128 - x)) {
      comment 'If y is on page boundary, just copy'
      if (0 == (y % 8)) {
        atPut GDidx _GDBuffer (at (imgDispl + byte#) image)
        GDidx += 1
        if (GDidx > 1024) {
          if (not _delayGDUpd) {OLEDshowGDBuffer}
          return 0
        }
      } else {
        comment 'Else, copy GDLowBits + shiftedByte + GDHiBits to GDBuffer and GDBuffer +128'
        local 'shiftedByte' ('_dec2hex' ((at (imgDispl + byte#) image) << (y % 8)))
        local 'temp' 0
        local 'tempHI' ('[data:copyFromTo]' shiftedByte 1 2)
        local 'tempLO' ('[data:copyFromTo]' shiftedByte 3 4)
        local 'GDLowBits' ((1 << (y % 8)) - 1)
        local 'GDHiBits' (255 - GDLowBits)
        tempLO = ((hexToInt tempLO) | ((at GDidx _GDBuffer) & GDLowBits))
        atPut GDidx _GDBuffer tempLO
        if ((GDidx + 128) <= 1024) {
          tempHI = ((hexToInt tempHI) | ((at (GDidx + 128) _GDBuffer) & GDHiBits))
          atPut (GDidx + 128) _GDBuffer tempHI
        }
        GDidx += 1
        if (GDidx > 1024) {
          if (not _delayGDUpd) {OLEDshowGDBuffer}
          return 0
        }
      }
      waitMillis 0
    }
    y += 8
  }
  if (not _delayGDUpd) {
    OLEDshowGDBuffer
  }
}

to OLEDdrawLine x0 y0 x1 y1 erase {
  comment 'Draws a line from x0,y0 to x1,y1 using the Bresenham Algorithm
x: 0-127
y: 0-63
plotLine(int x0, int y0, int x1, int y1)
    dx =  abs(x1-x0);
    sx = x0<x1 ? 1 : -1;
    dy = -abs(y1-y0);
    sy = y0<y1 ? 1 : -1;
    err = dx+dy;  /* error value e_xy */
    while (true)   /* loop */
        plot(x0, y0);
        if (x0 == x1 && y0 == y1) break;
        e2 = 2*err;
        if (e2 >= dy) /* e_xy+e_x > 0 */
            err += dy;
            x0 += sx;
        end if
        if (e2 <= dx) /* e_xy+e_y < 0 */
            err += dx;
            y0 += sy;
        end if
    end while'
  '_initCheck'
  results = ('[data:makeList]')
  local 'dx' (absoluteValue (x1 - x0))
  local 'dy' (-1 * (absoluteValue (y1 - y0)))
  local 'err' (dx + dy)
  local 'e2' 0
  local 'done' (booleanConstant false)
  if (x0 < x1) {
    local 'sx' 1
  } else {
    local 'sx' -1
  }
  if (y0 < y1) {
    local 'sy' 1
  } else {
    local 'sy' -1
  }
  repeatUntil done {
    OLEDpixel x0 y0 erase
    if (and (x0 == x1) (y0 == y1)) {
      done = (booleanConstant true)
    }
    e2 = (2 * err)
    if (e2 >= dy) {
      err += dy
      x0 += sx
    }
    if (e2 <= dx) {
      err += dx
      y0 += sy
    }
  }
  if (not _delayGDUpd) {
    OLEDshowGDBuffer
  }
}

to OLEDdrawRect TLx TLy width height erase cornerRad {
  comment 'Draw Rectangle with optional rounded corners with radius R.
Does not check for reversed rectangle coordinates for round corners.'
  '_initCheck'
  local 'oldDelayGDUpd' _delayGDUpd
  _delayGDUpd = true
  local 'BRx' (TLx + width)
  local 'BRy' (TLy + height)
  if (cornerRad >= 3) {
    '_corner' 'TL' TLx TLy cornerRad erase
    '_corner' 'TR' BRx TLy cornerRad erase
    '_corner' 'BR' BRx BRy cornerRad erase
    '_corner' 'BL' TLx BRy cornerRad erase
    comment 'TOP - Adjust x'
    OLEDdrawLine (TLx + cornerRad) TLy ((BRx - 1) - cornerRad) TLy erase
    comment 'RIGHT- Adjust y'
    OLEDdrawLine BRx ((TLy + 1) + cornerRad) BRx ((BRy - 1) - cornerRad) erase
    comment 'BOTTOM - Adjust x'
    OLEDdrawLine ((BRx - 1) - cornerRad) BRy ((TLx + 1) + cornerRad) BRy erase
    comment 'LEFT - Adjust y'
    OLEDdrawLine TLx ((BRy - 1) - cornerRad) TLx ((TLy + 1) + cornerRad) erase
  } else {
    OLEDdrawLine TLx TLy BRx TLy erase
    OLEDdrawLine BRx (TLy + 1) BRx BRy erase
    OLEDdrawLine (BRx - 1) BRy TLx BRy erase
    OLEDdrawLine TLx (BRy - 1) TLx (TLy + 1) erase
  }
  _delayGDUpd = oldDelayGDUpd
  if (not _delayGDUpd) {
    OLEDshowGDBuffer
  }
}

to OLEDfillRect x y w h erase {
  for row h {
    for col w {
      OLEDpixel (x + (col - 1)) (y + (row - 1)) erase
    }
  }
  if (not _delayGDUpd) {
    OLEDshowGDBuffer
  }
}

to OLEDflip flip {
  comment 'Flips the display initialization horizontally or vertically.
Horizontal or vertical is based on the pin connector location.'
  if flip {
    '_sendCmd' 'A0,C0'
  } else {
    '_sendCmd' 'A1,C8'
  }
}

to OLEDmakeImage spr# {
  comment 'Receives a spr# representing 5x5 image matrix.
Converts it to a HOR array of 5 VERT bitmap numbers.
This can be displayed with the draw image block.
sprNum max is 33554431'
  '_initCheck'
  local 'spriteList' ('[data:newByteArray]' 5)
  local 'val' 0
  for col 5 {
    for row ('[data:asByteArray]' ('[data:makeList]' 0 5 10 15 20)) {
      local 'bit' (col + row)
      local 'vertBit#' (bit / 5)
      if ((spr# & (1 << (bit - 1))) != 0) {
        if (col != 5) {
          val += (1 << vertBit#)
        } else {
          val += (1 << (vertBit# - 1))
        }
      }
    }
    atPut col spriteList val
    val = 0
  }
  _imgWidth = 5
  _imgHeight = 5
  return spriteList
}

to OLEDpixel x y erase {
  comment 'Places a pixel at x,y in the virtual GDBuffer
Use OLEDshowGDBuffer to display it
1024 Locations
x: 0-127
y: 0-63
page#: 0-7
pagePixel#: 0-7
GDIndex: 1-1024

RangeCheck:
verify x and y are in range of display limits
if X <= num <= Y'
  '_initCheck'
  if (and (and (x >= 0) (x <= 127)) (and (y >= 0) (y <= 63))) {
    local 'page#' (y / 8)
    local 'pagePixel#' (y % 8)
    local 'GDIndex' ((x + ((y / 8) * 128)) + 1)
    local 'byteBMP' (at GDIndex _GDBuffer)
    if (not erase) {
      byteBMP = (byteBMP | (1 << pagePixel#))
    } else {
      comment 'Turn off n th bit'
      byteBMP = (byteBMP & ('~' (1 << pagePixel#)))
    }
    atPut GDIndex _GDBuffer byteBMP
  }
}

to OLEDsetVideo videoMode {
  comment 'Switches the entire display:
Inverse: inverse video mode (bit 0 = on)
Normal: normal video mode (bit 1 = on).
Any image on the display will be preserved when mode changes.'
  '_initCheck'
  if (videoMode == 'Inverse') {
    local 'i2cCmd' 'A7'
  } else {
    local 'i2cCmd' 'A6'
  }
  '_sendCmd' i2cCmd
}

to OLEDshowGDBuffer {
  comment 'Copies contents of virtual _GDBuffer to display
i2c:
   in 61 byte chunks for speed.
   1 byte is used for the command 40
spi:
   fastest is dump buffer
 _GDBuffer is in decimal'
  '_initCheck'
  if (_comMode == 'i2c') {
    local 'idx' 0
    repeat 17 {
      '[sensors:i2cWrite]' OLEDi2cAddr ('[data:join]' _dataPrefix ('[data:copyFromTo]' _GDBuffer idx (idx + 60)))
      idx += 61
    }
  } else {
    '_SPIWriteData'
    '[sensors:spiExchange]' ('[data:copyFromTo]' _GDBuffer 1)
  }
  _delayGDUpd = (booleanConstant false)
}

to OLEDwrite string x y invFlag {
  comment 'Writes strings to display at any x,y; processing CR LF and wrapping at col x.
_textX and _textY are next write locations.'
  '_initCheck'
  local 'oldDelayGDUpd' _delayGDUpd
  _delayGDUpd = true
  '_verifyXY' x y
  local 'origX' x
  if (not (isType string 'string')) {
    string = ('[data:join]' '' string)
  }
  for char string {
    comment 'If in table process it - LINE SET is not supported.'
    if (('[data:find]' char _cTABLE) != -1) {
      OLEDdrawImage ('_cBMP' char invFlag) x y
      x += 8
      if (x > 127) {
        x = origX
        y += 8
        if (y > 63) {
          y = 0
        }
      }
    } (13 == ('[data:unicodeAt]' 1 char)) {
      noop
    } (10 == ('[data:unicodeAt]' 1 char)) {
      x = origX
      y += 8
      if (y > 63) {
        y = 0
      }
    } else {
      comment 'bad char - STOP'
      sayIt 'Invalid CHAR value:' char 'uniCode:' ('[data:unicodeAt]' 1 char)
      stopTask
    }
  }
  _textX = x
  _textY = y
  _delayGDUpd = oldDelayGDUpd
  if (not _delayGDUpd) {
    OLEDshowGDBuffer
  }
}

to OLEDwru {
  comment 'Next Row and Column to print
_textY, _textX'
  return ('[data:asByteArray]' ('[data:makeList]' _textY _textX))
}

to '_GDDRAMoff' {
  comment 'Displays a full empty screen of reverse video.
It disengages the hardware GDBuffer. '
  local 'i2cCmd' 'A5'
  '_sendCmd' i2cCmd
}

to '_GDDRAMon' {
  comment 'It disables the GDDRAMoff mode and engages the hardware GDBuffer for display content.'
  local 'i2cCmd' 'A4'
  '_sendCmd' i2cCmd
}

to '_OLEDcursorReset' {
  comment 'Sets display bounds to full range and resets cursor
to the origin top-left (0,0)
Rows: 0-7
Cols: 0-127
Cursor position is affected by any display operation
and also by OLEDColMode block.'
  '_initCheck'
  local 'cmdString' '22,00,07,21,00,7F'
  '_sendCmd' cmdString
  _textX = 0
  _textY = 0
  _begCol = 0
  _endCol = 127
  _begRow = 0
  _endRow = 7
}

to '_OLEDreset' pin {
  comment 'Does a power off and on on the display,
thus forcing a hardware initialization.'
  digitalWriteOp pin false
  waitMillis 1
  digitalWriteOp pin true
  waitMillis 1
}

to '_OLEDsetDisplay' onoff {
  comment 'Puts the display into
Off:SLEEP   On:WAKE   mode.
Images on display are preserved.'
  '_initCheck'
  if (onoff == 'On') {
    local 'i2cCmd' 'AF'
  } else {
    local 'i2cCmd' 'AE'
  }
  '_sendCmd' i2cCmd
}

to '_SPIWriteCmd' {
  comment 'In SPI mode, we send either a write command
or write data control code. Then follow it with
the appropriate command/data bundle.'
  digitalWriteOp _dcPin false
}

to '_SPIWriteData' {
  comment 'In SPI mode, we send either a write command
or write data control code. Then follow it with
the appropriate command/data bundle.'
  digitalWriteOp _dcPin true
}

to '_T1' {
  comment 'THIN-SS Character Set
Range: space - ?'
  local '_cHEX1' '00000000000000000000005F00000000000007000007000000147F14147F140000242A6B6B2A12000046261008646200304A454D324848000000040300000000001C224100000000000041221C000000082A1C1C1C2A08000008083E080800000000806000000000000808080808080000000060000000000040201008040200003E615149453E000044427F4040000000625151494966000022414949493600101814527F5010000027454545453900003C4A4949493000000301710905030000364949494936000006494949291E00000000660000000000008066000000000008142241000000002424242424240000000041221408000002010151090600'
  local 'idx' 1
  for i 256 {
    atPut i _cDecTBL (hexToInt ('[data:copyFromTo]' _cHEX1 idx (idx + 1)))
    idx += 2
  }
  _cHEX1 = ''
}

to '_T2' {
  comment 'THIN-SS Character Set
Range: @ - _ (underscore)'
  local '_cHEX2' '003E415D55551E00007C121111127C0000417F4949493600001C22414141220000417F4141221C0000417F495D41630000417F491D010300001C224151517200007F080808087F000000417F4100000000304040413F010000417F081422414000417F4140406000007F01020402017F007F010204087F00003E414141413E0000417F4909090600001E212131215E4000417F49192946000026494949493200000301417F410103003F404040403F00000F10204020100F003F40403840403F004122140814224100010244784402010043615149454361007F4141410000000102040810204000004141417F00000008040201020408008080808080808080'
  local 'idx' 1
  for i 256 {
    atPut (256 + i) _cDecTBL (hexToInt ('[data:copyFromTo]' _cHEX2 idx (idx + 1)))
    idx += 2
  }
  _cHEX2 = ''
}

to '_T3' {
  comment 'THIN-SS Character Set
Range: '' - . (last char)'
  local '_cHEX3' '0000000304000000002054545454784000017F304848483000384444444428000030484848317F4000385454545418000000487E490102000098A4A4A4A4780400417F08040478000000447D400000000060808080847D0000017F10284440000000417F40000000007C040478040478007C08040404780000384444444438000084FC98242418000018242498FC840000447C480404180000485454545424000004043F44442000003C404040207C00000C10204020100C003C40403840403C0044281028440000009CA0A0A0A07C00004464544C44000000080836414100000000007700000000000041413608080000020101020201000000000000000000'
  local 'idx' 1
  for i 256 {
    atPut (512 + i) _cDecTBL (hexToInt ('[data:copyFromTo]' _cHEX3 idx (idx + 1)))
    idx += 2
  }
  _cHEX3 = ''
}

to '_cBMP' char invFlag {
  comment 'Returns DEC char bitmap from _cHexTbl and
optionally converts it to inverse (XOR).
Line segments are NOT supported.
A: 00,7c,12,11,12,7c,00
dec:  0,124,18,17,17,124,0
inv:    255,131,237,238,238,131,255'
  local 'key' (((('[data:unicodeAt]' 1 char) - 32) * 8) + 1)
  local 'charList' ('[data:copyFromTo]' _cDecTBL key (key + 7))
  comment 'inverse'
  if invFlag {
    for item# (size charList) {
      atPut item# charList ((at item# charList) ^ 255)
    }
  }
  _imgWidth = 8
  _imgHeight = 8
  return charList
}

to '_clearDisplay' {
  comment 'Clear Screen without initializing _GDBuffer'
  '_initCheck'
  '_OLEDcursorReset'
  local 'clearBuff' ('[data:newByteArray]' 60 0)
  if ('i2c' == _comMode) {
    repeat 17 {
      '[sensors:i2cWrite]' OLEDi2cAddr ('[data:join]' _dataPrefix clearBuff)
    }
    '[sensors:i2cWrite]' OLEDi2cAddr ('[data:join]' _dataPrefix clearBuff)
  } else {
    '_SPIWriteData'
    '[sensors:spiExchange]' ('[data:newByteArray]' 1024)
  }
}

to '_corner' loc cx cy r erase {
  comment 'Calculates and displays the rounded corners for the rectangles.
loc is one of TL, TR, BL, BR ... topLeft, topright, bottomleft, bottomright
cx,cy are the corner coordinates for the rounded corner.
r is the radius in pixels of the arc to be calculated.'
  local 'x' (-1 * r)
  local 'y' 0
  local 'err' (2 - (2 * r))
  if (loc == 'TL') {
    cx += r
    cy += r
  } (loc == 'TR') {
    cx += (-1 * r)
    cy += r
  } (loc == 'BL') {
    cx += r
    cy += (-1 * r)
  } (loc == 'BR') {
    cx += (-1 * r)
    cy += (-1 * r)
  }
  repeatUntil (x >= 0) {
    if (loc == 'TL') {
      OLEDpixel (cx + x) (cy - y) erase
    } (loc == 'TR') {
      OLEDpixel (cx + y) (cy + x) erase
    } (loc == 'BL') {
      OLEDpixel (cx - y) (cy - x) erase
    } (loc == 'BR') {
      OLEDpixel (cx - x) (cy + y) erase
    }
    r = err
    if (r <= y) {
      y += 1
      err = (err + ((y * 2) + 1))
    }
    if (or (r > x) (err > y)) {
      x += 1
      err = (err + ((x * 2) + 1))
    }
  }
}

to '_dec2hex' num {
  comment 'Fast version w/o inversion. (~115uSecs)'
  local '_hexTbl' '0123456789ABCDEF'
  local 'hexNum' ''
  repeatUntil (num < 0) {
    if ((num / 16) != 0) {
      hexNum = ('[data:join]' (at ((num % 16) + 1) _hexTbl) hexNum)
      num = (num / 16)
    } else {
      hexNum = ('[data:join]' (at ((num % 16) + 1) _hexTbl) hexNum)
      num = -1
    }
  }
  comment 'If not half-byte length, pad it.'
  repeatUntil (((size hexNum) % 4) == 0) {
    hexNum = ('[data:join]' '0' hexNum)
  }
  return hexNum
}

to '_initChars' {
  comment 'Creates the character set used in the Library (96 characters)
used JOIN  for SPACE (uni-32) character so it won''t be deleted by mistake.
For each character, _cDecTbl is updated with 8 byte array values.'
  _cTABLE = ('[data:join]' ('[data:unicodeString]' 32) '!"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~.')
  '_T1'
  '_T2'
  '_T3'
}

to '_initCheck' {
  comment 'Verifies Library initialization status.'
  if OLEDReady {
    return 0
  } else {
    sayIt 'Display needs to be initialized before using the library blocks.'
    stopTask
  }
}

to '_initDisplayHW' {
  comment '*** DO NOT CHANGE THESE WITHOUT UNDERSTANDING THEIR MEANINGS ***
*** IT CAN MAKE THE DISPLAY NOT OPERATE CORRECTLY                          ***

Initializes display HW timings
OLED INITIALIZATION STRINGS:
1306: pins are on top
1309: pins are on the right

A8 3F - Multiplex Ratio 0F-3F (16mux to 64mux)
D3 00 - Display Offset (vertical) 00-63
40    - Display Start Line 40-7F (40:0)
A0    - Set Segment Remap A0: Remap 0:0, A1: 127:0                 [A0]
C0    - Scan Direction C0:0-127, C8:127-0                                     [C0]
DA 12 - COM pin hw config 02:double-high 12:normal bits
81 7F - Set contrast 00-FF (00:dimmest, FF:brightest)
A4    - A4:display shows GDRAM, A5:display all ON pixels
A6    - A6:Normal video, A7:Inverse video
D5 F0 - Set display clock HB:OSC freq / LB:divide ratio (00-FF)
D9 22 - Set pre-charge period HB:Phase2 / LB:Phase1 (1-15 DCLK)
DB 20 - Set Vcomh deselect level 20:1306(~0.77xVcc), 34:1309(~0.78xVcc)
8D 14 - Charge Pump Setting 10:disable CP, 14:enable CP
20 00 - Set HORIZONTAL mode
AF    - Display ON/OFF AE:off (sleep mode), AF:on'
  if (_resetPin != '-') {
    '_OLEDreset' _resetPin
  }
  if (9 == _displayType) {
    local 'initCmd' 'A8,3F,D3,00,40,A1,C8,DA,12,81,7F,A4,A6,D5,70,D9,22,DB,34,8D,14,20,00,AF'
  } else {
    local 'initCmd' 'A8,3F,D3,00,40,A1,C8,DA,12,81,7F,A4,A6,D5,70,D9,22,DB,20,8D,14,20,00,AF'
  }
  '_sendCmd' initCmd
}

to '_initLibrary' {
  comment 'Sets all Library variables and initializes the display hardware.
It also initializes the virtual GDBuffer, and clears the display.
NOTE:
Displays supported: OLED1306 (0.96in) and OLED1309 (2.42"), selected via boolean position.
OLED1309 requires the connection of RESET pin to a digital pin.
Both displays are 128x64 pixels or 16x8 characters in size.
Make sure the character hex tables are \n (LF) terminated.
Otherwise, extra lines are added in between and it gets messed up.
eg: A: 00,7C,12,11,11,12,7C,00\n
Max i2c IO is 64 bytes: buffered writes need to be max that size - 16 x 64'
  _comma = ('[data:unicodeString]' 44)
  _eol = ('[data:unicodeString]' 10)
  comment 'Col starts are in HEX'
  _dataPrefix = ('[data:newByteArray]' 1 (hexToInt '40'))
  comment 'There is no FF/255 in th cHexTBL.
this value is used to build the byteArray.'
  _cDecTBL = ('[data:newByteArray]' 768 255)
  _GDBuffer = ('[data:newByteArray]' 1024)
  _textX = 0
  _textY = 0
  _begRow = 0
  _begCol = 0
  _endRow = 7
  _endCol = 127
  _delayGDUpd = (booleanConstant false)
  '_initChars'
  OLEDReady = (booleanConstant true)
  '_OLEDsetDisplay' 'On'
  setUserLED true
  waitMillis 1000
  setUserLED false
}

to '_process image data' image {
  comment 'Processes the new hex image data format.
Each _imgHex gets added to _imgData in DEC byteArray format.
_byteCount keeps track of total bytes processed.
_imgWidth and _imgHeight (mod8) are dimensions.'
  local '_ptr' 1
  comment '_imgData is not initialized yet.'
  if (or (0 == _imgData) (not (isType _imgData 'byte array'))) {
    _imgWidth = (hexToInt ('[data:copyFromTo]' image 1 2))
    _imgHeight = (hexToInt ('[data:copyFromTo]' image 3 4))
    image = ('[data:copyFromTo]' image 5)
    comment 'If _imgHeight is partial byte, adjust to full byte'
    if (not (0 == (_imgHeight % 8))) {
      _imgHeight += (8 - (_imgHeight % 8))
    }
    _imgData = ('[data:newByteArray]' ((_imgWidth * _imgHeight) / 8))
  }
  for byte ((size image) / 2) {
    atPut (_byteCount + byte) _imgData (hexToInt ('[data:copyFromTo]' image _ptr (_ptr + 1)))
    _ptr += 2
  }
  _byteCount += byte
}

to '_sendCmd' cmdString {
  comment 'Input is a comma sep. STRING.
MAKE SURE ALL  INPUT PARAMETERS ARE HEX'
  local '_cList' ('[data:split]' cmdString _comma)
  local 'cmdPrefix' (hexToInt '80')
  if ('i2c' == _comMode) {
    for cmd _cList {
      '[sensors:i2cWrite]' OLEDi2cAddr ('[data:asByteArray]' ('[data:makeList]' cmdPrefix (hexToInt cmd)))
    }
  } else {
    '_SPIWriteCmd'
    for cmd _cList {
      spiSend (hexToInt cmd)
    }
  }
}

to '_verifyXY' x y {
  if (and (and (x >= 0) (x <= 127)) (and (y >= 0) (y <= 63))) {
    return 0
  } else {
    sayIt 'x or y value error:' ('[data:unicodeString]' 10) 'x:' x ' y:' y
    stopTask
  }
}

to 'defer display updates' {
  _delayGDUpd = (booleanConstant true)
}


module PicoBricks
author MicroBlocks
version 2 5 
depends 'Temperature Humidity (DHT11, DHT22)' 
description 'Robotistan PicoBricks Library

This library controls these Pico Bricks components:
- Red LED
- RGB LED
- DC Motors
- Piezo speaker
- Relay Switch (5V-250V, 5A)
- Button
- Potentiometer (variable resistor)
- Light sensor (light dependent resistor)
- Temperature and humidity sensor (DHT11)
- switched to renamed DHT library

Use separate libraries to control:
- Servo motors
- Graphic display (OLED)
- WIFI/Bluetooth expansion board

See https://www.robotistan.com, 
https://wiki.microblocks.fun/boards/pico
'
variables _pb_initialized _pb_pin_RedLED _pb_pin_Button _pb_pin_DHT _pb_pin_Relay _pb_pin_Pot _pb_pin_LDR _pb_pin_Buzzer _pb_pin_Motor1 _pb_pin_Motor2 _pb_pin_RGB_LED _pb_pin_TX _pb_pin_RX _pb_i2c_Addr 

  spec ' ' 'pb_beep' 'PicoBricks beep _ ms' 'auto' 500
  spec 'r' 'pb_button' 'PicoBricks button'
  spec 'r' 'pb_humidity' 'PicoBricks humidity'
  spec 'r' 'pb_light_sensor' 'PicoBricks light sensor (0-100) %'
  spec 'r' 'pb_potentiometer' 'PicoBricks potentiometer'
  spec 'r' 'pb_random_color' 'PicoBricks random color'
  spec 'r' 'pb_rgb_color' 'PicoBricks color r _ g _ b _ (0-255)' 'auto auto auto' 0 0 0
  spec ' ' 'pb_set_motor_speed' 'PicoBricks set motor _ speed _ (0-100)' 'auto num' 1 100
  spec ' ' 'pb_set_red_LED' 'PicoBricks set red LED _' 'bool' true
  spec ' ' 'pb_set_relay' 'PicoBricks set relay _' 'bool' true
  spec ' ' 'pb_set_rgb_color' 'PicoBricks set RGB LED color _' 'color'
  spec 'r' 'pb_temperature' 'PicoBricks temperature (Â°C)'
  spec ' ' 'pb_turn_off_RGB' 'PicoBricks turn off RGB LED'
  spec ' ' '_pb_init_pins' '_pb_init_pins'

to '_pb_init_pins' {
  if _pb_initialized {return}
  _pb_pin_RGB_LED = 6
  _pb_pin_RedLED = 7
  _pb_pin_Button = 10
  _pb_pin_DHT = 11
  _pb_pin_Relay = 12
  _pb_pin_Buzzer = 20
  _pb_pin_Motor1 = 21
  _pb_pin_Motor2 = 22
  _pb_pin_Pot = 26
  _pb_pin_LDR = 27
  _pb_pin_TX = 0
  _pb_pin_RX = 1
  _pb_i2c_Addr = '3C'
  _pb_initialized = (booleanConstant true)
}

to pb_beep duration {
  local 'buzzer pin' 20
  '[io:playTone]' (v 'buzzer pin') 300
  waitMillis duration
  '[io:playTone]' (v 'buzzer pin') 0
}

to pb_button {
  '_pb_init_pins'
  return (digitalReadOp _pb_pin_Button)
}

to pb_humidity {
  '_pb_init_pins'
  return (humidity_DHT11 _pb_pin_DHT)
}

to pb_light_sensor {
  comment 'Returns Light Values s a percentage:
0: dark,  100: light'
  '_pb_init_pins'
  return ('[misc:rescale]' (1023 - (analogReadOp _pb_pin_LDR)) 0 1023 0 100)
}

to pb_potentiometer {
  '_pb_init_pins'
  return (analogReadOp _pb_pin_Pot)
}

to pb_random_color {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to pb_rgb_color r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to pb_set_motor_speed which speed {
  '_pb_init_pins'
  speed = (maximum 0 (minimum speed 100))
  if (which == 1) {
    analogWriteOp _pb_pin_Motor1 ((1023 * speed) / 100)
  } (which == 2) {
    analogWriteOp _pb_pin_Motor2 ((1023 * speed) / 100)
  }
}

to pb_set_red_LED aBoolean {
  '_pb_init_pins'
  digitalWriteOp _pb_pin_RedLED aBoolean
}

to pb_set_relay aBoolean {
  '_pb_init_pins'
  digitalWriteOp _pb_pin_Relay aBoolean
}

to pb_set_rgb_color color {
  '_pb_init_pins'
  '[display:neoPixelSetPin]' _pb_pin_RGB_LED false
  '[display:neoPixelSend]' color
  waitMillis 1
}

to pb_temperature {
  '_pb_init_pins'
  return (temperature_DHT11 _pb_pin_DHT)
}

to pb_turn_off_RGB {
  '_pb_init_pins'
  '[display:neoPixelSetPin]' _pb_pin_RGB_LED false
  '[display:neoPixelSend]' 0
  waitMillis 1
}


module RobotLogo
author unknown
version 1 0 
description ''
variables _imgData _byteCount 

  spec ' ' 'R1' 'R1'
  spec ' ' 'R2' 'R2'
  spec ' ' 'RobotPIC' 'RobotPIC'

to R1 {
  comment 'Place this under P1'
  local '_imgHex' '4040FFFFFFFFFFFFFFFF4F076767676767FEFEFCF8000000F0F0F0F0E0E0E0E0E0C0C0C0C08080808000000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFF8682F282320282FFFFFFFF000000E3F1F0F8F8F0F0C00001030FFFFF7F3F1F0F8F878707060E0E1E3CFCFCFCF8E000000000000000000000FFFFFFFFFFFFFFF321A1F333931139FFFFFFFF000000F8F0E5E7E7E7E32120F0F8FEFFFFE0C0870F7F7F7F3F1F000080C0F0FFFF1F0100000000000000000000FFFFFFFFFFFFFF67263C6464672426FFFFFFFF000000F9F3F3F3F3E7E7E7E6ECCCCDCCCD9F9F9F9F3E3E3E3E7E7F7F7F3F3F1F03000000000000000000000000FFFFFFFFFFFFFFFE0C04E6E6E6060FFFFFFFFF000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC70F0F0E0E0E1E1C9CFCC484C0300000000000000000FFFFFFFFFFFFFF7F0F06627072060FFFFFFFFF000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFCC0000080C0F0FFFFFFFF8F000000000000000000'
  '_process image data' _imgHex
  _imgHex = ''
}

to R2 {
  comment 'Place this under P2'
  local '_imgHex' 'FFFFFFFFFFFFFFFE8E06727272068EFFFFFFFF000000A9ABABFBF30707FFFFAFAFAFAF8F9FBFBFBFBFBFBFBFAFA8A8AFAFAFA8FF1F1F01000000000000000000FFFFFFFFFFFFFFFFE1E3E2E6E6E6E7FF7F3F1F0000000A0A0A0F0F00000F0F0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0F000000000000000000000000'
  '_process image data' _imgHex
  _imgHex = ''
}

to RobotPIC {
  comment 'Place this under PIC'
  _imgData = 0
  _byteCount = 0
  R1
  R2
}


module Servo Output
author MicroBlocks
version 1 1 
tags servo motor angle rotation position 
description 'Control both positional (angle) and rotational servo motors.'
variables _servoPin _servoPulseWidth 

  spec ' ' 'setServoAngle' 'set servo _ to _ degrees (-90 to 90)' 'num num' 1 90
  spec ' ' 'setServoSpeed' 'set servo _ to speed _ (-100 to 100)' 'num num' 1 100
  spec ' ' 'stopServo' 'stop servo _' 'num' 1
  spec 'r' '_servoIndex' '_servoIndex _' 'num' 1
  spec ' ' '_servoPulse' '_servoPulse pin _ usecs _' 'num num' 1 1500
  spec ' ' '_servoUpdateLoop' '_servoUpdateLoop'

to '_servoIndex' which {
  if (_servoPin == 0) {
    _servoPin = ('[data:makeList]')
    _servoPulseWidth = ('[data:makeList]')
    sendBroadcast '_servoUpdateLoop'
  }
  local 'i' ('[data:find]' which _servoPin)
  if (i < 0) {
    comment 'Add new pin'
    '[data:addLast]' which _servoPin
    '[data:addLast]' '1500' _servoPulseWidth
    i = (size _servoPin)
  }
  return i
}

to '_servoPulse' pin usecs {
  if (usecs == 0) {
    comment 'Servo stopped; do nothing'
    return 0
  }
  usecs = (maximum 850 (minimum usecs 2150))
  comment 'Split wait into a long wait followed by a wait of <= 30 usecs for greater accuracy'
  local 'endTime' ((microsOp) + usecs)
  digitalWriteOp pin true
  waitMicros (usecs - 30)
  waitMicros (endTime - (microsOp))
  digitalWriteOp pin false
}

to '_servoUpdateLoop' {
  forever {
    if (_servoPin != 0) {
      comment 'If the _servoPin list is not 0, update the servos'
      for i (size _servoPin) {
        local 'pin' (at i _servoPin)
        local 'usecs' (at i _servoPulseWidth)
        if (and (pin >= 0) (usecs != 0)) {
          '_servoPulse' pin usecs
        }
      }
      waitMillis 15
    }
  }
}

to setServoAngle which degrees optionalReverse {
  local 'reversed' false
  if ((pushArgCount) > 2) {
    reversed = optionalReverse
  }
  if reversed {
    degrees = (0 - degrees)
  }
  local 'pulseWidth' (1500 - (10 * degrees))
  if ('[io:hasServo]') {
    '[io:setServo]' which pulseWidth
  } else {
    atPut ('_servoIndex' which) _servoPulseWidth pulseWidth
  }
}

to setServoSpeed which speed optionalReverse {
  local 'reversed' false
  if ((pushArgCount) > 2) {
    reversed = optionalReverse
  }
  if reversed {
    speed = (0 - speed)
  }
  local 'pulseWidth' (1500 - (10 * speed))
  if ((absoluteValue speed) < 2) {
    pulseWidth = 0
  }
  if ('[io:hasServo]') {
    '[io:setServo]' which pulseWidth
  } else {
    atPut ('_servoIndex' which) _servoPulseWidth pulseWidth
  }
}

to stopServo which {
  if ('[io:hasServo]') {
    '[io:setServo]' which 0
  } else {
    atPut ('_servoIndex' which) _servoPulseWidth 0
  }
}


module 'Temperature Humidity (DHT11, DHT22)' Input
author MicroBlocks
version 1 2 
tags sensor dht11 dht22 temperature humidity 
description 'Support for the DHT11 and DHT22 environmental sensors. These sensors provide temperature and humidity readings.'
variables _dht_temperature _dht_humidity _dhtData _dhtLastReadTime 

  spec 'r' 'temperature_DHT11' 'temperature (Celsius) DHT11 pin _' 'auto' 4
  spec 'r' 'humidity_DHT11' 'humidity DHT11 pin _' 'auto' 4
  spec 'r' 'temperature_DHT22' 'temperature (Celsius) DHT22 pin _' 'auto' 4
  spec 'r' 'humidity_DHT22' 'humidity DHT22 pin _' 'auto' 4
  spec ' ' '_dhtReadData' '_dhtReadData pin _' 'auto any' 4
  spec 'r' '_dhtChecksumOkay' '_dhtChecksumOkay' 'any'
  spec ' ' '_dhtUpdate' '_dhtUpdate _ isDHT11 _' 'auto bool any' 4 true
  spec 'r' '_dhtReady' '_dhtReady' 'any'

to '_dhtChecksumOkay' {
  if (not (isType _dhtData 'list')) {return (booleanConstant false)}
  local 'checksum' 0
  for i 4 {
    checksum += (at i _dhtData)
  }
  checksum = (checksum & 255)
  return (checksum == (at 5 _dhtData))
}

to '_dhtReadData' pin {
  comment 'Create DHT data array the first time'
  if (_dhtData == 0) {
    _dhtData = (newList 5)
  }
  comment 'fill with 1''s set checksum will be bad if read fails'
  atPut 'all' _dhtData 1
  comment 'Pull pin low for >18msec to request data'
  digitalWriteOp pin false
  waitMillis 20
  local 'useDHTPrimitive' (booleanConstant true)
  if useDHTPrimitive {
    result = ('[sensors:readDHT]' pin)
    if ((booleanConstant false) != result) {
      _dhtData = result
    }
    return 0
  }
  comment 'Read DHT start pulses (H L H L)'
  waitUntil (digitalReadOp pin)
  waitUntil (not (digitalReadOp pin))
  waitUntil (digitalReadOp pin)
  waitUntil (not (digitalReadOp pin))
  local 'i' 1
  local 'byte' 0
  local 'bit' 1
  comment 'Read 40 bits (5 bytes)'
  repeat 40 {
    waitUntil (digitalReadOp pin)
    local 'start' (microsOp)
    waitUntil (not (digitalReadOp pin))
    if (((microsOp) - start) > 40) {
      comment 'Long pulse - append a "1" bit'
      byte += 1
    }
    if (bit == 8) {
      atPut i _dhtData byte
      i += 1
      byte = 0
      bit = 1
    } else {
      byte = (byte << 1)
      bit += 1
    }
    waitUntil (not (digitalReadOp pin))
  }
}

to '_dhtReady' {
  local 'elapsed' ((millisOp) - _dhtLastReadTime)
  return (or (elapsed < 0) (elapsed > 2000))
}

to '_dhtUpdate' pin isDHT11 {
  if ('_dhtReady') {
    _dht_temperature = 0
    _dht_humidity = 0
    '_dhtReadData' pin
    _dhtLastReadTime = (millisOp)
  }
  if ('_dhtChecksumOkay') {
    if isDHT11 {
      _dht_temperature = (at 3 _dhtData)
      _dht_humidity = (at 1 _dhtData)
    } else {
      local 'n' (((at 1 _dhtData) * 256) + (at 2 _dhtData))
      _dht_humidity = ((n + 5) / 10)
      n = ((((at 3 _dhtData) & 127) * 256) + (at 4 _dhtData))
      if (((at 3 _dhtData) & 128) != 0) {
        n = (0 - n)
      }
      _dht_temperature = ((n + 5) / 10)
    }
  }
}

to humidity_DHT11 pin {
  '_dhtUpdate' pin true
  return _dht_humidity
}

to humidity_DHT22 pin {
  '_dhtUpdate' pin false
  return _dht_humidity
}

to temperature_DHT11 pin {
  '_dhtUpdate' pin true
  return _dht_temperature
}

to temperature_DHT22 pin {
  '_dhtUpdate' pin false
  return _dht_temperature
}


module picobricksLogo
author unknown
version 1 0 
description ''
variables _imgWidth _imgHeight _imgData timer _byteCount 

  spec ' ' 'PB1' 'PB1'
  spec ' ' 'PB2' 'PB2'
  spec ' ' 'PB3' 'PB3'
  spec ' ' 'pbPIC' 'pbPIC'

to PB1 {
  comment 'Place this under P1'
  local '_imgHex' '80400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE00000000000000C0E0E0C080C0E0E0E0E0C0C0800000000000E7E7E7C70000000080C0C0E0E0E0E0E0C0400000000080C0C0E0E0E0E0C0C0808000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F00000000000000FFFFFFFFC38100000081C3FFFFFF3C000000FFFFFFFF00003CFFFFFFC38100000081810000003CFFFFFF810000000081FFFFFF7E00000000000000000000000000000000000000000000000000000000000000000000'
  '_process image data' _imgHex
  _imgHex = ''
}

to PB2 {
  comment 'Place this under P2'
  local '_imgHex' '000000000000000000FEFEFEFEFEFEFEFEFEFEFE000000F8FEFEFEFEFEFEFEFEFEFEFE000000000000007F7F7F7F030307070707030301000000000007070707000000000103030707070707030200000000010303070707070303010100000000000000000000000000000000000000000000000000000000000000000000000000000000000000007FFFFFFFFFFFFFFFFFFF7F0000003F7FFFFFFFFFFFFFFFFFFF7F00000000000000F8F8F8F800008080808000000000000000808080000000808080000000001C9C9C9C0000000000000000808080800000000000F8F8F8F800000000808080808000000000008080808080800000000000000000000000000000000000000000F8FCFCFCFCFCFCFCFCFCFCFCFCFCFCFCFCFCFCFCFCFCFCFCFCF800000000000000FFFFFFFF0F07030303070FFFFEFCF00000FFFFFFFF070303030307030000FFFFFFFF000000F0FCFEFF07030303030703000000FFFFFFFFF878FEFFEF870301000000001E3F7F7F73F3F3E7E3C0000000000000000000'
  '_process image data' _imgHex
  _imgHex = ''
}

to PB3 {
  comment 'Place this under P3'
  local '_imgHex' '000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000F1F1F1F0F0E1C1C1C1E0F0F07030000000F0F0F0F0000000000000000000F1F1F1F0000000003070F0E1C1C1C1C0E0C0800001F1F1F1F00000003071F1F1E1C1000040E0F1E1C1C1C1F1F0F070000000000000000000000000000000000000001010101010101010101010101010101010101010101010100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
  '_process image data' _imgHex
  _imgHex = ''
}

to pbPIC {
  comment 'Place this under PIC'
  _imgData = 0
  _byteCount = 0
  PB1
  PB2
  PB3
}

module main
author MicroBlocks
version 1 0 
description ''

  spec ' ' 'displaySensor' 'display _ line _' 'auto auto' 123 1

to displaySensor value line {
  local 'rightJustified' ('[data:join]' '' value)
  repeatUntil ((size rightJustified) >= 4) {
    rightJustified = ('[data:join]' ' ' rightJustified)
  }
  local 'y' (8 + (12 * line))
  '[tft:text]' rightJustified 95 y (colorSwatch 35 190 30 255) 1 false
}

script 320 50 {
whenBroadcastReceived 'update display'
'[display:mbDisplayOff]'
'[tft:text]' 'PicoBricks' 0 0 (colorSwatch 35 190 30 255) 2 true
'[tft:text]' 'Potentiometer:' 10 20 (colorSwatch 35 190 30 255) 1 true
'[tft:text]' 'Light level:' 10 32 (colorSwatch 35 190 30 255) 1 true
'[tft:text]' 'Temperature:' 10 44 (colorSwatch 35 190 30 255) 1 true
'[tft:text]' 'Humidity:' 10 56 (colorSwatch 35 190 30 255) 1 true
forever {
  '_deferMonochromeDisplayUpdates'
  '[tft:rect]' 90 20 38 44 (colorSwatch 0 0 0 255) true
  displaySensor (pb_potentiometer) 1
  displaySensor (pb_light_sensor) 2
  displaySensor (pb_temperature) 3
  displaySensor (pb_humidity) 4
  '_resumeMonochromeDisplayUpdates'
  waitMillis 100
}
}

script 50 51 {
whenStarted
pb_set_relay true
waitMillis 500
pb_set_relay false
waitMillis 500
pb_set_red_LED true
pb_beep 500
pb_set_red_LED false
waitMillis 500
pb_set_rgb_color (colorSwatch 177 18 0 255)
waitMillis 500
pb_set_rgb_color (colorSwatch 19 105 16 255)
waitMillis 500
pb_set_rgb_color (colorSwatch 9 3 162 255)
waitMillis 500
pb_turn_off_RGB
sendBroadcast 'update display'
}

script 52 453 {
whenCondition (pb_button)
pb_set_red_LED true
waitUntil (not (pb_button))
pb_set_red_LED false
pb_set_rgb_color (pb_random_color)
}


module PicoBricks
author MicroBlocks
version 2 5 
depends 'Temperature Humidity (DHT11, DHT22)' 
description 'Robotistan PicoBricks Library

This library controls these Pico Bricks components:
- Red LED
- RGB LED
- DC Motors
- Piezo speaker
- Relay Switch (5V-250V, 5A)
- Button
- Potentiometer (variable resistor)
- Light sensor (light dependent resistor)
- Temperature and humidity sensor (DHT11)
- switched to renamed DHT library

Use separate libraries to control:
- Servo motors
- Graphic display (OLED)
- WIFI/Bluetooth expansion board

See https://www.robotistan.com, 
https://wiki.microblocks.fun/boards/pico
'
variables _pb_initialized _pb_pin_RedLED _pb_pin_Button _pb_pin_DHT _pb_pin_Relay _pb_pin_Pot _pb_pin_LDR _pb_pin_Buzzer _pb_pin_Motor1 _pb_pin_Motor2 _pb_pin_RGB_LED _pb_pin_TX _pb_pin_RX _pb_i2c_Addr 

  spec ' ' 'pb_beep' 'PicoBricks beep _ ms' 'auto' 500
  spec 'r' 'pb_button' 'PicoBricks button'
  spec 'r' 'pb_humidity' 'PicoBricks humidity'
  spec 'r' 'pb_light_sensor' 'PicoBricks light sensor (0-100) %'
  spec 'r' 'pb_potentiometer' 'PicoBricks potentiometer'
  spec 'r' 'pb_random_color' 'PicoBricks random color'
  spec 'r' 'pb_rgb_color' 'PicoBricks color r _ g _ b _ (0-255)' 'auto auto auto' 0 0 0
  spec ' ' 'pb_set_motor_speed' 'PicoBricks set motor _ speed _ (0-100)' 'auto num' 1 100
  spec ' ' 'pb_set_red_LED' 'PicoBricks set red LED _' 'bool' true
  spec ' ' 'pb_set_relay' 'PicoBricks set relay _' 'bool' true
  spec ' ' 'pb_set_rgb_color' 'PicoBricks set RGB LED color _' 'color'
  spec 'r' 'pb_temperature' 'PicoBricks temperature (Â°C)'
  spec ' ' 'pb_turn_off_RGB' 'PicoBricks turn off RGB LED'
  spec ' ' '_pb_init_pins' '_pb_init_pins'

to '_pb_init_pins' {
  if _pb_initialized {return}
  _pb_pin_RGB_LED = 6
  _pb_pin_RedLED = 7
  _pb_pin_Button = 10
  _pb_pin_DHT = 11
  _pb_pin_Relay = 12
  _pb_pin_Buzzer = 20
  _pb_pin_Motor1 = 21
  _pb_pin_Motor2 = 22
  _pb_pin_Pot = 26
  _pb_pin_LDR = 27
  _pb_pin_TX = 0
  _pb_pin_RX = 1
  _pb_i2c_Addr = '3C'
  _pb_initialized = (booleanConstant true)
}

to pb_beep duration {
  local 'buzzer pin' 20
  '[io:playTone]' (v 'buzzer pin') 300
  waitMillis duration
  '[io:playTone]' (v 'buzzer pin') 0
}

to pb_button {
  '_pb_init_pins'
  return (digitalReadOp _pb_pin_Button)
}

to pb_humidity {
  '_pb_init_pins'
  return (humidity_DHT11 _pb_pin_DHT)
}

to pb_light_sensor {
  comment 'Returns Light Values s a percentage:
0: dark,  100: light'
  '_pb_init_pins'
  return ('[misc:rescale]' (1023 - (analogReadOp _pb_pin_LDR)) 0 1023 0 100)
}

to pb_potentiometer {
  '_pb_init_pins'
  return (analogReadOp _pb_pin_Pot)
}

to pb_random_color {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to pb_rgb_color r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to pb_set_motor_speed which speed {
  '_pb_init_pins'
  speed = (maximum 0 (minimum speed 100))
  if (which == 1) {
    analogWriteOp _pb_pin_Motor1 ((1023 * speed) / 100)
  } (which == 2) {
    analogWriteOp _pb_pin_Motor2 ((1023 * speed) / 100)
  }
}

to pb_set_red_LED aBoolean {
  '_pb_init_pins'
  digitalWriteOp _pb_pin_RedLED aBoolean
}

to pb_set_relay aBoolean {
  '_pb_init_pins'
  digitalWriteOp _pb_pin_Relay aBoolean
}

to pb_set_rgb_color color {
  '_pb_init_pins'
  '[display:neoPixelSetPin]' _pb_pin_RGB_LED false
  '[display:neoPixelSend]' color
  waitMillis 1
}

to pb_temperature {
  '_pb_init_pins'
  return (temperature_DHT11 _pb_pin_DHT)
}

to pb_turn_off_RGB {
  '_pb_init_pins'
  '[display:neoPixelSetPin]' _pb_pin_RGB_LED false
  '[display:neoPixelSend]' 0
  waitMillis 1
}


module TFT Output
author MicroBlocks
version 1 5 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  space
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}


module 'Temperature Humidity (DHT11, DHT22)' Input
author MicroBlocks
version 1 2 
tags sensor dht11 dht22 temperature humidity 
description 'Support for the DHT11 and DHT22 environmental sensors. These sensors provide temperature and humidity readings.'
variables _dht_temperature _dht_humidity _dhtData _dhtLastReadTime 

  spec 'r' 'temperature_DHT11' 'temperature (Celsius) DHT11 pin _' 'auto' 4
  spec 'r' 'humidity_DHT11' 'humidity DHT11 pin _' 'auto' 4
  spec 'r' 'temperature_DHT22' 'temperature (Celsius) DHT22 pin _' 'auto' 4
  spec 'r' 'humidity_DHT22' 'humidity DHT22 pin _' 'auto' 4
  spec ' ' '_dhtReadData' '_dhtReadData pin _' 'auto any' 4
  spec 'r' '_dhtChecksumOkay' '_dhtChecksumOkay' 'any'
  spec ' ' '_dhtUpdate' '_dhtUpdate _ isDHT11 _' 'auto bool any' 4 true
  spec 'r' '_dhtReady' '_dhtReady' 'any'

to '_dhtChecksumOkay' {
  if (not (isType _dhtData 'list')) {return (booleanConstant false)}
  local 'checksum' 0
  for i 4 {
    checksum += (at i _dhtData)
  }
  checksum = (checksum & 255)
  return (checksum == (at 5 _dhtData))
}

to '_dhtReadData' pin {
  comment 'Create DHT data array the first time'
  if (_dhtData == 0) {
    _dhtData = (newList 5)
  }
  comment 'fill with 1''s set checksum will be bad if read fails'
  atPut 'all' _dhtData 1
  comment 'Pull pin low for >18msec to request data'
  digitalWriteOp pin false
  waitMillis 20
  local 'useDHTPrimitive' (booleanConstant true)
  if useDHTPrimitive {
    result = ('[sensors:readDHT]' pin)
    if ((booleanConstant false) != result) {
      _dhtData = result
    }
    return 0
  }
  comment 'Read DHT start pulses (H L H L)'
  waitUntil (digitalReadOp pin)
  waitUntil (not (digitalReadOp pin))
  waitUntil (digitalReadOp pin)
  waitUntil (not (digitalReadOp pin))
  local 'i' 1
  local 'byte' 0
  local 'bit' 1
  comment 'Read 40 bits (5 bytes)'
  repeat 40 {
    waitUntil (digitalReadOp pin)
    local 'start' (microsOp)
    waitUntil (not (digitalReadOp pin))
    if (((microsOp) - start) > 40) {
      comment 'Long pulse - append a "1" bit'
      byte += 1
    }
    if (bit == 8) {
      atPut i _dhtData byte
      i += 1
      byte = 0
      bit = 1
    } else {
      byte = (byte << 1)
      bit += 1
    }
    waitUntil (not (digitalReadOp pin))
  }
}

to '_dhtReady' {
  local 'elapsed' ((millisOp) - _dhtLastReadTime)
  return (or (elapsed < 0) (elapsed > 2000))
}

to '_dhtUpdate' pin isDHT11 {
  if ('_dhtReady') {
    _dht_temperature = 0
    _dht_humidity = 0
    '_dhtReadData' pin
    _dhtLastReadTime = (millisOp)
  }
  if ('_dhtChecksumOkay') {
    if isDHT11 {
      _dht_temperature = (at 3 _dhtData)
      _dht_humidity = (at 1 _dhtData)
    } else {
      local 'n' (((at 1 _dhtData) * 256) + (at 2 _dhtData))
      _dht_humidity = ((n + 5) / 10)
      n = ((((at 3 _dhtData) & 127) * 256) + (at 4 _dhtData))
      if (((at 3 _dhtData) & 128) != 0) {
        n = (0 - n)
      }
      _dht_temperature = ((n + 5) / 10)
    }
  }
}

to humidity_DHT11 pin {
  '_dhtUpdate' pin true
  return _dht_humidity
}

to humidity_DHT22 pin {
  '_dhtUpdate' pin false
  return _dht_humidity
}

to temperature_DHT11 pin {
  '_dhtUpdate' pin true
  return _dht_temperature
}

to temperature_DHT22 pin {
  '_dhtUpdate' pin false
  return _dht_temperature
}

module main
author unknown
version 1 0 
description ''

  spec ' ' 'part A' 'part A'
  spec ' ' 'part A2' 'part A1'
  spec ' ' 'part A3' 'part A2'

to 'part A' {
  'play tone' 'C' 2 250
  'play tone' 'D' 2 250
  'play tone' 'D#' 2 400
  waitMillis 100
  'play tone' 'D' 2 250
  'play tone' 'C' 2 250
  'play tone' 'B' 1 400
  waitMillis 100
  'play tone' 'C' 2 250
  'play tone' 'D' 2 250
  'play tone' 'G' 1 400
  waitMillis 100
  'play tone' 'A' 1 250
  'play tone' 'B' 1 250
  'play tone' 'C' 2 400
  waitMillis 100
  'play tone' 'A#' 1 250
  'play tone' 'G#' 1 250
  'play tone' 'G' 1 400
  waitMillis 100
}

to 'part A2' {
  'play tone' 'F' 1 250
  'play tone' 'D#' 1 250
  'play tone' 'D' 1 400
  waitMillis 100
  'play tone' 'D#' 1 250
  'play tone' 'F' 1 250
  'play tone' 'G' 1 250
  'play tone' 'F' 1 250
  'play tone' 'D#' 1 250
  'play tone' 'D' 1 250
  'play tone' 'C' 1 400
  waitMillis 100
}

to 'part A3' {
  'play tone' 'F' 1 250
  'play tone' 'D#' 1 250
  'play tone' 'D' 1 350
  waitMillis 100
  'play tone' 'D#' 1 125
  'play tone' 'D' 1 125
  repeat 4 {
    'play tone' 'D#' 1 70
    'play tone' 'D' 1 55
  }
  waitMillis 25
  'play tone' 'D#' 1 200
  waitMillis 100
  'play tone' 'D#' 1 1000
}

script 50 50 {
whenStarted
comment 'On a micro:bit, attach a piezo speaker between pin 0 and ground'
comment 'This will use the built-in speaker on boards that have one
such as the Circuit Playground Express, ED1, or M5Stack.'
'part A'
'part A2'
'part A'
'part A3'
}

script 179 189 {
comment 'To see what each "part" block does, right click
on it and select "show block definition..."'
'part A'
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''

script 54 50 {
whenStarted
comment 'On a micro:bit, attach a piezo speaker between pin 0 and ground'
comment 'This will use the built-in speaker on boards that have one
such as the Circuit Playground Express, ED1, or M5Stack.'
local 'eigth' 150
local 'quarter' (2 * eigth)
local 'half' (2 * quarter)
repeat 2 {
  'play tone' 'C' 1 quarter
  'play tone' 'D' 1 quarter
  'play tone' 'E' 1 quarter
  'play tone' 'C' 1 quarter
}
repeat 2 {
  'play tone' 'E' 1 quarter
  'play tone' 'F' 1 quarter
  'play tone' 'G' 1 half
}
repeat 2 {
  'play tone' 'G' 1 eigth
  'play tone' 'A' 1 eigth
  'play tone' 'G' 1 eigth
  'play tone' 'F' 1 eigth
  'play tone' 'E' 1 quarter
  'play tone' 'C' 1 quarter
}
repeat 2 {
  'play tone' 'C' 1 quarter
  'play tone' 'G' 0 quarter
  'play tone' 'C' 1 half
}
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''

  spec ' ' 'happy-birthday' 'happy-birthday'
  spec ' ' 'and-many-more' 'and-many-more'

to 'and-many-more' {
  local 'third' 266
  local 'whole' (3 * third)
  'play tone' 'D' 1 third
  'play tone' 'E' 1 third
  'play tone' 'D' 1 third
  'play tone' 'F' 1 whole
}

to 'happy-birthday' {
  local 'eigth' 200
  local 'quarter' (2 * eigth)
  local 'half' (2 * quarter)
  comment 'happy birthday part 1'
  'play tone' 'D' 1 eigth
  'play tone' 'D' 1 eigth
  'play tone' 'E' 1 quarter
  'play tone' 'D' 1 quarter
  'play tone' 'G' 1 quarter
  'play tone' 'F#' 1 half
  comment 'happy birthday part 2'
  'play tone' 'D' 1 eigth
  'play tone' 'D' 1 eigth
  'play tone' 'E' 1 quarter
  'play tone' 'D' 1 quarter
  'play tone' 'A' 1 quarter
  'play tone' 'G' 1 half
  comment 'happy birthday part 3'
  'play tone' 'D' 1 eigth
  'play tone' 'D' 1 eigth
  'play tone' 'D' 2 quarter
  'play tone' 'B' 1 quarter
  'play tone' 'G' 1 quarter
  'play tone' 'F#' 1 quarter
  'play tone' 'E' 1 quarter
  comment 'happy birthday part 4'
  'play tone' 'C' 2 eigth
  'play tone' 'C' 2 eigth
  'play tone' 'B' 1 quarter
  'play tone' 'G' 1 quarter
  'play tone' 'A' 1 quarter
  'play tone' 'G' 1 half
  waitMillis half
}

script 55 50 {
whenButtonPressed 'A'
comment 'On a micro:bit, attach a piezo speaker between pin 0 and ground'
comment 'This will use the built-in speaker on boards that have one
such as the Circuit Playground Express, ED1, or M5Stack.'
sendBroadcast 'show message'
'happy-birthday'
'and-many-more'
}

script 267 181 {
comment 'To see what each of these block does, right click
on it and select "show block definition..."'
'happy-birthday'
'and-many-more'
}

script 438 250 {
whenBroadcastReceived 'show message'
scroll_text 'HAPPY BIRTHDAY!'
}

script 55 301 {
whenStarted
comment 'Works out of the box on the Adafruit Circuit Playground Express.

For other boards, you''ll need to attach a NeoPixel strip and a buzzer, and
set their pin configurations in the following two blocks:'
'attach buzzer to pin' ''
neoPixelAttach 10 ''
setNeoPixelColor 1 (colorSwatch 35 190 30 255)
setNeoPixelColor 2 (colorSwatch 187 7 191 255)
setNeoPixelColor 3 (colorSwatch 191 149 2 255)
forever {
  waitMillis 400
  rotateNeoPixelsBy 3
}
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}


module NeoPixel Output
author MicroBlocks
version 1 6 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if ((boardType) == 'M5Atom-Matrix') {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'Mbits') {
    neoPixelAttach 25 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'r' ((rgb >> 16) & 255)
    local 'g' ((rgb >> 8) & 255)
    local 'b' (rgb & 255)
    local 'brightness' (maximum r g b)
    if (delta > 0) {
      delta = (minimum delta (255 - brightness))
    } else {
      delta = (maximum delta (42 - brightness))
    }
    r = (maximum 0 (minimum (r + delta) 255))
    g = (maximum 0 (minimum (g + delta) 255))
    b = (maximum 0 (minimum (b + delta) 255))
    atPut i _np_pixels (colorFromRGB r g b)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_update' {
  '[display:neoPixelSend]' _np_pixels
  waitMicros 100
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  hasWhite = false
  if ((pushArgCount) > 2) {
    hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  fillList _np_pixels 0
  '[display:neoPixelSetPin]' pinNumber hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels color
  '_NeoPixel_update'
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' (n > 0)
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''
variables e h 'h.' q 'q.' 

  spec ' ' 'part' 'part1'
  spec ' ' 'part2' 'part2'
  spec ' ' 'part3' 'part3'
  spec ' ' 'part4' 'part4'

to part {
  waitMillis q
  'play tone' 'B' 0 q
  'play tone' 'E' 1 q.
  'play tone' 'G' 1 e
  'play tone' 'F#' 1 q
  'play tone' 'E' 1 h
  'play tone' 'B' 1 q
  'play tone' 'A' 1 h.
  'play tone' 'F#' 1 h.
  'play tone' 'E' 1 q.
  'play tone' 'G' 1 e
  'play tone' 'F#' 1 q
  'play tone' 'D' 1 h
  'play tone' 'F' 1 q
  'play tone' 'B' 0 h.
}

to part2 {
  waitMillis q
  'play tone' 'B' 0 q
  'play tone' 'E' 1 q.
  'play tone' 'G' 1 e
  'play tone' 'F#' 1 q
  'play tone' 'E' 1 h
  'play tone' 'B' 1 q
  'play tone' 'D' 2 h
  'play tone' 'C#' 2 q
  'play tone' 'C' 2 h
  'play tone' 'G#' 1 q
  'play tone' 'C' 2 q.
  'play tone' 'B' 1 e
  'play tone' 'A#' 1 q
  'play tone' 'F#' 1 h
  'play tone' 'G' 1 q
  'play tone' 'E' 1 h.
}

to part3 {
  waitMillis q
  'play tone' 'E' 1 q
  'play tone' 'G' 1 q
  'play tone' 'B' 1 h
  'play tone' 'G' 1 q
  'play tone' 'B' 1 h
  'play tone' 'G' 1 q
  'play tone' 'C' 2 h
  'play tone' 'B' 1 q
  'play tone' 'A#' 1 h
  'play tone' 'F#' 1 q
  'play tone' 'G' 1 q.
  'play tone' 'B' 1 e
  'play tone' 'A#' 1 q
  'play tone' 'A#' 0 h
  'play tone' 'B' 0 q
  'play tone' 'B' 1 h.
}

to part4 {
  waitMillis q
  'play tone' 'E' 1 q
  'play tone' 'G' 1 q
  'play tone' 'B' 1 h
  'play tone' 'G' 1 q
  'play tone' 'B' 1 h
  'play tone' 'G' 1 q
  'play tone' 'D' 2 h
  'play tone' 'C#' 2 q
  'play tone' 'C' 2 h
  'play tone' 'G#' 1 q
  'play tone' 'C' 2 q.
  'play tone' 'B' 1 e
  'play tone' 'A#' 1 q
  'play tone' 'F#' 1 h
  'play tone' 'G' 1 q
  'play tone' 'E' 1 h.
}

script 50 50 {
whenStarted
comment 'On a micro:bit, attach a piezo speaker between pin 0 and ground'
comment 'This will use the built-in speaker on boards that have one
such as the Circuit Playground Express, ED1, or M5Stack.'
e = 150
q = (2 * e)
q. = (3 * e)
h = (4 * e)
h. = (6 * e)
w = (8 * e)
part
part2
part3
part4
}

script 279 199 {
comment 'To see what each "part" block does, right click
on it and select "show block definition..."'
part
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''
variables eighth quarter whole 

script 50 50 {
whenStarted
comment 'On a micro:bit, attach a piezo speaker between pin 0 and ground'
comment 'This will use the built-in speaker on boards that have one
such as the Circuit Playground Express, ED1, or M5Stack.'
whole = 320
quarter = (whole / 2)
eighth = (whole / 8)
'play tone' 'F' 1 whole
waitMillis quarter
'play tone' 'C' 2 (whole + eighth)
waitMillis (quarter - eighth)
'play tone' 'C' 1 quarter
'play tone' 'D' 1 quarter
'play tone' 'E' 1 quarter
forever {
  repeat 2 {
    'play tone' 'F' 1 whole
    'play tone' 'G#' 1 quarter
    'play tone' 'F' 1 whole
    'play tone' 'G#' 1 quarter
    'play tone' 'G' 1 quarter
    'play tone' 'F' 1 quarter
    'play tone' 'E' 1 quarter
  }
  'play tone' 'F' 1 whole
  repeat 2 {
    'play tone' 'G#' 1 quarter
    'play tone' 'G' 1 (quarter - eighth)
    waitMillis eighth
    'play tone' 'G' 1 quarter
    'play tone' 'G#' 1 quarter
    'play tone' 'A#' 1 (quarter - eighth)
    waitMillis eighth
    'play tone' 'A#' 1 quarter
    'play tone' 'G#' 1 quarter
    'play tone' 'G' 1 whole
    'play tone' 'C' 2 quarter
    'play tone' 'C' 1 whole
  }
  'play tone' 'G#' 1 quarter
  'play tone' 'G' 1 quarter
  'play tone' 'G#' 1 quarter
  'play tone' 'A#' 1 quarter
  repeat 7 {
    'play tone' 'C' 2 (quarter - eighth)
    waitMillis eighth
  }
  'play tone' 'A#' 1 quarter
  'play tone' 'G#' 1 quarter
  'play tone' 'G' 1 quarter
  'play tone' 'G#' 1 quarter
  'play tone' 'G' 1 quarter
}
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author unknown
version 1 0 
description ''
variables full half quarter 

script 50 50 {
whenStarted
comment 'On a micro:bit, attach a piezo speaker between pin 0 and ground'
comment 'This will use the built-in speaker on boards that have one
such as the Circuit Playground Express, ED1, or M5Stack.'
full = 360
half = (full / 2)
quarter = (full / 4)
repeat 2 {
  'play tone' 'G' 2 quarter
  'play tone' 'F' 2 quarter
  'play tone' 'G' 2 full
  'play tone' 'C' 2 full
  waitMillis (full + half)
  'play tone' 'G#' 2 quarter
  'play tone' 'G' 2 quarter
  'play tone' 'G#' 2 half
  'play tone' 'G' 2 half
  'play tone' 'F' 2 full
  waitMillis (full + half)
  'play tone' 'G#' 2 quarter
  'play tone' 'G' 2 quarter
  'play tone' 'G#' 2 full
  'play tone' 'C' 2 full
  'play tone' 'D' 2 full
  waitMillis half
  'play tone' 'F' 2 quarter
  'play tone' 'D#' 2 quarter
  'play tone' 'F' 2 half
  'play tone' 'D#' 2 half
  'play tone' 'D' 2 half
  'play tone' 'F' 2 half
  'play tone' 'D#' 2 full
  waitMillis half
}
'play tone' 'D' 2 quarter
'play tone' 'D#' 2 quarter
'play tone' 'F' 2 (full + half)
'play tone' 'D#' 2 quarter
'play tone' 'F' 2 quarter
'play tone' 'G' 2 half
'play tone' 'F' 2 half
'play tone' 'D#' 2 half
'play tone' 'D' 2 half
'play tone' 'C' 2 full
'play tone' 'G#' 2 full
'play tone' 'G' 2 (full * 3)
waitMillis quarter
'play tone' 'G' 2 quarter
'play tone' 'G#' 2 quarter
'play tone' 'G' 2 quarter
'play tone' 'F' 2 quarter
'play tone' 'G' 2 (full * 2)
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author 'JosÃ© GarcÃ­a Yeste'
version 1 0 
description ''
variables server _day _hours _minutes _month _seconds _year 

  spec 'r' 'online date from server' 'date and time from server _' 'auto' 'microblocks.fun'
  spec 'r' 'files list' 'files list'
  spec 'r' 'main menu' 'main page'
  spec ' ' 'write' 'write _ to file _' 'auto auto' '' ''
  spec 'r' 'file deleted' 'delete file _' 'auto' ''
  spec 'r' 'graph with data' 'graph data from file _' 'auto' '(list)'
  spec 'r' 'read file' 'read file _' 'auto' ''
  spec 'r' 'delete all files' 'delete all files'
  spec 'r' 'decimal' 'decimal _' 'auto' 123
  spec 'r' 'chart script' 'html chart script'
  spec 'r' 'download as csv file' 'html download as csv file _' 'auto' ''
  spec 'r' 'html chart from colum' 'html chart from file _ column _' 'auto auto' '' 1
  spec 'r' 'column names' 'column names _' 'auto' 1
  spec 'r' 'current time short' 'current time short'

to 'chart script' {
  return '<head>
<script src="https://unpkg.com/tlx/browser/tlx.js"></script>
<script src="https://unpkg.com/tlx-chart/browser/tlx-chart.js"></script>
</head>'
}

to 'column names' index {
  return (at index ('[data:makeList]' 'Temperature (&deg;C)' 'Humidity %' 'Air Pressure (mBar)' 'Gas (m&Omega;)'))
}

to 'current time short' {
  comment '+Timezone +Daylightsaving '
  local 'hours' (_hours + (1 + 0))
  local 'minutes' _minutes
  if (hours < 10) {
    hours = ('[data:join]' '0' hours)
  }
  if (minutes < 10) {
    minutes = ('[data:join]' '0' minutes)
  }
  return ('[data:join]' hours ':' minutes)
}

to decimal int {
  comment 'one decimal'
  return ('[data:join]' (int / 10) '.' (int % 10))
}

to 'delete all files' {
  for name ('file names') {
    '[file:delete]' name
  }
  return '<p>All files  removed successfully</p>
<button onclick="location.href=''/''" type="button">Back</button>'
}

to 'download as csv file' filename {
  return ('[data:join]' '<button onclick="location.href=''/' filename '.csv''" type="button">Download as CSV</button>
<br><br>
<button onclick="location.href=''/''" type="button">Back</button>')
}

to 'file deleted' name {
  '[file:delete]' name
  if (('[data:find]' ('current date') ('file names')) == -1) {
    return ('[data:join]' '<p>File ' name ' removed successfully</p>
<button onclick="location.href=''/''" type="button">Back</button>')
  } else {
    return ('[data:join]' '<p>Error removing file ' name '</p>
<button onclick="location.href=''/''" type="button">Back</button>')
  }
}

to 'files list' {
  local 'string' ''
  for 'file name' ('file names') {
    string = ('[data:join]' string '<li><a href="/' (v 'file name') '">' (v 'file name') '</a>&nbsp<button onclick="location.href=''/' (v 'file name') '/delete''" type="button">Delete</button></li>')
  }
  return string
}

to 'graph with data' filename {
  local 'html' ('[data:join]' ('chart script') '<body><h1>BME680 </h1>')
  for i 4 {
    html = ('[data:join]' html ('html chart from colum' filename i))
  }
  return ('[data:join]' html ('download as csv file' filename) '</body>')
}

to 'html chart from colum' filename col {
  local 'html' ('[data:join]' '<b>' ('column names' col) '</b>
<tlx-chart chart-type="LineChart" 
	chart-columns="${[''Timestamp'',''' ('column names' col) ''']}" 
	chart-data="${[')
  '[file:open]' filename
  comment 'Only the last 60 reads (aprox. 30 chars per line) Max 110 for ESP32 16000 bytes memory'
  local 'read_size' (30 * 60)
  if (('[file:fileSize]' filename) > read_size) {
    '[file:setReadPosition]' (('[file:fileSize]' filename) - read_size) filename
    local 'var' ('[file:readLine]' filename)
  }
  repeatUntil ('[file:endOfFile]' filename) {
    local 'colums' ('[data:split]' ('[file:readLine]' filename) ',')
    html = ('[data:join]' html '[' ('[data:join]' (at 1 colums) ',' (at (col + 1) colums)) '],')
  }
  '[file:close]' filename
  html = ('[data:join]' html ']}">
</tlx-chart>')
  return html
}

to 'main menu' {
  return ('[data:join]' '<h1>BME680 </h1>
<h3>Current values (Temperature &deg;C / Humidity % / Pressure mBar / Gas m&Omega;): ' ('[data:join]' (decimal ('bme680 temperature')) ' / ' (decimal ('bme680 humidity')) ' / ' (decimal ('bme680 pressure')) ' / ' (decimal ('bme680 gas'))) '</h3>
<p>Daily records with data registered every minute. Click on each link to visualize them in a linear graph:</p>
<ul>' ('files list') '</ul>
<button onclick="location.href=''/deleteAll''" type="button">Delete all files</button>
<br><br>
<i>File system info:  ' ('[file:systemInfo]'))
}

to 'read file' name {
  '[file:open]' name
  local 'string' ''
  repeatUntil ('[file:endOfFile]' name) {
    string = ('[data:join]' string ('[file:readLine]' name) ('[data:unicodeString]' 13))
  }
  '[file:close]' name
  return string
}

to write data name {
  '[file:open]' name
  '[file:appendLine]' data name
  '[file:close]' name
}

script 667 50 {
whenBroadcastReceived 'connected'
forever {
  if (('current date') == '0-00-0') {
    'fetch current time from server' 'microblocks.fun'
  } else {
    if ((timer) >= 60000) {
      write ('[data:join]' '''' ('current time short') ''',' (decimal ('bme680 temperature')) ',' (decimal ('bme680 humidity')) ',' (decimal ('bme680 pressure')) ',' (decimal ('bme680 gas'))) ('current date')
      resetTimer
    }
  }
  tick
}
}

script 51 60 {
whenStarted
wifiConnect 'Network_Name' ''
sendBroadcast 'connected'
forever {
  local 'request' ('[net:httpServerGetRequest]')
  if (request != '') {
    local 'path' ('path of request' request)
    if (path == '/') {
      '[net:respondToHttpRequest]' '200 OK' ('main menu')
    }
    if (path == '/deleteAll') {
      '[net:respondToHttpRequest]' '200 OK' ('delete all files')
    }
    for name ('file names') {
      if (path == ('[data:join]' '/' name)) {'[net:respondToHttpRequest]' '200 OK' ('graph with data' name)}
      if (path == ('[data:join]' '/' name '/delete')) {'[net:respondToHttpRequest]' '200 OK' ('file deleted' name)}
      if (path == ('[data:join]' '/' name '.csv')) {'[net:respondToHttpRequest]' '200 OK' ('read file' name) 'Content-Type: text/csv'}
    }
    '[net:respondToHttpRequest]' '404 Not Found' '<h1>404 Not Found</h1><p>I''m sorry, this page does not exist :(</p>'
  }
  waitMillis 10
}
}


module DateTime
author unknown
version 1 0 
description ''
variables _day _hours _minutes _month _seconds _year 

  spec ' ' 'fetch current time from server' 'fetch date and time from server _' 'auto' 'microblocks.fun'
  spec ' ' 'tick' 'tick'
  spec 'r' 'current date' 'current date'
  spec 'r' 'current time' 'current time'
  spec 'r' 'online date from server' 'date and time from server _' 'auto' 'microblocks.fun'
  spec 'r' 'seconds' 'seconds'

to 'current date' {
  local 'month' _month
  if (month < 10) {
    month = ('[data:join]' '0' month)
  }
  return ('[data:join]' _year '-' month '-' _day)
}

to 'current time' {
  local 'hours' _hours
  local 'minutes' _minutes
  local 'seconds' _seconds
  if (hours < 10) {
    hours = ('[data:join]' '0' hours)
  }
  if (minutes < 10) {
    minutes = ('[data:join]' '0' minutes)
  }
  if (seconds < 10) {
    seconds = ('[data:join]' '0' seconds)
  }
  return ('[data:join]' hours ':' minutes ':' seconds)
}

to 'fetch current time from server' url {
  local 'current datetime' ('online date from server' url)
  _year = ('[data:copyFromTo]' (v 'current datetime') 8 11)
  _day = ('[data:copyFromTo]' (v 'current datetime') 1 2)
  local 'month names' ('[data:makeList]' 'Jan' 'Feb' 'Mar' 'Apr' 'May' 'Jun' 'Jul' 'Aug' 'Sep' 'Oct' 'Nov' 'Dec')
  local 'month name' ('[data:copyFromTo]' (v 'current datetime') 4 6)
  _month = 1
  repeatUntil ((at _month (v 'month names')) == (v 'month name')) {
    _month += 1
  }
  local 'start ms' (millisOp)
  _hours = (('[data:copyFromTo]' (v 'current datetime') 13 14) + 1)
  _minutes = (('[data:copyFromTo]' (v 'current datetime') 16 17) + 0)
  _seconds = (('[data:copyFromTo]' (v 'current datetime') 19 20) - (((millisOp) - (v 'start ms')) / 1000))
}

to 'online date from server' server {
  local 'url' ('[data:join]' server '/nonExistentPage')
  local 'response' ('_request_url' url 'GET' '')
  local 'header' ('_http_header_text' response)
  return ('[data:copyFromTo]' header (('[data:find]' 'Date:' header) + 11) (('[data:find]' 'GMT' header) - 2))
}

to seconds {
  return _seconds
}

to tick {
  _seconds += 1
  if (_seconds == 60) {
    _seconds = 0
    _minutes += 1
    if (_minutes == 60) {
      _minutes = 0
      _hours += 1
      if (_hours == 24) {
        _hours = 0
      }
    }
  }
  waitMillis 1000
}


module Files Data
author MicroBlocks
version 1 3 
description 'Flash file system operations. Currently supports the LittleFS file system on ESP8266 and ESP32 boards. The GnuBlocks virtual machine (Linux and Raspberry Pi) supports the native system.'

  spec ' ' '[file:open]' 'open file _' 'str'
  spec ' ' '[file:close]' 'close file _' 'str'
  spec ' ' '[file:delete]' 'delete file _' 'str'
  space
  spec ' ' '[file:appendLine]' 'append line _ to file _' 'str str'
  spec ' ' '[file:appendBytes]' 'append bytes _ to file _' 'str str'
  space
  spec 'r' '[file:endOfFile]' 'end of file _' 'str'
  spec 'r' '[file:readLine]' 'next line of file _' 'str'
  spec 'r' '[file:readBytes]' 'next _ bytes of file _ : starting at _' 'num str num' 100 '' 0
  spec 'r' '[file:readInto]' 'read into _ from file _' 'str str' 'a ByteArray' ''
  space
  spec 'r' '[file:readPosition]' 'read position of file _' 'str'
  spec ' ' '[file:setReadPosition]' 'set read position _ of file _' 'num str' 0 ''
  spec ' ' 'file_SkipBytes' 'skip _ bytes of file _' 'num str' 4 ''
  space
  spec 'r' 'file names' 'file names : in directory _' 'str'
  spec 'r' '[file:fileSize]' 'size of file _' 'str'
  spec 'r' '[file:systemInfo]' 'file system info'

to 'file names' dir {
  '[file:startList]' dir
  local 'result' ('[data:makeList]')
  local 'fileName' ('[file:nextInList]')
  repeatUntil (fileName == '') {
    '[data:addLast]' fileName result
    fileName = ('[file:nextInList]')
  }
  return result
}

to file_SkipBytes offset file {
  local 'newPosition' (('[file:readPosition]' file) + offset)
  '[file:setReadPosition]' newPosition file
}


module 'Gas (BME680)' Input
author 'JosÃ© GarcÃ­a Yeste'
version 1 0 
description 'Suport for Bosch BME680 sensor
Temperature, Humidity, Air Pressure and Gas Sensor

Based on https://github.com/Zanduino/BME680

Tested on TeslaLAB Galileo Univestiy Board
'
variables _bme680 _bme680_last _bme680_raw _bme680_t _bme680_p _bme680_h _bme680_g 

  spec ' ' '_bme680 setup' '_bme680 setup'
  spec 'r' 'bme680 connected' 'bme680 connected'
  spec 'r' '_bme680 read int' '_bme680 read int16 _' 'auto' 0
  spec 'r' '_bme680 read word' '_bme680 read word _' 'auto' 0
  spec ' ' '_bme680 read raw' '_bme680 read raw'
  spec 'r' 'bme680 temperature' 'bme680 temperature (Â°C x10)'
  spec 'r' '_bm680 read int8' '_bm680 read int8 _' 'auto' 0
  spec 'r' 'bme680 pressure' 'bme680 pressure (mBar x10)'
  spec ' ' '_bme680_set_bits' '_bme680_set_bits reg _ mask _ pos _ val _' 'auto auto auto auto' 0 0 0 0
  spec 'r' '_bme680 temperature' '_bme680 temperature'
  spec 'r' 'bme680 humidity' 'bme680 humidity (% x10)'
  spec ' ' '_bm680 read humidity coefficients' '_bm680 read humidity coefficients'
  spec ' ' '_bme680 read pressure coefficients' '_bme680 read pressure coefficients'
  spec ' ' '_bme680 read temperature coefficients' '_bme680 read temperature coefficients'
  spec ' ' '_read gas coefficients' '_read gas coefficients'
  spec 'r' 'bme680 gas' 'bme680 gas resistance (mÎ© x10)'
  spec ' ' 'bme680 set gas' 'bme680 set gas to _ degrees for _ millisecs' 'auto auto' 320 150
  spec ' ' 'bme680 set address to' 'bme680 set address to _' 'auto' 119

to '_bm680 read humidity coefficients' {
  _bme680_h = ('[data:makeList]')
  local 'h' (i2cGet _bme680 ((hexToInt 'E1') + 1))
  '[data:addLast]' (((i2cGet _bme680 ((hexToInt 'E1') + 2)) << 4) | ((h >> 4) & (hexToInt '0F'))) _bme680_h
  '[data:addLast]' (((i2cGet _bme680 (hexToInt 'E1')) << 4) | ((h >> 4) & (hexToInt '0F'))) _bme680_h
  '[data:addLast]' ('_bm680 read int8' 28) _bme680_h
  '[data:addLast]' ('_bm680 read int8' 29) _bme680_h
  '[data:addLast]' ('_bm680 read int8' 30) _bme680_h
  '[data:addLast]' (i2cGet _bme680 ((hexToInt 'E1') + (31 - 25))) _bme680_h
  '[data:addLast]' ('_bm680 read int8' 32) _bme680_h
}

to '_bm680 read int8' index {
  if (index > 25) {
    local 'reg' ((hexToInt 'E1') + (index - 25))
  } else {
    local 'reg' ((hexToInt '89') + index)
  }
  local 'val' (i2cGet _bme680 reg)
  if (val > 128) {
    return (val - 256)
  } else {
    return val
  }
}

to '_bme680 read int' index {
  if (index > 25) {
    local 'reg' ((hexToInt 'E1') + (index - 25))
  } else {
    local 'reg' ((hexToInt '89') + index)
  }
  local 'val' (((i2cGet _bme680 (reg + 1)) << 8) | (i2cGet _bme680 reg))
  if (val > 32768) {
    return (val - 65536)
  } else {
    return val
  }
  local 'var' 0
}

to '_bme680 read pressure coefficients' {
  _bme680_p = ('[data:makeList]')
  '[data:addLast]' ('_bme680 read word' 5) _bme680_p
  '[data:addLast]' ('_bme680 read int' 7) _bme680_p
  '[data:addLast]' ('_bm680 read int8' 9) _bme680_p
  '[data:addLast]' ('_bme680 read int' 11) _bme680_p
  '[data:addLast]' ('_bme680 read int' 13) _bme680_p
  '[data:addLast]' ('_bm680 read int8' 16) _bme680_p
  '[data:addLast]' ('_bm680 read int8' 15) _bme680_p
  '[data:addLast]' ('_bme680 read int' 19) _bme680_p
  '[data:addLast]' ('_bme680 read int' 21) _bme680_p
  '[data:addLast]' ('_bm680 read int8' 23) _bme680_p
}

to '_bme680 read raw' {
  '_bme680 setup'
  if (or (_bme680_raw == 0) ((millisOp) > (_bme680_last + 1000))) {
    comment 'forced  mode'
    '_bme680_set_bits' (hexToInt '74') 3 0 1
    repeat 3 {
      waitMillis 10
      if (((i2cGet _bme680 (hexToInt '1D')) & (hexToInt '80')) != 0) {
        _bme680_raw = (newList 15 0)
        '[sensors:i2cWrite]' _bme680 ('[data:makeList]' (hexToInt '1D'))
        '[sensors:i2cRead]' _bme680 _bme680_raw
        _bme680_last = (millisOp)
        return 0
      }
    }
  }
}

to '_bme680 read temperature coefficients' {
  _bme680_t = ('[data:makeList]')
  '[data:addLast]' ('_bme680 read int' 33) _bme680_t
  '[data:addLast]' ('_bme680 read word' 1) _bme680_t
  '[data:addLast]' ('_bm680 read int8' 3) _bme680_t
}

to '_bme680 read word' index {
  if (index > 25) {
    local 'reg' ((hexToInt 'E1') + (index - 25))
  } else {
    local 'reg' ((hexToInt '89') + index)
  }
  return (((i2cGet _bme680 (reg + 1)) << 8) | (i2cGet _bme680 reg))
}

to '_bme680 setup' {
  if (_bme680 == 0) {_bme680 = (hexToInt '77')}
  if (_bme680_last == 0) {
    comment 'soft reset'
    i2cSet _bme680 (hexToInt 'E0') (hexToInt 'B6')
    waitMillis 10
    comment 'sleep mode'
    i2cSet _bme680 (hexToInt '74') 0
    '_bme680 read temperature coefficients'
    '_bme680 read pressure coefficients'
    '_bm680 read humidity coefficients'
    '_read gas coefficients'
    comment 'humidity oversample x2'
    '_bme680_set_bits' (hexToInt '72') 7 0 2
    comment 'pressure oversample x4'
    '_bme680_set_bits' (hexToInt '74') (hexToInt '1C') 2 3
    comment 'temperature oversample x8'
    '_bme680_set_bits' (hexToInt '74') (hexToInt 'E0') 5 4
    comment 'sef filter'
    '_bme680_set_bits' (hexToInt '75') (hexToInt '1C') 2 2
    _bme680_last = (millisOp)
    waitMillis 1000
  }
}

to '_bme680 temperature' {
  local 'v1' ((((at 6 _bme680_raw) << 12) | ((at 7 _bme680_raw) << 4)) | ((at 8 _bme680_raw) >> 4))
  v1 = ((v1 >> 3) - ((at 1 _bme680_t) << 1))
  local 'v2' ((v1 * (at 2 _bme680_t)) >> 11)
  local 'v3' (((v1 >> 1) * (v1 >> 1)) >> 12)
  v3 = ((v3 * ((at 3 _bme680_t) << 4)) >> 14)
  return (v2 + v3)
}

to '_bme680_set_bits' reg mask pos val {
  local 'reg_value' (i2cGet _bme680 reg)
  if (reg_value >= 0) {
    i2cSet _bme680 reg ((reg_value & ('~' mask)) | (val << pos))
  }
}

to '_read gas coefficients' {
  _bme680_g = ('[data:makeList]')
  '[data:addLast]' ('_bm680 read int8' 37) _bme680_g
  '[data:addLast]' ('_bme680 read int' 35) _bme680_g
  '[data:addLast]' ('_bm680 read int8' 38) _bme680_g
  comment 'heat_range, heat & rng_sw_err'
  '[data:addLast]' (((i2cGet _bme680 2) & (hexToInt '30')) / 16) _bme680_g
  '[data:addLast]' (i2cGet _bme680 0) _bme680_g
  if ((at 'last' _bme680_g) > 128) {
    atPut _bme680_g _bme680_g 10
    return ((at 'last' _bme680_g) - 256)
  }
  '[data:addLast]' (((i2cGet _bme680 2) & (hexToInt 'F0')) / 16) _bme680_g
}

to 'bme680 connected' {
  if (_bme680 == 0) {
    local 'addr' (hexToInt '77')
  } else {
    addr = _bme680
  }
  return ((i2cGet addr (hexToInt 'D0')) == (hexToInt '61'))
}

to 'bme680 gas' {
  '_bme680 read raw'
  if ((i2cGet _bme680 (hexToInt '71')) == 0) {
    'bme680 set gas' 320 150
  }
  local 'adc' (((at 14 _bme680_raw) << 2) | ((at 15 _bme680_raw) >> 6))
  if (adc > 0) {
    local 'range' (((at 15 _bme680_raw) & (hexToInt '0F')) + 1)
    return (('[misc:bme680GasResistance]' adc range (at 6 _bme680_g)) / 10)
  } else {
    return 0
  }
}

to 'bme680 humidity' {
  '_bme680 read raw'
  local 't' (((('_bme680 temperature') * 5) + 128) >> 8)
  local 'v1' (((at 9 _bme680_raw) << 8) | (at 10 _bme680_raw))
  v1 = ((v1 - ((at 1 _bme680_h) << 4)) - (((t * (at 3 _bme680_h)) / 100) >> 1))
  local 'v2' (longMult (at 2 _bme680_h) ((((t * (at 4 _bme680_h)) / 100) + (((t * ((t * (at 5 _bme680_h)) / 100)) >> 6) / 100)) + 16384) 10)
  local 'v3' (v1 * v2)
  local 'v4' ((at 6 _bme680_h) << 7)
  v4 = ((v4 + ((t * (at 7 _bme680_h)) / 100)) >> 4)
  local 'v5' (longMult (v3 >> 14) (v3 >> 14) 10)
  local 'v6' (longMult v4 v5 1)
  return ((maximum 0 (minimum 100000 (longMult ((v3 + v6) >> 10) 1000 12))) / 100)
}

to 'bme680 pressure' {
  local 'v1' ((('_bme680 temperature') >> 1) - 64000)
  local 'v2' (((((v1 >> 2) * (v1 >> 2)) >> 11) * (at 6 _bme680_p)) >> 2)
  v2 = (v2 + ((v1 * (at 5 _bme680_p)) << 1))
  v2 = ((v2 >> 2) + ((at 4 _bme680_p) << 16))
  v1 = ((((((v1 >> 2) * (v1 >> 2)) >> 13) * ((at 3 _bme680_p) << 5)) >> 3) + (((at 2 _bme680_p) * v1) >> 1))
  v1 = (v1 >> 18)
  v1 = (longMult (32768 + v1) (at 1 _bme680_p) 15)
  local 'p' (1048576 - ((((at 3 _bme680_raw) << 12) | ((at 4 _bme680_raw) << 4)) | ((at 5 _bme680_raw) >> 4)))
  comment 'original *3125, <<1'
  p = ((p - (v2 >> 12)) * 1562)
  p = ((p / v1) << 2)
  v1 = (longMult (at 9 _bme680_p) (longMult (p >> 3) (p >> 3) 13) 12)
  v2 = (longMult (p >> 2) (at 8 _bme680_p) 13)
  local 'v3' (longMult ((p >> 8) * ((p >> 8) * (p >> 8))) (at 10 _bme680_p) 17)
  return ((p + ((((v1 + v2) + v3) + ((at 7 _bme680_p) << 7)) >> 4)) / 10)
}

to 'bme680 set address to' addr {
  _bme680 = addr
  _bme680_last = 0
  '_bme680 setup'
}

to 'bme680 set gas' degrees ms {
  local 'gas_reg' (i2cGet _bme680 (hexToInt '71'))
  if (or (degrees <= 0) (ms <= 0)) {
    comment 'Turn off gas measurements'
    i2cSet _bme680 (hexToInt '70') 8
    i2cSet _bme680 (hexToInt '71') (gas_reg & (hexToInt 'EF'))
  } else {
    i2cSet _bme680 (hexToInt '70') 0
    degrees = (maximum (minimum degrees 400) 200)
    local 'v1' ((((((('_bme680 temperature') * 5) + 128) >> 8) * (at 3 _bme680_g)) / 1000) << 8)
    local 'v2' (((at 1 _bme680_g) + 784) * (((((((at 2 _bme680_g) + 154009) * degrees) * 5) / 100) + 3276800) / 10))
    local 'v3' (v1 + (v2 / 2))
    local 'v3' (v1 + (v2 / 2))
    local 'v4' (v3 / ((at 4 _bme680_g) + 4))
    local 'v5' ((131 * (at 5 _bme680_g)) + 65536)
    local 'heatr_res' (((((v4 / v5) - 250) * 34) + 50) / 100)
    i2cSet _bme680 (hexToInt '5A') heatr_res
    local 'factor' 0
    local 'durval' 0
    if (ms > 4032) {
      durval = (hexToInt 'FF')
    } else {
      repeatUntil (ms <= (hexToInt '3F')) {
        ms = (ms >> 1)
        if (ms > (hexToInt '3F')) {
          factor += 1
        }
      }
      durval = (ms + (factor * 64))
    }
    i2cSet _bme680 (hexToInt '70') 0
    i2cSet _bme680 (hexToInt '64') durval
    i2cSet _bme680 (hexToInt '71') (gas_reg | (hexToInt '10'))
  }
}

to 'bme680 temperature' {
  '_bme680 read raw'
  return ((((('_bme680 temperature') * 5) + 128) >> 8) / 10)
}


module 'HTTP client' Comm
author MicroBlocks
version 1 4 
depends WiFi 
tags http network get post put delete 
description 'Send HTTP requests and get responses back. You can use this library to fetch or store data in online servers, or to control other Wifi-enabled boards.
'

  spec 'r' '_http_body_start' '_http_body_start _' 'auto' ''
  spec 'r' '_http_header_text' '_http_header_text _' 'auto' ''
  spec 'r' '_http_status_text' '_http_status_text _' 'auto' ''
  spec 'r' '_http_header' '_header _ of response _' 'auto auto' 'content-length' ''
  spec 'r' '_http_status' '_status of response _' 'auto' ''
  spec 'r' '_line_end' '_line_end'
  spec 'r' '_lowercase' '_lowercase _' 'auto' 'ABC Def gH'
  spec 'r' '_request_url' '_request_url _ method _ body _ : port _' 'str menu.requestTypes str num' '' 'GET' '' 80
  spec 'r' '_readHTTPResponse' '_readHTTPResponse'
  spec 'r' 'httpÜ//' 'httpÜ// _  : port _' 'auto num' 'microblocks.fun/example.txt' 80
  spec ' ' 'request' '_ data _ to httpÜ// _  : port _' 'menu.requestTypes str str num' 'POST' 'MicroBlocks is fun' 'microblocks.fun' 80

to '_http_body_start' response {
  return (('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) response) + 4)
}

to '_http_header' header response {
  local 'header text' ('_http_header_text' response)
  header = ('_lowercase' header)
  repeatUntil ((size (v 'header text')) < 3) {
    local 'key' ('[data:copyFromTo]' (v 'header text') 1 (('[data:find]' ':' (v 'header text')) - 1))
    if (('_lowercase' key) == header) {
      return ('[data:copyFromTo]' (v 'header text') (('[data:find]' ':' (v 'header text')) + 2) (('[data:find]' ('_line_end') (v 'header text')) - 1))
    }
    'header text' = ('[data:copyFromTo]' (v 'header text') (('[data:find]' ('_line_end') (v 'header text')) + 2))
  }
  return (booleanConstant false)
}

to '_http_header_text' response {
  local 'headersStart' (('[data:find]' ('_line_end') response) + 2)
  return ('[data:copyFromTo]' response headersStart (('_http_body_start' response) + 2))
}

to '_http_status' response {
  return (('[data:copyFromTo]' ('_http_status_text' response) 1 4) + 0)
}

to '_http_status_text' response {
  return ('[data:copyFromTo]' response ('[data:find]' ' ' response) ('[data:find]' ('_line_end') response))
}

to '_line_end' {
  return ('[data:unicodeString]' ('[data:makeList]' 13 10))
}

to '_lowercase' string {
  local 'lowercased' ''
  local 'char code' ''
  for c (size string) {
    'char code' = ('[data:unicodeAt]' c string)
    if (and ((v 'char code') >= 65) ((v 'char code') <= 90)) {
      'char code' = ((v 'char code') + 32)
    }
    lowercased = ('[data:join]' lowercased ('[data:unicodeString]' (v 'char code')))
  }
  return lowercased
}

to '_readHTTPResponse' {
  local 'response' ''
  local 'lastChunkTime' (millisOp)
  repeatUntil (not ('[net:httpIsConnected]')) {
    local 'chunk' ('[net:httpResponse]')
    if ((size chunk) > 0) {
      response = ('[data:join]' response chunk)
      lastChunkTime = (millisOp)
    } (((millisOp) - lastChunkTime) > 10000) {
      return response
    }
    waitMillis 20
  }
  response = ('[data:join]' response ('[net:httpResponse]'))
  return response
}

to '_request_url' url method body optionalPort {
  local 'port' 80
  if ((pushArgCount) > 3) {
    port = optionalPort
  }
  local 'host' ''
  local 'path' ''
  local 'slashPosition' ('[data:find]' '/' url)
  if (slashPosition > 0) {
    host = ('[data:copyFromTo]' url 1 (slashPosition - 1))
    path = ('[data:copyFromTo]' url (slashPosition + 1))
  } else {
    host = url
  }
  if (('[net:wifiStatus]') != 'Connected') {
    return ('[data:join]' '0 Not Connected' ('_line_end'))
  }
  '[net:httpConnect]' host port
  if (not ('[net:httpIsConnected]')) {
    return ('[data:join]' '0 Could not connect to server' ('_line_end'))
  }
  '[net:httpRequest]' method host path
  return ('_readHTTPResponse')
}

to 'httpÜ//' url optionalPort {
  local 'port' 80
  if ((pushArgCount) > 1) {
    port = optionalPort
  }
  local 'response' ('_request_url' url 'GET' '' port)
  if (response != '') {
    if (('_http_status' response) == 200) {
      return ('[data:copyFromTo]' response ('_http_body_start' response))
    } else {
      return ('_http_status_text' response)
    }
  } else {
    return 'Failed to get response'
  }
}

to request method data url optionalPort {
  local 'port' 80
  if ((pushArgCount) > 3) {
    port = optionalPort
  }
  local 'response' ('_request_url' url method data port)
  if (response != '') {
    local 'status' ('_http_status' response)
    local 'body start' ('_http_body_start' response)
    if (and (200 == status) ((v 'body start') > 0)) {
      sayIt ('[data:copyFromTo]' response (v 'body start'))
    } else {
      sayIt ('_http_status_text' response)
    }
  } else {
    sayIt 'Failed to get response'
  }
}


module 'HTTP server' Comm
author MicroBlocks
version 1 3 
depends WiFi 
tags http network 
description 'Create an HTTP server in MicroBlocks. You can use this library to allow remote control for your Wifi-enabled board.'

  spec 'r' '[net:httpServerGetRequest]' 'HTTP server request : binary data _' 'bool' false
  spec 'r' 'request method' 'method of request _' 'str' ''
  spec 'r' 'path of request' 'path of request _' 'str' ''
  spec 'r' 'headers of request' 'headers of request _' 'str' ''
  spec 'r' 'body of request' 'body of request _' 'str' ''
  spec 'r' 'content length of request' 'content length of request _' 'str' ''
  spec ' ' '[net:respondToHttpRequest]' 'respond _ to HTTP request : with body _ : and headers _ : keepAlive _' 'str str str bool' '200 OK' 'Welcome to the MicroBlocks HTTP server' 'Content-Type: text/plain' false
  spec 'r' '_endOfHeaders' '_end of headers _' 'str'
  spec 'r' '_toString' '_toString _' 'auto' 'abc'

to '_endOfHeaders' request {
  return ('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) request)
}

to '_toString' aStringOrByteArray {
  comment 'If argument is a byte array, convert it to a string. '
  if (not (isType aStringOrByteArray 'string')) {
    aStringOrByteArray = ('[data:join]' '' aStringOrByteArray)
  }
  return aStringOrByteArray
}

to 'body of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('[data:copyFromTo]' request (i + 4))
}

to 'content length of request' request {
  local 'i' ('_endOfHeaders' request)
  if (i < 0) {
    return 0
  }
  local 'j' ('[data:find]' 'Content-Length: ' request)
  if (j < 0) {
    comment 'Try alternate capitalization'
    j = ('[data:find]' 'Content-length: ' request)
  }
  if (or (j < 0) (j > i)) {
    return 0
  }
  j += 16
  local 'k' ('[data:find]' ('[data:unicodeString]' 13) request j)
  return (('[data:copyFromTo]' request j (k - 1)) + 0)
}

to 'headers of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('_toString' ('[data:copyFromTo]' request 1 (i - 1)))
}

to 'path of request' request {
  return ('_toString' ('[data:copyFromTo]' request (('[data:find]' ' ' request) + 1) (('[data:find]' ' HTTP' request) - 1)))
}

to 'request method' request {
  return ('_toString' ('[data:copyFromTo]' request 1 (('[data:find]' ' ' request) - 1)))
}


module WiFi Comm
author MicroBlocks
version 1 6 
tags communication network 
description 'Connect to a WiFi network. Used in conjunction with other network libraries, such as HTTP client, HTTP server or Web Thing.
'

  spec ' ' 'wifiConnect' 'wifi connect to _ password _ : IP _ gateway _ subnet _' 'str str auto auto auto' 'Network_Name' '' '192.168.1.42' '192.168.1.1' '255.255.255.0'
  spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
  spec 'r' 'getIPAddress' 'IP address'
  spec 'r' '[net:myMAC]' 'MAC address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to wifiConnect ssid password fixedIP gatewayIP subnetIP {
  if (not ('[net:hasWiFi]')) {return}
  '[net:stopWiFi]'
  if ((pushArgCount) < 5) {
    '[net:startWiFi]' ssid password
  } else {
    '[net:startWiFi]' ssid password false fixedIP gatewayIP subnetIP
  }
  local 'startMSecs' (millisOp)
  repeatUntil (('[net:myIPAddress]') != '0.0.0.0') {
    comment 'Timeout after N seconds'
    if (((millisOp) - startMSecs) > 30000) {
      sayIt 'Could not connect'
      return 0
    }
    comment 'Slow blink while trying to connect'
    setUserLED true
    waitMillis 300
    setUserLED false
    waitMillis 300
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  if ('Connected' != ('[net:wifiStatus]')) {
    sayIt 'Could not create hotspot'
    return 0
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

module main
author unknown
version 1 0 
description ''

  spec 'r' 'getFile' 'getFile _' 'auto' '10'
  spec ' ' 'favIconRequest' 'favIconRequest'
  spec ' ' 'fileRequest' 'fileRequest _' 'auto' '10'
  spec ' ' 'formRequest' 'formRequest _' 'auto' '10'
  spec ' ' 'homePageRequest' 'homePageRequest'
  spec ' ' 'rgbFormRequest' 'rgbFormRequest _' 'auto' '10'

to favIconRequest {
  local 'favIconHTML' '<html><head><link rel="icon" href="data:,"></head></html>'
  '[net:respondToHttpRequest]' '200 OK' favIconHTML
}

to fileRequest path {
  local 'fileData' (getFile path)
  if ((size fileData) > 0) {
    '[net:respondToHttpRequest]' '200 OK' fileData
  } else {
    '[net:respondToHttpRequest]' '404 Not found'
  }
}

to formRequest path {
  comment 'Show that a form was received.'
  setUserLED true
  '[io:playTone]' -1 440
  waitMillis 200
  setUserLED false
  '[io:playTone]' -1 0
  if (('[data:find]' '?R=' path) != -1) {
    rgbFormRequest path
  }
  comment 'Could add cases to handle additional
forms here...'
  '[net:respondToHttpRequest]' '200 OK' 'Form received.'
}

to getFile path {
  if (i == -1) {return 0}
  local 'fn' ('[data:copyFromTo]' path 1)
  local 'fileSize' ('[file:fileSize]' fn)
  if (fileSize == 0) {
    return ('[data:join]' 'Not found: ' fn)
  }
  local 'fileContents' ('[data:newByteArray]' fileSize)
  '[file:open]' fn
  fileSize = ('[file:readInto]' fileContents fn)
  '[file:close]' fn
  return fileContents
}

to homePageRequest {
  local 'homePageHTML' '<!DOCTYPE html>
<html>
<body><h1>RGB LED Color Settings</h1>
<form action="">
<label for="red">RED (0-255):</label>
<input  style="accent-color: red" type="range" id="color" name="R" min="50" max="255" accent-color: #FF0000></br>
<label for="green">GREEN (0-255):</label>
<input  style="accent-color: green" type="range" id="color" name="G" min="50" max="255"></br>
<label for="blue">BLUE (0-255):</label>
<input  style="accent-color: blue" type="range" id="color" name="B" min="50" max="255"></br></br>
<input style="background-color: #909090; font-size: x-large; padding: 10px 40px;" type="submit">
</form></body></html>'
  '[net:respondToHttpRequest]' '200 OK' homePageHTML
}

to rgbFormRequest path {
  comment 'Expected path format:
?R=255&G=255&B=255'
  local 'i' ('[data:find]' '?R=' path)
  path = ('[data:copyFromTo]' path (i + 1))
  local 'colors' ('[data:split]' path '&')
  if ((size colors) < 3) {
    return 0
  }
  local 'r' (0 + ('[data:copyFromTo]' (at 1 colors) 3))
  local 'g' (0 + ('[data:copyFromTo]' (at 2 colors) 3))
  local 'b' (0 + ('[data:copyFromTo]' (at 3 colors) 3))
  waitMillis 10
  neoPixelSetAllToColor (colorFromRGB r g b)
}

script 218 50 {
comment 'For external NeoPixels, add this block to the
"when started" script to set the number of
NeoPixels and the pin number.

For example, on the PicoBricks board you
would attach 1 NeoPixel to pin 6.'
neoPixelAttach 10 ''
}

script 50 165 {
whenStarted
comment 'Fill in your network name (SSID) and password here:'
wifiConnect 'Network_Name' ''
forever {
  local 'request' ('[net:httpServerGetRequest]')
  if (request != '') {
    local 'path' ('path of request' request)
    comment 'Handle the request based on the URL path'
    if ('/' == path) {
      homePageRequest
    } ('/favicon.ico' == path) {
      favIconRequest
    } (('[data:find]' '?' request) > 0) {
      formRequest path
    } else {
      fileRequest path
    }
  }
  waitMillis 10
}
}

script 444 185 {
comment 'This example shows how to create a browser remote control panel
on a WIFi-capable board that allows the board to be controlled from
a web browser on any phone, tablet, or laptop.

It works by creating a simple HTTP server that both serves the
control panel as an HTML form and also responds to requests
generated by that form.

In this example, the form contains sliders for red, green, and blue.
Submitting the form sends an HTTP request containing the slider
values encoded in a URL like this:

 /?R=100&G=0&B=25

The server responds to such requests by:

  1. blinking the user LED
  2. making a beep sound (if the board has a speaker)
  3. setting the Neopixels to the given color (if the board has Neopixels)

It also responds to browser requests for favicon.ico.

One final feature: if the request URL is not "/", "favicon.ico" or a URL
containing a question mark, it is taken to be a file name, and the server
will return the contens of a file of that name in the boad''s file system.

Of course, this is just a starting point. You can modify this example to
create all sorts of browser-controlled projects.
  
Enjoy!
'
}


module Files Data
author MicroBlocks
version 1 3 
description 'Flash file system operations. Currently supports the LittleFS file system on ESP8266 and ESP32 boards. The GnuBlocks virtual machine (Linux and Raspberry Pi) supports the native system.'

  spec ' ' '[file:open]' 'open file _' 'str'
  spec ' ' '[file:close]' 'close file _' 'str'
  spec ' ' '[file:delete]' 'delete file _' 'str'
  space
  spec ' ' '[file:appendLine]' 'append line _ to file _' 'str str'
  spec ' ' '[file:appendBytes]' 'append bytes _ to file _' 'str str'
  space
  spec 'r' '[file:endOfFile]' 'end of file _' 'str'
  spec 'r' '[file:readLine]' 'next line of file _' 'str'
  spec 'r' '[file:readBytes]' 'next _ bytes of file _ : starting at _' 'num str num' 100 '' 0
  spec 'r' '[file:readInto]' 'read into _ from file _' 'str str' 'a ByteArray' ''
  space
  spec 'r' '[file:readPosition]' 'read position of file _' 'str'
  spec ' ' '[file:setReadPosition]' 'set read position _ of file _' 'num str' 0 ''
  spec ' ' 'file_SkipBytes' 'skip _ bytes of file _' 'num str' 4 ''
  space
  spec 'r' 'file names' 'file names : in directory _' 'str'
  spec 'r' '[file:fileSize]' 'size of file _' 'str'
  spec 'r' '[file:systemInfo]' 'file system info'

to 'file names' dir {
  '[file:startList]' dir
  local 'result' ('[data:makeList]')
  local 'fileName' ('[file:nextInList]')
  repeatUntil (fileName == '') {
    '[data:addLast]' fileName result
    fileName = ('[file:nextInList]')
  }
  return result
}

to file_SkipBytes offset file {
  local 'newPosition' (('[file:readPosition]' file) + offset)
  '[file:setReadPosition]' newPosition file
}


module 'HTTP server' Comm
author MicroBlocks
version 1 3 
depends WiFi 
tags http network 
description 'Create an HTTP server in MicroBlocks. You can use this library to allow remote control for your Wifi-enabled board.'

  spec 'r' '[net:httpServerGetRequest]' 'HTTP server request : binary data _' 'bool' false
  spec 'r' 'request method' 'method of request _' 'str' ''
  spec 'r' 'path of request' 'path of request _' 'str' ''
  spec 'r' 'headers of request' 'headers of request _' 'str' ''
  spec 'r' 'body of request' 'body of request _' 'str' ''
  spec 'r' 'content length of request' 'content length of request _' 'str' ''
  spec ' ' '[net:respondToHttpRequest]' 'respond _ to HTTP request : with body _ : and headers _ : keepAlive _' 'str str str bool' '200 OK' 'Welcome to the MicroBlocks HTTP server' 'Content-Type: text/plain' false
  spec 'r' '_endOfHeaders' '_end of headers _' 'str'
  spec 'r' '_toString' '_toString _' 'auto' 'abc'

to '_endOfHeaders' request {
  return ('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) request)
}

to '_toString' aStringOrByteArray {
  comment 'If argument is a byte array, convert it to a string. '
  if (not (isType aStringOrByteArray 'string')) {
    aStringOrByteArray = ('[data:join]' '' aStringOrByteArray)
  }
  return aStringOrByteArray
}

to 'body of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('[data:copyFromTo]' request (i + 4))
}

to 'content length of request' request {
  local 'i' ('_endOfHeaders' request)
  if (i < 0) {
    return 0
  }
  local 'j' ('[data:find]' 'Content-Length: ' request)
  if (j < 0) {
    comment 'Try alternate capitalization'
    j = ('[data:find]' 'Content-length: ' request)
  }
  if (or (j < 0) (j > i)) {
    return 0
  }
  j += 16
  local 'k' ('[data:find]' ('[data:unicodeString]' 13) request j)
  return (('[data:copyFromTo]' request j (k - 1)) + 0)
}

to 'headers of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('_toString' ('[data:copyFromTo]' request 1 (i - 1)))
}

to 'path of request' request {
  return ('_toString' ('[data:copyFromTo]' request (('[data:find]' ' ' request) + 1) (('[data:find]' ' HTTP' request) - 1)))
}

to 'request method' request {
  return ('_toString' ('[data:copyFromTo]' request 1 (('[data:find]' ' ' request) - 1)))
}


module NeoPixel Output
author MicroBlocks
version 1 6 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if ((boardType) == 'M5Atom-Matrix') {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'Mbits') {
    neoPixelAttach 25 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'r' ((rgb >> 16) & 255)
    local 'g' ((rgb >> 8) & 255)
    local 'b' (rgb & 255)
    local 'brightness' (maximum r g b)
    if (delta > 0) {
      delta = (minimum delta (255 - brightness))
    } else {
      delta = (maximum delta (42 - brightness))
    }
    r = (maximum 0 (minimum (r + delta) 255))
    g = (maximum 0 (minimum (g + delta) 255))
    b = (maximum 0 (minimum (b + delta) 255))
    atPut i _np_pixels (colorFromRGB r g b)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_update' {
  '[display:neoPixelSend]' _np_pixels
  waitMicros 100
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  hasWhite = false
  if ((pushArgCount) > 2) {
    hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  fillList _np_pixels 0
  '[display:neoPixelSetPin]' pinNumber hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels color
  '_NeoPixel_update'
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' (n > 0)
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}


module WiFi Comm
author MicroBlocks
version 1 6 
tags communication network 
description 'Connect to a WiFi network. Used in conjunction with other network libraries, such as HTTP client, HTTP server or Web Thing.
'

  spec ' ' 'wifiConnect' 'wifi connect to _ password _ : IP _ gateway _ subnet _' 'str str auto auto auto' 'Network_Name' '' '192.168.1.42' '192.168.1.1' '255.255.255.0'
  spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
  spec 'r' 'getIPAddress' 'IP address'
  spec 'r' '[net:myMAC]' 'MAC address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to wifiConnect ssid password fixedIP gatewayIP subnetIP {
  if (not ('[net:hasWiFi]')) {return}
  '[net:stopWiFi]'
  if ((pushArgCount) < 5) {
    '[net:startWiFi]' ssid password
  } else {
    '[net:startWiFi]' ssid password false fixedIP gatewayIP subnetIP
  }
  local 'startMSecs' (millisOp)
  repeatUntil (('[net:myIPAddress]') != '0.0.0.0') {
    comment 'Timeout after N seconds'
    if (((millisOp) - startMSecs) > 30000) {
      sayIt 'Could not connect'
      return 0
    }
    comment 'Slow blink while trying to connect'
    setUserLED true
    waitMillis 300
    setUserLED false
    waitMillis 300
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  if ('Connected' != ('[net:wifiStatus]')) {
    sayIt 'Could not create hotspot'
    return 0
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

module main
author MicroBlocks
version 1 0 
description ''
variables responses 

script 50 50 {
whenStarted
comment 'This server requires  an ESP32 camera board such as the
Freenove ESP32-WROVER. To any request,  it returns the
a snapshot from the camera as jpeg image.'
comment 'Remember to use your network name (SSID) and password below'
wifiConnect '***' '***'
'[camera:setSize]' '640x480'
'[camera:setEncoding]' 'jpeg' 100
forever {
  repeatUntil (('[net:httpServerGetRequest]') != '') {
    waitMillis 10
  }
  '[net:respondToHttpRequest]' '200 OK' ('[camera:takePhoto]') 'Content-Type: image/jpeg'
}
}


module 'Basic Sensors' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor 
choices accelerometerRange '1' '2' '4' '8' 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[sensors:acceleration]' 'acceleration'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (Â°C)'
  spec ' ' '_setAccelRange' 'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to '_setAccelRange' n {
  '[sensors:setAccelerometerRange]' (0 + n)
}


module Camera Input
author MicroBlocks
version 1 0 
choices camera_frameSize '320x240' '352x288' '640x480' '800x600' '1024x768' '1280x1024' '1600x1200' 
choices camera_format jpeg rgb565 grayscale 
description 'Primitives for ESP32 Camera boards (e.g. Freenove ESP32-WROVER).'

  spec 'r' '[camera:hasCamera]' 'has camera'
  spec 'r' '[camera:takePhoto]' 'get camera image'
  spec ' ' '[camera:setSize]' 'set camera image size _' 'menu.camera_frameSize' '640x480'
  spec ' ' '[camera:setEncoding]' 'set camera format _ jpeg quality _ (0-100)' 'menu.camera_format num' 'jpeg' 100

module 'HTTP server' Comm
author MicroBlocks
version 1 3 
depends WiFi 
tags http network 
description 'Create an HTTP server in MicroBlocks. You can use this library to allow remote control for your Wifi-enabled board.'

  spec 'r' '[net:httpServerGetRequest]' 'HTTP server request : binary data _' 'bool' false
  spec 'r' 'request method' 'method of request _' 'str' ''
  spec 'r' 'path of request' 'path of request _' 'str' ''
  spec 'r' 'headers of request' 'headers of request _' 'str' ''
  spec 'r' 'body of request' 'body of request _' 'str' ''
  spec 'r' 'content length of request' 'content length of request _' 'str' ''
  spec ' ' '[net:respondToHttpRequest]' 'respond _ to HTTP request : with body _ : and headers _ : keepAlive _' 'str str str bool' '200 OK' 'Welcome to the MicroBlocks HTTP server' 'Content-Type: text/plain' false
  spec 'r' '_endOfHeaders' '_end of headers _' 'str'
  spec 'r' '_toString' '_toString _' 'auto' 'abc'

to '_endOfHeaders' request {
  return ('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) request)
}

to '_toString' aStringOrByteArray {
  comment 'If argument is a byte array, convert it to a string. '
  if (not (isType aStringOrByteArray 'string')) {
    aStringOrByteArray = ('[data:join]' '' aStringOrByteArray)
  }
  return aStringOrByteArray
}

to 'body of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('[data:copyFromTo]' request (i + 4))
}

to 'content length of request' request {
  local 'i' ('_endOfHeaders' request)
  if (i < 0) {
    return 0
  }
  local 'j' ('[data:find]' 'Content-Length: ' request)
  if (j < 0) {
    comment 'Try alternate capitalization'
    j = ('[data:find]' 'Content-length: ' request)
  }
  if (or (j < 0) (j > i)) {
    return 0
  }
  j += 16
  local 'k' ('[data:find]' ('[data:unicodeString]' 13) request j)
  return (('[data:copyFromTo]' request j (k - 1)) + 0)
}

to 'headers of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('_toString' ('[data:copyFromTo]' request 1 (i - 1)))
}

to 'path of request' request {
  return ('_toString' ('[data:copyFromTo]' request (('[data:find]' ' ' request) + 1) (('[data:find]' ' HTTP' request) - 1)))
}

to 'request method' request {
  return ('_toString' ('[data:copyFromTo]' request 1 (('[data:find]' ' ' request) - 1)))
}


module WiFi Comm
author MicroBlocks
version 1 6 
tags communication network 
description 'Connect to a WiFi network. Used in conjunction with other network libraries, such as HTTP client, HTTP server or Web Thing.
'

  spec ' ' 'wifiConnect' 'wifi connect to _ password _ : IP _ gateway _ subnet _' 'str str auto auto auto' 'Network_Name' '' '192.168.1.42' '192.168.1.1' '255.255.255.0'
  spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
  spec 'r' 'getIPAddress' 'IP address'
  spec 'r' '[net:myMAC]' 'MAC address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to wifiConnect ssid password fixedIP gatewayIP subnetIP {
  if (not ('[net:hasWiFi]')) {return}
  '[net:stopWiFi]'
  if ((pushArgCount) < 5) {
    '[net:startWiFi]' ssid password
  } else {
    '[net:startWiFi]' ssid password false fixedIP gatewayIP subnetIP
  }
  local 'startMSecs' (millisOp)
  repeatUntil (('[net:myIPAddress]') != '0.0.0.0') {
    comment 'Timeout after N seconds'
    if (((millisOp) - startMSecs) > 30000) {
      sayIt 'Could not connect'
      return 0
    }
    comment 'Slow blink while trying to connect'
    setUserLED true
    waitMillis 300
    setUserLED false
    waitMillis 300
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  if ('Connected' != ('[net:wifiStatus]')) {
    sayIt 'Could not create hotspot'
    return 0
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

module main
author MicroBLocks
version 1 0 
description 'Based on "BME680 Demo" by JosÃ© Garcia.'
variables server _day _hours _minutes _month _seconds _year 

  spec 'r' 'online date from server' 'date and time from server _' 'auto' 'microblocks.fun'
  spec 'r' 'files list' 'files list'
  spec 'r' 'main menu' 'main page'
  spec ' ' 'write' 'write _ to file _' 'auto auto' '' ''
  spec 'r' 'file deleted' 'delete file _' 'auto' ''
  spec 'r' 'graph with data' 'graph data from file _' 'auto' '(list)'
  spec 'r' 'read file' 'read file _' 'auto' ''
  spec 'r' 'delete all files' 'delete all files'
  spec 'r' 'decimal' 'decimal _' 'auto' 123
  spec 'r' 'chart script' 'html chart script'
  spec 'r' 'download as csv file' 'html download as csv file _' 'auto' ''
  spec 'r' 'html chart from colum' 'html chart from file _ column _' 'auto auto' '' 1
  spec 'r' 'column names' 'column names _' 'auto' 1
  spec 'r' 'current time short' 'current time short'
  spec 'r' 'adjusted temperature' 'adjusted temperature'

to 'adjusted temperature' {
  return ((shtc3_temperature) - 7)
}

to 'chart script' {
  return '<head>
<script src="https://unpkg.com/tlx/browser/tlx.js"></script>
<script src="https://unpkg.com/tlx-chart/browser/tlx-chart.js"></script>
</head>'
}

to 'column names' index {
  return (at index ('[data:makeList]' 'Temperature (&deg;C)' 'Humidity %' 'Air Pressure (mBar)' 'CO2 (ppm)' 'VOC (ppm)'))
}

to 'current time short' {
  comment '+Timezone +Daylightsaving '
  local 'hours' (_hours + (1 + -8))
  local 'minutes' _minutes
  if (hours < 10) {
    hours = ('[data:join]' '0' hours)
  }
  if (minutes < 10) {
    minutes = ('[data:join]' '0' minutes)
  }
  return ('[data:join]' hours ':' minutes)
}

to decimal int {
  comment 'one decimal'
  return ('[data:join]' (int / 10) '.' (int % 10))
}

to 'delete all files' {
  for name ('file names') {
    '[file:delete]' name
  }
  return '<p>All files  removed successfully</p>
<button onclick="location.href=''/''" type="button">Back</button>'
}

to 'download as csv file' filename {
  return ('[data:join]' '<button onclick="location.href=''/' filename '.csv''" type="button">Download as CSV</button>
<br><br>
<button onclick="location.href=''/''" type="button">Back</button>')
}

to 'file deleted' name {
  '[file:delete]' name
  if (('[data:find]' ('current date') ('file names')) == -1) {
    return ('[data:join]' '<p>File ' name ' removed successfully</p>
<button onclick="location.href=''/''" type="button">Back</button>')
  } else {
    return ('[data:join]' '<p>Error removing file ' name '</p>
<button onclick="location.href=''/''" type="button">Back</button>')
  }
}

to 'files list' {
  local 'string' ''
  for 'file name' ('file names') {
    string = ('[data:join]' string '<li><a href="/' (v 'file name') '">' (v 'file name') '</a>&nbsp<button onclick="location.href=''/' (v 'file name') '/delete''" type="button">Delete</button></li>')
  }
  return string
}

to 'graph with data' filename {
  local 'html' ('[data:join]' ('chart script') '<body><h1>Recorded Data</h1>')
  for i 5 {
    html = ('[data:join]' html ('html chart from colum' filename i))
  }
  return ('[data:join]' html ('download as csv file' filename) '</body>')
}

to 'html chart from colum' filename col {
  local 'html' ('[data:join]' '<b>' ('column names' col) '</b>
<tlx-chart chart-type="LineChart"
	chart-columns="${[''Timestamp'',''' ('column names' col) ''']}"
	chart-data="${[')
  '[file:open]' filename
  comment 'Only the last 60 reads (aprox. 30 chars per line) Max 110 for ESP32 16000 bytes memory'
  local 'read_size' (30 * 60)
  if (('[file:fileSize]' filename) > read_size) {
    '[file:setReadPosition]' (('[file:fileSize]' filename) - read_size) filename
    local 'var' ('[file:readLine]' filename)
  }
  repeatUntil ('[file:endOfFile]' filename) {
    local 'colums' ('[data:split]' ('[file:readLine]' filename) ',')
    html = ('[data:join]' html '[' ('[data:join]' (at 1 colums) ',' (at (col + 1) colums)) '],')
  }
  '[file:close]' filename
  html = ('[data:join]' html ']}">
</tlx-chart>')
  return html
}

to 'main menu' {
  return ('[data:join]' '<h1>Databot Data Logger</h1>
<h3>Current values (Temperature &deg;C / Humidity % / Pressure mBar / CO2 ppm / Volatile Organic Compounds (VOC) ppm;): ' ('[data:joinStrings]' ('[data:makeList]' ('adjusted temperature') (shtc3_humidity) (lps22hb_airPressureMbar) (at 1 ('SGP30 read')) (at 2 ('SGP30 read'))) '/') '</h3>
<p>Daily records with data registered every minute. Click on each link to visualize them in a linear graph:</p>
<ul>' ('files list') '</ul>
<button onclick="location.href=''/deleteAll''" type="button">Delete all files</button>
<br><br>
<i>File system info:  ' ('[file:systemInfo]'))
}

to 'read file' name {
  '[file:open]' name
  local 'string' ''
  repeatUntil ('[file:endOfFile]' name) {
    string = ('[data:join]' string ('[file:readLine]' name) ('[data:unicodeString]' 13))
  }
  '[file:close]' name
  return string
}

to write data name {
  '[file:open]' name
  '[file:appendLine]' data name
  '[file:close]' name
}

script 572 50 {
whenBroadcastReceived 'connected'
forever {
  if (('current date') == '0-00-0') {
    'fetch current time from server' 'microblocks.fun'
  } else {
    if ((timer) >= 60000) {
      write ('[data:joinStrings]' ('[data:makeList]' ('[data:join]' '''' ('current time short') '''') ('adjusted temperature') (shtc3_humidity) (lps22hb_airPressureMbar) (at 1 ('SGP30 read')) (at 2 ('SGP30 read'))) ',') ('current date')
      resetTimer
    }
  }
  tick
}
}

script 53 67 {
whenStarted
comment 'Enter your WiFi network name and password:'
wifiConnect '' ''
sendBroadcast 'connected'
forever {
  local 'request' ('[net:httpServerGetRequest]')
  if (request != '') {
    local 'path' ('path of request' request)
    if (path == '/') {
      '[net:respondToHttpRequest]' '200 OK' ('main menu')
    }
    if (path == '/deleteAll') {
      '[net:respondToHttpRequest]' '200 OK' ('delete all files')
    }
    for name ('file names') {
      if (path == ('[data:join]' '/' name)) {'[net:respondToHttpRequest]' '200 OK' ('graph with data' name)}
      if (path == ('[data:join]' '/' name '/delete')) {'[net:respondToHttpRequest]' '200 OK' ('file deleted' name)}
      if (path == ('[data:join]' '/' name '.csv')) {'[net:respondToHttpRequest]' '200 OK' ('read file' name) 'Content-Type: text/csv'}
    }
    '[net:respondToHttpRequest]' '404 Not Found' '<h1>404 Not Found</h1><p>I''m sorry, this page does not exist :(</p>'
  }
  waitMillis 10
}
}

script 50 893 {
to 'main menu' {}
}


module 'Air Pressure (LPS22HB)' Input
author MicroBlocks
version 1 4 
description 'Sense air pressure and altitude with the LPS22HB air pressure sensor.
The altimeter can either report changes relative to the starting altitude. If calibrated to a known starting altitude, it can report absolute altitude.'
variables _lps22hb_basePressure _lps22hb_baseAltitude 

  spec 'r' 'lps22hb_airPressureMbar' 'air pressure (mBar)'
  spec 'r' 'lps22hb_airPressurePSI' 'air pressure (PSI x10)'
  space
  spec ' ' 'lps22hb_setBaseAltitude' 'set current altitude _ meters' 'num' 0
  spec ' ' 'lps22hb_setBasePressure' 'set base pressure (mBar x10) _ at _ meters' 'num num' 1013 0
  spec 'r' 'lps22hb_altitudeCentimeters' 'altitude (cm)'
  spec 'r' 'lps22hb_altitudeFeet' 'altitude (feet)'
  space
  spec 'r' 'lps22hb_temperature' 'lps22hb temperature (Â°C)'
  space
  spec 'r' '_lps22hb_altitudeMillimeters' '_lps22hb_altitudeMillimeters'
  spec 'r' '_lps22hb_rawPressure' '_lps22hb_rawPressure'
  spec 'r' '_lps22hb_readPressure' '_lps22hb_readPressure'

to '_lps22hb_altitudeMillimeters' {
  if (_lps22hb_basePressure == 0) {
    comment 'if base altitude not set, use zero (useful for relative measurments)'
    lps22hb_setBaseAltitude 0
  }
  mmChange = ('[misc:pressureToAltitude]' _lps22hb_basePressure ('_lps22hb_rawPressure'))
  return ((1000 * _lps22hb_baseAltitude) + mmChange)
}

to '_lps22hb_rawPressure' {
  local 'LPS22HB' (hexToInt '5C')
  local 'raw' ('_lps22hb_readPressure')
  if (raw == 0) {
    comment 'LPS22HB sometimes gets stuck returning zero pressure
This sequence may unstick it.'
    i2cSet LPS22HB (hexToInt '11') 128
    i2cSet LPS22HB (hexToInt '10') 0
    raw = ('_lps22hb_readPressure')
  }
  return raw
}

to '_lps22hb_readPressure' {
  local 'LPS22HB' (hexToInt '5C')
  i2cSet LPS22HB (hexToInt '11') 1
  waitMillis 2
  local 'result' (i2cGet LPS22HB (hexToInt '28'))
  result = (((i2cGet LPS22HB (hexToInt '29')) << 8) | result)
  result = (((i2cGet LPS22HB (hexToInt '2A')) << 16) | result)
  return result
}

to lps22hb_airPressureMbar {
  return (('_lps22hb_rawPressure') / 4096)
}

to lps22hb_airPressurePSI {
  return (('_lps22hb_rawPressure') / 28241)
}

to lps22hb_altitudeCentimeters {
  return (('_lps22hb_altitudeMillimeters') / 10)
}

to lps22hb_altitudeFeet {
  return (('_lps22hb_altitudeMillimeters') / 305)
}

to lps22hb_setBaseAltitude baseMeters {
  local 'total' 0
  comment 'Start regular sampling with filtering. Sampling rate is 75/9.'
  local 'LPS22HB' (hexToInt '5C')
  i2cSet LPS22HB (hexToInt '10') (hexToInt '58')
  waitMillis 300
  repeat 20 {
    total += ('_lps22hb_rawPressure')
    waitMillis 1
  }
  _lps22hb_basePressure = (total / 20)
  _lps22hb_baseAltitude = baseMeters
}

to lps22hb_setBasePressure basePressureMBar baseMeters {
  _lps22hb_basePressure = ((basePressureMBar * 4096) / 10)
  _lps22hb_baseAltitude = baseMeters
}

to lps22hb_temperature {
  local 'LPS22HB' (hexToInt '5C')
  i2cSet LPS22HB (hexToInt '11') 1
  waitMillis 1
  local 'result' (i2cGet LPS22HB (hexToInt '2B'))
  result = (((i2cGet LPS22HB (hexToInt '2C')) << 8) | result)
  if (result >= 32768) {
    result = (result - 65536)
  }
  if ('Databot' == (boardType)) {
    comment 'Adjust for extra heat from PC board'
    result += -1230
  }
  return (result / 100)
}


module DateTime
author unknown
version 1 0 
description ''
variables _day _hours _minutes _month _seconds _year 

  spec ' ' 'fetch current time from server' 'fetch date and time from server _' 'auto' 'microblocks.fun'
  spec ' ' 'tick' 'tick'
  spec 'r' 'current date' 'current date'
  spec 'r' 'current time' 'current time'
  spec 'r' 'online date from server' 'date and time from server _' 'auto' 'microblocks.fun'
  spec 'r' 'seconds' 'seconds'

to 'current date' {
  local 'month' _month
  if (month < 10) {
    month = ('[data:join]' '0' month)
  }
  return ('[data:join]' _year '-' month '-' _day)
}

to 'current time' {
  local 'hours' _hours
  local 'minutes' _minutes
  local 'seconds' _seconds
  if (hours < 10) {
    hours = ('[data:join]' '0' hours)
  }
  if (minutes < 10) {
    minutes = ('[data:join]' '0' minutes)
  }
  if (seconds < 10) {
    seconds = ('[data:join]' '0' seconds)
  }
  return ('[data:join]' hours ':' minutes ':' seconds)
}

to 'fetch current time from server' url {
  local 'current datetime' ('online date from server' url)
  _year = ('[data:copyFromTo]' (v 'current datetime') 8 11)
  _day = ('[data:copyFromTo]' (v 'current datetime') 1 2)
  local 'month names' ('[data:makeList]' 'Jan' 'Feb' 'Mar' 'Apr' 'May' 'Jun' 'Jul' 'Aug' 'Sep' 'Oct' 'Nov' 'Dec')
  local 'month name' ('[data:copyFromTo]' (v 'current datetime') 4 6)
  _month = 1
  repeatUntil ((at _month (v 'month names')) == (v 'month name')) {
    _month += 1
  }
  local 'start ms' (millisOp)
  _hours = (('[data:copyFromTo]' (v 'current datetime') 13 14) + 1)
  _minutes = (('[data:copyFromTo]' (v 'current datetime') 16 17) + 0)
  _seconds = (('[data:copyFromTo]' (v 'current datetime') 19 20) - (((millisOp) - (v 'start ms')) / 1000))
}

to 'online date from server' server {
  local 'url' ('[data:join]' server '/nonExistentPage')
  local 'response' ('_request_url' url 'GET' '')
  local 'header' ('_http_header_text' response)
  return ('[data:copyFromTo]' header (('[data:find]' 'Date:' header) + 11) (('[data:find]' 'GMT' header) - 2))
}

to seconds {
  return _seconds
}

to tick {
  _seconds += 1
  if (_seconds == 60) {
    _seconds = 0
    _minutes += 1
    if (_minutes == 60) {
      _minutes = 0
      _hours += 1
      if (_hours == 24) {
        _hours = 0
      }
    }
  }
  waitMillis 1000
}


module Files Data
author MicroBlocks
version 1 3 
description 'Flash file system operations. Currently supports the LittleFS file system on ESP8266 and ESP32 boards. The GnuBlocks virtual machine (Linux and Raspberry Pi) supports the native system.'

  spec ' ' '[file:open]' 'open file _' 'str'
  spec ' ' '[file:close]' 'close file _' 'str'
  spec ' ' '[file:delete]' 'delete file _' 'str'
  space
  spec ' ' '[file:appendLine]' 'append line _ to file _' 'str str'
  spec ' ' '[file:appendBytes]' 'append bytes _ to file _' 'str str'
  space
  spec 'r' '[file:endOfFile]' 'end of file _' 'str'
  spec 'r' '[file:readLine]' 'next line of file _' 'str'
  spec 'r' '[file:readBytes]' 'next _ bytes of file _ : starting at _' 'num str num' 100 '' 0
  spec 'r' '[file:readInto]' 'read into _ from file _' 'str str' 'a ByteArray' ''
  space
  spec 'r' '[file:readPosition]' 'read position of file _' 'str'
  spec ' ' '[file:setReadPosition]' 'set read position _ of file _' 'num str' 0 ''
  spec ' ' 'file_SkipBytes' 'skip _ bytes of file _' 'num str' 4 ''
  space
  spec 'r' 'file names' 'file names : in directory _' 'str'
  spec 'r' '[file:fileSize]' 'size of file _' 'str'
  spec 'r' '[file:systemInfo]' 'file system info'

to 'file names' dir {
  '[file:startList]' dir
  local 'result' ('[data:makeList]')
  local 'fileName' ('[file:nextInList]')
  repeatUntil (fileName == '') {
    '[data:addLast]' fileName result
    fileName = ('[file:nextInList]')
  }
  return result
}

to file_SkipBytes offset file {
  local 'newPosition' (('[file:readPosition]' file) + offset)
  '[file:setReadPosition]' newPosition file
}


module 'Gas (SGP30)' Input
author 'JosÃ© GarcÃ­a Yeste'
version 1 1 
tags sensor co2 
description 'Support for Sensirion SGP30 Air Quality Sensor.
Returns the CO2 in ppm and TVOC in ppb.

Based on: https://github.com/adafruit/Adafruit_SGP30/blob/master/Adafruit_SGP30.cpp'
variables '_SGP30 inizialized' 

  spec 'r' 'SGP30 connected' 'SGP30 connected'
  spec 'r' 'SGP30 read' 'SGP30 read air quality'
  spec 'r' 'SGP30 read raw' 'SGP30 read raw'
  spec ' ' 'SGP30 setup' 'SGP30 setup'
  spec 'r' 'SGP30 get baseline' 'SGP30 get baseline'
  spec ' ' 'SGP30 set baseline' 'SGP30 set baseline co2 _ tvoc _' 'auto auto' 36885 36209
  spec 'r' '_SGP30 generate CRC' '_SGP30 generate CRC _' 'auto' 400

to 'SGP30 connected' {
  local 'cmd' ('[data:makeList]' (hexToInt '20') (hexToInt '2F'))
  local 'response' (newList 3)
  '[sensors:i2cWrite]' (hexToInt '58') cmd
  waitMillis 10
  '[sensors:i2cRead]' (hexToInt '58') response
  local 'featureset' (((at 1 response) << 8) | (at 2 response))
  return ((featureset & (hexToInt 'F0')) == (hexToInt '20'))
}

to 'SGP30 get baseline' {
  'SGP30 setup'
  local 'cmd' ('[data:makeList]' (hexToInt '20') (hexToInt '15'))
  local 'response' (newList 6)
  '[sensors:i2cWrite]' (hexToInt '58') cmd
  waitMillis 10
  local 'baseline' (newList 2)
  '[sensors:i2cRead]' (hexToInt '58') response
  atPut 1 baseline (((at 1 response) << 8) | (at 2 response))
  atPut 2 baseline (((at 4 response) << 8) | (at 5 response))
  return baseline
}

to 'SGP30 read' {
  'SGP30 setup'
  local 'cmd' ('[data:makeList]' (hexToInt '20') (hexToInt '08'))
  local 'response' (newList 6)
  '[sensors:i2cWrite]' (hexToInt '58') cmd
  waitMillis 12
  local 'aq' (newList 2)
  '[sensors:i2cRead]' (hexToInt '58') response
  atPut 1 aq (((at 1 response) << 8) | (at 2 response))
  atPut 2 aq (((at 4 response) << 8) | (at 5 response))
  return aq
}

to 'SGP30 read raw' {
  'SGP30 setup'
  local 'cmd' ('[data:makeList]' (hexToInt '20') (hexToInt '50'))
  local 'response' (newList 6)
  '[sensors:i2cWrite]' (hexToInt '58') cmd
  waitMillis 25
  local 'raw' (newList 2)
  '[sensors:i2cRead]' (hexToInt '58') response
  atPut 1 raw (((at 1 response) << 8) | (at 2 response))
  atPut 2 raw (((at 4 response) << 8) | (at 5 response))
  return raw
}

to 'SGP30 set baseline' co2 tvoc {
  'SGP30 setup'
  local 'cmd' ('[data:makeList]' (hexToInt '20') (hexToInt '1E') (tvoc >> 8) (tvoc & 255) ('_SGP30 generate CRC' tvoc) (co2 >> 8) (co2 & 255) ('_SGP30 generate CRC' co2))
  '[sensors:i2cWrite]' (hexToInt '58') cmd
  waitMillis 10
}

to 'SGP30 setup' {
  if ((v '_SGP30 inizialized') == 0) {
    '_SGP30 inizialized' = 1
    local 'cmd' ('[data:makeList]' (hexToInt '20') (hexToInt '03'))
    '[sensors:i2cWrite]' (hexToInt '58') cmd
    waitMillis 10
  }
}

to '_SGP30 generate CRC' value {
  local 'buf' ('[data:makeList]' (value >> 8) (value & 255))
  local 'crc' (hexToInt 'FF')
  for i (size buf) {
    crc = (crc ^ (at i buf))
    for i 8 {
      if ((crc & (hexToInt '80')) != 0) {
        crc = ((crc << 1) ^ (hexToInt '31'))
      } else {
        crc = (crc << 1)
      }
    }
  }
  return (crc & 255)
}

script 642 50 {
to 'SGP30 set baseline' {}
}


module 'HTTP client' Comm
author MicroBlocks
version 1 4 
depends WiFi 
tags http network get post put delete 
description 'Send HTTP requests and get responses back. You can use this library to fetch or store data in online servers, or to control other Wifi-enabled boards.
'

  spec 'r' '_http_body_start' '_http_body_start _' 'auto' ''
  spec 'r' '_http_header_text' '_http_header_text _' 'auto' ''
  spec 'r' '_http_status_text' '_http_status_text _' 'auto' ''
  spec 'r' '_http_header' '_header _ of response _' 'auto auto' 'content-length' ''
  spec 'r' '_http_status' '_status of response _' 'auto' ''
  spec 'r' '_line_end' '_line_end'
  spec 'r' '_lowercase' '_lowercase _' 'auto' 'ABC Def gH'
  spec 'r' '_request_url' '_request_url _ method _ body _ : port _' 'str menu.requestTypes str num' '' 'GET' '' 80
  spec 'r' '_readHTTPResponse' '_readHTTPResponse'
  spec 'r' 'httpÜ//' 'httpÜ// _  : port _' 'auto num' 'microblocks.fun/example.txt' 80
  spec ' ' 'request' '_ data _ to httpÜ// _  : port _' 'menu.requestTypes str str num' 'POST' 'MicroBlocks is fun' 'microblocks.fun' 80

to '_http_body_start' response {
  return (('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) response) + 4)
}

to '_http_header' header response {
  local 'header text' ('_http_header_text' response)
  header = ('_lowercase' header)
  repeatUntil ((size (v 'header text')) < 3) {
    local 'key' ('[data:copyFromTo]' (v 'header text') 1 (('[data:find]' ':' (v 'header text')) - 1))
    if (('_lowercase' key) == header) {
      return ('[data:copyFromTo]' (v 'header text') (('[data:find]' ':' (v 'header text')) + 2) (('[data:find]' ('_line_end') (v 'header text')) - 1))
    }
    'header text' = ('[data:copyFromTo]' (v 'header text') (('[data:find]' ('_line_end') (v 'header text')) + 2))
  }
  return (booleanConstant false)
}

to '_http_header_text' response {
  local 'headersStart' (('[data:find]' ('_line_end') response) + 2)
  return ('[data:copyFromTo]' response headersStart (('_http_body_start' response) + 2))
}

to '_http_status' response {
  return (('[data:copyFromTo]' ('_http_status_text' response) 1 4) + 0)
}

to '_http_status_text' response {
  return ('[data:copyFromTo]' response ('[data:find]' ' ' response) ('[data:find]' ('_line_end') response))
}

to '_line_end' {
  return ('[data:unicodeString]' ('[data:makeList]' 13 10))
}

to '_lowercase' string {
  local 'lowercased' ''
  local 'char code' ''
  for c (size string) {
    'char code' = ('[data:unicodeAt]' c string)
    if (and ((v 'char code') >= 65) ((v 'char code') <= 90)) {
      'char code' = ((v 'char code') + 32)
    }
    lowercased = ('[data:join]' lowercased ('[data:unicodeString]' (v 'char code')))
  }
  return lowercased
}

to '_readHTTPResponse' {
  local 'response' ''
  local 'lastChunkTime' (millisOp)
  repeatUntil (not ('[net:httpIsConnected]')) {
    local 'chunk' ('[net:httpResponse]')
    if ((size chunk) > 0) {
      response = ('[data:join]' response chunk)
      lastChunkTime = (millisOp)
    } (((millisOp) - lastChunkTime) > 10000) {
      return response
    }
    waitMillis 20
  }
  response = ('[data:join]' response ('[net:httpResponse]'))
  return response
}

to '_request_url' url method body optionalPort {
  local 'port' 80
  if ((pushArgCount) > 3) {
    port = optionalPort
  }
  local 'host' ''
  local 'path' ''
  local 'slashPosition' ('[data:find]' '/' url)
  if (slashPosition > 0) {
    host = ('[data:copyFromTo]' url 1 (slashPosition - 1))
    path = ('[data:copyFromTo]' url (slashPosition + 1))
  } else {
    host = url
  }
  if (('[net:wifiStatus]') != 'Connected') {
    return ('[data:join]' '0 Not Connected' ('_line_end'))
  }
  '[net:httpConnect]' host port
  if (not ('[net:httpIsConnected]')) {
    return ('[data:join]' '0 Could not connect to server' ('_line_end'))
  }
  '[net:httpRequest]' method host path
  return ('_readHTTPResponse')
}

to 'httpÜ//' url optionalPort {
  local 'port' 80
  if ((pushArgCount) > 1) {
    port = optionalPort
  }
  local 'response' ('_request_url' url 'GET' '' port)
  if (response != '') {
    if (('_http_status' response) == 200) {
      return ('[data:copyFromTo]' response ('_http_body_start' response))
    } else {
      return ('_http_status_text' response)
    }
  } else {
    return 'Failed to get response'
  }
}

to request method data url optionalPort {
  local 'port' 80
  if ((pushArgCount) > 3) {
    port = optionalPort
  }
  local 'response' ('_request_url' url method data port)
  if (response != '') {
    local 'status' ('_http_status' response)
    local 'body start' ('_http_body_start' response)
    if (and (200 == status) ((v 'body start') > 0)) {
      sayIt ('[data:copyFromTo]' response (v 'body start'))
    } else {
      sayIt ('_http_status_text' response)
    }
  } else {
    sayIt 'Failed to get response'
  }
}


module 'HTTP server' Comm
author MicroBlocks
version 1 3 
depends WiFi 
tags http network 
description 'Create an HTTP server in MicroBlocks. You can use this library to allow remote control for your Wifi-enabled board.'

  spec 'r' '[net:httpServerGetRequest]' 'HTTP server request : binary data _' 'bool' false
  spec 'r' 'request method' 'method of request _' 'str' ''
  spec 'r' 'path of request' 'path of request _' 'str' ''
  spec 'r' 'headers of request' 'headers of request _' 'str' ''
  spec 'r' 'body of request' 'body of request _' 'str' ''
  spec 'r' 'content length of request' 'content length of request _' 'str' ''
  spec ' ' '[net:respondToHttpRequest]' 'respond _ to HTTP request : with body _ : and headers _ : keepAlive _' 'str str str bool' '200 OK' 'Welcome to the MicroBlocks HTTP server' 'Content-Type: text/plain' false
  spec 'r' '_endOfHeaders' '_end of headers _' 'str'
  spec 'r' '_toString' '_toString _' 'auto' 'abc'

to '_endOfHeaders' request {
  return ('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) request)
}

to '_toString' aStringOrByteArray {
  comment 'If argument is a byte array, convert it to a string. '
  if (not (isType aStringOrByteArray 'string')) {
    aStringOrByteArray = ('[data:join]' '' aStringOrByteArray)
  }
  return aStringOrByteArray
}

to 'body of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('[data:copyFromTo]' request (i + 4))
}

to 'content length of request' request {
  local 'i' ('_endOfHeaders' request)
  if (i < 0) {
    return 0
  }
  local 'j' ('[data:find]' 'Content-Length: ' request)
  if (j < 0) {
    comment 'Try alternate capitalization'
    j = ('[data:find]' 'Content-length: ' request)
  }
  if (or (j < 0) (j > i)) {
    return 0
  }
  j += 16
  local 'k' ('[data:find]' ('[data:unicodeString]' 13) request j)
  return (('[data:copyFromTo]' request j (k - 1)) + 0)
}

to 'headers of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('_toString' ('[data:copyFromTo]' request 1 (i - 1)))
}

to 'path of request' request {
  return ('_toString' ('[data:copyFromTo]' request (('[data:find]' ' ' request) + 1) (('[data:find]' ' HTTP' request) - 1)))
}

to 'request method' request {
  return ('_toString' ('[data:copyFromTo]' request 1 (('[data:find]' ' ' request) - 1)))
}


module 'Temperature Humidity (SHTC3)' Input
author MicroBlocks
version 1 3 
description 'Support for the SHTC3 temperature and relative humidity sensor.'

  spec 'r' 'shtc3_temperature' 'SHTC3 temperature (Â°C)'
  spec 'r' 'shtc3_humidity' 'SHTC3 relative humidity (%)'
  space
  spec ' ' '_shtc3_send_cmd' '_shtc3_send_cmd _' 'num' 0
  spec 'r' '_shtc3_read' '_shtc3_read'
  spec 'r' '_shtc3_crcOkay' '_shtc3_crcOkay _ _ _' 'num num num' 0 0 0

to '_shtc3_crcOkay' b1 b2 b3 {
  local 'crc' 255
  for i 2 {
    if (1 == i) {
      crc = (crc ^ b1)
    } else {
      crc = (crc ^ b2)
    }
    repeat 8 {
      if ((crc & 128) != 0) {
        crc = (((crc << 1) ^ 49) & 255)
      } else {
        crc = (crc << 1)
      }
    }
  }
  return (0 == (crc ^ b3))
}

to '_shtc3_read' {
  local 'SHTC addr' (hexToInt '70')
  comment 'Wakeup'
  '_shtc3_send_cmd' (hexToInt '3517')
  comment 'Read data, temperature first (with clock stretching)'
  '_shtc3_send_cmd' (hexToInt '7CA2')
  local 'sixBytes' (newList 6)
  '[sensors:i2cRead]' (v 'SHTC addr') sixBytes
  comment 'Do not send sleep command; that results in i2c error on next call'
  return sixBytes
}

to '_shtc3_send_cmd' cmd {
  local 'SHTC addr' (hexToInt '70')
  '[sensors:i2cWrite]' (v 'SHTC addr') ('[data:makeList]' ((cmd >> 8) & 255) (cmd & 255))
}

to shtc3_humidity {
  local 'data' ('_shtc3_read')
  local 'high' (at 4 data)
  local 'low' (at 5 data)
  if (not ('_shtc3_crcOkay' high low (at 6 data))) {
    return 0
  }
  local 'humidity' ((100 * ((high << 8) | low)) >> 16)
  if ('Databot' == (boardType)) {
    comment 'Adjust for extra heat from PC board'
    humidity += 10
  }
  return humidity
}

to shtc3_temperature {
  local 'data' ('_shtc3_read')
  local 'high' (at 1 data)
  local 'low' (at 2 data)
  if (not ('_shtc3_crcOkay' high low (at 3 data))) {
    return 0
  }
  local 'temperature' (((175 * ((high << 8) | low)) >> 16) - 45)
  if ('Databot' == (boardType)) {
    temperature += -10
    comment 'Adjust for extra heat from PC board'
  }
  return temperature
}


module WiFi Comm
author MicroBlocks
version 1 6 
tags communication network 
description 'Connect to a WiFi network. Used in conjunction with other network libraries, such as HTTP client, HTTP server or Web Thing.
'

  spec ' ' 'wifiConnect' 'wifi connect to _ password _ : IP _ gateway _ subnet _' 'str str auto auto auto' 'Network_Name' '' '192.168.1.42' '192.168.1.1' '255.255.255.0'
  spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
  spec 'r' 'getIPAddress' 'IP address'
  spec 'r' '[net:myMAC]' 'MAC address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to wifiConnect ssid password fixedIP gatewayIP subnetIP {
  if (not ('[net:hasWiFi]')) {return}
  '[net:stopWiFi]'
  if ((pushArgCount) < 5) {
    '[net:startWiFi]' ssid password
  } else {
    '[net:startWiFi]' ssid password false fixedIP gatewayIP subnetIP
  }
  local 'startMSecs' (millisOp)
  repeatUntil (('[net:myIPAddress]') != '0.0.0.0') {
    comment 'Timeout after N seconds'
    if (((millisOp) - startMSecs) > 30000) {
      sayIt 'Could not connect'
      return 0
    }
    comment 'Slow blink while trying to connect'
    setUserLED true
    waitMillis 300
    setUserLED false
    waitMillis 300
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  if ('Connected' != ('[net:wifiStatus]')) {
    sayIt 'Could not create hotspot'
    return 0
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}


module databot
author MicroBlocks
version 1 4 
depends 'Air Pressure (LPS22HB)' 'Gas (SGP30)' 'Temperature Humidity (SHTC3)' 'Light & Gesture (APDS9960)' 
choices databot_tempUnits 'Â°C' 'Â°F' 
description ''
variables _databot_pixels 

  spec ' ' 'databot_beep' 'databot beep'
  space
  spec ' ' 'databot_setAllLEDs' 'databot set all LEDs color _' 'color'
  spec ' ' 'databot_setLED' 'databot set LED _ color _' 'num color' 1
  spec 'r' 'databot_RGB' 'color r _ g _ b _ (0-255)' 'num num num' 100 0 100
  space
  spec 'r' 'databot_light' 'databot light level'
  space
  spec 'r' 'databot_tilt_x' 'databot tilt x'
  spec 'r' 'databot_tilt_y' 'databot tilt y'
  spec 'r' 'databot_tilt_z' 'databot tilt z'
  spec 'r' 'databot_acceleration' 'databot acceleration'
  space
  spec 'r' 'databot_temperature' 'databot temperature _' 'menu.databot_tempUnits' 'Â°C'
  spec 'r' 'databot_relative_humidity' 'databot relative humidity (%)'
  spec 'r' 'databot_uvIndex' 'databot UV Index (x10)'
  space
  spec 'r' 'databot_temp_probe1' 'databot temp probe 1 _ (x10)' 'menu.databot_tempUnits' 'Â°C'
  spec 'r' 'databot_temp_probe2' 'databot temp probe 2 _ (x10)' 'menu.databot_tempUnits' 'Â°C'
  space
  spec 'r' 'databot_magnetic_field' 'databot magenetic field'
  space
  spec ' ' '_databot_initLEDs' '_databot_initLEDs'
  spec 'r' '_databot_DS18B20_address' '_databot_DS18B20_address pin _' 'num' 4
  spec 'r' '_databot_raw_temperature' '_databot_raw_temperature pin _' 'num' 4

to '_databot_DS18B20_address' pin {
  '[1wire:init]' pin
  '[1wire:scanStart]'
  waitMillis 10
  local 'addr' ('[data:newByteArray]' 8)
  if (not ('[1wire:scanNext]' addr)) {
    comment 'No response; temperature probe not plugged in?'
    return 0
  }
  local 'family' (at 1 addr)
  if (not (or (family == 34) (or (family == 40) (family == 66)))) {
    comment 'Device is not a DS1822, DS18B20, or DS28EA00 temperature sensor'
    return 0
  }
  return addr
}

to '_databot_initLEDs' {
  '[display:neoPixelSetPin]' -1 false
  if (not (isType _databot_pixels 'list')) {
    _databot_pixels = (newList 3)
  }
}

to '_databot_raw_temperature' pin {
  comment 'Read the raw temperature. This function waits
a full second fo the temperature sensor to
measure the temperature, so it is best called
from a dedicated task.'
  local 'addr' ('_databot_DS18B20_address' pin)
  if (addr == 0) {
    sayIt 'Temperature probe not plugged in?'
    waitMillis 2000
    return 0
  }
  '[1wire:select]' addr
  '[1wire:writeByte]' (hexToInt '44') true
  waitMillis 1
  '[1wire:select]' addr
  '[1wire:writeByte]' (hexToInt 'BE')
  local 'data' ('[data:newByteArray]' 9)
  for i 9 {
    atPut i data ('[1wire:readByte]')
  }
  if (('[1wire:crc8]' data) != 0) {
    sayIt 'Bad temperature CRC'
    return 0
  }
  local 'result' (((at 2 data) << 8) | (at 1 data))
  if (result >= 32768) {
    comment 'Sign-extend 16-bit negative number'
    result = (result - 65536)
  }
  return result
}

to databot_RGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to databot_acceleration {
  return ('[sensors:acceleration]')
}

to databot_beep {
  '[io:playTone]' -1 440
  waitMillis 100
  '[io:playTone]' -1 0
}

to databot_light {
  return (apds9960_light)
}

to databot_magnetic_field {
  return ('[sensors:magneticField]')
}

to databot_relative_humidity {
  return (shtc3_humidity)
}

to databot_setAllLEDs color {
  '_databot_initLEDs'
  atPut 'all' _databot_pixels color
  '[display:neoPixelSend]' _databot_pixels
  waitMicros 150
}

to databot_setLED index color {
  '_databot_initLEDs'
  if (and (1 <= index) (index <= 3)) {
    if (3 == index) {
      index = 2
    } (2 == index) {
      index = 3
    }
    atPut index _databot_pixels color
    '[display:neoPixelSend]' _databot_pixels
    waitMicros 150
  }
}

to databot_temp_probe1 unit {
  local 'raw' ('_databot_raw_temperature' 4)
  if ('Â°F' == unit) {
    return ((((10 * 9) * raw) / (16 * 5)) + 320)
  } else {
    return ((10 * raw) / 16)
  }
}

to databot_temp_probe2 unit {
  local 'raw' ('_databot_raw_temperature' 23)
  if ('Â°F' == unit) {
    return ((((10 * 9) * raw) / (16 * 5)) + 320)
  } else {
    return ((10 * raw) / 16)
  }
}

to databot_temperature units {
  if (units == 'Â°C') {
    return (shtc3_temperature)
  } else {
    return (32 + (9 * ((shtc3_temperature) / 5)))
  }
}

to databot_tilt_x {
  return ('[sensors:tiltX]')
}

to databot_tilt_y {
  return ('[sensors:tiltY]')
}

to databot_tilt_z {
  return ('[sensors:tiltZ]')
}

to databot_uvIndex {
  local 'millivolts' ((3300 * (analogReadOp 34)) / 1023)
  if (millivolts < 200) {
    return 0
  }
  return ((millivolts - 132) / 94)
}

module main
author unknown
version 1 0 
description ''
variables responses 

  spec ' ' 'initializeResponses' 'initializeResponses'

to initializeResponses {
  responses = ('[data:makeList]' ('[data:makeList]' '/' '<h1>Hello!</h1>
<p>This is the MicroBlocks HTTP server.</p>
<p>You can test the following URLs:</p>
<ul>
<li>/test</li>
<li>/foo</li>
<li>/bar</li>
</ul>') ('[data:makeList]' '/test' '<p>This is a <strong>test</strong> URL</p>') ('[data:makeList]' '/foo' '<p>Just a page that says</p>
<h1>FOO</h1>') ('[data:makeList]' '/bar' '<p>Just a page that says</p>
<h1>BAR</h1>
<img src="https://microblocks.fun/assets/img/logos/MicroBlocks.svg"/>'))
}

script 50 50 {
comment 'This is an example HTTP server written in MicroBlocks.
It responds to the following URLs:
  /
  /test
  /foo
  /bar

You can also try a random URL and get back a 404 page.

The server responds to all request methods in the same way,
but you can easily add checks for other methods (like POST)
by using the ( method of request [ ] ) block.

You can also extract the body of a request (when it has one)
by using the ( body of request [ ] ) block.

Enjoy!'
}

script 52 347 {
whenStarted
comment 'Remember to use your network name (SSID) and password below'
wifiConnect 'Network_Name' ''
initializeResponses
local 'request' ''
forever {
  request = ('[net:httpServerGetRequest]')
  if (request != '') {
    for response responses {
      if (('path of request' request) == (at 1 response)) {'[net:respondToHttpRequest]' '200 OK' (at 2 response)}
    }
    '[net:respondToHttpRequest]' '404 Not Found' '<h1>404 Not Found</h1><p>I''m sorry, this page does not exist :(</p>'
  }
  waitMillis 10
}
}


module 'HTTP server' Comm
author MicroBlocks
version 1 3 
depends WiFi 
tags http network 
description 'Create an HTTP server in MicroBlocks. You can use this library to allow remote control for your Wifi-enabled board.'

  spec 'r' '[net:httpServerGetRequest]' 'HTTP server request : binary data _' 'bool' false
  spec 'r' 'request method' 'method of request _' 'str' ''
  spec 'r' 'path of request' 'path of request _' 'str' ''
  spec 'r' 'headers of request' 'headers of request _' 'str' ''
  spec 'r' 'body of request' 'body of request _' 'str' ''
  spec 'r' 'content length of request' 'content length of request _' 'str' ''
  spec ' ' '[net:respondToHttpRequest]' 'respond _ to HTTP request : with body _ : and headers _ : keepAlive _' 'str str str bool' '200 OK' 'Welcome to the MicroBlocks HTTP server' 'Content-Type: text/plain' false
  spec 'r' '_endOfHeaders' '_end of headers _' 'str'
  spec 'r' '_toString' '_toString _' 'auto' 'abc'

to '_endOfHeaders' request {
  return ('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) request)
}

to '_toString' aStringOrByteArray {
  comment 'If argument is a byte array, convert it to a string. '
  if (not (isType aStringOrByteArray 'string')) {
    aStringOrByteArray = ('[data:join]' '' aStringOrByteArray)
  }
  return aStringOrByteArray
}

to 'body of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('[data:copyFromTo]' request (i + 4))
}

to 'content length of request' request {
  local 'i' ('_endOfHeaders' request)
  if (i < 0) {
    return 0
  }
  local 'j' ('[data:find]' 'Content-Length: ' request)
  if (j < 0) {
    comment 'Try alternate capitalization'
    j = ('[data:find]' 'Content-length: ' request)
  }
  if (or (j < 0) (j > i)) {
    return 0
  }
  j += 16
  local 'k' ('[data:find]' ('[data:unicodeString]' 13) request j)
  return (('[data:copyFromTo]' request j (k - 1)) + 0)
}

to 'headers of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('_toString' ('[data:copyFromTo]' request 1 (i - 1)))
}

to 'path of request' request {
  return ('_toString' ('[data:copyFromTo]' request (('[data:find]' ' ' request) + 1) (('[data:find]' ' HTTP' request) - 1)))
}

to 'request method' request {
  return ('_toString' ('[data:copyFromTo]' request 1 (('[data:find]' ' ' request) - 1)))
}


module WiFi Comm
author MicroBlocks
version 1 6 
tags communication network 
description 'Connect to a WiFi network. Used in conjunction with other network libraries, such as HTTP client, HTTP server or Web Thing.
'

  spec ' ' 'wifiConnect' 'wifi connect to _ password _ : IP _ gateway _ subnet _' 'str str auto auto auto' 'Network_Name' '' '192.168.1.42' '192.168.1.1' '255.255.255.0'
  spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
  spec 'r' 'getIPAddress' 'IP address'
  spec 'r' '[net:myMAC]' 'MAC address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to wifiConnect ssid password fixedIP gatewayIP subnetIP {
  if (not ('[net:hasWiFi]')) {return}
  '[net:stopWiFi]'
  if ((pushArgCount) < 5) {
    '[net:startWiFi]' ssid password
  } else {
    '[net:startWiFi]' ssid password false fixedIP gatewayIP subnetIP
  }
  local 'startMSecs' (millisOp)
  repeatUntil (('[net:myIPAddress]') != '0.0.0.0') {
    comment 'Timeout after N seconds'
    if (((millisOp) - startMSecs) > 30000) {
      sayIt 'Could not connect'
      return 0
    }
    comment 'Slow blink while trying to connect'
    setUserLED true
    waitMillis 300
    setUserLED false
    waitMillis 300
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  if ('Connected' != ('[net:wifiStatus]')) {
    sayIt 'Could not create hotspot'
    return 0
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

module main
author wwj718
version 1 0 
description ''
variables event 

script 120 50 {
whenStarted
comment '1. connect wifi'
wifiConnect 'Network_Name' ''
waitMillis 1000
comment '2. connect MQTT broker'
'MQTT connect to' 'public.cloud.shiftr.io' 128 'MicroBlocks_client' 'public' 'public'
sendBroadcast 'loop'
}

script 50 279 {
comment 'subscribe topic'
'MQTT sub' 'testTopic'
}

script 367 280 {
comment 'publish topic payload'
'MQTT pub' 'testTopic' 'Hello!'
}

script 110 336 {
whenBroadcastReceived 'loop'
comment 'receive mqtt message'
forever {
  if ('MQTT connected') {
    event = ('[net:MQTTLastEvent]')
    if (isType event 'list') {
      sayIt 'topic' ('MQTT event topic' event) ', payload' ('MQTT event payload' event)
    }
  } else {
    sayIt 'try to connect ...'
    waitMillis 500
    'MQTT connect to' 'public.cloud.shiftr.io' 128 'MicroBlocks_client' 'public' 'public'
  }
}
}


module MQTT Comm
author wwj718
version 1 6 
depends WiFi 
tags mqtt network 
description 'A simple MQTT client.
'

  spec ' ' 'MQTT connect to' 'MQTT connect to broker _ : buffer sizes _ client id _ : username _ password _' 'str num str str str' '' 128 '' '' ''
  spec 'r' 'MQTT connected' 'MQTT connected'
  spec ' ' 'MQTT disconnect' 'MQTT disconnect'
  spec ' ' 'MQTT sub' 'MQTT sub _ : QoS _' 'str num' 'testTopic' 0
  spec ' ' 'MQTT unsub' 'MQTT unsub _' 'str' 'testTopic'
  spec ' ' 'MQTT pub' 'MQTT pub topic _ payload _ : retain _ QoS _' 'str auto bool num' 'testTopic' 'Hello!' false 0
  spec 'r' '[net:MQTTLastEvent]' 'MQTT event : binary _' 'bool' false
  spec 'r' 'MQTT event topic' 'topic for MQTT event _' 'str' ''
  spec 'r' 'MQTT event payload' 'payload for MQTT event _' 'str' ''
  spec ' ' '_MQTT set will' 'MQTT set will topic _ payload _ : retain _ QoS _ : buffer sizes _' 'str auto bool num num' 'testWill' 'Last will!' false 0 128

to 'MQTT connect to' broker buffer_sizes client_id username password {
  if ((getIPAddress) != '0.0.0.0') {
    if ((pushArgCount) == 1) {
      callCustomCommand '[net:MQTTConnect]' ('[data:makeList]' broker 128 ('[net:myMAC]'))
    } ((pushArgCount) == 3) {
      callCustomCommand '[net:MQTTConnect]' ('[data:makeList]' broker buffer_sizes client_id)
    } else {
      callCustomCommand '[net:MQTTConnect]' ('[data:makeList]' broker buffer_sizes client_id username password)
    }
    if ('MQTT connected') {
      sayIt 'Connected!'
    } else {
      sayIt 'Not Connected'
    }
  } else {
    sayIt 'Not Connected'
  }
}

to 'MQTT connected' {
  return (callCustomReporter '[net:MQTTIsConnected]')
}

to 'MQTT disconnect' {
  callCustomCommand '[net:MQTTdisconnect]'
}

to 'MQTT event payload' event {
  if (and (isType event 'list') ((size event) > 1)) {
    comment 'Join to empty string converts byte array to string'
    return ('[data:join]' '' (at 2 event))
  } else {
    return ''
  }
}

to 'MQTT event topic' event {
  if (and (isType event 'list') ((size event) > 1)) {
    return (at 1 event)
  } else {
    return ''
  }
}

to 'MQTT pub' topic payload retain qos {
  if ((pushArgCount) < 4) {
    okay = (callCustomReporter '[net:MQTTPub]' ('[data:makeList]' topic payload))
  } else {
    okay = (callCustomReporter '[net:MQTTPub]' ('[data:makeList]' topic payload retain qos))
  }
  if (not okay) {
    sayIt 'pub failure!'
  }
}

to 'MQTT sub' topic qos {
  if ((pushArgCount) < 2) {
    okay = (callCustomReporter '[net:MQTTSub]' ('[data:makeList]' topic))
  } else {
    okay = (callCustomReporter '[net:MQTTSub]' ('[data:makeList]' topic qos))
  }
  if (not okay) {
    sayIt 'sub failure!'
  }
}

to 'MQTT unsub' topic {
  if ((callCustomReporter '[net:MQTTUnsub]' ('[data:makeList]' topic)) != (booleanConstant true)) {sayIt 'unsub failure!'}
}

to '_MQTT set will' topic payload retain qos buffer_sizes {
  if ('MQTT connected') {
    sayIt 'set will has to be called before calling connect'
    return ''
  }
  if ((pushArgCount) < 4) {
    okay = (callCustomReporter '[net:MQTTSetWill]' ('[data:makeList]' topic payload))
  } ((pushArgCount) == 4) {
    okay = (callCustomReporter '[net:MQTTSetWill]' ('[data:makeList]' topic payload retain qos))
  } else {
    okay = (callCustomReporter '[net:MQTTSetWill]' ('[data:makeList]' topic payload retain qos buffer_sizes))
  }
  if (not okay) {
    sayIt 'set will failure!'
  }
}


module WiFi Comm
author MicroBlocks
version 1 6 
tags communication network 
description 'Connect to a WiFi network. Used in conjunction with other network libraries, such as HTTP client, HTTP server or Web Thing.
'

  spec ' ' 'wifiConnect' 'wifi connect to _ password _ : IP _ gateway _ subnet _' 'str str auto auto auto' 'Network_Name' '' '192.168.1.42' '192.168.1.1' '255.255.255.0'
  spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
  spec 'r' 'getIPAddress' 'IP address'
  spec 'r' '[net:myMAC]' 'MAC address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to wifiConnect ssid password fixedIP gatewayIP subnetIP {
  if (not ('[net:hasWiFi]')) {return}
  '[net:stopWiFi]'
  if ((pushArgCount) < 5) {
    '[net:startWiFi]' ssid password
  } else {
    '[net:startWiFi]' ssid password false fixedIP gatewayIP subnetIP
  }
  local 'startMSecs' (millisOp)
  repeatUntil (('[net:myIPAddress]') != '0.0.0.0') {
    comment 'Timeout after N seconds'
    if (((millisOp) - startMSecs) > 30000) {
      sayIt 'Could not connect'
      return 0
    }
    comment 'Slow blink while trying to connect'
    setUserLED true
    waitMillis 300
    setUserLED false
    waitMillis 300
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  if ('Connected' != ('[net:wifiStatus]')) {
    sayIt 'Could not create hotspot'
    return 0
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

module main
author wwj
version 1 0 
description ''
variables count _OctoAdvertising shape 

script 306 40 {
comment 'OctoStudio on Android phones is not very stable. 
After running for some time, 
the beam and wait for blocks might not work. 
If you''re not receiving messages, 
try restarting the OctoStudio  APP.'
}

script 56 59 {
whenStarted
'Octo start'
count = 0
forever {
  shape = ('Octo receive beam')
  if (shape != (booleanConstant false)) {
    count += 1
    sayIt shape count
  }
  waitMillis 100
}
}

script 400 196 {
'beam to phones' 'heart'
}


module OctoStudio Comm
author wwj718
version 1 3 
choices shape_choices triangle circle square heart star 
description 'Communicate with OctoStudio (https://octostudio.org/)'
variables _OctoAdvertising 

  spec ' ' 'Octo start' 'Octo start'
  spec ' ' 'beam to phones' 'Octo beam to phones _ : duration _ ms' 'menu.shape_choices num' 'heart' 200
  spec 'r' 'Octo receive beam' 'Octo receive beam'
  spec ' ' 'Octo stop' 'Octo stop'
  spec 'r' '_generate_full_shape_id' '_generate_full_shape_id shape _' 'auto' 'heart'
  spec ' ' '_Octo deinit' '_Octo deinit'
  spec 'r' '_shape_map' '_shape_map'

to 'Octo receive beam' {
  local 'shape_id' (callCustomReporter '[net:OctoGetOctoShapeId]')
  if (shape_id != (booleanConstant false)) {
    for s ('_shape_map') {
      if ((at 2 s) == shape_id) {return (at 1 s)}
    }
  } else {
    return (booleanConstant false)
  }
}

to 'Octo start' {
  if (not (callCustomReporter '[net:OctoGetBLEInitialized]')) {callCustomCommand '[net:OctoInitBLE]'}
  if (not (callCustomReporter '[net:OctoScanning]')) {callCustomCommand '[net:OctoStartScanning]'}
}

to 'Octo stop' {
  if (callCustomReporter '[net:OctoScanning]') {callCustomCommand '[net:OctoStopScanning]'}
}

to '_Octo deinit' {
  callCustomCommand '[net:OctoDeinitBLE]'
}

to '_generate_full_shape_id' shape_name {
  comment 'Mimic iOS, eg: ECA7059C00000001'
  local 'full_shap_id' ('[data:makeList]')
  repeat 8 {
    '[data:addLast]' (at 'random' '0123456789ABCDEF') full_shap_id
  }
  for s ('_shape_map') {
    if ((at 1 s) == shape_name) {
      repeat 7 {
        '[data:addLast]' 0 full_shap_id
      }
      '[data:addLast]' (at 2 s) full_shap_id
      return ('[data:joinStrings]' full_shap_id)
    }
  }
  return 'This shape does not exist'
}

to '_shape_map' {
  comment '"0": "circle",
"1": "square",
"2": "star",
"3": "heart",
"4": "triangle",'
  return ('[data:makeList]' ('[data:makeList]' 'circle' 0) ('[data:makeList]' 'square' 1) ('[data:makeList]' 'star' 2) ('[data:makeList]' 'heart' 3) ('[data:makeList]' 'triangle' 4))
}

to 'beam to phones' shape optionalDuration {
  local 'duration' 200
  if ((pushArgCount) > 1) {
    duration = optionalDuration
  }
  if (callCustomReporter '[net:OctoGetBLEInitialized]') {
    if (_OctoAdvertising == 1) {
      sayIt 'waiting...'
      waitUntil (_OctoAdvertising == 0)
      sayIt ''
    }
    _OctoAdvertising = 1
    callCustomCommand '[net:OctoSetDeviceName]' ('[data:makeList]' ('_generate_full_shape_id' shape))
    callCustomCommand '[net:OctoStartAdvertising]'
    waitMillis duration
    callCustomCommand '[net:OctoStopAdvertising]'
    _OctoAdvertising = 0
  } else {
    sayIt 'Please start Octo first'
  }
}

module main
author unknown
version 1 0 
description ''
variables hours minutes seconds server 

  spec ' ' 'draw time' 'draw time'
  spec ' ' 'fetch current time from server' 'fetch current time from server _' 'auto' 'microblocks.fun'
  spec 'r' 'online time' 'online time from server _' 'auto' 'microblocks.fun'
  spec ' ' 'tick' 'tick'
  spec 'r' 'twoDigits' 'twoDigits _' 'auto' 5

to 'draw time' {
  local 'y' (('[tft:getHeight]') / 3)
  local 'x' ((('[tft:getWidth]') - 145) / 2)
  if (x < 0) {
    x = 0
  }
  '[tft:rect]' x y 145 30 (colorSwatch 0 0 0 255)
  if (hours < 10) {
    '[tft:text]' '0' x y (colorSwatch 255 46 18 255) 3 false
    '[tft:text]' hours (x + 20) y (colorSwatch 255 46 18 255) 3 false
  } else {
    '[tft:text]' hours x y (colorSwatch 255 46 18 255) 3 false
  }
  '[tft:text]' ':' (x + 32) y (colorSwatch 255 46 18 255) 3 false
  if (minutes < 10) {
    '[tft:text]' '0' (x + 44) y (colorSwatch 255 46 18 255) 3 false
    '[tft:text]' minutes (x + 64) y (colorSwatch 255 46 18 255) 3 false
  } else {
    '[tft:text]' minutes (x + 44) y (colorSwatch 255 46 18 255) 3 false
  }
  '[tft:text]' ':' (x + 76) y (colorSwatch 255 46 18 255) 3 false
  if (seconds < 10) {
    '[tft:text]' '0' (x + 88) y (colorSwatch 255 46 18 255) 3 false
    '[tft:text]' seconds (x + 108) y (colorSwatch 255 46 18 255) 3 false
  } else {
    '[tft:text]' seconds (x + 88) y (colorSwatch 255 46 18 255) 3 false
  }
}

to 'fetch current time from server' url {
  local 'start ms' (millisOp)
  local 'current time' ('online time' url)
  hours = (('[data:copyFromTo]' (v 'current time') 1 2) + 0)
  minutes = (('[data:copyFromTo]' (v 'current time') 4 5) + 0)
  seconds = (('[data:copyFromTo]' (v 'current time') 7 8) - (((millisOp) - (v 'start ms')) / 1000))
  repeat 5 {
    '[tft:circle]' (('[tft:getWidth]') / 2) (('[tft:getHeight]') / 5) 5 (colorSwatch 255 242 71 255) true
    waitMillis 25
    '[tft:circle]' (('[tft:getWidth]') / 2) (('[tft:getHeight]') / 5) 5 (colorSwatch 0 0 0 255) true
    waitMillis 25
  }
}

to 'online time' server {
  local 'url' ('[data:join]' server '/nonExistentPage')
  local 'response' ('_request_url' url 'GET' '')
  local 'header' ('_http_header_text' response)
  return ('[data:copyFromTo]' header (('[data:find]' 'GMT' header) - 9) (('[data:find]' 'GMT' header) - 2))
}

to tick {
  seconds += 1
  if (seconds == 60) {
    seconds = 0
    minutes += 1
    if (minutes == 60) {
      minutes = 0
      hours += 1
    }
    if (hours == 24) {
      hours = 0
    }
  }
}

to twoDigits n {
  if (n < 10) {return ('[data:join]' '0' n)}
  return ('[data:join]' '' n)
}

script 50 50 {
comment 'This project fetches the current time (GMT) from
the microblocks.fun server. It does so by parsing
the headers of the HTTP response. After that, it
keeps time by itself and requests an update from
the server every minute.

Requires a board with Wifi and a TFT display.

Remember to enter your Wifi network name and
password.'
}

script 564 80 {
whenBroadcastReceived 'time received'
forever {
  sayIt ('[data:join]' hours ':' (twoDigits minutes) ':' (twoDigits seconds))
  'draw time'
  tick
  waitMillis 1000
}
}

script 52 238 {
whenStarted
server = 'microblocks.fun'
'[tft:text]' 'Connecting' 0 (('[tft:getHeight]') / 3) (colorSwatch 46 255 40 255) 2 true
wifiConnect 'Network_Name' ''
'[display:mbDisplayOff]'
'[tft:text]' 'Fetching time' 0 (('[tft:getHeight]') / 5) (colorSwatch 46 255 40 255) 2 true
'[tft:text]' server 0 (('[tft:getHeight]') / 2) (colorSwatch 46 255 40 255) 2 true
'fetch current time from server' server
'[display:mbDisplayOff]'
sendBroadcast 'time received'
}

script 564 260 {
whenButtonPressed 'A'
'fetch current time from server' server
}

script 567 365 {
whenCondition (and ((getIPAddress) != '0.0.0.0') (seconds == 0))
'fetch current time from server' server
waitUntil (seconds != 0)
}


module 'HTTP client' Comm
author MicroBlocks
version 1 4 
depends WiFi 
tags http network get post put delete 
description 'Send HTTP requests and get responses back. You can use this library to fetch or store data in online servers, or to control other Wifi-enabled boards.
'

  spec 'r' '_http_body_start' '_http_body_start _' 'auto' ''
  spec 'r' '_http_header_text' '_http_header_text _' 'auto' ''
  spec 'r' '_http_status_text' '_http_status_text _' 'auto' ''
  spec 'r' '_http_header' '_header _ of response _' 'auto auto' 'content-length' ''
  spec 'r' '_http_status' '_status of response _' 'auto' ''
  spec 'r' '_line_end' '_line_end'
  spec 'r' '_lowercase' '_lowercase _' 'auto' 'ABC Def gH'
  spec 'r' '_request_url' '_request_url _ method _ body _ : port _' 'str menu.requestTypes str num' '' 'GET' '' 80
  spec 'r' '_readHTTPResponse' '_readHTTPResponse'
  spec 'r' 'httpÜ//' 'httpÜ// _  : port _' 'auto num' 'microblocks.fun/example.txt' 80
  spec ' ' 'request' '_ data _ to httpÜ// _  : port _' 'menu.requestTypes str str num' 'POST' 'MicroBlocks is fun' 'microblocks.fun' 80

to '_http_body_start' response {
  return (('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) response) + 4)
}

to '_http_header' header response {
  local 'header text' ('_http_header_text' response)
  header = ('_lowercase' header)
  repeatUntil ((size (v 'header text')) < 3) {
    local 'key' ('[data:copyFromTo]' (v 'header text') 1 (('[data:find]' ':' (v 'header text')) - 1))
    if (('_lowercase' key) == header) {
      return ('[data:copyFromTo]' (v 'header text') (('[data:find]' ':' (v 'header text')) + 2) (('[data:find]' ('_line_end') (v 'header text')) - 1))
    }
    'header text' = ('[data:copyFromTo]' (v 'header text') (('[data:find]' ('_line_end') (v 'header text')) + 2))
  }
  return (booleanConstant false)
}

to '_http_header_text' response {
  local 'headersStart' (('[data:find]' ('_line_end') response) + 2)
  return ('[data:copyFromTo]' response headersStart (('_http_body_start' response) + 2))
}

to '_http_status' response {
  return (('[data:copyFromTo]' ('_http_status_text' response) 1 4) + 0)
}

to '_http_status_text' response {
  return ('[data:copyFromTo]' response ('[data:find]' ' ' response) ('[data:find]' ('_line_end') response))
}

to '_line_end' {
  return ('[data:unicodeString]' ('[data:makeList]' 13 10))
}

to '_lowercase' string {
  local 'lowercased' ''
  local 'char code' ''
  for c (size string) {
    'char code' = ('[data:unicodeAt]' c string)
    if (and ((v 'char code') >= 65) ((v 'char code') <= 90)) {
      'char code' = ((v 'char code') + 32)
    }
    lowercased = ('[data:join]' lowercased ('[data:unicodeString]' (v 'char code')))
  }
  return lowercased
}

to '_readHTTPResponse' {
  local 'response' ''
  local 'lastChunkTime' (millisOp)
  repeatUntil (not ('[net:httpIsConnected]')) {
    local 'chunk' ('[net:httpResponse]')
    if ((size chunk) > 0) {
      response = ('[data:join]' response chunk)
      lastChunkTime = (millisOp)
    } (((millisOp) - lastChunkTime) > 10000) {
      return response
    }
    waitMillis 20
  }
  response = ('[data:join]' response ('[net:httpResponse]'))
  return response
}

to '_request_url' url method body optionalPort {
  local 'port' 80
  if ((pushArgCount) > 3) {
    port = optionalPort
  }
  local 'host' ''
  local 'path' ''
  local 'slashPosition' ('[data:find]' '/' url)
  if (slashPosition > 0) {
    host = ('[data:copyFromTo]' url 1 (slashPosition - 1))
    path = ('[data:copyFromTo]' url (slashPosition + 1))
  } else {
    host = url
  }
  if (('[net:wifiStatus]') != 'Connected') {
    return ('[data:join]' '0 Not Connected' ('_line_end'))
  }
  '[net:httpConnect]' host port
  if (not ('[net:httpIsConnected]')) {
    return ('[data:join]' '0 Could not connect to server' ('_line_end'))
  }
  '[net:httpRequest]' method host path
  return ('_readHTTPResponse')
}

to 'httpÜ//' url optionalPort {
  local 'port' 80
  if ((pushArgCount) > 1) {
    port = optionalPort
  }
  local 'response' ('_request_url' url 'GET' '' port)
  if (response != '') {
    if (('_http_status' response) == 200) {
      return ('[data:copyFromTo]' response ('_http_body_start' response))
    } else {
      return ('_http_status_text' response)
    }
  } else {
    return 'Failed to get response'
  }
}

to request method data url optionalPort {
  local 'port' 80
  if ((pushArgCount) > 3) {
    port = optionalPort
  }
  local 'response' ('_request_url' url method data port)
  if (response != '') {
    local 'status' ('_http_status' response)
    local 'body start' ('_http_body_start' response)
    if (and (200 == status) ((v 'body start') > 0)) {
      sayIt ('[data:copyFromTo]' response (v 'body start'))
    } else {
      sayIt ('_http_status_text' response)
    }
  } else {
    sayIt 'Failed to get response'
  }
}


module TFT Output
author MicroBlocks
version 1 5 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  space
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}


module WiFi Comm
author MicroBlocks
version 1 6 
tags communication network 
description 'Connect to a WiFi network. Used in conjunction with other network libraries, such as HTTP client, HTTP server or Web Thing.
'

  spec ' ' 'wifiConnect' 'wifi connect to _ password _ : IP _ gateway _ subnet _' 'str str auto auto auto' 'Network_Name' '' '192.168.1.42' '192.168.1.1' '255.255.255.0'
  spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
  spec 'r' 'getIPAddress' 'IP address'
  spec 'r' '[net:myMAC]' 'MAC address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to wifiConnect ssid password fixedIP gatewayIP subnetIP {
  if (not ('[net:hasWiFi]')) {return}
  '[net:stopWiFi]'
  if ((pushArgCount) < 5) {
    '[net:startWiFi]' ssid password
  } else {
    '[net:startWiFi]' ssid password false fixedIP gatewayIP subnetIP
  }
  local 'startMSecs' (millisOp)
  repeatUntil (('[net:myIPAddress]') != '0.0.0.0') {
    comment 'Timeout after N seconds'
    if (((millisOp) - startMSecs) > 30000) {
      sayIt 'Could not connect'
      return 0
    }
    comment 'Slow blink while trying to connect'
    setUserLED true
    waitMillis 300
    setUserLED false
    waitMillis 300
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  if ('Connected' != ('[net:wifiStatus]')) {
    sayIt 'Could not create hotspot'
    return 0
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

module main
author MicroBlocks
version 1 0 
description 'Signada is a network protocol for remote control of microcontrollers'
variables password SSID mode event 'HTTP portal' 

  spec ' ' 'handle HTTP portal' 'handle HTTP portal'
  spec 'r' 'configPage' 'config page'
  spec ' ' 'connection' 'check credentials and connect'
  spec ' ' 'extract credentials from path' 'extract credentials from _' 'auto' ''
  spec ' ' 'savewifi' 'save WiFi SSID _ password _ mode _' 'auto auto auto' '' '' '10'
  spec ' ' 'showConnectionInfo' 'show connection info'
  spec ' ' 'process event' 'process event'
  spec ' ' 'set display' 'set display _' 'auto' ''
  spec ' ' 'clear' 'clear'
  spec 'r' 'get pin' 'get pin _ _' 'auto auto' '10' '10'
  spec 'r' 'sensor' 'sensor _' 'auto' 'acceleration'
  spec ' ' 'set led' 'set led _ _ _' 'auto auto bool' 10 10 true
  spec ' ' 'set pin' 'set pin _ _ _' 'auto auto auto' '10' 'analog' '10'
  spec ' ' 'text' 'text _ _ _ _ _' 'auto auto auto color auto' '10' '10' '10' nil '10'
  spec 'r' 'tilt' 'tilt _' 'auto' 'x'

to clear {
  '[display:mbDisplayOff]'
}

to configPage {
  return ('[data:join]' '<h1>WiFi configuration</h1>
<form action="/saveconfig">
  <label for="ssid">SSID:</label><br>
  <input type="text" name="ssid" value="' SSID '"><br><br>
  <label for="pass">Password:</label><br>
  <input type="text" name="pass" value="' password '"><br><br>
  <label for="mode">Mode AP?</label><br>
  <input type="checkbox" name="mode" value="ap"><br><br>
  <input type="submit" value="Submit">
</form>')
}

to connection {
  if (('[data:find]' 'wifi' ('file names')) == -1) {
    SSID = ('[data:join]' 'ED1-' ('[data:copyFromTo]' ('[net:myMAC]') 13 14) ('[data:copyFromTo]' ('[net:myMAC]') 16 17))
    password = '1234567890'
    mode = 'ap'
    wifiCreateHotspot SSID password
  } else {
    '[file:open]' 'wifi'
    SSID = ('[file:readLine]' 'wifi')
    password = ('[file:readLine]' 'wifi')
    modeAP = ('[file:readLine]' 'wifi')
    '[file:close]' 'wifi'
    if (modeAP == 'ap') {
      mode = 'ap'
      wifiCreateHotspot SSID password
    } else {
      wifiConnect SSID password
    }
  }
}

to 'extract credentials from path' string {
  SSID = ('[data:copyFromTo]' string (('[data:find]' 'ssid' string) + 5) (('[data:find]' 'pass' string) - 2))
  if (('[data:find]' 'mode' string) == -1) {
    password = ('[data:copyFromTo]' string (('[data:find]' 'pass' string) + 5))
    mode = ''
  } else {
    password = ('[data:copyFromTo]' string (('[data:find]' 'pass' string) + 5) (('[data:find]' 'mode' string) - 2))
    mode = ('[data:copyFromTo]' string (('[data:find]' 'mode' string) + 5))
  }
}

to 'get pin' pin 'analog or digital' {
  if ((v 'analog or digital') == 'analog') {
    return (analogReadOp pin)
  } else {
    return (digitalReadOp pin)
  }
}

to 'handle HTTP portal' {
  request = ('[net:httpServerGetRequest]')
  if (request != '') {
    local 'path' ('path of request' request)
    if (path == '/') {
      '[net:respondToHttpRequest]' '200 OK' (configPage)
    }
    if (('[data:copyFromTo]' path 1 11) == '/saveconfig') {
      'extract credentials from path' path
      savewifi SSID password mode
      'HTTP portal' = (booleanConstant false)
      '[net:respondToHttpRequest]' '200 OK' 'WiFi credentials saved! Please reset the board to connect again.'
    }
    '[net:respondToHttpRequest]' '404 Not Found' '<h1>404 Not Found</h1><p>:(</p>'
    waitMillis 10
  }
}

to 'process event' {
  local 'current event' ('[data:copyFromTo]' event 1)
  if (('ws event type' (v 'current event')) == 'connected') {
    '[display:mbDisplayOff]'
    '[tft:text]' 'Connected.' 5 5 (colorSwatch 255 255 255 255)
  } (('ws event type' (v 'current event')) == 'text message') {
    local 'msg' ('ws event payload' (v 'current event'))
    local 'message id' ('[misc:jsonGet]' msg '1')
    local 'selector' ('[misc:jsonGet]' msg '2')
    local 'params' ('[data:makeList]')
    for i ('[misc:jsonCount]' msg '3') {
      '[data:addLast]' ('[misc:jsonGet]' msg ('[data:join]' '3.' i)) params
    }
    local 'result' (callCustomReporter selector params)
    '[net:webSocketSendToClient]' ('[data:join]' '[' (v 'message id') ',' result ']') ('ws client id' (v 'current event'))
  }
}

to savewifi SSID password mode {
  '[file:delete]' 'wifi'
  '[file:open]' 'wifi'
  '[file:appendLine]' SSID 'wifi'
  '[file:appendLine]' password 'wifi'
  '[file:appendLine]' mode 'wifi'
  '[file:close]' 'wifi'
}

to sensor which {
  if (which == 'acceleration') {
    return ('[sensors:acceleration]')
  } (which == 'light') {
    return ('[display:lightLevel]')
  } else {
    return ('[sensors:temperature]')
  }
}

to 'set display' data {
  '[display:mbDisplayOff]'
  for y 5 {
    for x 5 {
      if ((at (((y - 1) * 5) + x) data) == 'X') {'[display:mbPlot]' x y}
    }
  }
}

to 'set led' x y value {
  if value {
    '[display:mbPlot]' x y
  } else {
    '[display:mbUnplot]' x y
  }
}

to 'set pin' pin 'analog or digital' value {
  if ((v 'analog or digital') == 'analog') {
    analogWriteOp pin value
  } else {
    digitalWriteOp pin value
  }
}

to showConnectionInfo {
  '[display:mbDisplayOff]'
  '[tft:text]' ('[data:join]' 'SSID: ' SSID) 0 0 16777215 1 true
  '[tft:text]' ('[data:join]' 'IP:' ('[net:myIPAddress]')) 0 10 16777215 1 true
  if (mode == 'ap') {
    '[tft:text]' ('[data:join]' 'PWD:' password) 0 20 16777215 1 true
  }
}

to text text x y clr scale {
  '[tft:text]' text x y (clr + 0) scale false
}

to tilt which {
  if (which == 'x') {
    return ('[sensors:tiltX]')
  } (which == 'y') {
    return ('[sensors:tiltY]')
  } else {
    return ('[sensors:tiltZ]')
  }
}

script 493 50 {
whenStarted
'[display:mbDisplayOff]'
'[tft:circle]' (('[tft:getWidth]') / 2) (('[tft:getHeight]') / 2) 30 255
waitMillis 1500
if (and (buttonA) (buttonB)) {
  '[tft:circle]' (('[tft:getWidth]') / 2) (('[tft:getHeight]') / 2) 30 (colorSwatch 46 255 86 255)
  '[file:delete]' 'wifi'
}
'HTTP portal' = (('[data:find]' 'wifi' ('file names')) == -1)
sendBroadcast 'go'
}

script 50 54 {
comment 'Signada: a network remote control procotol
================================

## What is it

This protocol was designed for the Citilab
ED1 board, but will work on any ESP board
with a display and two buttons, like the
M5Stack.

Its intended use is in conjunction with the
Signada Snap! library, but the protocol runs
over websockets and could be used with
other applications.

## Setup

The first time you run the project, the board
is going to create a WiFi hotspot. Look at
the screen to find out its name.

Connect to that hotspot from any device
(computer, phone, etc) and point its browser
to the board''s IP address, that should be
192.168.4.1. Make sure to not use https.

Follow the instructions on the website to set
up the board WiFi parameters according to
your local network.

If you want to modify that configuration later
on, keep buttons A and B pressed while
resetting the board and the hotspot portal
will load again.

## Usage

Load the Signada library in Snap!. Make
sure both the board and the device running
Snap! are in the same network, and use the
blocks provided by the Snap! library to
communicate with the board.'
}

script 940 56 {
whenBroadcastReceived 'go'
connection
showConnectionInfo
repeatUntil (not (v 'HTTP portal')) {
  'handle HTTP portal'
  waitMillis 50
}
'start WebSocket server'
forever {
  event = ('[net:webSocketLastEvent]')
  if (event != (booleanConstant false)) {
    sendBroadcast 'process event'
  }
  waitMillis 20
}
}

script 542 458 {
comment 'Use this script to set the Wifi credentials manually'
savewifi 'MySSID' 'MyPassword' ''
}


module 'Basic Sensors' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor 
choices accelerometerRange '1' '2' '4' '8' 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[sensors:acceleration]' 'acceleration'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (Â°C)'
  spec ' ' '_setAccelRange' 'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to '_setAccelRange' n {
  '[sensors:setAccelerometerRange]' (0 + n)
}


module 'ED1 Buttons' Input
author MicroBlocks
version 1 0 
tags button capacitive ed1 
description 'Provides blocks for the six capacitive buttons in the Citilab ED1 board.'
variables _ED1_buttons_init '_capacitive threshold' 

  spec ' ' '_ED1_buttons_init' '_ED1_buttons_init' 'any any any'
  spec 'r' 'OK button' 'button OK'
  spec 'r' 'cancel button' 'button X'
  spec 'r' 'up button' 'button up'
  spec 'r' 'down button' 'button down'
  spec 'r' 'left button' 'button left'
  spec 'r' 'right button' 'button right'
  spec ' ' 'set capacitive threshold to' 'set capacitive threshold to _' 'auto' 16

to 'OK button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 15) < (v '_capacitive threshold'))
}

to '_ED1_buttons_init' {
  if (_ED1_buttons_init == 0) {
    if ((v '_capacitive threshold') == 0) {'_capacitive threshold' = 16}
    _ED1_buttons_init = (booleanConstant true)
  }
}

to 'cancel button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 14) < (v '_capacitive threshold'))
}

to 'down button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 13) < (v '_capacitive threshold'))
}

to 'left button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 2) < (v '_capacitive threshold'))
}

to 'right button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 27) < (v '_capacitive threshold'))
}

to 'set capacitive threshold to' threshold {
  '_capacitive threshold' = threshold
}

to 'up button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 4) < (v '_capacitive threshold'))
}


module 'ED1 Stepper Motor' Output
author MicroBlocks
version 1 1 
tags '28byj-48' stepper motor fantastic ed1 
choices directions clockwise 'counter-clockwise' 
description 'Provides blocks to control 28BYJ-48 stepper motors, like the ones included in the Fantastic robot kit for the Citilab ED1 board.
'
variables _ED1_stepper_init _ED1_CW1 _ED1_CW2 _ED1_CCW1 _ED1_CCW2 _ED1_motor_running _ED1_exp_register 

  spec ' ' 'motor step' 'move motor _ _ steps _' 'auto auto menu.directions' 1 '128' 'clockwise'
  spec ' ' 'move motor ' 'move motor 1 _ and motor 2 _ _ steps' 'menu.directions menu.directions auto' 'clockwise' 'counter-clockwise' '64'
  spec ' ' 'motor angle' 'move motor _ angle _ Â°' 'auto auto' '1' '-90'
  spec ' ' 'motor turns' 'move motor _ _ complete turns' 'auto auto' '1' '3'
  spec ' ' '_ED1_stepper_init' '_ED1_stepper_init'
  spec ' ' 'stop steppers' 'stop steppers'

to '_ED1_stepper_init' {
  if (_ED1_stepper_init == 0) {
    comment '0 for ED1 V2'
    if ((i2cGet (hexToInt '20') 1) == 0) {
      _ED1_exp_register = (hexToInt '9')
    } else {
      _ED1_exp_register = (hexToInt '14')
    }
    _ED1_CW1 = (hexToInt 'C')
    _ED1_CW2 = (hexToInt '3')
    _ED1_CCW1 = (hexToInt '3')
    _ED1_CCW2 = (hexToInt 'C')
    _ED1_stepper_init = (booleanConstant true)
    i2cSet (hexToInt '20') 0 0
    i2cSet (hexToInt '20') 6 255
  }
}

to 'motor angle' 'motor number' angle {
  local 'direction' 'clockwise'
  if (angle < 0) {
    direction = 'counter-clockwise'
    angle = (angle * -1)
  }
  'motor step' (v 'motor number') ((142 * angle) / 100) direction
}

to 'motor step' 'motor number' steps direction {
  '_ED1_stepper_init'
  _ED1_motor_running = (booleanConstant true)
  repeat steps {
    if _ED1_motor_running {
      i2cSet (hexToInt '20') _ED1_exp_register ((hexToInt '9') << (((v 'motor number') % 2) << 2))
      waitMicros 1500
      if (direction == 'clockwise') {
        i2cSet (hexToInt '20') _ED1_exp_register ((hexToInt 'C') << (((v 'motor number') % 2) << 2))
      } else {
        i2cSet (hexToInt '20') _ED1_exp_register ((hexToInt '3') << (((v 'motor number') % 2) << 2))
      }
      waitMicros 1500
      i2cSet (hexToInt '20') _ED1_exp_register ((hexToInt '6') << (((v 'motor number') % 2) << 2))
      waitMicros 1500
      if (direction == 'clockwise') {
        i2cSet (hexToInt '20') _ED1_exp_register ((hexToInt '3') << (((v 'motor number') % 2) << 2))
      } else {
        i2cSet (hexToInt '20') _ED1_exp_register ((hexToInt 'C') << (((v 'motor number') % 2) << 2))
      }
      waitMicros 1500
    }
  }
  'stop steppers'
}

to 'motor turns' 'motor number' turns {
  local 'direction' 'clockwise'
  if (turns < 0) {
    direction = 'counter-clockwise'
    turns = (turns * -1)
  }
  'motor step' (v 'motor number') (turns * 512) direction
}

to 'move motor ' 'direction 1' 'direction 2' steps {
  '_ED1_stepper_init'
  _ED1_motor_running = (booleanConstant true)
  local 'step 1' 0
  local 'step 2' 0
  if ((v 'direction 1') == 'clockwise') {
    'step 1' = _ED1_CW1
    'step 2' = _ED1_CW2
  } else {
    'step 1' = _ED1_CCW1
    'step 2' = _ED1_CCW2
  }
  if ((v 'direction 2') == 'clockwise') {
    'step 1' = (((v 'step 1') << 4) | _ED1_CW1)
    'step 2' = (((v 'step 2') << 4) | _ED1_CW2)
  } else {
    'step 1' = (((v 'step 1') << 4) | _ED1_CCW1)
    'step 2' = (((v 'step 2') << 4) | _ED1_CCW2)
  }
  repeat steps {
    if _ED1_motor_running {
      i2cSet (hexToInt '20') _ED1_exp_register (hexToInt '99')
      waitMicros 1500
      i2cSet (hexToInt '20') _ED1_exp_register (v 'step 1')
      waitMicros 1500
      i2cSet (hexToInt '20') _ED1_exp_register (hexToInt '66')
      waitMicros 1500
      i2cSet (hexToInt '20') _ED1_exp_register (v 'step 2')
      waitMicros 1500
    }
  }
  'stop steppers'
}

to 'stop steppers' {
  i2cSet (hexToInt '20') _ED1_exp_register 0
  _ED1_motor_running = (booleanConstant false)
  waitMicros 1500
}


module Files Data
author MicroBlocks
version 1 3 
description 'Flash file system operations. Currently supports the LittleFS file system on ESP8266 and ESP32 boards. The GnuBlocks virtual machine (Linux and Raspberry Pi) supports the native system.'

  spec ' ' '[file:open]' 'open file _' 'str'
  spec ' ' '[file:close]' 'close file _' 'str'
  spec ' ' '[file:delete]' 'delete file _' 'str'
  space
  spec ' ' '[file:appendLine]' 'append line _ to file _' 'str str'
  spec ' ' '[file:appendBytes]' 'append bytes _ to file _' 'str str'
  space
  spec 'r' '[file:endOfFile]' 'end of file _' 'str'
  spec 'r' '[file:readLine]' 'next line of file _' 'str'
  spec 'r' '[file:readBytes]' 'next _ bytes of file _ : starting at _' 'num str num' 100 '' 0
  spec 'r' '[file:readInto]' 'read into _ from file _' 'str str' 'a ByteArray' ''
  space
  spec 'r' '[file:readPosition]' 'read position of file _' 'str'
  spec ' ' '[file:setReadPosition]' 'set read position _ of file _' 'num str' 0 ''
  spec ' ' 'file_SkipBytes' 'skip _ bytes of file _' 'num str' 4 ''
  space
  spec 'r' 'file names' 'file names : in directory _' 'str'
  spec 'r' '[file:fileSize]' 'size of file _' 'str'
  spec 'r' '[file:systemInfo]' 'file system info'

to 'file names' dir {
  '[file:startList]' dir
  local 'result' ('[data:makeList]')
  local 'fileName' ('[file:nextInList]')
  repeatUntil (fileName == '') {
    '[data:addLast]' fileName result
    fileName = ('[file:nextInList]')
  }
  return result
}

to file_SkipBytes offset file {
  local 'newPosition' (('[file:readPosition]' file) + offset)
  '[file:setReadPosition]' newPosition file
}


module 'HTTP server' Comm
author MicroBlocks
version 1 3 
depends WiFi 
tags http network 
description 'Create an HTTP server in MicroBlocks. You can use this library to allow remote control for your Wifi-enabled board.'

  spec 'r' '[net:httpServerGetRequest]' 'HTTP server request : binary data _ : port _' 'bool num' false 8080
  spec 'r' 'request method' 'method of request _' 'str' ''
  spec 'r' 'path of request' 'path of request _' 'str' ''
  spec 'r' 'headers of request' 'headers of request _' 'str' ''
  spec 'r' 'body of request' 'body of request _' 'str' ''
  spec 'r' 'content length of request' 'content length of request _' 'str' ''
  spec ' ' '[net:respondToHttpRequest]' 'respond _ to HTTP server request : with body _ : and headers _' 'str str str' '200 OK' 'Welcome to the MicroBlocks HTTP server' 'Content-Type: text/plain'
  spec 'r' '_endOfHeaders' '_end of headers _' 'str'
  spec 'r' '_toString' '_toString _' 'auto' 'abc'

to '_endOfHeaders' request {
  return ('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) request)
}

to '_toString' aStringOrByteArray {
  comment 'If argument is a byte array, convert it to a string. '
  if (not (isType aStringOrByteArray 'string')) {
    aStringOrByteArray = ('[data:join]' '' aStringOrByteArray)
  }
  return aStringOrByteArray
}

to 'body of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('[data:copyFromTo]' request (i + 4))
}

to 'content length of request' request {
  local 'i' ('_endOfHeaders' request)
  if (i < 0) {
    return 0
  }
  local 'j' ('[data:find]' 'Content-Length: ' request)
  if (j < 0) {
    comment 'Try alternate capitalization'
    j = ('[data:find]' 'Content-length: ' request)
  }
  if (or (j < 0) (j > i)) {
    return 0
  }
  j += 16
  local 'k' ('[data:find]' ('[data:unicodeString]' 13) request j)
  return (('[data:copyFromTo]' request j (k - 1)) + 0)
}

to 'headers of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('_toString' ('[data:copyFromTo]' request 1 (i - 1)))
}

to 'path of request' request {
  return ('_toString' ('[data:copyFromTo]' request (('[data:find]' ' ' request) + 1) (('[data:find]' ' HTTP' request) - 1)))
}

to 'request method' request {
  return ('_toString' ('[data:copyFromTo]' request 1 (('[data:find]' ' ' request) - 1)))
}


module 'JSON Primitives' Data
author MicroBlocks
version 1 0 
tags data json network 
description 'Very fast and efficient primitives to parse JSON strings.'

  spec 'r' '[misc:jsonGet]' 'json _ . _' 'str str' '{ "x": 1,  "y": [41, 42, 43] }' 'y.2'
  spec 'r' '[misc:jsonCount]' 'json count _ . _' 'str str' '[1, [4, 5, 6, 7], 3]' ''
  spec 'r' '[misc:jsonValueAt]' 'json value _ . _ at _' 'str str num' '{ "x": 1,  "y": 42 }' '' 2
  spec 'r' '[misc:jsonKeyAt]' 'json key _ . _ at _' 'str str num' '{ "x": 1,  "y": 42 }' '' 2

module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}


module TFT Output
author MicroBlocks
version 1 5 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  space
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}


module 'WebSocket server' Comm
author MicroBlocks
version 1 1 
tags websockets network 
description 'Blocks to build your own (very) simple websockets server.'

  spec ' ' 'start WebSocket server' 'start WebSocket server'
  spec 'r' '[net:webSocketLastEvent]' 'last WebSocket event'
  spec 'r' 'ws client id' 'client ID for WebSocket event _' 'str' ''
  spec 'r' 'ws event payload' 'payload for WebSocket event _' 'str' ''
  spec 'r' 'ws event type' 'type of WebSocket event _' 'str' ''
  spec ' ' '[net:webSocketSendToClient]' 'send _ to WebSocket client _' 'str num' 'Hello, Client!' 0

to 'start WebSocket server' {
  if ((getIPAddress) != '0.0.0.0') {
    '[net:webSocketStart]'
  } else {
    sayIt 'Not Connected'
  }
}

to 'ws client id' event {
  if (and (isType event 'list') ((size event) > 1)) {
    return (at 2 event)
  } else {
    return ''
  }
}

to 'ws event payload' event {
  if (and (isType event 'list') ((size event) > 2)) {
    return (at 3 event)
  } else {
    return ''
  }
}

to 'ws event type' event {
  if (and (isType event 'list') ((size event) > 0)) {
    return (at ((at 1 event) + 1) ('[data:makeList]' 'error' 'disconnected' 'connected' 'text message' 'binary message' 'text fragment start' 'binary fragment start' 'fragment' 'fragment end' 'ping' 'pong' 'waiting'))
  } else {
    return ''
  }
}


module WiFi Comm
author MicroBlocks
version 1 6 
tags communication network 
description 'Connect to a WiFi network. Used in conjunction with other network libraries, such as HTTP client, HTTP server or Web Thing.
'

  spec ' ' 'wifiConnect' 'wifi connect to _ password _ : IP _ gateway _ subnet _' 'str str auto auto auto' 'Network_Name' '' '192.168.1.42' '192.168.1.1' '255.255.255.0'
  spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
  spec 'r' 'getIPAddress' 'IP address'
  spec 'r' '[net:myMAC]' 'MAC address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to wifiConnect ssid password fixedIP gatewayIP subnetIP {
  if (not ('[net:hasWiFi]')) {return}
  '[net:stopWiFi]'
  if ((pushArgCount) < 5) {
    '[net:startWiFi]' ssid password
  } else {
    '[net:startWiFi]' ssid password false fixedIP gatewayIP subnetIP
  }
  local 'startMSecs' (millisOp)
  repeatUntil (('[net:myIPAddress]') != '0.0.0.0') {
    comment 'Timeout after N seconds'
    if (((millisOp) - startMSecs) > 30000) {
      sayIt 'Could not connect'
      return 0
    }
    comment 'Slow blink while trying to connect'
    setUserLED true
    waitMillis 300
    setUserLED false
    waitMillis 300
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  if ('Connected' != ('[net:wifiStatus]')) {
    sayIt 'Could not create hotspot'
    return 0
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

module main
author MicroBlocks
version 1 0 
description ''
variables responses 

script 50 50 {
whenStarted
comment 'This server responds to any request with a JSON object
containing the tilt x, y, and z values.'
comment 'Remember to use your network name (SSID) and password below'
wifiConnect 'Network_Name' ''
forever {
  repeatUntil (('[net:httpServerGetRequest]') != '') {
    waitMillis 10
  }
  '[net:respondToHttpRequest]' '200 OK' ('[data:join]' '{"x": ' ('[sensors:tiltX]') ', "y": ' ('[sensors:tiltY]') ', "z": ' ('[sensors:tiltZ]') '}')
}
}


module 'Basic Sensors' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor 
choices accelerometerRange '1' '2' '4' '8' 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[sensors:acceleration]' 'acceleration'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (Â°C)'
  spec ' ' '_setAccelRange' 'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to '_setAccelRange' n {
  '[sensors:setAccelerometerRange]' (0 + n)
}


module 'HTTP server' Comm
author MicroBlocks
version 1 3 
depends WiFi 
tags http network 
description 'Create an HTTP server in MicroBlocks. You can use this library to allow remote control for your Wifi-enabled board.'

  spec 'r' '[net:httpServerGetRequest]' 'HTTP server request : binary data _' 'bool' false
  spec 'r' 'request method' 'method of request _' 'str' ''
  spec 'r' 'path of request' 'path of request _' 'str' ''
  spec 'r' 'headers of request' 'headers of request _' 'str' ''
  spec 'r' 'body of request' 'body of request _' 'str' ''
  spec 'r' 'content length of request' 'content length of request _' 'str' ''
  spec ' ' '[net:respondToHttpRequest]' 'respond _ to HTTP request : with body _ : and headers _ : keepAlive _' 'str str str bool' '200 OK' 'Welcome to the MicroBlocks HTTP server' 'Content-Type: text/plain' false
  spec 'r' '_endOfHeaders' '_end of headers _' 'str'
  spec 'r' '_toString' '_toString _' 'auto' 'abc'

to '_endOfHeaders' request {
  return ('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) request)
}

to '_toString' aStringOrByteArray {
  comment 'If argument is a byte array, convert it to a string. '
  if (not (isType aStringOrByteArray 'string')) {
    aStringOrByteArray = ('[data:join]' '' aStringOrByteArray)
  }
  return aStringOrByteArray
}

to 'body of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('[data:copyFromTo]' request (i + 4))
}

to 'content length of request' request {
  local 'i' ('_endOfHeaders' request)
  if (i < 0) {
    return 0
  }
  local 'j' ('[data:find]' 'Content-Length: ' request)
  if (j < 0) {
    comment 'Try alternate capitalization'
    j = ('[data:find]' 'Content-length: ' request)
  }
  if (or (j < 0) (j > i)) {
    return 0
  }
  j += 16
  local 'k' ('[data:find]' ('[data:unicodeString]' 13) request j)
  return (('[data:copyFromTo]' request j (k - 1)) + 0)
}

to 'headers of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('_toString' ('[data:copyFromTo]' request 1 (i - 1)))
}

to 'path of request' request {
  return ('_toString' ('[data:copyFromTo]' request (('[data:find]' ' ' request) + 1) (('[data:find]' ' HTTP' request) - 1)))
}

to 'request method' request {
  return ('_toString' ('[data:copyFromTo]' request 1 (('[data:find]' ' ' request) - 1)))
}


module WiFi Comm
author MicroBlocks
version 1 6 
tags communication network 
description 'Connect to a WiFi network. Used in conjunction with other network libraries, such as HTTP client, HTTP server or Web Thing.
'

  spec ' ' 'wifiConnect' 'wifi connect to _ password _ : IP _ gateway _ subnet _' 'str str auto auto auto' 'Network_Name' '' '192.168.1.42' '192.168.1.1' '255.255.255.0'
  spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
  spec 'r' 'getIPAddress' 'IP address'
  spec 'r' '[net:myMAC]' 'MAC address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to wifiConnect ssid password fixedIP gatewayIP subnetIP {
  if (not ('[net:hasWiFi]')) {return}
  '[net:stopWiFi]'
  if ((pushArgCount) < 5) {
    '[net:startWiFi]' ssid password
  } else {
    '[net:startWiFi]' ssid password false fixedIP gatewayIP subnetIP
  }
  local 'startMSecs' (millisOp)
  repeatUntil (('[net:myIPAddress]') != '0.0.0.0') {
    comment 'Timeout after N seconds'
    if (((millisOp) - startMSecs) > 30000) {
      sayIt 'Could not connect'
      return 0
    }
    comment 'Slow blink while trying to connect'
    setUserLED true
    waitMillis 300
    setUserLED false
    waitMillis 300
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  if ('Connected' != ('[net:wifiStatus]')) {
    sayIt 'Could not create hotspot'
    return 0
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

module main
author wwj718
version 2 0 
description ''
variables running 

script 50 50 {
whenButtonPressed 'A'
running = (booleanConstant true)
}

script 242 50 {
whenButtonPressed 'B'
running = (booleanConstant false)
cutebot_stopWheels
}

script 50 137 {
whenStarted
running = (booleanConstant false)
forever {
  if running {
    if (cutebot_seesLine false true) {cutebot_setWheelSpeed 40 15}
    if (cutebot_seesLine true false) {cutebot_setWheelSpeed 15 40}
    if (cutebot_seesLine true true) {cutebot_setWheelSpeed 40 40}
  } else {
    cutebot_stopWheels
  }
}
}


module Cutebot Output
author wwj718
version 1 6 
depends 'Distance (HC-SR04)' NeoPixel 
choices cutebot_side left right 
choices cutebot_light left right both 
description 'Cutebot is a rear-drive smart car driven by dual high speed motors.

It features two RGB headlights, left and right line-following sensors, an ultrasonic distance sensor, and two downward-facing NeoPixels.

Add the IR Remote library to use the IR receiver (pin 16).

The Cutebot can work with the AILens library.

https://www.elecfreaks.com/learn-en/microbitKit/smart_cutebot/cutebot_car.html'

  spec ' ' 'cutebot_setWheelSpeed' 'Cutebot set wheel left _ right _ (-100 to 100)' 'num num' 100 -100
  spec ' ' 'cutebot_stopWheels' 'Cutebot stop wheels'
  space
  spec ' ' 'cutebot_setServo' 'Cutebot set servo _ to _ degrees (-90 to 90)' 'menu.range:1-2 num' 1 90
  spec ' ' 'cutebot_setServoSpeed' 'Cutebot set servo _ to speed _ (-100 to 100)' 'menu.range:1-2 num' 1 100
  space
  spec ' ' 'cutebot_setHeadlightColor' 'Cutebot set headlight _ to _' 'menu.cutebot_light color' 'both'
  spec ' ' 'cutebot_setNeopixels' 'Cutebot set NeoPixel _ to _' 'menu.cutebot_light color' 'both'
  space
  spec 'r' 'cutebot_lineSensor' 'Cutebot _ line sensor' 'menu.cutebot_side' 'left'
  spec 'r' 'cutebot_seesLine' 'Cutebot sees line on left _ right _' 'bool bool' true true
  spec 'r' 'cutebot_distance' 'Cutebot distance (cm)'
  space
  spec ' ' '_cutebot_sendCmd' '_cutebot_sendCmd _' 'str' 'aList'

to '_cutebot_sendCmd' aList {
  local 'cutebotAddr' 16
  '[sensors:i2cSetClockSpeed]' 100000
  '[sensors:i2cWrite]' cutebotAddr aList
  '[sensors:i2cSetClockSpeed]' 400000
}

to cutebot_distance {
  local 'trigger_pin' 8
  local 'echo_pin' 12
  return ('distance (cm)' trigger_pin echo_pin)
}

to cutebot_lineSensor side {
  comment 'Return true if a black line is detected on the given side.'
  local 'left_pin' 13
  local 'right_pin' 14
  if (side == 'left') {
    return (not (digitalReadOp left_pin))
  } else {
    return (not (digitalReadOp right_pin))
  }
}

to cutebot_seesLine leftSide rightSide {
  return (and (leftSide == (cutebot_lineSensor 'left')) (rightSide == (cutebot_lineSensor 'right')))
}

to cutebot_setHeadlightColor which color {
  local 'r' ((color >> 16) & 255)
  local 'g' ((color >> 8) & 255)
  local 'b' ((color >> b) & 255)
  local 'left_LED' 4
  local 'right_LED' 8
  if (which == 'left') {
    '_cutebot_sendCmd' ('[data:makeList]' left_LED r g b)
  } (which == 'right') {
    '_cutebot_sendCmd' ('[data:makeList]' right_LED r g b)
  } else {
    '_cutebot_sendCmd' ('[data:makeList]' left_LED r g b)
    '_cutebot_sendCmd' ('[data:makeList]' right_LED r g b)
  }
}

to cutebot_setNeopixels which_NeoPixel color {
  if (0 == _np_pixels) {neoPixelAttach 2 15}
  if (which_NeoPixel == 'left') {
    atPut 1 _np_pixels color
  } (which_NeoPixel == 'right') {
    atPut 2 _np_pixels color
  } else {
    atPut 1 _np_pixels color
    atPut 2 _np_pixels color
  }
  '_NeoPixel_update'
}

to cutebot_setServo servo value {
  comment 'servo (number) is one of: 1 2
value range of -90 to 90 maps to the full range of the servo'
  servo = (maximum 1 (minimum servo 2))
  value = (maximum -90 (minimum value 90))
  '_cutebot_sendCmd' ('[data:makeList]' (servo + 4) ('[misc:rescale]' value 90 -90 0 180) 0 0)
}

to cutebot_setServoSpeed servo value {
  comment 'servo (number) is one of: 1 2
value range of -100 to 100 maps to the full range of the servo'
  servo = (maximum 1 (minimum servo 2))
  value = (maximum -100 (minimum value 100))
  '_cutebot_sendCmd' ('[data:makeList]' (servo + 4) ('[misc:rescale]' value 100 -100 0 180) 0 0)
}

to cutebot_setWheelSpeed left_wheel_speed right_wheel_speed {
  comment 'speed (number): -100-100
direction: 1 = backward, 2 = forward'
  local 'left_direction' 2
  local 'right_direction' 2
  if (left_wheel_speed < 0) {
    left_direction = 1
    left_wheel_speed = (0 - left_wheel_speed)
  }
  if (right_wheel_speed < 0) {
    right_direction = 1
    right_wheel_speed = (0 - right_wheel_speed)
  }
  left_wheel_speed = (minimum left_wheel_speed 100)
  right_wheel_speed = (minimum right_wheel_speed 100)
  '_cutebot_sendCmd' ('[data:makeList]' 1 left_direction left_wheel_speed 0)
  '_cutebot_sendCmd' ('[data:makeList]' 2 right_direction right_wheel_speed 0)
}

to cutebot_stopWheels {
  cutebot_setWheelSpeed 0 0
}


module 'Distance (HC-SR04)' Input
author 'Joan GuillÃ©n & Josep FerrÃ ndiz'
version 1 2 
tags sensor 'hc-sr04' distance ultrasound 
description 'Support for the HC-SR04 ultrasound distance sensor.'
variables _sr04_last 

  spec 'r' 'distance (cm)' 'distance (cm) trigger _ echo _' 'num num' 2 4
  spec 'r' 'sr04_distanceOnePin' 'distance (cm) pin _' 'num' 0

to 'distance (cm)' trig ech {
  comment 'Contributed by Joan GuillÃ©n and Josep FerrÃ ndiz'
  digitalWriteOp trig false
  waitMicros 2
  digitalWriteOp trig true
  waitMicros 50
  digitalWriteOp trig false
  local 'start' (microsOp)
  waitUntil (or (not (digitalReadOp ech)) (((microsOp) - start) > 23320))
  waitUntil (or (digitalReadOp ech) (((microsOp) - start) > 23320))
  if (((microsOp) - start) > 23320) {
    comment 'Distance sensor not ready; return the last distance reading'
    return _sr04_last
  }
  comment 'Pulse sent. Measure time until echo is detected.'
  start = (microsOp)
  waitUntil (or (not (digitalReadOp ech)) (((microsOp) - start) > 23320))
  _sr04_last = ((10 * ((microsOp) - start)) / 583)
  comment 'Leave some time for reverberations to die away.'
  waitMillis 10
  if (_sr04_last == 0) {
    zeroCount += 1
  }
  return _sr04_last
}

to sr04_distanceOnePin pin {
  return ('distance (cm)' pin pin)
}


module NeoPixel Output
author MicroBlocks
version 1 6 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if ((boardType) == 'M5Atom-Matrix') {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'Mbits') {
    neoPixelAttach 25 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'r' ((rgb >> 16) & 255)
    local 'g' ((rgb >> 8) & 255)
    local 'b' (rgb & 255)
    local 'brightness' (maximum r g b)
    if (delta > 0) {
      delta = (minimum delta (255 - brightness))
    } else {
      delta = (maximum delta (42 - brightness))
    }
    r = (maximum 0 (minimum (r + delta) 255))
    g = (maximum 0 (minimum (g + delta) 255))
    b = (maximum 0 (minimum (b + delta) 255))
    atPut i _np_pixels (colorFromRGB r g b)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_update' {
  '[display:neoPixelSend]' _np_pixels
  waitMicros 100
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  hasWhite = false
  if ((pushArgCount) > 2) {
    hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  fillList _np_pixels 0
  '[display:neoPixelSetPin]' pinNumber hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels color
  '_NeoPixel_update'
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' (n > 0)
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}

module main
author unknown
version 1 0 
description ''

script 388 50 {
comment 'NOTE: Requires an ESP-based board with a built-in
accelerometer, like the M5Stick, the M5Stack Core Grey
(not the M5Stack Core Basic) or the Citilab ED1.

1) Unplug your board
2) Press the on-board button, launch the board into the air,
and catch it.
3) Plug the board back into your computer.
4) Open the graph window (graph icon in the top bar).
5) Click on the "graph" script to plot the change in
acceleration throughout the launch.'
}

script 50 112 {
whenButtonPressed 'A'
'[file:delete]' 'launch data'
'[file:open]' 'launch data'
repeat 1000 {
  '[file:appendLine]' ('[sensors:acceleration]') 'launch data'
}
'[file:close]' 'launch data'
}

script 408 324 {
comment 'graph script'
'[file:open]' 'launch data'
repeat 1000 {
  printIt ('[file:readLine]' 'launch data')
}
'[file:close]' 'launch data'
}


module 'Basic Sensors' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor 
choices accelerometerRange '1' '2' '4' '8' 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[sensors:acceleration]' 'acceleration'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (Â°C)'
  spec ' ' '_setAccelRange' 'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to '_setAccelRange' n {
  '[sensors:setAccelerometerRange]' (0 + n)
}


module Files Data
author MicroBlocks
version 1 3 
description 'Flash file system operations. Currently supports the LittleFS file system on ESP8266 and ESP32 boards. The GnuBlocks virtual machine (Linux and Raspberry Pi) supports the native system.'

  spec ' ' '[file:open]' 'open file _' 'str'
  spec ' ' '[file:close]' 'close file _' 'str'
  spec ' ' '[file:delete]' 'delete file _' 'str'
  space
  spec ' ' '[file:appendLine]' 'append line _ to file _' 'str str'
  spec ' ' '[file:appendBytes]' 'append bytes _ to file _' 'str str'
  space
  spec 'r' '[file:endOfFile]' 'end of file _' 'str'
  spec 'r' '[file:readLine]' 'next line of file _' 'str'
  spec 'r' '[file:readBytes]' 'next _ bytes of file _ : starting at _' 'num str num' 100 '' 0
  spec 'r' '[file:readInto]' 'read into _ from file _' 'str str' 'a ByteArray' ''
  space
  spec 'r' '[file:readPosition]' 'read position of file _' 'str'
  spec ' ' '[file:setReadPosition]' 'set read position _ of file _' 'num str' 0 ''
  spec ' ' 'file_SkipBytes' 'skip _ bytes of file _' 'num str' 4 ''
  space
  spec 'r' 'file names' 'file names : in directory _' 'str'
  spec 'r' '[file:fileSize]' 'size of file _' 'str'
  spec 'r' '[file:systemInfo]' 'file system info'

to 'file names' dir {
  '[file:startList]' dir
  local 'result' ('[data:makeList]')
  local 'fileName' ('[file:nextInList]')
  repeatUntil (fileName == '') {
    '[data:addLast]' fileName result
    fileName = ('[file:nextInList]')
  }
  return result
}

to file_SkipBytes offset file {
  local 'newPosition' (('[file:readPosition]' file) + offset)
  '[file:setReadPosition]' newPosition file
}

module main
author MicroBlocks
version 1 0 
description 'Bridge between MicroBlocks and Snap! using broadcast messages over USB-serial/WebSerial.
Streams pin and sensor data to Snap! Allows digital pins to be set.
Includes support for MakerBit and HyperDuino motor control.'
variables isMakerBit pinOutputValues 

  spec ' ' 'snapConnect_processCommands' 'Read & Execute Snap! Commands'
  spec ' ' 'snapConnect_sendPinState' 'Send Touch & Pin State'
  spec 'r' 'snapConnect_digitalPins' 'Digital Pin State from pin _ through pin _' 'auto auto' 2 13
  spec ' ' 'snapConnect_setDigitalPin' 'Set Digital Pin _ to _' 'auto bool' 2 true
  spec ' ' 'snapConnect_setMotorHyperduino' 'Set Motor _ Power _ (HyperDuino)' 'auto auto' 'A' 100
  spec ' ' 'snapConnect_setMotorMakerbit' 'Set Motor _ label _ (MakerBit)' 'auto auto' 'A' 100
  spec ' ' 'Send Sensors' 'Send Sensors'
  spec 'r' 'is microbit?' 'is microbit?'

to 'Send Sensors' {
  local 'msg' (newList 7)
  atPut 1 msg 'sensors'
  atPut 2 msg ('[sensors:tiltX]')
  atPut 3 msg ('[sensors:tiltY]')
  atPut 4 msg ('[sensors:tiltZ]')
  atPut 5 msg ('[display:lightLevel]')
  atPut 6 msg ('[sensors:temperature]')
  atPut 7 msg ('[sensors:magneticField]')
  sendBroadcast ('[data:joinStrings]' msg ',')
}

to 'is microbit?' {
  return (('[data:find]' 'micro:bit' (boardType)) == 1)
}

to snapConnect_digitalPins firstPin lastPin {
  comment 'Return an integer encoding the state of the digital pins from
firstPin through lastPin. The result encodes the pin values
as bits, where the pin number determines the bit offset.'
  comment 'Least signifcant bit is always pin zero, regardless of firstPin.'
  if (pinOutputValues == 0) {
    pinOutputValues = (newList 32 '')
  }
  local 'pinState' 0
  for i ((lastPin - firstPin) + 1) {
    local 'pin' ((firstPin + i) - 1)
    local 'output' (at (pin + 1) pinOutputValues)
    if (isType output 'boolean') {
      comment 'Pin is an output; set bit if current output is true'
      if output {
        pinState = (pinState | (1 << pin))
      }
    } else {
      comment 'Pin is an input; set bit if pin voltage is "high"'
      if (digitalReadOp pin) {
        pinState = (pinState | (1 << pin))
      }
    }
  }
  return pinState
}

to snapConnect_processCommands {
  local 'msg parts' ('[data:split]' (getLastBroadcast) ',')
  local 'cmd' (at 1 (v 'msg parts'))
  if (cmd == 'Set Digital Pin') {
    local 'pin' ((at 2 (v 'msg parts')) + 0)
    local 'value' ((at 3 (v 'msg parts')) == 'true')
    snapConnect_setDigitalPin pin value
  } (cmd == 'Enable Display') {
    '[display:mbEnableDisplay]' ((at 2 (v 'msg parts')) == 'true')
  } (cmd == 'Set Motor') {
    if ('is microbit?') {
      snapConnect_setMotorMakerbit (at 2 (v 'msg parts')) (at 3 (v 'msg parts'))
    } else {
      snapConnect_setMotorHyperduino (at 2 (v 'msg parts')) (at 3 (v 'msg parts'))
    }
  }
}

to snapConnect_sendPinState {
  local 'msg' (newList 9)
  atPut 1 msg 'pins'
  comment 'Add digital pin state'
  if ('is microbit?') {
    atPut 2 msg (snapConnect_digitalPins 0 16)
  } else {
    atPut 2 msg (snapConnect_digitalPins 0 13)
  }
  comment 'Update and add touch state'
  if (not _touch_initialized) {
    '_touch_init'
  }
  '_touch_update'
  atPut 3 msg _touch_state
  comment 'Add analog pin values'
  for i 6 {
    atPut (i + 3) msg (analogReadOp (i - 1))
  }
  sendBroadcast ('[data:joinStrings]' msg ',')
}

to snapConnect_setDigitalPin pin value {
  if (pinOutputValues == 0) {pinOutputValues = (newList 32 '')}
  digitalWriteOp pin value
  atPut (pin + 1) pinOutputValues value
}

to snapConnect_setMotorHyperduino motor power {
  comment 'Set motor (A or B) power (-100 to 100). The sign
of the power value determines motor direction.'
  comment 'HyperDuino pins: Motor A 3, 4, 5; Motor B 7, 8, 6'
  if (motor == 'A') {
    local 'p1' 3
    local 'p2' 4
    local 'pwrPin' 5
  } (motor == 'B') {
    local 'p1' 7
    local 'p2' 8
    local 'pwrPin' 6
  } else {
    return 0
  }
  comment 'Set the motor direction based on sign of power'
  if (power > 0) {
    snapConnect_setDigitalPin p1 false
    snapConnect_setDigitalPin p2 true
  } (power < 0) {
    snapConnect_setDigitalPin p1 true
    snapConnect_setDigitalPin p2 false
  } else {
    snapConnect_setDigitalPin p1 false
    snapConnect_setDigitalPin p2 false
  }
  comment 'Set the PWM duty cycle on the power pin'
  atPut (pwrPin + 1) pinOutputValues (power != 0)
  analogWriteOp pwrPin (minimum (((absoluteValue power) * 1023) / 100) 1023)
}

to snapConnect_setMotorMakerbit motor power {
  comment 'Set motor (A or B) power (-100 to 100). The sign
of the power value determines motor direction.'
  comment 'MakerBit pins: Motor A 11, 12, 13; Motor B 15, 16, 14'
  if (motor == 'A') {
    local 'p1' 11
    local 'p2' 12
    local 'pwrPin' 13
  } (motor == 'B') {
    local 'p1' 15
    local 'p2' 16
    local 'pwrPin' 14
  } else {
    return 0
  }
  comment 'Set the motor direction based on sign of power'
  if (power > 0) {
    snapConnect_setDigitalPin p1 false
    snapConnect_setDigitalPin p2 true
  } (power < 0) {
    snapConnect_setDigitalPin p1 true
    snapConnect_setDigitalPin p2 false
  } else {
    snapConnect_setDigitalPin p1 false
    snapConnect_setDigitalPin p2 false
  }
  comment 'Set the PWM duty cycle on the power pin'
  atPut (pwrPin + 1) pinOutputValues (power != 0)
  analogWriteOp pwrPin (minimum (((absoluteValue power) * 1023) / 100) 1023)
}

script 353 50 {
comment 'Click to test!'
sendBroadcast 'Set Digital Pin,2,false'
}

script 50 52 {
comment 'Click to test!'
sendBroadcast 'Set Digital Pin,2,true'
}

script 50 129 {
comment 'Click to test!'
sendBroadcast 'Set Motor,A,100'
}

script 358 129 {
comment 'Click to test!'
sendBroadcast 'Set Motor,A,0'
}

script 365 213 {
whenBroadcastReceived ''
comment 'Handle commands with arguments
(e.g. motor and pin control)'
snapConnect_processCommands
}

script 50 221 {
whenStarted
comment 'Send pin and sensor state'
forever {
  snapConnect_sendPinState
  if ('is microbit?') {
    'Send Sensors'
  }
  waitMillis 16
}
}

script 371 348 {
whenBroadcastReceived 'Get Info'
sendBroadcast ('[data:join]' 'info,SnapBridge 1.0 ' (boardType))
}

script 50 426 {
to snapConnect_sendPinState {}
}


module 'Basic Sensors' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor 
choices accelerometerRange '1' '2' '4' '8' 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[sensors:acceleration]' 'acceleration'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (Â°C)'
  spec 'r' '[sensors:magneticField]' 'magnetic field'
  spec ' ' '_setAccelRange' 'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to '_setAccelRange' n {
  '[sensors:setAccelerometerRange]' (0 + n)
}


module Touch Input
author MicroBlocks
version 1 8 
description 'Support for the MPR121 12-channel i2c touch sensor.'
variables _touch_state _touch_isTouched _touch_eventPending _touch_last_touched_pin _touch_last_released_pin 

  spec 'r' 'touch_isTouched' 'is pin _ touched?' 'menu.range:1-12' 1
  space
  spec 'r' 'touch_touch_event' 'pin touch event'
  spec 'r' 'touch_last_touched_pin' 'last touched pin'
  space
  spec 'r' 'touch_release_event' 'pin release event'
  spec 'r' 'touch_last_released_pin' 'last released pin'
  space
  spec 'r' 'touch_state_string' 'touch state string'
  space
  spec ' ' '_touch_init' '_touch_init'
  spec ' ' '_touch_update' '_touch_update'
  spec ' ' '_touch_setRegister' '_touch_setRegister _ to _' 'auto auto' 'hex register' 'hex value'

to '_touch_init' {
  if (isType _touch_isTouched 'list') {
    comment 'Already initialized.'
    return 0
  }
  _touch_isTouched = (newList 12 (booleanConstant false))
  _touch_eventPending = (newList 12 (booleanConstant false))
  _touch_last_touched_pin = -1
  _touch_last_released_pin = -1
  comment 'Soft reset -- sets all registers to defaults'
  '_touch_setRegister' '0x80' '0x63'
  comment 'Set filter parameters'
  '_touch_setRegister' '0x2B' '0x01'
  '_touch_setRegister' '0x2C' '0x01'
  '_touch_setRegister' '0x2D' '0x10'
  '_touch_setRegister' '0x2E' '0x20'
  '_touch_setRegister' '0x2F' '0x01'
  '_touch_setRegister' '0x30' '0x01'
  '_touch_setRegister' '0x31' '0x10'
  '_touch_setRegister' '0x32' '0x20'
  '_touch_setRegister' '0x33' '0x01'
  '_touch_setRegister' '0x34' '0x10'
  '_touch_setRegister' '0x35' '0xFF'
  comment 'Init debounce and config registers'
  '_touch_setRegister' '0x5B' '0x11'
  '_touch_setRegister' '0x5C' '0xFF'
  '_touch_setRegister' '0x5D' '0x30'
  comment 'Set touch/release thresholds'
  local 'touchThreshold' 40
  local 'releaseThreshold' 20
  for i 12 {
    local 'reg' ((hexToInt '40') + (2 * i))
    '_touch_setRegister' (reg - 1) touchThreshold
    '_touch_setRegister' reg releaseThreshold
  }
  comment 'Start tracking all 12 inputs (proximity detection disabled)'
  '_touch_setRegister' '0x5E' '0xCC'
}

to '_touch_setRegister' reg value {
  if (isType reg 'string') {reg = (hexToInt reg)}
  if (isType value 'string') {value = (hexToInt value)}
  i2cSet 90 reg value
}

to '_touch_update' {
  '_touch_init'
  _touch_state = (((i2cGet 90 1) << 8) | (i2cGet 90 0))
  if (_touch_state < 0) {
    comment 'i2c read operation failed'
    _touch_state = 0
  }
  for i 12 {
    local 'isTouchedNow' ((_touch_state & (1 << (i - 1))) != 0)
    if ((at i _touch_isTouched) != isTouchedNow) {
      atPut i _touch_isTouched isTouchedNow
      atPut i _touch_eventPending (booleanConstant true)
    }
  }
  comment 'Leave some time between updates'
  waitMillis 30
}

to touch_isTouched pin {
  if (or (pin < 1) (pin > 12)) {return (booleanConstant false)}
  '_touch_update'
  return ((_touch_state & (1 << (pin - 1))) != 0)
}

to touch_last_released_pin {
  comment 'Return the pin that triggered the last release event.'
  '_touch_init'
  return _touch_last_released_pin
}

to touch_last_touched_pin {
  comment 'Return the pin that triggered the last touch event.'
  '_touch_init'
  return _touch_last_touched_pin
}

to touch_release_event {
  '_touch_update'
  for i 12 {
    if (and (at i _touch_eventPending) ((_touch_state & (1 << (i - 1))) == 0)) {
      atPut i _touch_eventPending (booleanConstant false)
      _touch_last_released_pin = i
      return (booleanConstant true)
    }
  }
  _touch_last_released_pin = -1
  return (booleanConstant false)
}

to touch_state_string {
  '_touch_update'
  local 'pin states' ('[data:makeList]')
  for i 12 {
    if ((_touch_state & (1 << (i - 1))) != 0) {
      '[data:addLast]' '1' (v 'pin states')
    } else {
      '[data:addLast]' '0' (v 'pin states')
    }
  }
  return ('[data:joinStrings]' (v 'pin states'))
}

to touch_touch_event {
  '_touch_update'
  for i 12 {
    if (and (at i _touch_eventPending) ((_touch_state & (1 << (i - 1))) != 0)) {
      atPut i _touch_eventPending (booleanConstant false)
      _touch_last_touched_pin = i
      return (booleanConstant true)
    }
  }
  _touch_last_touched_pin = -1
  return (booleanConstant false)
}

module main
author MicroBlocks
version 1 0 
description ''

script 65 54 {
whenStarted
comment 'Click start, then clap 1 to 9 times in a row.
The number of claps will be shown on the
micro:bit display!'
turnOnMicrophone
comment 'Adjust the threshold so it doesn''t count random
sounds as claps but it doesn''t miss soft claps.'
setClapThreshold 250
forever {
  displayCharacter ('[data:unicodeString]' (48 + (clapCount)))
  waitMillis 1000
  '[display:mbDisplayOff]'
}
}

script 65 367 {
comment 'Run this loop while talking (but not clapping) to
get an estimate of the minimum clap threshold'
turnOnMicrophone
sayIt (guessClapThreshold)
}

script 266 1242 {
waitMillis 5
}

script 266 1276 (guessClapThreshold)


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}


module Microphone Input
author MicroBlocks
version 1 3 
description 'Microphone, loudness, and clap counting support for boards with built in microphones. The microphone block usually reports values between -512 and 511, with zero for silence. However, very loud sounds may exceed that range on some boards. On the micro:bit v2, the microphone must be turned on before use.'
variables _clapThreshold _loudnessSamples 

  spec 'r' '[sensors:microphone]' 'microphone'
  spec ' ' 'turnOnMicrophone' 'turn on microphone'
  spec 'r' 'loudness' 'loudness'
  spec 'r' 'clapCount' 'clap count'
  spec ' ' 'setClapThreshold' 'set clap threshold _' 'auto' 200
  spec 'r' 'guessClapThreshold' 'estimate clap threshold'
  spec ' ' '_loudnessLoop' '_loudnessLoop'

to '_loudnessLoop' {
  comment 'Sample microphone at ~2000 samples/sec, keeping the most recent N samples.'
  turnOnMicrophone
  waitMillis 20
  forever {
    for i (size _loudnessSamples) {
      atPut i _loudnessSamples ('[sensors:microphone]')
      waitMicros 500
    }
  }
}

to clapCount {
  comment 'Count the number of claps in a sequence.'
  if (_clapThreshold == 0) {
    _clapThreshold = 150
  }
  waitUntil ((loudness) > _clapThreshold)
  local 'count' 1
  forever {
    waitUntil ((loudness) < ((3 * _clapThreshold) / 4))
    resetTimer
    repeatUntil ((loudness) > _clapThreshold) {
      comment 'This loop awaits either the next clap or for a pause, indicating that the claps have ended.'
      if ((timer) > 700) {
        comment 'No clap for a while, return the count.'
        return count
      }
    }
    count += 1
  }
}

to guessClapThreshold {
  comment 'Sample the loudness for three seconds and set
_clapThreshold to 130% of the maxium.'
  local 'maxLoudness' 0
  resetTimer
  repeatUntil ((timer) > 3000) {
    maxLoudness = (maximum maxLoudness (loudness))
  }
  return ((13 * maxLoudness) / 10)
}

to loudness {
  if (_loudnessSamples == 0) {
    comment 'Initialize _loudnessSamples and start sampling.'
    _loudnessSamples = (newList 50)
    sendBroadcast '_loudnessLoop'
  }
  local 'low' 10000
  local 'high' -10000
  for n _loudnessSamples {
    low = (minimum low n)
    high = (maximum high n)
  }
  return (high - low)
}

to setClapThreshold n {
  _clapThreshold = n
}

to turnOnMicrophone {
  if ('micro:bit v2' == (boardType)) {
    comment 'Turn on the microphone and
wait for it to settle down.'
    digitalWriteOp 28 true
    waitMillis 50
  }
}

module main
author MicroBlocks
version 1 0 
description ''

script 50 50 {
whenStarted
comment 'This demonstrates plucked string synthesis
on a micro:bit v2, Circuit Playground, CIrcuit
Playground Bluefruit, Clue, or M5 Stack. It
requires either a DAC or fast PWM hardware,
so it works on ESP32, nRF52, or SAMD21
processors. Sorry, it does not work on the
original micro:bit or Calliope mini.

It sounds best when played through an
amplified external speaker.'
setPluckPin ''
for i 37 {
  pluckMidiKey (40 + i) 300
}
}


module Pluck Output
author MicroBlocks
version 1 1 
depends Tone 
description 'Uses a simple algorithm to synthesize a plucked-string sound similar to an acoustic guitar (see https://en.wikipedia.org/wiki/KarplusâStrong_string_synthesis).

Note: This library does NOT work on the original micro:bit or Calliope mini!

To output the generated waveform, the board must have a DAC (e.g. SAMD21 and ESP32 boards) or fast enough pulse-width modulation (PWM) hardware to simulate a DAC (e.g. nRF52xxx boards). To tune the output to standard A=440 pitch on boards with different clock speeds, change the tuningConstant variable in _pitchToBufferLength.'
variables _pluckInitialized _pluckPin _pluckShift _pluckOffset 

  spec ' ' 'pluckNote' 'pluck note _ octave _ for _ ms' 'str num num' 'C' 0 3000
  spec ' ' 'pluckMidiKey' 'pluck MIDI key _ for _ msecs' 'num num' 60 3000
  spec ' ' 'setPluckPin' 'set pluck pin _' 'auto' ''
  spec ' ' '_initPluck' '_initPluck'
  spec ' ' '_playPluck' '_playPluck _ for _ msecs' 'num num' 80 3000
  spec 'r' '_pitchToBufferLength' '_pitchToBufferLength _' 'num' 440
  spec 'r' '_midiKeyToPitch' '_midiKeyToPitch _' 'num' 60

to '_initPluck' {
  _pluckShift = 0
  _pluckOffset = 512
  if ((boardType) == 'micro:bit v2') {
    _pluckPin = 27
  } ((boardType) == 'Clue') {
    _pluckPin = 21
  } (or ((boardType) == 'Citilab ED1') ((boardType) == 'M5StickC')) {
    _pluckShift = 3
    _pluckOffset = 128
    _pluckPin = 26
  } ((boardType) == 'M5Stack-Core') {
    _pluckShift = 3
    _pluckOffset = 128
    _pluckPin = 25
  } else {
    _pluckPin = 0
  }
  _pluckInitialized = true
}

to '_midiKeyToPitch' key {
  local 'freq' (at ((key % 12) + 1) ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  return (freq / 1000)
}

to '_pitchToBufferLength' pitch {
  comment 'Adjust the tuning constant so that pluck pitch is correct.
(Compare with a piano or other instrument.)'
  local 'tuningConstant' 21000
  return (maximum 3 (tuningConstant / pitch))
}

to '_playPluck' bufSize msecs {
  if (not _pluckInitialized) {'_initPluck'}
  local 'buf' (newList bufSize)
  for i (bufSize / 5) {
    atPut i buf (random -400 400)
  }
  local 'endTime' ((millisOp) + msecs)
  repeatUntil ((millisOp) > endTime) {
    for i (bufSize - 1) {
      local 'sample' (((at i buf) + (at (i + 1) buf)) / 2)
      atPut i buf sample
      sample = ((sample >> _pluckShift) + _pluckOffset)
      analogWriteOp _pluckPin sample
      waitMicros 20
    }
    atPut bufSize buf (at 1 buf)
  }
}

to pluckMidiKey key msecs {
  local 'pitch' ('_midiKeyToPitch' key)
  '_playPluck' ('_pitchToBufferLength' pitch) msecs
}

to pluckNote note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    comment 'Rest or unrecognized note'
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_playPluck' ('_pitchToBufferLength' (freq / 1000)) ms
}

to setPluckPin pin {
  if (pin == '') {
    _pluckInitialized = false
    return 0
  }
  _pluckPin = pin
  _pluckShift = 0
  _pluckOffset = 512
  _pluckInitialized = true
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author MicroBlocks
version 1 0 
description ''
variables 'part A' 'part B' 'part C' 

script 50 50 {
comment 'This project uses two micro:bit''s to play two-part harmony.
When the A button is pressed on one board, it starts
playing the tune and sends a radio message to the other
board to tell it to start playing the harmony.'
}

script 381 145 {
whenCondition ('[radio:messageReceived]')
if (('[radio:receivedString]') == 'start') {
  sendBroadcast 'bells'
  'play ringtone' 'Jingle Bells Harmony:d=4,o=5,b=240:
d,d,2d,d#,d#,2d#,e,e,d#.,8d#,2d,2s
 e4,g4,c,e,d,b4,g4,e4,d4,e4,g4,b4,a4,d,c#,c,
d,d,2d,d#,d#,2d#,e,e,d#.,8d#,2d,2s,
e4,g4,c,e,d,b4,g4,b4,d,d,e,f#,g,s,g4'
}
}

script 52 148 {
whenButtonPressed 'A'
'attach buzzer to pin' ''
'[radio:sendString]' 'start'
sendBroadcast 'bells'
'play ringtone' 'Jingle Bells:d=4,o=4,b=240:
b,b,2b,b,b,2b,b,d5,g.,8a,2b,2s,
c5,c5,c.5,8c5,c5,b,b.,8b,b,a,a.,8b,2a,2s,
 b,b,2b,b,b,2b,b,d5,g.,8a,2b,2s,
c5,c5,c.5,8c5,c5,b,b.,8b,d5,d5,c5,a,g,s,g2'
}

script 52 349 {
whenBroadcastReceived 'bells'
repeat 16 {
  '[display:mbDisplay]' 32979072
  waitMillis 240
  '[display:mbDisplay]' 4398304
  waitMillis 240
  '[display:mbDisplay]' 32979072
  waitMillis 240
  '[display:mbDisplay]' 4617088
  waitMillis 240
}
'[display:mbDisplay]' 32979072
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}


module Radio Comm
author MicroBlocks
version 1 2 
tags radio communication messaging network 
description 'Send and receive messages between micro:bit boards via their built-in radio system.'

  spec ' ' '[radio:sendInteger]' 'radio send number _' 'num' 123
  spec ' ' '[radio:sendString]' 'radio send string _' 'str' 'Hello!'
  spec ' ' '[radio:sendPair]' 'radio send pair _ = _' 'str num' 'light' 10
  spec 'r' '[radio:messageReceived]' 'radio message received?'
  spec 'r' '[radio:receivedInteger]' 'radio last number'
  spec 'r' '[radio:receivedString]' 'radio last string'
  spec ' ' '[radio:setGroup]' 'radio set group _ (0-255)' 'num' 0
  spec ' ' '[radio:setPower]' 'radio set power (0-7) _' 'num' 4
  spec 'r' '_signalStrength' '_radio last signal strength'
  spec 'r' '_radioLastSenderID' '_radio last sender ID'
  spec 'r' '_radioMyID' '_radio my ID'
  spec 'r' '_receivedMessageType' '_radio last message type'
  spec ' ' '_setChannel' '_radio set channel (0-83) _' 'num' 7

to '_radioLastSenderID' {
  return ('[radio:lastMessageID]')
}

to '_radioMyID' {
  return ('[radio:deviceID]')
}

to '_receivedMessageType' {
  return ('[radio:receivedMessageType]')
}

to '_setChannel' channel {
  '[radio:setChannel]' channel
}

to '_signalStrength' {
  return ('[radio:signalStrength]')
}


module Ringtone Output
author MicroBlocks
version 1 2 
depends Tone 
description 'Plays tunes in RTTTL (Ringtone Text Transfer Language) a language developed by Nokia to store ringtones.
Also known as Nokring.'
variables '_RTTTL default duration' '_RTTTL default octave' '_RTTTL bpm' '_RTTTL song name' 

  spec 'r' '_RTTTL parse control from' '_RTTTL parse control from _' 'str' ''
  spec ' ' 'play ringtone' 'play ringtone _' 'str' 'Pacman:d=16,o=6,b=140:
b5,b,f#,d#,8b,8d#,c,c7,g,f,8c7,8e,b5,b,f#,d#,8b,8d#,32d#,32e,f,32f,32f#,g,32g,32g#,a,8b'
  spec 'r' 'current song name' 'current song name'
  spec ' ' '_RTTTL play note' '_RTTTL play note _' 'str' '8c#'

to '_RTTTL parse control from' 'control section' {
  comment 'Extract control section'
  local 'd' 4
  local 'o' 6
  local 'b' 63
  repeatUntil ((size (v 'control section')) == 0) {
    local 'next separator' ('[data:find]' ',' (v 'control section'))
    if ((v 'next separator') == -1) {
      'next separator' = (size (v 'control section'))
    }
    local 'to process' ('[data:copyFromTo]' (v 'control section') 1 (v 'next separator'))
    'control section' = ('[data:copyFromTo]' (v 'control section') ((v 'next separator') + 1))
    'next separator' = ('[data:find]' ',' (v 'to process'))
    if ((v 'next separator') == -1) {
      'next separator' = ((size (v 'to process')) + 1)
    }
    if (('[data:find]' 'd' (v 'to process')) > 0) {
      d = ('[data:copyFromTo]' (v 'to process') (('[data:find]' '=' (v 'to process')) + 1) ((v 'next separator') - 1))
    } (('[data:find]' 'b' (v 'to process')) > 0) {
      b = ('[data:copyFromTo]' (v 'to process') (('[data:find]' '=' (v 'to process')) + 1) ((v 'next separator') - 1))
    } (('[data:find]' 'o' (v 'to process')) > 0) {
      o = ('[data:copyFromTo]' (v 'to process') (('[data:find]' '=' (v 'to process')) + 1) ((v 'next separator') - 1))
    }
  }
  return ('[data:makeList]' d o b)
}

to '_RTTTL play note' note {
  local 'duration' ''
  local 'note name' ''
  local 'octave' (v '_RTTTL default octave')
  local 'ms / whole note' (240000 / (v '_RTTTL bpm'))
  local 'isDotted' (('[data:find]' '.' note) > -1)
  note = ('_trimmedLowercase' note)
  if (note == '') {
    comment 'empty note string; skip'
    return 0
  }
  comment 'parse duration value, if there is one'
  repeatUntil (or (('[data:unicodeAt]' 1 note) < 48) (('[data:unicodeAt]' 1 note) > 57)) {
    duration = ('[data:join]' duration (at 1 note))
    note = ('[data:copyFromTo]' note 2)
  }
  if (duration == '') {
    duration = (v '_RTTTL default duration')
  }
  comment 'parse note name'
  if (or (('[data:find]' '#' note) > -1) (('[data:find]' '_' note) > -1)) {
    'note name' = ('[data:copyFromTo]' note 1 2)
  } else {
    'note name' = (at 1 note)
  }
  note = ('[data:copyFromTo]' note ((size (v 'note name')) + 1))
  comment 'deal with dotted notes'
  if isDotted {
    duration = ((((v 'ms / whole note') / duration) * 15) / 10)
  } else {
    duration = ((v 'ms / whole note') / duration)
  }
  comment 'parse octave, if there is one'
  if (note != '') {
    octave = (at 1 note)
  }
  'play tone' (v 'note name') (octave - 4) duration
}

to 'current song name' {
  return (v '_RTTTL song name')
}

to 'play ringtone' RTTTL {
  comment 'Initialize frequency map.'
  ignoreArgs ('_baseFreqForNote' 'c')
  comment 'Remove song name'
  '_RTTTL song name' = ('[data:copyFromTo]' RTTTL 1 (('[data:find]' ':' RTTTL) - 1))
  RTTTL = ('[data:copyFromTo]' RTTTL ((size (v '_RTTTL song name')) + 2))
  local 'control' ('_RTTTL parse control from' ('[data:copyFromTo]' RTTTL 1 (('[data:find]' ':' RTTTL) - 1)))
  '_RTTTL default duration' = (at 1 control)
  '_RTTTL default octave' = (at 2 control)
  '_RTTTL bpm' = (at 3 control)
  RTTTL = ('[data:copyFromTo]' RTTTL (('[data:find]' ':' RTTTL) + 1))
  repeatUntil ((size RTTTL) == 0) {
    local 'next separator' ('[data:find]' ',' RTTTL)
    if ((v 'next separator') == -1) {
      'next separator' = ((size RTTTL) + 1)
    }
    local 'next note' ('[data:copyFromTo]' RTTTL 1 ((v 'next separator') - 1))
    RTTTL = ('[data:copyFromTo]' RTTTL ((v 'next separator') + 1))
    '_RTTTL play note' (v 'next note')
  }
  '_RTTTL song name' = ''
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

module main
author MicroBlocks
version 1 0 
description ''

script 50 50 {
comment 'Loudness meter for boards that have a
microphone and (optionally) a TFT.
(Click the graph icon to see the graph.)'
}

script 52 132 {
whenStarted
comment 'Graph the loudness both in the IDE and on
the board''s TFT display, if it has one.'
'set pen color to' (colorSwatch 255 255 255 255)
local 'bottom' (0 - (('[tft:getHeight]') / 2))
local 'right' (('[tft:getWidth]') / 2)
local 'x' (right + 1)
'pen down'
forever {
  if (x > right) {
    x = (0 - (('[tft:getWidth]') / 2))
    'go to x' x bottom
    '[display:mbDisplayOff]'
  }
  printIt (loudness)
  'go to x' x (bottom + (loudness))
  x += 1
  waitMillis 10
}
}


module Microphone Input
author MicroBlocks
version 1 3 
description 'Microphone, loudness, and clap counting support for boards with built in microphones. The microphone block usually reports values between -512 and 511, with zero for silence. However, very loud sounds may exceed that range on some boards. On the micro:bit v2, the microphone must be turned on before use.'
variables _clapThreshold _loudnessSamples 

  spec 'r' '[sensors:microphone]' 'microphone'
  spec ' ' 'turnOnMicrophone' 'turn on microphone'
  spec 'r' 'loudness' 'loudness'
  spec 'r' 'clapCount' 'clap count'
  spec ' ' 'setClapThreshold' 'set clap threshold _' 'auto' 200
  spec 'r' 'guessClapThreshold' 'estimate clap threshold'
  spec ' ' '_loudnessLoop' '_loudnessLoop'

to '_loudnessLoop' {
  comment 'Sample microphone at ~2000 samples/sec, keeping the most recent N samples.'
  turnOnMicrophone
  waitMillis 20
  forever {
    for i (size _loudnessSamples) {
      atPut i _loudnessSamples ('[sensors:microphone]')
      waitMicros 500
    }
  }
}

to clapCount {
  comment 'Count the number of claps in a sequence.'
  if (_clapThreshold == 0) {
    _clapThreshold = 150
  }
  waitUntil ((loudness) > _clapThreshold)
  local 'count' 1
  forever {
    waitUntil ((loudness) < ((3 * _clapThreshold) / 4))
    resetTimer
    repeatUntil ((loudness) > _clapThreshold) {
      comment 'This loop awaits either the next clap or for a pause, indicating that the claps have ended.'
      if ((timer) > 700) {
        comment 'No clap for a while, return the count.'
        return count
      }
    }
    count += 1
  }
}

to guessClapThreshold {
  comment 'Sample the loudness for three seconds and set
_clapThreshold to 130% of the maxium.'
  local 'maxLoudness' 0
  resetTimer
  repeatUntil ((timer) > 3000) {
    maxLoudness = (maximum maxLoudness (loudness))
  }
  return ((13 * maxLoudness) / 10)
}

to loudness {
  if (_loudnessSamples == 0) {
    comment 'Initialize _loudnessSamples and start sampling.'
    _loudnessSamples = (newList 50)
    sendBroadcast '_loudnessLoop'
  }
  local 'low' 10000
  local 'high' -10000
  for n _loudnessSamples {
    low = (minimum low n)
    high = (maximum high n)
  }
  return (high - low)
}

to setClapThreshold n {
  _clapThreshold = n
}

to turnOnMicrophone {
  if ('micro:bit v2' == (boardType)) {
    comment 'Turn on the microphone and
wait for it to settle down.'
    digitalWriteOp 28 true
    waitMillis 50
  }
}


module TFT Output
author MicroBlocks
version 1 5 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  space
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}


module Turtle Output
author MicroBlocks
version 1 3 
depends TFT 
tags tft graphics draw 
description 'Draw with turtle geometry on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.
'
variables _turtleX _turtleY _turtleHeading _turtlePenIsDown _turtleColor 

  spec ' ' 'home' 'home'
  spec ' ' 'move' 'move _' 'auto' '10'
  spec ' ' 'turnBy' 'turn _ degrees' 'auto' 90
  spec ' ' 'turnFraction' 'turn _ / _ of circle' 'auto auto' 1 4
  spec ' ' 'pen down' 'pen down'
  spec ' ' 'pen up' 'pen up'
  spec ' ' 'set pen color to' 'set pen color to _' 'color'
  spec ' ' 'setPenToRandomColor' 'set pen to random color'
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' 'clearDisplay' 'fill display with _' 'color'
  spec ' ' 'go to x' 'go to x _ y _' 'auto auto' '10' '10'
  spec ' ' 'setHeading' 'point in direction _' 'auto' 0
  spec ' ' '_turtleNotes' '_turtleNotes'

to '_turtleNotes' {
  comment 'Representation:
  _turtleHeading is in hundreths of a degree  (e.g. 4500 means 45 degrees)
  _turtleX and _turtleY are scaled by 16384 (2^14)

The sine function takes an angle in hundreds of a degree and returns a
number scaled by 16384. _turtleX and _turtleY are also scaled by 16384.
Those numbers are shifted right by 14 bits to get pixel locations.'
}

to clearDisplay color {
  '[tft:rect]' 0 0 ('[tft:getWidth]') ('[tft:getHeight]') color true
  comment 'Give the display controller time to finish this operation'
  waitMillis 1
}

to 'go to x' x y {
  local 'startX' (_turtleX >> 14)
  local 'startY' (_turtleY >> 14)
  _turtleX = (((('[tft:getWidth]') / 2) + x) << 14)
  _turtleY = (((('[tft:getHeight]') / 2) - y) << 14)
  local 'endX' (_turtleX >> 14)
  local 'endY' (_turtleY >> 14)
  if _turtlePenIsDown {
    '[tft:line]' startX startY endX endY _turtleColor
  }
}

to home {
  if (0 == _turtlePenIsDown) {
    'set pen color to' (colorSwatch 7 255 1 255)
    '[display:mbDisplayOff]'
    'pen up'
  }
  'go to x' 0 0
  setHeading 0
}

to move n {
  local 'startX' (_turtleX >> 14)
  local 'startY' (_turtleY >> 14)
  comment 'The cosine is just the sine shifted by 90 degrees.'
  _turtleX += (n * ('[misc:sin]' (_turtleHeading + 9000)))
  _turtleY += (n * ('[misc:sin]' _turtleHeading))
  local 'endX' (_turtleX >> 14)
  local 'endY' (_turtleY >> 14)
  if _turtlePenIsDown {
    '[tft:line]' startX startY endX endY _turtleColor
  }
}

to 'pen down' {
  _turtlePenIsDown = (booleanConstant true)
}

to 'pen up' {
  _turtlePenIsDown = (booleanConstant false)
}

to 'set pen color to' color {
  _turtleColor = color
}

to setHeading a {
  _turtleHeading = ((a * 100) % 36000)
}

to setPenToRandomColor {
  local 'c1' (random 150 220)
  local 'c2' (random 0 ((3 * c1) / 4))
  local 'c3' (random 0 ((3 * c1) / 4))
  local 'which' (random 1 3)
  if (1 == which) {
    _turtleColor = ((c1 << 16) | ((c2 << 8) | c3))
  } (2 == which) {
    _turtleColor = ((c2 << 16) | ((c3 << 8) | c1))
  } else {
    _turtleColor = ((c3 << 16) | ((c1 << 8) | c2))
  }
}

to turnBy a {
  _turtleHeading += (a * 100)
  _turtleHeading = (_turtleHeading % 36000)
}

to turnFraction num denom {
  _turtleHeading += ((num * 36000) / denom)
  _turtleHeading = (_turtleHeading % 36000)
}

module main
author MicroBlocks
version 1 0 
description ''

script 55 50 {
comment 'Loudness meter for boards
that have a microphone.'
}

script 57 112 {
whenStarted
comment 'Display loudness on a micro:bit style display.'
forever {
  local 'sound level' (loudness)
  if ((v 'sound level') > 120) {
    '[display:mbDisplay]' 33554431
  } ((v 'sound level') > 50) {
    '[display:mbDisplay]' 473536
  } ((v 'sound level') > 35) {
    '[display:mbDisplay]' 14336
  } ((v 'sound level') > 25) {
    '[display:mbDisplay]' 4096
  } else {
    '[display:mbDisplayOff]'
  }
  waitMillis 10
}
}

script 432 112 {
whenStarted
comment 'Display loudness on the NeoPixels of a
Circuit Playground Express or Bluefruit.'
neoPixelAttach 10 ''
forever {
  local 'sound level' (loudness)
  if ((v 'sound level') > 300) {
    setNeoPixelColors10 (colorSwatch 18 103 16 255) (colorSwatch 18 103 16 255) (colorSwatch 112 133 2 255) (colorSwatch 99 67 4 255) (colorSwatch 91 15 0 255) (colorSwatch 91 15 0 255) (colorSwatch 99 67 4 255) (colorSwatch 112 133 2 255) (colorSwatch 18 103 16 255) (colorSwatch 18 103 16 255)
  } ((v 'sound level') > 150) {
    setNeoPixelColors10 (colorSwatch 18 103 16 255) (colorSwatch 18 103 16 255) (colorSwatch 112 133 2 255) (colorSwatch 99 67 4 255) (colorSwatch 0 0 0 255) (colorSwatch 3 3 3 255) (colorSwatch 99 67 4 255) (colorSwatch 112 133 2 255) (colorSwatch 18 103 16 255) (colorSwatch 18 103 16 255)
  } ((v 'sound level') > 100) {
    setNeoPixelColors10 (colorSwatch 18 103 16 255) (colorSwatch 18 103 16 255) (colorSwatch 112 133 2 255) (colorSwatch 0 0 0 255) (colorSwatch 0 0 0 255) (colorSwatch 3 3 3 255) (colorSwatch 0 0 0 255) (colorSwatch 112 133 2 255) (colorSwatch 18 103 16 255) (colorSwatch 18 103 16 255)
  } ((v 'sound level') > 70) {
    setNeoPixelColors10 (colorSwatch 18 103 16 255) (colorSwatch 18 103 16 255) (colorSwatch 2 2 2 255) (colorSwatch 0 0 0 255) (colorSwatch 0 0 0 255) (colorSwatch 3 3 3 255) (colorSwatch 0 0 0 255) (colorSwatch 0 0 0 255) (colorSwatch 18 103 16 255) (colorSwatch 18 103 16 255)
  } ((v 'sound level') > 30) {
    setNeoPixelColors10 (colorSwatch 18 103 16 255) (colorSwatch 7 7 7 255) (colorSwatch 2 2 2 255) (colorSwatch 0 0 0 255) (colorSwatch 0 0 0 255) (colorSwatch 3 3 3 255) (colorSwatch 0 0 0 255) (colorSwatch 0 0 0 255) (colorSwatch 0 0 0 255) (colorSwatch 18 103 16 255)
  } else {
    clearNeoPixels
  }
  waitMillis 10
}
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}


module Microphone Input
author MicroBlocks
version 1 3 
description 'Microphone, loudness, and clap counting support for boards with built in microphones. The microphone block usually reports values between -512 and 511, with zero for silence. However, very loud sounds may exceed that range on some boards. On the micro:bit v2, the microphone must be turned on before use.'
variables _clapThreshold _loudnessSamples 

  spec 'r' '[sensors:microphone]' 'microphone'
  spec ' ' 'turnOnMicrophone' 'turn on microphone'
  spec 'r' 'loudness' 'loudness'
  spec 'r' 'clapCount' 'clap count'
  spec ' ' 'setClapThreshold' 'set clap threshold _' 'auto' 200
  spec 'r' 'guessClapThreshold' 'estimate clap threshold'
  spec ' ' '_loudnessLoop' '_loudnessLoop'

to '_loudnessLoop' {
  comment 'Sample microphone at ~2000 samples/sec, keeping the most recent N samples.'
  turnOnMicrophone
  waitMillis 20
  forever {
    for i (size _loudnessSamples) {
      atPut i _loudnessSamples ('[sensors:microphone]')
      waitMicros 500
    }
  }
}

to clapCount {
  comment 'Count the number of claps in a sequence.'
  if (_clapThreshold == 0) {
    _clapThreshold = 150
  }
  waitUntil ((loudness) > _clapThreshold)
  local 'count' 1
  forever {
    waitUntil ((loudness) < ((3 * _clapThreshold) / 4))
    resetTimer
    repeatUntil ((loudness) > _clapThreshold) {
      comment 'This loop awaits either the next clap or for a pause, indicating that the claps have ended.'
      if ((timer) > 700) {
        comment 'No clap for a while, return the count.'
        return count
      }
    }
    count += 1
  }
}

to guessClapThreshold {
  comment 'Sample the loudness for three seconds and set
_clapThreshold to 130% of the maxium.'
  local 'maxLoudness' 0
  resetTimer
  repeatUntil ((timer) > 3000) {
    maxLoudness = (maximum maxLoudness (loudness))
  }
  return ((13 * maxLoudness) / 10)
}

to loudness {
  if (_loudnessSamples == 0) {
    comment 'Initialize _loudnessSamples and start sampling.'
    _loudnessSamples = (newList 50)
    sendBroadcast '_loudnessLoop'
  }
  local 'low' 10000
  local 'high' -10000
  for n _loudnessSamples {
    low = (minimum low n)
    high = (maximum high n)
  }
  return (high - low)
}

to setClapThreshold n {
  _clapThreshold = n
}

to turnOnMicrophone {
  if ('micro:bit v2' == (boardType)) {
    comment 'Turn on the microphone and
wait for it to settle down.'
    digitalWriteOp 28 true
    waitMillis 50
  }
}


module NeoPixel Output
author MicroBlocks
version 1 6 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if ((boardType) == 'M5Atom-Matrix') {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'Mbits') {
    neoPixelAttach 25 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'r' ((rgb >> 16) & 255)
    local 'g' ((rgb >> 8) & 255)
    local 'b' (rgb & 255)
    local 'brightness' (maximum r g b)
    if (delta > 0) {
      delta = (minimum delta (255 - brightness))
    } else {
      delta = (maximum delta (42 - brightness))
    }
    r = (maximum 0 (minimum (r + delta) 255))
    g = (maximum 0 (minimum (g + delta) 255))
    b = (maximum 0 (minimum (b + delta) 255))
    atPut i _np_pixels (colorFromRGB r g b)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_update' {
  '[display:neoPixelSend]' _np_pixels
  waitMicros 100
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  hasWhite = false
  if ((pushArgCount) > 2) {
    hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  fillList _np_pixels 0
  '[display:neoPixelSetPin]' pinNumber hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels color
  '_NeoPixel_update'
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' (n > 0)
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}

module main
author MicroBlocks
version 1 0 
description ''
variables clapsPerMinute lastClapTime 

script 50 50 {
comment 'Click start and then clap at a steady rate.
This program will show the tempo in
beats per minute (bpm).'
}

script 54 125 {
whenCondition ((loudness) > 80)
local 'now' (millisOp)
clapsPerMinute = (60000 / (now - lastClapTime))
lastClapTime = now
sayIt clapsPerMinute
waitUntil ((loudness) < 50)
}

script 54 368 {
whenStarted
comment 'Open the graph to see how steady your beat is.
If you keep it very steady the graph will be almost flat.'
forever {
  printIt clapsPerMinute
  waitMillis 25
}
}


module Microphone Input
author MicroBlocks
version 1 3 
description 'Microphone, loudness, and clap counting support for boards with built in microphones. The microphone block usually reports values between -512 and 511, with zero for silence. However, very loud sounds may exceed that range on some boards. On the micro:bit v2, the microphone must be turned on before use.'
variables _clapThreshold _loudnessSamples 

  spec 'r' '[sensors:microphone]' 'microphone'
  spec ' ' 'turnOnMicrophone' 'turn on microphone'
  spec 'r' 'loudness' 'loudness'
  spec 'r' 'clapCount' 'clap count'
  spec ' ' 'setClapThreshold' 'set clap threshold _' 'auto' 200
  spec 'r' 'guessClapThreshold' 'estimate clap threshold'
  spec ' ' '_loudnessLoop' '_loudnessLoop'

to '_loudnessLoop' {
  comment 'Sample microphone at ~2000 samples/sec, keeping the most recent N samples.'
  turnOnMicrophone
  waitMillis 20
  forever {
    for i (size _loudnessSamples) {
      atPut i _loudnessSamples ('[sensors:microphone]')
      waitMicros 500
    }
  }
}

to clapCount {
  comment 'Count the number of claps in a sequence.'
  if (_clapThreshold == 0) {
    _clapThreshold = 150
  }
  waitUntil ((loudness) > _clapThreshold)
  local 'count' 1
  forever {
    waitUntil ((loudness) < ((3 * _clapThreshold) / 4))
    resetTimer
    repeatUntil ((loudness) > _clapThreshold) {
      comment 'This loop awaits either the next clap or for a pause, indicating that the claps have ended.'
      if ((timer) > 700) {
        comment 'No clap for a while, return the count.'
        return count
      }
    }
    count += 1
  }
}

to guessClapThreshold {
  comment 'Sample the loudness for three seconds and set
_clapThreshold to 130% of the maxium.'
  local 'maxLoudness' 0
  resetTimer
  repeatUntil ((timer) > 3000) {
    maxLoudness = (maximum maxLoudness (loudness))
  }
  return ((13 * maxLoudness) / 10)
}

to loudness {
  if (_loudnessSamples == 0) {
    comment 'Initialize _loudnessSamples and start sampling.'
    _loudnessSamples = (newList 50)
    sendBroadcast '_loudnessLoop'
  }
  local 'low' 10000
  local 'high' -10000
  for n _loudnessSamples {
    low = (minimum low n)
    high = (maximum high n)
  }
  return (high - low)
}

to setClapThreshold n {
  _clapThreshold = n
}

to turnOnMicrophone {
  if ('micro:bit v2' == (boardType)) {
    comment 'Turn on the microphone and
wait for it to settle down.'
    digitalWriteOp 28 true
    waitMillis 50
  }
}

module main
author MicroBlocks
version 1 0 
description ''
variables half quarter eighth dottedQuarter verseTime 

script 54 88 {
whenStarted
comment 'This demonstrate three part harmony
on a micro:bit v2, Circuit Playground, CIrcuit
Playground Bluefruit, Clue, or M5 Stack. It
requires either a DAC or fast PWM hardware,
so it works on ESP32, nRF52, or SAMD21
processors. Sorry, it does not work on the
original micro:bit or Calliope mini.

It sounds best when played through an
amplified external speaker.'
setMultitonePin ''
eighth = 200
quarter = (2 * eighth)
dottedQuarter = (3 * eighth)
half = (4 * eighth)
verseTime = ((4 * half) + 20)
comment 'Play the melody by itself'
sendBroadcast 'part1'
waitMillis verseTime
sendBroadcast 'part2'
waitMillis verseTime
sendBroadcast 'part3'
waitMillis verseTime
comment 'Play it like a round.'
sendBroadcast 'part1'
waitMillis verseTime
sendBroadcast 'part1'
sendBroadcast 'part2'
waitMillis verseTime
sendBroadcast 'part1'
sendBroadcast 'part2'
sendBroadcast 'part3'
waitMillis verseTime
sendBroadcast 'part2'
sendBroadcast 'part3'
waitMillis verseTime
sendBroadcast 'part3'
waitMillis verseTime
playNoteOnVoice 'C' 0 (2 * half) 1
}

script 448 90 {
whenBroadcastReceived 'part1'
playNoteOnVoice 'C' 0 half 1
playNoteOnVoice 'B' -1 half 1
playNoteOnVoice 'C' 0 quarter 1
playNoteOnVoice 'C' 0 eighth 1
playNoteOnVoice 'C' 0 eighth 1
playNoteOnVoice 'G' -1 half 1
}

script 451 316 {
whenBroadcastReceived 'part2'
playNoteOnVoice 'C' 0 quarter 2
playNoteOnVoice 'C' 0 quarter 2
playNoteOnVoice 'D' 0 quarter 2
playNoteOnVoice 'D' 0 quarter 2
playNoteOnVoice 'D#' 0 quarter 2
playNoteOnVoice 'F' 0 eighth 2
playNoteOnVoice 'D#' 0 eighth 2
playNoteOnVoice 'D' 0 half 2
}

script 451 604 {
whenBroadcastReceived 'part3'
playNoteOnVoice 'G' 0 dottedQuarter 3
playNoteOnVoice 'F' 0 eighth 3
playNoteOnVoice 'G' 0 dottedQuarter 3
playNoteOnVoice 'F' 0 eighth 3
playNoteOnVoice 'G' 0 dottedQuarter 3
playNoteOnVoice 'F' 0 eighth 3
playNoteOnVoice 'G' 0 eighth 3
playNoteOnVoice 'F' 0 eighth 3
playNoteOnVoice 'D#' 0 eighth 3
playNoteOnVoice 'D' 0 eighth 3
}


module MultiTone Output
author MicroBlocks
version 1 1 
description 'On boards that support it, play up to four simultaneous voices of music through a single speaker. The best sound quality is obtained by playing through through an amplified external speaker, but you can hear it through the built-in speakers on the micro:bit V2, Circuit Playground Express and Bluefruit, and M5 Stack/Core.

Note: This library does NOT work on the original micro:bit or Calliope mini!

To output the audio waveform, the board must have a DAC (e.g. SAMD21 and ESP32 boards) or fast enough pulse-width modulation (PWM) hardware to simulate a DAC (e.g. nRF52 boards). To tune the output to standard A=440 pitch on boards with different clock speeds, change the tuningConstant variable in _stepForNote.'
variables _multiTonePin _multiToneInitialized _v1 _v2 _v3 _v4 _v1Step _v2Step _v3Step _v4Step 

  spec ' ' 'playNoteOnVoice' 'play note _ octave _ for _ ms voice _' 'auto num num num' 'A' 0 500 1
  spec ' ' 'setMultitonePin' 'set multitone pin _' 'auto' ''
  spec 'r' '_baseFreqForNoteMulti' '_baseFreqForNoteMulti _' 'auto' 'A'
  spec ' ' '_initMultiTone' '_initMultiTone'
  spec ' ' '_multiToneLoop' '_multiToneLoop'
  spec 'r' '_nextSample' '_nextSample'
  spec 'r' '_stepForNote' '_stepForNote _ octave _' 'str num' 'A' 0
  spec 'r' '_uppercaseNote' '_uppercaseNote _' 'auto' ' a '

to '_baseFreqForNoteMulti' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case and may be followed
by # for a sharp or _ for a flat.'
  note = ('_uppercaseNote' note)
  if (note == 'C') {
    return 261626
  } (note == 'D') {
    return 293665
  } (note == 'E') {
    return 329628
  } (note == 'F') {
    return 349228
  } (note == 'G') {
    return 391995
  } (note == 'A') {
    return 440000
  } (note == 'B') {
    return 493883
  }
  if (or (note == 'C#') (note == 'D_')) {
    return 277183
  } (or (note == 'D#') (note == 'E_')) {
    return 311127
  } (or (note == 'F#') (note == 'G_')) {
    return 369994
  } (or (note == 'G#') (note == 'A_')) {
    return 415305
  } (or (note == 'A#') (note == 'B_')) {
    return 466164
  }
  comment 'Unrecognized note names map to 0.1 Hz, which is inaudible.
This helps users find typos in their tunes.'
  return 100
}

to '_initMultiTone' {
  if ((boardType) == 'micro:bit v2') {
    _multiTonePin = 27
  } ((boardType) == 'Clue') {
    _multiTonePin = 21
  } (or ((boardType) == 'Citilab ED1') ((boardType) == 'M5StickC')) {
    _multiTonePin = 26
  } ((boardType) == 'M5Stack-Core') {
    _multiTonePin = 25
  } else {
    _multiTonePin = 0
  }
  _multiToneInitialized = true
}

to '_multiToneLoop' {
  if (not _multiToneInitialized) {'_initMultiTone'}
  comment 'Set initial sample values to virtual zero (the middle of their range).'
  _v1 = 65536
  _v2 = 65536
  _v3 = 65536
  _v4 = 65536
  comment 'Generate and output sound samples. The DAC on the ESP32
is only 8-bits. Other boards have 10-bit DAC or PWM output.'
  if (or ((boardType) == 'Citilab ED1') ((boardType) == 'M5Stack-Core')) {
    forever {
      analogWriteOp _multiTonePin ((('_nextSample') >> 3) + 128)
    }
  } else {
    forever {
      analogWriteOp _multiTonePin (('_nextSample') + 512)
    }
  }
}

to '_nextSample' {
  comment 'Generate up to four triangle waves. v1-v4 hold the current state of
each voice. These numbers range from 0-262143 and are increased by _v1Step-v4Step
each time this function is called. When the state rises above 131072, the output
value begins to decreases back to zero, so the output value for each voice ranges
from 0-131072 with the middle (65536) being "zero". This code has been optimized
to all four voices to be generated fast enough to play in real time on micro:bit v2.'
  _v1 = ((_v1 + _v1Step) & 262143)
  _v2 = ((_v2 + _v2Step) & 262143)
  _v3 = ((_v3 + _v3Step) & 262143)
  _v4 = ((_v4 + _v4Step) & 262143)
  local 'out' 0
  if (_v1 < 131072) {
    out += (_v1 - 65536)
  } else {
    out += (196608 - _v1)
  }
  if (_v2 < 131072) {
    out += (_v2 - 65536)
  } else {
    out += (196608 - _v2)
  }
  if (_v3 < 131072) {
    out += (_v3 - 65536)
  } else {
    out += (196608 - _v3)
  }
  if (_v4 < 131072) {
    out += (_v4 - 65536)
  } else {
    out += (196608 - _v4)
  }
  return (out >> 9)
}

to '_stepForNote' note octave {
  comment 'Return the step size required to generate the given note name in the given octave.
To make the pitches match other instruments, adjust tuningConstant so that an A
in octave zero generates a pitch as close as possible to 440Hz.'
  local 'tuningConstant' 329
  local 'freq' ('_baseFreqForNoteMulti' note)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  return ((freq * tuningConstant) >> 14)
}

to '_uppercaseNote' aString {
  local 'result' (newList (size aString))
  '[data:delete]' 'all' result
  for i (size aString) {
    local 'ch' ('[data:unicodeAt]' i aString)
    if (ch > 32) {
      if (and (97 <= ch) (ch <= 122)) {
        '[data:addLast]' (ch - 32) result
      } else {
        '[data:addLast]' ch result
      }
    }
  }
  return ('[data:unicodeString]' result)
}

to playNoteOnVoice note octave ms voice {
  comment 'Make sure _multiToneLoop is running. Set the step size for the given
voice to start playing the note, wait ms miliseconds, then set step size
to zero to to stop the note.'
  sendBroadcast '_multiToneLoop'
  if (1 == voice) {
    _v1Step = ('_stepForNote' note octave)
    waitMillis ms
    _v1Step = 0
  } (2 == voice) {
    _v2Step = ('_stepForNote' note octave)
    waitMillis ms
    _v2Step = 0
  } (3 == voice) {
    _v3Step = ('_stepForNote' note octave)
    waitMillis ms
    _v3Step = 0
  } (4 == voice) {
    _v4Step = ('_stepForNote' note octave)
    waitMillis ms
    _v4Step = 0
  }
}

to setMultitonePin pin {
  if (pin == '') {
    _multiToneInitialized = false
    return 0
  }
  _multiTonePin = pin
  _multiToneInitialized = true
}

module main
author unknown
version 1 0 
description ''

script 52 50 {
whenButtonPressed 'A'
repeatUntil (not (buttonA)) {
  '[display:mbPlot]' 1 3
  waitMillis 100
  '[display:mbUnplot]' 1 3
  waitMillis 100
}
}

script 50 258 {
whenButtonPressed 'B'
repeatUntil (not (buttonB)) {
  '[display:mbPlot]' 5 3
  waitMillis 100
  '[display:mbUnplot]' 5 3
  waitMillis 100
}
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

module main
author unknown
version 1 0 
description ''
variables interval octave onOff 

script 57 57 {
whenStarted
comment 'Works out of the box on the Adafruit Circuit Playground Express.

For other boards, you''ll need to attach a NeoPixel strip and a buzzer, and
set their pin configurations in the following two blocks:'
neoPixelAttach 10 ''
'attach buzzer to pin' ''
wifiConnect 'Network_Name' ''
'set thing name to' 'Ambulance'
'set thing capability to' 'OnOffSwitch'
addBooleanProperty 'onOff' 'Triggered' 'OnOffProperty'
addNumProp 'octave' 'octave' -1 3 'LevelProperty'
addNumProp 'interval' 'interval' 250 1000 'LevelProperty'
'start WebThing server'
onOff = (booleanConstant false)
octave = 1
interval = 500
forever {
  if onOff {
    for i 5 {
      setNeoPixelColor i (colorSwatch 10 3 191 255)
      setNeoPixelColor (i + 5) (colorSwatch 191 0 14 255)
    }
    repeatUntil (not onOff) {
      setUserLED true
      'play tone' 'F' octave interval
      rotateNeoPixelsBy 5
      setUserLED false
      'play tone' 'A#' octave interval
      rotateNeoPixelsBy 5
    }
  } else {
    neoPixelSetAllToColor (colorSwatch 0 0 0 255)
    waitMillis 10
  }
}
}

script 346 423 {
whenButtonPressed 'A'
onOff = (not onOff)
}

script 441 549 {
comment 'Click on this script to test.'
onOff = (booleanConstant true)
waitMillis 2000
onOff = (booleanConstant false)
}


module 'HTTP server' Comm
author MicroBlocks
version 1 3 
depends WiFi 
tags http network 
description 'Create an HTTP server in MicroBlocks. You can use this library to allow remote control for your Wifi-enabled board.'

  spec 'r' '[net:httpServerGetRequest]' 'HTTP server request : binary data _ : port _' 'bool num' false 8080
  spec 'r' 'request method' 'method of request _' 'str' ''
  spec 'r' 'path of request' 'path of request _' 'str' ''
  spec 'r' 'headers of request' 'headers of request _' 'str' ''
  spec 'r' 'body of request' 'body of request _' 'str' ''
  spec 'r' 'content length of request' 'content length of request _' 'str' ''
  spec ' ' '[net:respondToHttpRequest]' 'respond _ to HTTP request : with body _ : and headers _ : keepAlive _' 'str str str bool' '200 OK' 'Welcome to the MicroBlocks HTTP server' 'Content-Type: text/plain' false
  spec 'r' '_endOfHeaders' '_end of headers _' 'str'
  spec 'r' '_toString' '_toString _' 'auto' 'abc'

to '_endOfHeaders' request {
  return ('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) request)
}

to '_toString' aStringOrByteArray {
  comment 'If argument is a byte array, convert it to a string. '
  if (not (isType aStringOrByteArray 'string')) {
    aStringOrByteArray = ('[data:join]' '' aStringOrByteArray)
  }
  return aStringOrByteArray
}

to 'body of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('[data:copyFromTo]' request (i + 4))
}

to 'content length of request' request {
  local 'i' ('_endOfHeaders' request)
  if (i < 0) {
    return 0
  }
  local 'j' ('[data:find]' 'Content-Length: ' request)
  if (j < 0) {
    comment 'Try alternate capitalization'
    j = ('[data:find]' 'Content-length: ' request)
  }
  if (or (j < 0) (j > i)) {
    return 0
  }
  j += 16
  local 'k' ('[data:find]' ('[data:unicodeString]' 13) request j)
  return (('[data:copyFromTo]' request j (k - 1)) + 0)
}

to 'headers of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('_toString' ('[data:copyFromTo]' request 1 (i - 1)))
}

to 'path of request' request {
  return ('_toString' ('[data:copyFromTo]' request (('[data:find]' ' ' request) + 1) (('[data:find]' ' HTTP' request) - 1)))
}

to 'request method' request {
  return ('_toString' ('[data:copyFromTo]' request 1 (('[data:find]' ' ' request) - 1)))
}


module NeoPixel Output
author MicroBlocks
version 1 6 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if ((boardType) == 'M5Atom-Matrix') {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'Mbits') {
    neoPixelAttach 25 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'r' ((rgb >> 16) & 255)
    local 'g' ((rgb >> 8) & 255)
    local 'b' (rgb & 255)
    local 'brightness' (maximum r g b)
    if (delta > 0) {
      delta = (minimum delta (255 - brightness))
    } else {
      delta = (maximum delta (42 - brightness))
    }
    r = (maximum 0 (minimum (r + delta) 255))
    g = (maximum 0 (minimum (g + delta) 255))
    b = (maximum 0 (minimum (b + delta) 255))
    atPut i _np_pixels (colorFromRGB r g b)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_update' {
  '[display:neoPixelSend]' _np_pixels
  waitMicros 100
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  hasWhite = false
  if ((pushArgCount) > 2) {
    hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  fillList _np_pixels 0
  '[display:neoPixelSetPin]' pinNumber hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels color
  '_NeoPixel_update'
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' (n > 0)
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}


module WebThings Comm
author MicroBlocks
version 3 4 
depends 'HTTP server' WiFi 
tags iot webthing wot 
choices thingTypesMenu Alarm BinarySensor ColorControl ColorSensor DoorSensor EnergyMonitor LeakSensor Light Lock MotionSensor MultiLevelSensor MultiLevelSwitch OnOffSwitch PushButton SmartPlug TemperatureSensor Thermostat 
choices thingEventTypesMenu OverheatedEvent PressedEvent DoublePressedEvent LongPressedEvent AlarmEvent 
choices numberPropertyTypesMenu LevelProperty BrightnessProperty ColorTemperatureProperty InstantaneousPowerProperty CurrentProperty VoltageProperty FrequencyProperty TargetTemperatureProperty TemperatureProperty 
choices booleanPropertyTypesMenu BooleanProperty OnOffProperty MotionProperty OpenProperty LeakProperty PushedProperty AlarmProperty 
choices stringPropertyTypesMenu ColorProperty TextProperty HeatingCoolingProperty LockedProperty ThermostatModeProperty 
description 'Create WebThings as specified by the WebThings schema and protocol. If your board is WiFi enabled, you can serve its thing description directly via HTTP. Otherwise, you can enable the MicroBlocks add-on in the WebThings Gateway.
'
variables _WoT_title _WoT_events _WoT_capability _WoT_event_defs _WoT_property_defs '_thing description' 

  spec ' ' 'set thing name to' 'set thing name to _' 'auto' 'MicroBlocks thing'
  spec ' ' 'set thing capability to' 'set thing capability to _' 'str.thingTypesMenu' 'Light'
  spec ' ' 'addBooleanProperty' 'set boolean property _ title _ @Type _ : read only _' 'menu.allVarsMenu str str.booleanPropertyTypesMenu bool' '' '' 'OnOffProperty' false
  spec ' ' 'addStringProperty' 'set string property _ title _ @Type _ : read only _' 'menu.allVarsMenu str str.stringPropertyTypesMenu bool' '' '' 'ColorProperty' false
  spec ' ' 'addNumProp' 'set number property _ title _ min _ max _ @Type _ : read only _' 'menu.allVarsMenu str num num str.numberPropertyTypesMenu bool' '' '' 0 100 'LevelProperty' false
  spec ' ' 'register event' 'register event _ type _' 'auto str.thingEventTypesMenu' 'Button A pressed' 'PressedEvent'
  spec ' ' 'start WebThing server' 'start WebThing server'
  spec ' ' 'trigger event' 'trigger event _' 'auto' 'button pressed'
  spec 'r' 'thing description JSON' 'thing description JSON'
  spec 'r' 'properties JSON' 'properties JSON'
  spec 'r' 'event definitions JSON' 'event definitions JSON'
  spec 'r' 'events JSON' 'events JSON'
  spec ' ' '_process OPTIONS request' '_process OPTIONS request _' 'auto' ''
  spec ' ' '_process PUT request' '_process PUT request _' 'auto' ''
  spec ' ' '_process request' '_process GET request _' 'auto' ''
  spec ' ' '_respond 404 Not Found' '_respond 404 Not Found'
  spec 'r' '_JSON value' '_JSON value _' 'auto' '10'
  spec 'r' '_parse JSON value' '_parse JSON value _' 'auto' ''
  spec 'r' '_trimmed' '_trimmed _' 'auto' '  hello    '
  spec ' ' '_WoT_start_server' '_WoT_start_server'
  spec 'r' '_type of' '_type of _' 'auto' '10'
  spec ' ' '_add or replace property' '_add or replace property _ attributes _' 'menu.nil str' '' ''
  spec ' ' '_clear thing description' '_clear thing description'
  spec 'r' '_varNames' '_varNames'

to '_JSON value' value {
  local 'JSON value' ''
  if (isType value 'string') {
    'JSON value' = ('[data:join]' '"' value '"')
  } (isType value 'list') {
    'JSON value' = '['
    for item value {
      'JSON value' = ('[data:join]' (v 'JSON value') ('_JSON value' item) ',')
    }
    'JSON value' = ('[data:join]' ('[data:copyFromTo]' (v 'JSON value') 1 ((size (v 'JSON value')) - 1)) ']')
  } (isType value 'boolean') {
    if value {
      'JSON value' = 'true'
    } else {
      'JSON value' = 'false'
    }
  } else {
    'JSON value' = value
  }
  return (v 'JSON value')
}

to '_WoT_start_server' {
  local 'request' ''
  forever {
    request = ('[net:httpServerGetRequest]')
    if (request != '') {
      if (('request method' request) == 'GET') {
        '_process request' request
      } (('request method' request) == 'PUT') {
        '_process PUT request' request
      } (('request method' request) == 'OPTIONS') {
        '_process OPTIONS request' request
      } else {
        '_respond 404 Not Found'
      }
    }
    waitMillis 50
  }
}

to '_add or replace property' varName 'attributes JSON' {
  if (_WoT_property_defs == 0) {_WoT_property_defs = ('[data:makeList]')}
  for def _WoT_property_defs {
    if ((at 1 def) == varName) {
      atPut 2 def (v 'attributes JSON')
      return ''
    }
  }
  '[data:addLast]' ('[data:makeList]' varName (v 'attributes JSON')) _WoT_property_defs
}

to '_clear thing description' {
  '_thing description' = 0
}

to '_parse JSON value' JSON {
  local 'value' ('_trimmed' JSON)
  if ((at 1 value) == '[') {
    comment 'Doesn''t handle multi-dimensional lists'
    local 'list' ('[data:makeList]')
    value = ('[data:copyFromTo]' value 2 ((size value) - 1))
    local 'comma index' ('[data:find]' ',' value)
    repeatUntil ((v 'comma index') == -1) {
      '[data:addLast]' ('_parse JSON value' ('[data:copyFromTo]' value 1 ((v 'comma index') - 1))) list
      value = ('[data:copyFromTo]' value ((v 'comma index') + 1))
      'comma index' = ('[data:find]' ',' value)
    }
    '[data:addLast]' ('_parse JSON value' value) list
    value = list
  } else {
    value = ('[misc:jsonGet]' value '')
  }
  return value
}

to '_process OPTIONS request' req {
  local 'path' ('path of request' req)
  '[net:respondToHttpRequest]' '200 OK' '' 'Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: PUT, GET, OPTIONS
Access-Control-Allow-Headers: Content-Type'
}

to '_process PUT request' req {
  local 'path' ('path of request' req)
  if (('[data:find]' '/properties/' path) > 0) {
    local 'varName' ('[data:copyFromTo]' path 13)
    if ('[vars:varExists]' varName) {
      local 'body' ('body of request' req)
      '[vars:setVarNamed]' varName ('_parse JSON value' ('[data:copyFromTo]' body (('[data:find]' ':' body) + 1) (('[data:find]' '}' body) - 1)))
      '[net:respondToHttpRequest]' '200 OK' ('[data:join]' '{"' varName '":' ('_JSON value' ('[vars:varNamed]' varName)) '}') 'Content-Type: application/json'
    } else {
      '_respond 404 Not Found'
    }
  } else {
    '_respond 404 Not Found'
  }
}

to '_process request' req {
  local 'path' ('path of request' req)
  if (path == '/') {
    '[net:respondToHttpRequest]' '200 OK' ('thing description JSON') 'Content-Type: application/json'
  } (or (path == '/properties') (path == '/properties/')) {
    '[net:respondToHttpRequest]' '200 OK' ('properties JSON') 'Content-Type: application/json'
  } (('[data:find]' '/properties/' path) > 0) {
    local 'varName' ('[data:copyFromTo]' path 13)
    if ('[vars:varExists]' varName) {
      '[net:respondToHttpRequest]' '200 OK' ('[data:join]' '{"' varName '":' ('_JSON value' ('[vars:varNamed]' varName)) '}') 'Content-Type: application/json'
    } else {
      '_respond 404 Not Found'
    }
  } (or (path == '/events') (path == '/events/')) {
    '[net:respondToHttpRequest]' '200 OK' ('events JSON') 'Content-Type: application/json'
    _WoT_events = ('[data:makeList]')
  } else {
    '_respond 404 Not Found'
  }
}

to '_respond 404 Not Found' {
  '[net:respondToHttpRequest]' '404 Not Found' '{ "error":"Resource not found" }' 'Content-Type: application/json'
}

to '_trimmed' string {
  comment 'remove surrounding spaces'
  repeatUntil ((at 1 string) != ' ') {
    string = ('[data:copyFromTo]' string 2)
  }
  repeatUntil ((at 'last' string) != ' ') {
    string = ('[data:copyFromTo]' string 1 ((size string) - 1))
  }
  return string
}

to '_type of' value {
  if (isType value 'number') {
    return 'number'
  } (isType value 'list') {
    return 'array'
  } (isType value 'string') {
    return 'string'
  } (isType value 'boolean') {
    return 'boolean'
  }
  comment 'should never happen'
  return 'null'
}

to '_varNames' {
  local 'result' ('[data:makeList]')
  local 'count' ('[vars:varNameForIndex]' -1)
  for i count {
    local 'varName' ('[vars:varNameForIndex]' i)
    if (isType varName 'string') {
      '[data:addLast]' varName result
    }
  }
  return result
}

to addBooleanProperty varName title type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 3) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"boolean","@type":"' type '",' '"readOnly":' readonly)
}

to addNumProp varName title min max type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 5) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"number","@type":"' type '",' '"readOnly":' readonly ',"minimum":' min ',"maximum":' max)
}

to addStringProperty varName title type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 3) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"string","@type":"' type '",' '"readOnly":' readonly)
}

to 'event definitions JSON' {
  local 'JSON' '{'
  if (_WoT_event_defs == 0) {
    _WoT_event_defs = ('[data:makeList]')
  }
  for 'event def' _WoT_event_defs {
    JSON = ('[data:join]' JSON '"' (at 1 (v 'event def')) '":{"description":"MicroBlocks event","@type":"' (at 2 (v 'event def')) '"},')
  }
  if ((size JSON) > 1) {
    return ('[data:join]' ('[data:copyFromTo]' JSON 1 ((size JSON) - 1)) '}')
  } else {
    return '{}'
  }
}

to 'events JSON' {
  local 'JSON' '['
  for event _WoT_events {
    JSON = ('[data:join]' JSON '{"' (at 1 event) '":{"data":{"id":' (at 2 event) '}}},')
  }
  if ((size JSON) > 1) {
    return ('[data:join]' ('[data:copyFromTo]' JSON 1 ((size JSON) - 1)) ']')
  } else {
    return '[]'
  }
}

to 'properties JSON' {
  local 'JSON' '{'
  if (or (_WoT_property_defs == 0) ((size _WoT_property_defs) == 0)) {
    for varName ('_varNames') {
      if (not ((at 1 varName) == '_')) {
        local 'value' ('[vars:varNamed]' varName)
        JSON = ('[data:join]' JSON '"' varName '":{"title":"' varName '","type":"' ('_type of' value) '","links":[{"href":"/properties/' varName '"}],"@type":""},')
      }
    }
  } else {
    for 'property def' _WoT_property_defs {
      local 'varName' (at 1 (v 'property def'))
      JSON = ('[data:join]' JSON '"' varName '":{"links":[{"href":"/properties/' varName '"}],' (at 2 (v 'property def')) '},')
    }
  }
  if ((at 'last' JSON) == ',') {
    JSON = ('[data:copyFromTo]' JSON 1 ((size JSON) - 1))
  }
  return ('[data:join]' JSON '}')
}

to 'register event' 'event title' 'event type' {
  local 'event def' ('[data:makeList]' (v 'event title') (v 'event type'))
  if (_WoT_event_defs == 0) {
    _WoT_event_defs = ('[data:makeList]')
  }
  for def _WoT_event_defs {
    if ((at 1 def) == (v 'event title')) {
      atPut 2 def (v 'event type')
      return ''
    }
  }
  '[data:addLast]' (v 'event def') _WoT_event_defs
}

to 'set thing capability to' capability {
  _WoT_capability = capability
}

to 'set thing name to' title {
  _WoT_title = title
}

to 'start WebThing server' {
  if (_WoT_title == 0) {'set thing name to' 'MicroBlocks thing'}
  if (_WoT_capability == 0) {'set thing capability to' ''}
  if ('[net:hasWiFi]') {
    if (_WoT_events == 0) {_WoT_events = ('[data:makeList]')}
    sendBroadcast '_WoT_start_server'
  } else {
    '_thing description' = ('thing description JSON')
  }
}

to 'thing description JSON' {
  return ('[data:join]' '{"title":"' _WoT_title '","@context":"https://webthings.io/schemas/","@type":["' _WoT_capability '"],"links":[{"rel":"events","href":"/events"},{"rel":"properties","href":"/properties"}],"properties":' ('properties JSON') ',"events":' ('event definitions JSON') '}')
}

to 'trigger event' 'event name' {
  if ('[net:hasWiFi]') {
    '[data:addLast]' ('[data:makeList]' (v 'event name') (millisOp)) _WoT_events
  } else {
    sendBroadcast (v 'event name')
  }
}


module WiFi Comm
author MicroBlocks
version 1 6 
tags communication network 
description 'Connect to a WiFi network. Used in conjunction with other network libraries, such as HTTP client, HTTP server or Web Thing.
'

  spec ' ' 'wifiConnect' 'wifi connect to _ password _ : IP _ gateway _ subnet _' 'str str auto auto auto' 'Network_Name' '' '192.168.1.42' '192.168.1.1' '255.255.255.0'
  spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
  spec 'r' 'getIPAddress' 'IP address'
  spec 'r' '[net:myMAC]' 'MAC address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to wifiConnect ssid password fixedIP gatewayIP subnetIP {
  if (not ('[net:hasWiFi]')) {return}
  '[net:stopWiFi]'
  if ((pushArgCount) < 5) {
    '[net:startWiFi]' ssid password
  } else {
    '[net:startWiFi]' ssid password false fixedIP gatewayIP subnetIP
  }
  local 'startMSecs' (millisOp)
  repeatUntil (('[net:myIPAddress]') != '0.0.0.0') {
    comment 'Timeout after N seconds'
    if (((millisOp) - startMSecs) > 30000) {
      sayIt 'Could not connect'
      return 0
    }
    comment 'Slow blink while trying to connect'
    setUserLED true
    waitMillis 300
    setUserLED false
    waitMillis 300
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  if ('Connected' != ('[net:wifiStatus]')) {
    sayIt 'Could not create hotspot'
    return 0
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

module main
author unknown
version 1 0 
description ''
variables _useWiFi bpm interval 

script 57 57 {
comment 'This example lets you simulate a heart rate using A and B buttons
and displays the rate as a beating heart on the LED matrix'
}

script 57 117 {
whenStarted
wifiConnect 'Network_Name' ''
'set thing name to' 'Heart rate'
'set thing capability to' 'MultiLevelSensor'
addNumProp 'bpm' 'rate' 40 200 'LevelProperty' true
'start WebThing server'
forever {
  if (and (buttonB) (bpm < 200)) {
    bpm += 5
  } (and (buttonA) (bpm > 40)) {
    bpm += -5
  } (and (buttonA) (bpm == 40)) {
    comment 'In case the board only has button A'
    bpm = 200
  }
  waitMillis 150
}
}

script 490 118 {
whenStarted
bpm = 60
forever {
  local 'interval' (60000 / bpm)
  setUserLED false
  '[display:mbDisplay]' 145728
  waitMillis (interval / 4)
  setUserLED true
  '[display:mbDisplay]' 4685802
  waitMillis (interval / 4)
  setUserLED false
  '[display:mbDisplayOff]'
  waitMillis (interval / 2)
}
}

script 59 608 {
comment 'To test, click this script, then press buttons
A and B to adjust the heart rate.'
forever {
  sayIt bpm
  waitMillis 100
}
}


module 'HTTP server' Comm
author MicroBlocks
version 1 3 
depends WiFi 
tags http network 
description 'Create an HTTP server in MicroBlocks. You can use this library to allow remote control for your Wifi-enabled board.'

  spec 'r' '[net:httpServerGetRequest]' 'HTTP server request : binary data _ : port _' 'bool num' false 8080
  spec 'r' 'request method' 'method of request _' 'str' ''
  spec 'r' 'path of request' 'path of request _' 'str' ''
  spec 'r' 'headers of request' 'headers of request _' 'str' ''
  spec 'r' 'body of request' 'body of request _' 'str' ''
  spec 'r' 'content length of request' 'content length of request _' 'str' ''
  spec ' ' '[net:respondToHttpRequest]' 'respond _ to HTTP request : with body _ : and headers _ : keepAlive _' 'str str str bool' '200 OK' 'Welcome to the MicroBlocks HTTP server' 'Content-Type: text/plain' false
  spec 'r' '_endOfHeaders' '_end of headers _' 'str'
  spec 'r' '_toString' '_toString _' 'auto' 'abc'

to '_endOfHeaders' request {
  return ('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) request)
}

to '_toString' aStringOrByteArray {
  comment 'If argument is a byte array, convert it to a string. '
  if (not (isType aStringOrByteArray 'string')) {
    aStringOrByteArray = ('[data:join]' '' aStringOrByteArray)
  }
  return aStringOrByteArray
}

to 'body of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('[data:copyFromTo]' request (i + 4))
}

to 'content length of request' request {
  local 'i' ('_endOfHeaders' request)
  if (i < 0) {
    return 0
  }
  local 'j' ('[data:find]' 'Content-Length: ' request)
  if (j < 0) {
    comment 'Try alternate capitalization'
    j = ('[data:find]' 'Content-length: ' request)
  }
  if (or (j < 0) (j > i)) {
    return 0
  }
  j += 16
  local 'k' ('[data:find]' ('[data:unicodeString]' 13) request j)
  return (('[data:copyFromTo]' request j (k - 1)) + 0)
}

to 'headers of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('_toString' ('[data:copyFromTo]' request 1 (i - 1)))
}

to 'path of request' request {
  return ('_toString' ('[data:copyFromTo]' request (('[data:find]' ' ' request) + 1) (('[data:find]' ' HTTP' request) - 1)))
}

to 'request method' request {
  return ('_toString' ('[data:copyFromTo]' request 1 (('[data:find]' ' ' request) - 1)))
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}


module WebThings Comm
author MicroBlocks
version 3 4 
depends 'HTTP server' WiFi 
tags iot webthing wot 
choices thingTypesMenu Alarm BinarySensor ColorControl ColorSensor DoorSensor EnergyMonitor LeakSensor Light Lock MotionSensor MultiLevelSensor MultiLevelSwitch OnOffSwitch PushButton SmartPlug TemperatureSensor Thermostat 
choices thingEventTypesMenu OverheatedEvent PressedEvent DoublePressedEvent LongPressedEvent AlarmEvent 
choices numberPropertyTypesMenu LevelProperty BrightnessProperty ColorTemperatureProperty InstantaneousPowerProperty CurrentProperty VoltageProperty FrequencyProperty TargetTemperatureProperty TemperatureProperty 
choices booleanPropertyTypesMenu BooleanProperty OnOffProperty MotionProperty OpenProperty LeakProperty PushedProperty AlarmProperty 
choices stringPropertyTypesMenu ColorProperty TextProperty HeatingCoolingProperty LockedProperty ThermostatModeProperty 
description 'Create WebThings as specified by the WebThings schema and protocol. If your board is WiFi enabled, you can serve its thing description directly via HTTP. Otherwise, you can enable the MicroBlocks add-on in the WebThings Gateway.
'
variables _WoT_title _WoT_events _WoT_capability _WoT_event_defs _WoT_property_defs '_thing description' 

  spec ' ' 'set thing name to' 'set thing name to _' 'auto' 'MicroBlocks thing'
  spec ' ' 'set thing capability to' 'set thing capability to _' 'str.thingTypesMenu' 'Light'
  spec ' ' 'addBooleanProperty' 'set boolean property _ title _ @Type _ : read only _' 'menu.allVarsMenu str str.booleanPropertyTypesMenu bool' '' '' 'OnOffProperty' false
  spec ' ' 'addStringProperty' 'set string property _ title _ @Type _ : read only _' 'menu.allVarsMenu str str.stringPropertyTypesMenu bool' '' '' 'ColorProperty' false
  spec ' ' 'addNumProp' 'set number property _ title _ min _ max _ @Type _ : read only _' 'menu.allVarsMenu str num num str.numberPropertyTypesMenu bool' '' '' 0 100 'LevelProperty' false
  spec ' ' 'register event' 'register event _ type _' 'auto str.thingEventTypesMenu' 'Button A pressed' 'PressedEvent'
  spec ' ' 'start WebThing server' 'start WebThing server'
  spec ' ' 'trigger event' 'trigger event _' 'auto' 'button pressed'
  spec 'r' 'thing description JSON' 'thing description JSON'
  spec 'r' 'properties JSON' 'properties JSON'
  spec 'r' 'event definitions JSON' 'event definitions JSON'
  spec 'r' 'events JSON' 'events JSON'
  spec ' ' '_process OPTIONS request' '_process OPTIONS request _' 'auto' ''
  spec ' ' '_process PUT request' '_process PUT request _' 'auto' ''
  spec ' ' '_process request' '_process GET request _' 'auto' ''
  spec ' ' '_respond 404 Not Found' '_respond 404 Not Found'
  spec 'r' '_JSON value' '_JSON value _' 'auto' '10'
  spec 'r' '_parse JSON value' '_parse JSON value _' 'auto' ''
  spec 'r' '_trimmed' '_trimmed _' 'auto' '  hello    '
  spec ' ' '_WoT_start_server' '_WoT_start_server'
  spec 'r' '_type of' '_type of _' 'auto' '10'
  spec ' ' '_add or replace property' '_add or replace property _ attributes _' 'menu.nil str' '' ''
  spec ' ' '_clear thing description' '_clear thing description'
  spec 'r' '_varNames' '_varNames'

to '_JSON value' value {
  local 'JSON value' ''
  if (isType value 'string') {
    'JSON value' = ('[data:join]' '"' value '"')
  } (isType value 'list') {
    'JSON value' = '['
    for item value {
      'JSON value' = ('[data:join]' (v 'JSON value') ('_JSON value' item) ',')
    }
    'JSON value' = ('[data:join]' ('[data:copyFromTo]' (v 'JSON value') 1 ((size (v 'JSON value')) - 1)) ']')
  } (isType value 'boolean') {
    if value {
      'JSON value' = 'true'
    } else {
      'JSON value' = 'false'
    }
  } else {
    'JSON value' = value
  }
  return (v 'JSON value')
}

to '_WoT_start_server' {
  local 'request' ''
  forever {
    request = ('[net:httpServerGetRequest]')
    if (request != '') {
      if (('request method' request) == 'GET') {
        '_process request' request
      } (('request method' request) == 'PUT') {
        '_process PUT request' request
      } (('request method' request) == 'OPTIONS') {
        '_process OPTIONS request' request
      } else {
        '_respond 404 Not Found'
      }
    }
    waitMillis 50
  }
}

to '_add or replace property' varName 'attributes JSON' {
  if (_WoT_property_defs == 0) {_WoT_property_defs = ('[data:makeList]')}
  for def _WoT_property_defs {
    if ((at 1 def) == varName) {
      atPut 2 def (v 'attributes JSON')
      return ''
    }
  }
  '[data:addLast]' ('[data:makeList]' varName (v 'attributes JSON')) _WoT_property_defs
}

to '_clear thing description' {
  '_thing description' = 0
}

to '_parse JSON value' JSON {
  local 'value' ('_trimmed' JSON)
  if ((at 1 value) == '[') {
    comment 'Doesn''t handle multi-dimensional lists'
    local 'list' ('[data:makeList]')
    value = ('[data:copyFromTo]' value 2 ((size value) - 1))
    local 'comma index' ('[data:find]' ',' value)
    repeatUntil ((v 'comma index') == -1) {
      '[data:addLast]' ('_parse JSON value' ('[data:copyFromTo]' value 1 ((v 'comma index') - 1))) list
      value = ('[data:copyFromTo]' value ((v 'comma index') + 1))
      'comma index' = ('[data:find]' ',' value)
    }
    '[data:addLast]' ('_parse JSON value' value) list
    value = list
  } else {
    value = ('[misc:jsonGet]' value '')
  }
  return value
}

to '_process OPTIONS request' req {
  local 'path' ('path of request' req)
  '[net:respondToHttpRequest]' '200 OK' '' 'Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: PUT, GET, OPTIONS
Access-Control-Allow-Headers: Content-Type'
}

to '_process PUT request' req {
  local 'path' ('path of request' req)
  if (('[data:find]' '/properties/' path) > 0) {
    local 'varName' ('[data:copyFromTo]' path 13)
    if ('[vars:varExists]' varName) {
      local 'body' ('body of request' req)
      '[vars:setVarNamed]' varName ('_parse JSON value' ('[data:copyFromTo]' body (('[data:find]' ':' body) + 1) (('[data:find]' '}' body) - 1)))
      '[net:respondToHttpRequest]' '200 OK' ('[data:join]' '{"' varName '":' ('_JSON value' ('[vars:varNamed]' varName)) '}') 'Content-Type: application/json'
    } else {
      '_respond 404 Not Found'
    }
  } else {
    '_respond 404 Not Found'
  }
}

to '_process request' req {
  local 'path' ('path of request' req)
  if (path == '/') {
    '[net:respondToHttpRequest]' '200 OK' ('thing description JSON') 'Content-Type: application/json'
  } (or (path == '/properties') (path == '/properties/')) {
    '[net:respondToHttpRequest]' '200 OK' ('properties JSON') 'Content-Type: application/json'
  } (('[data:find]' '/properties/' path) > 0) {
    local 'varName' ('[data:copyFromTo]' path 13)
    if ('[vars:varExists]' varName) {
      '[net:respondToHttpRequest]' '200 OK' ('[data:join]' '{"' varName '":' ('_JSON value' ('[vars:varNamed]' varName)) '}') 'Content-Type: application/json'
    } else {
      '_respond 404 Not Found'
    }
  } (or (path == '/events') (path == '/events/')) {
    '[net:respondToHttpRequest]' '200 OK' ('events JSON') 'Content-Type: application/json'
    _WoT_events = ('[data:makeList]')
  } else {
    '_respond 404 Not Found'
  }
}

to '_respond 404 Not Found' {
  '[net:respondToHttpRequest]' '404 Not Found' '{ "error":"Resource not found" }' 'Content-Type: application/json'
}

to '_trimmed' string {
  comment 'remove surrounding spaces'
  repeatUntil ((at 1 string) != ' ') {
    string = ('[data:copyFromTo]' string 2)
  }
  repeatUntil ((at 'last' string) != ' ') {
    string = ('[data:copyFromTo]' string 1 ((size string) - 1))
  }
  return string
}

to '_type of' value {
  if (isType value 'number') {
    return 'number'
  } (isType value 'list') {
    return 'array'
  } (isType value 'string') {
    return 'string'
  } (isType value 'boolean') {
    return 'boolean'
  }
  comment 'should never happen'
  return 'null'
}

to '_varNames' {
  local 'result' ('[data:makeList]')
  local 'count' ('[vars:varNameForIndex]' -1)
  for i count {
    local 'varName' ('[vars:varNameForIndex]' i)
    if (isType varName 'string') {
      '[data:addLast]' varName result
    }
  }
  return result
}

to addBooleanProperty varName title type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 3) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"boolean","@type":"' type '",' '"readOnly":' readonly)
}

to addNumProp varName title min max type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 5) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"number","@type":"' type '",' '"readOnly":' readonly ',"minimum":' min ',"maximum":' max)
}

to addStringProperty varName title type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 3) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"string","@type":"' type '",' '"readOnly":' readonly)
}

to 'event definitions JSON' {
  local 'JSON' '{'
  if (_WoT_event_defs == 0) {
    _WoT_event_defs = ('[data:makeList]')
  }
  for 'event def' _WoT_event_defs {
    JSON = ('[data:join]' JSON '"' (at 1 (v 'event def')) '":{"description":"MicroBlocks event","@type":"' (at 2 (v 'event def')) '"},')
  }
  if ((size JSON) > 1) {
    return ('[data:join]' ('[data:copyFromTo]' JSON 1 ((size JSON) - 1)) '}')
  } else {
    return '{}'
  }
}

to 'events JSON' {
  local 'JSON' '['
  for event _WoT_events {
    JSON = ('[data:join]' JSON '{"' (at 1 event) '":{"data":{"id":' (at 2 event) '}}},')
  }
  if ((size JSON) > 1) {
    return ('[data:join]' ('[data:copyFromTo]' JSON 1 ((size JSON) - 1)) ']')
  } else {
    return '[]'
  }
}

to 'properties JSON' {
  local 'JSON' '{'
  if (or (_WoT_property_defs == 0) ((size _WoT_property_defs) == 0)) {
    for varName ('_varNames') {
      if (not ((at 1 varName) == '_')) {
        local 'value' ('[vars:varNamed]' varName)
        JSON = ('[data:join]' JSON '"' varName '":{"title":"' varName '","type":"' ('_type of' value) '","links":[{"href":"/properties/' varName '"}],"@type":""},')
      }
    }
  } else {
    for 'property def' _WoT_property_defs {
      local 'varName' (at 1 (v 'property def'))
      JSON = ('[data:join]' JSON '"' varName '":{"links":[{"href":"/properties/' varName '"}],' (at 2 (v 'property def')) '},')
    }
  }
  if ((at 'last' JSON) == ',') {
    JSON = ('[data:copyFromTo]' JSON 1 ((size JSON) - 1))
  }
  return ('[data:join]' JSON '}')
}

to 'register event' 'event title' 'event type' {
  local 'event def' ('[data:makeList]' (v 'event title') (v 'event type'))
  if (_WoT_event_defs == 0) {
    _WoT_event_defs = ('[data:makeList]')
  }
  for def _WoT_event_defs {
    if ((at 1 def) == (v 'event title')) {
      atPut 2 def (v 'event type')
      return ''
    }
  }
  '[data:addLast]' (v 'event def') _WoT_event_defs
}

to 'set thing capability to' capability {
  _WoT_capability = capability
}

to 'set thing name to' title {
  _WoT_title = title
}

to 'start WebThing server' {
  if (_WoT_title == 0) {'set thing name to' 'MicroBlocks thing'}
  if (_WoT_capability == 0) {'set thing capability to' ''}
  if ('[net:hasWiFi]') {
    if (_WoT_events == 0) {_WoT_events = ('[data:makeList]')}
    sendBroadcast '_WoT_start_server'
  } else {
    '_thing description' = ('thing description JSON')
  }
}

to 'thing description JSON' {
  return ('[data:join]' '{"title":"' _WoT_title '","@context":"https://webthings.io/schemas/","@type":["' _WoT_capability '"],"links":[{"rel":"events","href":"/events"},{"rel":"properties","href":"/properties"}],"properties":' ('properties JSON') ',"events":' ('event definitions JSON') '}')
}

to 'trigger event' 'event name' {
  if ('[net:hasWiFi]') {
    '[data:addLast]' ('[data:makeList]' (v 'event name') (millisOp)) _WoT_events
  } else {
    sendBroadcast (v 'event name')
  }
}


module WiFi Comm
author MicroBlocks
version 1 6 
tags communication network 
description 'Connect to a WiFi network. Used in conjunction with other network libraries, such as HTTP client, HTTP server or Web Thing.
'

  spec ' ' 'wifiConnect' 'wifi connect to _ password _ : IP _ gateway _ subnet _' 'str str auto auto auto' 'Network_Name' '' '192.168.1.42' '192.168.1.1' '255.255.255.0'
  spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
  spec 'r' 'getIPAddress' 'IP address'
  spec 'r' '[net:myMAC]' 'MAC address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to wifiConnect ssid password fixedIP gatewayIP subnetIP {
  if (not ('[net:hasWiFi]')) {return}
  '[net:stopWiFi]'
  if ((pushArgCount) < 5) {
    '[net:startWiFi]' ssid password
  } else {
    '[net:startWiFi]' ssid password false fixedIP gatewayIP subnetIP
  }
  local 'startMSecs' (millisOp)
  repeatUntil (('[net:myIPAddress]') != '0.0.0.0') {
    comment 'Timeout after N seconds'
    if (((millisOp) - startMSecs) > 30000) {
      sayIt 'Could not connect'
      return 0
    }
    comment 'Slow blink while trying to connect'
    setUserLED true
    waitMillis 300
    setUserLED false
    waitMillis 300
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  if ('Connected' != ('[net:wifiStatus]')) {
    sayIt 'Could not create hotspot'
    return 0
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

module main
author unknown
version 1 0 
description ''
variables _np_pixels _useWiFi on 

  spec ' ' 'cpx-LEDs' 'cpx-LEDs'
  spec ' ' 'microbit-LEDs' 'microbit-LEDs'

to 'cpx-LEDs' {
  if on {
    setNeoPixelColors10 (colorSwatch 191 63 4 255) (colorSwatch 191 119 4 255) (colorSwatch 179 191 11 255) (colorSwatch 56 191 1 255) (colorSwatch 4 191 146 255) (colorSwatch 2 128 191 255) (colorSwatch 4 23 191 255) (colorSwatch 57 2 191 255) (colorSwatch 191 4 138 255) (colorSwatch 191 1 7 255)
  } else {
    clearNeoPixels
  }
}

to 'microbit-LEDs' {
  if on {
    setUserLED true
    '[display:mbDisplay]' 15728622
  } else {
    setUserLED false
    '[display:mbDisplayOff]'
  }
}

script 57 57 {
comment 'This example lets you control the built-in LEDs of a board, much as you
might control a smart bulb using the WebThings Gateway UI.'
}

script 542 83 {
to 'microbit-LEDs' {}
}

script 59 138 {
whenStarted
wifiConnect 'Network_Name' ''
'set thing name to' 'Hello LED'
'set thing capability to' 'Light'
addBooleanProperty 'on' 'On' 'OnOffProperty'
'start WebThing server'
setUserLED true
waitMillis 500
setUserLED false
on = (booleanConstant false)
forever {
  if (or ((boardType) == 'CircuitPlayground') ((boardType) == 'CircuitPlayground Bluefruit')) {
    'cpx-LEDs'
  } else {
    'microbit-LEDs'
  }
  waitMillis 50
}
}

script 253 274 {
whenButtonPressed 'A'
comment 'To test, click to toggle the LED.'
on = (not on)
}

script 431 375 {
to 'cpx-LEDs' {}
}

script 352 618 {
comment 'Check thing description'
sayIt ('thing description JSON')
}

script 78 620 {
comment 'Click to check IP address'
sayIt (getIPAddress)
}


module 'HTTP server' Comm
author MicroBlocks
version 1 3 
depends WiFi 
tags http network 
description 'Create an HTTP server in MicroBlocks. You can use this library to allow remote control for your Wifi-enabled board.'

  spec 'r' '[net:httpServerGetRequest]' 'HTTP server request : binary data _ : port _' 'bool num' false 8080
  spec 'r' 'request method' 'method of request _' 'str' ''
  spec 'r' 'path of request' 'path of request _' 'str' ''
  spec 'r' 'headers of request' 'headers of request _' 'str' ''
  spec 'r' 'body of request' 'body of request _' 'str' ''
  spec 'r' 'content length of request' 'content length of request _' 'str' ''
  spec ' ' '[net:respondToHttpRequest]' 'respond _ to HTTP request : with body _ : and headers _ : keepAlive _' 'str str str bool' '200 OK' 'Welcome to the MicroBlocks HTTP server' 'Content-Type: text/plain' false
  spec 'r' '_endOfHeaders' '_end of headers _' 'str'
  spec 'r' '_toString' '_toString _' 'auto' 'abc'

to '_endOfHeaders' request {
  return ('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) request)
}

to '_toString' aStringOrByteArray {
  comment 'If argument is a byte array, convert it to a string. '
  if (not (isType aStringOrByteArray 'string')) {
    aStringOrByteArray = ('[data:join]' '' aStringOrByteArray)
  }
  return aStringOrByteArray
}

to 'body of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('[data:copyFromTo]' request (i + 4))
}

to 'content length of request' request {
  local 'i' ('_endOfHeaders' request)
  if (i < 0) {
    return 0
  }
  local 'j' ('[data:find]' 'Content-Length: ' request)
  if (j < 0) {
    comment 'Try alternate capitalization'
    j = ('[data:find]' 'Content-length: ' request)
  }
  if (or (j < 0) (j > i)) {
    return 0
  }
  j += 16
  local 'k' ('[data:find]' ('[data:unicodeString]' 13) request j)
  return (('[data:copyFromTo]' request j (k - 1)) + 0)
}

to 'headers of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('_toString' ('[data:copyFromTo]' request 1 (i - 1)))
}

to 'path of request' request {
  return ('_toString' ('[data:copyFromTo]' request (('[data:find]' ' ' request) + 1) (('[data:find]' ' HTTP' request) - 1)))
}

to 'request method' request {
  return ('_toString' ('[data:copyFromTo]' request 1 (('[data:find]' ' ' request) - 1)))
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}


module NeoPixel Output
author MicroBlocks
version 1 6 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if ((boardType) == 'M5Atom-Matrix') {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'Mbits') {
    neoPixelAttach 25 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'r' ((rgb >> 16) & 255)
    local 'g' ((rgb >> 8) & 255)
    local 'b' (rgb & 255)
    local 'brightness' (maximum r g b)
    if (delta > 0) {
      delta = (minimum delta (255 - brightness))
    } else {
      delta = (maximum delta (42 - brightness))
    }
    r = (maximum 0 (minimum (r + delta) 255))
    g = (maximum 0 (minimum (g + delta) 255))
    b = (maximum 0 (minimum (b + delta) 255))
    atPut i _np_pixels (colorFromRGB r g b)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_update' {
  '[display:neoPixelSend]' _np_pixels
  waitMicros 100
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  hasWhite = false
  if ((pushArgCount) > 2) {
    hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  fillList _np_pixels 0
  '[display:neoPixelSetPin]' pinNumber hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels color
  '_NeoPixel_update'
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' (n > 0)
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}


module WebThings Comm
author MicroBlocks
version 3 4 
depends 'HTTP server' WiFi 
tags iot webthing wot 
choices thingTypesMenu Alarm BinarySensor ColorControl ColorSensor DoorSensor EnergyMonitor LeakSensor Light Lock MotionSensor MultiLevelSensor MultiLevelSwitch OnOffSwitch PushButton SmartPlug TemperatureSensor Thermostat 
choices thingEventTypesMenu OverheatedEvent PressedEvent DoublePressedEvent LongPressedEvent AlarmEvent 
choices numberPropertyTypesMenu LevelProperty BrightnessProperty ColorTemperatureProperty InstantaneousPowerProperty CurrentProperty VoltageProperty FrequencyProperty TargetTemperatureProperty TemperatureProperty 
choices booleanPropertyTypesMenu BooleanProperty OnOffProperty MotionProperty OpenProperty LeakProperty PushedProperty AlarmProperty 
choices stringPropertyTypesMenu ColorProperty TextProperty HeatingCoolingProperty LockedProperty ThermostatModeProperty 
description 'Create WebThings as specified by the WebThings schema and protocol. If your board is WiFi enabled, you can serve its thing description directly via HTTP. Otherwise, you can enable the MicroBlocks add-on in the WebThings Gateway.
'
variables _WoT_title _WoT_events _WoT_capability _WoT_event_defs _WoT_property_defs '_thing description' 

  spec ' ' 'set thing name to' 'set thing name to _' 'auto' 'MicroBlocks thing'
  spec ' ' 'set thing capability to' 'set thing capability to _' 'str.thingTypesMenu' 'Light'
  spec ' ' 'addBooleanProperty' 'set boolean property _ title _ @Type _ : read only _' 'menu.allVarsMenu str str.booleanPropertyTypesMenu bool' '' '' 'OnOffProperty' false
  spec ' ' 'addStringProperty' 'set string property _ title _ @Type _ : read only _' 'menu.allVarsMenu str str.stringPropertyTypesMenu bool' '' '' 'ColorProperty' false
  spec ' ' 'addNumProp' 'set number property _ title _ min _ max _ @Type _ : read only _' 'menu.allVarsMenu str num num str.numberPropertyTypesMenu bool' '' '' 0 100 'LevelProperty' false
  spec ' ' 'register event' 'register event _ type _' 'auto str.thingEventTypesMenu' 'Button A pressed' 'PressedEvent'
  spec ' ' 'start WebThing server' 'start WebThing server'
  spec ' ' 'trigger event' 'trigger event _' 'auto' 'button pressed'
  spec 'r' 'thing description JSON' 'thing description JSON'
  spec 'r' 'properties JSON' 'properties JSON'
  spec 'r' 'event definitions JSON' 'event definitions JSON'
  spec 'r' 'events JSON' 'events JSON'
  spec ' ' '_process OPTIONS request' '_process OPTIONS request _' 'auto' ''
  spec ' ' '_process PUT request' '_process PUT request _' 'auto' ''
  spec ' ' '_process request' '_process GET request _' 'auto' ''
  spec ' ' '_respond 404 Not Found' '_respond 404 Not Found'
  spec 'r' '_JSON value' '_JSON value _' 'auto' '10'
  spec 'r' '_parse JSON value' '_parse JSON value _' 'auto' ''
  spec 'r' '_trimmed' '_trimmed _' 'auto' '  hello    '
  spec ' ' '_WoT_start_server' '_WoT_start_server'
  spec 'r' '_type of' '_type of _' 'auto' '10'
  spec ' ' '_add or replace property' '_add or replace property _ attributes _' 'menu.nil str' '' ''
  spec ' ' '_clear thing description' '_clear thing description'
  spec 'r' '_varNames' '_varNames'

to '_JSON value' value {
  local 'JSON value' ''
  if (isType value 'string') {
    'JSON value' = ('[data:join]' '"' value '"')
  } (isType value 'list') {
    'JSON value' = '['
    for item value {
      'JSON value' = ('[data:join]' (v 'JSON value') ('_JSON value' item) ',')
    }
    'JSON value' = ('[data:join]' ('[data:copyFromTo]' (v 'JSON value') 1 ((size (v 'JSON value')) - 1)) ']')
  } (isType value 'boolean') {
    if value {
      'JSON value' = 'true'
    } else {
      'JSON value' = 'false'
    }
  } else {
    'JSON value' = value
  }
  return (v 'JSON value')
}

to '_WoT_start_server' {
  local 'request' ''
  forever {
    request = ('[net:httpServerGetRequest]')
    if (request != '') {
      if (('request method' request) == 'GET') {
        '_process request' request
      } (('request method' request) == 'PUT') {
        '_process PUT request' request
      } (('request method' request) == 'OPTIONS') {
        '_process OPTIONS request' request
      } else {
        '_respond 404 Not Found'
      }
    }
    waitMillis 50
  }
}

to '_add or replace property' varName 'attributes JSON' {
  if (_WoT_property_defs == 0) {_WoT_property_defs = ('[data:makeList]')}
  for def _WoT_property_defs {
    if ((at 1 def) == varName) {
      atPut 2 def (v 'attributes JSON')
      return ''
    }
  }
  '[data:addLast]' ('[data:makeList]' varName (v 'attributes JSON')) _WoT_property_defs
}

to '_clear thing description' {
  '_thing description' = 0
}

to '_parse JSON value' JSON {
  local 'value' ('_trimmed' JSON)
  if ((at 1 value) == '[') {
    comment 'Doesn''t handle multi-dimensional lists'
    local 'list' ('[data:makeList]')
    value = ('[data:copyFromTo]' value 2 ((size value) - 1))
    local 'comma index' ('[data:find]' ',' value)
    repeatUntil ((v 'comma index') == -1) {
      '[data:addLast]' ('_parse JSON value' ('[data:copyFromTo]' value 1 ((v 'comma index') - 1))) list
      value = ('[data:copyFromTo]' value ((v 'comma index') + 1))
      'comma index' = ('[data:find]' ',' value)
    }
    '[data:addLast]' ('_parse JSON value' value) list
    value = list
  } else {
    value = ('[misc:jsonGet]' value '')
  }
  return value
}

to '_process OPTIONS request' req {
  local 'path' ('path of request' req)
  '[net:respondToHttpRequest]' '200 OK' '' 'Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: PUT, GET, OPTIONS
Access-Control-Allow-Headers: Content-Type'
}

to '_process PUT request' req {
  local 'path' ('path of request' req)
  if (('[data:find]' '/properties/' path) > 0) {
    local 'varName' ('[data:copyFromTo]' path 13)
    if ('[vars:varExists]' varName) {
      local 'body' ('body of request' req)
      '[vars:setVarNamed]' varName ('_parse JSON value' ('[data:copyFromTo]' body (('[data:find]' ':' body) + 1) (('[data:find]' '}' body) - 1)))
      '[net:respondToHttpRequest]' '200 OK' ('[data:join]' '{"' varName '":' ('_JSON value' ('[vars:varNamed]' varName)) '}') 'Content-Type: application/json'
    } else {
      '_respond 404 Not Found'
    }
  } else {
    '_respond 404 Not Found'
  }
}

to '_process request' req {
  local 'path' ('path of request' req)
  if (path == '/') {
    '[net:respondToHttpRequest]' '200 OK' ('thing description JSON') 'Content-Type: application/json'
  } (or (path == '/properties') (path == '/properties/')) {
    '[net:respondToHttpRequest]' '200 OK' ('properties JSON') 'Content-Type: application/json'
  } (('[data:find]' '/properties/' path) > 0) {
    local 'varName' ('[data:copyFromTo]' path 13)
    if ('[vars:varExists]' varName) {
      '[net:respondToHttpRequest]' '200 OK' ('[data:join]' '{"' varName '":' ('_JSON value' ('[vars:varNamed]' varName)) '}') 'Content-Type: application/json'
    } else {
      '_respond 404 Not Found'
    }
  } (or (path == '/events') (path == '/events/')) {
    '[net:respondToHttpRequest]' '200 OK' ('events JSON') 'Content-Type: application/json'
    _WoT_events = ('[data:makeList]')
  } else {
    '_respond 404 Not Found'
  }
}

to '_respond 404 Not Found' {
  '[net:respondToHttpRequest]' '404 Not Found' '{ "error":"Resource not found" }' 'Content-Type: application/json'
}

to '_trimmed' string {
  comment 'remove surrounding spaces'
  repeatUntil ((at 1 string) != ' ') {
    string = ('[data:copyFromTo]' string 2)
  }
  repeatUntil ((at 'last' string) != ' ') {
    string = ('[data:copyFromTo]' string 1 ((size string) - 1))
  }
  return string
}

to '_type of' value {
  if (isType value 'number') {
    return 'number'
  } (isType value 'list') {
    return 'array'
  } (isType value 'string') {
    return 'string'
  } (isType value 'boolean') {
    return 'boolean'
  }
  comment 'should never happen'
  return 'null'
}

to '_varNames' {
  local 'result' ('[data:makeList]')
  local 'count' ('[vars:varNameForIndex]' -1)
  for i count {
    local 'varName' ('[vars:varNameForIndex]' i)
    if (isType varName 'string') {
      '[data:addLast]' varName result
    }
  }
  return result
}

to addBooleanProperty varName title type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 3) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"boolean","@type":"' type '",' '"readOnly":' readonly)
}

to addNumProp varName title min max type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 5) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"number","@type":"' type '",' '"readOnly":' readonly ',"minimum":' min ',"maximum":' max)
}

to addStringProperty varName title type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 3) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"string","@type":"' type '",' '"readOnly":' readonly)
}

to 'event definitions JSON' {
  local 'JSON' '{'
  if (_WoT_event_defs == 0) {
    _WoT_event_defs = ('[data:makeList]')
  }
  for 'event def' _WoT_event_defs {
    JSON = ('[data:join]' JSON '"' (at 1 (v 'event def')) '":{"description":"MicroBlocks event","@type":"' (at 2 (v 'event def')) '"},')
  }
  if ((size JSON) > 1) {
    return ('[data:join]' ('[data:copyFromTo]' JSON 1 ((size JSON) - 1)) '}')
  } else {
    return '{}'
  }
}

to 'events JSON' {
  local 'JSON' '['
  for event _WoT_events {
    JSON = ('[data:join]' JSON '{"' (at 1 event) '":{"data":{"id":' (at 2 event) '}}},')
  }
  if ((size JSON) > 1) {
    return ('[data:join]' ('[data:copyFromTo]' JSON 1 ((size JSON) - 1)) ']')
  } else {
    return '[]'
  }
}

to 'properties JSON' {
  local 'JSON' '{'
  if (or (_WoT_property_defs == 0) ((size _WoT_property_defs) == 0)) {
    for varName ('_varNames') {
      if (not ((at 1 varName) == '_')) {
        local 'value' ('[vars:varNamed]' varName)
        JSON = ('[data:join]' JSON '"' varName '":{"title":"' varName '","type":"' ('_type of' value) '","links":[{"href":"/properties/' varName '"}],"@type":""},')
      }
    }
  } else {
    for 'property def' _WoT_property_defs {
      local 'varName' (at 1 (v 'property def'))
      JSON = ('[data:join]' JSON '"' varName '":{"links":[{"href":"/properties/' varName '"}],' (at 2 (v 'property def')) '},')
    }
  }
  if ((at 'last' JSON) == ',') {
    JSON = ('[data:copyFromTo]' JSON 1 ((size JSON) - 1))
  }
  return ('[data:join]' JSON '}')
}

to 'register event' 'event title' 'event type' {
  local 'event def' ('[data:makeList]' (v 'event title') (v 'event type'))
  if (_WoT_event_defs == 0) {
    _WoT_event_defs = ('[data:makeList]')
  }
  for def _WoT_event_defs {
    if ((at 1 def) == (v 'event title')) {
      atPut 2 def (v 'event type')
      return ''
    }
  }
  '[data:addLast]' (v 'event def') _WoT_event_defs
}

to 'set thing capability to' capability {
  _WoT_capability = capability
}

to 'set thing name to' title {
  _WoT_title = title
}

to 'start WebThing server' {
  if (_WoT_title == 0) {'set thing name to' 'MicroBlocks thing'}
  if (_WoT_capability == 0) {'set thing capability to' ''}
  if ('[net:hasWiFi]') {
    if (_WoT_events == 0) {_WoT_events = ('[data:makeList]')}
    sendBroadcast '_WoT_start_server'
  } else {
    '_thing description' = ('thing description JSON')
  }
}

to 'thing description JSON' {
  return ('[data:join]' '{"title":"' _WoT_title '","@context":"https://webthings.io/schemas/","@type":["' _WoT_capability '"],"links":[{"rel":"events","href":"/events"},{"rel":"properties","href":"/properties"}],"properties":' ('properties JSON') ',"events":' ('event definitions JSON') '}')
}

to 'trigger event' 'event name' {
  if ('[net:hasWiFi]') {
    '[data:addLast]' ('[data:makeList]' (v 'event name') (millisOp)) _WoT_events
  } else {
    sendBroadcast (v 'event name')
  }
}


module WiFi Comm
author MicroBlocks
version 1 6 
tags communication network 
description 'Connect to a WiFi network. Used in conjunction with other network libraries, such as HTTP client, HTTP server or Web Thing.
'

  spec ' ' 'wifiConnect' 'wifi connect to _ password _ : IP _ gateway _ subnet _' 'str str auto auto auto' 'Network_Name' '' '192.168.1.42' '192.168.1.1' '255.255.255.0'
  spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
  spec 'r' 'getIPAddress' 'IP address'
  spec 'r' '[net:myMAC]' 'MAC address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to wifiConnect ssid password fixedIP gatewayIP subnetIP {
  if (not ('[net:hasWiFi]')) {return}
  '[net:stopWiFi]'
  if ((pushArgCount) < 5) {
    '[net:startWiFi]' ssid password
  } else {
    '[net:startWiFi]' ssid password false fixedIP gatewayIP subnetIP
  }
  local 'startMSecs' (millisOp)
  repeatUntil (('[net:myIPAddress]') != '0.0.0.0') {
    comment 'Timeout after N seconds'
    if (((millisOp) - startMSecs) > 30000) {
      sayIt 'Could not connect'
      return 0
    }
    comment 'Slow blink while trying to connect'
    setUserLED true
    waitMillis 300
    setUserLED false
    waitMillis 300
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  if ('Connected' != ('[net:wifiStatus]')) {
    sayIt 'Could not create hotspot'
    return 0
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

module main
author unknown
version 1 0 
description ''
variables _WoT_definingEvents _useWiFi 

script 57 57 {
comment 'Web of Things pushbutton example.

To test it, either press, long-press or double-press the A button
in your board and look at the display.'
}

script 62 151 {
whenStarted
wifiConnect 'Network_Name' ''
'set thing name to' 'microButton'
'set thing capability to' 'PushButton'
'register event' 'Button pressed' 'PressedEvent'
'register event' 'Button double-pressed' 'DoublePressedEvent'
'register event' 'Button long-pressed' 'LongPressedEvent'
'start WebThing server'
}

script 470 151 {
whenCondition ('button double pressed' 'A')
'trigger event' 'Button double-pressed'
setUserLED true
waitMillis 100
setUserLED false
waitMillis 100
setUserLED true
waitMillis 100
setUserLED false
}

script 64 369 {
whenCondition ('button long pressed' 'A')
'trigger event' 'Button long-pressed'
setUserLED true
waitMillis 1500
setUserLED false
}

script 298 370 {
whenCondition ('button pressed' 'A')
'trigger event' 'Button pressed'
setUserLED true
waitMillis 100
setUserLED false
}


module 'Button Events' Input
author MicroBlocks
version 1 0 
tags event button double long press 
description 'Provides blocks to detect press, long press and double press events on buttons.'
variables _buttons 

  spec 'r' 'button double pressed' 'button _ double pressed' 'auto' 'A'
  spec 'r' 'button long pressed' 'button _ long pressed' 'auto' 5
  spec 'r' 'button pressed' 'button _ pressed' 'auto' 5
  spec 'r' '_button' '_button _' 'auto' 10
  spec ' ' '_updateButtons' '_updateButtons'
  spec 'r' '_read button' '_read button _' 'auto' 10

to '_button' 'pin or name' {
  '_updateButtons'
  for 'each button' _buttons {
    if ((at 1 (v 'each button')) == (v 'pin or name')) {return (v 'each button')}
  }
  comment 'This button has not been initialized. Let''s add it.'
  local 'new button' ('[data:makeList]' (v 'pin or name') '' '' 'waiting')
  '[data:addLast]' (v 'new button') _buttons
  return (v 'new button')
}

to '_read button' 'pin or name' {
  if ((v 'pin or name') == 'A') {
    return (buttonA)
  } ((v 'pin or name') == 'B') {
    return (buttonB)
  } else {
    return (digitalReadOp (v 'pin or name'))
  }
}

to '_updateButtons' {
  if (_buttons == 0) {_buttons = ('[data:makeList]')}
  for button _buttons {
    local 'currently pressed' ('_read button' (at 1 button))
    local 'previous state' (at 4 button)
    if (and ((v 'previous state') == 'waiting') (v 'currently pressed')) {
      comment 'save state change time'
      atPut 2 button (millisOp)
      atPut 3 button (v 'currently pressed')
      atPut 4 button 'pressed'
    } (and ((v 'previous state') == 'pressed') (not (v 'currently pressed'))) {
      local 'press time' ((millisOp) - (at 2 button))
      comment 'There''s been a press. Let''s check how long it was.'
      if ((v 'press time') > 500) {
        atPut 4 button 'long press'
      } ((v 'press time') > 250) {
        atPut 4 button 'single press'
      } else {
        comment 'This is an internal intermediate state.
It could turn out to be a single press or a double press.'
        atPut 2 button (millisOp)
        atPut 4 button 'short press'
      }
    } (and ((v 'previous state') == 'short press') (v 'currently pressed')) {
      atPut 4 button 'double press'
    } (and (and ((v 'previous state') == 'short press') (not (v 'currently pressed'))) (((millisOp) - (at 2 button)) > 250)) {
      atPut 4 button 'single press'
    } (and ((v 'previous state') == 'double press handled') (not (v 'currently pressed'))) {
      comment 'We only go back to "waiting" after a double press if the event has been handled
and the user has released the button. Otherwise we''ll cause false "single press"
positives.'
      atPut 4 button 'waiting'
    }
  }
}

to 'button double pressed' 'pin or name' {
  local 'button' ('_button' (v 'pin or name'))
  local 'state' (at 4 button)
  if (state == 'double press') {
    comment 'We only go back to "waiting" after a double press if the event has been handled
and the user has released the button. Otherwise we''ll cause false "single press"
positives.'
    atPut 4 button 'double press handled'
    return (booleanConstant true)
  }
  return (booleanConstant false)
}

to 'button long pressed' 'pin or name' {
  local 'button' ('_button' (v 'pin or name'))
  local 'state' (at 4 button)
  if (state == 'long press') {
    atPut 4 button 'waiting'
    return (booleanConstant true)
  }
  return (booleanConstant false)
}

to 'button pressed' 'pin or name' {
  local 'button' ('_button' (v 'pin or name'))
  local 'state' (at 4 button)
  if (state == 'single press') {
    atPut 4 button 'waiting'
    return (booleanConstant true)
  }
  return (booleanConstant false)
}


module 'HTTP server' Comm
author MicroBlocks
version 1 3 
depends WiFi 
tags http network 
description 'Create an HTTP server in MicroBlocks. You can use this library to allow remote control for your Wifi-enabled board.'

  spec 'r' '[net:httpServerGetRequest]' 'HTTP server request : binary data _ : port _' 'bool num' false 8080
  spec 'r' 'request method' 'method of request _' 'str' ''
  spec 'r' 'path of request' 'path of request _' 'str' ''
  spec 'r' 'headers of request' 'headers of request _' 'str' ''
  spec 'r' 'body of request' 'body of request _' 'str' ''
  spec 'r' 'content length of request' 'content length of request _' 'str' ''
  spec ' ' '[net:respondToHttpRequest]' 'respond _ to HTTP request : with body _ : and headers _ : keepAlive _' 'str str str bool' '200 OK' 'Welcome to the MicroBlocks HTTP server' 'Content-Type: text/plain' false
  spec 'r' '_endOfHeaders' '_end of headers _' 'str'
  spec 'r' '_toString' '_toString _' 'auto' 'abc'

to '_endOfHeaders' request {
  return ('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) request)
}

to '_toString' aStringOrByteArray {
  comment 'If argument is a byte array, convert it to a string. '
  if (not (isType aStringOrByteArray 'string')) {
    aStringOrByteArray = ('[data:join]' '' aStringOrByteArray)
  }
  return aStringOrByteArray
}

to 'body of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('[data:copyFromTo]' request (i + 4))
}

to 'content length of request' request {
  local 'i' ('_endOfHeaders' request)
  if (i < 0) {
    return 0
  }
  local 'j' ('[data:find]' 'Content-Length: ' request)
  if (j < 0) {
    comment 'Try alternate capitalization'
    j = ('[data:find]' 'Content-length: ' request)
  }
  if (or (j < 0) (j > i)) {
    return 0
  }
  j += 16
  local 'k' ('[data:find]' ('[data:unicodeString]' 13) request j)
  return (('[data:copyFromTo]' request j (k - 1)) + 0)
}

to 'headers of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('_toString' ('[data:copyFromTo]' request 1 (i - 1)))
}

to 'path of request' request {
  return ('_toString' ('[data:copyFromTo]' request (('[data:find]' ' ' request) + 1) (('[data:find]' ' HTTP' request) - 1)))
}

to 'request method' request {
  return ('_toString' ('[data:copyFromTo]' request 1 (('[data:find]' ' ' request) - 1)))
}


module WebThings Comm
author MicroBlocks
version 3 4 
depends 'HTTP server' WiFi 
tags iot webthing wot 
choices thingTypesMenu Alarm BinarySensor ColorControl ColorSensor DoorSensor EnergyMonitor LeakSensor Light Lock MotionSensor MultiLevelSensor MultiLevelSwitch OnOffSwitch PushButton SmartPlug TemperatureSensor Thermostat 
choices thingEventTypesMenu OverheatedEvent PressedEvent DoublePressedEvent LongPressedEvent AlarmEvent 
choices numberPropertyTypesMenu LevelProperty BrightnessProperty ColorTemperatureProperty InstantaneousPowerProperty CurrentProperty VoltageProperty FrequencyProperty TargetTemperatureProperty TemperatureProperty 
choices booleanPropertyTypesMenu BooleanProperty OnOffProperty MotionProperty OpenProperty LeakProperty PushedProperty AlarmProperty 
choices stringPropertyTypesMenu ColorProperty TextProperty HeatingCoolingProperty LockedProperty ThermostatModeProperty 
description 'Create WebThings as specified by the WebThings schema and protocol. If your board is WiFi enabled, you can serve its thing description directly via HTTP. Otherwise, you can enable the MicroBlocks add-on in the WebThings Gateway.
'
variables _WoT_title _WoT_events _WoT_capability _WoT_event_defs _WoT_property_defs '_thing description' 

  spec ' ' 'set thing name to' 'set thing name to _' 'auto' 'MicroBlocks thing'
  spec ' ' 'set thing capability to' 'set thing capability to _' 'str.thingTypesMenu' 'Light'
  spec ' ' 'addBooleanProperty' 'set boolean property _ title _ @Type _ : read only _' 'menu.allVarsMenu str str.booleanPropertyTypesMenu bool' '' '' 'OnOffProperty' false
  spec ' ' 'addStringProperty' 'set string property _ title _ @Type _ : read only _' 'menu.allVarsMenu str str.stringPropertyTypesMenu bool' '' '' 'ColorProperty' false
  spec ' ' 'addNumProp' 'set number property _ title _ min _ max _ @Type _ : read only _' 'menu.allVarsMenu str num num str.numberPropertyTypesMenu bool' '' '' 0 100 'LevelProperty' false
  spec ' ' 'register event' 'register event _ type _' 'auto str.thingEventTypesMenu' 'Button A pressed' 'PressedEvent'
  spec ' ' 'start WebThing server' 'start WebThing server'
  spec ' ' 'trigger event' 'trigger event _' 'auto' 'button pressed'
  spec 'r' 'thing description JSON' 'thing description JSON'
  spec 'r' 'properties JSON' 'properties JSON'
  spec 'r' 'event definitions JSON' 'event definitions JSON'
  spec 'r' 'events JSON' 'events JSON'
  spec ' ' '_process OPTIONS request' '_process OPTIONS request _' 'auto' ''
  spec ' ' '_process PUT request' '_process PUT request _' 'auto' ''
  spec ' ' '_process request' '_process GET request _' 'auto' ''
  spec ' ' '_respond 404 Not Found' '_respond 404 Not Found'
  spec 'r' '_JSON value' '_JSON value _' 'auto' '10'
  spec 'r' '_parse JSON value' '_parse JSON value _' 'auto' ''
  spec 'r' '_trimmed' '_trimmed _' 'auto' '  hello    '
  spec ' ' '_WoT_start_server' '_WoT_start_server'
  spec 'r' '_type of' '_type of _' 'auto' '10'
  spec ' ' '_add or replace property' '_add or replace property _ attributes _' 'menu.nil str' '' ''
  spec ' ' '_clear thing description' '_clear thing description'
  spec 'r' '_varNames' '_varNames'

to '_JSON value' value {
  local 'JSON value' ''
  if (isType value 'string') {
    'JSON value' = ('[data:join]' '"' value '"')
  } (isType value 'list') {
    'JSON value' = '['
    for item value {
      'JSON value' = ('[data:join]' (v 'JSON value') ('_JSON value' item) ',')
    }
    'JSON value' = ('[data:join]' ('[data:copyFromTo]' (v 'JSON value') 1 ((size (v 'JSON value')) - 1)) ']')
  } (isType value 'boolean') {
    if value {
      'JSON value' = 'true'
    } else {
      'JSON value' = 'false'
    }
  } else {
    'JSON value' = value
  }
  return (v 'JSON value')
}

to '_WoT_start_server' {
  local 'request' ''
  forever {
    request = ('[net:httpServerGetRequest]')
    if (request != '') {
      if (('request method' request) == 'GET') {
        '_process request' request
      } (('request method' request) == 'PUT') {
        '_process PUT request' request
      } (('request method' request) == 'OPTIONS') {
        '_process OPTIONS request' request
      } else {
        '_respond 404 Not Found'
      }
    }
    waitMillis 50
  }
}

to '_add or replace property' varName 'attributes JSON' {
  if (_WoT_property_defs == 0) {_WoT_property_defs = ('[data:makeList]')}
  for def _WoT_property_defs {
    if ((at 1 def) == varName) {
      atPut 2 def (v 'attributes JSON')
      return ''
    }
  }
  '[data:addLast]' ('[data:makeList]' varName (v 'attributes JSON')) _WoT_property_defs
}

to '_clear thing description' {
  '_thing description' = 0
}

to '_parse JSON value' JSON {
  local 'value' ('_trimmed' JSON)
  if ((at 1 value) == '[') {
    comment 'Doesn''t handle multi-dimensional lists'
    local 'list' ('[data:makeList]')
    value = ('[data:copyFromTo]' value 2 ((size value) - 1))
    local 'comma index' ('[data:find]' ',' value)
    repeatUntil ((v 'comma index') == -1) {
      '[data:addLast]' ('_parse JSON value' ('[data:copyFromTo]' value 1 ((v 'comma index') - 1))) list
      value = ('[data:copyFromTo]' value ((v 'comma index') + 1))
      'comma index' = ('[data:find]' ',' value)
    }
    '[data:addLast]' ('_parse JSON value' value) list
    value = list
  } else {
    value = ('[misc:jsonGet]' value '')
  }
  return value
}

to '_process OPTIONS request' req {
  local 'path' ('path of request' req)
  '[net:respondToHttpRequest]' '200 OK' '' 'Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: PUT, GET, OPTIONS
Access-Control-Allow-Headers: Content-Type'
}

to '_process PUT request' req {
  local 'path' ('path of request' req)
  if (('[data:find]' '/properties/' path) > 0) {
    local 'varName' ('[data:copyFromTo]' path 13)
    if ('[vars:varExists]' varName) {
      local 'body' ('body of request' req)
      '[vars:setVarNamed]' varName ('_parse JSON value' ('[data:copyFromTo]' body (('[data:find]' ':' body) + 1) (('[data:find]' '}' body) - 1)))
      '[net:respondToHttpRequest]' '200 OK' ('[data:join]' '{"' varName '":' ('_JSON value' ('[vars:varNamed]' varName)) '}') 'Content-Type: application/json'
    } else {
      '_respond 404 Not Found'
    }
  } else {
    '_respond 404 Not Found'
  }
}

to '_process request' req {
  local 'path' ('path of request' req)
  if (path == '/') {
    '[net:respondToHttpRequest]' '200 OK' ('thing description JSON') 'Content-Type: application/json'
  } (or (path == '/properties') (path == '/properties/')) {
    '[net:respondToHttpRequest]' '200 OK' ('properties JSON') 'Content-Type: application/json'
  } (('[data:find]' '/properties/' path) > 0) {
    local 'varName' ('[data:copyFromTo]' path 13)
    if ('[vars:varExists]' varName) {
      '[net:respondToHttpRequest]' '200 OK' ('[data:join]' '{"' varName '":' ('_JSON value' ('[vars:varNamed]' varName)) '}') 'Content-Type: application/json'
    } else {
      '_respond 404 Not Found'
    }
  } (or (path == '/events') (path == '/events/')) {
    '[net:respondToHttpRequest]' '200 OK' ('events JSON') 'Content-Type: application/json'
    _WoT_events = ('[data:makeList]')
  } else {
    '_respond 404 Not Found'
  }
}

to '_respond 404 Not Found' {
  '[net:respondToHttpRequest]' '404 Not Found' '{ "error":"Resource not found" }' 'Content-Type: application/json'
}

to '_trimmed' string {
  comment 'remove surrounding spaces'
  repeatUntil ((at 1 string) != ' ') {
    string = ('[data:copyFromTo]' string 2)
  }
  repeatUntil ((at 'last' string) != ' ') {
    string = ('[data:copyFromTo]' string 1 ((size string) - 1))
  }
  return string
}

to '_type of' value {
  if (isType value 'number') {
    return 'number'
  } (isType value 'list') {
    return 'array'
  } (isType value 'string') {
    return 'string'
  } (isType value 'boolean') {
    return 'boolean'
  }
  comment 'should never happen'
  return 'null'
}

to '_varNames' {
  local 'result' ('[data:makeList]')
  local 'count' ('[vars:varNameForIndex]' -1)
  for i count {
    local 'varName' ('[vars:varNameForIndex]' i)
    if (isType varName 'string') {
      '[data:addLast]' varName result
    }
  }
  return result
}

to addBooleanProperty varName title type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 3) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"boolean","@type":"' type '",' '"readOnly":' readonly)
}

to addNumProp varName title min max type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 5) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"number","@type":"' type '",' '"readOnly":' readonly ',"minimum":' min ',"maximum":' max)
}

to addStringProperty varName title type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 3) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"string","@type":"' type '",' '"readOnly":' readonly)
}

to 'event definitions JSON' {
  local 'JSON' '{'
  if (_WoT_event_defs == 0) {
    _WoT_event_defs = ('[data:makeList]')
  }
  for 'event def' _WoT_event_defs {
    JSON = ('[data:join]' JSON '"' (at 1 (v 'event def')) '":{"description":"MicroBlocks event","@type":"' (at 2 (v 'event def')) '"},')
  }
  if ((size JSON) > 1) {
    return ('[data:join]' ('[data:copyFromTo]' JSON 1 ((size JSON) - 1)) '}')
  } else {
    return '{}'
  }
}

to 'events JSON' {
  local 'JSON' '['
  for event _WoT_events {
    JSON = ('[data:join]' JSON '{"' (at 1 event) '":{"data":{"id":' (at 2 event) '}}},')
  }
  if ((size JSON) > 1) {
    return ('[data:join]' ('[data:copyFromTo]' JSON 1 ((size JSON) - 1)) ']')
  } else {
    return '[]'
  }
}

to 'properties JSON' {
  local 'JSON' '{'
  if (or (_WoT_property_defs == 0) ((size _WoT_property_defs) == 0)) {
    for varName ('_varNames') {
      if (not ((at 1 varName) == '_')) {
        local 'value' ('[vars:varNamed]' varName)
        JSON = ('[data:join]' JSON '"' varName '":{"title":"' varName '","type":"' ('_type of' value) '","links":[{"href":"/properties/' varName '"}],"@type":""},')
      }
    }
  } else {
    for 'property def' _WoT_property_defs {
      local 'varName' (at 1 (v 'property def'))
      JSON = ('[data:join]' JSON '"' varName '":{"links":[{"href":"/properties/' varName '"}],' (at 2 (v 'property def')) '},')
    }
  }
  if ((at 'last' JSON) == ',') {
    JSON = ('[data:copyFromTo]' JSON 1 ((size JSON) - 1))
  }
  return ('[data:join]' JSON '}')
}

to 'register event' 'event title' 'event type' {
  local 'event def' ('[data:makeList]' (v 'event title') (v 'event type'))
  if (_WoT_event_defs == 0) {
    _WoT_event_defs = ('[data:makeList]')
  }
  for def _WoT_event_defs {
    if ((at 1 def) == (v 'event title')) {
      atPut 2 def (v 'event type')
      return ''
    }
  }
  '[data:addLast]' (v 'event def') _WoT_event_defs
}

to 'set thing capability to' capability {
  _WoT_capability = capability
}

to 'set thing name to' title {
  _WoT_title = title
}

to 'start WebThing server' {
  if (_WoT_title == 0) {'set thing name to' 'MicroBlocks thing'}
  if (_WoT_capability == 0) {'set thing capability to' ''}
  if ('[net:hasWiFi]') {
    if (_WoT_events == 0) {_WoT_events = ('[data:makeList]')}
    sendBroadcast '_WoT_start_server'
  } else {
    '_thing description' = ('thing description JSON')
  }
}

to 'thing description JSON' {
  return ('[data:join]' '{"title":"' _WoT_title '","@context":"https://webthings.io/schemas/","@type":["' _WoT_capability '"],"links":[{"rel":"events","href":"/events"},{"rel":"properties","href":"/properties"}],"properties":' ('properties JSON') ',"events":' ('event definitions JSON') '}')
}

to 'trigger event' 'event name' {
  if ('[net:hasWiFi]') {
    '[data:addLast]' ('[data:makeList]' (v 'event name') (millisOp)) _WoT_events
  } else {
    sendBroadcast (v 'event name')
  }
}


module WiFi Comm
author MicroBlocks
version 1 6 
tags communication network 
description 'Connect to a WiFi network. Used in conjunction with other network libraries, such as HTTP client, HTTP server or Web Thing.
'

  spec ' ' 'wifiConnect' 'wifi connect to _ password _ : IP _ gateway _ subnet _' 'str str auto auto auto' 'Network_Name' '' '192.168.1.42' '192.168.1.1' '255.255.255.0'
  spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
  spec 'r' 'getIPAddress' 'IP address'
  spec 'r' '[net:myMAC]' 'MAC address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to wifiConnect ssid password fixedIP gatewayIP subnetIP {
  if (not ('[net:hasWiFi]')) {return}
  '[net:stopWiFi]'
  if ((pushArgCount) < 5) {
    '[net:startWiFi]' ssid password
  } else {
    '[net:startWiFi]' ssid password false fixedIP gatewayIP subnetIP
  }
  local 'startMSecs' (millisOp)
  repeatUntil (('[net:myIPAddress]') != '0.0.0.0') {
    comment 'Timeout after N seconds'
    if (((millisOp) - startMSecs) > 30000) {
      sayIt 'Could not connect'
      return 0
    }
    comment 'Slow blink while trying to connect'
    setUserLED true
    waitMillis 300
    setUserLED false
    waitMillis 300
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  if ('Connected' != ('[net:wifiStatus]')) {
    sayIt 'Could not create hotspot'
    return 0
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

module main
author unknown
version 1 0 
description ''
variables temperature lightLevel 

script 57 57 {
whenStarted
comment 'Set your WiFi network name and password here:'
wifiConnect 'Network_Name' ''
'set thing name to' 'Temperature and Light'
'set thing capability to' 'TemperatureSensor'
addNumProp 'temperature' 'Temperature' 15 35 'TemperatureProperty' true
addNumProp 'lightLevel' 'Light' 0 1000 'LevelProperty' true
'start WebThing server'
forever {
  temperature = ('[sensors:temperature]')
  lightLevel = ('[display:lightLevel]')
  waitMillis 1000
}
}

script 312 357 {
comment 'View the thing description'
sayIt ('thing description JSON')
}

script 57 428 {
whenButtonPressed 'A'
scroll_text temperature
}

script 317 428 {
whenButtonPressed 'B'
scroll_text lightLevel
}


module 'Basic Sensors' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor 
choices accelerometerRange '1' '2' '4' '8' 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[sensors:acceleration]' 'acceleration'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (Â°C)'
  spec ' ' '_setAccelRange' 'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to '_setAccelRange' n {
  '[sensors:setAccelerometerRange]' (0 + n)
}


module 'HTTP server' Comm
author MicroBlocks
version 1 3 
depends WiFi 
tags http network 
description 'Create an HTTP server in MicroBlocks. You can use this library to allow remote control for your Wifi-enabled board.'

  spec 'r' '[net:httpServerGetRequest]' 'HTTP server request : binary data _ : port _' 'bool num' false 8080
  spec 'r' 'request method' 'method of request _' 'str' ''
  spec 'r' 'path of request' 'path of request _' 'str' ''
  spec 'r' 'headers of request' 'headers of request _' 'str' ''
  spec 'r' 'body of request' 'body of request _' 'str' ''
  spec 'r' 'content length of request' 'content length of request _' 'str' ''
  spec ' ' '[net:respondToHttpRequest]' 'respond _ to HTTP request : with body _ : and headers _ : keepAlive _' 'str str str bool' '200 OK' 'Welcome to the MicroBlocks HTTP server' 'Content-Type: text/plain' false
  spec 'r' '_endOfHeaders' '_end of headers _' 'str'
  spec 'r' '_toString' '_toString _' 'auto' 'abc'

to '_endOfHeaders' request {
  return ('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) request)
}

to '_toString' aStringOrByteArray {
  comment 'If argument is a byte array, convert it to a string. '
  if (not (isType aStringOrByteArray 'string')) {
    aStringOrByteArray = ('[data:join]' '' aStringOrByteArray)
  }
  return aStringOrByteArray
}

to 'body of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('[data:copyFromTo]' request (i + 4))
}

to 'content length of request' request {
  local 'i' ('_endOfHeaders' request)
  if (i < 0) {
    return 0
  }
  local 'j' ('[data:find]' 'Content-Length: ' request)
  if (j < 0) {
    comment 'Try alternate capitalization'
    j = ('[data:find]' 'Content-length: ' request)
  }
  if (or (j < 0) (j > i)) {
    return 0
  }
  j += 16
  local 'k' ('[data:find]' ('[data:unicodeString]' 13) request j)
  return (('[data:copyFromTo]' request j (k - 1)) + 0)
}

to 'headers of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('_toString' ('[data:copyFromTo]' request 1 (i - 1)))
}

to 'path of request' request {
  return ('_toString' ('[data:copyFromTo]' request (('[data:find]' ' ' request) + 1) (('[data:find]' ' HTTP' request) - 1)))
}

to 'request method' request {
  return ('_toString' ('[data:copyFromTo]' request 1 (('[data:find]' ' ' request) - 1)))
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}


module WebThings Comm
author MicroBlocks
version 3 4 
depends 'HTTP server' WiFi 
tags iot webthing wot 
choices thingTypesMenu Alarm BinarySensor ColorControl ColorSensor DoorSensor EnergyMonitor LeakSensor Light Lock MotionSensor MultiLevelSensor MultiLevelSwitch OnOffSwitch PushButton SmartPlug TemperatureSensor Thermostat 
choices thingEventTypesMenu OverheatedEvent PressedEvent DoublePressedEvent LongPressedEvent AlarmEvent 
choices numberPropertyTypesMenu LevelProperty BrightnessProperty ColorTemperatureProperty InstantaneousPowerProperty CurrentProperty VoltageProperty FrequencyProperty TargetTemperatureProperty TemperatureProperty 
choices booleanPropertyTypesMenu BooleanProperty OnOffProperty MotionProperty OpenProperty LeakProperty PushedProperty AlarmProperty 
choices stringPropertyTypesMenu ColorProperty TextProperty HeatingCoolingProperty LockedProperty ThermostatModeProperty 
description 'Create WebThings as specified by the WebThings schema and protocol. If your board is WiFi enabled, you can serve its thing description directly via HTTP. Otherwise, you can enable the MicroBlocks add-on in the WebThings Gateway.
'
variables _WoT_title _WoT_events _WoT_capability _WoT_event_defs _WoT_property_defs '_thing description' 

  spec ' ' 'set thing name to' 'set thing name to _' 'auto' 'MicroBlocks thing'
  spec ' ' 'set thing capability to' 'set thing capability to _' 'str.thingTypesMenu' 'Light'
  spec ' ' 'addBooleanProperty' 'set boolean property _ title _ @Type _ : read only _' 'menu.allVarsMenu str str.booleanPropertyTypesMenu bool' '' '' 'OnOffProperty' false
  spec ' ' 'addStringProperty' 'set string property _ title _ @Type _ : read only _' 'menu.allVarsMenu str str.stringPropertyTypesMenu bool' '' '' 'ColorProperty' false
  spec ' ' 'addNumProp' 'set number property _ title _ min _ max _ @Type _ : read only _' 'menu.allVarsMenu str num num str.numberPropertyTypesMenu bool' '' '' 0 100 'LevelProperty' false
  spec ' ' 'register event' 'register event _ type _' 'auto str.thingEventTypesMenu' 'Button A pressed' 'PressedEvent'
  spec ' ' 'start WebThing server' 'start WebThing server'
  spec ' ' 'trigger event' 'trigger event _' 'auto' 'button pressed'
  spec 'r' 'thing description JSON' 'thing description JSON'
  spec 'r' 'properties JSON' 'properties JSON'
  spec 'r' 'event definitions JSON' 'event definitions JSON'
  spec 'r' 'events JSON' 'events JSON'
  spec ' ' '_process OPTIONS request' '_process OPTIONS request _' 'auto' ''
  spec ' ' '_process PUT request' '_process PUT request _' 'auto' ''
  spec ' ' '_process request' '_process GET request _' 'auto' ''
  spec ' ' '_respond 404 Not Found' '_respond 404 Not Found'
  spec 'r' '_JSON value' '_JSON value _' 'auto' '10'
  spec 'r' '_parse JSON value' '_parse JSON value _' 'auto' ''
  spec 'r' '_trimmed' '_trimmed _' 'auto' '  hello    '
  spec ' ' '_WoT_start_server' '_WoT_start_server'
  spec 'r' '_type of' '_type of _' 'auto' '10'
  spec ' ' '_add or replace property' '_add or replace property _ attributes _' 'menu.nil str' '' ''
  spec ' ' '_clear thing description' '_clear thing description'
  spec 'r' '_varNames' '_varNames'

to '_JSON value' value {
  local 'JSON value' ''
  if (isType value 'string') {
    'JSON value' = ('[data:join]' '"' value '"')
  } (isType value 'list') {
    'JSON value' = '['
    for item value {
      'JSON value' = ('[data:join]' (v 'JSON value') ('_JSON value' item) ',')
    }
    'JSON value' = ('[data:join]' ('[data:copyFromTo]' (v 'JSON value') 1 ((size (v 'JSON value')) - 1)) ']')
  } (isType value 'boolean') {
    if value {
      'JSON value' = 'true'
    } else {
      'JSON value' = 'false'
    }
  } else {
    'JSON value' = value
  }
  return (v 'JSON value')
}

to '_WoT_start_server' {
  local 'request' ''
  forever {
    request = ('[net:httpServerGetRequest]')
    if (request != '') {
      if (('request method' request) == 'GET') {
        '_process request' request
      } (('request method' request) == 'PUT') {
        '_process PUT request' request
      } (('request method' request) == 'OPTIONS') {
        '_process OPTIONS request' request
      } else {
        '_respond 404 Not Found'
      }
    }
    waitMillis 50
  }
}

to '_add or replace property' varName 'attributes JSON' {
  if (_WoT_property_defs == 0) {_WoT_property_defs = ('[data:makeList]')}
  for def _WoT_property_defs {
    if ((at 1 def) == varName) {
      atPut 2 def (v 'attributes JSON')
      return ''
    }
  }
  '[data:addLast]' ('[data:makeList]' varName (v 'attributes JSON')) _WoT_property_defs
}

to '_clear thing description' {
  '_thing description' = 0
}

to '_parse JSON value' JSON {
  local 'value' ('_trimmed' JSON)
  if ((at 1 value) == '[') {
    comment 'Doesn''t handle multi-dimensional lists'
    local 'list' ('[data:makeList]')
    value = ('[data:copyFromTo]' value 2 ((size value) - 1))
    local 'comma index' ('[data:find]' ',' value)
    repeatUntil ((v 'comma index') == -1) {
      '[data:addLast]' ('_parse JSON value' ('[data:copyFromTo]' value 1 ((v 'comma index') - 1))) list
      value = ('[data:copyFromTo]' value ((v 'comma index') + 1))
      'comma index' = ('[data:find]' ',' value)
    }
    '[data:addLast]' ('_parse JSON value' value) list
    value = list
  } else {
    value = ('[misc:jsonGet]' value '')
  }
  return value
}

to '_process OPTIONS request' req {
  local 'path' ('path of request' req)
  '[net:respondToHttpRequest]' '200 OK' '' 'Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: PUT, GET, OPTIONS
Access-Control-Allow-Headers: Content-Type'
}

to '_process PUT request' req {
  local 'path' ('path of request' req)
  if (('[data:find]' '/properties/' path) > 0) {
    local 'varName' ('[data:copyFromTo]' path 13)
    if ('[vars:varExists]' varName) {
      local 'body' ('body of request' req)
      '[vars:setVarNamed]' varName ('_parse JSON value' ('[data:copyFromTo]' body (('[data:find]' ':' body) + 1) (('[data:find]' '}' body) - 1)))
      '[net:respondToHttpRequest]' '200 OK' ('[data:join]' '{"' varName '":' ('_JSON value' ('[vars:varNamed]' varName)) '}') 'Content-Type: application/json'
    } else {
      '_respond 404 Not Found'
    }
  } else {
    '_respond 404 Not Found'
  }
}

to '_process request' req {
  local 'path' ('path of request' req)
  if (path == '/') {
    '[net:respondToHttpRequest]' '200 OK' ('thing description JSON') 'Content-Type: application/json'
  } (or (path == '/properties') (path == '/properties/')) {
    '[net:respondToHttpRequest]' '200 OK' ('properties JSON') 'Content-Type: application/json'
  } (('[data:find]' '/properties/' path) > 0) {
    local 'varName' ('[data:copyFromTo]' path 13)
    if ('[vars:varExists]' varName) {
      '[net:respondToHttpRequest]' '200 OK' ('[data:join]' '{"' varName '":' ('_JSON value' ('[vars:varNamed]' varName)) '}') 'Content-Type: application/json'
    } else {
      '_respond 404 Not Found'
    }
  } (or (path == '/events') (path == '/events/')) {
    '[net:respondToHttpRequest]' '200 OK' ('events JSON') 'Content-Type: application/json'
    _WoT_events = ('[data:makeList]')
  } else {
    '_respond 404 Not Found'
  }
}

to '_respond 404 Not Found' {
  '[net:respondToHttpRequest]' '404 Not Found' '{ "error":"Resource not found" }' 'Content-Type: application/json'
}

to '_trimmed' string {
  comment 'remove surrounding spaces'
  repeatUntil ((at 1 string) != ' ') {
    string = ('[data:copyFromTo]' string 2)
  }
  repeatUntil ((at 'last' string) != ' ') {
    string = ('[data:copyFromTo]' string 1 ((size string) - 1))
  }
  return string
}

to '_type of' value {
  if (isType value 'number') {
    return 'number'
  } (isType value 'list') {
    return 'array'
  } (isType value 'string') {
    return 'string'
  } (isType value 'boolean') {
    return 'boolean'
  }
  comment 'should never happen'
  return 'null'
}

to '_varNames' {
  local 'result' ('[data:makeList]')
  local 'count' ('[vars:varNameForIndex]' -1)
  for i count {
    local 'varName' ('[vars:varNameForIndex]' i)
    if (isType varName 'string') {
      '[data:addLast]' varName result
    }
  }
  return result
}

to addBooleanProperty varName title type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 3) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"boolean","@type":"' type '",' '"readOnly":' readonly)
}

to addNumProp varName title min max type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 5) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"number","@type":"' type '",' '"readOnly":' readonly ',"minimum":' min ',"maximum":' max)
}

to addStringProperty varName title type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 3) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"string","@type":"' type '",' '"readOnly":' readonly)
}

to 'event definitions JSON' {
  local 'JSON' '{'
  if (_WoT_event_defs == 0) {
    _WoT_event_defs = ('[data:makeList]')
  }
  for 'event def' _WoT_event_defs {
    JSON = ('[data:join]' JSON '"' (at 1 (v 'event def')) '":{"description":"MicroBlocks event","@type":"' (at 2 (v 'event def')) '"},')
  }
  if ((size JSON) > 1) {
    return ('[data:join]' ('[data:copyFromTo]' JSON 1 ((size JSON) - 1)) '}')
  } else {
    return '{}'
  }
}

to 'events JSON' {
  local 'JSON' '['
  for event _WoT_events {
    JSON = ('[data:join]' JSON '{"' (at 1 event) '":{"data":{"id":' (at 2 event) '}}},')
  }
  if ((size JSON) > 1) {
    return ('[data:join]' ('[data:copyFromTo]' JSON 1 ((size JSON) - 1)) ']')
  } else {
    return '[]'
  }
}

to 'properties JSON' {
  local 'JSON' '{'
  if (or (_WoT_property_defs == 0) ((size _WoT_property_defs) == 0)) {
    for varName ('_varNames') {
      if (not ((at 1 varName) == '_')) {
        local 'value' ('[vars:varNamed]' varName)
        JSON = ('[data:join]' JSON '"' varName '":{"title":"' varName '","type":"' ('_type of' value) '","links":[{"href":"/properties/' varName '"}],"@type":""},')
      }
    }
  } else {
    for 'property def' _WoT_property_defs {
      local 'varName' (at 1 (v 'property def'))
      JSON = ('[data:join]' JSON '"' varName '":{"links":[{"href":"/properties/' varName '"}],' (at 2 (v 'property def')) '},')
    }
  }
  if ((at 'last' JSON) == ',') {
    JSON = ('[data:copyFromTo]' JSON 1 ((size JSON) - 1))
  }
  return ('[data:join]' JSON '}')
}

to 'register event' 'event title' 'event type' {
  local 'event def' ('[data:makeList]' (v 'event title') (v 'event type'))
  if (_WoT_event_defs == 0) {
    _WoT_event_defs = ('[data:makeList]')
  }
  for def _WoT_event_defs {
    if ((at 1 def) == (v 'event title')) {
      atPut 2 def (v 'event type')
      return ''
    }
  }
  '[data:addLast]' (v 'event def') _WoT_event_defs
}

to 'set thing capability to' capability {
  _WoT_capability = capability
}

to 'set thing name to' title {
  _WoT_title = title
}

to 'start WebThing server' {
  if (_WoT_title == 0) {'set thing name to' 'MicroBlocks thing'}
  if (_WoT_capability == 0) {'set thing capability to' ''}
  if ('[net:hasWiFi]') {
    if (_WoT_events == 0) {_WoT_events = ('[data:makeList]')}
    sendBroadcast '_WoT_start_server'
  } else {
    '_thing description' = ('thing description JSON')
  }
}

to 'thing description JSON' {
  return ('[data:join]' '{"title":"' _WoT_title '","@context":"https://webthings.io/schemas/","@type":["' _WoT_capability '"],"links":[{"rel":"events","href":"/events"},{"rel":"properties","href":"/properties"}],"properties":' ('properties JSON') ',"events":' ('event definitions JSON') '}')
}

to 'trigger event' 'event name' {
  if ('[net:hasWiFi]') {
    '[data:addLast]' ('[data:makeList]' (v 'event name') (millisOp)) _WoT_events
  } else {
    sendBroadcast (v 'event name')
  }
}


module WiFi Comm
author MicroBlocks
version 1 6 
tags communication network 
description 'Connect to a WiFi network. Used in conjunction with other network libraries, such as HTTP client, HTTP server or Web Thing.
'

  spec ' ' 'wifiConnect' 'wifi connect to _ password _ : IP _ gateway _ subnet _' 'str str auto auto auto' 'Network_Name' '' '192.168.1.42' '192.168.1.1' '255.255.255.0'
  spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
  spec 'r' 'getIPAddress' 'IP address'
  spec 'r' '[net:myMAC]' 'MAC address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to wifiConnect ssid password fixedIP gatewayIP subnetIP {
  if (not ('[net:hasWiFi]')) {return}
  '[net:stopWiFi]'
  if ((pushArgCount) < 5) {
    '[net:startWiFi]' ssid password
  } else {
    '[net:startWiFi]' ssid password false fixedIP gatewayIP subnetIP
  }
  local 'startMSecs' (millisOp)
  repeatUntil (('[net:myIPAddress]') != '0.0.0.0') {
    comment 'Timeout after N seconds'
    if (((millisOp) - startMSecs) > 30000) {
      sayIt 'Could not connect'
      return 0
    }
    comment 'Slow blink while trying to connect'
    setUserLED true
    waitMillis 300
    setUserLED false
    waitMillis 300
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  if ('Connected' != ('[net:wifiStatus]')) {
    sayIt 'Could not create hotspot'
    return 0
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

module AILens
author wwj718
version 1 0 
choices modeMenu Card Ball Color Face Tracking Learn 
description 'AI Lens

The AI Lens is able to achieve the functions of face recognition, balls tracking, cards recognition and characteristics acquisition.

ref: https://www.elecfreaks.com/learn-en/microbitplanetX/ai/Plant_X_EF05035.html
'
variables _Camera_Add _Card _Face _Ball _Tracking _Color _Learn _numberCards _letterCards _otherCards _colorList '_AILens initialized' _Data_buff _Temp_Data_buff _recursion_depth 

	spec ' ' '_AILens setup' '_AILens setup'
	spec ' ' '_get_image' '_get_image'
	spec ' ' 'switch_function' 'switch mode _' 'menu.modeMenu' 'Card'
	spec 'r' 'get_card_content' 'get_card_content'
	spec 'r' 'get_card_data' 'get_card_data'
	spec 'r' 'get_ball_color' 'get_ball_color'
	spec 'r' 'get_ball_data' 'get_ball_data'
	spec 'r' 'get_color_name' 'get_color_name'
	spec 'r' 'get_face' 'get_face'
	spec 'r' 'get_face_data' 'get_face_data'
	spec 'r' 'get_track_data' 'get_track_data'
	spec ' ' 'learn_object' 'learn_object _' 'menu.range:1-5' 1
	spec 'r' 'get_learn_data' 'get_learn_data'
	spec 'r' '_get_7_data' '_get_7_data'

to '_AILens setup' {
  if ((v '_AILens initialized') == 0) {
    _Camera_Add = (hexToInt '14')
    _Card = 0
    _Face = 0
    _Ball = 7
    _Tracking = 1
    _Color = 0
    _Learn = 0
    _numberCards = ('[data:makeList]' 0 1 2 3 4 5 6 7 8 9)
    _letterCards = ('[data:makeList]' 'A' 'B' 'C' 'D' 'E')
    _otherCards = ('[data:makeList]' 'Mouse' 'micro:bit' 'Ruler' 'Cat' 'Peer' 'Ship' 'Apple' 'Car' 'Pan' 'Dog' 'Umbrella' 'Airplane' 'Clock' 'Grape' 'Cup' 'Turn left' 'Turn right' 'Forward' 'Stop' 'Back')
    _colorList = ('[data:makeList]' 'Green' 'Blue' 'Yellow' 'Black' 'Red' 'White')
    _Temp_Data_buff = (newList 9)
    _Data_buff = (newList 9)
    _recursion_depth = 0
    local 'tmp' (newList 1)
    '[sensors:i2cRead]' _Camera_Add tmp
    '_AILens initialized' = 1
  }
}

to '_get_7_data' {
  '_get_image'
  comment 'return (a list):Data [x,y,w,h,confidence,total,order]'
  local 'data' ('[data:makeList]')
  for i 7 {
    '[data:addLast]' (at (i + 2) _Data_buff) data
  }
  return data
}

to '_get_image' {
  '_AILens setup'
  '[sensors:i2cRead]' _Camera_Add _Temp_Data_buff
  if (_Temp_Data_buff == _Data_buff) {
    waitMillis 100
    if (_recursion_depth < 5) {
      _recursion_depth = (_recursion_depth + 1)
      '_get_image'
    }
  } else {
    _Data_buff = _Temp_Data_buff
  }
}

to get_ball_color {
  '_get_image'
  if ((at 1 _Data_buff) == 7) {
    if ((at 2 _Data_buff) == 1) {
      return 'Blue'
    } else {
      if ((at 2 _Data_buff) == 2) {return 'Red'}
    }
  }
  if else {
    return '"No Ball"'
  }
}

to get_ball_data {
  return ('_get_7_data')
}

to get_card_content {
  '_get_image'
  if ((at 1 _Data_buff) == 2) {
    return (at (at 2 _Data_buff) _numberCards)
  }
  if ((at 1 _Data_buff) == 4) {
    return (at (at 2 _Data_buff) _letterCards)
  }
  if (and ((at 1 _Data_buff) == 3) ((at 2 _Data_buff) < 21)) {
    return (at (at 2 _Data_buff) _otherCards)
  }
  return 'No Card'
}

to get_card_data {
  return ('_get_7_data')
}

to get_color_name {
  '_get_image'
  if ((at 1 _Data_buff) == 9) {
    return (at (at 2 _Data_buff) _colorList)
  } else {
    return 'No Color'
  }
}

to get_face {
  '_get_image'
  return ((at 1 _Data_buff) == 6)
}

to get_face_data {
  return ('_get_7_data')
}

to get_learn_data {
  comment 'return: LearnData [ID,confidence]'
  '_get_image'
  return ('[data:makeList]' (at 2 _Data_buff) (100 - (at 3 _Data_buff)))
}

to get_track_data {
  comment 'return: LineData [angel,width,len]'
  '_get_image'
  local 'data' 0
  for i 3 {
    '[data:addLast]' (at (i + 2) _Data_buff) data
  }
  return data
}

to learn_object id {
  '_AILens setup'
  if (or (id > 5) (id < 1)) {
    sayIt '"Learn id out of range"'
  } else {
    '[sensors:i2cWrite]' _Camera_Add ('[data:asByteArray]' ('[data:makeList]' 10 id))
  }
}

to switch_function mode {
  '_AILens setup'
  comment 'mode'
  if (mode == 'Card') {
    mode = 2
  }
  if (mode == 'Face') {
    mode = 6
  }
  if (mode == 'Ball') {
    mode = 7
  }
  if (mode == 'Tracking') {
    mode = 8
  }
  if (mode == 'Color') {
    mode = 9
  }
  if (mode == 'Learn') {
    mode = 10
  }
  '[sensors:i2cWrite]' _Camera_Add ('[data:asByteArray]' ('[data:makeList]' (hexToInt '20') mode))
}

module HuskyLens Input
author 'Murat Akguller'
version 2 0 
choices requestByMenu Blocks Arrows 
choices requestedMenu Blocks Arrows 'Learned Blocks' 'Learned Arrows' 
choices changeAlgoMenu 'Color Recog' 'Face Recog' 'Line Track' 'Obj Classify' 'Obj Recog' 'Obj Track' 'Tag Recog' 
choices getInfoMenu 'Object Count' 'Learned Count' 'Frame Number' 
choices requestFileMenu 'Save Model' 'Load Model' 
choices doMenu Knock 'Save Picture' 'Save Screenshot' 'Forget Learned Objects' 'Clear Screen' 'is pro' 'firmware version' 
choices getArrowMenu 'X origin' 'Y origin' 'X target' 'Y target' id 
choices getBlockMenu 'X center' 'Y center' Width Height id 
choices requestPhotoMenu 'Save Picture' 'Save Screenshot' 
description 'Integrates DFROBOT HuskyLens camera into MicroBlocks.
Supports I2C and Serial 9600 
Full Arduino Lib support
Changes: 
- New _HLinitLib auto init
- New HL set Comms
- Renamed Learn blocks
- SERIAL 9600 support
'
variables HuskyData HL_I2C_address _buffer _cmd_list _get_lists _bufferdata HL_initalized _currAlgo _algo_list _serialMode 

  spec ' ' 'HL set Comms' 'HL set Comms i2cAddr _ serial _' 'str bool' '32' false
  spec ' ' 'HL change algorithm' 'HL change algorithm _' 'menu.changeAlgoMenu' 'Face Recog'
  spec 'r' 'HL do' 'HL do _' 'menu.doMenu' 'Knock'
  spec ' ' 'HL request' 'HL request _' 'menu.requestedMenu' 'Blocks'
  spec ' ' 'HL request by ID' 'HL request by ID _ Object _' 'num menu.requestByMenu' 1 'Blocks'
  spec 'r' 'HL get arrow' 'HL get arrow _ arrow index _' 'menu.getArrowMenu num' 'X origin' 1
  spec 'r' 'HL get block' 'HL get block _ block index _' 'menu.getBlockMenu num' 'X center' 1
  spec 'r' 'HL get info' 'HL get info _' 'menu.getInfoMenu' 'Object Count'
  spec 'r' 'HL learn current object as ID' 'HL learn current object as ID _' 'num' 1
  spec 'r' 'HL learn object as ID' 'HL learn object as ID _ Name _' 'num str' 1 'name'
  spec 'r' 'HL set CustomName' 'HL set CustomName _ for a learned object with ID _' 'str num' 'name' 1
  spec ' ' 'HL write' 'HL write _ at x _ y _' 'str num num' 'Hello!' 0 0
  spec 'r' 'HL file' 'HL file _ file# _' 'menu.requestFileMenu num' 'Save Model' 1
  spec 'r' '_HLcalc_checkSum' '_HLcalc_checkSum _' 'auto' '10'
  spec 'r' '_HLcheck' '_HLcheck'
  spec ' ' '_HLcmd_init' '_HLcmd_init'
  spec 'r' '_HLcmdarrow43' '_HLcmdarrow43 _' 'auto' 'return arrow'
  spec 'r' '_HLcmdblock42' '_HLcmdblock42 _' 'auto' 'return block'
  spec 'r' '_HLcmdinfo41' '_HLcmdinfo41 _' 'auto' 'return info'
  spec 'r' '_HLdecode_bufferdata' '_HLdecode_bufferdata _' 'auto' 'buffer data'
  spec 'r' '_HLgetcmdnum' '_HLgetcmdnum _' 'auto' 'Blocks'
  spec ' ' '_HLgetdata_from_cmd' '_HLgetdata_from_cmd'
  spec ' ' '_HLinitLib' '_HLinitLib'
  spec ' ' '_HLsendCommand' '_HLsendCommand _ data _' 'auto auto' 10 '10'

to 'HL change algorithm' algo {
  if (not HL_initalized) {'_HLinitLib'}
  local 'data' ('[data:makeList]' (at (('[data:find]' algo _algo_list) + 1) _algo_list) 0)
  '_HLsendCommand' 45 ('[data:asByteArray]' data)
  waitUntil ('_HLcheck')
  _currAlgo = algo
}

to 'HL do' command {
  if (not HL_initalized) {'_HLinitLib'}
  local 'data' ('[data:newByteArray]' 0)
  local 'cmd_num' ('_HLgetcmdnum' command)
  '_HLsendCommand' cmd_num data
  waitUntil ('_HLcheck')
  '_HLgetdata_from_cmd'
  return ('_HLdecode_bufferdata' _bufferdata)
}

to 'HL file' action fileNum {
  if (not HL_initalized) {'_HLinitLib'}
  if (or (fileNum <= 0) (fileNum > 65535)) {return 'File number range: 0-65535'}
  local 'data' ('[data:makeList]' (fileNum % 256) (fileNum / 256))
  '_HLsendCommand' ('_HLgetcmdnum' action) ('[data:asByteArray]' data)
  waitUntil ('_HLcheck')
  '_HLgetdata_from_cmd'
  return ('_HLdecode_bufferdata' _bufferdata)
}

to 'HL get arrow' arrowDetails inx {
  if ((size HuskyData) == 1) {
    return 'No Object Detected'
  } ((size HuskyData) == 0) {
    return 'HuskyData is empty, Make a request'
  }
  if (inx <= 0) {
    return 'Index Error'
  } (inx > ((size HuskyData) - 1)) {
    return 'Index Error but Object detected'
  }
  local 'split_data' ('[data:split]' (at (inx + 1) HuskyData) ',')
  return ((at ('[data:find]' arrowDetails (at 2 _get_lists)) split_data) + 0)
}

to 'HL get block' blockDetails inx {
  if ((size HuskyData) == 1) {
    return 'No Object Detected'
  } ((size HuskyData) == 0) {
    return 'HuskyData is empty, Make a request'
  }
  if (inx <= 0) {
    return 'Index Error'
  } (inx > ((size HuskyData) - 1)) {
    return 'Index Error but Object detected'
  }
  local 'split_data' ('[data:split]' (at (inx + 1) HuskyData) ',')
  return ((at ('[data:find]' blockDetails (at 1 _get_lists)) split_data) + 0)
}

to 'HL get info' infoDetails {
  if ((size HuskyData) == 0) {return 'HuskyData is empty, Make a request'}
  local 'split_data' ('[data:split]' (at 1 HuskyData) ',')
  return ((at ('[data:find]' infoDetails (at 3 _get_lists)) split_data) + 0)
}

to 'HL learn current object as ID' id {
  if (not HL_initalized) {'_HLinitLib'}
  if (or (id <= 0) (id > 255)) {return 'ID must be 0 - 255'}
  local 'data' ('[data:makeList]' (id % 256) (id / 256))
  '_HLsendCommand' ('_HLgetcmdnum' 'Learn ById') ('[data:asByteArray]' data)
  waitUntil ('_HLcheck')
  '_HLgetdata_from_cmd'
  return ('_HLdecode_bufferdata' _bufferdata)
}

to 'HL learn object as ID' id name {
  if (not HL_initalized) {'_HLinitLib'}
  if (('HL learn current object as ID' id) == 'OK') {return ('HL set CustomName' name id)}
}

to 'HL request' objName {
  if (not HL_initalized) {'_HLinitLib'}
  '_HLsendCommand' ('_HLgetcmdnum' objName) ('[data:newByteArray]' 0)
  waitUntil ('_HLcheck')
  '_HLgetdata_from_cmd'
  HuskyData = ('_HLdecode_bufferdata' _bufferdata)
  if (('HL get info' 'Object Count') != ((size HuskyData) - 1)) {
    HuskyData = ('[data:makeList]')
  }
}

to 'HL request by ID' id objName {
  if (not HL_initalized) {'_HLinitLib'}
  local 'resultList' ('[data:makeList]')
  if (or (id <= 0) (id > 65535)) {
    return 'ID must be greater than 0 and less than 65536'
  }
  local 'data' ('[data:makeList]' (id % 256) (id / 256))
  '_HLsendCommand' ('_HLgetcmdnum' ('[data:join]' 'ById' objName)) ('[data:asByteArray]' data)
  waitUntil ('_HLcheck')
  '_HLgetdata_from_cmd'
  HuskyData = ('_HLdecode_bufferdata' _bufferdata)
  if (and ((('HL get info' 'Object Count') + 1) != (size HuskyData)) (('HL get info' 'Object Count') == 0)) {
    HuskyData = ('[data:makeList]')
  }
}

to 'HL set Comms' addr serial {
  '_HLinitLib'
  HL_I2C_address = (hexToInt addr)
  _serialMode = serial
  if (and (HL_I2C_address == 0) (not _serialMode)) {
    sayIt 'I2C address can not be 0, Set I2C address'
    stopTask
  } _serialMode {
    '[serial:open]' 9600
  }
  if (not _serialMode) {
    sayIt 'I2C: ON, Serial: OFF'
  } else {
    sayIt 'I2C: OFF, Serial: ON'
  }
}

to 'HL set CustomName' name id {
  if (not HL_initalized) {'_HLinitLib'}
  if (or (id <= 0) (id > 255)) {return 'ID must be 0 - 255'}
  local 'data' ('[data:makeList]' id ((size name) + 1))
  for byte ('[data:asByteArray]' name) {
    '[data:addLast]' byte data
  }
  '[data:addLast]' 0 data
  '_HLsendCommand' ('_HLgetcmdnum' 'Set Custom Name') ('[data:asByteArray]' data)
  waitUntil ('_HLcheck')
  '_HLgetdata_from_cmd'
  return ('_HLdecode_bufferdata' _bufferdata)
}

to 'HL write' text x y {
  if (not HL_initalized) {'_HLinitLib'}
  if ((size text) >= 20) {
    sayIt 'Text string must be less than 20 characters'
    stopTask
  }
  if (or (x >= 320) (x < 0)) {
    sayIt 'X must be 0-319'
    stopTask
  }
  if (or (y >= 240) (y < 0)) {
    sayIt 'Y must be 0-239'
    stopTask
  }
  local 'data' ('[data:makeList]' (size text))
  if (x >= 255) {
    '[data:addLast]' 255 data
  } else {
    '[data:addLast]' 0 data
  }
  '[data:addLast]' (x % 256) data
  '[data:addLast]' y data
  for byte ('[data:asByteArray]' text) {
    '[data:addLast]' byte data
  }
  '_HLsendCommand' ('_HLgetcmdnum' 'Write') ('[data:asByteArray]' data)
  waitUntil ('_HLcheck')
}

to '_HLcalc_checkSum' cmdData {
  local 'checksum' 0
  for byte cmdData {
    checksum += byte
  }
  return (checksum % 256)
}

to '_HLcheck' {
  comment 'I2C reads n bytes in List or Bytearray format
SERIAL only reads Bytearrays of 0-n length
Therefore:
  for SERIAL, we change the lookups to bytearray'
  _buffer = (newList 32)
  _bufferdata = ('[data:makeList]')
  local 'returned' (booleanConstant false)
  local 'lookupResult' 0
  local 'serBuff' 0
  repeatUntil (returned == (booleanConstant true)) {
    waitMillis 20
    if _serialMode {
      serBuff = ('[serial:read]')
      if ((size serBuff) > 0) {
        local 'idx' 1
        for byte serBuff {
          atPut idx _buffer byte
          idx += 1
        }
      }
    } else {
      '[sensors:i2cRead]' HL_I2C_address _buffer
    }
    lookupResult = ('[data:find]' '8517017' ('[data:joinStrings]' _buffer))
    if (lookupResult > 0) {
      _bufferdata = ('[data:join]' _bufferdata _buffer)
      returned = (booleanConstant true)
    } else {
      returned = (booleanConstant false)
    }
  }
  return returned
}

to '_HLcmd_init' {
  _cmd_list = ('[data:makeList]' 'Blocks' 33 'Arrows' 34 'Learned Blocks' 36 'Learned Arrows' 37 'Knock' 44 'Save Picture' 48 'Save Screenshot' 57 'Forget Learned Objects' 55 'Clear Screen' 53 'firmware version' 60 'is pro' 59 'ByIdBlocks' 39 'ByIdArrows' 40 'Change Algorithm' 45 'Save Model' 50 'Load Model' 51 'Learn ById' 54 'Set Custom Name' 47 'Write' 52)
  _get_lists = ('[data:makeList]' ('[data:makeList]' 'B' 'X center' 'Y center' 'Width' 'Height' 'id') ('[data:makeList]' 'A' 'X origin' 'Y origin' 'X target' 'Y target' 'id') ('[data:makeList]' 'I' 'Object Count' 'Learned Count' 'Frame Number'))
}

to '_HLcmdarrow43' obj_data {
  return ('[data:join]' 'A' ',' (((at 4 obj_data) * 256) + (at 3 obj_data)) ',' (((at 6 obj_data) * 256) + (at 5 obj_data)) ',' (((at 8 obj_data) * 256) + (at 7 obj_data)) ',' (((at 10 obj_data) * 256) + (at 9 obj_data)) ',' (('[data:join]' (at 12 obj_data) (at 11 obj_data)) + 0))
}

to '_HLcmdblock42' obj_data {
  return ('[data:join]' 'B' ',' (((at 4 obj_data) * 256) + (at 3 obj_data)) ',' (((at 6 obj_data) * 256) + (at 5 obj_data)) ',' (((at 8 obj_data) * 256) + (at 7 obj_data)) ',' (((at 10 obj_data) * 256) + (at 9 obj_data)) ',' (('[data:join]' (at 12 obj_data) (at 11 obj_data)) + 0))
}

to '_HLcmdinfo41' info_data {
  return ('[data:join]' 'I' ',' (('[data:join]' (at 4 info_data) (at 3 info_data)) + 0) ',' (('[data:join]' (at 6 info_data) (at 5 info_data)) + 0) ',' (((at 8 info_data) * 256) + (at 7 info_data)))
}

to '_HLdecode_bufferdata' data {
  comment 'Split Buffer Data 0x55 0xAA 0x11
dec85 dec170 dec17 '
  local 'parsed_data' ('[data:split]' ('[data:joinStrings]' data ',') '85,170,17,')
  '[data:delete]' 1 parsed_data
  comment 'split each parsed data(string)  for  decoding'
  for i (size parsed_data) {
    atPut i parsed_data ('[data:split]' (at i parsed_data) ',')
  }
  comment 'What is returned?
INFO?41 OK?46 IS PRO?59'
  if (((at 2 (at 1 parsed_data)) + 0) == 41) {
    local 'data_item' ('[data:makeList]')
    local 'decoded_dataList' ('[data:makeList]')
    '[data:addLast]' ('_HLcmdinfo41' (at 1 parsed_data)) decoded_dataList
    if ((size parsed_data) > 1) {
      if (((at 2 (at 2 parsed_data)) + 0) == 42) {
        for i ((size parsed_data) - 1) {
          data_item = (at (i + 1) parsed_data)
          '[data:addLast]' ('_HLcmdblock42' data_item) decoded_dataList
        }
      } else {
        for i ((size parsed_data) - 1) {
          data_item = (at (i + 1) parsed_data)
          '[data:addLast]' ('_HLcmdarrow43' data_item) decoded_dataList
        }
      }
    }
    return decoded_dataList
  } (((at 2 (at 1 parsed_data)) + 0) == 46) {
    return 'OK'
  } (((at 2 (at 1 parsed_data)) + 0) == 59) {
    if ((at 6 _buffer) == 1) {
      return 'pro version'
    } else {
      return 'not pro version'
    }
  }
}

to '_HLgetcmdnum' cmdName {
  return (at (('[data:find]' cmdName _cmd_list) + 1) _cmd_list)
}

to '_HLgetdata_from_cmd' {
  comment 'I2C reads n bytes in List or Bytearray format
SERIAL only reads Bytearrays of 0-n length'
  repeatUntil (0 == (('[data:joinStrings]' _buffer) + 0)) {
    if _serialMode {
      _buffer = (newList 32)
      local 'idx' 1
      local 'serBuff' ('[serial:read]')
      waitMillis 20
      if ((size serBuff) > 0) {
        for byte serBuff {
          atPut idx _buffer byte
          idx += 1
        }
      }
    } else {
      '[sensors:i2cRead]' HL_I2C_address _buffer
    }
    _bufferdata = ('[data:join]' _bufferdata _buffer)
  }
}

to '_HLinitLib' {
  '_HLcmd_init'
  _algo_list = ('[data:makeList]' 'Color Recog' 4 'Face Recog' 0 'Line Track' 3 'Obj Classify' 6 'Obj Recog' 2 'Obj Track' 1 'Tag Recog' 5)
  HuskyData = ('[data:makeList]')
  _bufferdata = ('[data:makeList]')
  _buffer = (newList 32)
  HL_initalized = (booleanConstant true)
}

to '_HLsendCommand' cmd data {
  _buffer = ('[data:join]' ('[data:asByteArray]' ('[data:makeList]' 85 170 17 (size data) cmd)) data)
  _buffer = ('[data:join]' _buffer ('[data:asByteArray]' ('_HLcalc_checkSum' _buffer)))
  if _serialMode {
    '[serial:write]' _buffer
    waitMillis 50
  } else {
    '[sensors:i2cWrite]' HL_I2C_address _buffer
  }
}

module 'Basic Sensors' Input
author MicroBlocks
version 1 1
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'
tags tilt acceleration light sensor
choices accelerometerRange '1' '2' '4' '8'

	// Sensing primitives for the BBC micro:bit, Calliope mini, Citilab ED1, and AdaFruit
	// Circuit Playground Express. These boards all have accelerometers and use various
	// techniques to sense temperature and light.

	spec 'r' '[sensors:tiltX]'			'tilt x'
	spec 'r' '[sensors:tiltY]'			'tilt y'
	spec 'r' '[sensors:tiltZ]'			'tilt z'
	spec 'r' '[sensors:acceleration]'	'acceleration'
	spec 'r' '[display:lightLevel]'		'light level'
	spec 'r' '[sensors:temperature]'	'temperature (Â°C)'
	spec 'r' '[sensors:magneticField]'	'magnetic field'
	spec ' ' '_setAccelRange'			'set acceleration range _ g = 100' 'menu.accelerometerRange' '1'

to _setAccelRange n {
	'[sensors:setAccelerometerRange]' (0 + n)
}module '8 Bit Graphics' Output
author MicroBlocks
version 1 2 
tags graphics 
choices eightBitPalettes MicroBlocks 'red hues' 'green hues' 'blue hues' grayscale 
choices fourBitPalettes CGA 'Machintosh II' 'Win & OS/2' MSX 'RISC 2' grayscale 
description 'Provides a full 8-bit (and lower depth) framework to create retro-looking games and applications.

By combining different scales and bit depths you can adapt your project to work on virtually any board.

It allows reading 8-bit indexed BMP files, color palettes and raw image data exported from GIMP, or creating your own bitmaps by hand as byte arrays.  It also includes a bunch of default 4-bit and 8-bit color palettes.

By using a buffer and bitmap merge operations, you can work with sprites and backgrounds at a reasonably high abstraction level, while achieving a decent framerate.
'
variables _8bit_scale _8bit_alpha_index _8bit_buffer _8bit_palette _bmpIsRGB565 _bmpHeight _bmpCompression _bmpWidth _bmpPalette _bmpPixelsOffset _bmpBPP _bmpLine 

  spec ' ' 'set scale _' 'set scale _' 'num' 4
  spec ' ' 'set transparent color index _' 'set transparent color index _' 'num' 0
  spec ' ' 'merge' 'merge bitmap _ at _ , _' 'auto num num' '' 10 20
  spec 'r' 'bitmap from BMP file' 'bitmap from BMP file _' 'auto' '8bit.bmp'
  spec 'r' 'bitmap from file' 'bitmap of width _ from raw indexed file _' 'num str' 32 'filename.data'
  spec 'r' 'bitmap' 'bitmap of width _ from string _' 'num str' 7 '0003000003B30003BFB30003B3000003000'
  spec ' ' 'draw buffer' 'draw buffer : starting at x _ y _ width _ height _' 'num num num num' 10 20 7 7
  spec ' ' 'clear display' 'clear display'
  spec ' ' 'set palette' 'set palette _' 'auto' ''
  spec 'r' 'palette from pal format' 'palette from pal file _' 'auto' 'filename.data.pal'
  spec 'r' 'palette from BMP file' 'palette from BMP file _' 'auto' '8bit.bmp'
  spec 'r' '4 bit palette' '4 bit _ palette' 'menu.fourBitPalettes' 'CGA'
  spec 'r' '8 bit palette' '8 bit _ palette' 'menu.eightBitPalettes' 'MicroBlocks'
  spec ' ' 'draw palette table' 'draw palette table _' 'auto' ''
  spec 'r' 'screen width' 'screen width'
  spec 'r' 'screen height' 'screen height'
  spec 'r' '_8bit_4bit_CGA palette' '_8bit_4bit_CGA palette'
  spec 'r' '_8bit_4bit_Machintosh II palette' '_8bit_4bit_Machintosh II palette'
  spec 'r' '_8bit_4bit_Win & OS/2 palette' '_8bit_4bit_Win & OS/2 palette'
  spec 'r' '_8bit_4bit_grayscale palette' '_8bit_4bit_grayscale palette'
  spec 'r' '_8bit_4bit_MSX palette' '_8bit_4bit_MSX palette'
  spec 'r' '_8bit_4bit_RISC 2 palette' '_8bit_4bit_RISC 2 palette'
  spec 'r' '_8bit_8bit_grayscale palette' '_8bit_8bit_grayscale palette'
  spec 'r' '_8bit_8bit_green hues palette' '_8bit_8bit_green hues palette'
  spec 'r' '_8bit_8bit_red hues palette' '_8bit_8bit_red hues palette'
  spec 'r' '_8bit_8bit_blue hues palette' '_8bit_8bit_blue hues palette'
  spec 'r' '_8bit_8bit_MicroBlocks palette' '_8bit_8bit_MicroBlocks palette'
  spec 'r' '_sqrt _' '_sqrt _' 'num' 10
  spec 'r' '_bmp_readHeader' '_bmp_readHeader file _' 'str' ''
  spec ' ' '_bmp_readPalette' '_bmp_readPalette file _' 'auto' ''
  spec ' ' '_bmp_readLine' '_bmp_readLine file _' 'auto' ''
  spec 'r' '_bmp_line2indexes' '_bmp_line2indexes'
  spec 'r' '_bmp_RLEline' '_bmp_readRLELine file _' 'auto' ''
  spec 'r' '_bmp_readInt16' '_bmp read int16 file _' 'str' ''
  spec 'r' '_bmp_readInt32' '_bmp read int32 file _' 'str' ''
  spec ' ' '_bmp_alignLineData' '_bmp_alignLineData file _' 'auto' ''

to '4 bit palette' selector {
  return (callCustomReporter ('[data:join]' '_8bit_4bit_' selector ' palette'))
}

to '8 bit palette' selector {
  return (callCustomReporter ('[data:join]' '_8bit_8bit_' selector ' palette'))
}

to '_8bit_4bit_CGA palette' {
  return ('[data:makeList]' 0 170 43520 43690 11141120 11141290 11162880 11184810 5592405 5592575 5635925 5636095 16733525 16733695 16777045 16777215)
}

to '_8bit_4bit_MSX palette' {
  return ('[data:makeList]' (hexToInt '0') (hexToInt '010101') (hexToInt '3eb849') (hexToInt '74d07d') (hexToInt '5955e0') (hexToInt '8076f1') (hexToInt 'b95e51') (hexToInt '65dbef') (hexToInt 'db6559') (hexToInt 'ff897d') (hexToInt 'ccc35e') (hexToInt 'ded087') (hexToInt '3aa241') (hexToInt 'b766b5') (hexToInt 'cccccc') (hexToInt 'ffffff'))
}

to '_8bit_4bit_Machintosh II palette' {
  return ('[data:makeList]' (hexToInt 'ffffff') (hexToInt 'fcf400') (hexToInt 'ff6400') (hexToInt 'dd0202') (hexToInt 'f10285') (hexToInt '4600a6') (hexToInt 'd5') (hexToInt 'aee9') (hexToInt '1ab90c') (hexToInt '6408') (hexToInt '582800') (hexToInt '917135') (hexToInt 'c1c1c1') (hexToInt '818181') (hexToInt '3e3e3e') (hexToInt '0'))
}

to '_8bit_4bit_RISC 2 palette' {
  return ('[data:makeList]' (hexToInt 'ffffff') (hexToInt 'dddddd') (hexToInt 'bdbdbd') (hexToInt '999999') (hexToInt '797979') (hexToInt '535353') (hexToInt '313131') (hexToInt '0') (hexToInt '4299') (hexToInt 'f0f000') (hexToInt 'cd00') (hexToInt 'dd0000') (hexToInt 'f0f0bd') (hexToInt '538900') (hexToInt 'ffbd00') (hexToInt 'bdff'))
}

to '_8bit_4bit_Win & OS/2 palette' {
  return ('[data:makeList]' (hexToInt '0') (hexToInt '800000') (hexToInt '8000') (hexToInt '808000') (hexToInt '80') (hexToInt '800080') (hexToInt '8080') (hexToInt 'c0c0c0') (hexToInt '808080') (hexToInt 'ff0000') (hexToInt 'ff00') (hexToInt 'ffff00') (hexToInt 'ff') (hexToInt 'ff00ff') (hexToInt 'ffff') (hexToInt 'ffffff'))
}

to '_8bit_4bit_grayscale palette' {
  return ('[data:makeList]' 0 1315860 2105376 2894892 3684408 4539717 5329233 6381921 7434609 8553090 9605778 10658466 11974326 13355979 14935011 16777215)
}

to '_8bit_8bit_MicroBlocks palette' {
  return ('[data:join]' ('[data:range]' 0 (hexToInt 'FFFFFF') ((hexToInt 'FFFFFF') / 239)) ('[data:range]' 0 (hexToInt 'FFFFFF') ((hexToInt 'FFFFFF') / 15)))
}

to '_8bit_8bit_blue hues palette' {
  return ('[data:range]' 0 255)
}

to '_8bit_8bit_grayscale palette' {
  return ('[data:range]' 0 (hexToInt 'FFFFFF') ((hexToInt 'FFFFFF') / 255))
}

to '_8bit_8bit_green hues palette' {
  return ('[data:range]' (hexToInt 'FF00') (hexToInt 'FFFF'))
}

to '_8bit_8bit_red hues palette' {
  return ('[data:range]' (hexToInt 'FF0000') (hexToInt 'FF00FF'))
}

to '_bmp_RLEline' filename {
  local 'result' ('[data:newByteArray]' 0)
  forever {
    if ((('[file:readPosition]' filename) & 1) == 1) {file_SkipBytes 1 filename}
    local 'rle' ('[file:readBytes]' 2 filename)
    if ((at 1 rle) == 0) {
      if ((at 2 rle) > 2) {
        comment 'odd numbers for RL4?'
        result = ('[data:join]' result ('[file:readBytes]' ((((at 2 rle) * _bmpBPP) + 7) / 8) filename))
      } else {
        return result
      }
    } else {
      result = ('[data:join]' result ('[data:newByteArray]' ((((at 1 rle) * _bmpBPP) + 7) / 8) (at 2 rle)))
    }
  }
}

to '_bmp_alignLineData' filename {
  if (and (_bmpCompression != 1) (_bmpCompression != 2)) {
    local 'padding' (((32 - ((_bmpWidth * _bmpBPP) % 32)) / 8) % 4)
    if (padding > 0) {
      file_SkipBytes padding filename
    }
  }
}

to '_bmp_line2indexes' {
  local 'mask' ((1 << _bmpBPP) - 1)
  local 'result' ('[data:newByteArray]' 0)
  local 'i' 1
  repeatUntil ((size result) == _bmpWidth) {
    local 'byte' (at i _bmpLine)
    local 'b' (8 / _bmpBPP)
    repeatUntil (or (b < 1) ((size result) == _bmpWidth)) {
      b += -1
      result = ('[data:join]' result ('[data:asByteArray]' ((byte >> (_bmpBPP * b)) & mask)))
    }
    i += 1
  }
  return result
}

to '_bmp_readHeader' filename {
  if (('[file:fileSize]' filename) < 0) {
    sayIt 'File not found: ' filename
    return (booleanConstant false)
  }
  '[file:open]' filename
  if (or (('[file:fileSize]' filename) < 54) ('BM' != ('[data:join]' '' ('[file:readBytes]' 2 filename)))) {
    sayIt 'Not a BMP file: ' filename
    return (booleanConstant false)
  }
  file_SkipBytes 8 filename
  _bmpPixelsOffset = ('_bmp_readInt32' filename)
  local 'headerSize' ('_bmp_readInt32' filename)
  _bmpWidth = ('_bmp_readInt32' filename)
  _bmpHeight = ('_bmp_readInt32' filename)
  file_SkipBytes 2 filename
  _bmpBPP = ('_bmp_readInt16' filename)
  _bmpCompression = ('_bmp_readInt32' filename)
  if (_bmpCompression > 3) {
    sayIt ('[data:join]' 'Unsupported compression method: ' _bmpCompression)
    return (booleanConstant false)
  }
  _bmpPalette = 0
  if (_bmpBPP <= 8) {
    file_SkipBytes 12 filename
    local 'palSize' ('_bmp_readInt16' filename)
    if (palSize == 0) {
      palSize = (1 << _bmpBPP)
    }
    _bmpPalette = (newList palSize)
    file_SkipBytes (headerSize - 34) filename
    '_bmp_readPalette' filename
  } else {
    _bmpIsRGB565 = (booleanConstant false)
    if (_bmpCompression == 3) {
      file_SkipBytes 20 filename
      comment 'BITFIELD  Red'
      _bmpIsRGB565 = (('_bmp_readInt32' filename) == (hexToInt 'F800'))
    }
  }
  return (booleanConstant true)
}

to '_bmp_readInt16' filename {
  local 'data' ('[file:readBytes]' 2 filename)
  return (((at 2 data) << 8) | (at 1 data))
}

to '_bmp_readInt32' filename {
  local 'data' ('[file:readBytes]' 4 filename)
  return ((((at 4 data) << 24) | ((at 3 data) << 16)) | (((at 2 data) << 8) | (at 1 data)))
}

to '_bmp_readLine' filename {
  if (or (_bmpCompression == 1) (_bmpCompression == 2)) {
    _bmpLine = ('_bmp_RLEline' filename)
  } else {
    _bmpLine = ('[file:readBytes]' (((_bmpWidth * _bmpBPP) + 7) / 8) filename)
  }
  if (_bmpBPP < 8) {
    local 'indexes' ('_bmp_line2indexes')
    _bmpLine = indexes
  }
}

to '_bmp_readPalette' filename {
  for i (size _bmpPalette) {
    local 'data' ('[file:readBytes]' 4 filename)
    local 'color' (((at 3 data) << 16) | (((at 2 data) << 8) | (at 1 data)))
    atPut i _bmpPalette color
  }
}

to '_sqrt _' n {
  for i n {
    if ((i * i) >= n) {return i}
  }
}

to bitmap width 'bitmap string' {
  local 'list' ('[data:makeList]')
  for line ('[data:split]' (v 'bitmap string') ('[data:unicodeString]' 10)) {
    for bit line {
      '[data:addLast]' (hexToInt bit) list
    }
  }
  return ('[data:makeList]' width ('[data:asByteArray]' list))
}

to 'bitmap from BMP file' filename {
  if (not ('_bmp_readHeader' filename)) {return 0}
  if (_bmpBPP > 8) {return 1}
  '[file:setReadPosition]' _bmpPixelsOffset filename
  local 'buf' ('[data:newByteArray]' 0)
  repeat (absoluteValue _bmpHeight) {
    '_bmp_readLine' filename
    if (_bmpHeight >= 0) {
      buf = ('[data:join]' _bmpLine buf)
    } else {
      buf = ('[data:join]' buf _bmpLine)
    }
    '_bmp_alignLineData' filename
  }
  return ('[data:makeList]' _bmpWidth buf)
}

to 'bitmap from file' width 'file name' {
  '[file:open]' (v 'file name')
  local 'bitmap' ('[data:newByteArray]' ('[file:fileSize]' (v 'file name')))
  for i ('[file:fileSize]' (v 'file name')) {
    atPut i bitmap (at 1 ('[file:readBytes]' 1 (v 'file name')))
  }
  '[file:close]' (v 'file name')
  return ('[data:makeList]' width bitmap)
}

to 'clear display' {
  '[display:mbDisplayOff]'
}

to 'draw buffer' 'region x' 'region y' width height {
  if (not (isType _8bit_palette 'list')) {_8bit_palette = ('[data:makeList]' '0' 'AA' 'AA00' 'AAAA' 'AA0000' 'AA00AA' 'AA5500' 'AAAAAA' '555555' '5555FF' '55FF55' '55FFFF' 'FF5555' 'FF55FF' 'FFFF55' 'FFFFFF')}
  if ((pushArgCount) < 1) {
    '[tft:drawBuffer]' _8bit_buffer _8bit_palette _8bit_scale
  } else {
    '[tft:drawBuffer]' _8bit_buffer _8bit_palette _8bit_scale (v 'region x') (v 'region y') width height
  }
  waitMicros 500
}

to 'draw palette table' palette {
  if (not (isType palette 'list')) {if (isType _8bit_palette 'list') {
    palette = _8bit_palette
  } else {
    return 0
  }}
  local 'side' ('_sqrt _' (size palette))
  local 'width' (('[tft:getWidth]') / side)
  for y side {
    for x side {
      local 'index' (((y - 1) * side) + x)
      if (index <= (size palette)) {
        '[tft:rect]' ((x - 1) * width) ((y - 1) * width) width width (at index palette)
      }
    }
  }
}

to merge bitmap 'origin x' 'origin y' {
  if (_8bit_scale == 0) {'set scale _' 2}
  '[tft:mergeBitmap]' (at 2 bitmap) (at 1 bitmap) _8bit_buffer _8bit_scale _8bit_alpha_index (v 'origin x') (v 'origin y')
}

to 'palette from BMP file' filename {
  if ('_bmp_readHeader' filename) {return _bmpPalette}
}

to 'palette from pal format' 'file name' {
  '[file:open]' (v 'file name')
  local 'palette' (newList (('[file:fileSize]' (v 'file name')) / 3))
  for i (('[file:fileSize]' (v 'file name')) / 3) {
    atPut i palette ((((at 1 ('[file:readBytes]' 1 (v 'file name'))) << 16) | ((at 1 ('[file:readBytes]' 1 (v 'file name'))) << 8)) | (at 1 ('[file:readBytes]' 1 (v 'file name'))))
  }
  '[file:close]' (v 'file name')
  return palette
}

to 'screen height' {
  return (('[tft:getHeight]') / _8bit_scale)
}

to 'screen width' {
  return (('[tft:getWidth]') / _8bit_scale)
}

to 'set palette' 'color list' {
  _8bit_palette = (v 'color list')
}

to 'set scale _' scale {
  _8bit_scale = scale
  _8bit_buffer = ('[data:newByteArray]' (('screen width') * ('screen height')) 0)
}

to 'set transparent color index _' 'alpha index' {
  _8bit_alpha_index = (v 'alpha index')
}

module BMP Output
author 'JosÃ© GarcÃ­a Yeste'
version 2 2 
depends TFT Files 
description 'Display BMP files on a TFT screen.

BMP files can be transferred to and from boards with a file systems using the put/get commands in the IDE file menu (available in "show advanced blocks" mode).

Dragging a BMP file over microBlocks also loads the file into the file system.

This library works with uncompressed BMP files with 1, 4, 8, 16, 24 and 32 bits per pixel. v2.0 supports 4 and 8 bit RLE compressed files.

Tested with GIMP, online-convert.com and convert.io generated files.

'
variables _bmpPalette _bmpIsRGB565 _bmpPixelsOffset _bmpWidth _bmpHeight _bmpBPP _bmpCompression _bmpLine 

  spec ' ' 'drawBMPfile' 'display BMP file _ at x _ y _' 'str num num' 'image.bmp' 0 0
  space
  spec 'r' '_bmp_readHeader' '_bmp_readHeader file _' 'str' ''
  spec ' ' '_bmp_drawBMP' '_bmp_drawBMP file _ x _ y _' 'str num num' '' 0 0
  spec ' ' '_bmp_drawBMPPixels' '_bmp_drawBMPPixels file _ x _ y _ with function _' 'str num num str' '' 0 0 '[tft:setPixel]'
  space
  spec 'r' '_bmp_readPixelLine' '_bmp_readPixelLine file _' 'str' ''
  spec 'r' '_bmp_16BitPixel' '_bmp_16BitPixel from _ starting at _' 'str num' '' 1
  spec 'r' '_bmp_24BitPixel' '_bmp_24BitPixel from _ starting at _' 'str num' '' 1
  spec ' ' '_bmp_readPalette' '_bmp_readPalette file _' 'auto' ''
  spec ' ' '_bmp_readLine' '_bmp_readLine file _' 'auto' ''
  spec 'r' '_bmp_line2indexes' '_bmp_line2indexes'
  spec 'r' '_bmp_RLEline' '_bmp_readRLELine file _' 'auto' ''
  space
  spec 'r' '_bmp_readInt16' '_bmp read int16 file _' 'str' ''
  spec 'r' '_bmp_readInt32' '_bmp read int32 file _' 'str' ''
  spec ' ' '_bmp_alignLineData' '_bmp_alignLineData file _' 'auto' ''

to '_bmp_16BitPixel' data i {
  local 'pixel' (((at (i + 1) data) << 8) | (at i data))
  if _bmpIsRGB565 {
    local 'r' ((pixel >> 8) & 248)
    local 'g' ((pixel >> 3) & 248)
  } else {
    local 'r' ((pixel >> 7) & 248)
    local 'g' ((pixel >> 2) & 248)
  }
  local 'b' ((pixel & 31) << 3)
  return ((r << 16) | ((g << 8) | b))
}

to '_bmp_24BitPixel' data i {
  return ((((at (i + 2) data) << 16) | ((at (i + 1) data) << 8)) | (at i data))
}

to '_bmp_RLEline' filename {
  local 'result' ('[data:newByteArray]' 0)
  forever {
    if ((('[file:readPosition]' filename) & 1) == 1) {file_SkipBytes 1 filename}
    local 'rle' ('[file:readBytes]' 2 filename)
    if ((at 1 rle) == 0) {
      if ((at 2 rle) > 2) {
        comment 'odd numbers for RL4?'
        result = ('[data:join]' result ('[file:readBytes]' ((((at 2 rle) * _bmpBPP) + 7) / 8) filename))
      } else {
        return result
      }
    } else {
      result = ('[data:join]' result ('[data:newByteArray]' ((((at 1 rle) * _bmpBPP) + 7) / 8) (at 2 rle)))
    }
  }
}

to '_bmp_alignLineData' filename {
  if (and (_bmpCompression != 1) (_bmpCompression != 2)) {
    local 'padding' (((32 - ((_bmpWidth * _bmpBPP) % 32)) / 8) % 4)
    if (padding > 0) {
      file_SkipBytes padding filename
    }
  }
}

to '_bmp_drawBMP' filename originX originY {
  '[file:setReadPosition]' _bmpPixelsOffset filename
  if (_bmpHeight >= 0) {
    local 'y' ((originY + _bmpHeight) - 1)
    local 'yIncrement' -1
  } else {
    local 'y' originY
    local 'yIncrement' 1
  }
  local 'optimize' ((boardType) != 'Boardie')
  repeat (absoluteValue _bmpHeight) {
    local 'line' ('_bmp_readPixelLine' filename)
    if optimize {
      local 'rep' 1
      local 'lastColor' (at 1 line)
      for x (size line) {
        if ((at x line) != lastColor) {
          '[tft:line]' ((x - rep) + originX) y ((x - 1) + originX) y lastColor
          lastColor = (at x line)
          rep = 1
        } else {
          rep += 1
        }
      }
      '[tft:line]' ((x - rep) + originX) y ((x - 1) + originX) y lastColor
    } else {
      for x (size line) {
        '[tft:setPixel]' ((x - 1) + originX) y (at x line)
      }
    }
    y += yIncrement
  }
}

to '_bmp_drawBMPPixels' filename originX originY setPixelFunction {
  comment 'Much slower than _bmp_drawBMP but allows client to supply
a setPixelFunction, so it can be used to draw a BMP file
file onto other devices such as a NeoPixel panel.'
  '[file:setReadPosition]' _bmpPixelsOffset filename
  if (_bmpHeight >= 0) {
    local 'y' ((originY + _bmpHeight) - 1)
    local 'yIncrement' -1
  } else {
    local 'y' originY
    local 'yIncrement' 1
  }
  local 'parameters' (newList 3)
  repeat (absoluteValue _bmpHeight) {
    local 'line' ('_bmp_readPixelLine' filename)
    for x (size line) {
      atPut 1 parameters (originX + (x - 1))
      atPut 2 parameters y
      atPut 3 parameters (at x line)
      callCustomCommand setPixelFunction parameters
    }
    y += yIncrement
  }
}

to '_bmp_line2indexes' {
  local 'mask' ((1 << _bmpBPP) - 1)
  local 'result' ('[data:newByteArray]' 0)
  local 'i' 1
  repeatUntil ((size result) == _bmpWidth) {
    local 'byte' (at i _bmpLine)
    local 'b' (8 / _bmpBPP)
    repeatUntil (or (b < 1) ((size result) == _bmpWidth)) {
      b += -1
      result = ('[data:join]' result ('[data:asByteArray]' ((byte >> (_bmpBPP * b)) & mask)))
    }
    i += 1
  }
  return result
}

to '_bmp_readHeader' filename {
  if (('[file:fileSize]' filename) < 0) {
    sayIt 'File not found: ' filename
    return 'false'
  }
  '[file:open]' filename
  if (or (('[file:fileSize]' filename) < 54) ('BM' != ('[data:join]' '' ('[file:readBytes]' 2 filename)))) {
    sayIt 'Not a BMP file: ' filename
    return false
  }
  file_SkipBytes 8 filename
  _bmpPixelsOffset = ('_bmp_readInt32' filename)
  local 'headerSize' ('_bmp_readInt32' filename)
  _bmpWidth = ('_bmp_readInt32' filename)
  _bmpHeight = ('_bmp_readInt32' filename)
  file_SkipBytes 2 filename
  _bmpBPP = ('_bmp_readInt16' filename)
  _bmpCompression = ('_bmp_readInt32' filename)
  if (_bmpCompression > 3) {
    sayIt ('[data:join]' 'Unsupported compression method: ' _bmpCompression)
    return false
  }
  _bmpPalette = 0
  if (_bmpBPP <= 8) {
    file_SkipBytes 12 filename
    local 'palSize' ('_bmp_readInt16' filename)
    if (palSize == 0) {
      palSize = (1 << _bmpBPP)
    }
    _bmpPalette = (newList palSize)
    file_SkipBytes (headerSize - 34) filename
    '_bmp_readPalette' filename
  } else {
    _bmpIsRGB565 = (booleanConstant false)
    if (_bmpCompression == 3) {
      file_SkipBytes 20 filename
      comment 'BITFIELD  Red'
      _bmpIsRGB565 = (('_bmp_readInt32' filename) == (hexToInt 'F800'))
    }
  }
  return true
}

to '_bmp_readInt16' filename {
  local 'data' ('[file:readBytes]' 2 filename)
  return (((at 2 data) << 8) | (at 1 data))
}

to '_bmp_readInt32' filename {
  local 'data' ('[file:readBytes]' 4 filename)
  return ((((at 4 data) << 24) | ((at 3 data) << 16)) | (((at 2 data) << 8) | (at 1 data)))
}

to '_bmp_readLine' filename {
  if (or (_bmpCompression == 1) (_bmpCompression == 2)) {
    _bmpLine = ('_bmp_RLEline' filename)
  } else {
    _bmpLine = ('[file:readBytes]' (((_bmpWidth * _bmpBPP) + 7) / 8) filename)
  }
  if (_bmpBPP < 8) {
    local 'indexes' ('_bmp_line2indexes')
    _bmpLine = indexes
  }
}

to '_bmp_readPalette' filename {
  for i (size _bmpPalette) {
    local 'data' ('[file:readBytes]' 4 filename)
    local 'color' (((at 3 data) << 16) | (((at 2 data) << 8) | (at 1 data)))
    atPut i _bmpPalette color
  }
}

to '_bmp_readPixelLine' filename {
  local 'result' ('[data:makeList]')
  '_bmp_readLine' filename
  if (_bmpBPP <= 8) {
    for i _bmpLine {
      '[data:addLast]' (at (i + 1) _bmpPalette) result
    }
  } else {
    local 'i' 1
    repeatUntil ((size result) == _bmpWidth) {
      if (_bmpBPP == 16) {
        '[data:addLast]' ('_bmp_16BitPixel' _bmpLine i) result
      } else {
        '[data:addLast]' ('_bmp_24BitPixel' _bmpLine i) result
      }
      i += (maximum (_bmpBPP / 8) 1)
    }
  }
  '_bmp_alignLineData' filename
  return result
}

to drawBMPfile filename originX originY {
  if ('_bmp_readHeader' filename) {
    '_bmp_drawBMP' filename originX originY
    '[file:close]' filename
  }
}

module 'HSV Colors' Operators
author MicroBlocks
version 1 1 
depends Fractions 
description 'HSV to RGB color conversions.
'

  spec 'r' 'HSV_hsv_to_color' 'color of hue _ saturation _ brightness _ (0-100)' 'num num num' 0 100 50
  spec 'r' 'HSV_hsv_rgb' 'RGB of hue _ saturation _ brightness _ (0-100)' 'num num num' 0 100 50
  space
  spec 'r' 'HSV_rgb_to_color' 'color of r _ g _ b _ (0-255)' 'num num num' 128 0 0
  spec 'r' 'HSV_rgb_to_hsv' 'HSV of r _ g _ b _' 'num num num' 128 0 0
  space
  spec 'r' 'HSV_color_to_hsv' 'HSV of color _' 'color'
  spec 'r' 'HSV_color_to_rgb' 'RBG of color _' 'color'

to HSV_color_to_hsv color {
  return (HSV_rgb_to_hsv ((color >> 16) & 255) ((color >> 8) & 255) (color & 255))
}

to HSV_color_to_rgb color {
  return ('[data:makeList]' ((color >> 16) & 255) ((color >> 8) & 255) (color & 255))
}

to HSV_hsv_rgb h s v {
  comment 'return a list representing the corresponding RGB values for the given HSV color
ranges hsv from 0 to 100, rgb from 0 to 255'
  h = (FRACT h 360)
  s = (FRACT s 100)
  v = (FRACT v 100)
  local 'i' (FRACT_integer (FRACT_multiply h 6))
  local 'fract' (FRACT_subtract (FRACT_multiply h 6) i)
  local 'p' (FRACT_multiply v (FRACT_subtract 1 s))
  local 'q' (FRACT_multiply v (FRACT_subtract 1 (FRACT_multiply fract s)))
  local 't' (FRACT_multiply v (FRACT_subtract 1 (FRACT_multiply (FRACT_subtract 1 fract) s)))
  local 'case' (i % 6)
  local 'r' 0
  local 'g' 0
  local 'b' 0
  if (case == 0) {
    r = v
    g = t
    b = p
  } (case == 1) {
    r = q
    g = v
    b = p
  } (case == 2) {
    r = p
    g = v
    b = t
  } (case == 3) {
    r = p
    g = q
    b = v
  } (case == 4) {
    r = t
    g = p
    b = v
  } (case == 5) {
    r = v
    g = p
    b = q
  }
  return ('[data:makeList]' (FRACT_integer (FRACT_multiply r 255)) (FRACT_integer (FRACT_multiply g 255)) (FRACT_integer (FRACT_multiply b 255)))
}

to HSV_hsv_to_color h s v {
  local 'rgb' (HSV_hsv_rgb h s v)
  return (((at 1 rgb) << 16) | (((at 2 rgb) << 8) | (at 3 rgb)))
}

to HSV_rgb_to_color r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to HSV_rgb_to_hsv r g b {
  local 'r_' (FRACT r 255)
  local 'g_' (FRACT g 255)
  local 'b_' (FRACT b 255)
  local 'max' (maximum r g b)
  local 'min' (minimum r g b)
  local 'hsv' ('[data:makeList]' 0 0 (FRACT_integer (FRACT_multiply 100 (FRACT max 255))))
  if (min != max) {
    local 'delta' (FRACT (max - min) 255)
    atPut 2 hsv (FRACT_integer (FRACT_multiply 100 (FRACT delta (FRACT max 255))))
    local 'h' (FRACT 1 delta)
    if (max == r) {
      h = (FRACT_multiply h (FRACT_subtract g_ b_))
    }
    if (max == g) {
      h = (FRACT_add (FRACT_multiply h (FRACT_subtract b_ r_)) 2)
    }
    if (max == b) {
      h = (FRACT_add (FRACT_multiply h (FRACT_subtract r_ g_)) 4)
    }
    h = (FRACT_integer (FRACT_multiply 60 h))
    if (h < 0) {
      h += 360
    }
    atPut 1 hsv h
  }
  return hsv
}

module 'LCD Display' Output
author MicroBlocks
version 1 5 
description 'Library for 16x2 LCD text displays with 1602 controller I2C "backpack" like the ones from DFRobot, SunFounder, and others. These displays have two lines of sixteen characters.

Most of these displays require 5 volts to provide sufficient LCD contrast, so you will need an external power source for 3.3v boards like the micro:bit.'
variables _LCD1602_ADDR _LCD1602_LINE1 _LCD1602_LINE2 _LCD1602_LOCK_MSECS 

  spec ' ' 'LCD1602_write' 'write _ on LCD line _' 'str num num num' 'Hello, World!' 1 1 16
  spec ' ' 'LCD1602_write_field' 'write field _ on LCD line _ from _ to _' 'str num num num' 'Moon!' 1 8 12
  spec ' ' 'LCD1602_clear' 'clear LCD'
  spec 'r' 'LCD1602_isConnected' 'is LCD connected?'
  spec 'r' '_LCD1602 init' '_LCD1602 init'
  spec ' ' '_LCD1602 send' '_LCD1602 send byte _ mode _' 'num num' 10 1
  spec ' ' '_LCD1602 toggle enable' '_LCD1602 toggle enable _' 'num' 10

to LCD1602_clear {
  if (not ('_LCD1602 init')) {return}
  waitUntil (((millisOp) - _LCD1602_LOCK_MSECS) > 500)
  _LCD1602_LOCK_MSECS = (millisOp)
  _LCD1602_LINE1 = ('[data:newByteArray]' 16 32)
  _LCD1602_LINE2 = ('[data:newByteArray]' 16 32)
  '_LCD1602 send' 1 0
  _LCD1602_LOCK_MSECS = 0
}

to LCD1602_isConnected {
  return ('_LCD1602 init')
}

to LCD1602_write string line {
  LCD1602_write_field string line 1 16
}

to LCD1602_write_buffer line {
  local 'bytes' 0
  if (line == 1) {
    '_LCD1602 send' (hexToInt '80') 0
    bytes = _LCD1602_LINE1
  } else {
    '_LCD1602 send' (hexToInt 'C0') 0
    bytes = _LCD1602_LINE2
  }
  for b bytes {
    '_LCD1602 send' b 1
  }
}

to LCD1602_write_field string line start end {
  if (not ('_LCD1602 init')) {return}
  string = ('[data:join]' '' string)
  if (or (start < 1) (start > 16)) {
    return
  }
  if (or (end < start) (end > 16)) {
    return
  }
  if (line == 1) {
    bytes = _LCD1602_LINE1
  } else {
    bytes = _LCD1602_LINE2
  }
  waitUntil (((millisOp) - _LCD1602_LOCK_MSECS) > 500)
  _LCD1602_LOCK_MSECS = (millisOp)
  local 'count' ((end - start) + 1)
  for i count {
    local 'char' 32
    if (i <= (size string)) {
      char = ('[data:unicodeAt]' i string)
      if (char > 127) {
        char = 32
      }
    }
    atPut ((start - 1) + i) bytes char
  }
  LCD1602_write_buffer line
  _LCD1602_LOCK_MSECS = 0
}

to '_LCD1602 init' {
  comment 'Return true if already initialized'
  if (_LCD1602_ADDR != 0) {
    return true
  }
  comment 'Use slow I2C speed'
  '[sensors:i2cSetClockSpeed]' 100000
  comment 'Try two common I2C addresses and
use the one that gets a response'
  _LCD1602_ADDR = (hexToInt '27')
  if ((i2cGet _LCD1602_ADDR 0) < 0) {
    _LCD1602_ADDR = (hexToInt '3F')
  }
  if ((i2cGet _LCD1602_ADDR 0) < 0) {
    _LCD1602_ADDR = 0
    comment 'LCD panel not found'
    return false
  }
  _LCD1602_LINE1 = ('[data:newByteArray]' 16 32)
  _LCD1602_LINE2 = ('[data:newByteArray]' 16 32)
  comment 'Initialize display'
  '_LCD1602 send' (hexToInt '33') 0
  '_LCD1602 send' (hexToInt '32') 0
  '_LCD1602 send' (hexToInt '06') 0
  '_LCD1602 send' (hexToInt '0C') 0
  '_LCD1602 send' (hexToInt '28') 0
  '_LCD1602 send' (hexToInt '01') 0
  '[sensors:i2cSetClockSpeed]' 400000
  waitMillis 250
  return true
}

to '_LCD1602 send' bits mode {
  comment 'Use slow I2C speed'
  '[sensors:i2cSetClockSpeed]' 100000
  local '_LCD1602 BACKLIGHT' (hexToInt '8')
  local 'high bits' ((mode | (bits & (hexToInt 'F0'))) | (v '_LCD1602 BACKLIGHT'))
  local 'low bits' ((mode | ((bits << 4) & (hexToInt 'F0'))) | (v '_LCD1602 BACKLIGHT'))
  '[sensors:i2cWrite]' _LCD1602_ADDR (v 'high bits')
  '_LCD1602 toggle enable' (v 'high bits')
  '[sensors:i2cWrite]' _LCD1602_ADDR (v 'low bits')
  '_LCD1602 toggle enable' (v 'low bits')
  comment 'Revert to fast I2C speed'
  '[sensors:i2cSetClockSpeed]' 400000
  waitMillis 1
}

to '_LCD1602 toggle enable' bits {
  local '_LCD1602 ENABLE' 4
  waitMicros 5
  '[sensors:i2cWrite]' _LCD1602_ADDR (bits | (v '_LCD1602 ENABLE'))
  waitMicros 5
  '[sensors:i2cWrite]' _LCD1602_ADDR (bits & ('~' (v '_LCD1602 ENABLE')))
  waitMicros 5
}

module 'LED Dot Matrix (d1 mini)' Output
author MicroBlocks
version 1 1 
tags display d1mini 
description 'Support for the WEMOS 8x8 LED Dot Matrix D1 Mini shield.'
variables '_MLED data pin' '_MLED clock pin' '_MLED buffer' '_MLED intensity' 

  spec ' ' '_MLED display' '_MLED display'
  spec ' ' '_MLED init' '_MLED init'
  spec ' ' '_MLED send' '_MLED send byte _' 'auto' '10'
  spec ' ' '_MLED send command' '_MLED send command _' 'auto' '10'
  spec ' ' '_MLED send data' '_MLED send data _ to address _' 'auto auto' '10' '10'
  spec ' ' 'set dot' 'set dot x _ y _ to _' 'auto auto bool' 3 4 true
  spec ' ' '_MLED stealth set dot x' '_MLED stealth set dot x _ y _ to _' 'auto auto bool' '10' '10' true
  spec ' ' 'clear LED matrix' 'clear LED matrix'
  spec ' ' 'set LED matrix intensity to' 'set LED matrix intensity to _ (1-8)' 'auto' 5

to '_MLED display' {
  for byte 8 {
    '_MLED send data' (at byte (v '_MLED buffer')) (byte - 1)
    digitalWriteOp (v '_MLED data pin') false
    digitalWriteOp (v '_MLED clock pin') false
    digitalWriteOp (v '_MLED clock pin') true
    digitalWriteOp (v '_MLED data pin') true
  }
  '_MLED send command' ((hexToInt '88') | (v '_MLED intensity'))
}

to '_MLED init' {
  '_MLED clock pin' = 14
  '_MLED data pin' = 13
  '_MLED intensity' = 7
  '_MLED buffer' = ('[data:newByteArray]' 8)
  digitalWriteOp (v '_MLED clock pin') true
  digitalWriteOp (v '_MLED data pin') true
}

to '_MLED send' data {
  local 'data' data
  for bit 8 {
    digitalWriteOp (v '_MLED clock pin') false
    digitalWriteOp (v '_MLED data pin') ((data & 1) == 1)
    data = (data >> 1)
    digitalWriteOp (v '_MLED clock pin') true
  }
}

to '_MLED send command' command {
  digitalWriteOp (v '_MLED data pin') false
  '_MLED send' command
  digitalWriteOp (v '_MLED data pin') true
}

to '_MLED send data' data address {
  '_MLED send command' (hexToInt '44')
  digitalWriteOp (v '_MLED data pin') false
  '_MLED send' ((hexToInt 'C0') | address)
  '_MLED send' data
  digitalWriteOp (v '_MLED data pin') true
}

to '_MLED stealth set dot x' x y draw {
  x = (maximum 1 (minimum x 8))
  y = (maximum 1 (minimum y 8))
  if ((v '_MLED buffer') == 0) {
    '_MLED init'
  }
  if draw {
    atPut y (v '_MLED buffer') ((at y (v '_MLED buffer')) | (1 << (x - 1)))
  } else {
    atPut y (v '_MLED buffer') (('~' (1 << (x - 1))) & (at y (v '_MLED buffer')))
  }
}

to 'clear LED matrix' {
  '_MLED buffer' = ('[data:newByteArray]' 8)
  '_MLED display'
}

to 'set LED matrix intensity to' intensity {
  '_MLED intensity' = (maximum 0 (minimum (intensity - 1) 7))
}

to 'set dot' x y draw {
  '_MLED stealth set dot x' x y draw
  '_MLED display'
}

module NeoPanel Output
author 'JosÃ© GarcÃ­a Yeste & VÃ­ctor Casado'
version 1 1 
depends NeoPixel BMP 
description 'Draw lines, rectangles, text, and images on a NeoPixel panels (e.g. 8x8, 16x16 or 32x8) in either horizontal or vertical orientation. Panels can be daisy-chained to create larger displays if there is sufficient power to drive them.
See: https://www.btf-lighting.com/collections/led-matrix-display/products/ws2812b-panel-screen-8-8-16-16-8-32-pixel-256-pixels-digital-flexible-led-programmed-individually-addressable-full-color-dc5v#
'
variables _neoPanel_width _neoPanel_height _neoPanel_isHorizontal 

  spec ' ' 'neoPanel_attach' 'attach NeoPixel panel width _ height _ at pin _' 'num num num' 8 8 1
  space
  spec ' ' 'neoPanel_drawPixel' 'NeoPanel set x _ y _ color _' 'num num color' 1 1
  spec ' ' 'neoPanel_drawVerticalLine' 'NeoPanel fill column _ color _' 'num color' 1
  spec ' ' 'neoPanel_drawHorizontalLine' 'NeoPanel fill row _ color _' 'num color' 1
  spec ' ' 'neoPanel_fillRectangle' 'NeoPanel fill rectangle x _ y _ width _ height _ color _' 'num num num num color' 1 1 4 4
  space
  spec ' ' 'neoPanel_drawText' 'NeoPanel draw text _ at x _ y _ color _' 'str num num color' 'HELLO' 1 1
  spec ' ' 'neoPanel_drawBMP' 'NeoPanel draw BMP file _ at x _ y _' 'str num num' '' 1 1
  space
  spec 'r' '_neoPanel_indexForXY' '_neoPanel_index for x _ y _' 'num num' 1 1

to '_neoPanel_indexForXY' x y {
  if (or (x < 1) (y < 1)) {return 0}
  if (or (x > _neoPanel_width) (y > _neoPanel_height)) {return 0}
  if _neoPanel_isHorizontal {
    if ((x & 1) == 0) {
      return (((x - 1) * _neoPanel_height) + ((_neoPanel_height - y) + 1))
    } else {
      return (((x - 1) * _neoPanel_height) + y)
    }
  } else {
    if ((y & 1) == 0) {
      return (((y - 1) * _neoPanel_width) + x)
    } else {
      return (((y - 1) * _neoPanel_width) + ((_neoPanel_width - x) + 1))
    }
  }
}

to neoPanel_attach width height pin {
  _neoPanel_width = width
  _neoPanel_height = height
  _neoPanel_isHorizontal = (width >= height)
  neoPixelAttach (_neoPanel_width * _neoPanel_height) pin
}

to neoPanel_drawBMP filename originX originY {
  if (not ('_bmp_readHeader' filename)) {return}
  '[file:setReadPosition]' _bmpPixelsOffset filename
  if (_bmpHeight >= 0) {
    local 'y' ((originY + _bmpHeight) - 1)
    local 'yIncrement' -1
  } else {
    local 'y' originY
    local 'yIncrement' 1
  }
  repeat (absoluteValue _bmpHeight) {
    local 'line' ('_bmp_readPixelLine' filename)
    for x (size line) {
      local 'pixel' ('_neoPanel_indexForXY' (originX + (x - 1)) y)
      if (pixel > 0) {
        atPut pixel _np_pixels (at x line)
      }
    }
    y += yIncrement
  }
  '[file:close]' filename
  '_NeoPixel_update'
}

to neoPanel_drawHorizontalLine y color {
  if (and (y > 0) (y <= _neoPanel_width)) {
    if _neoPanel_isHorizontal {
      local 'index' (((y - 1) * _neoPanel_height) + 1)
      repeat _neoPanel_height {
        atPut index _np_pixels color
        index += 1
      }
    } else {
      local 'index' ((_neoPanel_width - y) + 1)
      repeat (_neoPanel_height / 2) {
        atPut index _np_pixels color
        index += (((y - 1) * 2) + 1)
        atPut index _np_pixels color
        index += ((((_neoPanel_width - y) + 1) * 2) - 1)
      }
    }
    '_NeoPixel_update'
  }
}

to neoPanel_drawPixel x y color {
  setNeoPixelColor ('_neoPanel_indexForXY' x y) color
}

to neoPanel_drawText text x0 y0 color {
  for letter text {
    local 'shape' ('[display:mbShapeForLetter]' letter)
    local 'mask' 1
    local 'x' (x0 - 1)
    local 'y' (y0 - 1)
    for c 5 {
      for f 5 {
        if ((shape & mask) != 0) {
          local 'i' ('_neoPanel_indexForXY' (x + f) (y + c))
          if (i > 0) {
            atPut i _np_pixels color
          }
        }
        mask = (mask << 1)
      }
    }
    if _neoPanel_isHorizontal {
      x0 += 5
    } else {
      y0 += 6
    }
  }
  '_NeoPixel_update'
}

to neoPanel_drawVerticalLine x color {
  if (and (x > 0) (x <= _neoPanel_height)) {
    if _neoPanel_isHorizontal {
      local 'index' x
      repeat (_neoPanel_width / 2) {
        atPut index _np_pixels color
        index += (((_neoPanel_height - x) * 2) + 1)
        atPut index _np_pixels color
        index += ((x * 2) - 1)
      }
    } else {
      local 'index' (((x - 1) * _neoPanel_width) + 1)
      atPut index _np_pixels color
      repeat _neoPanel_width {
        atPut index _np_pixels color
        index += 1
      }
    }
    '_NeoPixel_update'
  }
}

to neoPanel_fillRectangle x y width height color {
  local 'column' y
  repeat height {
    local 'row' x
    repeat width {
      atPut ('_neoPanel_indexForXY' row column) _np_pixels color
      row += 1
    }
    column += 1
  }
  '_NeoPixel_update'
}

module 'OLED Graphics' Output
author 'Turgut Guneysu'
version 1 13 
choices DispTypeMenu 'OLED_0.96in' 'OLED_2.42in' 
choices OnOffMenu On Off 
choices VideoMenu Inverse Normal 
choices ModeMenu Horizontal Vertical 
description 'Supports 0.96in and 2.42in OLED Displays with SD1306 and SD1309 chipsets. Comm mode is I2C or SPI.
Changes:
- always display buffer
- defer display updates block
- remove reveal
- switch to x (0-127), y (0-63)
- Pruned commands and vars
- textX and textY
- Text at any x and y
- handles newLines
- removed dependencies
- unified data format for chars, sprites, and images
- image draw at any x,y
- filled rectangle
- image draw bug fix
- stack overflow fix
'
variables OLEDReady OLEDi2cAddr _GDBuffer _begCol _begRow _cDecTBL _comma _cTABLE _comMode _dcPin _delayGDUpd _displayType _endCol _endRow _eol _resetPin _textX _textY _dataPrefix _byteCount _imgData _imgWidth _imgHeight 

  spec ' ' 'OLEDInit_I2C' 'initialize i2c _ address(hex) _ reset pin# _ flip _' 'str.DispTypeMenu auto auto bool' 'OLED_0.96in' '3C' '-' false
  spec ' ' 'OLEDInit_SPI' 'initialize spi _ d/c pin# _ reset pin# _ flip _' 'str.DispTypeMenu auto auto bool' 'OLED_2.42in' 16 8 false
  spec ' ' 'OLEDwrite' 'write _ at x _ y _ inverse _' 'auto auto auto bool' 'Hello!' 0 0 false
  spec ' ' 'OLEDshowGDBuffer' 'show display buffer'
  spec ' ' 'OLEDclear' 'clear'
  spec ' ' 'OLEDcontrast' 'set contrast (1-4) _' 'auto' 2
  spec ' ' 'OLEDdrawCircle' 'draw circle at x _ y _ radius _ erase _' 'auto auto auto bool' 64 32 '10' false
  spec ' ' 'OLEDdrawImage' 'draw image _ at x _ y _' 'auto auto auto' 0 0 0
  spec ' ' 'OLEDdrawLine' 'draw line from x _ y _ to x _ y _ erase _' 'auto auto auto auto bool' 0 0 127 63 false
  spec ' ' 'OLEDdrawRect' 'draw rectangle x _ y _ w _ h _ erase _ rounding(3-15) _' 'auto auto auto auto bool auto' 0 0 127 63 false 0
  spec ' ' 'OLEDfillRect' 'fill rectangle x _ y _ w _ h _ erase _' 'auto auto auto auto bool' 20 20 30 20 false
  spec ' ' 'OLEDflip' '_flip display top _' 'bool' false
  spec 'r' 'OLEDmakeImage' 'make image _' 'microbitDisplay' 33084991
  spec ' ' 'OLEDpixel' 'set pixel x _ y _ erase _' 'auto auto bool' 0 0 false
  spec ' ' 'OLEDsetVideo' 'set video _' 'str.VideoMenu' 'Inverse'
  spec 'r' 'OLEDwru' 'cursor location'
  spec ' ' 'defer display updates' 'defer display updates'
  spec ' ' '_GDDRAMoff' '_GDDRAMoff'
  spec ' ' '_GDDRAMon' '_GDDRAMon'
  spec ' ' '_OLEDcursorReset' '_cursor reset'
  spec ' ' '_OLEDsetDisplay' '_set display _' 'str.OnOffMenu' 'On'
  spec ' ' '_OLEDreset' '_set reset Pin# _' 'auto' '0'
  spec ' ' '_SPIWriteCmd' '_SPIWriteCmd'
  spec ' ' '_SPIWriteData' '_SPIWriteData'
  spec ' ' '_T1' '_T1'
  spec ' ' '_T2' '_T2'
  spec ' ' '_T3' '_T3'
  spec 'r' '_cBMP' '_cBMP _ InvYN _' 'auto bool' '' false
  spec ' ' '_clearDisplay' '_clearDisplay'
  spec ' ' '_corner' '_corner _ _ _ _ _' 'auto auto auto auto bool' 'TL' 32 1 0 true
  spec 'r' '_dec2hex' '_dec2hex _' 'auto' 0
  spec ' ' '_initChars' '_initChars'
  spec ' ' '_initCheck' '_initCheck'
  spec ' ' '_initDisplayHW' '_initDisplayHW'
  spec ' ' '_initLibrary' '_initLibrary'
  spec ' ' '_process image data' '_process image data _' 'auto' ' '
  spec ' ' '_sendCmd' '_sendCmd _' 'auto' ''
  spec ' ' '_verifyXY' '_verifyXY _ _' 'auto auto' 0 0

to OLEDInit_I2C dispType i2cAddr resetPin flip {
  comment 'Sets display type and interface and initializes HW settings.
Do NOT set a ResetPin# unless one exists on the display hardware.
NOTE:
Displays supported:
- OLED 0.96in (SD1306 chip) and
- OLED 2.42" (SD1309 chip)
Both displays are 128x64 pixels or 16x8 characters in size.
Displays come in dual mode version (i2c and spi) and pure i2c.
Pure i2c models do not have a Reset pin.

flip setting controls display hardware write direction:
- false: top to bottom
- true: bottom to top'
  _comma = ('[data:unicodeString]' 44)
  _comMode = 'i2c'
  OLEDi2cAddr = (hexToInt ('[data:join]' ('[data:unicodeString]' 32) i2cAddr))
  if (_displayType != 0) { 
    return
  }
  if (dispType == 'OLED_0.96in') {
    _displayType = 6
    _resetPin = resetPin
  } else {
    _displayType = 9
    _resetPin = resetPin
  }
  '_initDisplayHW'
  if flip {
    OLEDflip true
  }
  '_initLibrary'
  OLEDclear
  OLEDcontrast 4
}

to OLEDInit_SPI dispType dcPin resetPin flip {
  comment 'Sets display type and interface and initializes HW settings.
SPI four wire in Mode-0 is supported. Max speed=10000000.

Do NOT set a ResetPin# unless one exists on the display hardware.
NOTE:
Displays supported:
- OLED 0.96in (SD1306 chip) and
- OLED 2.42" (SD1309 chip)
Both displays are 128x64 pixels or 16x8 characters in size.
Displays come in dual mode version (i2c and spi) and pure i2c.
Pure i2c models do not have a Reset pin.
flip setting controls display hardware write direction:
- false: top to bottom
- true: bottom to top'
  _comma = ('[data:unicodeString]' 44)
  _comMode = 'spi'
  _dcPin = dcPin
  if (_displayType != 0) { 
    return
  }
  if (dispType == 'OLED_0.96in') {
    _displayType = 6
    _resetPin = resetPin
  } else {
    _displayType = 9
    _resetPin = resetPin
  }
  '[sensors:spiSetup]' 10000000
  '_initDisplayHW'
  if flip {
    OLEDflip true
  }
  '_initLibrary'
  OLEDclear
  OLEDcontrast 4
}

to OLEDclear {
  comment 'Set bounds to FullScreen and CLEARs display
and GDBuffer.'
  _GDBuffer = ('[data:newByteArray]' 1024)
  '_initCheck'
  '_OLEDcursorReset'
  OLEDshowGDBuffer
}

to OLEDcontrast contrast {
  comment 'Sets the brightness control of the display to one of four values.
1 is the least bright, 4 is the brightest setting.'
  '_initCheck'
  local 'cLevels' ('[data:makeList]' 0 '1F' '2F' 'F0')
  if (and (contrast >= 1) (contrast <= 4)) {
    local 'i2cCmd' ('[data:join]' '81' _comma (at contrast cLevels))
    '_sendCmd' i2cCmd
  } else {
    sayIt 'Error in CONTRAST Level'
  }
}

to OLEDdrawCircle cx cy r erase {
  comment 'Bresenham Circle:
Draws circles, even partially bigger than the display.
x: 0-127
y: 0-63
void plotCircle(int xm, int ym, int r)
{
   int x = -r, y = 0, err = 2-2*r; /* II. Quadrant */
   do {
      setPixel(xm-x, ym+y); /*   I. Quadrant */
      setPixel(xm-y, ym-x); /*  II. Quadrant */
      setPixel(xm+x, ym-y); /* III. Quadrant */
      setPixel(xm+y, ym+x); /*  IV. Quadrant */
      r = err;
      if (r <= y) err += ++y*2+1;           /* e_xy+e_y < 0 */
      if (r > x || err > y) err += ++x*2+1; /* e_xy+e_x > 0 or no 2nd y-step */
   } while (x < 0);
}'
  '_initCheck'
  local 'x' (-1 * r)
  local 'y' 0
  local 'err' (2 - (2 * r))
  repeatUntil (x >= 0) {
    OLEDpixel (cx - x) (cy + y) erase
    OLEDpixel (cx - y) (cy - x) erase
    OLEDpixel (cx + x) (cy - y) erase
    OLEDpixel (cx + y) (cy + x) erase
    r = err
    if (r <= y) {
      y += 1
      err = (err + ((y * 2) + 1))
    }
    if (or (r > x) (err > y)) {
      x += 1
      err = (err + ((x * 2) + 1))
    }
  }
  if (not _delayGDUpd) {
    OLEDshowGDBuffer
  }
}

to OLEDdrawImage image x y {
  comment '_imgHeight has to be mod8 or 1-8'
  for row# (maximum 1 ((minimum _imgHeight (64 - y)) / 8)) {
    local 'GDidx' ((((y / 8) * 128) + x) + 1)
    local 'imgDispl' ((row# - 1) * _imgWidth)
    for byte# (minimum _imgWidth (128 - x)) {
      comment 'If y is on page boundary, just copy'
      if (0 == (y % 8)) {
        atPut GDidx _GDBuffer (at (imgDispl + byte#) image)
        GDidx += 1
        if (GDidx > 1024) {
          if (not _delayGDUpd) {OLEDshowGDBuffer}
          return 0
        }
      } else {
        comment 'Else, copy GDLowBits + shiftedByte + GDHiBits to GDBuffer and GDBuffer +128'
        local 'shiftedByte' ('_dec2hex' ((at (imgDispl + byte#) image) << (y % 8)))
        local 'temp' 0
        local 'tempHI' ('[data:copyFromTo]' shiftedByte 1 2)
        local 'tempLO' ('[data:copyFromTo]' shiftedByte 3 4)
        local 'GDLowBits' ((1 << (y % 8)) - 1)
        local 'GDHiBits' (255 - GDLowBits)
        tempLO = ((hexToInt tempLO) | ((at GDidx _GDBuffer) & GDLowBits))
        atPut GDidx _GDBuffer tempLO
        if ((GDidx + 128) <= 1024) {
          tempHI = ((hexToInt tempHI) | ((at (GDidx + 128) _GDBuffer) & GDHiBits))
          atPut (GDidx + 128) _GDBuffer tempHI
        }
        GDidx += 1
        if (GDidx > 1024) {
          if (not _delayGDUpd) {OLEDshowGDBuffer}
          return 0
        }
      }
      waitMillis 0
    }
    y += 8
  }
  if (not _delayGDUpd) {
    OLEDshowGDBuffer
  }
}

to OLEDdrawLine x0 y0 x1 y1 erase {
  comment 'Draws a line from x0,y0 to x1,y1 using the Bresenham Algorithm
x: 0-127
y: 0-63
plotLine(int x0, int y0, int x1, int y1)
    dx =  abs(x1-x0);
    sx = x0<x1 ? 1 : -1;
    dy = -abs(y1-y0);
    sy = y0<y1 ? 1 : -1;
    err = dx+dy;  /* error value e_xy */
    while (true)   /* loop */
        plot(x0, y0);
        if (x0 == x1 && y0 == y1) break;
        e2 = 2*err;
        if (e2 >= dy) /* e_xy+e_x > 0 */
            err += dy;
            x0 += sx;
        end if
        if (e2 <= dx) /* e_xy+e_y < 0 */
            err += dx;
            y0 += sy;
        end if
    end while'
  '_initCheck'
  results = ('[data:makeList]')
  local 'dx' (absoluteValue (x1 - x0))
  local 'dy' (-1 * (absoluteValue (y1 - y0)))
  local 'err' (dx + dy)
  local 'e2' 0
  local 'done' (booleanConstant false)
  if (x0 < x1) {
    local 'sx' 1
  } else {
    local 'sx' -1
  }
  if (y0 < y1) {
    local 'sy' 1
  } else {
    local 'sy' -1
  }
  repeatUntil done {
    OLEDpixel x0 y0 erase
    if (and (x0 == x1) (y0 == y1)) {
      done = (booleanConstant true)
    }
    e2 = (2 * err)
    if (e2 >= dy) {
      err += dy
      x0 += sx
    }
    if (e2 <= dx) {
      err += dx
      y0 += sy
    }
  }
  if (not _delayGDUpd) {
    OLEDshowGDBuffer
  }
}

to OLEDdrawRect TLx TLy width height erase cornerRad {
  comment 'Draw Rectangle with optional rounded corners with radius R.
Does not check for reversed rectangle coordinates for round corners.'
  '_initCheck'
  local 'oldDelayGDUpd' _delayGDUpd
  _delayGDUpd = true
  local 'BRx' (TLx + width)
  local 'BRy' (TLy + height)
  if (cornerRad >= 3) {
    '_corner' 'TL' TLx TLy cornerRad erase
    '_corner' 'TR' BRx TLy cornerRad erase
    '_corner' 'BR' BRx BRy cornerRad erase
    '_corner' 'BL' TLx BRy cornerRad erase
    comment 'TOP - Adjust x'
    OLEDdrawLine (TLx + cornerRad) TLy ((BRx - 1) - cornerRad) TLy erase
    comment 'RIGHT- Adjust y'
    OLEDdrawLine BRx ((TLy + 1) + cornerRad) BRx ((BRy - 1) - cornerRad) erase
    comment 'BOTTOM - Adjust x'
    OLEDdrawLine ((BRx - 1) - cornerRad) BRy ((TLx + 1) + cornerRad) BRy erase
    comment 'LEFT - Adjust y'
    OLEDdrawLine TLx ((BRy - 1) - cornerRad) TLx ((TLy + 1) + cornerRad) erase
  } else {
    OLEDdrawLine TLx TLy BRx TLy erase
    OLEDdrawLine BRx (TLy + 1) BRx BRy erase
    OLEDdrawLine (BRx - 1) BRy TLx BRy erase
    OLEDdrawLine TLx (BRy - 1) TLx (TLy + 1) erase
  }
  _delayGDUpd = oldDelayGDUpd
  if (not _delayGDUpd) {
    OLEDshowGDBuffer
  }
}

to OLEDfillRect x y w h erase {
  for row h {
    for col w {
      OLEDpixel (x + (col - 1)) (y + (row - 1)) erase
    }
  }
  if (not _delayGDUpd) {
    OLEDshowGDBuffer
  }
}

to OLEDflip flip {
  comment 'Flips the display initialization horizontally or vertically.
Horizontal or vertical is based on the pin connector location.'
  if flip {
    '_sendCmd' 'A0,C0'
  } else {
    '_sendCmd' 'A1,C8'
  }
}

to OLEDmakeImage spr# {
  comment 'Receives a spr# representing 5x5 image matrix.
Converts it to a HOR array of 5 VERT bitmap numbers.
This can be displayed with the draw image block.
sprNum max is 33554431'
  '_initCheck'
  local 'spriteList' ('[data:newByteArray]' 5)
  local 'val' 0
  for col 5 {
    for row ('[data:asByteArray]' ('[data:makeList]' 0 5 10 15 20)) {
      local 'bit' (col + row)
      local 'vertBit#' (bit / 5)
      if ((spr# & (1 << (bit - 1))) != 0) {
        if (col != 5) {
          val += (1 << vertBit#)
        } else {
          val += (1 << (vertBit# - 1))
        }
      }
    }
    atPut col spriteList val
    val = 0
  }
  _imgWidth = 5
  _imgHeight = 5
  return spriteList
}

to OLEDpixel x y erase {
  comment 'Places a pixel at x,y in the virtual GDBuffer
Use OLEDshowGDBuffer to display it
1024 Locations
x: 0-127
y: 0-63
page#: 0-7
pagePixel#: 0-7
GDIndex: 1-1024

RangeCheck:
verify x and y are in range of display limits
if X <= num <= Y'
  '_initCheck'
  if (and (and (x >= 0) (x <= 127)) (and (y >= 0) (y <= 63))) {
    local 'page#' (y / 8)
    local 'pagePixel#' (y % 8)
    local 'GDIndex' ((x + ((y / 8) * 128)) + 1)
    local 'byteBMP' (at GDIndex _GDBuffer)
    if (not erase) {
      byteBMP = (byteBMP | (1 << pagePixel#))
    } else {
      comment 'Turn off n th bit'
      byteBMP = (byteBMP & ('~' (1 << pagePixel#)))
    }
    atPut GDIndex _GDBuffer byteBMP
  }
}

to OLEDsetVideo videoMode {
  comment 'Switches the entire display:
Inverse: inverse video mode (bit 0 = on)
Normal: normal video mode (bit 1 = on).
Any image on the display will be preserved when mode changes.'
  '_initCheck'
  if (videoMode == 'Inverse') {
    local 'i2cCmd' 'A7'
  } else {
    local 'i2cCmd' 'A6'
  }
  '_sendCmd' i2cCmd
}

to OLEDshowGDBuffer {
  comment 'Copies contents of virtual _GDBuffer to display
i2c:
   in 61 byte chunks for speed.
   1 byte is used for the command 40
spi:
   fastest is dump buffer
 _GDBuffer is in decimal'
  '_initCheck'
  if (_comMode == 'i2c') {
    local 'idx' 0
    repeat 17 {
      '[sensors:i2cWrite]' OLEDi2cAddr ('[data:join]' _dataPrefix ('[data:copyFromTo]' _GDBuffer idx (idx + 60)))
      idx += 61
    }
  } else {
    '_SPIWriteData'
    '[sensors:spiExchange]' ('[data:copyFromTo]' _GDBuffer 1)
  }
  _delayGDUpd = (booleanConstant false)
}

to OLEDwrite string x y invFlag {
  comment 'Writes strings to display at any x,y; processing CR LF and wrapping at col x.
_textX and _textY are next write locations.'
  '_initCheck'
  local 'oldDelayGDUpd' _delayGDUpd
  _delayGDUpd = true
  '_verifyXY' x y
  local 'origX' x
  if (not (isType string 'string')) {
    string = ('[data:join]' '' string)
  }
  for char string {
    comment 'If in table process it - LINE SET is not supported.'
    if (('[data:find]' char _cTABLE) != -1) {
      OLEDdrawImage ('_cBMP' char invFlag) x y
      x += 8
      if (x > 127) {
        x = origX
        y += 8
        if (y > 63) {
          y = 0
        }
      }
    } (13 == ('[data:unicodeAt]' 1 char)) {
      noop
    } (10 == ('[data:unicodeAt]' 1 char)) {
      x = origX
      y += 8
      if (y > 63) {
        y = 0
      }
    } else {
      comment 'bad char - STOP'
      sayIt 'Invalid CHAR value:' char 'uniCode:' ('[data:unicodeAt]' 1 char)
      stopTask
    }
  }
  _textX = x
  _textY = y
  _delayGDUpd = oldDelayGDUpd
  if (not _delayGDUpd) {
    OLEDshowGDBuffer
  }
}

to OLEDwru {
  comment 'Next Row and Column to print
_textY, _textX'
  return ('[data:asByteArray]' ('[data:makeList]' _textY _textX))
}

to '_GDDRAMoff' {
  comment 'Displays a full empty screen of reverse video.
It disengages the hardware GDBuffer. '
  local 'i2cCmd' 'A5'
  '_sendCmd' i2cCmd
}

to '_GDDRAMon' {
  comment 'It disables the GDDRAMoff mode and engages the hardware GDBuffer for display content.'
  local 'i2cCmd' 'A4'
  '_sendCmd' i2cCmd
}

to '_OLEDcursorReset' {
  comment 'Sets display bounds to full range and resets cursor
to the origin top-left (0,0)
Rows: 0-7
Cols: 0-127
Cursor position is affected by any display operation
and also by OLEDColMode block.'
  '_initCheck'
  local 'cmdString' '22,00,07,21,00,7F'
  '_sendCmd' cmdString
  _textX = 0
  _textY = 0
  _begCol = 0
  _endCol = 127
  _begRow = 0
  _endRow = 7
}

to '_OLEDreset' pin {
  comment 'Does a power off and on on the display,
thus forcing a hardware initialization.'
  digitalWriteOp pin false
  waitMillis 1
  digitalWriteOp pin true
  waitMillis 1
}

to '_OLEDsetDisplay' onoff {
  comment 'Puts the display into
Off:SLEEP   On:WAKE   mode.
Images on display are preserved.'
  '_initCheck'
  if (onoff == 'On') {
    local 'i2cCmd' 'AF'
  } else {
    local 'i2cCmd' 'AE'
  }
  '_sendCmd' i2cCmd
}

to '_SPIWriteCmd' {
  comment 'In SPI mode, we send either a write command
or write data control code. Then follow it with
the appropriate command/data bundle.'
  digitalWriteOp _dcPin false
}

to '_SPIWriteData' {
  comment 'In SPI mode, we send either a write command
or write data control code. Then follow it with
the appropriate command/data bundle.'
  digitalWriteOp _dcPin true
}

to '_T1' {
  comment 'THIN-SS Character Set
Range: space - ?'
  local '_cHEX1' '00000000000000000000005F00000000000007000007000000147F14147F140000242A6B6B2A12000046261008646200304A454D324848000000040300000000001C224100000000000041221C000000082A1C1C1C2A08000008083E080800000000806000000000000808080808080000000060000000000040201008040200003E615149453E000044427F4040000000625151494966000022414949493600101814527F5010000027454545453900003C4A4949493000000301710905030000364949494936000006494949291E00000000660000000000008066000000000008142241000000002424242424240000000041221408000002010151090600'
  local 'idx' 1
  for i 256 {
    atPut i _cDecTBL (hexToInt ('[data:copyFromTo]' _cHEX1 idx (idx + 1)))
    idx += 2
  }
  _cHEX1 = ''
}

to '_T2' {
  comment 'THIN-SS Character Set
Range: @ - _ (underscore)'
  local '_cHEX2' '003E415D55551E00007C121111127C0000417F4949493600001C22414141220000417F4141221C0000417F495D41630000417F491D010300001C224151517200007F080808087F000000417F4100000000304040413F010000417F081422414000417F4140406000007F01020402017F007F010204087F00003E414141413E0000417F4909090600001E212131215E4000417F49192946000026494949493200000301417F410103003F404040403F00000F10204020100F003F40403840403F004122140814224100010244784402010043615149454361007F4141410000000102040810204000004141417F00000008040201020408008080808080808080'
  local 'idx' 1
  for i 256 {
    atPut (256 + i) _cDecTBL (hexToInt ('[data:copyFromTo]' _cHEX2 idx (idx + 1)))
    idx += 2
  }
  _cHEX2 = ''
}

to '_T3' {
  comment 'THIN-SS Character Set
Range: '' - . (last char)'
  local '_cHEX3' '0000000304000000002054545454784000017F304848483000384444444428000030484848317F4000385454545418000000487E490102000098A4A4A4A4780400417F08040478000000447D400000000060808080847D0000017F10284440000000417F40000000007C040478040478007C08040404780000384444444438000084FC98242418000018242498FC840000447C480404180000485454545424000004043F44442000003C404040207C00000C10204020100C003C40403840403C0044281028440000009CA0A0A0A07C00004464544C44000000080836414100000000007700000000000041413608080000020101020201000000000000000000'
  local 'idx' 1
  for i 256 {
    atPut (512 + i) _cDecTBL (hexToInt ('[data:copyFromTo]' _cHEX3 idx (idx + 1)))
    idx += 2
  }
  _cHEX3 = ''
}

to '_cBMP' char invFlag {
  comment 'Returns DEC char bitmap from _cHexTbl and
optionally converts it to inverse (XOR).
Line segments are NOT supported.
A: 00,7c,12,11,12,7c,00
dec:  0,124,18,17,17,124,0
inv:    255,131,237,238,238,131,255'
  local 'key' (((('[data:unicodeAt]' 1 char) - 32) * 8) + 1)
  local 'charList' ('[data:copyFromTo]' _cDecTBL key (key + 7))
  comment 'inverse'
  if invFlag {
    for item# (size charList) {
      atPut item# charList ((at item# charList) ^ 255)
    }
  }
  _imgWidth = 8
  _imgHeight = 8
  return charList
}

to '_clearDisplay' {
  comment 'Clear Screen without initializing _GDBuffer'
  '_initCheck'
  '_OLEDcursorReset'
  local 'clearBuff' ('[data:newByteArray]' 60 0)
  if ('i2c' == _comMode) {
    repeat 17 {
      '[sensors:i2cWrite]' OLEDi2cAddr ('[data:join]' _dataPrefix clearBuff)
    }
    '[sensors:i2cWrite]' OLEDi2cAddr ('[data:join]' _dataPrefix clearBuff)
  } else {
    '_SPIWriteData'
    '[sensors:spiExchange]' ('[data:newByteArray]' 1024)
  }
}

to '_corner' loc cx cy r erase {
  comment 'Calculates and displays the rounded corners for the rectangles.
loc is one of TL, TR, BL, BR ... topLeft, topright, bottomleft, bottomright
cx,cy are the corner coordinates for the rounded corner.
r is the radius in pixels of the arc to be calculated.'
  local 'x' (-1 * r)
  local 'y' 0
  local 'err' (2 - (2 * r))
  if (loc == 'TL') {
    cx += r
    cy += r
  } (loc == 'TR') {
    cx += (-1 * r)
    cy += r
  } (loc == 'BL') {
    cx += r
    cy += (-1 * r)
  } (loc == 'BR') {
    cx += (-1 * r)
    cy += (-1 * r)
  }
  repeatUntil (x >= 0) {
    if (loc == 'TL') {
      OLEDpixel (cx + x) (cy - y) erase
    } (loc == 'TR') {
      OLEDpixel (cx + y) (cy + x) erase
    } (loc == 'BL') {
      OLEDpixel (cx - y) (cy - x) erase
    } (loc == 'BR') {
      OLEDpixel (cx - x) (cy + y) erase
    }
    r = err
    if (r <= y) {
      y += 1
      err = (err + ((y * 2) + 1))
    }
    if (or (r > x) (err > y)) {
      x += 1
      err = (err + ((x * 2) + 1))
    }
  }
}

to '_dec2hex' num {
  comment 'Fast version w/o inversion. (~115uSecs)'
  local '_hexTbl' '0123456789ABCDEF'
  local 'hexNum' ''
  repeatUntil (num < 0) {
    if ((num / 16) != 0) {
      hexNum = ('[data:join]' (at ((num % 16) + 1) _hexTbl) hexNum)
      num = (num / 16)
    } else {
      hexNum = ('[data:join]' (at ((num % 16) + 1) _hexTbl) hexNum)
      num = -1
    }
  }
  comment 'If not half-byte length, pad it.'
  repeatUntil (((size hexNum) % 4) == 0) {
    hexNum = ('[data:join]' '0' hexNum)
  }
  return hexNum
}

to '_initChars' {
  comment 'Creates the character set used in the Library (96 characters)
used JOIN  for SPACE (uni-32) character so it won''t be deleted by mistake.
For each character, _cDecTbl is updated with 8 byte array values.'
  _cTABLE = ('[data:join]' ('[data:unicodeString]' 32) '!"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~.')
  '_T1'
  '_T2'
  '_T3'
}

to '_initCheck' {
  comment 'Verifies Library initialization status.'
  if OLEDReady {
    return 0
  } else {
    sayIt 'Display needs to be initialized before using the library blocks.'
    stopTask
  }
}

to '_initDisplayHW' {
  comment '*** DO NOT CHANGE THESE WITHOUT UNDERSTANDING THEIR MEANINGS ***
*** IT CAN MAKE THE DISPLAY NOT OPERATE CORRECTLY                          ***

Initializes display HW timings
OLED INITIALIZATION STRINGS:
1306: pins are on top
1309: pins are on the right

A8 3F - Multiplex Ratio 0F-3F (16mux to 64mux)
D3 00 - Display Offset (vertical) 00-63
40    - Display Start Line 40-7F (40:0)
A0    - Set Segment Remap A0: Remap 0:0, A1: 127:0                 [A0]
C0    - Scan Direction C0:0-127, C8:127-0                                     [C0]
DA 12 - COM pin hw config 02:double-high 12:normal bits
81 7F - Set contrast 00-FF (00:dimmest, FF:brightest)
A4    - A4:display shows GDRAM, A5:display all ON pixels
A6    - A6:Normal video, A7:Inverse video
D5 F0 - Set display clock HB:OSC freq / LB:divide ratio (00-FF)
D9 22 - Set pre-charge period HB:Phase2 / LB:Phase1 (1-15 DCLK)
DB 20 - Set Vcomh deselect level 20:1306(~0.77xVcc), 34:1309(~0.78xVcc)
8D 14 - Charge Pump Setting 10:disable CP, 14:enable CP
20 00 - Set HORIZONTAL mode
AF    - Display ON/OFF AE:off (sleep mode), AF:on'
  if (_resetPin != '-') {
    '_OLEDreset' _resetPin
  }
  if (9 == _displayType) {
    local 'initCmd' 'A8,3F,D3,00,40,A1,C8,DA,12,81,7F,A4,A6,D5,70,D9,22,DB,34,8D,14,20,00,AF'
  } else {
    local 'initCmd' 'A8,3F,D3,00,40,A1,C8,DA,12,81,7F,A4,A6,D5,70,D9,22,DB,20,8D,14,20,00,AF'
  }
  '_sendCmd' initCmd
}

to '_initLibrary' {
  comment 'Sets all Library variables and initializes the display hardware.
It also initializes the virtual GDBuffer, and clears the display.
NOTE:
Displays supported: OLED1306 (0.96in) and OLED1309 (2.42"), selected via boolean position.
OLED1309 requires the connection of RESET pin to a digital pin.
Both displays are 128x64 pixels or 16x8 characters in size.
Make sure the character hex tables are \n (LF) terminated.
Otherwise, extra lines are added in between and it gets messed up.
eg: A: 00,7C,12,11,11,12,7C,00\n
Max i2c IO is 64 bytes: buffered writes need to be max that size - 16 x 64'
  _comma = ('[data:unicodeString]' 44)
  _eol = ('[data:unicodeString]' 10)
  comment 'Col starts are in HEX'
  _dataPrefix = ('[data:newByteArray]' 1 (hexToInt '40'))
  comment 'There is no FF/255 in th cHexTBL.
this value is used to build the byteArray.'
  _cDecTBL = ('[data:newByteArray]' 768 255)
  _GDBuffer = ('[data:newByteArray]' 1024)
  _textX = 0
  _textY = 0
  _begRow = 0
  _begCol = 0
  _endRow = 7
  _endCol = 127
  _delayGDUpd = (booleanConstant false)
  '_initChars'
  OLEDReady = (booleanConstant true)
  '_OLEDsetDisplay' 'On'
  setUserLED true
  waitMillis 1000
  setUserLED false
}

to '_process image data' image {
  comment 'Processes the new hex image data format.
Each _imgHex gets added to _imgData in DEC byteArray format.
_byteCount keeps track of total bytes processed.
_imgWidth and _imgHeight (mod8) are dimensions.'
  local '_ptr' 1
  comment '_imgData is not initialized yet.'
  if (or (0 == _imgData) (not (isType _imgData 'byte array'))) {
    _imgWidth = (hexToInt ('[data:copyFromTo]' image 1 2))
    _imgHeight = (hexToInt ('[data:copyFromTo]' image 3 4))
    image = ('[data:copyFromTo]' image 5)
    comment 'If _imgHeight is partial byte, adjust to full byte'
    if (not (0 == (_imgHeight % 8))) {
      _imgHeight += (8 - (_imgHeight % 8))
    }
    _imgData = ('[data:newByteArray]' ((_imgWidth * _imgHeight) / 8))
  }
  for byte ((size image) / 2) {
    atPut (_byteCount + byte) _imgData (hexToInt ('[data:copyFromTo]' image _ptr (_ptr + 1)))
    _ptr += 2
  }
  _byteCount += byte
}

to '_sendCmd' cmdString {
  comment 'Input is a comma sep. STRING.
MAKE SURE ALL  INPUT PARAMETERS ARE HEX'
  local '_cList' ('[data:split]' cmdString _comma)
  local 'cmdPrefix' (hexToInt '80')
  if ('i2c' == _comMode) {
    for cmd _cList {
      '[sensors:i2cWrite]' OLEDi2cAddr ('[data:asByteArray]' ('[data:makeList]' cmdPrefix (hexToInt cmd)))
    }
  } else {
    '_SPIWriteCmd'
    for cmd _cList {
      spiSend (hexToInt cmd)
    }
  }
}

to '_verifyXY' x y {
  if (and (and (x >= 0) (x <= 127)) (and (y >= 0) (y <= 63))) {
    return 0
  } else {
    sayIt 'x or y value error:' ('[data:unicodeString]' 10) 'x:' x ' y:' y
    stopTask
  }
}

to 'defer display updates' {
  _delayGDUpd = (booleanConstant true)
}

module 'OLED Turtle' Output
author 'Turgut Guneysu'
version 1 11
depends 'OLED Graphics' dec2anyBase 
choices DegMenu '45' '90' '135' '180' '225' '270' '315' 
choices SizeMenu small large 
choices PenMenu up down 
description 'Turtle Graphics based on the OLED Library.
Will write text anywhere on screen.
Degreee turns are restricted to 45degs.
Changes: Multiline Text support at any x, y with wrap
            and fast/slow draw (slow:by pixel)
         Small and Large Turtles
         Direction bug fix
         +/- direction changes
         Blocks renamed
         Works with OLED Graphics1.11
'
variables Tpen Tdir Tx Ty TShapes _TDirs _TSaveGDBuffInfo TpenPrev _GDIndex _dX _dY _bits _charBMPList _convTBL _TSize _TDisp size dir num timer _idx penDirection penX penY points startX startY endX endY x y string turtle col row 

  spec ' ' 'TCircle' 'draw circle radius _' 'auto' '10'
  spec ' ' 'TClear' 'Tclear'
  spec ' ' 'TGo to x' 'go to x _ y _' 'num num' 0 0
  spec ' ' 'THome' 'home'
  spec ' ' 'TInit' 'initialize turtle _' 'str.SizeMenu' 'large'
  spec ' ' 'TMove' 'move _' 'auto' '10'
  spec ' ' 'TPenDOWN' 'pen down'
  spec ' ' 'TPenUP' 'pen  up'
  spec ' ' 'TPoint in direction' 'point in direction (0-360) _' 'num' 0
  spec ' ' 'TText' 'write text _ x _ y _ fast _' 'auto num num bool' 'hello' 0 0 true
  spec ' ' 'TTurn Deg' 'turn _ degrees' 'auto' 45
  spec 'r' 'WRU' 'wru'
  spec ' ' '_TDraw' '_TDraw X _ Y _' 'num auto' 0 0
  spec ' ' '_TRestoreGDBuff' '_TRestoreGDBuff'
  spec ' ' '_TSaveGDBuff' '_TSaveGDBuff _ _' 'auto auto' '10' '10'
  spec 'r' '_num2TF' '_num2TF _' 'auto' 0
  spec 'r' '_toString' '_toString _' 'auto' ''

to TCircle rad {
  comment 'Go to center of circle x,y
Then call this block with desired radius.
It is also possible to make a circle by moving and turning.'
  if Tpen {
    OLEDdrawCircle Tx Ty rad false
  } else {
    OLEDdrawCircle Tx Ty rad true
  }
}

to TClear {
  comment 'Clears the screen and initlalizes the turtle controls.'
  OLEDclear
  TpenPrev = (booleanConstant false)
  Tpen = (booleanConstant false)
  Tdir = 1
  _TSaveGDBuffInfo = ('[data:makeList]')
}

to 'TGo to x' x y {
  comment 'Places the turtle at x, y.
Image of turtle is based on penDirection.
If PEN is down, a line will be drawn from 
current location to the destination.
If PEN is up, line will be erased.'
  '_TRestoreGDBuff'
  local 'curX' (penX >> 14)
  local 'curY' (penY >> 14)
  if Tpen {
    OLEDdrawLine curX curY x y false
    '_TSaveGDBuff' curX curY
    '_TDraw' x y
  } else {
    OLEDdrawLine curX curY x y true
    '_TSaveGDBuff' curX curY
    '_TDraw' x y
  }
  penX = (x << 14)
  penY = (y << 14)
  TpenPrev = Tpen
}

to THome {
  comment 'Places turtle at the center of screen'
  penDirection = 0
  'TGo to x' 64 32
}

to TInit size {
  comment 'Initializes all turtle controls.
Turtle is either Small (3x3) or Large (5x5).
TShapes is bitmaps of Turtles (LSB-MSB)  starting with ->
 in clockwise rotation, numbered 1-8.

small: 0-7
/1:072  /2:467  /3:262  /4:764  /5:270  /6:731  /7:232  /8:137

large: 0-31
/1:0 0 31 14 4  /2:16 24 28 30 31  /3;4 12 28 12 4  /4:31 30 28 24 16 
/5:4 14 31 0 0  /6:31 15 7 3 1        /7:4 6 7 6 4        /8:1 3 7 15 31'
  _TSaveGDBuffInfo = ('[data:makeList]')
  if (size == 'small') {
    TShapes = ('[data:makeList]' ('[data:makeList]' 0 7 2) ('[data:makeList]' 4 6 7) ('[data:makeList]' 2 6 2) ('[data:makeList]' 7 6 4) ('[data:makeList]' 2 7 0) ('[data:makeList]' 7 3 1) ('[data:makeList]' 2 3 2) ('[data:makeList]' 1 3 7))
    _TSize = 3
    _TDisp = 1
  } else {
    TShapes = ('[data:makeList]' ('[data:makeList]' 0 0 31 14 4) ('[data:makeList]' 16 24 28 30 31) ('[data:makeList]' 4 12 28 12 4) ('[data:makeList]' 31 30 28 24 16) ('[data:makeList]' 4 14 31 0 0) ('[data:makeList]' 31 15 7 3 1) ('[data:makeList]' 4 6 7 6 4) ('[data:makeList]' 1 3 7 15 31))
    _TSize = 5
    _TDisp = 2
  }
  TClear
  THome
}

to TMove steps {
  comment 'Moves the turtle steps at a time. 
If PEN is down, line will be drawn, if  up line will be erased.

Representation:
  penDirection is in hundreths of a degree (e.g. 4500 means 45 degrees)
  penX and penY are scaled by 16384 (2^14)

The sine function takes an angle in hundreds of a degree and returns a
number scaled by 16384. penX and penY are also scaled by 16384.
Those numbers are shifted right by 14 bits to get pixel locations.'
  local 'startX' (penX >> 14)
  local 'startY' (penY >> 14)
  comment 'The cosine is just the sine shifted by 90 degrees.'
  penX += (steps * ('[misc:sin]' (penDirection + 9000)))
  penY += (steps * ('[misc:sin]' penDirection))
  local 'endX' (penX >> 14)
  local 'endY' (penY >> 14)
  '_TRestoreGDBuff'
  if Tpen {
    OLEDdrawLine startX startY endX endY false
    '_TSaveGDBuff' startX startY
    '_TDraw' endX endY
  } else {
    OLEDdrawLine startX startY endX endY true
    '_TSaveGDBuff' startX startY
    '_TDraw' endX endY
  }
  TpenPrev = Tpen
}

to TPenDOWN {
  comment 'Sets PEN down, causing any movement to draw.'
  Tpen = (booleanConstant true)
}

to TPenUP {
  comment 'Sets PEN up.
Movements erase.'
  Tpen = (booleanConstant false)
}

to 'TPoint in direction' dir {
  comment 'Sets value of the penDirection variable.
dir=0 is to the right.
Corresponding turtle image will be to nearest 45 deg.'
  dir = (absoluteValue dir)
  penDirection = ((dir * 100) % 36000)
  comment 'Selects one of 8 cardinal directions:'
  local '_Tdir' 'ââââââââ'
  if (0 == penDirection) {
    Tdir = 1
  } else {
    Tdir = (minimum 8 (((dir / 45) % 45) + 1))
  }
  '_TDraw' Tx Ty
}

to TText string x y fast {
  comment 'Writes text at any x,y location with wrap to next line at x.
If 56 < y < 63, character bitmap will be truncated.
You can use LF (unicode = 10) to skip to next line in text.'
  _dX = 0
  for char string {
    _dY = 0
    if fast {
      '_TRestoreGDBuff'
    }
    if (10 == ('[data:unicodeAt]' 1 char)) {
      _dX = 0
      y += 8
    } (13 == ('[data:unicodeAt]' 1 char)) {
      noop
    } else {
      _charBMPList = ('_cBMP' char false)
      for byte _charBMPList {
        _dY = 0
        for bit ('dec2any Base' '2' byte 8 true) {
          if (not fast) {'_TRestoreGDBuff'}
          if (and ((x + _dX) <= 127) ((y + _dY) <= 63)) {OLEDpixel (x + _dX) (y + _dY) ('_num2TF' bit)}
          comment 'if not fast'
          if (not fast) {
            '_TDraw' (x + _dX) (y + _dY)
          }
          _dY += 1
        }
        _dX += 1
        if ((x + _dX) > 127) {
          _dX = 0
          y += 8
          if (y > 63) {
            y = 0
            _dY = 0
          }
        }
      }
    }
    comment 'if fast'
    if fast {
      '_TDraw' (x + _dX) (y + _dY)
    }
    _textX = (x + _dX)
    _textY = y
  }
}

to 'TTurn Deg' deg {
  comment 'Accepts +/- deg changes and sets penDirection variable.
Corresponding Turtle image will be to nearest 45 deg.'
  local '_Tdir' 'ââââââââ'
  penDirection += (deg * 100)
  if (penDirection < 0) {
    penDirection = ((36000 + penDirection) % 36000)
  } else {
    penDirection = (penDirection % 36000)
  }
  '_TRestoreGDBuff'
  '_TDraw' Tx Ty
}

to WRU {
  comment 'Displays Turtle location and direction info'
  local 'penStat' 'UP'
  if Tpen {
    penStat = 'DOWN'
  }
  return ('[data:join]' ('[data:join]' 'Turtle points to:' (penDirection / 100)) ('[data:join]' ('[data:unicodeString]' 10) 'Located @:') ' x:' Tx ' y:' Ty ('[data:unicodeString]' 10) 'Pen:' penStat)
}

to '_TDraw' x y {
  comment 'Turtle is a large (5x5) or small (3x3) bitmap shape. 
Turtle location x,y is always located at the center of this matrix and is marked by pixel "o".
There are 8 turtle shapes, each rotated clockwise by 45 degrees.
eg: #1 shape is:
..x..
..xx.
..oxx
..xx.
..x..

To calculate the start position to draw the turtle, _Tdisp is used.
_Tdisp is 2 for the large turtle and 1 for the small  turtle. It indicates where the "o"
pixel is, based on the edge of the matrix.
Before drawing a turtle, the previous location of the turtle is restored from  _TSaveGDBuffInfo.
Then the new turtle location matrix is saved to _TSaveGDBuffInfo.'
  comment 'Select turtle image: 1-8'
  if (0 == penDirection) {
    Tdir = 1
  } else {
    Tdir = (minimum 8 ((((penDirection / 100) / 45) % 45) + 1))
  }
  local 'col' (x - _TDisp)
  local 'row' (y - _TDisp)
  comment 'Copy turtle img so the original is not modified.'
  local 'Timg' ('[data:makeList]')
  for byte (at Tdir TShapes) {
    '[data:addLast]' byte Timg
  }
  _imgHeight = _TSize
  _imgWidth = _TSize
  comment 'Adjust Turtle image if matrix is out of bounds.'
  if (col < 0) {
    repeat (absoluteValue col) {
      '[data:delete]' 1 Timg
    }
    _imgWidth += col
    col = 0
  }
  if (row < 0) {
    for i (size Timg) {
      atPut i Timg ((at i Timg) >> (absoluteValue row))
    }
    _imgHeight += row
    row = 0
  }
  local 'turtle' ('[data:asByteArray]' Timg)
  '_TSaveGDBuff' col row
  comment 'Draw Turtle'
  for byte turtle {
    local '_yInc' 0
    for bit ('dec2any Base' '2' byte _TSize true) {
      'defer display updates'
      OLEDpixel col (row + _yInc) ('_num2TF' bit)
      _yInc += 1
    }
    col += 1
  }
  OLEDshowGDBuffer
  Tx = x
  Ty = y
}

to '_TRestoreGDBuff' {
  comment 'Erases the drawn Turtle by restoring the previously saved
GDBuffer content at turtle location.'
  for info _TSaveGDBuffInfo {
    atPut (at 1 info) _GDBuffer (at 2 info)
  }
  if TpenPrev {
    OLEDpixel Tx Ty false
  }
}

to '_TSaveGDBuff' x y {
  comment 'Save GDBuff info of Turtle location to be restored later.
x,y is the top left of Turtle matrix from _TDraw.
_imgWidth and _imgHeight is the adj turtle size.'
  local 'prevIdx' 0
  _TSaveGDBuffInfo = ('[data:makeList]')
  repeat _imgWidth {
    repeat _imgHeight {
      _GDIndex = ((x + ((y / 8) * 128)) + 1)
      if (_GDIndex < 1) {
        _GDIndex = 1
      } (_GDIndex > 1024) {
        _GDIndex = 1024
      }
      if (_GDIndex != prevIdx) {
        '[data:addLast]' ('[data:makeList]' _GDIndex (at _GDIndex _GDBuffer)) _TSaveGDBuffInfo
        prevIdx = _GDIndex
      }
      y += 1
    }
    x += 1
    y += (-1 * _imgHeight)
  }
}

to '_num2TF' num {
  comment 'Converts bitmap 0 and 1 binary info to 
true/false flag info that is used to erase pixels.'
  if (num == 1) {
    return (booleanConstant false)
  } (num == '0') {
    return (booleanConstant true)
  }
}

to '_toString' aStringOrByteArray {
  comment 'If argument is a byte array, convert it to a string. '
  if (not (isType aStringOrByteArray 'string')) {
    local 'list' ('[data:makeList]')
    for i aStringOrByteArray {
      '[data:addLast]' ('[data:unicodeString]' i) list
    }
    aStringOrByteArray = ('[data:joinStrings]' list)
  }
  return aStringOrByteArray
}

module TFT Output
author MicroBlocks
version 1 5 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  space
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

module Turtle Output
author MicroBlocks
version 1 3 
depends TFT 
tags tft graphics draw 
description 'Draw with turtle geometry on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.
'
variables _turtleX _turtleY _turtleHeading _turtlePenIsDown _turtleColor 

	spec ' ' 'home' 'home'
	spec ' ' 'move' 'move _' 'auto' '10'
	spec ' ' 'turnBy' 'turn _ degrees' 'auto' 90
	spec ' ' 'turnFraction' 'turn _ / _ of circle' 'auto auto' 1 4
	spec ' ' 'pen down' 'pen down'
	spec ' ' 'pen up' 'pen up'
	spec ' ' 'set pen color to' 'set pen color to _' 'color'
	spec ' ' 'setPenToRandomColor' 'set pen to random color'
	spec ' ' '[display:mbDisplayOff]' 'clear display'
	spec ' ' 'clearDisplay' 'fill display with _' 'color'
	spec ' ' 'go to x' 'go to x _ y _' 'auto auto' '10' '10'
	spec ' ' 'setHeading' 'point in direction _' 'auto' 0
	spec ' ' '_turtleNotes' '_turtleNotes'

to '_turtleNotes' {
  comment 'Representation:
  _turtleHeading is in hundreths of a degree  (e.g. 4500 means 45 degrees)
  _turtleX and _turtleY are scaled by 16384 (2^14)

The sine function takes an angle in hundreds of a degree and returns a
number scaled by 16384. _turtleX and _turtleY are also scaled by 16384.
Those numbers are shifted right by 14 bits to get pixel locations.'
}

to clearDisplay color {
  '[tft:rect]' 0 0 ('[tft:getWidth]') ('[tft:getHeight]') color true
  comment 'Give the display controller time to finish this operation'
  waitMillis 1
}

to 'go to x' x y {
  local 'startX' (_turtleX >> 14)
  local 'startY' (_turtleY >> 14)
  _turtleX = (((('[tft:getWidth]') / 2) + x) << 14)
  _turtleY = (((('[tft:getHeight]') / 2) - y) << 14)
  local 'endX' (_turtleX >> 14)
  local 'endY' (_turtleY >> 14)
  if _turtlePenIsDown {
    '[tft:line]' startX startY endX endY _turtleColor
  }
}

to home {
  if (0 == _turtlePenIsDown) {
    'set pen color to' (colorSwatch 7 255 1 255)
    '[display:mbDisplayOff]'
    'pen up'
  }
  'go to x' 0 0
  setHeading 0
}

to move n {
  local 'startX' (_turtleX >> 14)
  local 'startY' (_turtleY >> 14)
  comment 'The cosine is just the sine shifted by 90 degrees.'
  _turtleX += (n * ('[misc:sin]' (_turtleHeading + 9000)))
  _turtleY += (n * ('[misc:sin]' _turtleHeading))
  local 'endX' (_turtleX >> 14)
  local 'endY' (_turtleY >> 14)
  if _turtlePenIsDown {
    '[tft:line]' startX startY endX endY _turtleColor
  }
}

to 'pen down' {
  _turtlePenIsDown = (booleanConstant true)
}

to 'pen up' {
  _turtlePenIsDown = (booleanConstant false)
}

to 'set pen color to' color {
  _turtleColor = color
}

to setHeading a {
  _turtleHeading = ((a * 100) % 36000)
}

to setPenToRandomColor {
  local 'c1' (random 150 220)
  local 'c2' (random 0 ((3 * c1) / 4))
  local 'c3' (random 0 ((3 * c1) / 4))
  local 'which' (random 1 3)
  if (1 == which) {
    _turtleColor = ((c1 << 16) | ((c2 << 8) | c3))
  } (2 == which) {
    _turtleColor = ((c2 << 16) | ((c3 << 8) | c1))
  } else {
    _turtleColor = ((c3 << 16) | ((c1 << 8) | c2))
  }
}

to turnBy a {
  _turtleHeading += (a * 100)
  _turtleHeading = (_turtleHeading % 36000)
}

to turnFraction num denom {
  _turtleHeading += ((num * 36000) / denom)
  _turtleHeading = (_turtleHeading % 36000)
}

module Finch
author 'Tom Lauwers'
version 1 1 
description 'Provides support for the BirdBrain Technologies Finch 2 robot.'
choices finchTailMenu '1' '2' '3' '4' All
choices finchMoveMenu Forward Backward
choices robotDirections Forward Backward Right Left
choices finchTurnMenu Right Left
choices finchOrientationMenu 'Beak Up' 'Beak Down' 'Tilt Left' 'Tilt Right' Level 'Upside Down'
choices finchAxisMenu x y z strength
tags birdbrain robot
variables _finch_spi_lock _all_sensors _finch_started _finch_starting _beak_led _all_leds _motor_cmds _blank_list 

	spec ' ' 'Finch Beak Red' 'Finch Beak R _ % G _ % B _ %' 'auto auto auto' 0 0 0
	spec ' ' 'Finch Tail' 'Finch Tail _ R _ % G _ % B _ %' 'menu.finchTailMenu auto auto auto' 'All' 0 0 0
	spec ' ' 'setMove' 'Finch Move _ _ cm at _ %' 'menu.finchMoveMenu auto auto' 'Forward' 10 50
	spec ' ' 'Finch Turn' 'Finch Turn _ _ Â° at _ %' 'menu.finchTurnMenu auto auto' 'Right' 90 50
	spec ' ' 'Finch Wheels L' 'Finch Wheels L _ % R _ %' 'auto auto' 0 0
	spec ' ' 'Finch2 Stop' 'Finch Stop'
	spec 'r' 'Finch Distance (cm)' 'Finch Distance (cm)'
	spec 'r' 'Finch Light' 'Finch _ Light' 'menu.finchTurnMenu' 'Right'
	spec 'r' 'Finch' 'Finch _ Line' 'menu.finchTurnMenu' 'Right'
	spec ' ' 'Finch2 Reset Encoders' 'Finch Reset Encoders'
	spec 'r' 'Finch2 Encoder' 'Finch _ Encoder' 'menu.finchTurnMenu' 'Right'
	spec 'r' 'Finch2 Accelerometer' 'Finch Accelerometer _' 'menu.finchAxisMenu' 'x'
  spec 'r' 'Finch2 Orientation' 'Finch Orientation'
	spec 'r' 'Finch2 Battery' 'Finch Battery'
	spec 'r' '_within' 'bound _ low _ high _' 'auto auto auto' 0 0 100
	spec 'r' '_getPositionControlFlag' 'getPositionControlFlag'
	spec ' ' '_sendMotor' 'sendMotor _ _ _ _' 'auto auto auto auto' '10' '10' '10' '10'
	spec ' ' '_Finch Lock' 'Finch Lock'
	spec ' ' '_Finch SPI Command' 'Finch SPI Command _' 'auto' '10'
	spec ' ' '_Finch Unlock' 'Finch Unlock'
	spec ' ' '_Start Finch' 'Start Finch'
	spec ' ' '_getAllSensors' 'getAllSensors'
	spec ' ' '_updateSensorTask' 'updateSensorTask'

to Finch side {
  '_Start Finch'
  local 'return_val' 0
  if (side == 'Right') {
    return_val = ((at 8 _all_sensors) & (hexToInt '7F'))
  } else {
    return_val = ((at 7 _all_sensors) & (hexToInt '7F'))
  }
  return (100 - (((return_val - 6) * 100) / 121))
}

to 'Finch Beak Red' Red Green Blue {
  '_Start Finch'
  atPut 1 _beak_led ('_within' Red 0 100)
  atPut 2 _beak_led ('_within' Green 0 100)
  atPut 3 _beak_led ('_within' Blue 0 100)
  atPut 2 _all_leds (((at 1 _beak_led) * 255) / 100)
  atPut 3 _all_leds ((('_within' Green 0 100) * 255) / 100)
  atPut 4 _all_leds ((('_within' Blue 0 100) * 255) / 100)
  'Finch SPI Command' _all_leds
}

to 'Finch Distance (cm)' {
  '_Start Finch'
  local 'return_val' 0
  return_val = (((at 3 _all_sensors) << 8) | (at 4 _all_sensors))
  return_val = ((return_val * 919) / 10000)
  return return_val
}

to 'Finch Light' side {
  '_Start Finch'
  local 'correction' 0
  if (side == 'Right') {
    correction = ((((((((6405 * (at 1 _beak_led)) + (14102 * (at 2 _beak_led))) + (50555 * (at 3 _beak_led))) + (398 * ((at 1 _beak_led) * (at 2 _beak_led)))) + (441 * ((at 1 _beak_led) * (at 3 _beak_led)))) + (641 * ((at 2 _beak_led) * (at 3 _beak_led)))) + ((-48 * ((at 1 _beak_led) * ((at 2 _beak_led) * (at 3 _beak_led)))) / 10)) / 1000000)
    return ((('_within' ((at 6 _all_sensors) - correction) 0 100) * 100) / 255)
  } else {
    correction = ((((((((10687 * (at 1 _beak_led)) + (19453 * (at 2 _beak_led))) + (61241 * (at 3 _beak_led))) + (401 * ((at 1 _beak_led) * (at 2 _beak_led)))) + (426 * ((at 1 _beak_led) * (at 3 _beak_led)))) + (646 * ((at 2 _beak_led) * (at 3 _beak_led)))) + ((-44 * ((at 1 _beak_led) * ((at 2 _beak_led) * (at 3 _beak_led)))) / 10)) / 1000000)
    return ((('_within' ((at 5 _all_sensors) - correction) 0 100) * 100) / 255)
  }
}

to 'Finch SPI Command' commands {
  '_Finch Lock'
  if _finch_spi_lock {
    waitMicros 500
    digitalWriteOp 16 false
    waitMicros 100
    for i 16 {
      spiSend (at i commands)
      waitMicros 5
    }
    '_Finch Unlock'
  }
}

to 'Finch Tail' port Red Green Blue {
  '_Start Finch'
  if (port == 'All') {
    for i 4 {
      atPut ((i * 3) + 2) _all_leds ((('_within' Red 0 100) * 255) / 100)
      atPut ((i * 3) + 3) _all_leds ((('_within' Green 0 100) * 255) / 100)
      atPut ((i * 3) + 4) _all_leds ((('_within' Blue 0 100) * 255) / 100)
    }
  } else {
    atPut ((port * 3) + 2) _all_leds ((('_within' Red 0 100) * 255) / 100)
    atPut ((port * 3) + 3) _all_leds ((('_within' Green 0 100) * 255) / 100)
    atPut ((port * 3) + 4) _all_leds ((('_within' Blue 0 100) * 255) / 100)
  }
  'Finch SPI Command' _all_leds
}

to 'Finch Turn' dir degrees speed {
  '_Start Finch'
  '_sendMotor' 0 0 0 0
  local 'l_velocity' 0
  local 'r_velocity' 0
  local 'tick_distance' 0
  local 'positionControlFlag' (booleanConstant false)
  if (degrees != 0) {
    speed = ((('_within' speed -100 100) * 36) / 100)
    tick_distance = ((('_within' degrees 0 360000) * 4335) / 1000)
    if (dir == 'Right') {
      l_velocity = (speed | 128)
      r_velocity = (speed & 127)
    } else {
      r_velocity = (speed | 128)
      l_velocity = (speed & 127)
    }
    '_sendMotor' l_velocity tick_distance r_velocity tick_distance
    waitMillis 50
    repeatUntil (not ('_getPositionControlFlag')) {
      waitMillis 30
    }
  }
}

to 'Finch Wheels L' l_velocity r_velocity {
  '_Start Finch'
  l_velocity = ((('_within' l_velocity -100 100) * 36) / 100)
  r_velocity = ((('_within' r_velocity -100 100) * 36) / 100)
  if (l_velocity >= 0) {
    l_velocity = (l_velocity | 128)
  } else {
    l_velocity = (l_velocity & 127)
  }
  if (r_velocity >= 0) {
    r_velocity = (r_velocity | 128)
  } else {
    r_velocity = (r_velocity & 127)
  }
  '_sendMotor' l_velocity 0 r_velocity 0
}

to 'Finch2 Accelerometer' axis {
  if (axis == 'x') {
    return ('[sensors:tiltX]')
  } else {
    local 'return_val' 0
    if (axis == 'y') {
      return_val = (((('[sensors:tiltY]') * -766) / 1000) - ((('[sensors:tiltZ]') * -643) / 1000))
      return return_val
    } (axis == 'z') {
      return_val = (((('[sensors:tiltY]') * -643) / 1000) + ((('[sensors:tiltZ]') * -766) / 1000))
      return return_val
    }
    return ('[sensors:acceleration]')
  }
}

to 'Finch2 Battery' {
  '_Start Finch'
  return ((((at 9 _all_sensors) + 320) * 937) / 100)
}

to 'Finch2 Encoder' side {
  '_Start Finch'
  local 'return_val' 0
  if (side == 'Right') {
    return_val = ((((at 13 _all_sensors) << 16) | ((at 14 _all_sensors) << 8)) | (at 15 _all_sensors))
  } else {
    return_val = ((((at 10 _all_sensors) << 16) | ((at 11 _all_sensors) << 8)) | (at 12 _all_sensors))
  }
  if (return_val >= (hexToInt '800000')) {
    return_val = (return_val - (hexToInt 'FFFFFF'))
  }
  return_val = ((100 * return_val) / 792)
  return return_val
}

to 'Finch2 Reset Encoders' {
  '_Start Finch'
  atPut 1 _blank_list (hexToInt 'D5')
  'Finch SPI Command' _blank_list
}

to 'Finch2 Stop' {
  'Finch Wheels L' 0 0
}

to SensorLoop {
}

to '_Finch Lock' {
  if (_finch_spi_lock == 0) {_finch_spi_lock = (booleanConstant false)}
  local 'time_out' 0
  repeatUntil (or (not _finch_spi_lock) (time_out > 100)) {
    time_out += 1
    waitMicros 100
  }
  if (not _finch_spi_lock) {
    _finch_spi_lock = (booleanConstant true)
  }
}

to '_Finch Unlock' {
  waitMicros 100
  digitalWriteOp 16 true
  _finch_spi_lock = (booleanConstant false)
}

to '_Start Finch' {
  if (_finch_started == 0) {if (_finch_starting == 0) {
    _finch_starting = (booleanConstant false)
    analogWriteOp 0 0
    digitalWriteOp 2 true
    waitMillis 100
    digitalWriteOp 2 false
    for y 5 {
      for x 5 {
        '[display:mbPlot]' x y
        waitMillis 70
      }
    }
    '_Finch Unlock'
    _beak_led = (newList 3)
    _all_sensors = (newList 16)
    _all_leds = (newList 16)
    _motor_cmds = (newList 16)
    _blank_list = (newList 16)
    atPut 1 _all_leds (hexToInt 'D0')
    atPut 1 _motor_cmds (hexToInt 'D2')
    atPut 2 _motor_cmds (hexToInt 'FF')
    sendBroadcast '_updateSensorTask'
    _finch_started = (booleanConstant true)
    sendBroadcast 'sensor_loop'
    '[display:mbDisplayOff]'
    _finch_starting = (booleanConstant true)
    '_sendMotor' 0 0 0 0
  } else {
    repeatUntil _finch_starting {
      waitMillis 20
    }
  }}
}

to '_getAllSensors' {
  '_Finch Lock'
  if _finch_spi_lock {
    waitMicros 500
    digitalWriteOp 16 false
    waitMicros 100
    for i 16 {
      if (i == 0) {
        spiSend (hexToInt 'D4')
      } else {
        atPut i _all_sensors (spiRecv)
      }
      waitMicros 5
    }
    '_Finch Unlock'
    return (booleanConstant true)
  } else {
    return (booleanConstant false)
  }
}

to '_getPositionControlFlag' {
  '_Start Finch'
  if ((((at 7 _all_sensors) & 128) >> 7) == 1) {
    return (booleanConstant true)
  } else {
    return (booleanConstant false)
  }
}

to '_sendMotor' l_velocity l_distance r_velocity r_distance {
  atPut 3 _motor_cmds l_velocity
  atPut 4 _motor_cmds ((l_distance & (hexToInt 'FF0000')) >> 16)
  atPut 5 _motor_cmds ((l_distance & (hexToInt '00FF00')) >> 8)
  atPut 6 _motor_cmds (l_distance & (hexToInt '0000FF'))
  atPut 7 _motor_cmds r_velocity
  atPut 8 _motor_cmds ((r_distance & (hexToInt 'FF0000')) >> 16)
  atPut 9 _motor_cmds ((r_distance & (hexToInt '00FF00')) >> 8)
  atPut 10 _motor_cmds (r_distance & (hexToInt '0000FF'))
  for i 6 {
    atPut (i + 10) _motor_cmds (hexToInt 'FF')
  }
  'Finch SPI Command' _motor_cmds
}

to '_updateSensorTask' {
  forever {
    '_getAllSensors'
    waitMillis 20
  }
}

to '_within' number low high {
  comment 'Contributed by Tom Lauwers'
  if (number < low) {
    return low
  }
  if (number > high) {
    return high
  }
  return number
}

to setMove dir distance speed {
  '_Start Finch'
  '_sendMotor' 0 0 0 0
  local 'velocity' 0
  local 'tick_distance' 0
  local 'positionControlFlag' (booleanConstant false)
  if (distance != 0) {
    velocity = ((('_within' speed -100 100) * 36) / 100)
    tick_distance = ((('_within' distance 0 10000) * 497) / 10)
    if (dir == 'Forward') {
      velocity = (velocity | 128)
    } else {
      velocity = (velocity & 127)
    }
    '_sendMotor' velocity tick_distance velocity tick_distance
    waitMillis 50
    repeatUntil (not ('_getPositionControlFlag')) {
      waitMillis 30
    }
  }
}

to 'Finch2 Orientation' {
  local 'threshold' 80
  if (('Finch2 Accelerometer' 'y') > threshold) {
    return 'Beak up'
  } (('Finch2 Accelerometer' 'y') < (0 - threshold)) {
    return 'Beak down'
  } (('Finch2 Accelerometer' 'x') > threshold) {
    return 'Tilt left'
  } (('Finch2 Accelerometer' 'x') < (0 - threshold)) {
    return 'Tilt right'
  } (('Finch2 Accelerometer' 'z') > threshold) {
    return 'Upside down'
  } (('Finch2 Accelerometer' 'z') < (0 - threshold)) {
    return 'Level'
  }
  return 'In between'
}
module Hummingbird
author 'Tom Lauwers'
version 1 0
description 'Provides blocks for the Birdbrain Technologies Hummingbird bit kit.'
choices hummingbirdSensorsMenu Light Dial 'Distance (cm)' Sound Other
tags birdbrain hummingbird bit led servo sensor

variables _spi_lock

	spec ' ' 'Hummingbird LED' 'Hummingbird LED _  _ %' 'menu.range:1-3 num' 1 0
	spec ' ' 'Hummingbird Tri-LED' 'Hummingbird Tri-LED _ R _ % G _ % B _ %' 'menu.range:1-2 num num num' 1 0 0 0
	spec ' ' 'Hummingbird Position Servo' 'Hummingbird Position Servo _ _ Â°' 'menu.range:1-4 num' 1 90
	spec ' ' 'Hummingbird Rotation Servo' 'Hummingbird Rotation Servo _ _ %' 'menu.range:1-4 num' 1 0
	spec 'r' 'Hummingbird Sensor' 'Hummingbird _ _' 'menu.hummingbirdSensorsMenu menu.range:1-3' 'Light' 1
	spec 'r' 'Hummingbird Battery Voltage (mV)' 'Hummingbird Battery (mV)'
	spec ' ' '_SPI HB Lock' 'SPI HB Lock'
	spec ' ' '_SPI HB Unlock' 'SPI HB Unlock'
	spec ' ' '_Hummingbird Command' 'SPI Command _ _ _ _' 'num num num num'
	spec 'r' '_within' '_ within _ and _' 'num num num' 10 0 100

to 'Hummingbird Battery Voltage (mV)' {
  comment 'Contributed by Tom Lauwers'
  return (('Hummingbird Sensor' 'Other' 4) * 96)
}

to 'Hummingbird LED' port intensity {
  comment 'Contributed by Tom Lauwers'
  intensity = ('_within' intensity 0 100)
  port = ('_within' port 1 3)
  if (port == 1) {
    '_Hummingbird Command' 192 ((intensity * 51) / 20) 255 255
  } (port == 2) {
    analogWriteOp 2 (intensity * 10)
  } (port == 3) {
    analogWriteOp 8 (intensity * 10)
  }
}

to 'Hummingbird Position Servo' port angle {
  comment 'Contributed by Tom Lauwers'
  angle = ((('_within' angle 0 180) * 254) / 180)
  port = (('_within' port 1 4) + 197)
  '_Hummingbird Command' port angle 255 255
}

to 'Hummingbird Rotation Servo' port speed {
  comment 'Contributed by Tom Lauwers'
  if (and (speed < 2) (speed > -2)) {
    speed = 255
  } else {
    speed = (128 + ((('_within' speed -100 100) * 23) / 100))
  }
  port = (('_within' port 1 4) + 197)
  '_Hummingbird Command' port speed 255 255
}

to 'Hummingbird Sensor' type port {
  comment 'Contributed by Tom Lauwers'
  local 'return_val' 0
  local 'trash' 0
  port = ('_within' port 1 4)
  '_SPI HB Lock'
  trash = (spiRecv)
  waitMicros 100
  trash = (spiRecv)
  waitMicros 100
  trash = (spiRecv)
  waitMicros 100
  trash = (spiRecv)
  waitMicros 100
  digitalWriteOp 16 true
  waitMicros 500
  digitalWriteOp 16 false
  waitMicros 50
  if (port == 1) {
    return_val = (spiRecv)
  } else {
    trash = (spiRecv)
  }
  waitMicros 100
  if (port == 2) {
    return_val = (spiRecv)
  } else {
    trash = (spiRecv)
  }
  waitMicros 100
  if (port == 3) {
    return_val = (spiRecv)
  } else {
    trash = (spiRecv)
  }
  waitMicros 100
  if (port == 4) {
    return_val = (spiRecv)
  } else {
    trash = (spiRecv)
  }
  '_SPI HB Unlock'
  if (type == 'Distance (cm)') {
    return_val = ((return_val * 117) / 100)
  } (type == 'Sound') {
    return_val = ((return_val * 40) / 51)
  } (type == 'Dial') {
    return_val = ((return_val * 10) / 23)
    if (return_val > 100) {
      return_val = 100
    }
  } else {
    return_val = ((return_val * 20) / 51)
  }
  return return_val
}

to 'Hummingbird Tri-LED' port red green blue {
  comment 'Contributed by Tom Lauwers'
  red = ('_within' red 0 100)
  green = ('_within' green 0 100)
  blue = ('_within' blue 0 100)
  port = ('_within' port 1 2)
  '_Hummingbird Command' (port + 195) ((red * 51) / 20) ((green * 51) / 20) ((blue * 51) / 20)
}

to '_Hummingbird Command' cmd arg1 arg2 arg3 {
  comment 'Contributed by Tom Lauwers'
  '_SPI HB Lock'
  spiSend cmd
  waitMicros 100
  spiSend arg1
  waitMicros 100
  spiSend arg2
  waitMicros 100
  spiSend arg3
  '_SPI HB Unlock'
}

to '_SPI HB Lock' {
  if (_spi_lock == 0) {_spi_lock = (booleanConstant false)}
  local 'time_out' 0
  repeatUntil (or (not _spi_lock) (time_out > 100)) {
    time_out += 1
    waitMicros 30
  }
  _spi_lock = (booleanConstant true)
  if (time_out > 100) {
    digitalWriteOp 16 true
    waitMicros 100
  }
  digitalWriteOp 16 false
  waitMicros 5
}

to '_SPI HB Unlock' {
  waitMicros 5
  digitalWriteOp 16 true
  waitMicros 300
  _spi_lock = (booleanConstant false)
}

to '_within' number low high {
  comment 'Contributed by Tom Lauwers'
  if (number < low) {
    return low
  }
  if (number > high) {
    return high
  }
  return number
}

module 'ED1 Buttons' Input
author MicroBlocks
version 1 0
description 'Provides blocks for the six capacitive buttons in the Citilab ED1 board.'
tags button capacitive ed1

variables _ED1_buttons_init '_capacitive threshold'

	spec ' ' '_ED1_buttons_init' '_ED1_buttons_init' 'any any any'
	spec 'r' 'OK button' 'button OK'
	spec 'r' 'cancel button' 'button X'
	spec 'r' 'up button' 'button up'
	spec 'r' 'down button' 'button down'
	spec 'r' 'left button' 'button left'
	spec 'r' 'right button' 'button right'
	spec ' ' 'set capacitive threshold to' 'set capacitive threshold to _' 'auto' 16

to 'OK button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 15) < (v '_capacitive threshold'))
}

to '_ED1_buttons_init' {
  if (_ED1_buttons_init == 0) {
    if ((v '_capacitive threshold') == 0) {'_capacitive threshold' = 16}
    _ED1_buttons_init = (booleanConstant true)
  }
}

to 'cancel button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 14) < (v '_capacitive threshold'))
}

to 'down button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 13) < (v '_capacitive threshold'))
}

to 'left button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 2) < (v '_capacitive threshold'))
}

to 'right button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 27) < (v '_capacitive threshold'))
}

to 'set capacitive threshold to' threshold {
  '_capacitive threshold' = threshold
}

to 'up button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 4) < (v '_capacitive threshold'))
}

module 'ED1 Stepper Motor' Output
author MicroBlocks
version 1 1 
tags '28byj-48' stepper motor fantastic ed1 
choices directions clockwise 'counter-clockwise' 
description 'Provides blocks to control 28BYJ-48 stepper motors, like the ones included in the Fantastic robot kit for the Citilab ED1 board.
'
variables _ED1_stepper_init _ED1_CW1 _ED1_CW2 _ED1_CCW1 _ED1_CCW2 _ED1_motor_running _ED1_exp_register 

	spec ' ' 'motor step' 'move motor _ _ steps _' 'auto auto menu.directions' 1 '128' 'clockwise'
	spec ' ' 'move motor ' 'move motor 1 _ and motor 2 _ _ steps' 'menu.directions menu.directions auto' 'clockwise' 'counter-clockwise' '64'
	spec ' ' 'motor angle' 'move motor _ angle _ Â°' 'auto auto' '1' '-90'
	spec ' ' 'motor turns' 'move motor _ _ complete turns' 'auto auto' '1' '3'
	spec ' ' '_ED1_stepper_init' '_ED1_stepper_init'
	spec ' ' 'stop steppers' 'stop steppers'

to '_ED1_stepper_init' {
  if (_ED1_stepper_init == 0) {
    comment '0 for ED1 V2'
    if ((i2cGet (hexToInt '20') 1) == 0) {
      _ED1_exp_register = (hexToInt '9')
    } else {
      _ED1_exp_register = (hexToInt '14')
    }
    _ED1_CW1 = (hexToInt 'C')
    _ED1_CW2 = (hexToInt '3')
    _ED1_CCW1 = (hexToInt '3')
    _ED1_CCW2 = (hexToInt 'C')
    _ED1_stepper_init = (booleanConstant true)
    i2cSet (hexToInt '20') 0 0
    i2cSet (hexToInt '20') 6 255
  }
}

to 'motor angle' 'motor number' angle {
  local 'direction' 'clockwise'
  if (angle < 0) {
    direction = 'counter-clockwise'
    angle = (angle * -1)
  }
  'motor step' (v 'motor number') ((142 * angle) / 100) direction
}

to 'motor step' 'motor number' steps direction {
  '_ED1_stepper_init'
  _ED1_motor_running = (booleanConstant true)
  repeat steps {
    if _ED1_motor_running {
      i2cSet (hexToInt '20') _ED1_exp_register ((hexToInt '9') << (((v 'motor number') % 2) << 2))
      waitMicros 1500
      if (direction == 'clockwise') {
        i2cSet (hexToInt '20') _ED1_exp_register ((hexToInt 'C') << (((v 'motor number') % 2) << 2))
      } else {
        i2cSet (hexToInt '20') _ED1_exp_register ((hexToInt '3') << (((v 'motor number') % 2) << 2))
      }
      waitMicros 1500
      i2cSet (hexToInt '20') _ED1_exp_register ((hexToInt '6') << (((v 'motor number') % 2) << 2))
      waitMicros 1500
      if (direction == 'clockwise') {
        i2cSet (hexToInt '20') _ED1_exp_register ((hexToInt '3') << (((v 'motor number') % 2) << 2))
      } else {
        i2cSet (hexToInt '20') _ED1_exp_register ((hexToInt 'C') << (((v 'motor number') % 2) << 2))
      }
      waitMicros 1500
    }
  }
  'stop steppers'
}

to 'motor turns' 'motor number' turns {
  local 'direction' 'clockwise'
  if (turns < 0) {
    direction = 'counter-clockwise'
    turns = (turns * -1)
  }
  'motor step' (v 'motor number') (turns * 512) direction
}

to 'move motor ' 'direction 1' 'direction 2' steps {
  '_ED1_stepper_init'
  _ED1_motor_running = (booleanConstant true)
  local 'step 1' 0
  local 'step 2' 0
  if ((v 'direction 1') == 'clockwise') {
    'step 1' = _ED1_CW1
    'step 2' = _ED1_CW2
  } else {
    'step 1' = _ED1_CCW1
    'step 2' = _ED1_CCW2
  }
  if ((v 'direction 2') == 'clockwise') {
    'step 1' = (((v 'step 1') << 4) | _ED1_CW1)
    'step 2' = (((v 'step 2') << 4) | _ED1_CW2)
  } else {
    'step 1' = (((v 'step 1') << 4) | _ED1_CCW1)
    'step 2' = (((v 'step 2') << 4) | _ED1_CCW2)
  }
  repeat steps {
    if _ED1_motor_running {
      i2cSet (hexToInt '20') _ED1_exp_register (hexToInt '99')
      waitMicros 1500
      i2cSet (hexToInt '20') _ED1_exp_register (v 'step 1')
      waitMicros 1500
      i2cSet (hexToInt '20') _ED1_exp_register (hexToInt '66')
      waitMicros 1500
      i2cSet (hexToInt '20') _ED1_exp_register (v 'step 2')
      waitMicros 1500
    }
  }
  'stop steppers'
}

to 'stop steppers' {
  i2cSet (hexToInt '20') _ED1_exp_register 0
  _ED1_motor_running = (booleanConstant false)
  waitMicros 1500
}

module Cutebot Output
author wwj718
version 1 6 
depends 'Distance (HC-SR04)' NeoPixel 
choices cutebot_side left right 
choices cutebot_light left right both 
description 'Cutebot is a rear-drive smart car driven by dual high speed motors.

It features two RGB headlights, left and right line-following sensors, an ultrasonic distance sensor, and two downward-facing NeoPixels.

Add the IR Remote library to use the IR receiver (pin 16).

The Cutebot can work with the AILens library.

https://www.elecfreaks.com/learn-en/microbitKit/smart_cutebot/cutebot_car.html'

  spec ' ' 'cutebot_setWheelSpeed' 'Cutebot set wheel left _ right _ (-100 to 100)' 'num num' 100 -100
  spec ' ' 'cutebot_stopWheels' 'Cutebot stop wheels'
  space
  spec ' ' 'cutebot_setServo' 'Cutebot set servo _ to _ degrees (-90 to 90)' 'menu.range:1-2 num' 1 90
  spec ' ' 'cutebot_setServoSpeed' 'Cutebot set servo _ to speed _ (-100 to 100)' 'menu.range:1-2 num' 1 100
  space
  spec ' ' 'cutebot_setHeadlightColor' 'Cutebot set headlight _ to _' 'menu.cutebot_light color' 'both'
  spec ' ' 'cutebot_setNeopixels' 'Cutebot set NeoPixel _ to _' 'menu.cutebot_light color' 'both'
  space
  spec 'r' 'cutebot_lineSensor' 'Cutebot _ line sensor' 'menu.cutebot_side' 'left'
  spec 'r' 'cutebot_seesLine' 'Cutebot sees line on left _ right _' 'bool bool' true true
  spec 'r' 'cutebot_distance' 'Cutebot distance (cm)'
  space
  spec ' ' '_cutebot_sendCmd' '_cutebot_sendCmd _' 'str' 'aList'

to '_cutebot_sendCmd' aList {
  local 'cutebotAddr' 16
  '[sensors:i2cSetClockSpeed]' 100000
  '[sensors:i2cWrite]' cutebotAddr aList
  '[sensors:i2cSetClockSpeed]' 400000
}

to cutebot_distance {
  local 'trigger_pin' 8
  local 'echo_pin' 12
  return ('distance (cm)' trigger_pin echo_pin)
}

to cutebot_lineSensor side {
  comment 'Return true if a black line is detected on the given side.'
  local 'left_pin' 13
  local 'right_pin' 14
  if (side == 'left') {
    return (not (digitalReadOp left_pin))
  } else {
    return (not (digitalReadOp right_pin))
  }
}

to cutebot_seesLine leftSide rightSide {
  return (and (leftSide == (cutebot_lineSensor 'left')) (rightSide == (cutebot_lineSensor 'right')))
}

to cutebot_setHeadlightColor which color {
  local 'r' ((color >> 16) & 255)
  local 'g' ((color >> 8) & 255)
  local 'b' ((color >> b) & 255)
  local 'left_LED' 4
  local 'right_LED' 8
  if (which == 'left') {
    '_cutebot_sendCmd' ('[data:makeList]' left_LED r g b)
  } (which == 'right') {
    '_cutebot_sendCmd' ('[data:makeList]' right_LED r g b)
  } else {
    '_cutebot_sendCmd' ('[data:makeList]' left_LED r g b)
    '_cutebot_sendCmd' ('[data:makeList]' right_LED r g b)
  }
}

to cutebot_setNeopixels which_NeoPixel color {
  if (0 == _np_pixels) {neoPixelAttach 2 15}
  if (which_NeoPixel == 'left') {
    atPut 1 _np_pixels color
  } (which_NeoPixel == 'right') {
    atPut 2 _np_pixels color
  } else {
    atPut 1 _np_pixels color
    atPut 2 _np_pixels color
  }
  '_NeoPixel_update'
}

to cutebot_setServo servo value {
  comment 'servo (number) is one of: 1 2
value range of -90 to 90 maps to the full range of the servo'
  servo = (maximum 1 (minimum servo 2))
  value = (maximum -90 (minimum value 90))
  '_cutebot_sendCmd' ('[data:makeList]' (servo + 4) ('[misc:rescale]' value 90 -90 0 180) 0 0)
}

to cutebot_setServoSpeed servo value {
  comment 'servo (number) is one of: 1 2
value range of -100 to 100 maps to the full range of the servo'
  servo = (maximum 1 (minimum servo 2))
  value = (maximum -100 (minimum value 100))
  '_cutebot_sendCmd' ('[data:makeList]' (servo + 4) ('[misc:rescale]' value 100 -100 0 180) 0 0)
}

to cutebot_setWheelSpeed left_wheel_speed right_wheel_speed {
  comment 'speed (number): -100-100
direction: 1 = backward, 2 = forward'
  local 'left_direction' 2
  local 'right_direction' 2
  if (left_wheel_speed < 0) {
    left_direction = 1
    left_wheel_speed = (0 - left_wheel_speed)
  }
  if (right_wheel_speed < 0) {
    right_direction = 1
    right_wheel_speed = (0 - right_wheel_speed)
  }
  left_wheel_speed = (minimum left_wheel_speed 100)
  right_wheel_speed = (minimum right_wheel_speed 100)
  '_cutebot_sendCmd' ('[data:makeList]' 1 left_direction left_wheel_speed 0)
  '_cutebot_sendCmd' ('[data:makeList]' 2 right_direction right_wheel_speed 0)
}

to cutebot_stopWheels {
  cutebot_setWheelSpeed 0 0
}

module NeZha Output
author wwj718
version 1 2 
choices servoType '180' '270' '360' 
choices RJ_pin J1 J2 J3 J4 
choices inputPin J1 J2 
description 'Nezha is an expanstion board for micro:bit with multuple functions available. It equips with four servos connections, four motors connections and seven sensors connections. All of the connections are required with RJ11 connectors that are fool-proofing and easy to plug. It is also compatible to Lego and Fischertechnik bricks and is available to get them connected with the electric modules, thus it allows students to easily create their own amazing micro:bit projects.

https://www.elecfreaks.com/learn-en/microbitExtensionModule/nezha.html'
variables _NEZHA_ADDR '_NeZha initialized' 

  spec ' ' 'set motor speed' 'NeZha set motor _ speed to _ %' 'menu.range:1-4 num' 1 100
  spec ' ' 'stop motor' 'NeZha stop motor _' 'menu.range:1-4' 1
  spec ' ' 'stop all motors' 'NeZha stop all motors'
  spec ' ' 'set servo angle' 'NeZha set _ servo _ angle to _' 'menu.servoType menu.range:1-4 num' '360' 1 0
  spec ' ' 'set continuous rotation servo speed' 'NeZha set continuous rotation servo _ speed to _ %' 'menu.range:1-4 num' 1 0
  spec ' ' '_NeZha setup' 'NeZha _NeZha setup'

to '_NeZha setup' {
  if ((v '_NeZha initialized') == 0) {
    _NEZHA_ADDR = (hexToInt '10')
    '_NeZha initialized' = 1
  }
}

to 'set continuous rotation servo speed' servo angle {
  comment 'motor (number): 1 2 3 4'
  comment 'speed (number): -100-100'
  if (or (angle < -100) (angle > 100)) {
    angle = 0
  }
  'set servo angle' '180' servo ('[misc:rescale]' angle -100 100 0 180)
}

to 'set motor speed' motor speed {
  '_NeZha setup'
  comment 'motor (number): 1 2 3 4'
  comment 'speed (number): -100-100'
  if (or (motor < 1) (motor > 4)) {
    motor = 1
  }
  if (or (speed < -100) (speed > 100)) {
    speed = 0
  }
  if (speed < 0) {
    '[sensors:i2cWrite]' _NEZHA_ADDR ('[data:asByteArray]' ('[data:makeList]' motor 2 (speed * -1) 0))
  } else {
    '[sensors:i2cWrite]' _NEZHA_ADDR ('[data:asByteArray]' ('[data:makeList]' motor 1 speed 0))
  }
}

to 'set servo angle' servo_type servo angle {
  '_NeZha setup'
  comment 'servo (number): 1 2 3 4'
  comment '''180'' ''270'' ''360''

str -> num'
  servo_type = (absoluteValue servo_type)
  if (or (servo < 1) (servo > 4)) {
    servo = 1
  }
  if (or (angle < 0) (angle > servo_type)) {
    angle = 0
  }
  '[sensors:i2cWrite]' _NEZHA_ADDR ('[data:asByteArray]' ('[data:makeList]' ((hexToInt '10') + (servo - 1)) ('[misc:rescale]' angle 0 servo_type 0 180) 0 0))
}

to 'stop all motors' {
  '_NeZha setup'
  for i 4 {
    'set motor speed' i 0
  }
}

to 'stop motor' index {
  '_NeZha setup'
  'set motor speed' index 0
}

module Nezha2 Output
author wwj718 and MicroBlocks
version 1 3 
choices nezhaAnalogPort J1 J2 
choices nezhaServoType '180Â°' '270Â°' '360Â°' 
choices nezhaPort J1 J2 J3 J4 
description 'Library for ELECFREAKS Nezha micro:bit expansion board.
https://www.elecfreaks.com/learn-en/microbitExtensionModule/nezha.html

The Nezha board has four DC motor ports, four servo ports, and a built-in, 900mAh rechargeable LiIon battery. It also has three Planet X I2C ports and four general Planet X ports, two of which are capable of reading analog values. Components are connected with easy-to-use RJ11 (telephone cord style) connectors. The Nezha board and Planet X components are compatible to Lego and Fischertechnik bricks.

This library supports all the components included in the Nezha Inventor Kit for micro:bit. It was created by Wenjie Wu (wwj718) and extended by MicroBlocks.
'

  spec ' ' 'nezha_beep' 'Nezha beep _ Hz for _ msecs' 'num num' 440 100
  space
  spec ' ' 'nezha_setMotor' 'Nezha set motor _ speed to _ (-100-100)' 'menu.range:1-4 num' 1 50
  spec ' ' 'nezha_stopMotor' 'Nezha stop motor _' 'menu.range:1-4' 1
  spec ' ' 'nezha_allMotorsOff' 'Nezha stop all motors'
  space
  spec ' ' 'nezha_setServo' 'Nezha set _ servo _ angle to _' 'menu.nezhaServoType menu.range:1-4 num' '180Â°' 1 90
  spec ' ' 'nezha_setContinuousServo' 'Nezha set continuous servo _ speed to _ (-100 to 100)' 'menu.range:1-4 num' 1 50
  space
  spec ' ' 'nezha_setLED' 'Nezha set LED _ to _ : brightness _ %' 'menu.nezhaPort bool num' 'J1' true 20
  spec ' ' 'nezha_setAllLEDs' 'Nezha set all LEDs to _ : brightness _ %' 'bool num' true 20
  space
  spec 'r' 'nezha_trimPot' 'Nezha trim pot _' 'menu.nezhaAnalogPort' 'J1'
  spec 'r' 'nezha_soilMoisture' 'Nezha soil moisture _' 'menu.nezhaAnalogPort' 'J1'
  spec 'r' 'nezha_readAnalog' 'Nezha read analog _' 'menu.nezhaAnalogPort' 'J1'
  space
  spec 'r' 'nezha_crashSensor' 'Nezha crash sensor _' 'menu.nezhaPort' 'J1'
  spec 'r' 'nezha_lineSensor' 'Nezha line sensor _ sees line on left _ right _' 'menu.nezhaPort bool bool' 'J1' true true
  spec 'r' 'nezha_distance' 'Nezha distance _ (cm)' 'menu.nezhaPort' 'J1'
  space
  spec 'r' '_nezha_pinAForPort' '_Nezha pin A of _' 'menu.nezhaPort' 'J1'
  spec 'r' '_nezha_pinBForPort' '_Nezha pin B of _' 'menu.nezhaPort' 'J1'

to '_nezha_pinAForPort' port {
  if (or ('J1' == port) (1 == port)) {
    return 1
  } (or ('J2' == port) (2 == port)) {
    return 2
  } (or ('J3' == port) (3 == port)) {
    return 13
  } (or ('J4' == port) (4 == port)) {
    return 15
  } else {
    return 1
  }
}

to '_nezha_pinBForPort' port {
  if (or ('J1' == port) (1 == port)) {
    return 8
  } (or ('J2' == port) (2 == port)) {
    return 12
  } (or ('J3' == port) (3 == port)) {
    return 14
  } (or ('J4' == port) (4 == port)) {
    return 16
  } else {
    return 8
  }
}

to nezha_allMotorsOff {
  for i 4 {
    nezha_setMotor i 0
  }
}

to nezha_beep freq msecs {
  '[io:playTone]' 0 freq
  waitMillis msecs
  '[io:playTone]' 0 0
}

to nezha_crashSensor port {
  return (not (digitalReadOp ('_nezha_pinBForPort' port)))
}

to nezha_distance port {
  local 'trig' ('_nezha_pinAForPort' port)
  local 'ech' ('_nezha_pinBForPort' port)
  digitalWriteOp trig false
  waitMicros 2
  digitalWriteOp trig true
  waitMicros 50
  digitalWriteOp trig false
  local 'start' (microsOp)
  waitUntil (or (not (digitalReadOp ech)) (((microsOp) - start) > 23320))
  waitUntil (or (digitalReadOp ech) (((microsOp) - start) > 23320))
  if (((microsOp) - start) > 23320) {
    comment 'Distance sensor not ready; return the last distance reading'
    return _sr04_last
  }
  comment 'Pulse sent. Measure time until echo is detected.'
  start = (microsOp)
  waitUntil (or (not (digitalReadOp ech)) (((microsOp) - start) > 23320))
  _sr04_last = ((10 * ((microsOp) - start)) / 583)
  comment 'Leave some time for reverberations to die away.'
  waitMillis 10
  if (_sr04_last == 0) {
    zeroCount += 1
  }
  return _sr04_last
}

to nezha_lineSensor port leftSide rightSide {
  return (and (leftSide == (not (digitalReadOp ('_nezha_pinAForPort' port)))) (rightSide == (not (digitalReadOp ('_nezha_pinBForPort' port)))))
}

to nezha_readAnalog port {
  return (analogReadOp ('_nezha_pinAForPort' port))
}

to nezha_setAllLEDs state optionalBrightness {
  local 'brightness' 100
  if ((pushArgCount) > 1) {
    brightness = optionalBrightness
  }
  for i 4 {
    nezha_setLED i state brightness
  }
}

to nezha_setContinuousServo servoNum power {
  if (or (servoNum < 1) (servoNum > 4)) {return 0}
  power = (maximum -100 (minimum power 100))
  local 'cmd' (newList 4)
  atPut 1 cmd (15 + servoNum)
  atPut 2 cmd ('[misc:rescale]' power -100 100 0 180)
  '[sensors:i2cWrite]' 16 cmd
}

to nezha_setLED port state optionalBrightness {
  local 'brightness' 100
  if ((pushArgCount) > 2) {
    brightness = (maximum 0 (minimum optionalBrightness 100))
  }
  if (and (true == state) (brightness < 100)) {
    analogWriteOp ('_nezha_pinAForPort' port) ('[misc:rescale]' brightness 0 100 0 1023)
  } else {
    digitalWriteOp ('_nezha_pinAForPort' port) state
  }
}

to nezha_setMotor motorNum power {
  local 'cmd' (newList 4)
  if (or (motorNum < 1) (motorNum > 4)) {
    return 0
  }
  atPut 1 cmd motorNum
  if (power >= 0) {
    atPut 2 cmd 1
  } else {
    atPut 2 cmd 2
    power = (absoluteValue power)
  }
  atPut 3 cmd power
  '[sensors:i2cWrite]' 16 cmd
}

to nezha_setServo servoType servoNum degrees {
  local 'degreeRange' 100
  if ('180Â°' == servoType) {
    degreeRange = 180
  } ('270Â°' == servoType) {
    degreeRange = 270
  } ('360Â°' == servoType) {
    degreeRange = 360
  }
  degrees = (maximum 0 (minimum degrees degreeRange))
  nezha_setContinuousServo servoNum ('[misc:rescale]' degrees 0 degreeRange -100 100)
}

to nezha_soilMoisture port {
  comment 'Raw range seems to be roughly 70-520.
Divide by 5 to get a range of roughly 14-100.
Lower numbers indicate dryer soil.
DIfferent pots will give different ranges.'
  local 'result' ((1023 - (analogReadOp ('_nezha_pinAForPort' port))) / 5)
  return (minimum result 100)
}

to nezha_stopMotor motorNum {
  nezha_setMotor motorNum 0
}

to nezha_trimPot port {
  return (analogReadOp ('_nezha_pinAForPort' port))
}

module Octopus
author ELECFREAKS
version 1 3 
depends 'Temperature Humidity (DHT11, DHT22)' 
description 'ELECFREAKS Octopus Component Library

Octopus components help you build projects quickly and enjoy the fun of creation.

Official website:
https://www.elecfreaks.com/

Wiki reference:
http://wiki.elecfreaks.com/en/microbit/sensor/octopus-sensors/

'

  spec ' ' 'Octopus LED pin' 'Octopus LED pin _ toggle to _' 'auto bool' '0' true
  spec ' ' 'Octopus set led brightness' 'Octopus LED pin _ brightness _ %' 'num num' 0 100
  space
  spec ' ' 'Octopus set fan' 'Octopus motor fan pin _ speed to _ %' 'num num' 0 50
  space
  spec ' ' 'Octopus set servo angle' 'Octopus 180Â° servo pin _ angle to _ Â° (0~180)' 'num num' 0 90
  space
  spec 'r' 'Octopus get distance' 'Octopus sonar trig _ echo _ distance (cm)' 'num num' 17 16
  space
  spec 'r' 'Octopus get light' 'Octopus value of light intensity (Lux) at pin _' 'num' 26
  space
  spec 'r' 'Octopus get temperature' 'Octopus value of DHT11 temperature (Â°C) at pin _' 'num' 26
  spec 'r' 'Octopus get humidity' 'Octopus value of DHT11 humidity (0~100) at pin _' 'num' 26
  space
  spec 'r' 'Octopus get water level' 'Octopus value of water level (0~40mm) at pin _' 'num' 26
  space
  spec 'r' 'Octopus get trimpot' 'Octopus value of trimpot (0~1023) at pin _' 'num' 26
  space
  spec 'r' 'Octopus get loudness' 'Octopus value of noise (dB) at pin _' 'num' 26
  space
  spec ' ' 'Octopus draw string' 'Octopus OLED show _ at x _ y _' 'str num num' 'hello!' 0 0
  spec ' ' 'Octopus clear OLED' 'Octopus OLED clear'
  spec ' ' 'Octopus draw pixel' 'Octopus OLED draw pixel x _ y _' 'num num' 63 31
  spec ' ' 'Octopus draw line' 'Octopus OLED draw line from x _ y _ to x _ y _' 'num num num num' 0 0 127 63
  spec ' ' 'Octopus draw rectangle' 'Octopus OLED draw rectangle x _ y _ w _ h _ rounding _ (0~15)' 'num num num num num' 0 0 60 30 0
  spec ' ' 'Octopus fill rectangle' 'Octopus OLED fill rectangle x _ y _ w _ h _ rounding _ (0~15)' 'num num num num auto' 0 0 60 30 0
  spec ' ' 'Octupus draw circle' 'Octopus OLED draw circle x _ y _ radius _' 'num num num' 10 10 10
  spec ' ' 'Octopus fill circle' 'Octopus OLED fill circle x _ y _ radius _' 'num num num' 10 10 10

to 'Octopus LED pin' pin bool {
  digitalWriteOp pin bool
}

to 'Octopus clear OLED' {
  '[display:mbDisplayOff]'
}

to 'Octopus draw line' x y x1 y1 {
  '[tft:line]' x y x1 y1 (colorSwatch 35 190 30 255)
}

to 'Octopus draw pixel' x y {
  '[tft:setPixel]' x y (colorSwatch 35 190 30 255)
}

to 'Octopus draw rectangle' x y w h rounding {
  '[tft:roundedRect]' x y w h rounding (colorSwatch 35 190 30 255) false
}

to 'Octopus draw string' text x y {
  '[tft:text]' text x y (colorSwatch 35 190 30 255) 1 true
}

to 'Octopus fill circle' x y r {
  '[tft:circle]' x y r (colorSwatch 35 190 30 255) true
}

to 'Octopus fill rectangle' x y w h rounding {
  '[tft:roundedRect]' x y w h rounding (colorSwatch 35 190 30 255) true
}

to 'Octopus get distance' trig echo {
  digitalWriteOp trig false
  waitMicros 2
  digitalWriteOp trig true
  waitMicros 50
  digitalWriteOp trig false
  local 'start' (microsOp)
  waitUntil (or (not (digitalReadOp echo)) (((microsOp) - start) > 23320))
  waitUntil (or (digitalReadOp echo) (((microsOp) - start) > 23320))
  if (((microsOp) - start) > 23320) {
    comment 'Distance sensor not ready; return the last distance reading'
    return _sr04_last
  }
  comment 'Pulse sent. Measure time until echo is detected.'
  start = (microsOp)
  waitUntil (or (not (digitalReadOp echo)) (((microsOp) - start) > 23320))
  _sr04_last = ((10 * ((microsOp) - start)) / 583)
  comment 'Leave some time for reverberations to die away.'
  waitMillis 10
  if (_sr04_last == 0) {
    zeroCount += 1
  }
  return _sr04_last
}

to 'Octopus get humidity' pin {
  return (humidity_DHT11 pin)
}

to 'Octopus get light' pin {
  if ((analogReadOp pin) <= 300) {
    return ((((analogReadOp pin) - 10) * 1600) / 300)
  } else {
    return (((((analogReadOp pin) - 300) * 12400) / 723) + 1600)
  }
}

to 'Octopus get loudness' pin {
  return (analogReadOp pin)
}

to 'Octopus get temperature' pin {
  return (temperature_DHT11 pin)
}

to 'Octopus get trimpot' pin {
  return (analogReadOp pin)
}

to 'Octopus get water level' pin {
  return ('[misc:rescale]' (analogReadOp pin) 0 550 0 400)
}

to 'Octopus set fan' pin speed {
  analogWriteOp pin ('[misc:rescale]' speed 0 100 0 1023)
}

to 'Octopus set led brightness' pin brightness {
  analogWriteOp pin ('[misc:rescale]' brightness 0 100 0 1023)
}

to 'Octopus set servo angle' which degrees {
  local 'pulseWidth' (1500 - (10 * (degrees - 90)))
  '[io:setServo]' which pulseWidth
}

to 'Octupus draw circle' x y r {
  '[tft:circle]' x y r (colorSwatch 35 190 30 255) false
}

module WuKong2040 Output
author ELECFREAKS
version 1 1 
depends Tone 
tags pico picow wukong2040 wukong2040 pico picow tone 
choices wk2040_rainbowLEDMenu '0' '1' all 
choices wk2040_motorMenu M1 M2 M3 M4 
description 'ELECFREAKS WuKong2040 multi-function expansion board.

Features:
  Raspberry Pi Pico/PicoW
  14 Ã Expansion GPIO Ports (including SPI\IIC\UART)
   4 Ã Motor Driving
   2 Ã Rainbow LED
   2 Ã Button
   1 Ã Buzzer

Power Supply:
  18650 Lithium Battery

Pins:
  Buzzer = 9
  Button_A = 18
  Button_B = 19
  RGB_LED = 22
  Motor_M1 = 20, 21
  Motor_M2 = 10, 11
  Motor_M3 = 14, 15
  Motor_M4 = 12, 13

  UART_TX = 0
  UART_RX = 1

  SPI_SCK = 2
  SPI_MOSI = 3
  SPI_MISO = 4
  SPI_SS = 5

  IIC_SDA = 16
  IIC_SCL = 17

Official website:
https://www.elecfreaks.com/

Wiki reference:
http://wiki.elecfreaks.com/en/pico/extension-module/wukong2040-pico
'
variables _wk2040_pixels 

  spec ' ' 'wk2040_set_LED_color' 'WuKong2040 rainbowLED _ color to _' 'menu.wk2040_rainbowLEDMenu color' '0'
  spec ' ' 'wk2040_set_LED_RGB' 'WuKong2040 rainbowLED _ R _ G _ B _ (0~255)' 'menu.wk2040_rainbowLEDMenu num num num' '0' 0 0 255
  spec ' ' 'wk2040_turn_off_all_LEDs' 'WuKong2040 clear all rainbowLED'
  space
  spec ' ' 'wk2040_set_motor_speed' 'WuKong2040 motor _ speed to _ (-100~100)' 'menu.wk2040_motorMenu num' 'M1' 50
  spec ' ' 'WuKong2040 stop motor' 'WuKong2040 stop motor _' 'menu.wk2040_motorMenu' 'M1'
  spec ' ' 'wk2040_stop_all_motors' 'WuKong2040 stop all motors'
  space
  spec ' ' 'wk2040_beat' 'WuKong2040 buzzer beep _ ms' 'auto' '100'
  space
  spec ' ' '_wk2040_initLEDs' '_wk2040_initLEDs'
  spec 'r' '_wk2040_colorFromRGB' '_color r _ g _ b _ (0-255)' 'num num num' 0 100 100

to 'WuKong2040 stop motor' motor {
  if ('M1' == motor) {
    '_wk2040_set_motor_speed' 20 21 0
  } ('M2' == motor) {
    '_wk2040_set_motor_speed' 10 11 0
  } ('M3' == motor) {
    '_wk2040_set_motor_speed' 15 14 0
  } ('M4' == motor) {
    '_wk2040_set_motor_speed' 13 12 0
  }
}

to '_wk2040_colorFromRGB' r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to '_wk2040_initLEDs' {
  '[display:neoPixelSetPin]' -1 false
  if (not (isType _wk2040_pixels 'list')) {
    _wk2040_pixels = (newList 2)
  }
}

to '_wk2040_set_motor_speed' pin1 pin2 speed {
  if (speed < 0) {
    analogWriteOp pin1 ('[misc:rescale]' (absoluteValue speed) 0 100 0 1023)
    analogWriteOp pin2 0
  } else {
    analogWriteOp pin2 ('[misc:rescale]' speed 0 100 0 1023)
    analogWriteOp pin1 0
  }
}

to wk2040_beat duration {
  local 'pin_buzzer' 9
  local 'end time' ((millisOp) + duration)
  repeatUntil ((millisOp) >= (v 'end time')) {
    digitalWriteOp pin_buzzer true
    waitMicros 400
    digitalWriteOp pin_buzzer false
    waitMicros 400
  }
}

to wk2040_set_LED_RGB num r g b {
  wk2040_set_LED_color num ('_wk2040_colorFromRGB' r g b)
}

to wk2040_set_LED_color num color {
  '_wk2040_initLEDs'
  if (num == '0') {
    atPut 1 _wk2040_pixels color
    '[display:neoPixelSend]' _wk2040_pixels
    waitMicros 150
  }
  if (num == '1') {
    atPut 'last' _wk2040_pixels color
    '[display:neoPixelSend]' _wk2040_pixels
    waitMicros 150
  }
  if (num == 'all') {
    atPut 'all' _wk2040_pixels color
    '[display:neoPixelSend]' _wk2040_pixels
    waitMicros 150
  }
}

to wk2040_set_motor_speed motor speed {
  if ('M1' == motor) {
    '_wk2040_set_motor_speed' 20 21 speed
  } ('M2' == motor) {
    '_wk2040_set_motor_speed' 10 11 speed
  } ('M3' == motor) {
    '_wk2040_set_motor_speed' 15 14 speed
  } ('M4' == motor) {
    '_wk2040_set_motor_speed' 13 12 speed
  }
}

to wk2040_stop_all_motors {
  wk2040_set_motor_speed 'M1' 0
  wk2040_set_motor_speed 'M2' 0
  wk2040_set_motor_speed 'M3' 0
  wk2040_set_motor_speed 'M4' 0
}

to wk2040_turn_off_all_LEDs {
  wk2040_set_LED_color 'all' (colorSwatch 0 0 0 255)
}

module Wukong Output
author wwj718
version 1 5 
depends NeoPixel 
description 'Wukong is a compact micro:bit breakout board with servo and motor drivers, eight I/O pins, four NeoPixels, and four blue LEDs.

The built-in 400mAh Li-ion battery provides over than 40 minutes of power and can be fully recharged in just 20 minutes.

The base board design is compatible with Lego.

https://www.elecfreaks.com/learn-en/microbitExtensionModule/wukong.html
'

  spec ' ' 'wukong_setServo' 'Wukong set servo _ to _ degrees (-90 to 90)' 'menu.range:0-7 num' 0 90
  spec ' ' 'wukong_setServoSpeed' 'Wukong set servo _ to speed _ (-100 to 100)' 'menu.range:0-7 num' 0 100
  space
  spec ' ' 'wukong_setMotor' 'Wukong set motor _ to _ (-100 to 100)' 'menu.range:1-2 num' 1 50
  spec ' ' 'wukong_stopAll' 'Wukong stop all'
  space
  spec ' ' 'wukong_setNeopixels' 'Wukong set NeoPixels _ _ _ _' 'color color color color'
  spec ' ' 'wukong_setLEDBrightness' 'Wukong set LED brightness to _' 'num' 100
  space
  spec 'r' '_wukong_ADDR' '_wukong_ADDR'

to '_wukong_ADDR' {
  return 16
}

to wukong_setLEDBrightness num {
  num = (maximum 0 (minimum num 100))
  '[sensors:i2cWrite]' ('_wukong_ADDR') ('[data:makeList]' (hexToInt '12') num 0 0)
  '[sensors:i2cWrite]' ('_wukong_ADDR') ('[data:makeList]' (hexToInt '11') 160 0 0)
}

to wukong_setMotor motor power {
  comment 'motor (number): 1 or 2'
  comment 'power (number): -100 to 100'
  if (or (motor < 1) (motor > 2)) {
    motor = 1
  }
  power = (maximum -100 (minimum power 100))
  if (power < 0) {
    '[sensors:i2cWrite]' ('_wukong_ADDR') ('[data:makeList]' motor 2 (0 - power) 0)
  } else {
    '[sensors:i2cWrite]' ('_wukong_ADDR') ('[data:makeList]' motor 1 power 0)
  }
}

to wukong_setNeopixels c1 c2 c3 c4 {
  neoPixelAttach 4 16
  setNeoPixelColors10 c1 c2 c3 c4
}

to wukong_setServo servo value {
  comment 'servo (number) is 0-7
value range of -90 to 90 maps to the full range of the servo'
  servo = (maximum 0 (minimum servo 7))
  channel = (servo + 3)
  if (servo == 7) {
    comment 'servo 7 is controlled by channel 16'
    channel = 16
  }
  value = (maximum -90 (minimum value 90))
  '[sensors:i2cWrite]' ('_wukong_ADDR') ('[data:makeList]' channel ('[misc:rescale]' value 90 -90 0 180) 0 0)
}

to wukong_setServoSpeed servo value {
  comment 'servo (number) is 0-7
value range of -100 to 100 maps to the full range of the servo'
  servo = (maximum 0 (minimum servo 7))
  channel = (servo + 3)
  if (servo == 7) {
    comment 'servo 7 is controlled by channel 16'
    channel = 16
  }
  value = (maximum -100 (minimum value 100))
  '[sensors:i2cWrite]' ('_wukong_ADDR') ('[data:makeList]' channel ('[misc:rescale]' value 100 -100 0 180) 0 0)
}

to wukong_stopAll {
  wukong_setMotor 1 0
  wukong_setMotor 2 0
  for i 8 {
    wukong_setServo (i - 1) 0
  }
  wukong_setNeopixels 0 0 0 0
  wukong_setLEDBrightness 0
}

module HyperDuino Output
author MicroBlocks
version 1 6 
depends Touch 
choices hyperduino_motor A B 
description 'Support for HyperDuino (https://hyperduino.com).'

  spec 'r' 'hyperduino_pinTouched' 'is HyperDuino pin _ touched?' 'menu.range:2-13' 2
  space
  spec 'r' 'hyperduino_touchEvent' 'pin touch event'
  spec 'r' 'hyperduino_last_touched_pin' 'last touched pin'
  space
  spec 'r' 'hyperduino_releaseEvent' 'pin release event'
  spec 'r' 'hyperduino_last_released_pin' 'last released pin'
  space
  spec ' ' 'hyperduino_setAllPins' 'set all HyperDuino LEDs _' 'bool' false
  spec 'r' 'hyperduino_allPins' 'HyperDuino pins'
  space
  spec ' ' 'hyperduino_setMotorHyperduino' 'set motor _ power _' 'menu.hyperduino_motor num' 'A' 100
  spec ' ' 'hyperduino_stopMotors' 'stop all motors'

to hyperduino_allPins {
  return ('[data:range]' 2 13)
}

to hyperduino_last_released_pin {
  local 'pin' (touch_last_released_pin)
  if (pin < 0) {
    return -1
  }
  return (14 - pin)
}

to hyperduino_last_touched_pin {
  local 'pin' (touch_last_touched_pin)
  if (pin < 0) {
    return -1
  }
  return (14 - pin)
}

to hyperduino_pinTouched pin {
  return (touch_isTouched (14 - pin))
}

to hyperduino_releaseEvent {
  return (touch_release_event)
}

to hyperduino_setAllPins bool {
  for pin (hyperduino_allPins) {
    digitalWriteOp pin bool
  }
}

to hyperduino_setMotorHyperduino motor power {
  comment 'Set motor (A or B) power (-100 to 100). The sign
of the power value determines motor direction.'
  comment 'Motor A: 3 & 4 (direction), 5 (power)
Motor B: 7 & 8 (direction), 6 (power)'
  if (motor == 'A') {
    local 'p1' 3
    local 'p2' 4
    local 'pwrPin' 5
  } (motor == 'B') {
    local 'p1' 7
    local 'p2' 8
    local 'pwrPin' 6
  } else {
    return 0
  }
  comment 'Set the motor direction based on sign of power'
  if (power > 0) {
    digitalWriteOp p1 false
    digitalWriteOp p2 true
  } (power < 0) {
    digitalWriteOp p1 true
    digitalWriteOp p2 false
  } else {
    digitalWriteOp p1 false
    digitalWriteOp p2 false
  }
  comment 'Set the PWM duty cycle on the power pin'
  analogWriteOp pwrPin (minimum (((absoluteValue power) * 1023) / 100) 1023)
}

to hyperduino_stopMotors {
  hyperduino_setMotorHyperduino 'A' 0
  hyperduino_setMotorHyperduino 'B' 0
}

to hyperduino_touchEvent {
  return (touch_touch_event)
}

module MakerBit Output
author MicroBlocks
version 1 8 
depends Touch 
choices makerbit_motor A B 
description 'Support for MakerBit (https://makerbit.com)'

  spec 'r' 'makerbit_pinTouched' 'is MakerBit pin _ touched?' 'menu.range:5-16' 5
  space
  spec 'r' 'makerbit_touchEvent' 'pin touch event'
  spec 'r' 'makerbit_last_touched_pin' 'last touched pin'
  space
  spec 'r' 'makerbit_releaseEvent' 'pin release event'
  spec 'r' 'makerbit_last_released_pin' 'last released pin'
  space
  spec ' ' 'makerbit_setAllPins' 'set all MakerBit LEDs _' 'bool' false
  spec 'r' 'makerbit_allPins' 'MakerBit pins'
  space
  spec ' ' '[display:mbEnableDisplay]' 'enable microbit LED display _' 'bool' false
  space
  spec ' ' 'makerbit_setMotorMakerBit' 'set motor _ power _' 'menu.makerbit_motor num' 'A' 100
  spec ' ' 'makerbit_stopMotors' 'stop all motors'

to makerbit_allPins {
  return ('[data:range]' 5 16)
}

to makerbit_last_released_pin {
  local 'pin' (touch_last_released_pin)
  if (pin < 0) {
    return -1
  }
  comment 'Convert to MakerBit pin numbering'
  return (17 - pin)
}

to makerbit_last_touched_pin {
  local 'pin' (touch_last_touched_pin)
  if (pin < 0) {
    return -1
  }
  comment 'Convert to MakerBit pin numbering'
  return (17 - pin)
}

to makerbit_pinTouched pin {
  comment 'Convert from MakerBit pin numbering'
  return (touch_isTouched (17 - pin))
}

to makerbit_releaseEvent {
  return (touch_release_event)
}

to makerbit_setAllPins bool {
  for pin (makerbit_allPins) {
    digitalWriteOp pin bool
  }
}

to makerbit_setMotorMakerBit motor power {
  comment 'Set motor (A or B) power (-100 to 100). The sign
of the power value determines motor direction.'
  comment 'Motor A: 11 & 12 (direction), 13 (power)
Motor B: 15 & 16 (direction), 14 (power)'
  if (motor == 'A') {
    local 'p1' 11
    local 'p2' 12
    local 'pwrPin' 13
  } (motor == 'B') {
    local 'p1' 15
    local 'p2' 16
    local 'pwrPin' 14
  } else {
    return 0
  }
  comment 'Set the motor direction based on sign of power'
  if (power > 0) {
    digitalWriteOp p1 false
    digitalWriteOp p2 true
  } (power < 0) {
    digitalWriteOp p1 true
    digitalWriteOp p2 false
  } else {
    digitalWriteOp p1 false
    digitalWriteOp p2 false
  }
  comment 'Set the PWM duty cycle on the power pin'
  analogWriteOp pwrPin (minimum (((absoluteValue power) * 1023) / 100) 1023)
}

to makerbit_stopMotors {
  makerbit_setMotorMakerBit 'A' 0
  makerbit_setMotorMakerBit 'B' 0
}

to makerbit_touchEvent {
  return (touch_touch_event)
}

module MakerPort Output
author MicroBlocks
version 1 9 
depends 'LCD Display' 'MP3 Player' Touch 'IR Remote' 
choices makerport_audioSource MP3 Tone 
description 'Support for MakerPort (https://makerport.fun)'
variables _makerport_microSDInserted _makerport_time_averages 

  spec ' ' 'makerport_initialize' 'MakerPort initialize'
  space
  spec ' ' 'makerport_beep' 'MakerPort tone _ Hz for _ msecs : volume _ (0-10)' 'num num num' 440 100 10
  spec ' ' 'makerport_setAudioSource' 'set MakerPort audio source to _' 'menu.makerport_audioSource' 'MP3'
  space
  spec ' ' 'makerport_setAllLEDs' 'set all MakerPort LEDs _' 'bool' false
  space
  spec ' ' 'makerport_typeString' 'type _ to computer' 'str' 'Hello from MakerPort!'
  space
  spec 'r' 'makerport_mp3_hasCard' 'mp3 player has Flash card'
  space
  spec 'r' 'makerport_loudness' 'loudness'
  space
  spec 'r' 'makerport_timeAveragedLevel' 'input level from _ with time sample _ ms' 'num num' 13 64
  spec 'r' '_makerport_compute_time_average' '_compute time average _ _ _' 'num num num' 13 64 0

to '_makerport_compute_time_average' pin timeSample timeAverage {
  local 'samples' 0
  local 'average' 0
  local 'endTime' ((millisOp) + timeSample)
  repeatUntil ((millisOp) >= endTime) {
    samples += 1
    average += (absoluteValue ((analogReadOp pin) - timeAverage))
  }
  return (average / (maximum samples 1))
}

to makerport_beep freq msecs optionalVolume {
  if (freq < 1) {return 0}
  local 'halfCycleTime' (500000 / freq)
  local 'cycles' ((500 * msecs) / halfCycleTime)
  local 'amplitude' (50 * (argOrDefault 3 10))
  amplitude = (maximum 0 (minimum amplitude 1023))
  digitalWriteOp 19 true
  repeat cycles {
    analogWriteOp 0 amplitude
    waitMicros halfCycleTime
    analogWriteOp 0 0
    waitMicros halfCycleTime
  }
}

to makerport_initialize {
  makerport_setAllLEDs false
  attachIR 18
  mp3_initialize 'MakerPort' 20 21
  if (makerport_mp3_hasCard) {
    makerport_setAudioSource 'MP3'
  } else {
    makerport_setAudioSource 'Tone'
  }
}

to makerport_loudness {
  local 'low' 10000
  local 'high' -10000
  for i 40 {
    comment 'Sample microphone connected to analog port for ~20 msecs at ~2000 samples/sec.'
    local 'sample' (analogReadOp 13)
    low = (minimum low sample)
    high = (maximum high sample)
    waitMicros 500
  }
  return (high - low)
}

to makerport_mp3_hasCard {
  comment 'Note: This command works only if MP3 player is
connected to the hardware serial pins.'
  if (isType _makerport_microSDInserted 'boolean') {
    comment 'return previously determined value'
    return _makerport_microSDInserted
  }
  '[serial:open]' 9600
  comment 'Send MP3 player initialization command'
  '[serial:write]' ('[data:makeList]' (hexToInt '7E') (hexToInt 'FF') 6 (hexToInt '0C') 0 0 0 254 239 (hexToInt 'EF'))
  local 'bytesRead' ('[data:newByteArray]' 0)
  repeat 60 {
    comment 'Loop for up to 3 seconds while waiting for a response'
    bytesRead = ('[data:join]' bytesRead ('[serial:read]'))
    if ((size bytesRead) >= 10) {
      comment 'Got a response message. Item 7 is 2 if
a Flash card is inserted in the player.'
      '[serial:close]'
      _makerport_microSDInserted = ((at 7 bytesRead) == 2)
      return _makerport_microSDInserted
    }
    waitMillis 50
  }
  '[serial:close]'
  _makerport_microSDInserted = (booleanConstant false)
  return _makerport_microSDInserted
}

to makerport_setAllLEDs bool {
  for pin 12 {
    digitalWriteOp pin bool
  }
}

to makerport_setAudioSource src {
  digitalWriteOp 19 (src != 'MP3')
}

to makerport_timeAveragedLevel pin timeSample {
  if (_makerport_time_averages == 0) {_makerport_time_averages = (newList 32 0)}
  pin = (maximum 1 (minimum pin 32))
  local 'average' ('_makerport_compute_time_average' pin timeSample (at pin _makerport_time_averages))
  if ((at pin _makerport_time_averages) == 0) {
    atPut pin _makerport_time_averages average
    average = 0
  }
  return average
}

to makerport_typeString s {
  for ch s {
    '[hid:pressKey]' ch -1
  }
}

module '3dBot'
author 'Josep FerrÃ ndiz'
version 1 0 
depends Imagina 
tags imagina '3dbot' robot 
choices lineSensor 'right sensor' 'left sensor' 'both sensors' 
choices direction stop forward backward 'turn right' 'turn left' 
description 'Blocks for Imagina 3dBot robot with ESP32 board (from Innova DidÃ ctic)
https://shop.innovadidactic.com/es/placas-kits-y-robots/1604-kit-3dbot-iot-esp32-steamakers-arduinoblocks-blynk-bachillerato.html'
variables _3dBotPower _3dBotDirection

  spec ' ' 'bot3D_move' '3dBot _ : _ steps : at _ % speed' 'menu.direction num num' 'forward' 10 100
  spec ' ' 'bot3D_set_speed' '3dBot set speed at _ %' 'num' 100
  space
  spec 'r' 'bot3D_obstacle_detected' '3dBot obstacle < _ cm?' 'auto' '10'
  spec 'r' 'bot3D_sees_line' '3dBot line on _ ?' 'menu.lineSensor' 'right sensor'
  space
  spec ' ' '_bot3D_set_direction' '_bot3D_set_direction _' 'menu.direction' 'stop'
  spec ' ' '_bot3D_move' '_bot3D_move _ steps' 'num' 10

to '_bot3D_move' steps {
  local 'initialState' 0
  'bot3D_move' _3dBotDirection
  repeat steps {
    initialState = (('imagina_read_A1') > 800)
    waitUntil (not ((('imagina_read_A1') > 800) == initialState))
  }
  'imagina_set_motor_rotation' 'Motor A' 'stop'
  'imagina_set_motor_rotation' 'Motor B' 'stop'
}

to '_bot3D_set_direction' direction {
  for item ('[data:makeList]' 'forward' 'backward' 'stop' 'turn right' 'turn left' ) {
    if (direction == item) {_3dBotDirection = direction}
  }
  if (_3dBotDirection == 'turn right') {
    'imagina_set_motor_rotation' 'Motor A' 'forward'
    'imagina_set_motor_rotation' 'Motor B' 'backward'
  } (_3dBotDirection == 'turn left') {
    'imagina_set_motor_rotation' 'Motor A' 'backward'
    'imagina_set_motor_rotation' 'Motor B' 'forward'
  } else {
    'imagina_set_motor_rotation' 'Motor A' _3dBotDirection
    'imagina_set_motor_rotation' 'Motor B' _3dBotDirection
  }
}

to bot3D_move direction steps power {  
  if ((pushArgCount) == 3) {
    'imagina_set_motor_speed' 'Motor A' power
    'imagina_set_motor_speed' 'Motor B' power
  }
  '_bot3D_set_direction' direction
  if ((pushArgCount) > 1) {
    '_bot3D_move' steps
  }
}

to bot3D_obstacle_detected distance {
  local 'aux_dist' (imagina_distance)
  waitMillis 50
  if ((imagina_distance) <= distance) {return (booleanConstant true)}
  return (booleanConstant false)
}

to bot3D_sees_line sensor {
  if (sensor == 'right sensor') {
    return (digitalReadOp 27)
  } (sensor == 'left sensor') {
    return (digitalReadOp 16)
  } (sensor == 'both sensors') {
    return (and (digitalReadOp 27) (digitalReadOp 16))
  } else {
    return (booleanConstant false)
  }
}

to bot3D_set_speed power {
  _3dBotPower = power
  'imagina_set_motor_speed' 'Motor A' _3dBotPower
  'imagina_set_motor_speed' 'Motor B' _3dBotPower
}

module Imagina
author 'Josep FerrÃ ndiz'
version 1 0 
depends 'IR Remote' 'Distance (HC-SR04)' Servo Tone 
choices nunchuck joyX joyY butC butZ accX accY accZ 
choices motorRotation stop forward backward 
choices servo A B 
choices motor 'Motor A' 'Motor B' 
choices notes c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
choices led red yellow green 
choices sensor 'SL (D5)' 'SR (D6)' 
choices state on off 
description 'Provides blocks for INNOVA DIDACTIC Imagina shield when used with ESP32 STEAMakers board.

Imagina shield: https://shop.innovadidactic.com/es/imagina-steam-y-makers/1466-placa-imagina-3dbot-arduino-12-funciones-incluye-sensores-actuadores-y-driver-para-dos-motores.html
ESP32 STEAMakers board:
https://shop.innovadidactic.com/es/standard-placas-shields-y-kits/1567-placa-esp32-steamakers.html'

  spec ' ' 'imagina_set_led' 'Imagina set _ led to _' 'menu.led bool' 'red' true
  spec ' ' 'imagina_play' 'Imagina play _ octave _ for _ ms' 'menu.notes num num' 'c' 0 500
  space
  spec 'r' 'imagina_temperature' 'Imagina temperature (Â°C)'
  spec 'r' 'imagina_light' 'Imagina light'
  spec 'r' 'imagina_distance' 'Imagina distance (cm)'
  spec 'r' 'imagina_button' 'Imagina button (D2) pressed?'
  spec 'r' 'imagina_read_digital' 'Imagina digital reading _' 'menu.sensor' 'SL (D5)'
  spec 'r' 'imagina_read_A1' 'Imagina analog reading A1'
  space
  spec ' ' 'imagina_set_digital' 'Imagina set digital pin _ to _' 'menu.sensor bool' 'SL (D5)' true
  space
  spec ' ' 'imagina_stop_servo' 'Imagina stop servo _' 'menu.servo' 'A'
  spec ' ' 'imagina_set_servo_degrees' 'Imagina set servo _ to _ degrees (-90 to 90)' 'menu.servo num' 'A' 90
  spec ' ' 'imagina_set_servo_speed' 'Imagina set servo _ to speed _ (-100 to 100)' 'menu.servo num' 'A' 100
  space
  spec ' ' 'imagina_set_motor_speed' 'Imagina set _ speed to _ %' 'menu.motor auto' 'Motor A' 100
  spec ' ' 'imagina_set_motor_rotation' 'Imagina set _ to _' 'menu.motor menu.motorRotation' 'Motor A' 'stop'
  space
  spec 'r' 'imagina_nunchuck' 'Imagina Nunchuck _' 'menu.nunchuck' 'joyX'
  space
  spec 'r' 'imagina_receive_IR' 'Imagina IR reading'
  spec ' ' 'imagina_transmit_IR' 'Imagina IR transmit device _ command _' 'num num' 48896 0

to imagina_button {
  return (digitalReadOp 26)
}

to imagina_distance {
  return ('distance (cm)' 17 26)
}

to imagina_light {
  return (analogReadOp 35)
}

to imagina_nunchuck which {
  local 'value' 0
  local 'data' (newList 6)
  '[sensors:i2cRead]' (hexToInt '52') data
  if (which == 'joyX') {
    value = (at 1 data)
  }
  if (which == 'joyY') {
    value = (at 2 data)
  }
  if (which == 'accX') {
    value = (((at 3 data) << 2) | (((at 6 data) >> 2) & 3))
  }
  if (which == 'accY') {
    value = (((at 4 data) << 2) | (((at 6 data) >> 4) & 3))
  }
  if (which == 'accZ') {
    value = (((at 5 data) << 2) | (((at 6 data) >> 6) & 3))
  }
  if (which == 'butC') {
    value = ((((at 6 data) >> 1) & 1) == 0)
  }
  if (which == 'butZ') {
    value = ((((at 6 data) >> 0) & 1) == 0)
  }
  return value
}

to imagina_play note octave ms {
  'attach buzzer to pin' 2
  'play tone' note octave ms
}

to imagina_read_A1 {
  return (analogReadOp 4)
}

to imagina_read_digital sensor {
  if (sensor == 'SL (D5)') {local 'pin' 16}
  if (sensor == 'SR (D6)') {local 'pin' 27}
  return (digitalReadOp pin)
}

to imagina_receive_IR {
  attachIR 23
  return (receiveIR)
}

to imagina_set_digital sensor state {
  if (sensor == 'SL (D5)') {local 'pin' 16}
  if (sensor == 'SR (D6)') {local 'pin' 27}
  digitalWriteOp pin state
}

to imagina_set_led led state {
  comment 'For yellow and red leds, only works if nothing is connected
to D5 or D6 pins respectively (SL, servo B/ SR, servo A)'
  if (state == 'on') {
    state = true
  } else {
    state = false
  }
  if (led == 'red') {
    digitalWriteOp 27 state
  } (led == 'yellow') {
    digitalWriteOp 16 state
  } else {
    digitalWriteOp 25 state
  }
}

to imagina_set_motor_rotation motor state {
  if (motor == 'Motor A') {
    local 'pin1' 12
    local 'pin2' 14
  } else {
    local 'pin1' 18
    local 'pin2' 19
  }
  if (state == 'stop') {
    digitalWriteOp pin1 false
    digitalWriteOp pin2 false
  }
  if (state == 'forward') {
    digitalWriteOp pin1 true
    digitalWriteOp pin2 false
  }
  if (state == 'backward') {
    digitalWriteOp pin1 false
    digitalWriteOp pin2 true
  }
}

to imagina_set_motor_speed motor speed {
  if (motor == 'Motor A') {
    local 'pin' 13
  } else {
    local 'pin' 5
  }
  if (speed > 100) {
    speed = 100
  }
  if (speed > 0) {
    analogWriteOp pin ('[misc:rescale]' speed 0 100 400 1024)
  } else {
    analogWriteOp pin 0
  }
}

to imagina_set_servo_degrees servo degrees {
  if (servo == 'A') {setServoAngle 27 degrees}
  if (servo == 'B') {setServoAngle 16 degrees}
}

to imagina_set_servo_speed servo speed {
  if (servo == 'A') {setServoSpeed 27 speed}
  if (servo == 'B') {setServoSpeed 16 speed}
}

to imagina_stop_servo servo {
  if (servo == 'A') {stopServo 27}
  if (servo == 'B') {stopServo 16}
}

to imagina_temperature {
  return ((analogReadOp 34) / 18)
}

to imagina_transmit_IR device value {
  _ir_transmit_pin = 25
  IR_Transmit device value
}

module 'MiKe Robot'
author 'Joan GuillÃ©n'
version 1 0 
tags keyestudio robot car 
description 'Provides sensor, light and motion blocks for the Keyestudio micro:bit Mini Smart Robot Car v2.'
variables _MiKe_circlePixels _MiKe_i2c_on 
choices directions clockwise 'counter-clockwise'
choices sideMenu Right Left
choices robotDirections Forward Backward Right Left

	spec 'r' 'MiKe front obstacle (cm)' 'MiKe front obstacle (cm)'
	spec 'r' 'MiKe obstacle ?' 'MiKe _ obstacle ?' 'menu.sideMenu' 'Right'
	spec 'r' 'MiKe black line on ?' 'MiKe black line on _ ?' 'menu.sideMenu' 'Right'
	spec 'r' 'MiKe back light' 'MiKe back light'
	spec 'r' 'MiKe IR' 'MiKe IR'
	spec 'r' 'MiKe digital D8 sensor' 'MiKe digital D8 sensor'
	space
	spec ' ' 'MiKe stop motors' 'MiKe stop motors'
	spec ' ' 'MiKe Robot go' 'MiKe Robot go _ at _ %' 'menu.robotDirections num' 'Forward' 25
	spec ' ' 'MiKe Robot speed' 'MiKe Robot speed _ %' 'num' 25
	spec ' ' 'MiKe Robot direction' 'MiKe Robot direction _' 'menu.robotDirections' 'Forward'
	spec ' ' 'MiKe turn motor' 'MiKe turn _ motor _' 'menu.sideMenu menu.directions' 'Right' 'clockwise'
	spec ' ' 'MiKe speed motor' 'MiKe speed _ motor at _ %' 'menu.sideMenu num' 'Right' 25
	space
	spec ' ' 'MiKe front lights off' 'MiKe front lights off'
	spec ' ' 'MiKe front lights' 'MiKe front lights to _' 'color'
	spec ' ' 'MiKe circle lights off' 'MiKe circle lights off'
	spec ' ' 'MiKe circle ligths to' 'MiKe circle ligths to _' 'color'
	spec ' ' 'MiKe circle light to' 'MiKe circle light _ (1-18) to _' 'num color' 1
	spec ' ' 'MiKe rotate lights by' 'MiKe rotate lights by _' 'num' 1
	spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
	spec 'r' 'randomColor' 'random color'
	space
	spec ' ' 'MiKe digital D8 to' 'MiKe digital D8 to _' 'bool' false
	spec ' ' '_MiKe_i2c_ensureInitialized' '_MiKe_i2c_ensureInitialized'
	spec ' ' '_MiKe_circlePixels_ensureInitialized' '_MiKe_circlePixels_ensureInitialized'
	spec ' ' '_MiKe_circlePixels_update' '_MiKe_circlePixels_update'

to 'MiKe IR' {
  local 'ir_pin' 16
  forever {
    local 'ir_pulse_times' (newList 200)
    fillList ir_pulse_times 0
    local 'i' 1
    waitUntil (not (digitalReadOp ir_pin))
    local 'start' (microsOp)
    local 'exit' 0
    repeatUntil (exit > 0) {
      waitUntil (digitalReadOp ir_pin)
      local 'end' (microsOp)
      atPut i ir_pulse_times (end - start)
      i += 1
      start = end
      repeatUntil (or (not (digitalReadOp ir_pin)) (exit > 0)) {
        if (((microsOp) - start) > 5000) {exit = 1}
      }
      if (exit == 0) {
        local 'end' (microsOp)
        atPut i ir_pulse_times (end - start)
        i += 1
        start = end
      }
    }
    if (and ((at 67 ir_pulse_times) != 0) ((at 68 ir_pulse_times) == 0)) {
      local 'result' 0
      local 'i' 36
      local 'bit' 1
      repeat 8 {
        if ((at i ir_pulse_times) > 1000) {result = (result | bit)}
        bit = (bit << 1)
        i += 2
      }
      return result
    }
  }
}

to 'MiKe Robot direction' direction {
  if (direction == 'Backward') {
    'MiKe turn motor' 'Right' 'counter-clockwise'
    'MiKe turn motor' 'Left' 'clockwise'
  } (direction == 'Left') {
    'MiKe turn motor' 'Right' 'clockwise'
    'MiKe turn motor' 'Left' 'clockwise'
  } (direction == 'Right') {
    'MiKe turn motor' 'Right' 'counter-clockwise'
    'MiKe turn motor' 'Left' 'counter-clockwise'
  } else {
    'MiKe turn motor' 'Right' 'clockwise'
    'MiKe turn motor' 'Left' 'counter-clockwise'
  }
}

to 'MiKe Robot go' direction speed {
  'MiKe Robot speed' speed
  'MiKe Robot direction' direction
}

to 'MiKe Robot speed' speed {
  'MiKe speed motor' 'Right' speed
  'MiKe speed motor' 'Left' speed
}

to 'MiKe back light' {
  return (analogReadOp 1)
}

to 'MiKe black line on ?' side {
  local 'pin' 12
  if (side == 'Left') {
    pin = 13
  }
  return (digitalReadOp pin)
}

to 'MiKe circle light to' i color {
  '_MiKe_circlePixels_ensureInitialized'
  if (and (1 <= i) (i <= 18)) {
    if (i != 10) {
      i = ((28 - i) % 18)
    } else {
      i = 18
    }
    atPut i _MiKe_circlePixels color
    '_MiKe_circlePixels_update'
  }
}

to 'MiKe circle lights off' {
  '_MiKe_circlePixels_ensureInitialized'
  fillList _MiKe_circlePixels 0
  '_MiKe_circlePixels_update'
}

to 'MiKe circle ligths to' color {
  '_MiKe_circlePixels_ensureInitialized'
  fillList _MiKe_circlePixels color
  '_MiKe_circlePixels_update'
}

to 'MiKe digital D8 sensor' {
  return (digitalReadOp 8)
}

to 'MiKe digital D8 to' value {
  digitalWriteOp 8 value
}

to 'MiKe front lights' color {
  local 'i2cAdd' 67
  '_MiKe_i2c_ensureInitialized'
  local 'red' (absoluteValue (4095 - (((color >> 16) * 4095) / 255)))
  local 'green' (absoluteValue (4095 - ((((color >> 8) & 255) * 4095) / 255)))
  local 'blue' (absoluteValue (4095 - (((color & 255) * 4095) / 255)))
  '[sensors:i2cWrite]' i2cAdd ('[data:makeList]' (6 + (4 * 6)) (0 & 255) ((0 >> 8) & 255) (red & 255) ((red >> 8) & 255))
  '[sensors:i2cWrite]' i2cAdd ('[data:makeList]' (6 + (4 * 5)) (0 & 255) ((0 >> 8) & 255) (green & 255) ((green >> 8) & 255))
  '[sensors:i2cWrite]' i2cAdd ('[data:makeList]' (6 + (4 * 4)) (0 & 255) ((0 >> 8) & 255) (blue & 255) ((blue >> 8) & 255))
}

to 'MiKe front lights off' {
  '_MiKe_i2c_ensureInitialized'
  'MiKe front lights' 0
}

to 'MiKe front obstacle (cm)' {
  digitalWriteOp 14 false
  waitMicros 2
  digitalWriteOp 14 true
  waitMicros 50
  digitalWriteOp 14 false
  local 'start' (microsOp)
  waitUntil (or (not (digitalReadOp 15)) (((microsOp) - start) > 23320))
  waitUntil (or (digitalReadOp 15) (((microsOp) - start) > 23320))
  local 'init' (microsOp)
  waitUntil (or (not (digitalReadOp 15)) (((microsOp) - init) > 23320))
  local 'end' (microsOp)
  return ((10 * (end - init)) / 583)
}

to 'MiKe obstacle ?' side {
  local 'pin' 11
  if (side == 'Left') {
    pin = 2
  }
  return (not (digitalReadOp pin))
}

to 'MiKe rotate lights by' n {
  '_MiKe_circlePixels_ensureInitialized'
  repeat (absoluteValue n) {
    local 'isClockwise' (n > 0)
    local 'length' (size _MiKe_circlePixels)
    if isClockwise {
      local 'first' (at 1 _MiKe_circlePixels)
      for i (length - 1) {
        atPut i _MiKe_circlePixels (at (i + 1) _MiKe_circlePixels)
      }
      atPut length _MiKe_circlePixels first
    } else {
      local 'last' (at length _MiKe_circlePixels)
      for i (length - 1) {
        atPut ((length - i) + 1) _MiKe_circlePixels (at (length - i) _MiKe_circlePixels)
      }
      atPut 1 _MiKe_circlePixels last
    }
  }
  '_MiKe_circlePixels_update'
}

to 'MiKe speed motor' motor speed {
  '_MiKe_i2c_ensureInitialized'
  local 'i2cAdd' 67
  speed = ((speed * 4095) / 100)
  local 'pin' 3
  if (motor == 'Left') {
    pin = 1
  }
  '[sensors:i2cWrite]' i2cAdd ('[data:makeList]' (6 + (4 * pin)) (0 & 255) ((0 >> 8) & 255) (speed & 255) ((speed >> 8) & 255))
}

to 'MiKe stop motors' {
  'MiKe speed motor' 'Right' 0
  'MiKe speed motor' 'Left' 0
}

to 'MiKe turn motor' motor direction {
  '_MiKe_i2c_ensureInitialized'
  local 'i2cAdd' 67
  local 'pin' 2
  local 'directionValue' 0
  if (motor == 'Left') {
    pin = 0
    if (direction == 'clockwise') {
      directionValue = 4095
    }
  } else {
    if (direction == 'counter-clockwise') {directionValue = 4095}
  }
  '[sensors:i2cWrite]' i2cAdd ('[data:makeList]' (6 + (4 * pin)) (0 & 255) ((0 >> 8) & 255) (directionValue & 255) ((directionValue >> 8) & 255))
}

to '_MiKe_circlePixels_ensureInitialized' {
  if (_MiKe_circlePixels == 0) {
    _MiKe_circlePixels = (newList 18)
    fillList _MiKe_circlePixels 0
    '[display:neoPixelSetPin]' 5 false
  }
}

to '_MiKe_circlePixels_update' {
  '[display:neoPixelSend]' _MiKe_circlePixels
  waitMicros 100
}

to '_MiKe_i2c_ensureInitialized' {
  if (_MiKe_i2c_on == 0) {
    local 'i2cAdd' 67
    local 'oldmode' 0
    i2cSet i2cAdd 0 0
    oldmode = (i2cGet i2cAdd 0)
    i2cSet i2cAdd 0 ((oldmode & 127) | 16)
    i2cSet i2cAdd 254 121
    i2cSet i2cAdd 0 oldmode
    waitMillis 5
    i2cSet i2cAdd 0 (oldmode | 161)
    for i 16 {
      '[sensors:i2cWrite]' i2cAdd ('[data:makeList]' (6 + (4 * (i - 1))) (0 & 255) ((0 >> 8) & 255) (0 & 255) ((0 >> 8) & 255))
    }
    _MiKe_i2c_on = 1
  }
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

module 'shield:bit'
author 'Joan GuillÃ©n'
version 1 0 
tags keyestudio micro:bit 
description 'Provides custom blocks for the shield:bit. It has control for 4 DC motors, 2 Steppers, 1 Buzzer/Audio_out, 1 potenciometer and 4 neopixel LEDs'
variables _sb_neoPixels _sb_neoPixels_on _tonePin _toneInitalized _pca9685_on _pca9685_prescale _pca9685_st_steps
choices motorDirections clockwise 'counter-clockwise'
choices motorTypes all servos 'DC/Steppers'
choices stepperSteps turns degrees
	
	spec ' ' 'sb LEDs off' 'sêb LEDs off'
	spec ' ' 'sb LEDs to color' 'sêb LEDs to _' 'color'
	spec ' ' 'sb LED to color' 'sêb LED _ (1-4) to _' 'num color' 1
	spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
	spec 'r' 'randomColor' 'random color'
	space
	spec ' ' 'sb change audio output to shield' 'sêb audio output to shield _' 'bool' true
	space
	spec ' ' 'sb stop motors' 'sêb stop _ motors' 'menu.motorTypes' 'all'
	space
	spec ' ' 'sb turn 180 servo' 'sêb turn 180 servo S- _ (1-8) to angle _' 'num num' 1 90
	spec ' ' 'sb turn 360 servo' 'sêb turn 360 servo S- _ (1-8) _ at _ %' 'num menu.motorDirections num' 1 'clockwise' 50
    space
	spec ' ' 'sb turn M motor' 'sêb turn DC M- _ (1-4) motor _ at _ %' 'num menu.motorDirections num' 1 'clockwise' 50
	spec ' ' 'sb turn Stepper' 'sêb turn Stepper- _ (1-2) motor _ for _ _' 'num menu.motorDirections num menu.stepperSteps' 1 'clockwise' 1 'turns'
	space
	spec ' ' 'sb set pin' 'sêb set pin S- _ (1-8) to _ %' 'num num' 1 100
	space
    spec ' ' '_sb_neoPixels_setup' '_sb_neoPixels_setup'
	spec ' ' '_sb_neoPixels_update' '_sb_neoPixels_update'
	spec ' ' '_pca9685_pwm' '_pca9685_pwm pin _ from _ to _' 'num num num' 1 0 0
    spec ' ' '_pca9685_setup' '_pca9685_setup'

//////
//4 neopixel LEDs at pin 16
//////

to 'sb LEDs off' {
  if (not _sb_neoPixels_on) {'_sb_neoPixels_setup'}
  fillList _sb_neoPixels 0
  '_sb_neoPixels_update'
}

to 'sb LEDs to color' color {
  if (not _sb_neoPixels_on) {'_sb_neoPixels_setup'}
  fillList _sb_neoPixels color
  '_sb_neoPixels_update'
}

to 'sb LED to color' i color {
  if (not _sb_neoPixels_on) {'_sb_neoPixels_setup'}
  if (and (1 <= i) (i <= 4)) {
    atPut i _sb_neoPixels color
    '_sb_neoPixels_update'
  }
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

//////
//Shield audio connection for micro:bit v2
//////
to 'sb change audio output to shield' on {
  if on {
    _tonePin = 0
  } else {
    _tonePin = -1
  }
  _toneInitalized = true
}

//////
//PCA9685 for servos, DC and Stepper motors
//////

to 'sb stop motors' type {
  if (not _pca9685_on) {'_pca9685_setup'}
  if (or (type == 'DC/Steppers') (type == 'all')) {
    for i 8 {
      '_pca9685_pwm' (i - 1) 0 0
    }
  }
  if (or (type == 'servos') (type == 'all')) {
    for i 8 {
      '_pca9685_pwm' (i + 7) 0 0
    }
  }
}

//////
//Servo motors S1 to S8
//////

to 'sb turn 180 servo' s angle {
  if (not _pca9685_on) {'_pca9685_setup'}
  if (and (1 <= s) (s <= 8)) {
    if (angle < 0) {angle = 0}
    if (180 < angle) {angle = 180}
    angle = (((((angle * 1800) / 180) + 600) * 4095) / 20000)
    '_pca9685_pwm' (s + 7) 0 angle
  }
}

to 'sb turn 360 servo' s direction speed {
  if (not _pca9685_on) {'_pca9685_setup'}
  if (and (1 <= s) (s <= 8)) {
    if (speed < 0) {speed = 0}
    if (100 < speed) {speed = 100}
    if (direction == 'counter-clockwise') {
      speed = (((((speed * 900) / 100) + 1500) * 4095) / 20000)
    } else {
      speed = (((((speed * -900) / 100) + 1500) * 4095) / 20000)
    }
    '_pca9685_pwm' (s + 7) 0 speed
  }
}

//////
//DC Motors M1 to M4 and Steppers 1 and 2
//////

to 'sb turn M motor' m direction speed {
  if (not _pca9685_on) {'_pca9685_setup'}
  if (and (1 <= m) (m <= 4)) {
    if (speed < 0) {speed = 0}
    if (100 < speed) {speed = 100}
    speed = ((speed * 4095) / 100)
    local 'pin2' ((m - 1) * 2)
    local 'pin1' (pin2 + 1)
    if (or (and (or (m == 1) (m == 2)) (direction == 'counter-clockwise')) (and (or (m == 3) (m == 4)) (not (direction == 'counter-clockwise')))) {
      pin2 = pin1
      pin1 = (pin2 - 1)  
    }
    '_pca9685_pwm' pin1 0 0
    '_pca9685_pwm' pin2 0 speed
  }
}

to 'sb turn Stepper' stp direction steps unit {
  if (not _pca9685_on) {'_pca9685_setup'}
  if (steps < 0) {steps = 0}
  steps = (steps * ((1000 * _pca9685_st_steps) / 50))
  if (unit == 'degrees') {
    steps = (steps / 360)
  }
  if (stp == 1) {
    if (direction == 'counter-clockwise') {
      '_pca9685_pwm' 1 0 1023
      '_pca9685_pwm' 0 1024 2047
      '_pca9685_pwm' 3 2048 3071
      '_pca9685_pwm' 2 3072 4095
    } else {
      '_pca9685_pwm' 2 0 1023
      '_pca9685_pwm' 3 1024 2047
      '_pca9685_pwm' 0 2048 3071
      '_pca9685_pwm' 1 3072 4095
    }
    waitMillis steps
    for i 4 {
      '_pca9685_pwm' (i - 1) 0 0
    }
  }
  if (stp == 2) {
    if (direction == 'counter-clockwise') {
      '_pca9685_pwm' 7 0 1023
      '_pca9685_pwm' 6 1024 2047
      '_pca9685_pwm' 5 2048 3071
      '_pca9685_pwm' 4 3072 4095
    } else {
      '_pca9685_pwm' 4 0 1023
      '_pca9685_pwm' 5 1024 2047
      '_pca9685_pwm' 6 2048 3071
      '_pca9685_pwm' 7 3072 4095
    }
    waitMillis steps
    for i 4 {
      '_pca9685_pwm' (i + 3) 0 0
    }
  }
}

//////
//PWM servo pins
//////

to 'sb set pin' pin value {
  if (not _pca9685_on) {'_pca9685_setup'}
  if (and (1 <= pin) (pin <= 8)) {
    if (value < 0) {value = 0}
    if (100 < value) {value = 100}
    value = ((value * 4095) / 100)
    '_pca9685_pwm' (pin + 7) 0 value
  }
}

//////
//Library blocks
//////

to '_sb_neoPixels_setup' {
  _sb_neoPixels = (newList 4)
  fillList _sb_neoPixels 0
  '[display:neoPixelSetPin]' 16 false
  _sb_neoPixels_on = true
}

to '_sb_neoPixels_update' {
  '[display:neoPixelSend]' _sb_neoPixels
  waitMicros 100
}
to '_pca9685_pwm' pin in out {
  '[sensors:i2cWrite]' (64) ('[data:makeList]' (6 + (4 * pin)) (in & 255) ((in >> 8) & 255) (out & 255) ((out >> 8) & 255))
}

to '_pca9685_setup' {
  if (_pca9685_prescale == 0) {_pca9685_prescale = 129}
  if (_pca9685_st_steps == 0) {_pca9685_st_steps = 512}
  i2cSet (hexToInt '40') 0 128
  waitMillis 100
  i2cSet (hexToInt '40') 0 16
  i2cSet (hexToInt '40') (hexToInt 'FE') _pca9685_prescale
  i2cSet (hexToInt '40') 0 0
  waitMillis 100
  i2cSet (hexToInt '40') 0 160
  for i 16 {
    '_pca9685_pwm' (i - 1) 0 0
  }
  _pca9685_on = (booleanConstant true)
}



module 'TdR STEAM' Output
author 'K Giori'
version 1 1 
depends 'IR Remote' 'Temperature Humidity (DHT11, DHT22)' 
description 'Library for INNOVA DIDACTIC Imagina TdR STEAM v2.0 shield when used with ESP32 board.

https://shop.innovadidactic.com/es/placas-kits-y-robots/1574-kit-imagina-tdr-steam-basado-en-esp32-steamaker.html'

	spec ' ' 'tdr_test_buzzer' 'TdR test buzzer'
	spec ' ' 'tdr_set_blue_LED' 'TdR set blue LED _' 'bool' true
	spec ' ' 'tdr_set_red_LED' 'TdR set red LED _' 'bool' true
	space
	spec ' ' 'tdr_set_RGB_LED' 'TdR set RGB LED _' 'color'
	spec ' ' 'tdr_clear_RGB_LED' 'TdR clear RGB LED'
	spec 'r' 'tdr_colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
	spec 'r' 'tdr_randomColor' 'random color'
	space
	spec 'r' 'tdr_LM35_temp' 'TdR LM35 temperature Â°C'
	spec 'r' 'tdr_DHT11_temp' 'TdR DHT11 temperature Â°C'
	spec 'r' 'tdr_DHT11_humidity' 'TdR DHT11 humidity'
	space
	spec 'r' 'tdr_rotation' 'TdR rotation'
	spec 'r' 'tdr_light_level' 'TdR light level'
	spec 'r' 'tdr_switch_1' 'TdR button 1'
	spec 'r' 'tdr_switch_2' 'TdR button 2'
	space
	spec 'r' 'tdr_receiveIRcode' 'TdR receive IR code'

to tdr_DHT11_humidity {
  return (humidity_DHT11 17)
}

to tdr_DHT11_temp {
  return (temperature_DHT11 17)
}

to tdr_LM35_temp {
  return (((5000 * (analogReadOp 35)) / 10240) + 4)
}

to tdr_clear_RGB_LED {
  analogWriteOp 27 0
  analogWriteOp 13 0
  analogWriteOp 5 0
}

to tdr_colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to tdr_light_level {
  return (analogReadOp 4)
}

to tdr_randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to tdr_receiveIRcode {
  attachIR 23
  return (receiveIR)
}

to tdr_rotation {
  return (analogReadOp 2)
}

to tdr_set_RGB_LED color {
  comment 'red 27, green 13, blue 5'
  local 'r' (255 & (color >> 16))
  local 'g' (255 & (color >> 8))
  local 'b' (255 & color)
  analogWriteOp 27 (r / 3)
  analogWriteOp 13 (g / 4)
  analogWriteOp 5 (b / 2)
}

to tdr_set_blue_LED on {
  digitalWriteOp 18 on
}

to tdr_set_red_LED on {
  digitalWriteOp 19 on
}

to tdr_switch_1 {
  return (digitalReadOp 26)
}

to tdr_switch_2 {
  return (digitalReadOp 14)
}

to tdr_test_buzzer {
  comment 'buzzer is pin 12'
  repeat 100 {
    digitalWriteOp 12 true
    waitMillis 2
    digitalWriteOp 12 false
    waitMillis 2
  }
}

module 'LEGO EV3'
author 'Julia Reiter'
version 1 0 
description 'Control the LEGO MINDSTORMS Education EV3 robot. Some of the functionalities are not yet available.'
tags lego robot

	spec ' ' 'get manufacturer' 'get manufacturer'
	spec 'r' 'get touch sensor' 'get touch sensor _ _' 'auto auto' '1' '13'
	spec ' ' 'set address' 'set address _' 'auto' '1'
	spec ' ' 'set motor power' 'set motor power _ _' 'auto auto' '1' '0'
	spec ' ' 'set sensortype' 'set sensortype _ _ _' 'auto auto auto' '1' '0' '1'
	spec 'r' 'get color sensor' 'get color sensor _  _' 'auto auto' '1' '13'
	spec 'r' '_get ultrasonic sensor' '_get ultrasonic sensor _ _ _' 'auto auto auto' '1' '1' '0'

to 'get color sensor' address messagetype {
  comment 'gets back the value of the color sensor'
  comment 'messagetype defines on which port the sensor is'
  comment 'port1 = 13 port2 = 14 port3 = 15 port4 = 16'
  local 'msg' ('[data:newByteArray]' 7)
  atPut 1 msg address
  atPut 2 msg messagetype
  atPut 3 msg 0
  atPut 4 msg 0
  atPut 5 msg 0
  atPut 6 msg 0
  atPut 7 msg 0
  '[sensors:spiExchange]' msg
  return (at 7 msg)
}

to 'get manufacturer' {
  comment 'Read the manufacturer name'
  local 'msg' ('[data:newByteArray]' 24)
  atPut 1 msg 1
  atPut 2 msg 1
  '[sensors:spiExchange]' msg
  sayIt ('[data:join]' 'Status byte (decimal):' (at 4 msg))
  waitMillis 2000
  sayIt ('[data:join]' '' ('[data:copyFromTo]' msg 5))
  return ('[data:join]' '' ('[data:copyFromTo]' msg 5))
}

to 'get touch sensor' address messagetype {
  comment 'gets the sensor value of a touch sensor on a specific port'
  comment 'the port is selected with messagetype port1 = 13 port2 = 14 port3 = 15 port4 = 16'
  local 'msg' ('[data:newByteArray]' 7)
  atPut 1 msg address
  atPut 2 msg messagetype
  atPut 3 msg 0
  atPut 4 msg 0
  atPut 5 msg 0
  atPut 6 msg 0
  atPut 7 msg 0
  '[sensors:spiExchange]' msg
  return (at 7 msg)
}

to '_get ultrasonic sensor' address messagetype sensortype {
  comment 'gets the value of the ultrasonic sensor (still faulty)'
  comment 'messagetype sets the port'
  comment 'port1 = 13 port2 = 14 port3 = 15 port4 = 16'
  comment 'sensortype: cm = 23 inches = 24 listen = 25'
  local 'msg' ('[data:newByteArray]' 8)
  if (sensortype == 25) {
    atPut 1 msg address
    atPut 2 msg messagetype
    atPut 3 msg 0
    atPut 4 msg 0
    atPut 5 msg 0
    atPut 6 msg 0
    atPut 7 msg 0
    '[sensors:spiExchange]' msg
    return (at 7 msg)
  } (or (sensortype == 23) (sensortype == 24)) {
    atPut 1 msg address
    atPut 2 msg messagetype
    atPut 3 msg 0
    atPut 4 msg 0
    atPut 5 msg 0
    atPut 6 msg 0
    atPut 7 msg 0
    atPut 8 msg 0
    '[sensors:spiExchange]' msg
    local 'value' ((((at 7 msg) << 8) | (at 8 msg)) / 10)
    return value
  }
}

to 'set address' address {
  comment 'Setting the SPI address'
  local 'addr' ('[data:newByteArray]' 3)
  atPut 1 addr 0
  atPut 2 addr 11
  atPut 3 addr address
  '[sensors:spiExchange]' addr
}

to 'set motor power' port percentage {
  comment 'setting the motor power on a specific port per percentage'
  local 'msg' ('[data:newByteArray]' 4)
  atPut 1 msg 1
  atPut 2 msg 21
  atPut 3 msg port
  atPut 4 msg percentage
  '[sensors:spiExchange]' msg
}

to 'set sensortype' port type address {
  comment 'Setting the sensortype on a specific port'
  comment 'Currently only EV3 sensors supported'
  comment 'supported types:'
  comment 'EV3-TOUCH=6, EV3-color=20, EV3-ultrasonic=23,24,25'
  local 'msg' ('[data:newByteArray]' 4)
  atPut 1 msg address
  atPut 2 msg 12
  atPut 3 msg port
  atPut 4 msg type
  '[sensors:spiExchange]' msg
}

module M5FireKits Input
author 'Shao Yue'
version 1 0 
depends NeoPixel 
tags m5fire 
description 'M5Core Fire kits pinout
button C 37
NeoPixel RGB LED 15
IRTxPin 13
Mic 34
PortA Red 21/22 
PortB Black 26/36
PortC Blue 16/17
'
variables _m5go_init_flag _np_pixels 

  spec 'r' 'buttonC' 'buttonC'
  spec 'r' 'LEDLightPin15' 'LEDStripPin15'
  spec 'r' 'IRPin' 'IRTxPin'
  spec 'r' 'readMicValue' 'readMicValue'
  spec 'r' 'PortA' 'PortA _' 'auto' 22
  spec 'r' 'PortB' 'PortB _' 'auto' 36
  spec 'r' 'PortC' 'PortC _' 'auto' 17
  space
  spec ' ' 'clearStrip' 'clearStrip'
  spec ' ' 'setStripLED' 'setStripLED _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'setStripRight' 'setStripRight _ _ _ _ _' 'color color color color color'
  spec ' ' 'setStripLeft' 'setStripLeft _ _ _ _ _' 'color color color color color'
  spec ' ' '_m5go_init' '_m5go_init'
  spec 'r' 'MicPin34' '_MicPin34'

to IRPin {
  comment 'm5go åºåº§çº¢å¤åå° 13'
  return 13
}

to LEDLightPin15 {
  comment 'm5go åºåº§(10 LED)ç¯å¸¦ 15'
  return 15
}

to MicPin34 {
  comment 'm5go åºåº§ mic 34'
  return 34
}

to PortA Pin {
  comment 'PortA 21/22 çº¢è² I2C'
  if (Pin == 21) {
    return 21
  } else {
    return 22
  }
}

to PortB Pin {
  comment 'm5go åºåº§ PortB 26/36 é»è² GPIO
36 åªè½åè¾å¥'
  if (Pin == 26) {
    return 26
  } else {
    return 36
  }
}

to PortC Pin {
  comment 'm5go åºåº§ PortC 16/17 èè² UART'
  if (Pin == 17) {
    return 17
  } else {
    return 16
  }
}

to '_m5go_init' {
  if _m5go_init_flag {return 0}
  neoPixelAttach 10 (LEDLightPin15)
  _m5go_init_flag = (booleanConstant true)
}

to buttonC {
  return (not (digitalReadOp 37))
}

to clearStrip {
  '_m5go_init'
  clearNeoPixels
}

to readMicValue {
  comment 'è¯»å m5go åºåº§ mic æ°å¼'
  return (analogReadOp (MicPin34))
}

to setStripLED foo bar baz quux garply spam frob corge grault waldo {
  '_m5go_init'
  atPut 1 _np_pixels foo
  atPut 2 _np_pixels bar
  atPut 3 _np_pixels baz
  atPut 4 _np_pixels quux
  atPut 5 _np_pixels garply
  atPut 10 _np_pixels spam
  atPut 9 _np_pixels frob
  atPut 8 _np_pixels corge
  atPut 7 _np_pixels grault
  atPut 6 _np_pixels waldo
  '_NeoPixel_update'
}

to setStripLeft foo bar baz quux garply {
  '_m5go_init'
  atPut 10 _np_pixels foo
  atPut 9 _np_pixels bar
  atPut 8 _np_pixels baz
  atPut 7 _np_pixels quux
  atPut 6 _np_pixels garply
  '_NeoPixel_update'
}

to setStripRight foo bar baz quux garply {
  '_m5go_init'
  atPut 1 _np_pixels foo
  atPut 2 _np_pixels bar
  atPut 3 _np_pixels baz
  atPut 4 _np_pixels quux
  atPut 5 _np_pixels garply
  '_NeoPixel_update'
}

module Maqueen Output
author 'Turgut Guneysu'
version 1 2 
depends 'IR Remote' 
choices LRBMenu left right both 
choices DirMenu fwd bwd 
choices PosMenu left right 
description 'DFRobot Maqueen Car Kit Library
Supports:
  micro:bit v1 and v2
  2 x N20 Motors (133rpm)
  2 x LEDs
  2 x Servos (use Servo Lib)
  2 x Line Sensors
  2 x Extension Ports
  4 x RGB LEDs (use NEOPixel Lib)
  HC-SR04 Distance Sensor
  Buzzer
  IR receiver (NEC)
  I2C Connector
  3.5-5V Battery Connector
Pin assignments:
  Buzzer = 0
  Trigger = 1
  Echo = 2
  Servo1 = 1
  Servo2 = 2
  LED_Left = 8
  LED_Right = 12
  Line_Left = 13
  Line_Right = 14
  NeoPixels = 15
  IR Receiver = 16
Note: HC-SR04 and SERVOs share pins 1 and 2.
'

	spec ' ' 'Maqueen motor' 'Maqueen motor _ dir _ speed(0-255) _' 'menu.LRBMenu menu.DirMenu auto' 'both' 'fwd' 128
	spec ' ' 'Maqueen stop motors' 'Maqueen stop motors _' 'menu.LRBMenu' 'both'
	space
	spec ' ' 'Maqueen LED' 'Maqueen LED _ _' 'menu.LRBMenu bool' 'left' true
	spec ' ' 'Maqueen beep' 'Maqueen beep _ ms' 'auto' 100
	space
	spec 'r' 'Maqueen line sensor' 'Maqueen line sensor _' 'menu.PosMenu' 'left'
	spec 'r' 'Maqueen sees line on left' 'Maqueen sees line on left _ right _' 'bool bool' true true
	space
	spec 'r' 'Maqueen distance (cm)' 'Maqueen distance (cm)'
	spec 'r' 'Maqueen IR keycode' 'Maqueen IR keycode'

to 'Maqueen IR keycode' {
  comment 'Wait for an IR message and return the key code.'
  attachIR 16
  return (receiveIR)
}

to 'Maqueen LED' lrb LEDstatus {
  comment '2 x red LEDs'
  local '_mq_pin_LED_Left' 8
  local '_mq_pin_LED_Right' 12
  if (lrb == 'left') {
    digitalWriteOp _mq_pin_LED_Left LEDstatus
  } (lrb == 'right') {
    digitalWriteOp _mq_pin_LED_Right LEDstatus
  } (lrb == 'both') {
    digitalWriteOp _mq_pin_LED_Left LEDstatus
    digitalWriteOp _mq_pin_LED_Right LEDstatus
  }
}

to 'Maqueen beep' duration {
  comment 'Buzzer
Remember to set the P0 switch.'
  local '_mq_pin_Buzzer' 0
  local 'end time' ((millisOp) + duration)
  repeatUntil ((millisOp) >= (v 'end time')) {
    digitalWriteOp _mq_pin_Buzzer true
    waitMicros 1900
    digitalWriteOp _mq_pin_Buzzer false
    waitMicros 1900
  }
}

to 'Maqueen distance (cm)' {
  comment 'HC-SR04 Distance Sensor
Contributed by Joan GuillÃ©n and Josep FerrÃ ndiz'
  local '_mq_pin_Trigger' 1
  local '_mq_pin_Echo' 2
  digitalWriteOp _mq_pin_Trigger false
  waitMicros 2
  digitalWriteOp _mq_pin_Trigger true
  waitMicros 50
  digitalWriteOp _mq_pin_Trigger false
  local 'start' (microsOp)
  waitUntil (or (not (digitalReadOp _mq_pin_Echo)) (((microsOp) - start) > 23320))
  waitUntil (or (digitalReadOp _mq_pin_Echo) (((microsOp) - start) > 23320))
  local 'init' (microsOp)
  waitUntil (or (not (digitalReadOp _mq_pin_Echo)) (((microsOp) - init) > 23320))
  local 'end' (microsOp)
  waitMillis 10
  return ((10 * (end - init)) / 583)
}

to 'Maqueen line sensor' lr {
  comment '2 x Line Sensors (true/false)
When Maqueenâs line-tracking sensor is put on the black line,
the sensor outputs 0, and the blue LED turns off;
if put on white area, it outputs 1 and the blue LED turns on.'
  local '_mq_pin_Line_Left' 13
  local '_mq_pin_Line_Right' 14
  if (lr == 'left') {
    return (digitalReadOp _mq_pin_Line_Left)
  } (lr == 'right') {
    return (digitalReadOp _mq_pin_Line_Right)
  }
}

to 'Maqueen motor' lrb dir speed {
  comment 'MOTOR CONTROL:

//% blockId="left motor" block="left" M1 = 0,
//% blockId="right motor" block="right" M2 = 1,
//% blockId="all motor" block="all" All  (issue 2 cmds, one for each motor)

//% blockId="CW" block="Forward" CW = 0x0,
//% blockId="CCW" block="Backward" CCW = 0x1

//% blockId=motor_MotorRun block="motor|%index|move|%Dir|at speed|%speed"
//% speed.min=0 speed.max=255'
  local '_mq_i2c_addr' (hexToInt '10')
  speed = (minimum 255 speed)
  if (dir == 'fwd') {
    dir = 0
  } (dir == 'bwd') {
    dir = 1
  }
  if (lrb == 'left') {
    lrb = 0
    '[sensors:i2cWrite]' _mq_i2c_addr ('[data:makeList]' lrb dir speed)
  } (lrb == 'right') {
    lrb = 2
    '[sensors:i2cWrite]' _mq_i2c_addr ('[data:makeList]' lrb dir speed)
  } (lrb == 'both') {
    '[sensors:i2cWrite]' _mq_i2c_addr ('[data:makeList]' 0 dir speed)
    waitMillis 1
    '[sensors:i2cWrite]' _mq_i2c_addr ('[data:makeList]' 2 dir speed)
  }
  waitMillis 50
}

to 'Maqueen sees line on left' leftSide rightSide {
  comment 'Allows for dual evaluation of the sensors for faster results '
  return (and (leftSide == (not ('Maqueen line sensor' 'left'))) (rightSide == (not ('Maqueen line sensor' 'right'))))
}

to 'Maqueen stop motors' lrb {
  comment 'STOP Motors'
  'Maqueen motor' lrb 'fwd' 0
}

module PicoBricks
author MicroBlocks
version 2 5 
depends 'Temperature Humidity (DHT11, DHT22)' 
description 'Robotistan PicoBricks Library

This library controls these Pico Bricks components:
- Red LED
- RGB LED
- DC Motors
- Piezo speaker
- Relay Switch (5V-250V, 5A)
- Button
- Potentiometer (variable resistor)
- Light sensor (light dependent resistor)
- Temperature and humidity sensor (DHT11)
- switched to renamed DHT library

Use separate libraries to control:
- Servo motors
- Graphic display (OLED)
- WIFI/Bluetooth expansion board

See https://www.robotistan.com, 
https://wiki.microblocks.fun/boards/pico
'
variables _pb_initialized _pb_pin_RedLED _pb_pin_Button _pb_pin_DHT _pb_pin_Relay _pb_pin_Pot _pb_pin_LDR _pb_pin_Buzzer _pb_pin_Motor1 _pb_pin_Motor2 _pb_pin_RGB_LED _pb_pin_TX _pb_pin_RX _pb_i2c_Addr 

  spec ' ' 'pb_beep' 'PicoBricks beep _ ms' 'auto' 500
  spec 'r' 'pb_button' 'PicoBricks button'
  spec 'r' 'pb_humidity' 'PicoBricks humidity'
  spec 'r' 'pb_light_sensor' 'PicoBricks light sensor (0-100) %'
  spec 'r' 'pb_potentiometer' 'PicoBricks potentiometer'
  spec 'r' 'pb_random_color' 'PicoBricks random color'
  spec 'r' 'pb_rgb_color' 'PicoBricks color r _ g _ b _ (0-255)' 'auto auto auto' 0 0 0
  spec ' ' 'pb_set_motor_speed' 'PicoBricks set motor _ speed _ (0-100)' 'auto num' 1 100
  spec ' ' 'pb_set_red_LED' 'PicoBricks set red LED _' 'bool' true
  spec ' ' 'pb_set_relay' 'PicoBricks set relay _' 'bool' true
  spec ' ' 'pb_set_rgb_color' 'PicoBricks set RGB LED color _' 'color'
  spec 'r' 'pb_temperature' 'PicoBricks temperature (Â°C)'
  spec ' ' 'pb_turn_off_RGB' 'PicoBricks turn off RGB LED'
  spec ' ' '_pb_init_pins' '_pb_init_pins'

to '_pb_init_pins' {
  if _pb_initialized {return}
  _pb_pin_RGB_LED = 6
  _pb_pin_RedLED = 7
  _pb_pin_Button = 10
  _pb_pin_DHT = 11
  _pb_pin_Relay = 12
  _pb_pin_Buzzer = 20
  _pb_pin_Motor1 = 21
  _pb_pin_Motor2 = 22
  _pb_pin_Pot = 26
  _pb_pin_LDR = 27
  _pb_pin_TX = 0
  _pb_pin_RX = 1
  _pb_i2c_Addr = '3C'
  _pb_initialized = (booleanConstant true)
}

to pb_beep duration {
  local 'buzzer pin' 20
  '[io:playTone]' (v 'buzzer pin') 300
  waitMillis duration
  '[io:playTone]' (v 'buzzer pin') 0
}

to pb_button {
  '_pb_init_pins'
  return (digitalReadOp _pb_pin_Button)
}

to pb_humidity {
  '_pb_init_pins'
  return (humidity_DHT11 _pb_pin_DHT)
}

to pb_light_sensor {
  comment 'Returns Light Values s a percentage:
0: dark,  100: light'
  '_pb_init_pins'
  return ((minimum (analogReadOp _pb_pin_LDR) 300) / 3)
}

to pb_potentiometer {
  '_pb_init_pins'
  return (analogReadOp _pb_pin_Pot)
}

to pb_random_color {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to pb_rgb_color r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to pb_set_motor_speed which speed {
  '_pb_init_pins'
  speed = (maximum 0 (minimum speed 100))
  if (which == 1) {
    analogWriteOp _pb_pin_Motor1 ((1023 * speed) / 100)
  } (which == 2) {
    analogWriteOp _pb_pin_Motor2 ((1023 * speed) / 100)
  }
}

to pb_set_red_LED aBoolean {
  '_pb_init_pins'
  digitalWriteOp _pb_pin_RedLED aBoolean
}

to pb_set_relay aBoolean {
  '_pb_init_pins'
  digitalWriteOp _pb_pin_Relay aBoolean
}

to pb_set_rgb_color color {
  '_pb_init_pins'
  '[display:neoPixelSetPin]' _pb_pin_RGB_LED false
  '[display:neoPixelSend]' color
  waitMillis 1
}

to pb_temperature {
  '_pb_init_pins'
  return (temperature_DHT11 _pb_pin_DHT)
}

to pb_turn_off_RGB {
  '_pb_init_pins'
  '[display:neoPixelSetPin]' _pb_pin_RGB_LED false
  '[display:neoPixelSend]' 0
  waitMillis 1
}

module RoboFut Output
author MicroBlocks
version 1 0 
description 'Blocks for the RoboFut football robot designed by Tesla Lab at the Galileo University in Guatemala.'

  spec ' ' 'move forward' 'move forward'
  spec ' ' 'move backwards' 'move backwards'
  spec ' ' 'turn left' 'turn left'
  spec ' ' 'turn right' 'turn right'
  spec ' ' 'stop' 'stop'
  spec ' ' 'pick ball' 'pick up ball'
  spec ' ' 'shoot ball' 'shoot ball'
  spec ' ' 'stop2 ball motors' 'stop ball motors'
  spec ' ' 'stop all motors' 'stop all motors'

to 'move backwards' {
  digitalWriteOp 4 true
  digitalWriteOp 18 false
  digitalWriteOp 14 true
  digitalWriteOp 27 false
}

to 'move forward' {
  digitalWriteOp 4 false
  digitalWriteOp 18 true
  digitalWriteOp 14 false
  digitalWriteOp 27 true
}

to 'pick ball' {
  'stop2 ball motors'
  digitalWriteOp 25 false
  digitalWriteOp 26 true
  digitalWriteOp 32 true
  digitalWriteOp 33 false
}

to 'shoot ball' {
  'stop2 ball motors'
  digitalWriteOp 25 true
  digitalWriteOp 26 false
  digitalWriteOp 32 false
  digitalWriteOp 33 true
  waitMillis 1000
  'stop2 ball motors'
}

to stop {
  digitalWriteOp 4 false
  digitalWriteOp 18 false
  digitalWriteOp 14 false
  digitalWriteOp 27 false
}

to 'stop all motors' {
  for i ('[data:makeList]' 4 14 18 25 26 27 32 33) {
    digitalWriteOp i false
  }
}

to 'stop2 ball motors' {
  digitalWriteOp 25 false
  digitalWriteOp 26 false
  digitalWriteOp 32 false
  digitalWriteOp 33 false
}

to 'turn left' {
  digitalWriteOp 4 true
  digitalWriteOp 18 false
  digitalWriteOp 14 false
  digitalWriteOp 27 true
}

to 'turn right' {
  digitalWriteOp 4 false
  digitalWriteOp 18 true
  digitalWriteOp 14 true
  digitalWriteOp 27 false
}

module RobotBit Output
author MicroBlocks
version 1 0
description 'Library for the Kittenbot RobotBit motor and servo controller board.
Currently supports servos and gear motors but not stepper motors.'
variables _robotbitMicrosecsPerCycle

	spec ' ' 'initRobotbit' 'initialize Robotbit (all off)'
	spec ' ' 'setRobobitServoAngle' 'set Robotbit servo _ to _ degrees (-90 to 90)' 'menu.range:1-8 num' 1 90
	spec ' ' 'setRobotbitServoSpeed' 'set Robotbit servo  _ to speed _ (-100 to 100)' 'menu.range:1-8 num' 1 100
	spec ' ' 'setRobotbitMotor' 'set Robotbit motor _ to speed _ (-100 to 100)' 'menu.range:1-4 num' 1 100
	spec 'r' '_computeMicrosecsPerCycle' '_compute microsecs per cycle'
	spec ' ' '_robotbitAllOff' '_robotbitAllOff'
	spec ' ' '_setPWM' '_setPWM _ _ _' 'auto auto auto' 1 0 2048

to '_computeMicrosecsPerCycle' {
  comment 'The Robobit''s clock speed varies slightly board to board,
which can slightly offset the range of servo pulse widths.
This function allows you measure the actual PWM cycle time
allowing you to achieve greater servo precision.
Connect a jumper wire from pin S1 to P15 and run this
script to measure the microseconds per PWM cycle.
Set the variable _robotbitMicrosecsPerCycle to the
result in your startup code (after "initialize Robotbit").'
  initRobotbit
  '_setPWM' 8 0 1000
  local 'total' 0
  repeat 10 {
    waitUntil (not (digitalReadOp 15))
    waitUntil (digitalReadOp 15)
    local 'start' (microsOp)
    waitUntil (not (digitalReadOp 15))
    waitUntil (digitalReadOp 15)
    total += (((microsOp) - start) + 120)
  }
  return (total / 10)
}

to _robotbitAllOff {
  comment 'Writing to egisters 250-253 sets the PWM parameters
for all 16 channels at once. Here we turn them all off.
See the PCA9685 datasheet for technical details.'
  for i 4 {
    i2cSet 64 (249 + i) 0
  }
}

to '_setPWM' channel on off {
  comment 'Set the on and off time of the given PWM channel.
The I2C message is: <starting register address> <start time (2 bytes) <end time (2 bytes)>
The start and stop times (range 0-4096) are sent least significant byte first.
Usually the start time is zero and the end time determines the duty cycle.
'
  if (or (channel < 0) (channel > 15)) {return 0}
  local 'buf' ('[data:newByteArray]' 5)
  atPut 1 buf (6 + (4 * channel))
  atPut 2 buf (on & 255)
  atPut 3 buf ((on >> 8) & 255)
  atPut 4 buf (off & 255)
  atPut 5 buf ((off >> 8) & 255)
  '[sensors:i2cWrite]' 64 buf
}

to initRobotbit {
  comment 'Initialize the Kittenbot Robobit servo and motor board.
See the PCA9685 datasheet for technical details.'
  comment 'Enter sleep mode'
  i2cSet 64 0 (hexToInt '10')
  comment 'Set prescale register to generate 50 Hz'
  i2cSet 64 (hexToInt 'FE') (25000000 / (50 * 4096))
  _robotbitAllOff
  comment 'Start PWM again (with autoincrement enabled)'
  i2cSet 64 0 (hexToInt '20')
  comment 'Set the default calibration. This can be adjusted by for a specific
Robotbit by running "_compute microsecs per cycle" block, then
setting _robotbitMicrosecsPerCycle to the number it returns.'
  _robotbitMicrosecsPerCycle = 20000
}

to setRobobitServoAngle servo degrees {
  if (or (servo < 1) (servo > 8)) {return 0}
  degrees = (maximum -100 (minimum degrees 100))
  local 'usecs' (1500 + ((500 * degrees) / 90))
  '_setPWM' (servo + 7) 0 ((usecs * 4096) / _robotbitMicrosecsPerCycle)
}

to setRobotbitMotor motor speed {
  if (or (motor < 1) (motor > 4)) {return 0}
  speed = (maximum -100 (minimum speed 100))
  local 'plusPin' (2 * (motor - 1))
  local 'minusPin' (plusPin + 1)
  local 'pwmSteps' ((4095 * speed) / 100)
  if (pwmSteps < 0) {
    '_setPWM' plusPin 0 0
    '_setPWM' minusPin 0 (absoluteValue pwmSteps)
  } else {
    '_setPWM' plusPin 0 pwmSteps
    '_setPWM' minusPin 0 0
  }
}

to setRobotbitServoSpeed servo speed {
  if (or (servo < 1) (servo > 8)) {return 0}
  speed = (maximum -120 (minimum speed 120))
  if (speed == 0) {
    '_setPWM' (servo + 7) 0 0 // turn off PWM
    return
  }
  local 'usecs' (1500 + (6 * speed))
  '_setPWM' (servo + 7) 0 ((usecs * 4096) / _robotbitMicrosecsPerCycle)
}

module 'Sphero-RVR' Output
author wwj718
version 1 0 
choices leftModeMenu Forward Backward Off 
choices rightModeMenu Forward Backward Off 
description 'Controls a Sphero RVR Robot via a serial port.

Works on the micro:bit v2 and most other boards
but not the micro:bit v1 because that board lacks
a second hardware serial port.'
variables my_bytes _led_list _rvr_started 

	spec ' ' 'wake' 'wake'
	spec ' ' 'sleep' 'sleep'
	spec ' ' 'reset yaw' 'reset the yaw'
	spec ' ' 'drive with speed' 'drive with speed _ and heading _' 'auto auto' 0 0
	spec ' ' 'set raw motors with left mode' 'set raw motors with left mode _ left speed _ right mode _ right speed _' 'menu.leftModeMenu auto menu.rightModeMenu auto' 'Forward' 0 'Forward' 0
	spec ' ' 'stop' 'stop with heading _' 'auto' '10'
	spec ' ' 'set RGB LED' 'set RGB LED _ to red _ green _ blue _' 'auto auto auto auto' 1 0 0 0
	spec ' ' 'set_all_leds' 'set all LEDs to red _ green _ blue _' 'auto auto auto' 0 0 0
	spec ' ' '_start_rvr' '_start_rvr'

to '_start_rvr' {
  if (_rvr_started == 0) {
    '[serial:open]' 115200
    _rvr_started = 1
    _led_list = ('[data:makeList]' ('[data:makeList]' (hexToInt '00') (hexToInt '00') (hexToInt '00') (hexToInt '07')) ('[data:makeList]' (hexToInt '00') (hexToInt '00') (hexToInt '00') (hexToInt '38')) ('[data:makeList]' (hexToInt '00') (hexToInt '00') (hexToInt '01') (hexToInt 'c0')) ('[data:makeList]' (hexToInt '00') (hexToInt '00') (hexToInt '0e') (hexToInt '00')) ('[data:makeList]' (hexToInt '00') (hexToInt '03') (hexToInt '80') (hexToInt '00')) ('[data:makeList]' (hexToInt '00') (hexToInt '00') (hexToInt '70') (hexToInt '00')) ('[data:makeList]' (hexToInt '00') (hexToInt '1c') (hexToInt '00') (hexToInt '00')) ('[data:makeList]' (hexToInt '00') (hexToInt 'e0') (hexToInt '00') (hexToInt '00')) ('[data:makeList]' (hexToInt '07') (hexToInt '00') (hexToInt '00') (hexToInt '00')) ('[data:makeList]' (hexToInt '38') (hexToInt '00') (hexToInt '00') (hexToInt '00')))
  }
}

to 'drive with speed' speed heading {
  '_start_rvr'
  local 'flags' (hexToInt '00')
  if (speed < 0) {
    speed = (-1 * speed)
    heading = ((180 + heading) % 360)
    flags = (hexToInt '01')
  }
  local 'drive_data' ('[data:makeList]' (hexToInt '8d') (hexToInt '3e') (hexToInt '12') (hexToInt '01') (hexToInt '16') (hexToInt '07') (hexToInt '00') speed (heading >> 8) (heading & (hexToInt 'ff')) flags)
  local 'sum' 0
  for i (size drive_data) {
    sum = (sum + (at i drive_data))
  }
  '[data:addLast]' (('~' ((sum - (hexToInt '8d')) % 256)) & (hexToInt '00ff')) drive_data
  '[data:addLast]' (hexToInt 'd8') drive_data
  '[serial:write]' ('[data:asByteArray]' drive_data)
}

to 'reset yaw' {
  '_start_rvr'
  local 'drive_data' ('[data:makeList]' (hexToInt '8d') (hexToInt '3e') (hexToInt '12') (hexToInt '01') (hexToInt '16') (hexToInt '06') (hexToInt '00'))
  local 'sum' 0
  for i (size drive_data) {
    sum = (sum + (at i drive_data))
  }
  '[data:addLast]' (('~' ((sum - (hexToInt '8d')) % 256)) & (hexToInt '00ff')) drive_data
  '[data:addLast]' (hexToInt 'd8') drive_data
  '[serial:write]' ('[data:asByteArray]' drive_data)
}

to 'set RGB LED' led_index red green blue {
  '_start_rvr'
  comment 'led index

1    RIGHT_HEADLIGHT = [0x00, 0x00, 0x00, 0x07]
2    LEFT_HEADLIGHT = [0x00, 0x00, 0x00, 0x38]
3    LEFT_STATUS = [0x00, 0x00, 0x01, 0xC0]
4    RIGHT_STATUS = [0x00, 0x00, 0x0E, 0x00]
5    BATTERY_DOOR_FRONT = [0x00, 0x03, 0x80, 0x00]
6    BATTERY_DOOR_REAR = [0x00, 0x00, 0x70, 0x00]
7    POWER_BUTTON_FRONT = [0x00, 0x1C, 0x00, 0x00]
8    POWER_BUTTON_REAR = [0x00, 0xE0, 0x00, 0x00]
9    LEFT_BRAKELIGHT = [0x07, 0x00, 0x00, 0x00]
10    RIGHT_BRAKELIGHT = [0x38, 0x00, 0x00, 0x00]'
  if (or (led_index < 1) (led_index > 10)) {
    led_index = 1
  }
  local 'led_data' ('[data:makeList]' (hexToInt '8d') (hexToInt '3e') (hexToInt '11') (hexToInt '01') (hexToInt '1a') (hexToInt '1a') (hexToInt '00'))
  for i (size (at led_index _led_list)) {
    '[data:addLast]' (at i (at led_index _led_list)) led_data
  }
  '[data:addLast]' red led_data
  '[data:addLast]' green led_data
  '[data:addLast]' blue led_data
  local 'sum' 0
  for i (size led_data) {
    sum = (sum + (at i led_data))
  }
  '[data:addLast]' (('~' ((sum - (hexToInt '8d')) % 256)) & (hexToInt '00ff')) led_data
  '[data:addLast]' (hexToInt 'd8') led_data
  '[serial:write]' ('[data:asByteArray]' led_data)
}

to 'set raw motors with left mode' left_mode left_speed right_mode right_speed {
  '_start_rvr'
  comment 'mode 0 off 1 forward 2 backward'
  if (left_mode == 'Forward') {
    left_mode = 1
  }
  if (left_mode == 'Backward') {
    left_mode = 2
  }
  if (left_mode == 'Off') {
    left_mode = 0
  }
  if (right_mode == 'Forward') {
    right_mode = 1
  }
  if (right_mode == 'Backward') {
    right_mode = 2
  }
  if (right_mode == 'Off') {
    right_mode = 0
  }
  local 'raw_motor_data' ('[data:makeList]' (hexToInt '8d') (hexToInt '3e') (hexToInt '12') (hexToInt '01') (hexToInt '16') (hexToInt '01') (hexToInt '00') left_mode left_speed right_mode right_speed)
  local 'sum' 0
  for i (size raw_motor_data) {
    sum = (sum + (at i raw_motor_data))
  }
  '[data:addLast]' (('~' ((sum - (hexToInt '8d')) % 256)) & (hexToInt '00ff')) raw_motor_data
  '[data:addLast]' (hexToInt 'd8') raw_motor_data
  '[serial:write]' ('[data:asByteArray]' raw_motor_data)
}

to set_all_leds red green blue {
  '_start_rvr'
  local 'led_data' ('[data:makeList]' (hexToInt '8d') (hexToInt '3e') (hexToInt '11') (hexToInt '01') (hexToInt '1a') (hexToInt '1a') (hexToInt '00') (hexToInt '3f') (hexToInt 'ff') (hexToInt 'ff') (hexToInt 'ff'))
  repeat 10 {
    '[data:addLast]' red led_data
    '[data:addLast]' green led_data
    '[data:addLast]' blue led_data
  }
  local 'sum' 0
  for i (size led_data) {
    sum = (sum + (at i led_data))
  }
  '[data:addLast]' (('~' ((sum - (hexToInt '8d')) % 256)) & (hexToInt '00ff')) led_data
  '[data:addLast]' (hexToInt 'd8') led_data
  '[serial:write]' ('[data:asByteArray]' led_data)
}

to sleep {
  '_start_rvr'
  local 'cmd' ('[data:makeList]' (hexToInt '8d') (hexToInt '3e') (hexToInt '11') (hexToInt '01') (hexToInt '13') (hexToInt '01') (hexToInt '00') (hexToInt '9b') (hexToInt 'd8'))
  '[serial:write]' ('[data:asByteArray]' cmd)
}

to stop heading {
  'drive with speed' 0 heading
}

to wake {
  '_start_rvr'
  local 'cmd' ('[data:makeList]' (hexToInt '8d') (hexToInt '3e') (hexToInt '11') (hexToInt '01') (hexToInt '13') (hexToInt '0d') (hexToInt '00') (hexToInt '8f') (hexToInt 'd8'))
  '[serial:write]' ('[data:asByteArray]' cmd)
}

module databot
author MicroBlocks
version 1 4 
depends 'Air Pressure (LPS22HB)' 'Gas (SGP30)' 'Temperature Humidity (SHTC3)' 'Light & Gesture (APDS9960)' 
choices databot_tempUnits 'Â°C' 'Â°F' 
description ''
variables _databot_pixels 

  spec ' ' 'databot_beep' 'databot beep'
  space
  spec ' ' 'databot_setAllLEDs' 'databot set all LEDs color _' 'color'
  spec ' ' 'databot_setLED' 'databot set LED _ color _' 'num color' 1
  spec 'r' 'databot_RGB' 'color r _ g _ b _ (0-255)' 'num num num' 100 0 100
  space
  spec 'r' 'databot_light' 'databot light level'
  space
  spec 'r' 'databot_tilt_x' 'databot tilt x'
  spec 'r' 'databot_tilt_y' 'databot tilt y'
  spec 'r' 'databot_tilt_z' 'databot tilt z'
  spec 'r' 'databot_acceleration' 'databot acceleration'
  space
  spec 'r' 'databot_temperature' 'databot temperature _' 'menu.databot_tempUnits' 'Â°C'
  spec 'r' 'databot_relative_humidity' 'databot relative humidity (%)'
  spec 'r' 'databot_uvIndex' 'databot UV Index (x10)'
  space
  spec 'r' 'databot_temp_probe1' 'databot temp probe 1 _ (x10)' 'menu.databot_tempUnits' 'Â°C'
  spec 'r' 'databot_temp_probe2' 'databot temp probe 2 _ (x10)' 'menu.databot_tempUnits' 'Â°C'
  space
  spec 'r' 'databot_magnetic_field' 'databot magenetic field'
  space
  spec ' ' '_databot_initLEDs' '_databot_initLEDs'
  spec 'r' '_databot_DS18B20_address' '_databot_DS18B20_address pin _' 'num' 4
  spec 'r' '_databot_raw_temperature' '_databot_raw_temperature pin _' 'num' 4

to '_databot_DS18B20_address' pin {
  '[1wire:init]' pin
  '[1wire:scanStart]'
  waitMillis 10
  local 'addr' ('[data:newByteArray]' 8)
  if (not ('[1wire:scanNext]' addr)) {
    comment 'No response; temperature probe not plugged in?'
    return 0
  }
  local 'family' (at 1 addr)
  if (not (or (family == 34) (or (family == 40) (family == 66)))) {
    comment 'Device is not a DS1822, DS18B20, or DS28EA00 temperature sensor'
    return 0
  }
  return addr
}

to '_databot_initLEDs' {
  '[display:neoPixelSetPin]' -1 false
  if (not (isType _databot_pixels 'list')) {
    _databot_pixels = (newList 3)
  }
}

to '_databot_raw_temperature' pin {
  comment 'Read the raw temperature. This function waits
a full second fo the temperature sensor to
measure the temperature, so it is best called
from a dedicated task.'
  local 'addr' ('_databot_DS18B20_address' pin)
  if (addr == 0) {
    sayIt 'Temperature probe not plugged in?'
    waitMillis 2000
    return 0
  }
  '[1wire:select]' addr
  '[1wire:writeByte]' (hexToInt '44') true
  waitMillis 1
  '[1wire:select]' addr
  '[1wire:writeByte]' (hexToInt 'BE')
  local 'data' ('[data:newByteArray]' 9)
  for i 9 {
    atPut i data ('[1wire:readByte]')
  }
  if (('[1wire:crc8]' data) != 0) {
    sayIt 'Bad temperature CRC'
    return 0
  }
  local 'result' (((at 2 data) << 8) | (at 1 data))
  if (result >= 32768) {
    comment 'Sign-extend 16-bit negative number'
    result = (result - 65536)
  }
  return result
}

to databot_RGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to databot_acceleration {
  return ('[sensors:acceleration]')
}

to databot_beep {
  '[io:playTone]' -1 440
  waitMillis 100
  '[io:playTone]' -1 0
}

to databot_light {
  return (apds9960_light)
}

to databot_magnetic_field {
  return ('[sensors:magneticField]')
}

to databot_relative_humidity {
  return (shtc3_humidity)
}

to databot_setAllLEDs color {
  '_databot_initLEDs'
  atPut 'all' _databot_pixels color
  '[display:neoPixelSend]' _databot_pixels
  waitMicros 150
}

to databot_setLED index color {
  '_databot_initLEDs'
  if (and (1 <= index) (index <= 3)) {
    if (3 == index) {
      index = 2
    } (2 == index) {
      index = 3
    }
    atPut index _databot_pixels color
    '[display:neoPixelSend]' _databot_pixels
    waitMicros 150
  }
}

to databot_temp_probe1 unit {
  local 'raw' ('_databot_raw_temperature' 4)
  if ('Â°F' == unit) {
    return ((((10 * 9) * raw) / (16 * 5)) + 320)
  } else {
    return ((10 * raw) / 16)
  }
}

to databot_temp_probe2 unit {
  local 'raw' ('_databot_raw_temperature' 23)
  if ('Â°F' == unit) {
    return ((((10 * 9) * raw) / (16 * 5)) + 320)
  } else {
    return ((10 * raw) / 16)
  }
}

to databot_temperature units {
  if (units == 'Â°C') {
    return (shtc3_temperature)
  } else {
    return (32 + (9 * ((shtc3_temperature) / 5)))
  }
}

to databot_tilt_x {
  return ('[sensors:tiltX]')
}

to databot_tilt_y {
  return ('[sensors:tiltY]')
}

to databot_tilt_z {
  return ('[sensors:tiltZ]')
}

to databot_uvIndex {
  local 'millivolts' ((3300 * (analogReadOp 34)) / 1023)
  if (millivolts < 200) {
    return 0
  }
  return ((millivolts - 132) / 94)
}

module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '_set display color' 'set display color _' 'color'
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  space
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}

to '_set display color' color {
  callCustomCommand '[display:mbSetColor]' ('[data:makeList]' color)
}
module NeoPixel Output
author MicroBlocks
version 1 6 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if ((boardType) == 'M5Atom-Matrix') {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'Mbits') {
    neoPixelAttach 25 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'r' ((rgb >> 16) & 255)
    local 'g' ((rgb >> 8) & 255)
    local 'b' (rgb & 255)
    local 'brightness' (maximum r g b)
    if (delta > 0) {
      delta = (minimum delta (255 - brightness))
    } else {
      delta = (maximum delta (42 - brightness))
    }
    r = (maximum 0 (minimum (r + delta) 255))
    g = (maximum 0 (minimum (g + delta) 255))
    b = (maximum 0 (minimum (b + delta) 255))
    atPut i _np_pixels (colorFromRGB r g b)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_update' {
  '[display:neoPixelSend]' _np_pixels
  waitMicros 100
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  hasWhite = false
  if ((pushArgCount) > 2) {
    hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  fillList _np_pixels 0
  '[display:neoPixelSetPin]' pinNumber hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels color
  '_NeoPixel_update'
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' (n > 0)
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}

module 'HTTP client' Comm
author MicroBlocks
version 1 4 
depends WiFi 
tags http network get post put delete 
choices requestTypes GET POST PUT DELETE
description 'Send HTTP requests and get responses back. You can use this library to fetch or store data in online servers, or to control other Wifi-enabled boards.
'

	spec 'r' '_http_body_start' '_http_body_start _' 'auto' ''
	spec 'r' '_http_header_text' '_http_header_text _' 'auto' ''
	spec 'r' '_http_status_text' '_http_status_text _' 'auto' ''
	spec 'r' '_http_header' '_header _ of response _' 'auto auto' 'content-length' ''
	spec 'r' '_http_status' '_status of response _' 'auto' ''
	spec 'r' '_line_end' '_line_end'
	spec 'r' '_lowercase' '_lowercase _' 'auto' 'ABC Def gH'
	spec 'r' '_request_url' '_request_url _ method _ body _ :port _' 'str menu.requestTypes str num' '' 'GET' '' 80
	spec 'r' '_readHTTPResponse' '_readHTTPResponse'
	spec 'r' 'httpÜ//' 'httpÜ// _ :port _' 'auto num' 'microblocks.fun/example.txt' 80
	spec ' ' 'request' '_ data _ to httpÜ// _ :port _' 'menu.requestTypes str str num' 'POST' 'MicroBlocks is fun' 'microblocks.fun' 80

to '_http_body_start' response {
  return (('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) response) + 4)
}

to '_http_header' header response {
  local 'header text' ('_http_header_text' response)
  header = ('_lowercase' header)
  repeatUntil ((size (v 'header text')) < 3) {
    local 'key' ('[data:copyFromTo]' (v 'header text') 1 (('[data:find]' ':' (v 'header text')) - 1))
    if (('_lowercase' key) == header) {
      return ('[data:copyFromTo]' (v 'header text') (('[data:find]' ':' (v 'header text')) + 2) (('[data:find]' ('_line_end') (v 'header text')) - 1))
    }
    'header text' = ('[data:copyFromTo]' (v 'header text') (('[data:find]' ('_line_end') (v 'header text')) + 2))
  }
  return (booleanConstant false)
}

to '_http_header_text' response {
  local 'headersStart' (('[data:find]' ('_line_end') response) + 2)
  return ('[data:copyFromTo]' response headersStart (('_http_body_start' response) + 2))
}

to '_http_status' response {
  return (('[data:copyFromTo]' ('_http_status_text' response) 1 4) + 0)
}

to '_http_status_text' response {
  return ('[data:copyFromTo]' response ('[data:find]' ' ' response) ('[data:find]' ('_line_end') response))
}

to '_line_end' {
  return ('[data:unicodeString]' ('[data:makeList]' 13 10))
}

to '_lowercase' string {
  local 'lowercased' ''
  local 'char code' ''
  for c (size string) {
    'char code' = ('[data:unicodeAt]' c string)
    if (and ((v 'char code') >= 65) ((v 'char code') <= 90)) {
      'char code' = ((v 'char code') + 32)
    }
    lowercased = ('[data:join]' lowercased ('[data:unicodeString]' (v 'char code')))
  }
  return lowercased
}

to '_readHTTPResponse' {
  local 'response' ''
  local 'lastChunkTime' (millisOp)
  repeatUntil (not ('[net:httpIsConnected]')) {
    local 'chunk' ('[net:httpResponse]')
    if ((size chunk) > 0) {
      response = ('[data:join]' response chunk)
      lastChunkTime = (millisOp)
    } (((millisOp) - lastChunkTime) > 10000) {
      return response
    }
    waitMillis 20
  }
  response = ('[data:join]' response ('[net:httpResponse]'))
  return response
}

to '_request_url' url method body optionalPort {
  local 'port' 80
  if ((pushArgCount) > 3) {
    port = optionalPort
  }
  local 'host' ''
  local 'path' ''
  local 'slashPosition' ('[data:find]' '/' url)
  if (slashPosition > 0) {
    host = ('[data:copyFromTo]' url 1 (slashPosition - 1))
    path = ('[data:copyFromTo]' url (slashPosition + 1))
  } else {
    host = url
  }
  if (('[net:wifiStatus]') != 'Connected') {
    return ('[data:join]' '0 Not Connected' ('_line_end'))
  }
  '[net:httpConnect]' host port
  if (not ('[net:httpIsConnected]')) {
    return ('[data:join]' '0 Could not connect to server' ('_line_end'))
  }
  '[net:httpRequest]' method host path
  return ('_readHTTPResponse')
}

to 'httpÜ//' url optionalPort {
  local 'port' 80
  if ((pushArgCount) > 1) {
    port = optionalPort
  }
  local 'response' ('_request_url' url 'GET' '' port)
  if (response != '') {
    if (('_http_status' response) == 200) {
      return ('[data:copyFromTo]' response ('_http_body_start' response))
    } else {
      return ('_http_status_text' response)
    }
  } else {
    return 'Failed to get response'
  }
}

to request method data url optionalPort {
  local 'port' 80
  if ((pushArgCount) > 3) {
    port = optionalPort
  }
  local 'response' ('_request_url' url method data port)
  if (response != '') {
    local 'status' ('_http_status' response)
    local 'body start' ('_http_body_start' response)
    if (and (200 == status) ((v 'body start') > 0)) {
      sayIt ('[data:copyFromTo]' response (v 'body start'))
    } else {
      sayIt ('_http_status_text' response)
    }
  } else {
    sayIt 'Failed to get response'
  }
}

module 'HTTP server' Comm
author MicroBlocks
version 1 3
depends WiFi
tags http network
description 'Create an HTTP server in MicroBlocks. You can use this library to allow remote control for your Wifi-enabled board.'

	spec 'r' '[net:httpServerGetRequest]' 'HTTP server request : binary data _ : port _' 'bool num' false 8080
	spec 'r' 'request method' 'method of request _' 'str' ''
	spec 'r' 'path of request' 'path of request _' 'str' ''
	spec 'r' 'headers of request' 'headers of request _' 'str' ''
	spec 'r' 'body of request' 'body of request _' 'str' ''
	spec 'r' 'content length of request' 'content length of request _' 'str' ''
	spec ' ' '[net:respondToHttpRequest]' 'respond _ to HTTP request : with body _ : and headers _ : keepAlive _' 'str str str bool' '200 OK' 'Welcome to the MicroBlocks HTTP server' 'Content-Type: text/plain' false
	spec 'r' '_endOfHeaders' '_end of headers _' 'str'
	spec 'r' '_toString' '_toString _' 'auto' 'abc'

to 'body of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('[data:copyFromTo]' request (i + 4))
}

to 'content length of request' request {
  local 'i' ('_endOfHeaders' request)
  if (i < 0) {
    return 0
  }
  local 'j' ('[data:find]' 'Content-Length: ' request)
  if (j < 0) {
    comment 'Try alternate capitalization'
    j = ('[data:find]' 'Content-length: ' request)
  }
  if (or (j < 0) (j > i)) {
    return 0
  }
  j += 16
  local 'k' ('[data:find]' ('[data:unicodeString]' 13) request j)
  return (('[data:copyFromTo]' request j (k - 1)) + 0)
}

to 'headers of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('_toString' ('[data:copyFromTo]' request 1 (i - 1)))
}

to 'path of request' request {
  return ('_toString' ('[data:copyFromTo]' request (('[data:find]' ' ' request) + 1) (('[data:find]' ' HTTP' request) - 1)))
}

to 'request method' request {
  return ('_toString' ('[data:copyFromTo]' request 1 (('[data:find]' ' ' request) - 1)))
}

to '_endOfHeaders' request {
  return ('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) request)
}

to '_toString' aStringOrByteArray {
  comment 'If argument is a byte array, convert it to a string. '
  if (not (isType aStringOrByteArray 'string')) {
    aStringOrByteArray = ('[data:join]' '' aStringOrByteArray)
  }
  return aStringOrByteArray
}

module MQTT Comm
author wwj718
version 1 6 
depends WiFi 
tags mqtt network 
description 'A simple MQTT client.
'

  spec ' ' 'MQTT connect to' 'MQTT connect to broker _ : buffer sizes _ client id _ : username _ password _' 'str num str str str' '' 128 '' '' ''
  spec 'r' 'MQTT connected' 'MQTT connected'
  spec ' ' 'MQTT disconnect' 'MQTT disconnect'
  spec ' ' 'MQTT sub' 'MQTT sub _ : QoS _' 'str num' 'testTopic' 0
  spec ' ' 'MQTT unsub' 'MQTT unsub _' 'str' 'testTopic'
  spec ' ' 'MQTT pub' 'MQTT pub topic _ payload _ : retain _ QoS _' 'str auto bool num' 'testTopic' 'Hello!' false 0
  spec 'r' '[net:MQTTLastEvent]' 'MQTT event : binary _' 'bool' false
  spec 'r' 'MQTT event topic' 'topic for MQTT event _' 'str' ''
  spec 'r' 'MQTT event payload' 'payload for MQTT event _' 'str' ''
  spec ' ' '_MQTT set will' 'MQTT set will topic _ payload _ : retain _ QoS _: buffer sizes _' 'str auto bool num num' 'testWill' 'Last will!' false 0 128

to 'MQTT connect to' broker buffer_sizes client_id username password {
  if ((getIPAddress) != '0.0.0.0') {
    if ((pushArgCount) == 1) {
      callCustomCommand '[net:MQTTConnect]' ('[data:makeList]' broker 128 ('[net:myMAC]'))
    } ((pushArgCount) == 3) {
      callCustomCommand '[net:MQTTConnect]' ('[data:makeList]' broker buffer_sizes client_id)
    } else {
      callCustomCommand '[net:MQTTConnect]' ('[data:makeList]' broker buffer_sizes client_id username password)
    }
    if ('MQTT connected') {
      sayIt 'Connected!'
    } else {
      sayIt 'Not Connected'
    }
  } else {
    sayIt 'Not Connected'
  }
}

to 'MQTT connected' {
  return (callCustomReporter '[net:MQTTIsConnected]')
}

to 'MQTT disconnect' {
  callCustomCommand '[net:MQTTdisconnect]'
}

to 'MQTT event payload' event {
  if (and (isType event 'list') ((size event) > 1)) {
    comment 'Join to empty string converts byte array to string'
    return ('[data:join]' '' (at 2 event))
  } else {
    return ''
  }
}

to 'MQTT event topic' event {
  if (and (isType event 'list') ((size event) > 1)) {
    return (at 1 event)
  } else {
    return ''
  }
}

to 'MQTT pub' topic payload retain qos {
  if ((pushArgCount) < 4) {
    okay = (callCustomReporter '[net:MQTTPub]' ('[data:makeList]' topic payload))
  } else {
    okay = (callCustomReporter '[net:MQTTPub]' ('[data:makeList]' topic payload retain qos))
  }
  if (not okay) {
    sayIt 'pub failure!'
  }
}

to 'MQTT sub' topic qos {
  if ((pushArgCount) < 2) {
    okay = (callCustomReporter '[net:MQTTSub]' ('[data:makeList]' topic))
  } else {
    okay = (callCustomReporter '[net:MQTTSub]' ('[data:makeList]' topic qos))
  }
  if (not okay) {
    sayIt 'sub failure!'
  }
}

to 'MQTT unsub' topic {
  if ((callCustomReporter '[net:MQTTUnsub]' ('[data:makeList]' topic)) != (booleanConstant true)) {sayIt 'unsub failure!'}
}


to '_MQTT set will' topic payload retain qos buffer_sizes {
  if ('MQTT connected') {
      sayIt 'set will has to be called before calling connect'
      return ''
    }
  if ((pushArgCount) < 4) {
    okay = (callCustomReporter '[net:MQTTSetWill]' ('[data:makeList]' topic payload))
  } ((pushArgCount) == 4) {
    okay = (callCustomReporter '[net:MQTTSetWill]' ('[data:makeList]' topic payload retain qos))
  } else {
    okay = (callCustomReporter '[net:MQTTSetWill]' ('[data:makeList]' topic payload retain qos buffer_sizes))
  }
  if (not okay) {
    sayIt 'set will failure!'
  }
}
module OctoStudio Comm
author wwj718
version 1 3 
choices shape_choices triangle circle square heart star 
description 'Communicate with OctoStudio (https://octostudio.org/)'
variables _OctoAdvertising 

  spec ' ' 'Octo start' 'Octo start'
  spec ' ' 'beam to phones' 'Octo beam to phones _ : duration _ ms' 'menu.shape_choices num' 'heart' 200
  spec 'r' 'Octo receive beam' 'Octo receive beam'
  spec ' ' 'Octo stop' 'Octo stop'
  spec 'r' '_generate_full_shape_id' '_generate_full_shape_id shape _' 'auto' 'heart'
  spec ' ' '_Octo deinit' '_Octo deinit'
  spec 'r' '_shape_map' '_shape_map'

to 'Octo receive beam' {
  local 'shape_id' (callCustomReporter '[net:OctoGetOctoShapeId]')
  if (shape_id != (booleanConstant false)) {
    for s ('_shape_map') {
      if ((at 2 s) == shape_id) {return (at 1 s)}
    }
  } else {
    return (booleanConstant false)
  }
}

to 'Octo start' {
  if (not (callCustomReporter '[net:OctoGetBLEInitialized]')) {callCustomCommand '[net:OctoInitBLE]'}
  if (not (callCustomReporter '[net:OctoScanning]')) {callCustomCommand '[net:OctoStartScanning]'}
}

to 'Octo stop' {
  if (callCustomReporter '[net:OctoScanning]') {callCustomCommand '[net:OctoStopScanning]'}
}

to '_Octo deinit' {
  callCustomCommand '[net:OctoDeinitBLE]'
}

to '_generate_full_shape_id' shape_name {
  comment 'Mimic iOS, eg: ECA7059C00000001'
  local 'full_shap_id' ('[data:makeList]')
  repeat 8 {
    '[data:addLast]' (at 'random' '0123456789ABCDEF') full_shap_id
  }
  for s ('_shape_map') {
    if ((at 1 s) == shape_name) {
      repeat 7 {
        '[data:addLast]' 0 full_shap_id
      }
      '[data:addLast]' (at 2 s) full_shap_id
      return ('[data:joinStrings]' full_shap_id)
    }
  }
  return 'This shape does not exist'
}

to '_shape_map' {
  comment '"0": "circle",
"1": "square",
"2": "star",
"3": "heart",
"4": "triangle",'
  return ('[data:makeList]' ('[data:makeList]' 'circle' 0) ('[data:makeList]' 'square' 1) ('[data:makeList]' 'star' 2) ('[data:makeList]' 'heart' 3) ('[data:makeList]' 'triangle' 4))
}

to 'beam to phones' shape optionalDuration {
  local 'duration' 200
  if ((pushArgCount) > 1) {
    duration = optionalDuration
  }
  if (callCustomReporter '[net:OctoGetBLEInitialized]') {
    if (_OctoAdvertising == 1) {
      sayIt 'waiting...'
      waitUntil (_OctoAdvertising == 0)
      sayIt ''
    }
    _OctoAdvertising = 1
    callCustomCommand '[net:OctoSetDeviceName]' ('[data:makeList]' ('_generate_full_shape_id' shape))
    callCustomCommand '[net:OctoStartAdvertising]'
    waitMillis duration
    callCustomCommand '[net:OctoStopAdvertising]'
    _OctoAdvertising = 0
  } else {
    sayIt 'Please start Octo first'
  }
}

module UDP Comm
author MicroBlocks
version 1 0 
depends WiFi 
tags udp network 
description 'Blocks to send and receive UDP packets.'

  spec ' ' '[net:udpStart]' 'UDP start port _' 'auto' 5000
  spec ' ' '[net:udpStop]' 'UDP stop'
  spec ' ' '[net:udpSendPacket]' 'UDP send packet _ to ip _ port _' 'auto auto num' 'Hello!' '255.255.255.255' 5000
  spec 'r' '[net:udpReceivePacket]' 'UDP receive packet : binary data _' 'bool' false
  spec 'r' '[net:udpRemoteIPAddress]' 'UDP remote IP address'
  spec 'r' '[net:udpRemotePort]' 'UDP remote port'
module 'WebSocket server' Comm
author MicroBlocks
version 1 1 
tags websockets network 
description 'Blocks to build your own (very) simple websockets server. The websockets server runs on port 81.'

	spec ' ' 'start WebSocket server' 'start WebSocket server'
	spec 'r' '[net:webSocketLastEvent]' 'last WebSocket event'
	spec 'r' 'ws client id' 'client ID for WebSocket event _' 'str' ''
	spec 'r' 'ws event payload' 'payload for WebSocket event _' 'str' ''
	spec 'r' 'ws event type' 'type of WebSocket event _' 'str' ''
	spec ' ' '[net:webSocketSendToClient]' 'send _ to WebSocket client _' 'str num' 'Hello, Client!' 0

to 'start WebSocket server' {
  comment 'The websockets server runs on port 81.'
  if ((getIPAddress) != '0.0.0.0') {
    '[net:webSocketStart]'
  } else {
    sayIt 'Not Connected'
  }
}

to 'ws client id' event {
  if (and (isType event 'list') ((size event) > 1)) {
    return (at 2 event)
  } else {
    return ''
  }
}

to 'ws event payload' event {
  if (and (isType event 'list') ((size event) > 2)) {
    return (at 3 event)
  } else {
    return ''
  }
}

to 'ws event type' event {
  if (and (isType event 'list') ((size event) > 0)) {
    return (at ((at 1 event) + 1) ('[data:makeList]' 'error' 'disconnected' 'connected' 'text message' 'binary message' 'text fragment start' 'binary fragment start' 'fragment' 'fragment end' 'ping' 'pong' 'waiting'))
  } else {
    return ''
  }
}

module 'WebThings' Comm
author MicroBlocks
version 3 4 
depends 'HTTP server' WiFi 
tags iot webthing wot 
description 'Create WebThings as specified by the WebThings schema and protocol. If your board is WiFi enabled, you can serve its thing description directly via HTTP. Otherwise, you can enable the MicroBlocks add-on in the WebThings Gateway.
'
choices thingTypesMenu Alarm BinarySensor ColorControl ColorSensor DoorSensor EnergyMonitor LeakSensor Light Lock MotionSensor MultiLevelSensor MultiLevelSwitch OnOffSwitch PushButton SmartPlug TemperatureSensor Thermostat
choices thingEventTypesMenu OverheatedEvent PressedEvent DoublePressedEvent LongPressedEvent AlarmEvent
choices numberPropertyTypesMenu LevelProperty BrightnessProperty ColorTemperatureProperty InstantaneousPowerProperty CurrentProperty VoltageProperty FrequencyProperty TargetTemperatureProperty TemperatureProperty
choices booleanPropertyTypesMenu BooleanProperty OnOffProperty MotionProperty OpenProperty LeakProperty PushedProperty AlarmProperty
choices stringPropertyTypesMenu ColorProperty TextProperty HeatingCoolingProperty LockedProperty ThermostatModeProperty
variables _WoT_title _WoT_events _WoT_capability _WoT_event_defs _WoT_property_defs '_thing description' 

	spec ' ' 'set thing name to' 'set thing name to _' 'auto' 'MicroBlocks thing'
	spec ' ' 'set thing capability to' 'set thing capability to _' 'str.thingTypesMenu' 'Light'
	spec ' ' 'addBooleanProperty' 'set boolean property _ title _ @Type _ : read only _' 'menu.allVarsMenu str str.booleanPropertyTypesMenu bool' '' '' 'OnOffProperty' false
	spec ' ' 'addStringProperty' 'set string property _ title _ @Type _ : read only _' 'menu.allVarsMenu str str.stringPropertyTypesMenu bool' '' '' 'ColorProperty' false
	spec ' ' 'addNumProp' 'set number property _ title _ min _ max _ @Type _ : read only _' 'menu.allVarsMenu str num num str.numberPropertyTypesMenu bool' '' '' 0 100 'LevelProperty' false
	spec ' ' 'register event' 'register event _ type _' 'auto str.thingEventTypesMenu' 'Button A pressed' 'PressedEvent'
	spec ' ' 'start WebThing server' 'start WebThing server'
	spec ' ' 'trigger event' 'trigger event _' 'auto' 'button pressed'
	spec 'r' 'thing description JSON' 'thing description JSON'
	spec 'r' 'properties JSON' 'properties JSON'
	spec 'r' 'event definitions JSON' 'event definitions JSON'
	spec 'r' 'events JSON' 'events JSON'
	spec ' ' '_process OPTIONS request' '_process OPTIONS request _' 'auto' ''
	spec ' ' '_process PUT request' '_process PUT request _' 'auto' ''
	spec ' ' '_process request' '_process GET request _' 'auto' ''
	spec ' ' '_respond 404 Not Found' '_respond 404 Not Found'
	spec 'r' '_JSON value' '_JSON value _' 'auto' '10'
	spec 'r' '_parse JSON value' '_parse JSON value _' 'auto' ''
	spec 'r' '_trimmed' '_trimmed _' 'auto' '  hello    '
	spec ' ' '_WoT_start_server' '_WoT_start_server'
	spec 'r' '_type of' '_type of _' 'auto' '10'
	spec ' ' '_add or replace property' '_add or replace property _ attributes _' 'menu.nil str' '' ''
	spec ' ' '_clear thing description' '_clear thing description'
	spec 'r' '_varNames' '_varNames'

to '_JSON value' value {
  local 'JSON value' ''
  if (isType value 'string') {
    'JSON value' = ('[data:join]' '"' value '"')
  } (isType value 'list') {
    'JSON value' = '['
    for item value {
      'JSON value' = ('[data:join]' (v 'JSON value') ('_JSON value' item) ',')
    }
    'JSON value' = ('[data:join]' ('[data:copyFromTo]' (v 'JSON value') 1 ((size (v 'JSON value')) - 1)) ']')
  } (isType value 'boolean') {
    if value {
      'JSON value' = 'true'
    } else {
      'JSON value' = 'false'
    }
  } else {
    'JSON value' = value
  }
  return (v 'JSON value')
}

to '_WoT_start_server' {
  local 'request' ''
  forever {
    request = ('[net:httpServerGetRequest]')
    if (request != '') {
      if (('request method' request) == 'GET') {
        '_process request' request
      } (('request method' request) == 'PUT') {
        '_process PUT request' request
      } (('request method' request) == 'OPTIONS') {
        '_process OPTIONS request' request
      } else {
        '_respond 404 Not Found'
      }
    }
    waitMillis 50
  }
}

to '_add or replace property' varName 'attributes JSON' {
  if (_WoT_property_defs == 0) {_WoT_property_defs = ('[data:makeList]')}
  for def _WoT_property_defs {
    if ((at 1 def) == varName) {
      atPut 2 def (v 'attributes JSON')
      return ''
    }
  }
  '[data:addLast]' ('[data:makeList]' varName (v 'attributes JSON')) _WoT_property_defs
}

to '_clear thing description' {
  '_thing description' = 0
}

to '_parse JSON value' JSON {
  local 'value' ('_trimmed' JSON)
  if ((at 1 value) == '[') {
    comment 'Doesn''t handle multi-dimensional lists'
    local 'list' ('[data:makeList]')
    value = ('[data:copyFromTo]' value 2 ((size value) - 1))
    local 'comma index' ('[data:find]' ',' value)
    repeatUntil ((v 'comma index') == -1) {
      '[data:addLast]' ('_parse JSON value' ('[data:copyFromTo]' value 1 ((v 'comma index') - 1))) list
      value = ('[data:copyFromTo]' value ((v 'comma index') + 1))
      'comma index' = ('[data:find]' ',' value)
    }
    '[data:addLast]' ('_parse JSON value' value) list
    value = list
  } else {
    value = ('[misc:jsonGet]' value '')
  }
  return value
}

to '_process OPTIONS request' req {
  local 'path' ('path of request' req)
  '[net:respondToHttpRequest]' '200 OK' '' 'Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: PUT, GET, OPTIONS
Access-Control-Allow-Headers: Content-Type'
}

to '_process PUT request' req {
  local 'path' ('path of request' req)
  if (('[data:find]' '/properties/' path) > 0) {
    local 'varName' ('[data:copyFromTo]' path 13)
    if ('[vars:varExists]' varName) {
      local 'body' ('body of request' req)
      '[vars:setVarNamed]' varName ('_parse JSON value' ('[data:copyFromTo]' body (('[data:find]' ':' body) + 1) (('[data:find]' '}' body) - 1)))
      '[net:respondToHttpRequest]' '200 OK' ('[data:join]' '{"' varName '":' ('_JSON value' ('[vars:varNamed]' varName)) '}') 'Content-Type: application/json'
    } else {
      '_respond 404 Not Found'
    }
  } else {
    '_respond 404 Not Found'
  }
}

to '_process request' req {
  local 'path' ('path of request' req)
  if (path == '/') {
    '[net:respondToHttpRequest]' '200 OK' ('thing description JSON') 'Content-Type: application/json'
  } (or (path == '/properties') (path == '/properties/')) {
    '[net:respondToHttpRequest]' '200 OK' ('properties JSON') 'Content-Type: application/json'
  } (('[data:find]' '/properties/' path) > 0) {
    local 'varName' ('[data:copyFromTo]' path 13)
    if ('[vars:varExists]' varName) {
      '[net:respondToHttpRequest]' '200 OK' ('[data:join]' '{"' varName '":' ('_JSON value' ('[vars:varNamed]' varName)) '}') 'Content-Type: application/json'
    } else {
      '_respond 404 Not Found'
    }
  } (or (path == '/events') (path == '/events/')) {
    '[net:respondToHttpRequest]' '200 OK' ('events JSON') 'Content-Type: application/json'
    _WoT_events = ('[data:makeList]')
  } else {
    '_respond 404 Not Found'
  }
}

to '_respond 404 Not Found' {
  '[net:respondToHttpRequest]' '404 Not Found' '{ "error":"Resource not found" }' 'Content-Type: application/json'
}

to '_trimmed' string {
  comment 'remove surrounding spaces'
  repeatUntil ((at 1 string) != ' ') {
    string = ('[data:copyFromTo]' string 2)
  }
  repeatUntil ((at 'last' string) != ' ') {
    string = ('[data:copyFromTo]' string 1 ((size string) - 1))
  }
  return string
}

to '_type of' value {
  if (isType value 'number') {
    return 'number'
  } (isType value 'list') {
    return 'array'
  } (isType value 'string') {
    return 'string'
  } (isType value 'boolean') {
    return 'boolean'
  }
  comment 'should never happen'
  return 'null'
}

to '_varNames' {
  local 'result' ('[data:makeList]')
  local 'count' ('[vars:varNameForIndex]' -1)
  for i count {
    local 'varName' ('[vars:varNameForIndex]' i)
    if (isType varName 'string') {
      '[data:addLast]' varName result
    }
  }
  return result
}

to addBooleanProperty varName title type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 3) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"boolean","@type":"' type '",' '"readOnly":' readonly)
}

to addNumProp varName title min max type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 5) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"number","@type":"' type '",' '"readOnly":' readonly ',"minimum":' min ',"maximum":' max)
}

to addStringProperty varName title type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 3) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"string","@type":"' type '",' '"readOnly":' readonly)
}

to 'event definitions JSON' {
  local 'JSON' '{'
  if (_WoT_event_defs == 0) {
    _WoT_event_defs = ('[data:makeList]')
  }
  for 'event def' _WoT_event_defs {
    JSON = ('[data:join]' JSON '"' (at 1 (v 'event def')) '":{"description":"MicroBlocks event","@type":"' (at 2 (v 'event def')) '"},')
  }
  if ((size JSON) > 1) {
    return ('[data:join]' ('[data:copyFromTo]' JSON 1 ((size JSON) - 1)) '}')
  } else {
    return '{}'
  }
}

to 'events JSON' {
  local 'JSON' '['
  for event _WoT_events {
    JSON = ('[data:join]' JSON '{"' (at 1 event) '":{"data":{"id":' (at 2 event) '}}},')
  }
  if ((size JSON) > 1) {
    return ('[data:join]' ('[data:copyFromTo]' JSON 1 ((size JSON) - 1)) ']')
  } else {
    return '[]'
  }
}

to 'properties JSON' {
  local 'JSON' '{'
  if (or (_WoT_property_defs == 0) ((size _WoT_property_defs) == 0)) {
    for varName ('_varNames') {
      if (not ((at 1 varName) == '_')) {
        local 'value' ('[vars:varNamed]' varName)
        JSON = ('[data:join]' JSON '"' varName '":{"title":"' varName '","type":"' ('_type of' value) '","links":[{"href":"/properties/' varName '"}],"@type":""},')
      }
    }
  } else {
    for 'property def' _WoT_property_defs {
      local 'varName' (at 1 (v 'property def'))
      JSON = ('[data:join]' JSON '"' varName '":{"links":[{"href":"/properties/' varName '"}],' (at 2 (v 'property def')) '},')
    }
  }
  if ((at 'last' JSON) == ',') {
    JSON = ('[data:copyFromTo]' JSON 1 ((size JSON) - 1))
  }
  return ('[data:join]' JSON '}')
}

to 'register event' 'event title' 'event type' {
  local 'event def' ('[data:makeList]' (v 'event title') (v 'event type'))
  if (_WoT_event_defs == 0) {
    _WoT_event_defs = ('[data:makeList]')
  }
  for def _WoT_event_defs {
    if ((at 1 def) == (v 'event title')) {
      atPut 2 def (v 'event type')
      return ''
    }
  }
  '[data:addLast]' (v 'event def') _WoT_event_defs
}

to 'set thing capability to' capability {
  _WoT_capability = capability
}

to 'set thing name to' title {
  _WoT_title = title
}

to 'start WebThing server' {
  if (_WoT_title == 0) {'set thing name to' 'MicroBlocks thing'}
  if (_WoT_capability == 0) {'set thing capability to' ''}
  if ('[net:hasWiFi]') {
    if (_WoT_events == 0) {_WoT_events = ('[data:makeList]')}
    sendBroadcast '_WoT_start_server'
  } else {
    '_thing description' = ('thing description JSON')
  }
}

to 'thing description JSON' {
  return ('[data:join]' '{"title":"' _WoT_title '","@context":"https://webthings.io/schemas/","@type":["' _WoT_capability '"],"links":[{"rel":"events","href":"/events"},{"rel":"properties","href":"/properties"}],"properties":' ('properties JSON') ',"events":' ('event definitions JSON') '}')
}

to 'trigger event' 'event name' {
  if ('[net:hasWiFi]') {
    '[data:addLast]' ('[data:makeList]' (v 'event name') (millisOp)) _WoT_events
  } else {
    sendBroadcast (v 'event name')
  }
}

module 'WiFi Radio' Comm
author MicroBlocks
version 1 1 
depends WiFi 
tags radio communication messaging network 
description 'This library supports easy message exchange among WiFi-enabled boards on the same network.

A message can contain a string, a number, or both. Messages are received by all boards in the same radio group as the sender.

This library is similar to the Radio library, but messages are sent via UDP over WiFi instead of the Nordic radio system. Since UDP supports larger packets, this library can send longer strings.

This library can only communicate with other boards that support WiFi; it cannot interoperate with Nordic-based boards like the micro:bit.
'
variables _wifiRadio_Started _wifiRadio_group _wifiRadio_lastNumber _wifiRadio_lastString 

  spec ' ' 'wifiRadio_sendNumber' 'wifi send number _' 'num' 123
  spec ' ' 'wifiRadio_sendString' 'wifi send string _' 'str' 'Hello!'
  spec ' ' 'wifiRadio_sendPair' 'wifi send pair _ = _' 'str num' 'light' 10
  space
  spec 'r' 'wifiRadio_messageReceived' 'wifi message received?'
  spec 'r' 'wifiRadio_receivedInteger' 'wifi last number'
  spec 'r' 'wifiRadio_receivedString' 'wifi last string'
  space
  spec ' ' 'wifiRadio_setGroup' 'wifi set group _ (0-255)' 'num' 0
  space
  spec ' ' '_wifiRadio_init' '_wifiRadio_init'

to '_wifiRadio_init' {
  comment 'Open WiFi Radio UDP port if necessary.'
  if (not _wifiRadio_Started) {
    '[net:udpStart]' 34567
    _wifiRadio_group = 0
    _wifiRadio_Started = true
  }
}

to wifiRadio_messageReceived {
  '_wifiRadio_init'
  local 'msg' ('[net:udpReceivePacket]' true)
  if ((size msg) < 8) {
    return (booleanConstant false)
  }
  if (not (and ((at 1 msg) == 77) (and ((at 2 msg) == 66) ((at 3 msg) == 82)))) {
    return (booleanConstant false)
  }
  if ((at 4 msg) != _wifiRadio_group) {
    return (booleanConstant false)
  }
  _wifiRadio_lastNumber = ((at 5 msg) | (((at 6 msg) << 8) | (((at 7 msg) << 16) | ((at 8 msg) << 24))))
  _wifiRadio_lastString = ('[data:join]' '' ('[data:copyFromTo]' msg 9))
  return (booleanConstant true)
}

to wifiRadio_receivedInteger {
  return _wifiRadio_lastNumber
}

to wifiRadio_receivedString {
  if (_wifiRadio_lastString == 0) {_wifiRadio_lastString = ''}
  return _wifiRadio_lastString
}

to wifiRadio_sendNumber n {
  wifiRadio_sendPair '' n
}

to wifiRadio_sendPair s n {
  '_wifiRadio_init'
  local 'msg' ('[data:newByteArray]' 8)
  comment 'MicroBlocks WiFi Radio message format:
  tag: ''MBR'' (3 bytes)
  group (1 byte)
  number, LSB (4 bytes)
  utf8 string datat (variable length)'
  atPut 1 msg 77
  atPut 2 msg 66
  atPut 3 msg 82
  atPut 4 msg _wifiRadio_group
  atPut 5 msg (n & 255)
  atPut 6 msg ((n >> 8) & 255)
  atPut 7 msg ((n >> 16) & 255)
  atPut 8 msg ((n >> 24) & 255)
  msg = ('[data:join]' msg ('[data:asByteArray]' s))
  comment 'Broadcast msg to the WiFi Radio port number on all boards on the WiFi network.'
  '[net:udpSendPacket]' msg '255.255.255.255' 34567
}

to wifiRadio_sendString s {
  wifiRadio_sendPair s 0
}

to wifiRadio_setGroup n {
  '_wifiRadio_init'
  _wifiRadio_group = n
}

module WiFi Comm
author MicroBlocks
version 1 6 
tags communication network 
description 'Connect to a WiFi network. Used in conjunction with other network libraries, such as HTTP client, HTTP server or Web Thing.
'

  spec ' ' 'wifiConnect' 'wifi connect to _ password _ : IP _ gateway _ subnet _' 'str str auto auto auto' 'Network_Name' '' '192.168.1.42' '192.168.1.1' '255.255.255.0'
  spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
  spec 'r' 'getIPAddress' 'IP address'
  spec 'r' '[net:myMAC]' 'MAC address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to wifiConnect ssid password fixedIP gatewayIP subnetIP {
  if (not ('[net:hasWiFi]')) {return}
  '[net:stopWiFi]'
  if ((pushArgCount) < 5) {
    '[net:startWiFi]' ssid password
  } else {
    '[net:startWiFi]' ssid password false fixedIP gatewayIP subnetIP
  }
  local 'startMSecs' (millisOp)
  repeatUntil (('[net:myIPAddress]') != '0.0.0.0') {
    comment 'Timeout after N seconds'
    if (((millisOp) - startMSecs) > 30000) {
      sayIt 'Could not connect'
      return 0
    }
    comment 'Slow blink while trying to connect'
    setUserLED true
    waitMillis 300
    setUserLED false
    waitMillis 300
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  if ('Connected' != ('[net:wifiStatus]')) {
    sayIt 'Could not create hotspot'
    return 0
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

module 'Camera' Input
author MicroBlocks
version 1 0
description 'Primitives for ESP32 Camera boards (e.g. Freenove ESP32-WROVER).'
choices camera_frameSize '320x240' '352x288' '640x480' '800x600' '1024x768' '1280x1024' '1600x1200'
choices camera_format 'jpeg' 'rgb565' 'grayscale'

	spec 'r' '[camera:hasCamera]'	'has camera'
	spec 'r' '[camera:takePhoto]'	'get camera image'
	spec ' ' '[camera:setSize]'		'set camera image size _' 'menu.camera_frameSize' '640x480'
	spec ' ' '[camera:setEncoding]'	'set camera format _ jpeg quality _ (0-100)' 'menu.camera_format num' 'jpeg' 100
module 'Circuit Playground'
author MicroBlocks
version 1 0
description 'Blocks to control speaker and slide switch in Circuit Playground Express boards.'
tags cpx slide switch speaker


	spec ' ' 'Circuit Playground set speaker' 'Circuit Playground set speaker _' 'bool' true
	spec 'r' 'Circuit Playground slide switch' 'Circuit Playground slide switch'

to 'Circuit Playground set speaker' onOff {
  digitalWriteOp 0 onOff
}

to 'Circuit Playground slide switch' {
  return (digitalReadOp 10)
}
module 'D1 Motor Shield' Output
author MicroBlocks
version 1 0 
choices d1_motor A B 
description 'Support for Wemos/Lolin D1 mini motor shield.
https://www.wemos.cc/en/latest/d1_mini_shield/motor.html'

  spec ' ' 'd1MotorControl' 'd1 motor _ power _' 'menu.d1_motor num' 'A' 50
  spec ' ' 'd1MotorStopAll' 'd1 stop all motors'
  spec ' ' '_d1MotorSetPower' '_d1MotorSetPower _ label _' 'num num' 0 100
  spec ' ' '_d1MotorSetPWMFrequency' '_d1MotorSetPWMFrequency'
  spec ' ' '_d1MotorSendCmd' '_d1MotorSendCmd _' 'num' 10

to '_d1MotorSendCmd' bytes {
  '[sensors:i2cWrite]' 48 bytes
  local 'result' (newList 1)
  '[sensors:i2cRead]' 48 result
}

to '_d1MotorSetPWMFrequency' {
  comment 'Set PWM frequency for both motors to 1000 Hz'
  local 'freq' 1000
  local 'cmd' (newList 5)
  atPut 1 cmd 5
  atPut 2 cmd 2
  atPut 3 cmd (freq & 255)
  atPut 4 cmd ((freq >> 8) & 255)
  atPut 5 cmd ((freq >> 16) & 255)
  '_d1MotorSendCmd' cmd
}

to '_d1MotorSetPower' motorNum power {
  comment 'motorNum: 0, 1, 2 (both)
Power: 0-100'
  '_d1MotorSetPWMFrequency'
  local 'pwr' (100 * (absoluteValue power))
  local 'cmd' (newList 4)
  atPut 1 cmd 6
  atPut 2 cmd motorNum
  atPut 3 cmd (pwr & 255)
  atPut 4 cmd ((pwr >> 8) & 255)
  '_d1MotorSendCmd' cmd
}

to d1MotorControl motor power {
  if ('A' == motor) {
    motorNum = 0
  } else {
    motorNum = 1
  }
  '_d1MotorSetPower' motorNum (absoluteValue power)
  if (power > 0) {
    comment 'Clockwise'
    '_d1MotorSendCmd' ('[data:makeList]' 4 motorNum 1)
  } (power < 0) {
    comment 'Counter clockwise'
    '_d1MotorSendCmd' ('[data:makeList]' 4 motorNum 2)
  } (power == 0) {
    comment 'Stop motor (brake)'
    '_d1MotorSendCmd' ('[data:makeList]' 4 motorNum 3)
  }
}

to d1MotorStopAll {
  d1MotorControl 'A' 0
  d1MotorControl 'B' 0
}

module DotStar Output
author MicroBlocks
version 1 0
description 'Control Adafruit DotStar RGB LED strips.'
tags led strip rgb string

variables '_DotStar brightness' '_DotStar clock pin' '_DotStar data pin' '_DotStar pixels'

	spec ' ' 'DotStar attach' 'attach _ DotStar LEDs to data pin _ clock pin _' 'auto auto auto' 1 5 6
	spec ' ' 'set all DotStars' 'set all DotStar LEDs to r _ g _ b _' 'auto auto auto' 0 0 0
	spec ' ' 'set DotStar LED' 'set DotStar LED _ to r _ g _ b _' 'auto auto auto auto' 1 60 0 255
	spec ' ' 'set DotStar brightness' 'set DotStar brightness _' 'auto' 31
	spec ' ' '_DotStar send byte' '_DotStar send byte _' 'auto any' 0
	spec ' ' '_update DotStar strip' '_update DotStar strip' 'any'

to 'DotStar attach' count dataPin clockPin {
  '_DotStar data pin' = dataPin
  '_DotStar clock pin' = clockPin
  '_DotStar brightness' = 31
  if (0 == (v '_DotStar pixels')) {
    '_DotStar pixels' = (newList count)
  }
  if (count != (size (v '_DotStar pixels'))) {
    '_DotStar pixels' = (newList count)
  }
}

to 'set all DotStars' r g b {
  for i (size (v '_DotStar pixels')) {
    atPut i (v '_DotStar pixels') (((r << 16) | (g << 8)) | b)
  }
  '_update DotStar strip'
}

to 'set DotStar LED' number r g b {
  atPut number (v '_DotStar pixels') (((r << 16) | (g << 8)) | b)
  '_update DotStar strip'
}

to 'set DotStar brightness' number {
  if (number > 31) {number = 31}
  if (number < 0) {number = 0}
  '_DotStar brightness' = number
  '_update DotStar strip'
}

to '_DotStar send byte' byte {
  printIt byte
  local 'mask' 128
  repeat 8 {
    digitalWriteOp (v '_DotStar data pin') ((byte & mask) != 0)
    digitalWriteOp (v '_DotStar clock pin') true
    digitalWriteOp (v '_DotStar clock pin') false
    mask = (mask >> 1)
  }
}

to '_update DotStar strip' {
  repeat 4 {
    '_DotStar send byte' 0
  }
  for pix (v '_DotStar pixels') {
    '_DotStar send byte' ((7 << 5) | (v '_DotStar brightness'))
    '_DotStar send byte' (pix & 255)
    '_DotStar send byte' ((pix >> 8) & 255)
    '_DotStar send byte' ((pix >> 16) & 255)
  }
  repeat 4 {
    '_DotStar send byte' 255
  }
}
module DrawBot Output
author 'MicroBlocks and JosÃ© GarcÃ­a'
version 2 3 
depends Servo Strings 
tags cnc protoneer drawbot plotter 
description 'Control CoreXY DrawBots that use the Protoneer CNC shield.'
variables _plotterDelay _plotterHeading _letters '_letter size' '_letter spacing' 

	spec ' ' '_plotter init' '_plotter init'
	spec ' ' '_plotter step A' '_plotter step A'
	spec ' ' '_plotter step B' '_plotter step B'
	spec ' ' '_plot letter' '_plot letter _' 'auto' 'A'
	spec ' ' '_plot commands' '_plot commands _' 'auto' 'p0,r4,m30,t90'
	spec ' ' '_create letters' '_create letters'
	spec ' ' '_create letters 1' '_create letters 1'
	spec ' ' '_create letters 2' '_create letters 2'
	spec ' ' '_create letters 3' '_create letters 3'
	spec ' ' '_read letters from file' '_read letters from file'
	spec ' ' 'plotter move' 'plotter move X _ Y _' 'auto auto' 1000 2000
	spec ' ' 'ploturtle move' 'plotter move _ steps' 'auto' '1000'
	spec ' ' 'ploturtle turnBy' 'plotter turn _ degrees' 'auto' 90
	spec ' ' 'ploturtle turnFraction' 'plotter turn _ / _ of circle' 'auto auto' 1 4
	spec ' ' 'ploturtle setHeading' 'plotter point in direction _' 'auto' 0
	spec ' ' 'plotter pen down' 'plotter pen down'
	spec ' ' 'plotter pen up' 'plotter pen up'
	spec ' ' 'plotter stop' 'plotter stop'
	spec ' ' 'set plotter speed to' 'set plotter speed to _ %' 'auto' 10
	spec ' ' 'plot text' 'plot text _ size _' 'auto auto' 'HELLO' 20

to '_create letters' {
  if ('[file:systemInfo]') {'_read letters from file'}
  if ((size letters) == 0) {
    callCustomCommand '_create letters 1'
    callCustomCommand '_create letters 2'
    callCustomCommand '_create letters 3'
  }
  if ((v '_letter size') == 0) {
    '_letter size' = 20
  }
  if ((v '_letter spacing') == 0) {
    '_letter spacing' = 12
  }
}

to '_create letters 1' {
  _letters = ('[data:makeList]' 'A:d,t-73,m52,t146,m26,t107,m15,t180,m15,t74,m26' 'B:d,t-90,m50,t90,m10,r8,m4,t18,u,m1,t18,m17,t180,d,m15,r9,m4,t18,m19,u,t180,m30' 'C:u,t-90,m17,d,m20,r10,t16,m4,u,t4,m20,d,m1,r10,t16,m4,m1,u,t124,m34' 'D:d,t-90,m50,t90,m4,r8,m4,t10,m8,r8,t10,m4,m4,u,t181,m30' 'E:d,t-90,m50,t90,m29,u,t140,m38,t220,d,m16,u,t122,m30,t238,d,m29,u,m1' 'F:d,t-90,m50,t90,m29,u,t140,m38,t220,d,m18,u,m12,t90,m26' 'G:u,t-90,m16,d,m22,r7,t20,m5,u,t20,m16,t90,d,m12,t180,m12,t90,m10,r8,t20,m5,u,t119,m35' 'H:d,t-90,m50,u,m-25,t90,d,m29,u,t-90,m25,t180,d,m50' 'I:u,m14,t-90,d,m50,u,t90,m16,t90,m50' 'J:u,m1,t-90,m12,d,t180,r8,t-20,m5,m33,u,t180,m50')
}

to '_create letters 2' {
  l2 = ('[data:makeList]' 'K:d,t-90,m50,m-22,t50,m32,u,t180,m25,d,t-88,m41' 'L:d,t-90,m50,t180,m50,t-90,m29' 'M:d,t-90,m50,t148,m31,t-120,m30,t152,m50' 'N:d,t-90,m50,t150,m58,u,t-150,m50,t180,d,m50' 'O:u,t-90,m32,d,r11,m4,t15,m22,r11,t15,m4,m18,u,t140,m47' 'P:d,t-90,m50,t90,m18,r9,t18,m4,m14,u,t220,m39' 'Q:u,t-90,m18,d,m20,r8,t20,m5,m20,r8,t20,m5,u,t121,m20,d,m15' 'R:d,t-90,m50,t90,m10,r8,m4,t18,t18,m18,m-18,t-115,m28' 'S:u,t-90,m12,t180,d,r5,t-22,m6,r3,t-30,m6,m14,r3,t30,m6,r3,t22,m6,t22,m5,u,t22,m38' 'T:u,m15,d,t-90,m50,u,t-90,m15,t180,d,m30,u,t90,m50')
  for i l2 {
    '[data:addLast]' i _letters
  }
}

to '_create letters 3' {
  l2 = ('[data:makeList]' 'U:u,t-90,m50,t180,d,m38,r8,t-20,m5,m33,u,t180,m50' 'V:u,t-90,m50,d,t162,m52,t-146,m51,u,t164,m49' 'W:u,t-90,m50,d,t172,m50,t-152,m24,t140,m24,t-152,m50,u,t172,m50' 'X:d,t-60,m57,u,t-120,m28,t-120,d,m57' 'Y:u,m15,d,t-90,m25,t-30,m28,m-28,t60,m28,u,t149,m49' 'Z:u,m1,t-90,m50,t90,d,m28,t120,m57,t-120,m29')
  for i l2 {
    '[data:addLast]' i _letters
  }
}

to '_plot commands' commands {
  local 'cmd list' ('[data:split]' commands ',')
  for i (size (v 'cmd list')) {
    local 'key' (at 1 (at i (v 'cmd list')))
    local 'value' ('[data:copyFromTo]' (at i (v 'cmd list')) 2)
    if (key == 'm') {
      'ploturtle move' (value * (v '_letter size'))
    }
    if (key == 'p') {
      'ploturtle setHeading' value
    }
    if (key == 't') {
      'ploturtle turnBy' (0 - value)
    }
    if (key == 'u') {
      'plotter pen up'
      waitMillis 100
    }
    if (key == 'd') {
      'plotter pen down'
    }
    if (key == 'r') {
      repeat value {
        comment ('[data:join]' (at (i + 1) (v 'cmd list')) ',' (at (i + 2) (v 'cmd list')))
        key = (at 1 (at (i + 1) (v 'cmd list')))
        value = ('[data:copyFromTo]' (at (i + 1) (v 'cmd list')) 2)
        if (key == 'm') {
          'ploturtle move' (value * (v '_letter size'))
        }
        if (key == 't') {
          'ploturtle turnBy' (0 - value)
        }
        key = (at 1 (at (i + 2) (v 'cmd list')))
        value = ('[data:copyFromTo]' (at (i + 2) (v 'cmd list')) 2)
        if (key == 'm') {
          'ploturtle move' (value * (v '_letter size'))
        }
        if (key == 't') {
          'ploturtle turnBy' (0 - value)
        }
      }
      i += 2
    }
  }
}

to '_plot letter' letter {
  if (letters == 0) {'_create letters'}
  local 'heading' _plotterHeading
  letter = (uppercase letter)
  if (isUppercase letter) {
    local 'commands' (at (('[data:unicodeAt]' 1 letter) - 64) _letters)
    '_plot commands' ('[data:copyFromTo]' commands 3)
  } else {
    '_plot commands' 'm50'
  }
  'plotter pen up'
  _plotterHeading = heading
}

to '_plotter init' {
  if (_plotterDelay == 0) {'set plotter speed to' 10}
  comment 'enable steppers'
  digitalWriteOp 8 false
}

to '_plotter step A' {
  digitalWriteOp 2 true
  waitMicros _plotterDelay
  digitalWriteOp 2 false
}

to '_plotter step B' {
  digitalWriteOp 3 true
  waitMicros _plotterDelay
  digitalWriteOp 3 false
}

to '_read letters from file' {
  if (('[data:find]' 'letters.txt' ('file names')) > 0) {
    _letters = ('[data:makeList]')
    '[file:open]' 'letters.txt'
    local 'line' ('[file:readLine]' 'letters.txt')
    repeatUntil ((size line) == 0) {
      '[data:addLast]' line letters
      line = ('[file:readLine]' 'letters.txt')
    }
    '[file:close]' 'letters.txt'
    if ((size _letters) == 0) {
      _letters = 0
    }
  }
}

to 'plot text' text size {
  '_letter size' = size
  for i text {
    '_plot letter' i
    waitMillis 100
    'ploturtle move' ((v '_letter spacing') * (v '_letter size'))
  }
}

to 'plotter move' x y {
  '_plotter resolution' = 10000
  '_plotter init'
  local 'delta A' (x + y)
  local 'delta B' (x - y)
  digitalWriteOp 5 ((v 'delta A') >= 0)
  digitalWriteOp 6 ((v 'delta B') >= 0)
  motorA = ('[data:makeList]')
  motorB = ('[data:makeList]')
  local 'relation' 0
  if (and ((v 'delta A') != 0) ((v 'delta B') != 0)) {
    if ((absoluteValue (v 'delta A')) >= (absoluteValue (v 'delta B'))) {
      relation = (absoluteValue (((v 'delta B') * (v '_plotter resolution')) / (v 'delta A')))
      local 'r' 0
      repeat (absoluteValue (v 'delta A')) {
        r += relation
        if (r >= (v '_plotter resolution')) {
          r += (0 - (v '_plotter resolution'))
          '_plotter step A'
          '_plotter step B'
        } else {
          '_plotter step A'
        }
      }
    } else {
      relation = (absoluteValue (((v 'delta A') * (v '_plotter resolution')) / (v 'delta B')))
      local 'r' 0
      repeat (absoluteValue (v 'delta B')) {
        r += relation
        if (r >= (v '_plotter resolution')) {
          r += (0 - (v '_plotter resolution'))
          '_plotter step A'
          '_plotter step B'
        } else {
          '_plotter step B'
        }
      }
    }
  } else {
    if ((v 'delta B') == 0) {
      repeat (absoluteValue (v 'delta A')) {
        '_plotter step A'
      }
    } ((v 'delta A') == 0) {
      repeat (absoluteValue (v 'delta B')) {
        '_plotter step B'
      }
    }
  }
}

to 'plotter pen down' {
  setServoAngle 11 0
  waitMillis 250
}

to 'plotter pen up' {
  setServoAngle 11 -90
}

to 'plotter stop' {
  stopAll
  comment 'disable steppers'
  digitalWriteOp 8 true
  'plotter pen up'
}

to 'ploturtle move' n {
  'plotter move' ((n * ('[misc:sin]' (_plotterHeading + 9000))) >> 14) ((n * ('[misc:sin]' _plotterHeading)) >> 14)
}

to 'ploturtle setHeading' a {
  _plotterHeading = ((a * 100) % 36000)
}

to 'ploturtle turnBy' a {
  _plotterHeading += (a * 100)
  _plotterHeading = (_plotterHeading % 36000)
}

to 'ploturtle turnFraction' num denom {
  _plotterHeading += ((num * 36000) / denom)
  _plotterHeading = (_plotterHeading % 36000)
}

to 'set plotter speed to' speed {
  _plotterDelay = ((950 / (maximum 1 (minimum 100 speed))) + 41)
}

module 'Encoder Motor' Output
author MicroBlocks
version 1 1 
depends Wukong 
description 'Control motors with digital encoder outputs using the Wukong board.
Pins 1 and 2 are the encoder inputs for the two motors.'
variables _encoderMotor_M1_degrees _encoderMotor_M2_degrees 

  spec ' ' 'encodeMotor_turnMotors' 'turn motor 1 _ motor 2 _ (degrees)' 'num num' 500 500
  spec ' ' '_encodeMotor_runM1' '_encodeMotor_runM1'
  spec ' ' '_encodeMotor_runM2' '_encodeMotor_runM2'
  spec ' ' '_encodeMotor_run' '_run motor _' 'num' 1
  spec ' ' '_encodeMotor_stepMotor' '_step motor _ by _ steps power _' 'num num num' 1 100 50
  spec ' ' '_encodeMotor_waitForStop' '_encodeMotor_waitForStop _' 'num' 1

to '_encodeMotor_run' motor {
  if (motor == 1) {
    local 'degrees' _encoderMotor_M1_degrees
  } else {
    local 'degrees' _encoderMotor_M2_degrees
  }
  local 'dir' 1
  if (degrees < 0) {
    dir = -1
    degrees = (0 - degrees)
  }
  degrees = (maximum degrees 4)
  if (degrees >= 20) {
    '_encodeMotor_stepMotor' motor (degrees - 1) (30 * dir)
    wukong_setMotor motor (-100 * dir)
    '_encodeMotor_waitForStop' motor
  } else {
    '_encodeMotor_stepMotor' motor (degrees - 1) (30 * dir)
    wukong_setMotor motor (-50 * dir)
    '_encodeMotor_waitForStop' motor
  }
  wukong_setMotor motor 0
}

to '_encodeMotor_runM1' {
  comment 'Motor1 task.'
  '_encodeMotor_run' 1
  _encoderMotor_M1_degrees = 0
}

to '_encodeMotor_runM2' {
  comment 'Motor2 task.'
  '_encodeMotor_run' 2
  _encoderMotor_M2_degrees = 0
}

to '_encodeMotor_stepMotor' m steps power {
  wukong_setMotor m power
  repeat steps {
    waitUntil (digitalReadOp m)
    waitUntil (not (digitalReadOp m))
  }
}

to '_encodeMotor_waitForStop' encoderPin {
  local 'last state' (booleanConstant false)
  local 'last pulse start' (microsOp)
  local 'usecs since last pulse' 0
  repeatUntil ((v 'usecs since last pulse') > 5000) {
    local 'state' (digitalReadOp encoderPin)
    local 'now' (microsOp)
    if (now < (v 'last pulse start')) {
      comment 'Handle clock wrap'
      'last pulse start' = 0
    }
    if (state != (v 'last state')) {
      if state {'last pulse start' = now}
      'last state' = state
    }
    'usecs since last pulse' = (now - (v 'last pulse start'))
  }
}

to encodeMotor_turnMotors degrees1 degrees2 {
  _encoderMotor_M1_degrees = degrees1
  _encoderMotor_M2_degrees = degrees2
  sendBroadcast '_encodeMotor_runM1'
  sendBroadcast '_encodeMotor_runM2'
  waitUntil (and (_encoderMotor_M1_degrees <= 0) (_encoderMotor_M2_degrees <= 0))
}

module Files Data
author MicroBlocks
version 1 3 
description 'Flash file system operations. Currently supports the LittleFS file system on ESP8266 and ESP32 boards. The GnuBlocks virtual machine (Linux and Raspberry Pi) supports the native system.'

  spec ' ' '[file:open]' 'open file _' 'str'
  spec ' ' '[file:close]' 'close file _' 'str'
  spec ' ' '[file:delete]' 'delete file _' 'str'
  space
  spec ' ' '[file:appendLine]' 'append line _ to file _' 'str str'
  spec ' ' '[file:appendBytes]' 'append bytes _ to file _' 'str str'
  space
  spec 'r' '[file:endOfFile]' 'end of file _' 'str'
  spec 'r' '[file:readLine]' 'next line of file _' 'str'
  spec 'r' '[file:readBytes]' 'next _ bytes of file _ : starting at _' 'num str num' 100 '' 0
  spec 'r' '[file:readInto]' 'read into _ from file _' 'str str' 'a ByteArray' ''
  space
  spec 'r' '[file:readPosition]' 'read position of file _' 'str'
  spec ' ' '[file:setReadPosition]' 'set read position _ of file _' 'num str' 0 ''
  spec ' ' 'file_SkipBytes' 'skip _ bytes of file _' 'num str' 4 ''
  space
  spec 'r' 'file names' 'file names : in directory _' 'str'
  spec 'r' '[file:fileSize]' 'size of file _' 'str'
  spec 'r' '[file:systemInfo]' 'file system info'

to 'file names' dir {
  '[file:startList]' dir
  local 'result' ('[data:makeList]')
  local 'fileName' ('[file:nextInList]')
  repeatUntil (fileName == '') {
    '[data:addLast]' fileName result
    fileName = ('[file:nextInList]')
  }
  return result
}

to file_SkipBytes offset file {
  local 'newPosition' (('[file:readPosition]' file) + offset)
  '[file:setReadPosition]' newPosition file
}

module Fractions Operators
author MicroBlocks
version 1 0 
tags numbers fractions precision float 
description 'Rational number arithmetic.'

	spec 'r' 'FRACT' 'fract _ / _' 'num num' 3 4
	spec 'r' 'FRACT_add' 'fract _ + _' 'num num' 3 4
	spec 'r' 'FRACT_subtract' 'fract _ â _' 'num num' 4 3
	spec 'r' 'FRACT_multiply' 'fract _ Ã _' 'num num' 3 4
	spec 'r' 'FRACT_equal' 'fract _ = _' 'num num' 3 4
	spec 'r' 'FRACT_less' 'fract _ < _' 'num num' 3 4
	spec 'r' 'FRACT_greater' 'fract _ > _' 'num num' 3 4
	spec 'r' 'FRACT_simplify' 'simplify fraction _' 'num' 5
	spec 'r' 'FRACT_integer' 'integer part of fraction _' 'num' 5
	spec 'r' 'FRACT_numerator' 'numerator of fraction _' 'num' 5
	spec 'r' 'FRACT_denominator' 'denominator of fraction _' 'num' 5
	spec 'r' 'FRACT_gcd' 'gcd _ _' 'num num' 9 12
	spec 'r' 'FRACT_lcm' 'lcm _ _' 'num num' 4 6

to FRACT a b {
  if (and (isType a 'number') (isType b 'number')) {return ('[data:makeList]' a b)}
  if (isType a 'number') {return (FRACT_simplify ('[data:makeList]' (a * (FRACT_denominator b)) (FRACT_numerator b)))}
  if (isType b 'number') {return (FRACT_simplify ('[data:makeList]' (FRACT_numerator a) (b * (FRACT_denominator a))))}
  return (FRACT_simplify ('[data:makeList]' ((FRACT_numerator a) * (FRACT_denominator b)) ((FRACT_denominator a) * (FRACT_numerator b))))
}

to FRACT_add a b {
  local 'lcd' (FRACT_lcm (FRACT_denominator a) (FRACT_denominator b))
  return (FRACT_simplify (FRACT (((FRACT_numerator a) * (lcd / (FRACT_denominator a))) + ((FRACT_numerator b) * (lcd / (FRACT_denominator b)))) lcd))
}

to FRACT_denominator fraction {
  if (isType fraction 'number') {return 1}
  return (at 2 fraction)
}

to FRACT_equal a b {
  local 'lcd' ((FRACT_denominator a) * (FRACT_denominator b))
  return (((FRACT_numerator a) * (lcd / (FRACT_denominator a))) == ((FRACT_numerator b) * (lcd / (FRACT_denominator b))))
}

to FRACT_gcd a b {
  a = (absoluteValue a)
  b = (absoluteValue b)
  repeatUntil (b == 0) {
    local 'tmp' b
    b = (a % b)
    a = tmp
  }
  return a
}

to FRACT_greater a b {
  local 'lcd' ((FRACT_denominator a) * (FRACT_denominator b))
  return (((FRACT_numerator a) * (lcd / (FRACT_denominator a))) > ((FRACT_numerator b) * (lcd / (FRACT_denominator b))))
}

to FRACT_integer fraction {
  return ((FRACT_numerator fraction) / (FRACT_denominator fraction))
}

to FRACT_lcm a b {
  return ((a / (FRACT_gcd a b)) * b)
}

to FRACT_less a b {
  local 'lcd' ((FRACT_denominator a) * (FRACT_denominator b))
  return (((FRACT_numerator a) * (lcd / (FRACT_denominator a))) < ((FRACT_numerator b) * (lcd / (FRACT_denominator b))))
}

to FRACT_multiply a b {
  return (FRACT_simplify (FRACT ((FRACT_numerator a) * (FRACT_numerator b)) ((FRACT_denominator a) * (FRACT_denominator b))))
}

to FRACT_numerator fraction {
  if (isType fraction 'number') {return fraction}
  return (at 1 fraction)
}

to FRACT_simplify fraction {
  if (isType fraction 'number') {return fraction}
  local 'gcd' (FRACT_gcd (FRACT_numerator fraction) (FRACT_denominator fraction))
  local 'simple' (FRACT ((FRACT_numerator fraction) / gcd) ((FRACT_denominator fraction) / gcd))
  if ((FRACT_denominator simple) == 1) {
    return (FRACT_numerator simple)
  }
  return simple
}

to FRACT_subtract a b {
  local 'lcd' (FRACT_lcm (FRACT_denominator a) (FRACT_denominator b))
  return (FRACT_simplify (FRACT (((FRACT_numerator a) * (lcd / (FRACT_denominator a))) - ((FRACT_numerator b) * (lcd / (FRACT_denominator b)))) lcd))
}

module 'IR Remote' Comm
author MicroBlocks
version 1 5 
tags ir infrared remote 
description 'Sends and receives infrared remote control messages like the ones used for TV sets or air conditioners. Currently supports only the NEC protocol, which is quite common but not the only IR protocol in use. An NEC message consists of a one byte device number and a one byte command.

Note: Transmitting IR does not work on ESP8266 boards.

Receiving requires an IR receiver module, such as those built into the Circuit Playground Express and ED1 boards. Transmitting requires an IR transmitter LED, such as those built into the Circuit Playground Express and several M5 Stack products. Inexpensive IR LED transmitter and receivers are available for use with other boards.'
variables _ir_pin _ir_pulse_times _ir_last_code _ir_last_device _ir_transmit_pin 

  spec ' ' 'attachIR' 'attach IR receiver to pin _' 'num' 0
  spec 'r' 'ir_code_received' 'IR code received?'
  spec 'r' 'ir_last_code' 'IR code'
  space
  spec ' ' 'IR_Transmit' 'IR transmit device _ command _' 'num num' 48896 1
  spec ' ' 'attachIRTransmitter' 'attach IR transmitter to pin _' 'num' 0
  space
  spec 'r' 'receiveIR' 'receive IR code'
  space
  spec ' ' '_testIR' '_test IR'
  spec 'r' '_receiveIRFromDevice' '_receive IR code from device _' 'num' 48896
  space
  spec ' ' '_captureIRMessage' '_captureIRMessage' 'any'
  spec ' ' '_dumpIR' '_dumpIR' 'any'
  spec 'r' '_getIRByte' '_getIRByte _' 'auto any' 4
  spec 'r' '_got32Bits' '_got32Bits' 'any'
  spec ' ' '_IR_SendByte' '_IR_SendByte _' 'auto' '10'

to IR_Transmit device command {
  if (_ir_transmit_pin == 0) {if (or ((boardType) == 'CircuitPlayground') ((boardType) == 'M5Atom-Matrix')) {
    _ir_transmit_pin = 12
  } (or ((boardType) == 'M5StickC') ((boardType) == 'M5StickC+')) {
    _ir_transmit_pin = 9
  }}
  comment 'Message start pulse and space'
  '[io:playTone]' _ir_transmit_pin 38000
  waitMicros 9000
  '[io:playTone]' _ir_transmit_pin 0
  waitMicros 4500
  comment 'Send device and command and their inverses'
  '_IR_SendByte' (device & 255)
  '_IR_SendByte' ((device >> 8) & 255)
  '_IR_SendByte' command
  '_IR_SendByte' ('~' command)
  comment 'Send stop bit'
  '[io:playTone]' _ir_transmit_pin 38000
  waitMicros 562
  '[io:playTone]' _ir_transmit_pin 0
  comment 'Turn off IR transmit LED'
  if (or ((boardType) == 'M5StickC') ((boardType) == 'M5StickC+')) {
    comment 'IR pin is inverted so true means "off"'
    digitalWriteOp _ir_transmit_pin true
  } else {
    digitalWriteOp _ir_transmit_pin false
  }
}

to '_IR_SendByte' byte {
  local 'bit' 1
  repeat 8 {
    if (0 == (byte & bit)) {
      '[io:playTone]' _ir_transmit_pin 38000
      waitMicros 530
      '[io:playTone]' _ir_transmit_pin 0
      waitMicros 530
    } else {
      '[io:playTone]' _ir_transmit_pin 38000
      waitMicros 530
      '[io:playTone]' _ir_transmit_pin 0
      waitMicros 1630
    }
    bit = (bit << 1)
  }
}

to '_captureIRMessage' {
  if (_ir_pulse_times == 0) {
    _ir_pulse_times = (newList 200)
    if (_ir_pin == 0) {
      if ((boardType) == 'CircuitPlayground') {
        _ir_pin = 11
      } ((boardType) == 'Citilab ED1') {
        _ir_pin = 35
      } ((boardType) == 'D1-Mini') {
        _ir_pin = 2
      } ((boardType) == 'MakerPort') {
        _ir_pin = 18
      }
    }
  }
  fillList _ir_pulse_times 0
  local 'i' 1
  comment 'Wait for IR signal -- this is the start of a new message.
Note: THe pin goes low when an IR signal is detected.'
  waitUntil (not (digitalReadOp _ir_pin))
  local 'start' (microsOp)
  forever {
    comment 'Record the time until the end of the current IR pulse ("mark")'
    waitUntil (digitalReadOp _ir_pin)
    local 'end' (microsOp)
    atPut i _ir_pulse_times (end - start)
    i += 1
    start = end
    comment 'Record time until the start of the next IR pulse ("space")'
    repeatUntil (not (digitalReadOp _ir_pin)) {
      if (((microsOp) - start) > 5000) {
        comment 'No IR pulse for 5000 usecs means "end of message"'
        return 0
      }
    }
    local 'end' (microsOp)
    atPut i _ir_pulse_times (end - start)
    i += 1
    start = end
  }
}

to '_dumpIR' {
  comment 'Print raw pulse timings to the terminal.
Can be used to analyze new protocols.'
  local 'i' 1
  printIt '-----'
  repeat (size _ir_pulse_times) {
    local 'mark usecs' (at i _ir_pulse_times)
    local 'space usecs' (at (i + 1) _ir_pulse_times)
    printIt (v 'mark usecs') (v 'space usecs')
    i += 2
    if ((v 'space usecs') == 0) {
      printIt 'timing entries:' (i - 2)
      return 0
    }
  }
}

to '_getIRByte' position {
  local 'result' 0
  local 'i' position
  local 'bit' 1
  repeat 8 {
    if ((at i _ir_pulse_times) > 1000) {result = (result | bit)}
    bit = (bit << 1)
    i += 2
  }
  return result
}

to '_got32Bits' {
  return (and ((at 67 _ir_pulse_times) != 0) ((at 68 _ir_pulse_times) == 0))
}

to '_receiveIRFromDevice' deviceID {
  forever {
    '_captureIRMessage'
    if ('_got32Bits') {
      local 'id_lowByte' ('_getIRByte' 4 nil)
      local 'id_highByte' ('_getIRByte' 20 nil)
      if (and (id_highByte == (deviceID >> 8)) (id_lowByte == (deviceID & 255))) {
        return ('_getIRByte' 36 nil)
      }
    }
  }
}

to '_testIR' {
  forever {
    '_captureIRMessage'
    if ('_got32Bits') {
      comment 'Four byte message format:
<device low byte><device high byte><command><command, bit-inverted>'
      local 'b1' ('_getIRByte' 4 nil)
      local 'b2' ('_getIRByte' 20 nil)
      local 'b3' ('_getIRByte' 36 nil)
      local 'b4' ('_getIRByte' 52 nil)
      sayIt 'Device:' ((b2 << 8) | b1) 'code:' b3
    }
  }
}

to attachIR pin {
  _ir_pin = pin
}

to attachIRTransmitter pin {
  _ir_transmit_pin = pin
}

to ir_code_received {
  return ((receiveIR) >= 0)
}

to ir_last_code {
  return _ir_last_code
}

to receiveIR {
  forever {
    '_captureIRMessage'
    if ('_got32Bits') {
      local 'id_lowByte' ('_getIRByte' 4 nil)
      local 'id_highByte' ('_getIRByte' 20 nil)
      _ir_last_device = ((id_highByte << 8) | id_lowByte)
      _ir_last_code = ('_getIRByte' 36 nil)
      atPut 'all' _ir_pulse_times 0
      return _ir_last_code
    }
  }
}

module 'Joystick:bit' Input
author wwj718
version 1 0 
choices axisXY X Y 
choices button_4 C D E F 
description 'Joystick:bit V2 is a game board based on micro:bit. It contains a 4-direction joystick and 4 undefined buttons. At the same time, it enhances the game experience with its on-board buzzer and vibration motor. Joystick:bit V2 can also be used as a remote control with a good apperance and comfortable feels.

https://www.elecfreaks.com/learn-en/microbitExtensionModule/joystick_bit_v2.html
'

	spec 'r' 'button' 'button _ is pressed' 'menu.button_4' 'C'
	spec 'r' 'rocker value of' 'rocker value of _' 'menu.axisXY' 'X'
	spec ' ' 'motor vibrate for' 'motor vibrate for _ ms' 'auto' 100
	spec ' ' '_initialization' 'initialization'

to '_initialization' {
  digitalWriteOp 0 false
  digitalWriteOp 16 true
}

to button button {
  if (button == 'C') {
    return (not (digitalReadOp 12 true))
  } (button == 'D') {
    return (not (digitalReadOp 13 true))
  } (button == 'E') {
    return (not (digitalReadOp 14 true))
  } else {
    return (not (digitalReadOp 15 true))
  }
}

to 'motor vibrate for' x {
  digitalWriteOp 16 false
  waitMillis x
  digitalWriteOp 16 true
}

to 'rocker value of' axis {
  if (axis == 'X') {
    return (analogReadOp 1)
  } else {
    return (analogReadOp 2)
  }
}

module 'Keyboard and Mouse' Comm
author MicroBlocks
version 1 5 
choices keyModifiers Shift Control 'Alt / â¥' 'Logo / â' AltGr 
choices mouseButtons left right middle both 
choices specialKeys 'enter:10' 'return:13' 'tab:179' 'backspace:178' 'delete:212' 'insert:209' 'home:210' 'end:213' 'PgUp:211' 'PgDown:214' 'â:215' 'â:216' 'â:217' 'â:218' 'F1:194' 'F2:195' 'F3:196' 'F4:197' 'F5:198' 'F6:199' 'F7:200' 'F8:201' 'F9:202' 'F10:203' 'F11:204' 'F12:205' 'CapsLock:193' 'NumLock:219' 'ScrollLock:207' 'PrintScreen:206' 'ESC:177' 
description 'This library can send mouse and keyboard events to a computer over USB (i.e. it emulates a USB HID device) on boards with the necessary hardware. It currently works on RP2040 and SAMD21 boards such as the Adafruit Circuit Playground Express, Trinket M0, and Metro M0 Express. It also works on the MakerPort.

It is based on the Arduino Mouse and Keyboard libraries. The list of special, non-ascii keys and modifiers is here:

https://www.arduino.cc/reference/en/language/functions/usb/keyboard/keyboardmodifiers/
'

  spec ' ' 'press key' 'press key _ : while holding _' 'auto.specialKeys menu.keyModifiers' 'n' 'Shift'
  spec ' ' '[hid:holdKey]' 'hold key _' 'auto.specialKeys' 'A'
  spec ' ' '[hid:releaseKey]' 'release key _' 'auto.specialKeys' 'A'
  spec ' ' '[hid:releaseKeys]' 'release all keys'
  space
  spec ' ' 'mouse click' '_ mouse click' 'menu.mouseButtons' 'left'
  spec ' ' '[hid:mouseMove]' 'move mouse pointer by _ , _' 'num num' 10 -20
  spec ' ' '[hid:mouseScroll]' 'scroll mouse by _' 'num' -5
  spec ' ' 'mouse hold' 'hold _ mouse button' 'menu.mouseButtons' 'left'
  spec ' ' '[hid:mouseRelease]' 'release mouse buttons'

to 'mouse click' which {
  '[hid:mousePress]' ('[data:find]' which ('[data:makeList]' 'left' 'right' 'both' 'middle'))
  waitMillis 50
  '[hid:mouseRelease]'
}

to 'mouse hold' which {
  '[hid:mousePress]' ('[data:find]' which ('[data:makeList]' 'left' 'right' 'both' 'middle'))
}

to 'press key' key modifier {
  '[hid:pressKey]' key ('[data:find]' modifier ('[data:makeList]' 'Shift' 'Control' 'Alt / â¥' 'Logo / â' 'AltGr'))
}

module Lists Data
author MicroBlocks
version 1 2 
description 'Useful functions for working with lists.
'

  spec 'r' 'list_contains' 'list _ contains _' 'auto auto' 'aList' 'cat'
  space
  spec 'r' 'list_circular' 'circular item _ of _' 'auto auto' '10' 'aListOrString'
  space
  spec 'r' 'list_map' 'map _ over _' 'str.functionNameMenu auto' 'aFunction' 'aList'
  spec 'r' 'list_filter' 'filter _ with _' 'auto str.functionNameMenu' 'aList' 'aFunction'
  space
  spec ' ' 'list_reverse' 'reverse _' 'auto' 'aList'
  spec ' ' 'list_shuffle' 'shuffle _' 'auto' 'aList'
  spec ' ' 'list_mergesort' 'sort _' 'auto' 'aList'
  space
  spec 'r' 'list_shuffled' 'shuffled _' 'auto' 'aList'
  spec 'r' 'list_reversed' 'reversed _' 'auto' 'aList'
  spec 'r' 'list_sorted' 'sorted _' 'auto' 'aList'
  space
  spec ' ' '_list_mergeStep' '_mergeStep _ _ _ _ _' 'auto num num num auto' 'srcList' 1 2 3 'dstList'

to '_list_mergeStep' src left right end dst {
  local 'i' left
  local 'j' right
  local 'k' left
  repeatUntil (k > end) {
    if (and (i < right) (or (j > end) ((at i src) <= (at j src)))) {
      atPut k dst (at i src)
      i += 1
    } else {
      atPut k dst (at j src)
      j += 1
    }
    k += 1
  }
}

to list_circular n list {
  if (n < 1) {
    return (at ((size list) - ((absoluteValue n) % (size list))) list)
  } else {
    return (at (((n - 1) % (size list)) + 1) list)
  }
}

to list_contains aList aValue {
  for item aList {
    if (aValue == item) {return (booleanConstant true)}
  }
  return (booleanConstant false)
}

to list_filter src selectionFunction {
  local 'result' ('[data:makeList]')
  for item src {
    if (callCustomReporter selectionFunction ('[data:makeList]' item)) {'[data:addLast]' item result}
  }
  return result
}

to list_map aFunction src {
  local 'result' ('[data:makeList]')
  for item src {
    '[data:addLast]' (callCustomReporter aFunction ('[data:makeList]' item)) result
  }
  return result
}

to list_mergesort src {
  local 'len' (size src)
  local 'work list' (newList len)
  local 'width' 1
  repeatUntil (width >= len) {
    local 'i' 1
    repeatUntil (i > len) {
      '_list_mergeStep' src i (minimum (i + width) len) (minimum (i + ((2 * width) - 1)) len) (v 'work list')
      i += (2 * width)
    }
    comment 'Copy working list into the source list.'
    for i len {
      atPut i src (at i (v 'work list'))
    }
    width = (2 * width)
  }
}

to list_reverse aList {
  local 'i' 1
  local 'j' (size aList)
  repeatUntil (i >= j) {
    local 'tmp' (at i aList)
    atPut i aList (at j aList)
    atPut j aList tmp
    i += 1
    j += -1
  }
}

to list_reversed list {
  local 'new list' ('[data:copyFromTo]' list 1)
  list_reverse (v 'new list')
  return (v 'new list')
}

to list_shuffle aList {
  local 'len' (size aList)
  for i len {
    local 'j' (random 1 len)
    local 'tmp' (at i aList)
    atPut i aList (at j aList)
    atPut j aList tmp
  }
}

to list_shuffled list {
  local 'new list' ('[data:copyFromTo]' list 1)
  list_shuffle (v 'new list')
  return (v 'new list')
}

to list_sorted list {
  local 'new list' ('[data:copyFromTo]' list 1)
  list_mergesort (v 'new list')
  return (v 'new list')
}

module SquareWave Output
author MicroBlocks
version 1 0 
description 'Generate a high frequency square wave on a micro:bit (v1 or v2), other nRF5x board, or ESP32 board pin.

On nRF5x boards, frequencies in the AM radio band (in kHz) are:
   533 571 615 727 800 889 1000 1143 1333 1600
ESP32 boards support finer-grained frequency selection in the AM band.

Frequency range is 122 Hz to 8 MHz (nRF5x boards) or 500 Hz to 20 MHz (ESP32 boards).'

	spec ' ' '[io:squareWave]' 'set square wave frequency _ pin _' 'num num' 1000000 0
	spec ' ' 'squareWaveOff' 'stop square wave'

to squareWaveOff {
  '[io:squareWave]' 0 0
}

module Strings Data
author MicroBlocks
version 1 5 
description 'String operations.'

	spec 'r' 'isDigit' '_ is a digit' 'str' '5'
	spec 'r' 'isLowercase' '_ is lowercase' 'str' 'A'
	spec 'r' 'isUppercase' '_ is uppercase' 'str' 'E'
	space
	spec 'r' 'beginsWith' '_ begins with _' 'str str' 'prefix' 'pre'
	spec 'r' 'endsWith' '_ ends with _' 'str str' 'suffix' 'fix'
	spec 'r' 'contains' '_ contains _' 'str str' 'smiles' 'mile'
	space
	spec 'r' 'lowercase' 'lowercase _' 'str' 'THIS is a String! :)'
	spec 'r' 'uppercase' 'uppercase _' 'str' 'Hello, world!'
	spec 'r' 'withoutWhiteSpace' '_ without white space' 'str' '1, 2,	3,
4'
	space
	spec 'r' 'joinWith' 'join string list _ separator _' 'auto str' ' ' ' '
	spec 'r' 'stringToUnicodes' 'unicodes _' 'auto' 'aString'
	spec 'r' 'unicodesToString' 'string from unicodes _' 'auto' 'aList'
	space
	spec 'r' 'num2str' 'num2str _' 'auto' 42
	spec 'r' 'str2num' 'str2num _' 'str' '123'

to beginsWith string substring {
  return (('[data:find]' substring string) == 1)
}

to contains string substring {
  return (('[data:find]' substring string) > 0)
}

to endsWith string substring {
  return (('[data:find]' substring string) > ((size string) - (size substring)))
}

to isDigit char {
  local 'unicode' ('[data:unicodeAt]' 1 char)
  return (and (unicode >= 48) (unicode <= 57))
}

to isLowercase char {
  local 'unicode' ('[data:unicodeAt]' 1 char)
  return (and (unicode >= 97) (unicode <= 122))
}

to isUppercase char {
  local 'unicode' ('[data:unicodeAt]' 1 char)
  return (and (unicode >= 65) (unicode <= 90))
}

to joinWith stringList separator {
  if (not (isType stringList 'list')) {return ('[data:join]' '' stringList)}
  if (or ((pushArgCount) == 1) (separator == '')) {return ('[data:joinStrings]' stringList)}
  local 'result' (newList (2 * (size stringList)))
  '[data:delete]' 'all' result
  for s stringList {
    '[data:addLast]' s result
    '[data:addLast]' separator result
  }
  '[data:delete]' 'last' result
  return ('[data:joinStrings]' result)
}

to lowercase string {
  local 'new string' ''
  for i (size string) {
    if (isUppercase (at i string)) {
      'new string' = ('[data:join]' (v 'new string') ('[data:unicodeString]' (('[data:unicodeAt]' i string) + 32)))
    } else {
      'new string' = ('[data:join]' (v 'new string') (at i string))
    }
  }
  return (v 'new string')
}

to num2str n {
  return ('[data:join]' '' n)
}

to str2num s {
  return (0 + s)
}

to stringToUnicodes s {
  local 'result' (newList (size s))
  for i (size s) {
    atPut i result ('[data:unicodeAt]' i s)
  }
  return result
}

to unicodesToString aList {
  return ('[data:unicodeString]' aList)
}

to uppercase string {
  local 'new string' ''
  for i (size string) {
    if (isLowercase (at i string)) {
      'new string' = ('[data:join]' (v 'new string') ('[data:unicodeString]' (('[data:unicodeAt]' i string) - 32)))
    } else {
      'new string' = ('[data:join]' (v 'new string') (at i string))
    }
  }
  return (v 'new string')
}

to withoutWhiteSpace aString {
  local 'result' (newList (size aString))
  '[data:delete]' 'all' result
  for i (size aString) {
    local 'ch' ('[data:unicodeAt]' i aString)
    if (ch > 32) {
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

module 'File Primitives' Data
author MicroBlocks
version 1 2
tags data esp
description 'Primitives to access the built-in file system on ESP32 and ESP8266 boards.'

	// File system primtives.

	spec ' ' '[file:open]'			'open file _' 'str'
	spec ' ' '[file:close]'			'close file _' 'str'
	spec ' ' '[file:delete]'		'delete file _' 'str'

	spec 'r' '[file:endOfFile]'		'end of file _' 'str'
	spec 'r' '[file:readLine]'		'next line of file _' 'str'
	spec 'r' '[file:readBytes]'		'next _ bytes of file _ : starting at _' 'num str num' 100 '' 0

	spec ' ' '[file:appendLine]'	'append line _ to file _' 'str str'
	spec ' ' '[file:appendBytes]'	'append bytes _ to file _' 'str str'

	spec 'r' '[file:fileSize]'		'size of file _' 'str'
	spec ' ' '[file:startList]'		'start file list : directory _' 'str'
	spec 'r' '[file:nextInList]'	'next file in list'
	spec 'r' '[file:systemInfo]'	'file system info'
module 'Graphics Primitives' Output
author MicroBlocks
version 1 0
description 'Low level graphics primitives. Currently supported screens include the ones built into the Citilab ED1, M5Stack, M5Stick and (discontinued) IoT-Bus.' 
tags tft draw pixel

	// Graphics primitives. Currently supported screens include the IoT-Bus QVGA
	// touch screen and the 128x128 TFT display built into the Citilab ED1 board.
	// https://www.oddwires.com/iot-bus-qvga-2-4-tft-touch-display/
	// http://wiki.edutec.citilab.eu/IntroducciÃ³_a_ED1_i_robot_FantÃ stic

	spec ' ' '[tft:enableDisplay]'			'enable TFT _' 'bool' true
        spec 'r' '[tft:getWidth]'			'TFT width'
	spec 'r' '[tft:getHeight]'			'TFT height'
	spec ' ' '[tft:setPixel]'				'set TFT pixel x _ y _ to _' 'num num num' 50 32 16711680
	spec ' ' '[tft:line]'					'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num num' 12 8 25 15 255
	spec ' ' '[tft:rect]'					'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num num bool' 10 10 40 30 65280 false
	spec ' ' '[tft:roundedRect]'			'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num num bool' 10 10 40 30 8 12255317 false
	spec ' ' '[tft:circle]'					'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num num bool' 60 100 30 65535 false
	spec ' ' '[tft:triangle]'				'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num num bool' 20 20 30 80 60 5 5592354 false
	spec ' ' '[tft:text]'					'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num num num bool' 'Hello World!' 0 80 16777215 1 false
module 'JSON Primitives' Data
author MicroBlocks
version 1 0
description 'Very fast and efficient primitives to parse JSON strings.'
tags data json network

	spec 'r' '[misc:jsonGet]'		'json _ . _' 'str str' '{ "x": 1,  "y": [41, 42, 43] }' 'y.2'
	spec 'r' '[misc:jsonCount]'	'json count _ . _' 'str str' '[1, [4, 5, 6, 7], 3]' ''
	spec 'r' '[misc:jsonValueAt]'	'json value _ . _ at _' 'str str num' '{ "x": 1,  "y": 42 }' '' 2
	spec 'r' '[misc:jsonKeyAt]'	'json key _ . _ at _' 'str str num' '{ "x": 1,  "y": 42 }' ''  2
module 'Misc Primitives'
author MicroBlocks
version 1 3 
description 'Miscellaneous system primitives.'

  spec ' ' 'noop' 'no op'
  spec ' ' 'ignoreArgs' 'ignore : _ : ...' 'auto' 0
  space
  spec 'r' 'pushArgCount' 'arg count'
  spec 'r' 'getArg' 'arg _' 'num' 0
  space
  spec 'r' 'longMult' '( _ * _ ) >> _' 'num num num' 1024 2048 10
  spec 'r' '[misc:sin]' 'fixed sine _' 'num' 9000
  spec 'r' '[misc:pressureToAltitude]' 'altitude diff for pressure change from _ to _' 'num num' 30 29
  spec 'r' '[misc:bme680GasResistance]' 'bme680 gas resistance adc _ range _ calibration range error  _' 'num num num' 500 0 0
  space
  spec ' ' '[misc:broadcastToIDE]' 'broadcast _ to IDE only' 'str' ''
  space
  spec ' ' '[display:mbEnableDisplay]' 'enable LED display _' 'bool' false
module 'OneWire Primitives' Comm
author MicroBlocks
version 1 0
description 'Primitives for 1-wire protocol used by devices like the DS18S20 temperature probe.'

  spec ' ' '[1wire:init]' 'oneWire init pin _' 'num' 0
  spec ' ' '[1wire:scanStart]' 'oneWire scan start'
  spec 'r' '[1wire:scanNext]' 'oneWire scan next _' 'str' 'addressByteArray'
  spec ' ' '[1wire:select]' 'oneWire select address _' 'str' 'addressByteArray'
  spec ' ' '[1wire:selectAll]' 'oneWire select all'
  spec ' ' '[1wire:writeByte]' 'oneWire write byte _ : power _' 'num bool' 0 false
  spec 'r' '[1wire:readByte]' 'oneWire read byte'
  spec 'r' '[1wire:crc8]' 'oneWire crc8 _ : byte count _' 'str num' 'aByteArray' 8
  spec 'r' '[1wire:crc16]' 'oneWire crc16 _ : byte count _' 'str num' 'aByteArray' 8
module 'Radio Primitives' Comm
author MicroBlocks
version 1 2 
tags radio communication messaging network 
description 'Low level BBC micro:bit radio primitives. You are probably looking for the Radio library in the folder above.

Messages to send and receive strings, numbers, and pairs use the same packet format as MakeCode and can be used to communicate with devices running MakeCode.

The packetSend/packetReceive primitives provide access to raw 32-byte radio packets so you can create your own protocol. The first byte gives the message length in bytes not counting the length byte; max is 31. The next byte is "1" for MakeCode packets; use anything but "1" for you own protocol and then it is up to you to define the format for the rest of the packet. See https://ukbaz.github.io/howto/ubit_radio.html.
'

	spec ' ' '[radio:sendInteger]' 'radio send number _' 'num' 123
	spec ' ' '[radio:sendString]' 'radio send string _' 'str' 'Hello!'
	spec ' ' '[radio:sendPair]' 'radio send pair _ = _' 'str num' 'light' 10
	spec 'r' '[radio:messageReceived]' 'radio message received?'
	spec 'r' '[radio:receivedInteger]' 'radio last number'
	spec 'r' '[radio:receivedString]' 'radio last string'
	spec 'r' '[radio:receivedMessageType]' 'radio last message type'
	spec ' ' '[radio:setGroup]' 'radio set group _ (0-255)' 'num' 0
	spec ' ' '[radio:setChannel]' 'radio set channel (0-83) _' 'num' 7
	spec ' ' '[radio:setPower]' 'radio set power (0-7) _' 'num' 4
	spec 'r' '[radio:signalStrength]' 'radio last signal strength'
	spec 'r' '[radio:packetReceive]' 'radio receive packet _' 'str'
	spec ' ' '[radio:packetSend]' 'radio send packet _' 'str'
	spec 'r' '[radio:deviceID]' 'radio my ID'
	spec 'r' '[radio:lastMessageID]' 'radio last sender ID'
	spec ' ' '[radio:disableRadio]' 'disable radio'
module 'Sensor Primitives' Input
author MicroBlocks
version 1 1
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'
tags tilt acceleration light sensor capacitive button


	// Sensor primitives for the BBC micro:bit, Calliope mini, Citilab ED1, and AdaFruit
	// Circuit Playground Express. These boards all have accelerometers and use various
	// techniques to sense temperature and light. The new ED1 board uses capacitive sensing
	// for its buttons.

	spec 'r' '[sensors:tiltX]'			'tilt x'
	spec 'r' '[sensors:tiltY]'			'tilt y'
	spec 'r' '[sensors:tiltZ]'			'tilt z'
	spec 'r' '[display:lightLevel]'		'light level'
	spec 'r' '[sensors:temperature]'	'temperature (Â°C)'
	space
	spec 'r' '[sensors:touchRead]'		'capacitive sensor _' 'num' 1
	space
	spec ' ' '[sensors:i2cSetClockSpeed]' 'set i2c clock speed _' 'num' 400000
module 'Servo Primitives' Output
author MicroBlocks
version 1 0
description 'Low level servo motor primitives. You are probably looking for the Servo library in the folder above.'
tags servo motor angle rotation position


	spec 'r' '[io:hasServo]'				'has servo support'
	spec ' ' '[io:setServo]'				'set servo pin _ to _ usecs' 'num num' 0 1500
module 'Sound Primitives' Output
author MicroBlocks
version 2 0
description 'Low level support for tone generation and DAC audio output on selected boards. You are probably looking for the Tone library in the folder above. The tone primitives use the Arduino tone library to provide smoother music output. The DAC primitives are currently supported only on ESP32 boards.'
tags tone sound music audio note speaker

	spec 'r' '[io:hasTone]'				'has tone support'
	spec ' ' '[io:playTone]'				'play tone pin _ frequency _' 'num num' 0 440
	spec ' ' '[io:dacInit]'					'init DAC pin _ sample rate _' 'num num' 25 11025
	spec 'r' '[io:dacWrite]'				'DAC write _ : starting at _' 'num num' 128 1
module 'Touch Screen Primitives' Input
author MicroBlocks
version 1 0
description 'Primitives to support the QVGA touch screen display on the (discontinued) IoT-Bus Io system.'
tags qvga touch tft

	// Primitives to support the QVGA touch screen display on the IoT-Bus Io system.
	// https://www.oddwires.com/iot-bus-qvga-2-4-tft-touch-display/

	spec 'r' '[tft:tftTouched]'				'TFT touched'
	spec 'r' '[tft:tftTouchX]'				'TFT touch X position'
	spec 'r' '[tft:tftTouchY]'				'TFT touch Y position'
	spec 'r' '[tft:tftTouchPressure]'		'TFT touch pressure'
module 'Variable Primitives' Variables
author MicroBlocks
version 1 0
description 'Global variable introspection primitives to read and write variables given their name, enumerate variables and check whether a variable exists.'
tags introspection variables

	spec 'r' 'varNames' 			'varNames'
	spec 'r' '[vars:varExists]'		'variable named _ exists?' 'str' 'var'
	spec 'r' '[vars:varNamed]'		'value of variable named _' 'str' 'var'
	spec ' ' '[vars:setVarNamed]'	'set variable named _ to _' 'str auto' 'var' 0
	spec 'r' '[vars:varNameForIndex]' 'variable name for index _' 'num' 1

to varNames {
  local 'result' ('[data:makeList]')
  local 'count' ('[vars:varNameForIndex]' -1)
  for i count {
    local 'varName' ('[vars:varNameForIndex]' i)
    if (isType varName 'string') {
      '[data:addLast]' varName result
    }
  }
  return result
}
module 'WiFi Primitives' Comm
author MicroBlocks
version 1 5
choices requestTypes GET POST PUT DELETE
tags network http server client
description 'Low level network primitives. You are probably looking for either the HTTP Client, HTTP Server, UDP, or Wifi libraries in the Network folder.'

	// These primitives support WiFi
	// These primitives currently work only on ESP8266 and ESP32 boards, but may be ported
	// to other WiFi capable boards in the future.

	spec 'r' '[net:hasWiFi]'				'has WiFi support'
	spec ' ' '[net:startWiFi]'				'start WiFi _ password _ : be hotspot _ : IP _ gateway _ subnet _' 'auto auto bool auto auto auto' 'SSID' 'MyPassword' true '192.168.1.42' '192.168.1.1' '255.255.255.0'
	spec ' ' '[net:stopWiFi]'				'stop WiFi'
	spec 'r' '[net:wifiStatus]'				'WiFi status'
	spec 'r' '[net:startSSIDscan]'				'scan SSID list'
	spec 'r' '[net:getSSID]'				'get SSID number _' 'num' 1
	spec 'r' '[net:myMAC]'					'my MAC address'
	spec 'r' '[net:myIPAddress]'			'my IP address'

	spec ' ' '[net:httpConnect]'			'connect to httpê// _ : port _' 'auto num' 'microblocks.fun' 80
	spec 'r' '[net:httpIsConnected]'		'is HTTP connected?'
	spec ' ' '[net:httpRequest]'			'_ request httpê// _ / _ : body _' 'menu.requestTypes auto auto str' 'GET' 'microblocks.fun' 'example.txt' ''
	spec 'r' '[net:httpResponse]'			'HTTP response'

	spec 'r' '[net:httpServerGetRequest]'	'HTTP server request : binary data _ : port _' 'bool num' false 8080
	spec ' ' '[net:respondToHttpRequest]'	'respond _ to HTTP server request : with body _ : and headers _' 'auto str str' '200 OK' 'Welcome to the MicroBlocks HTTP server' 'Content-Type: text/plain'

	spec ' ' '[net:udpStart]'			'UDP start port _' 'auto' 5000
	spec ' ' '[net:udpStop]'			'UDP stop'
	spec ' ' '[net:udpSendPacket]'		'UDP send packet _ to ip _ port _' 'auto auto num' 'Hello!' '255.255.255.255' 5000
	spec 'r' '[net:udpReceivePacket]'	'UDP receive packet : binary data _' 'bool' false
	spec 'r' '[net:udpRemoteIPAddress]'	'UDP remote IP address'
	spec 'r' '[net:udpRemotePort]'		'UDP remote port'
module dec2anyBase
author 'Turgut Guneysu'
version 1 2 
choices BaseMenu '2' '8' '16' '32' 
description 'Converts DEC numbers into any Base system.
eg: BIN (base=2) or OCT (base=8) or HEX (base=16)

Changes: fix padding
'

  spec 'r' 'dec2any Base' 'dec2any Base _ Dec# _ PadLen _ Rev _' 'str.BaseMenu num num bool' '16' 255 4 false

to 'dec2any Base' base decNo padLength reversed {
  local '_answer' ('[data:makeList]')
  local '_output' ''
  repeatUntil (decNo < base) {
    '[data:addLast]' (decNo - ((decNo / base) * base)) _answer
    decNo = (decNo / base)
  }
  '[data:addLast]' decNo _answer
  repeatUntil ((size _answer) == 0) {
    if ((at 'last' _answer) == 0) {
      _output = ('[data:join]' _output '0')
    } else {
      _output = ('[data:join]' _output (at (at 'last' _answer) '123456789ABCDEFGHIJKLMNOPQRSTUV'))
    }
    '[data:delete]' 'last' _answer
  }
  if (and (padLength > 0) ((size _output) < padLength)) {
    _output = ('[data:join]' ('[data:copyFromTo]' '0000000000000000' 1 (padLength - (size _output))) _output)
  }
  if reversed {
    _answer = ('[data:split]' _output '')
    _output = ('[data:makeList]')
    repeat (size _answer) {
      '[data:addLast]' (at 'last' _answer) _output
      '[data:delete]' 'last' _answer
    }
    _output = ('[data:join]' '' ('[data:joinStrings]' _output))
  }
  return _output
}

module Radio Comm
author MicroBlocks
version 1 2 
tags radio communication messaging network 
description 'Send and receive messages between micro:bit boards via their built-in radio system.'

	spec ' ' '[radio:sendInteger]' 'radio send number _' 'num' 123
	spec ' ' '[radio:sendString]' 'radio send string _' 'str' 'Hello!'
	spec ' ' '[radio:sendPair]' 'radio send pair _ = _' 'str num' 'light' 10
	spec 'r' '[radio:messageReceived]' 'radio message received?'
	spec 'r' '[radio:receivedInteger]' 'radio last number'
	spec 'r' '[radio:receivedString]' 'radio last string'
	spec ' ' '[radio:setGroup]' 'radio set group _ (0-255)' 'num' 0
	spec ' ' '[radio:setPower]' 'radio set power (0-7) _' 'num' 4
	spec 'r' '_signalStrength' '_radio last signal strength'
	spec 'r' '_radioLastSenderID' '_radio last sender ID'
	spec 'r' '_radioMyID' '_radio my ID'
	spec 'r' '_receivedMessageType' '_radio last message type'
	spec ' ' '_setChannel' '_radio set channel (0-83) _' 'num' 7

to '_radioLastSenderID' {
  return ('[radio:lastMessageID]')
}

to '_radioMyID' {
  return ('[radio:deviceID]')
}

to '_receivedMessageType' {
  return ('[radio:receivedMessageType]')
}

to '_setChannel' channel {
  '[radio:setChannel]' channel
}

to '_signalStrength' {
  return ('[radio:signalStrength]')
}

module Ringtone Output
author MicroBlocks
version 1 2 
depends Tone 
description 'Plays tunes in RTTTL (Ringtone Text Transfer Language) a language developed by Nokia to store ringtones.
Also known as Nokring.'
variables '_RTTTL default duration' '_RTTTL default octave' '_RTTTL bpm' '_RTTTL song name' 

	spec 'r' '_RTTTL parse control from' '_RTTTL parse control from _' 'str' ''
	spec ' ' 'play ringtone' 'play ringtone _' 'str' 'Pacman:d=16,o=6,b=140:
b5,b,f#,d#,8b,8d#,c,c7,g,f,8c7,8e,b5,b,f#,d#,8b,8d#,32d#,32e,f,32f,32f#,g,32g,32g#,a,8b'
	spec 'r' 'current song name' 'current song name'
	spec ' ' '_RTTTL play note' '_RTTTL play note _' 'str' '8c#'

to '_RTTTL parse control from' 'control section' {
  comment 'Extract control section'
  local 'd' 4
  local 'o' 6
  local 'b' 63
  repeatUntil ((size (v 'control section')) == 0) {
    local 'next separator' ('[data:find]' ',' (v 'control section'))
    if ((v 'next separator') == -1) {
      'next separator' = (size (v 'control section'))
    }
    local 'to process' ('[data:copyFromTo]' (v 'control section') 1 (v 'next separator'))
    'control section' = ('[data:copyFromTo]' (v 'control section') ((v 'next separator') + 1))
    'next separator' = ('[data:find]' ',' (v 'to process'))
    if ((v 'next separator') == -1) {
      'next separator' = ((size (v 'to process')) + 1)
    }
    if (('[data:find]' 'd' (v 'to process')) > 0) {
      d = ('[data:copyFromTo]' (v 'to process') (('[data:find]' '=' (v 'to process')) + 1) ((v 'next separator') - 1))
    } (('[data:find]' 'b' (v 'to process')) > 0) {
      b = ('[data:copyFromTo]' (v 'to process') (('[data:find]' '=' (v 'to process')) + 1) ((v 'next separator') - 1))
    } (('[data:find]' 'o' (v 'to process')) > 0) {
      o = ('[data:copyFromTo]' (v 'to process') (('[data:find]' '=' (v 'to process')) + 1) ((v 'next separator') - 1))
    }
  }
  return ('[data:makeList]' d o b)
}

to '_RTTTL play note' note {
  local 'duration' ''
  local 'note name' ''
  local 'octave' (v '_RTTTL default octave')
  local 'ms / whole note' (240000 / (v '_RTTTL bpm'))
  local 'isDotted' (('[data:find]' '.' note) > -1)
  note = ('_trimmedLowercase' note)
  if (note == '') {
    comment 'empty note string; skip'
    return 0
  }
  comment 'parse duration value, if there is one'
  repeatUntil (or (('[data:unicodeAt]' 1 note) < 48) (('[data:unicodeAt]' 1 note) > 57)) {
    duration = ('[data:join]' duration (at 1 note))
    note = ('[data:copyFromTo]' note 2)
  }
  if (duration == '') {
    duration = (v '_RTTTL default duration')
  }
  comment 'parse note name'
  if (or (('[data:find]' '#' note) > -1) (('[data:find]' '_' note) > -1)) {
    'note name' = ('[data:copyFromTo]' note 1 2)
  } else {
    'note name' = (at 1 note)
  }
  note = ('[data:copyFromTo]' note ((size (v 'note name')) + 1))
  comment 'deal with dotted notes'
  if isDotted {
    duration = ((((v 'ms / whole note') / duration) * 15) / 10)
  } else {
    duration = ((v 'ms / whole note') / duration)
  }
  comment 'parse octave, if there is one'
  if (note != '') {
    octave = (at 1 note)
  }
  'play tone' (v 'note name') (octave - 4) duration
}

to 'current song name' {
  return (v '_RTTTL song name')
}

to 'play ringtone' RTTTL {
  comment 'Initialize frequency map.'
  ignoreArgs ('_baseFreqForNote' 'c')
  comment 'Remove song name'
  '_RTTTL song name' = ('[data:copyFromTo]' RTTTL 1 (('[data:find]' ':' RTTTL) - 1))
  RTTTL = ('[data:copyFromTo]' RTTTL ((size (v '_RTTTL song name')) + 2))
  local 'control' ('_RTTTL parse control from' ('[data:copyFromTo]' RTTTL 1 (('[data:find]' ':' RTTTL) - 1)))
  '_RTTTL default duration' = (at 1 control)
  '_RTTTL default octave' = (at 2 control)
  '_RTTTL bpm' = (at 3 control)
  RTTTL = ('[data:copyFromTo]' RTTTL (('[data:find]' ':' RTTTL) + 1))
  repeatUntil ((size RTTTL) == 0) {
    local 'next separator' ('[data:find]' ',' RTTTL)
    if ((v 'next separator') == -1) {
      'next separator' = ((size RTTTL) + 1)
    }
    local 'next note' ('[data:copyFromTo]' RTTTL 1 ((v 'next separator') - 1))
    RTTTL = ('[data:copyFromTo]' RTTTL ((v 'next separator') + 1))
    '_RTTTL play note' (v 'next note')
  }
  '_RTTTL song name' = ''
}

module 'Air Pressure (LPS22HB)' Input
author MicroBlocks
version 1 4 
description 'Sense air pressure and altitude with the LPS22HB air pressure sensor.
The altimeter can either report changes relative to the starting altitude. If calibrated to a known starting altitude, it can report absolute altitude.'
variables _lps22hb_basePressure _lps22hb_baseAltitude 

  spec 'r' 'lps22hb_airPressureMbar' 'air pressure (mBar)'
  spec 'r' 'lps22hb_airPressurePSI' 'air pressure (PSI x10)'
  space
  spec ' ' 'lps22hb_setBaseAltitude' 'set current altitude _ meters' 'num' 0
  spec ' ' 'lps22hb_setBasePressure' 'set base pressure (mBar x10) _ at _ meters' 'num num' 1013 0
  spec 'r' 'lps22hb_altitudeCentimeters' 'altitude (cm)'
  spec 'r' 'lps22hb_altitudeFeet' 'altitude (feet)'
  space
  spec 'r' 'lps22hb_temperature' 'lps22hb temperature (Â°C)'
  space
  spec 'r' '_lps22hb_altitudeMillimeters' '_lps22hb_altitudeMillimeters'
  spec 'r' '_lps22hb_rawPressure' '_lps22hb_rawPressure'
  spec 'r' '_lps22hb_readPressure' '_lps22hb_readPressure'

to '_lps22hb_altitudeMillimeters' {
  if (_lps22hb_basePressure == 0) {
    comment 'if base altitude not set, use zero (useful for relative measurments)'
    lps22hb_setBaseAltitude 0
  }
  mmChange = ('[misc:pressureToAltitude]' _lps22hb_basePressure ('_lps22hb_rawPressure'))
  return ((1000 * _lps22hb_baseAltitude) + mmChange)
}

to '_lps22hb_rawPressure' {
  local 'LPS22HB' (hexToInt '5C')
  local 'raw' ('_lps22hb_readPressure')
  if (raw == 0) {
    comment 'LPS22HB sometimes gets stuck returning zero pressure
This sequence may unstick it.'
    i2cSet LPS22HB (hexToInt '11') 128
    i2cSet LPS22HB (hexToInt '10') 0
    raw = ('_lps22hb_readPressure')
  }
  return raw
}

to '_lps22hb_readPressure' {
  local 'LPS22HB' (hexToInt '5C')
  i2cSet LPS22HB (hexToInt '11') 1
  waitMillis 2
  local 'result' (i2cGet LPS22HB (hexToInt '28'))
  result = (((i2cGet LPS22HB (hexToInt '29')) << 8) | result)
  result = (((i2cGet LPS22HB (hexToInt '2A')) << 16) | result)
  return result
}

to lps22hb_airPressureMbar {
  return (('_lps22hb_rawPressure') / 4096)
}

to lps22hb_airPressurePSI {
  return (('_lps22hb_rawPressure') / 28241)
}

to lps22hb_altitudeCentimeters {
  return (('_lps22hb_altitudeMillimeters') / 10)
}

to lps22hb_altitudeFeet {
  return (('_lps22hb_altitudeMillimeters') / 305)
}

to lps22hb_setBaseAltitude baseMeters {
  local 'total' 0
  comment 'Start regular sampling with filtering. Sampling rate is 75/9.'
  local 'LPS22HB' (hexToInt '5C')
  i2cSet LPS22HB (hexToInt '10') (hexToInt '58')
  waitMillis 300
  repeat 20 {
    total += ('_lps22hb_rawPressure')
    waitMillis 1
  }
  _lps22hb_basePressure = (total / 20)
  _lps22hb_baseAltitude = baseMeters
}

to lps22hb_setBasePressure basePressureMBar baseMeters {
  _lps22hb_basePressure = ((basePressureMBar * 4096) / 10)
  _lps22hb_baseAltitude = baseMeters
}

to lps22hb_temperature {
  local 'LPS22HB' (hexToInt '5C')
  i2cSet LPS22HB (hexToInt '11') 1
  waitMillis 1
  local 'result' (i2cGet LPS22HB (hexToInt '2B'))
  result = (((i2cGet LPS22HB (hexToInt '2C')) << 8) | result)
  if (result >= 32768) {
    result = (result - 65536)
  }
  if ('Databot' == (boardType)) {
    comment 'Adjust for extra heat from PC board'
    result += -1230
  }
  return (result / 100)
}

module 'Barometric Pressure (BMX280)' Input
author 'JosÃ© Garcia Yeste'
version 1 3 
description 'Provides support for the BME280 and BMP280 barometric pressure sensors. These sensors measure temperature, pressure and, in the case of BME280, also humidity.'
variables _bmxAddr _bme280coefficients _bmx280_baseAltitude _bmx280_basePressure 

  spec 'r' 'bmx280 temperature' 'bmx280 temperature'
  spec 'r' 'bmx280 pressure' 'bmx280 pressure (Pa)'
  spec 'r' 'bme280 humidity' 'bme280 humidity'
  space
  spec ' ' 'bmx280_setBaseAltitude' 'bmx280 set base altitude _ meters' 'num' 0
  spec 'r' 'bmx280_altitudeCentimeters' 'bmx280 altitude (cm)'
  spec 'r' 'bmx280_altitudeFeet' 'bmx280 altitude (feet)'
  space
  spec 'r' 'bmp280 connected' 'bmp280 connected'
  spec 'r' 'bme280 connected' 'bme280 connected'
  space
  spec ' ' '_bmx280_initAddr' '_bmx280_initAddr'
  spec ' ' '_bmx280 setup' '_bmx280 setup'
  spec ' ' '_bme280 read humidity coefficients' '_bme280 read humidity coefficients'
  spec 'r' '_bmx280 temperature' '_bmx280 temperature'

to '_bme280 read humidity coefficients' {
  if ('bme280 connected') {
    i2cSet _bmxAddr (hexToInt 'F2') (0 | 7)
    comment 'Read humidity coefficients'
    atPut 13 _bme280coefficients (i2cGet _bmxAddr (hexToInt 'A1'))
    atPut 14 _bme280coefficients (((i2cGet _bmxAddr (hexToInt 'E2')) << 8) | (i2cGet _bmxAddr (hexToInt 'E1')))
    atPut 15 _bme280coefficients (i2cGet _bmxAddr (hexToInt 'E3'))
    atPut 16 _bme280coefficients (((i2cGet _bmxAddr (hexToInt 'E4')) << 4) | ((i2cGet _bmxAddr (hexToInt 'E5')) & 15))
    atPut 17 _bme280coefficients (((i2cGet _bmxAddr (hexToInt 'E6')) << 4) | (((i2cGet _bmxAddr (hexToInt 'E5')) >> 4) & 15))
    atPut 18 _bme280coefficients (i2cGet _bmxAddr (hexToInt 'E7'))
  }
}

to '_bmx280 setup' {
  '_bmx280_initAddr'
  _bme280coefficients = (newList 18)
  comment 'Read temperature coefficients'
  local 'reg' (hexToInt '88')
  for i 3 {
    atPut i _bme280coefficients (((i2cGet _bmxAddr (reg + 1)) << 8) | (i2cGet _bmxAddr reg))
    reg += 2
  }
  comment 'Read pressure coefficients'
  local 'reg' (hexToInt '8E')
  for i 9 {
    atPut (i + 3) _bme280coefficients (((i2cGet _bmxAddr (reg + 1)) << 8) | (i2cGet _bmxAddr reg))
    reg += 2
  }
  '_bme280 read humidity coefficients'
  comment 'Most are signed coefs'
  for i 18 {
    if (and ((at i _bme280coefficients) > 32768) (('[data:find]' i ('[data:makeList]' 1 4 13 15)) < 0)) {atPut i _bme280coefficients ((at i _bme280coefficients) - 65536)}
  }
  comment 'Cfg: temp << 5 & pres << 2 & sensor mode  '
  i2cSet _bmxAddr (hexToInt 'F4') (((5 << 5) | (5 << 2)) | 3)
}

to '_bmx280 temperature' {
  if (_bme280coefficients == 0) {'_bmx280 setup'}
  '[sensors:i2cWrite]' _bmxAddr (hexToInt 'FA')
  local 'data' (newList 3)
  atPut 1 data 3
  '[sensors:i2cRead]' _bmxAddr data
  local 'r' ((((at 1 data) << 12) | ((at 2 data) << 4)) | (((at 3 data) >> 4) & 15))
  local 'v1' ((((r >> 3) - ((at 1 _bme280coefficients) << 1)) * (at 2 _bme280coefficients)) >> 11)
  local 'v2' ((r >> 4) - (at 1 _bme280coefficients))
  v2 = ((((v2 * v2) >> 12) * (at 3 _bme280coefficients)) >> 14)
  return (v1 + v2)
}

to '_bmx280_altitudeMillimeters' {
  if (_bmx280_basePressure == 0) {
    comment 'if base altitude not set, use zero (useful for relative measurments)' ,
    bmx280_setBaseAltitude 0
  }
  mmChange = ('[misc:pressureToAltitude]' _bmx280_basePressure ('bmx280 pressure'))
  return ((1000 * baseMeters) + mmChange)
}

to '_bmx280_initAddr' {
  if (_bmxAddr != 0) {return}
  if ((i2cGet (hexToInt '76') 0) >= 0) {
    _bmxAddr = (hexToInt '76')
  } ((i2cGet (hexToInt '77') 0) >= 0) {
    _bmxAddr = (hexToInt '77')
  } else {
    _bmxAddr = 0
    sayIt 'No BMP280 or BME280 connected'
    stopTask
  }
}

to 'bme280 connected' {
  '_bmx280_initAddr'
  return ((i2cGet _bmxAddr (hexToInt 'D0')) == (hexToInt '60'))
}

to 'bme280 humidity' {
  local 't' ('_bmx280 temperature')
  local 'r' (((i2cGet _bmxAddr (hexToInt 'FD')) << 8) | (i2cGet _bmxAddr (hexToInt 'FE')))
  local 'v1' (t - 76800)
  v1 = (((((r << 14) - ((at 16 _bme280coefficients) << 20)) - (((at 17 _bme280coefficients) * v1) + 16384)) >> 15) * (((((longMult ((v1 * (at 18 _bme280coefficients)) >> 10) (((v1 * (at 15 _bme280coefficients)) >> 11) + 32768) 10) + 2097152) * (at 14 _bme280coefficients)) + 8192) >> 14))
  v1 = (v1 - (((((v1 >> 15) * (v1 >> 15)) >> 7) * (at 13 _bme280coefficients)) >> 4))
  v1 = (maximum 0 (minimum v1 419430400))
  v1 = (v1 >> 12)
  return ((v1 * 100) / 1024)
}

to 'bmp280 connected' {
  '_bmx280_initAddr'
  local 'value' (i2cGet _bmxAddr (hexToInt 'D0'))
  return (and (value >= (hexToInt '56')) (value <= (hexToInt '58')))
}

to 'bmx280 pressure' {
  local 't' ('_bmx280 temperature')
  '[sensors:i2cWrite]' _bmxAddr (hexToInt 'F7')
  local 'data' (newList 3)
  atPut 1 data 3
  '[sensors:i2cRead]' _bmxAddr data
  local 'r' ((((at 1 data) << 12) | ((at 2 data) << 4)) | (((at 3 data) >> 4) & 15))
  local 'v1' ((t >> 1) - 64000)
  local 'v2' ((((v1 >> 2) * (v1 >> 2)) >> 11) * (at 9 _bme280coefficients))
  v2 += ((v1 * (at 8 _bme280coefficients)) << 1)
  v2 = ((v2 >> 2) + ((at 7 _bme280coefficients) << 16))
  v1 = (((((at 6 _bme280coefficients) * (((v1 >> 2) * (v1 >> 2)) >> 13)) >> 3) + (((at 5 _bme280coefficients) * v1) >> 1)) >> 18)
  v1 = (longMult (32768 + v1) (at 4 _bme280coefficients) 15)
  if (v1 == 0) {
    return 0
  } else {
    comment 'p = (((U32_t)(((S32_t)1048576)-adc_P)-(var2>>12)))*3125;
p = (p /(U32_t)var1) * 2;'
    local 'p' (((((1048576 - r) - (v2 >> 12)) * 1250) / v1) * 5)
    v1 = (longMult (at 12 _bme280coefficients) (longMult (p >> 3) (p >> 3) 13) 12)
    v2 = (longMult (p >> 2) (at 11 _bme280coefficients) 13)
    p += (((v1 + v2) + (at 10 _bme280coefficients)) >> 4)
    return p
  }
}

to 'bmx280 temperature' {
  return (((('_bmx280 temperature') * 5) + 128) >> 8)
}

to bmx280_altitudeCentimeters {
  return (('_bmx280_altitudeMillimeters') / 10)
}

to bmx280_altitudeFeet {
  return (('_bmx280_altitudeMillimeters') / 305)
}

to bmx280_setBaseAltitude baseMeters {
  local 'total' 0
  repeat 20 {
    total += ('bmx280 pressure')
    waitMillis 1
  }
  _bmx280_basePressure = (total / 20)
  _bmx280_baseAltitude = baseMeters
}

module 'Button Events' Input
author MicroBlocks
version 1 0
description 'Provides blocks to detect press, long press and double press events on buttons.'
tags event button double long press

variables _buttons

	spec 'r' 'button double pressed' 'button _ double pressed' 'auto' 'A'
	spec 'r' 'button long pressed' 'button _ long pressed' 'auto' 5
	spec 'r' 'button pressed' 'button _ pressed' 'auto' 5
	spec 'r' '_button' '_button _' 'auto' 10
	spec ' ' '_updateButtons' '_updateButtons'
	spec 'r' '_read button' '_read button _' 'auto' 10

to '_button' 'pin or name' {
  '_updateButtons'
  for 'each button' _buttons {
    if ((at 1 (v 'each button')) == (v 'pin or name')) {return (v 'each button')}
  }
  comment 'This button has not been initialized. Let''s add it.'
  local 'new button' ('[data:makeList]' (v 'pin or name') '' '' 'waiting')
  '[data:addLast]' (v 'new button') _buttons
  return (v 'new button')
}

to '_read button' 'pin or name' {
  if ((v 'pin or name') == 'A') {
    return (buttonA)
  } ((v 'pin or name') == 'B') {
    return (buttonB)
  } else {
    return (digitalReadOp (v 'pin or name'))
  }
}

to '_updateButtons' {
  if (_buttons == 0) {_buttons = ('[data:makeList]')}
  for button _buttons {
    local 'currently pressed' ('_read button' (at 1 button))
    local 'previous state' (at 4 button)
    if (and ((v 'previous state') == 'waiting') (v 'currently pressed')) {
      comment 'save state change time'
      atPut 2 button (millisOp)
      atPut 3 button (v 'currently pressed')
      atPut 4 button 'pressed'
    } (and ((v 'previous state') == 'pressed') (not (v 'currently pressed'))) {
      local 'press time' ((millisOp) - (at 2 button))
      comment 'There''s been a press. Let''s check how long it was.'
      if ((v 'press time') > 500) {
        atPut 4 button 'long press'
      } ((v 'press time') > 250) {
        atPut 4 button 'single press'
      } else {
        comment 'This is an internal intermediate state.
It could turn out to be a single press or a double press.'
        atPut 2 button (millisOp)
        atPut 4 button 'short press'
      }
    } (and ((v 'previous state') == 'short press') (v 'currently pressed')) {
      atPut 4 button 'double press'
    } (and (and ((v 'previous state') == 'short press') (not (v 'currently pressed'))) (((millisOp) - (at 2 button)) > 250)) {
      atPut 4 button 'single press'
    } (and ((v 'previous state') == 'double press handled') (not (v 'currently pressed'))) {
      comment 'We only go back to "waiting" after a double press if the event has been handled
and the user has released the button. Otherwise we''ll cause false "single press"
positives.'
      atPut 4 button 'waiting'
    }
  }
}

to 'button double pressed' 'pin or name' {
  local 'button' ('_button' (v 'pin or name'))
  local 'state' (at 4 button)
  if (state == 'double press') {
    comment 'We only go back to "waiting" after a double press if the event has been handled
and the user has released the button. Otherwise we''ll cause false "single press"
positives.'
    atPut 4 button 'double press handled'
    return (booleanConstant true)
  }
  return (booleanConstant false)
}

to 'button long pressed' 'pin or name' {
  local 'button' ('_button' (v 'pin or name'))
  local 'state' (at 4 button)
  if (state == 'long press') {
    atPut 4 button 'waiting'
    return (booleanConstant true)
  }
  return (booleanConstant false)
}

to 'button pressed' 'pin or name' {
  local 'button' ('_button' (v 'pin or name'))
  local 'state' (at 4 button)
  if (state == 'single press') {
    atPut 4 button 'waiting'
    return (booleanConstant true)
  }
  return (booleanConstant false)
}

module 'Color (TCS34725)' Input
author 'JosÃ© GarcÃ­a Yeste'
version 1 4 
tags sensor color 
description 'Support for the TCS34725 RGB color sensor.

Tested with:
https://www.dfrobot.com/product-1546.html
https://www.ebay.es/itm/323902408493 
'
variables '_TCS34725 initalized' 

  spec 'r' 'TCS34725 connected' 'TCS34725 connected'
  spec 'r' 'TCS34725 rgb' 'TCS34725 rgb'
  spec 'r' 'TCS34725 luminance' 'TCS34725 luminance'
  spec 'r' 'color' 'color _ name' 'color'
  spec ' ' '_TCS34725 setup' '_TCS34725 setup'
  spec 'r' '_TCS34725 raw' '_TCS34725 raw'

to 'TCS34725 connected' {
  local 'id' (i2cGet (hexToInt '29') (hexToInt '92'))
  comment '0x4D for TCS34727 (untested)'
  return (or (id == (hexToInt '44')) (id == (hexToInt '4D')))
}

to 'TCS34725 luminance' {
  local 'crgb' ('_TCS34725 raw')
  local 'r' (at 2 crgb)
  local 'g' (at 3 crgb)
  local 'b' (at 4 crgb)
  comment '(-0.32466 * r) + (1.57837 * g) + (-0.73191 * b);'
  return (maximum 0 ((((r * -3246) + (g * 15784)) + (b * -7319)) / 10000))
}

to 'TCS34725 rgb' {
  local 'raw' ('_TCS34725 raw')
  local 'rgb' (newList 3)
  for i 3 {
    atPut i rgb (minimum ((at (i + 1) raw) / 14) 255)
  }
  return ((((at 1 rgb) << 16) | ((at 2 rgb) << 8)) | (at 3 rgb))
}

to '_TCS34725 raw' {
  '_TCS34725 setup'
  comment 'read 8 bytes c,r,g,b'
  local 'crgb' (newList 8)
  if ('TCS34725 connected') {
    '[sensors:i2cWrite]' (hexToInt '29') (hexToInt '94')
    '[sensors:i2cRead]' (hexToInt '29') crgb
    waitMillis 1
    atPut 1 crgb (((at 2 crgb) << 8) | (at 1 crgb))
    atPut 2 crgb (((at 4 crgb) << 8) | (at 3 crgb))
    atPut 3 crgb (((at 6 crgb) << 8) | (at 5 crgb))
    atPut 4 crgb (((at 8 crgb) << 8) | (at 7 crgb))
  }
  waitMillis 50
  return crgb
}

to '_TCS34725 setup' {
  comment 'https://github.com/DFRobot/DFRobot_TCS34725'
  if ((v '_TCS34725 initialized') == 0) {
    comment 'setIntegrationTime 50 ms (0xEB)'
    i2cSet (hexToInt '29') (hexToInt '81') (hexToInt 'EB')
    comment 'setGain 4X (0x01)'
    i2cSet (hexToInt '29') (hexToInt '8F') 1
    comment 'enable'
    i2cSet (hexToInt '29') (hexToInt '80') 1
    waitMillis 3
    i2cSet (hexToInt '29') (hexToInt '80') 3
    '_TCS34725 initialized' = 1
  }
}

to color color {
  local 'r' ((color >> 16) & 255)
  local 'g' ((color >> 8) & 255)
  local 'b' (color & 255)
  local 'min' (minimum r g b)
  local 'max' (maximum r g b)
  if (max < 50) {
    return 'Black'
  }
  if (min > 185) {
    return 'White'
  }
  if (max == r) {
    local 'l' ((r * 2) / 3)
    if (and (g < l) (b < l)) {
      return 'Red'
    }
    if (g < l) {
      return 'Magenta'
    }
    if (b < l) {
      return 'Yellow'
    }
  }
  if (max == g) {
    local 'l' ((g * 2) / 3)
    if (and (r < l) (b < l)) {
      return 'Green'
    }
    if (r < l) {
      return 'Cyan'
    }
    if (b < l) {
      return 'Yellow'
    }
  }
  if (max == b) {
    local 'l' ((b * 2) / 3)
    if (and (r < l) (g < l)) {
      return 'Blue'
    }
    if (r < l) {
      return 'Cyan'
    }
    if (g < l) {
      return 'Magenta'
    }
  }
  return ''
}

module 'Distance (HC-SR04)' Input
author 'Joan GuillÃ©n & Josep FerrÃ ndiz'
version 1 2 
tags sensor 'hc-sr04' distance ultrasound 
description 'Support for the HC-SR04 ultrasound distance sensor.'
variables _sr04_last 

  spec 'r' 'distance (cm)' 'distance (cm) trigger _ echo _' 'num num' 2 4
  spec 'r' 'sr04_distanceOnePin' 'distance (cm) pin _' 'num' 0

to 'distance (cm)' trig ech {
  comment 'Contributed by Joan GuillÃ©n and Josep FerrÃ ndiz'
  digitalWriteOp trig false
  waitMicros 2
  digitalWriteOp trig true
  waitMicros 50
  digitalWriteOp trig false
  local 'start' (microsOp)
  waitUntil (or (not (digitalReadOp ech)) (((microsOp) - start) > 23320))
  waitUntil (or (digitalReadOp ech) (((microsOp) - start) > 23320))
  if (((microsOp) - start) > 23320) {
    comment 'Distance sensor not ready; return the last distance reading'
    return _sr04_last
  }
  comment 'Pulse sent. Measure time until echo is detected.'
  start = (microsOp)
  waitUntil (or (not (digitalReadOp ech)) (((microsOp) - start) > 23320))
  _sr04_last = ((10 * ((microsOp) - start)) / 583)
  comment 'Leave some time for reverberations to die away.'
  waitMillis 10
  if (_sr04_last == 0) {
    zeroCount += 1
  }
  return _sr04_last
}

to sr04_distanceOnePin pin {
  return ('distance (cm)' pin pin)
}

module 'Distance (VL53L0X)' Input
author 'JosÃ© GarcÃ­a Yeste'
version 1 2 
tags sensor distance 
description 'Support for VL53L0X distance sensor.
TOF laser based.
Range 3-200mm.

Tested on:
https://shop.m5stack.com/products/tof-sensor-unit (take Kapton tape on sensor!)
'

  spec 'r' 'VL53L0X connected' 'VL53L0X connected'
  spec 'r' 'VL53L0X distance (mm)' 'VL53L0X distance (mm)'

to 'VL53L0X connected' {
  return ((i2cGet 41 (hexToInt 'C0')) == (hexToInt 'EE'))
}

to 'VL53L0X distance (mm)' {
  i2cSet 41 0 1
  waitMillis 70
  if (((i2cGet 41 (hexToInt '14')) & 1) == 1) {
    '[sensors:i2cWrite]' 41 ('[data:makeList]' (hexToInt '14'))
    local 'buf' (newList 12)
    '[sensors:i2cRead]' 41 buf
    if ((at 1 buf) == 95) {
      return (((at 11 buf) << 8) | (at 12 buf))
    } else {
      return -1
    }
  } else {
    return -2
  }
}

module 'Distance (VL53L1x)' Input
author 'JosÃ© GarcÃ­a Yeste'
version 1 0 
tags sensor distance 
description 'Support for VL53L1x distance sensor.
Long distance ranging Time-of-Flight sensor.
Emitter: 940 nm invisible laser (Class1).

Based on https://github.com/pololu/vl53l1x-arduino
'
variables '_VL53L1x initialized' 

	spec 'r' 'VL53L1x connected' 'VL53L1x connected'
	spec 'r' 'VL53L1x distance (mm)' 'VL53L1x distance (mm)'
	spec ' ' 'VL53L1x set distance mode long' 'VL53L1x set distance mode long'
	spec ' ' 'VL53L1x set distance mode medium' 'VL53L1x set distance mode medium'
	spec ' ' 'VL53L1x set distance mode short' 'VL53L1x set distance mode short'
	spec ' ' '_VL53L1x setup' '_VL53L1x setup'
	spec ' ' '_VL53L1x write reg' '_VL53L1x write reg _ byte _' 'auto auto' 0 0
	spec ' ' '_VL53L1x write reg 32' '_VL53L1x write reg _ int32 _' 'auto auto' 0 0
	spec 'r' '_VL53L1x read reg' '_VL53L1x read 16bit reg _' 'auto' 0

to 'VL53L1x connected' {
  return (('_VL53L1x read reg' (hexToInt '010F')) == (hexToInt 'EACC'))
}

to 'VL53L1x distance (mm)' {
  '_VL53L1x setup'
  i2cSet 41 0 (hexToInt '89')
  local 'data' (newList 17)
  '[sensors:i2cRead]' 41 data
  local 'status' (at 1 data)
  if (status == 9) {
    local 'range' (((at 14 data) << 8) | (at 15 data))
    range = (((range * 2011) + 1024) >> 11)
    return range
  } else {
    return (0 - status)
  }
}

to 'VL53L1x set distance mode long' {
  '_VL53L1x write reg' (hexToInt '0060') 15
  '_VL53L1x write reg' (hexToInt '0063') 13
  '_VL53L1x write reg' (hexToInt '0069') (hexToInt 'B8')
  '_VL53L1x write reg' (hexToInt '0078') 15
  '_VL53L1x write reg' (hexToInt '0079') 13
  '_VL53L1x write reg' (hexToInt '007A') 14
  '_VL53L1x write reg' (hexToInt '007B') 14
}

to 'VL53L1x set distance mode medium' {
  '_VL53L1x write reg' (hexToInt '0060') 11
  '_VL53L1x write reg' (hexToInt '0063') 9
  '_VL53L1x write reg' (hexToInt '0069') (hexToInt '78')
  '_VL53L1x write reg' (hexToInt '0078') 11
  '_VL53L1x write reg' (hexToInt '0079') 9
  '_VL53L1x write reg' (hexToInt '007A') 10
  '_VL53L1x write reg' (hexToInt '007B') 10
}

to 'VL53L1x set distance mode short' {
  '_VL53L1x write reg' (hexToInt '0060') 7
  '_VL53L1x write reg' (hexToInt '0063') 5
  '_VL53L1x write reg' (hexToInt '0069') (hexToInt '38')
  '_VL53L1x write reg' (hexToInt '0078') 7
  '_VL53L1x write reg' (hexToInt '0079') 5
  '_VL53L1x write reg' (hexToInt '007A') 6
  '_VL53L1x write reg' (hexToInt '007B') 6
}

to '_VL53L1x read reg' reg {
  local 'reg' reg
  i2cSet 41 (reg >> 8) (reg & 255)
  local 'data' (newList 2)
  '[sensors:i2cRead]' 41 data
  return (((at 1 data) << 8) | (at 2 data))
}

to '_VL53L1x setup' {
  if ((v 'VL53L1x initialized') == 0) {
    'VL53L1x set distance mode long'
    comment 'read every 50 ms'
    '_VL53L1x write reg 32' (hexToInt '006C') (50 * ('_VL53L1x read reg' (hexToInt '00DE')))
    '_VL53L1x write reg' (hexToInt '0086') 1
    '_VL53L1x write reg' (hexToInt '0087') (hexToInt '40')
    '_VL53L1x initialized' = 1
  }
}

to '_VL53L1x write reg' reg byte {
  local 'data' (newList 3)
  atPut 1 data (reg >> 8)
  atPut 2 data (reg & 255)
  atPut 3 data byte
  '[sensors:i2cWrite]' 41 data
}

to '_VL53L1x write reg 32' reg value {
  local 'data' (newList 6)
  atPut 1 data (reg >> 8)
  atPut 2 data (reg & 255)
  atPut 3 data (value >> 24)
  atPut 4 data (value >> 16)
  atPut 5 data (value >> 8)
  atPut 6 data (value & 255)
  '[sensors:i2cWrite]' 41 data
}

module 'Distance (VL6180x)' Input
author 'JosÃ© GarcÃ­a Yeste'
version 1 0 
tags sensor distance 
description 'Support for VL6180x distance sensor.

Based on:
https://github.com/adafruit/Adafruit_VL6180X'

variables '_vl6180x initalized' 

	spec 'r' 'vl6180x connected' 'vl8161 connected'
	spec 'r' 'vl6180x read mm' 'vl6180x read (mm)'
	spec 'r' 'vl6180x status' 'vl6180x status'
	spec ' ' '_vl6180x setup' '_vl6180x setup'
	spec ' ' '_vl6180x setup1' '_vl6180x setup1'
	spec ' ' '_vl6180x setup2' '_vl6180x setup2'
	spec 'r' '_vl6180x read register' '_vl6180x read register _' 'auto' 0
	spec ' ' '_vl6180x write byte' '_vl6180x write register _ to _' 'auto auto' 0 0


to 'vl6180x status' {
  return (('_vl6180x read register' (hexToInt '4D')) >> 4)
}

to '_vl6180x read register' reg {
  i2cSet (hexToInt '29') (reg >> 8) reg
  local 'value' ('[data:makeList]' 0)
  '[sensors:i2cRead]' (hexToInt '29') value
  return (at 1 value)
}

to '_vl6180x setup' {
  if ((v '_vl6180x initalized') == 0) {if ('vl6180x connected') {
    '_vl6180x setup1'
    '_vl6180x setup2'
    '_vl6180x write byte' (hexToInt '16') 0
    '_vl6180x initalized' = 0
  }}
}

to '_vl6180x setup1' {
  local 'regs' ('[data:makeList]' (hexToInt '207') (hexToInt '208') (hexToInt '96') (hexToInt '97') (hexToInt 'E3') (hexToInt 'E4') (hexToInt 'E5') (hexToInt 'E6') (hexToInt 'E7') (hexToInt 'F5') (hexToInt 'D9') (hexToInt 'DB') (hexToInt 'DC') (hexToInt 'DD') (hexToInt '9F') (hexToInt 'A3') (hexToInt 'B7') (hexToInt 'BB') (hexToInt 'B2') (hexToInt 'CA') (hexToInt '198') (hexToInt '1B0') (hexToInt '1AD') (hexToInt 'FF') (hexToInt '100') (hexToInt '199') (hexToInt '1A6') (hexToInt '1AC') (hexToInt '1A7') (hexToInt '30'))
  local 'values' ('[data:makeList]' 1 1 0 (hexToInt 'FD') 0 4 2 1 3 2 5 (hexToInt 'CE') 3 (hexToInt 'F8') 0 (hexToInt '3C') 0 (hexToInt '3C') 9 9 1 (hexToInt '17') 0 5 5 5 (hexToInt '1B') (hexToInt '3E') (hexToInt '1F') 0)
  for i (size regs) {
    '_vl6180x write byte' (at i regs) (at i values)
  }
}

to '_vl6180x setup2' {
  '_vl6180x write byte' (hexToInt '11') (hexToInt '10')
  '_vl6180x write byte' (hexToInt '10A') (hexToInt '30')
  '_vl6180x write byte' (hexToInt '3F') (hexToInt '46')
  '_vl6180x write byte' (hexToInt '31') (hexToInt 'FF')
  '_vl6180x write byte' (hexToInt '40') (hexToInt '63')
  '_vl6180x write byte' (hexToInt '2E') (hexToInt '1')
  '_vl6180x write byte' (hexToInt '1B') (hexToInt '9')
  '_vl6180x write byte' (hexToInt '3E') (hexToInt '31')
  '_vl6180x write byte' (hexToInt '14') (hexToInt '24')
}

to '_vl6180x write byte' reg value {
  '[sensors:i2cWrite]' (hexToInt '29') ('[data:makeList]' (reg >> 8) reg value)
  waitMicros 10
}

to 'vl6180x read mm' {
  if ((v '_vl6180x initalized') == 0) {'_vl6180x setup'}
  if ('vl6180x connected') {
    waitUntil ((('_vl6180x read register' (hexToInt '4D')) & 1) != 0)
    '_vl6180x write byte' (hexToInt '18') 1
    waitUntil ((('_vl6180x read register' (hexToInt '4F')) & 4) != 0)
    local 'result' ('_vl6180x read register' (hexToInt '62'))
    '_vl6180x write byte' (hexToInt '15') 7
    return result
  }
}

to 'vl6180x connected' {
  return (('_vl6180x read register' 0) == 180)
}

module 'Gas (BME680)' Input
author 'JosÃ© GarcÃ­a Yeste'
version 1 0 
description 'Suport for Bosch BME680 sensor
Temperature, Humidity, Air Pressure and Gas Sensor

Based on https://github.com/Zanduino/BME680

Tested on TeslaLAB Galileo Univestiy Board
'
variables _bme680 _bme680_last _bme680_raw _bme680_t _bme680_p _bme680_h _bme680_g 

  spec ' ' '_bme680 setup' '_bme680 setup'
  spec 'r' 'bme680 connected' 'bme680 connected'
  spec 'r' '_bme680 read int' '_bme680 read int16 _' 'auto' 0
  spec 'r' '_bme680 read word' '_bme680 read word _' 'auto' 0
  spec ' ' '_bme680 read raw' '_bme680 read raw'
  spec 'r' 'bme680 temperature' 'bme680 temperature (Â°C x10)'
  spec 'r' '_bm680 read int8' '_bm680 read int8 _' 'auto' 0
  spec 'r' 'bme680 pressure' 'bme680 pressure (mBar x10)'
  spec ' ' '_bme680_set_bits' '_bme680_set_bits reg _ mask _ pos _ val _' 'auto auto auto auto' 0 0 0 0
  spec 'r' '_bme680 temperature' '_bme680 temperature'
  spec 'r' 'bme680 humidity' 'bme680 humidity (% x10)'
  spec ' ' '_bm680 read humidity coefficients' '_bm680 read humidity coefficients'
  spec ' ' '_bme680 read pressure coefficients' '_bme680 read pressure coefficients'
  spec ' ' '_bme680 read temperature coefficients' '_bme680 read temperature coefficients'
  spec ' ' '_read gas coefficients' '_read gas coefficients'
  spec 'r' 'bme680 gas' 'bme680 gas resistance (mÎ© x10)'
  spec ' ' 'bme680 set gas' 'bme680 set gas to _ degrees for _ millisecs' 'auto auto' 320 150
  spec ' ' 'bme680 set address to' 'bme680 set address to _' 'auto' 119

to '_bm680 read humidity coefficients' {
  _bme680_h = ('[data:makeList]')
  local 'h' (i2cGet _bme680 ((hexToInt 'E1') + 1))
  '[data:addLast]' (((i2cGet _bme680 ((hexToInt 'E1') + 2)) << 4) | ((h >> 4) & (hexToInt '0F'))) _bme680_h
  '[data:addLast]' (((i2cGet _bme680 (hexToInt 'E1')) << 4) | ((h >> 4) & (hexToInt '0F'))) _bme680_h
  '[data:addLast]' ('_bm680 read int8' 28) _bme680_h
  '[data:addLast]' ('_bm680 read int8' 29) _bme680_h
  '[data:addLast]' ('_bm680 read int8' 30) _bme680_h
  '[data:addLast]' (i2cGet _bme680 ((hexToInt 'E1') + (31 - 25))) _bme680_h
  '[data:addLast]' ('_bm680 read int8' 32) _bme680_h
}

to '_bm680 read int8' index {
  if (index > 25) {
    local 'reg' ((hexToInt 'E1') + (index - 25))
  } else {
    local 'reg' ((hexToInt '89') + index)
  }
  local 'val' (i2cGet _bme680 reg)
  if (val > 128) {
    return (val - 256)
  } else {
    return val
  }
}

to '_bme680 read int' index {
  if (index > 25) {
    local 'reg' ((hexToInt 'E1') + (index - 25))
  } else {
    local 'reg' ((hexToInt '89') + index)
  }
  local 'val' (((i2cGet _bme680 (reg + 1)) << 8) | (i2cGet _bme680 reg))
  if (val > 32768) {
    return (val - 65536)
  } else {
    return val
  }
  local 'var' 0
}

to '_bme680 read pressure coefficients' {
  _bme680_p = ('[data:makeList]')
  '[data:addLast]' ('_bme680 read word' 5) _bme680_p
  '[data:addLast]' ('_bme680 read int' 7) _bme680_p
  '[data:addLast]' ('_bm680 read int8' 9) _bme680_p
  '[data:addLast]' ('_bme680 read int' 11) _bme680_p
  '[data:addLast]' ('_bme680 read int' 13) _bme680_p
  '[data:addLast]' ('_bm680 read int8' 16) _bme680_p
  '[data:addLast]' ('_bm680 read int8' 15) _bme680_p
  '[data:addLast]' ('_bme680 read int' 19) _bme680_p
  '[data:addLast]' ('_bme680 read int' 21) _bme680_p
  '[data:addLast]' ('_bm680 read int8' 23) _bme680_p
}

to '_bme680 read raw' {
  '_bme680 setup'
  if (or (_bme680_raw == 0) ((millisOp) > (_bme680_last + 1000))) {
    comment 'forced  mode'
    '_bme680_set_bits' (hexToInt '74') 3 0 1
    repeat 3 {
      waitMillis 10
      if (((i2cGet _bme680 (hexToInt '1D')) & (hexToInt '80')) != 0) {
        _bme680_raw = (newList 15 0)
        '[sensors:i2cWrite]' _bme680 ('[data:makeList]' (hexToInt '1D'))
        '[sensors:i2cRead]' _bme680 _bme680_raw
        _bme680_last = (millisOp)
        return 0
      }
    }
  }
}

to '_bme680 read temperature coefficients' {
  _bme680_t = ('[data:makeList]')
  '[data:addLast]' ('_bme680 read int' 33) _bme680_t
  '[data:addLast]' ('_bme680 read word' 1) _bme680_t
  '[data:addLast]' ('_bm680 read int8' 3) _bme680_t
}

to '_bme680 read word' index {
  if (index > 25) {
    local 'reg' ((hexToInt 'E1') + (index - 25))
  } else {
    local 'reg' ((hexToInt '89') + index)
  }
  return (((i2cGet _bme680 (reg + 1)) << 8) | (i2cGet _bme680 reg))
}

to '_bme680 setup' {
  if (_bme680 == 0) {_bme680 = (hexToInt '77')}
  if (_bme680_last == 0) {
    comment 'soft reset'
    i2cSet _bme680 (hexToInt 'E0') (hexToInt 'B6')
    waitMillis 10
    comment 'sleep mode'
    i2cSet _bme680 (hexToInt '74') 0
    '_bme680 read temperature coefficients'
    '_bme680 read pressure coefficients'
    '_bm680 read humidity coefficients'
    '_read gas coefficients'
    comment 'humidity oversample x2'
    '_bme680_set_bits' (hexToInt '72') 7 0 2
    comment 'pressure oversample x4'
    '_bme680_set_bits' (hexToInt '74') (hexToInt '1C') 2 3
    comment 'temperature oversample x8'
    '_bme680_set_bits' (hexToInt '74') (hexToInt 'E0') 5 4
    comment 'sef filter'
    '_bme680_set_bits' (hexToInt '75') (hexToInt '1C') 2 2
    _bme680_last = (millisOp)
    waitMillis 1000
  }
}

to '_bme680 temperature' {
  '_bme680 read raw'
  local 'v1' ((((at 6 _bme680_raw) << 12) | ((at 7 _bme680_raw) << 4)) | ((at 8 _bme680_raw) >> 4))
  v1 = ((v1 >> 3) - ((at 1 _bme680_t) << 1))
  local 'v2' ((v1 * (at 2 _bme680_t)) >> 11)
  local 'v3' (((v1 >> 1) * (v1 >> 1)) >> 12)
  v3 = ((v3 * ((at 3 _bme680_t) << 4)) >> 14)
  return (v2 + v3)
}

to '_bme680_set_bits' reg mask pos val {
  local 'reg_value' (i2cGet _bme680 reg)
  if (reg_value >= 0) {
    i2cSet _bme680 reg ((reg_value & ('~' mask)) | (val << pos))
  }
}

to '_read gas coefficients' {
  _bme680_g = ('[data:makeList]')
  '[data:addLast]' ('_bm680 read int8' 37) _bme680_g
  '[data:addLast]' ('_bme680 read int' 35) _bme680_g
  '[data:addLast]' ('_bm680 read int8' 38) _bme680_g
  comment 'heat_range, heat & rng_sw_err'
  '[data:addLast]' (((i2cGet _bme680 2) & (hexToInt '30')) / 16) _bme680_g
  '[data:addLast]' (i2cGet _bme680 0) _bme680_g
  if ((at 'last' _bme680_g) > 128) {
    atPut _bme680_g _bme680_g 10
    return ((at 'last' _bme680_g) - 256)
  }
  '[data:addLast]' (((i2cGet _bme680 2) & (hexToInt 'F0')) / 16) _bme680_g
}

to 'bme680 connected' {
  if (_bme680 == 0) {
    local 'addr' (hexToInt '77')
  } else {
    addr = _bme680
  }
  return ((i2cGet addr (hexToInt 'D0')) == (hexToInt '61'))
}

to 'bme680 gas' {
  '_bme680 read raw'
  if ((i2cGet _bme680 (hexToInt '71')) == 0) {
    'bme680 set gas' 320 150
  }
  local 'adc' (((at 14 _bme680_raw) << 2) | ((at 15 _bme680_raw) >> 6))
  if (adc > 0) {
    local 'range' (((at 15 _bme680_raw) & (hexToInt '0F')) + 1)
    return (('[misc:bme680GasResistance]' adc range (at 6 _bme680_g)) / 10)
  } else {
    return 0
  }
}

to 'bme680 humidity' {
  local 't' (('bme680 temperature') * 10)
  local 'v1' (((at 9 _bme680_raw) << 8) | (at 10 _bme680_raw))
  v1 = ((v1 - ((at 1 _bme680_h) << 4)) - (((t * (at 3 _bme680_h)) / 100) >> 1))
  local 'v2' (longMult (at 2 _bme680_h) ((((t * (at 4 _bme680_h)) / 100) + (((t * ((t * (at 5 _bme680_h)) / 100)) >> 6) / 100)) + 16384) 10)
  local 'v3' (v1 * v2)
  local 'v4' ((at 6 _bme680_h) << 7)
  v4 = ((v4 + ((t * (at 7 _bme680_h)) / 100)) >> 4)
  local 'v5' (longMult (v3 >> 14) (v3 >> 14) 10)
  local 'v6' (longMult v4 v5 1)
  return ((maximum 0 (minimum 100000 (longMult ((v3 + v6) >> 10) 1000 12))) / 100)
}

to 'bme680 pressure' {
  local 'v1' ((('_bme680 temperature') >> 1) - 64000)
  local 'v2' (((((v1 >> 2) * (v1 >> 2)) >> 11) * (at 6 _bme680_p)) >> 2)
  v2 = (v2 + ((v1 * (at 5 _bme680_p)) << 1))
  v2 = ((v2 >> 2) + ((at 4 _bme680_p) << 16))
  v1 = ((((((v1 >> 2) * (v1 >> 2)) >> 13) * ((at 3 _bme680_p) << 5)) >> 3) + (((at 2 _bme680_p) * v1) >> 1))
  v1 = (v1 >> 18)
  v1 = (longMult (32768 + v1) (at 1 _bme680_p) 15)
  local 'p' (1048576 - ((((at 3 _bme680_raw) << 12) | ((at 4 _bme680_raw) << 4)) | ((at 5 _bme680_raw) >> 4)))
  comment 'original *3125, <<1'
  p = ((p - (v2 >> 12)) * 1562)
  p = ((p / v1) << 2)
  v1 = (longMult (at 9 _bme680_p) (longMult (p >> 3) (p >> 3) 13) 12)
  v2 = (longMult (p >> 2) (at 8 _bme680_p) 13)
  local 'v3' (longMult ((p >> 8) * ((p >> 8) * (p >> 8))) (at 10 _bme680_p) 17)
  return ((p + ((((v1 + v2) + v3) + ((at 7 _bme680_p) << 7)) >> 4)) / 10)
}

to 'bme680 set address to' addr {
  _bme680 = addr
  _bme680_last = 0
  '_bme680 setup'
}

to 'bme680 set gas' degrees ms {
  local 'gas_reg' (i2cGet _bme680 (hexToInt '71'))
  if (or (degrees <= 0) (ms <= 0)) {
    comment 'Turn off gas measurements'
    i2cSet _bme680 (hexToInt '70') 8
    i2cSet _bme680 (hexToInt '71') (gas_reg & (hexToInt 'EF'))
  } else {
    i2cSet _bme680 (hexToInt '70') 0
    degrees = (maximum (minimum degrees 400) 200)
    local 'v1' ((((('bme680 temperature') / 10) * (at 3 _bme680_g)) / 1000) << 8)
    local 'v2' (((at 1 _bme680_g) + 784) * (((((((at 2 _bme680_g) + 154009) * degrees) * 5) / 100) + 3276800) / 10))
    local 'v3' (v1 + (v2 / 2))
    local 'v3' (v1 + (v2 / 2))
    local 'v4' (v3 / ((at 4 _bme680_g) + 4))
    local 'v5' ((131 * (at 5 _bme680_g)) + 65536)
    local 'heatr_res' (((((v4 / v5) - 250) * 34) + 50) / 100)
    i2cSet _bme680 (hexToInt '5A') heatr_res
    local 'factor' 0
    local 'durval' 0
    if (ms > 4032) {
      durval = (hexToInt 'FF')
    } else {
      repeatUntil (ms <= (hexToInt '3F')) {
        ms = (ms >> 1)
        if (ms > (hexToInt '3F')) {
          factor += 1
        }
      }
      durval = (ms + (factor * 64))
    }
    i2cSet _bme680 (hexToInt '70') 0
    i2cSet _bme680 (hexToInt '64') durval
    i2cSet _bme680 (hexToInt '71') (gas_reg | (hexToInt '10'))
  }
}

to 'bme680 temperature' {
  return ((((('_bme680 temperature') * 5) + 128) >> 8) / 10)
}

module 'Gas (CCS811)' Input
author 'VÃ­ctor Casado'
version 1 1 
tags voc co2 air environmental 
description 'Support for the Adafruit CCS811 indoor air quality sensor. Gives out VOC and eCO2 readings.'
variables _ccs811_wakePin _ccs811_driveMode _ccs811_deviceId _ccs811_CO2 _ccs811_TVOC 

	spec ' ' 'inicialitzar sensor pin' 'initialize CCS811 wake pin _ mode _' 'auto auto' 1 1
	spec 'r' 'update data' 'check and update data'
	spec 'r' 'CO2' 'CO2'
	spec 'r' 'TVOC' 'TVOC'
	spec 'r' '_ccs811_checkError' '_ccs811_checkError'
	spec 'r' '_ccs811_configure' '_ccs811_configure'
	spec 'r' '_ccs811_getBaseline' '_ccs811_getBaseline'
	spec 'r' '_ccs811_getError' '_ccs811_getError'
	spec ' ' '_ccs811_reset' '_ccs811_reset'
	spec 'r' '_ccs811_setBaseline' '_ccs811_setBaseline _' 'auto' ''
	spec ' ' '_ccs811_setDriveMode' '_ccs811_setDriveMode'
	spec ' ' '_ccs811_sleep' '_ccs811_sleep'
	spec ' ' '_ccs811_startApp' '_ccs811_startApp'
	spec ' ' '_ccs811_wakeUp' '_ccs811_wakeUp'

to CO2 {
  return _ccs811_CO2
}

to TVOC {
  return _ccs811_TVOC
}

to '_ccs811_checkError' {
  return (((i2cGet _ccs811_deviceId 0) & 1) == 1)
}

to '_ccs811_configure' {
  '_ccs811_reset'
  if ((i2cGet _ccs811_deviceId (hexToInt '20')) != (hexToInt '81')) {
    return 'CCS811 not found, please check wiring'
  }
  if ('_ccs811_checkError') {
    return ('[data:join]' 'Error at startup: ' ('_ccs811_getError'))
  }
  if ((i2cGet _ccs811_deviceId 0) != (hexToInt '10')) {
    return 'App not valid'
  }
  '_ccs811_startApp'
  if ('_ccs811_checkError') {
    return ('[data:join]' 'Error starting app: ' ('_ccs811_getError'))
  }
  '_ccs811_setDriveMode'
  if ('_ccs811_checkError') {
    return ('[data:join]' 'Error setting drive mode: ' ('_ccs811_getError'))
  }
  return 0
}

to '_ccs811_getBaseline' {
  '[sensors:i2cWrite]' _ccs811_deviceId ('[data:makeList]' (hexToInt '11'))
  local 'bytes' (newList 2)
  '[sensors:i2cRead]' _ccs811_deviceId bytes
  return (((at 1 bytes) << 8) | (at 2 bytes))
}

to '_ccs811_getError' {
  local 'error' ((i2cGet _ccs811_deviceId (hexToInt 'E0')) & 1)
  if (error == 1) {
    return 'WRITE_REG_INVALID'
  } ((error << 1) == 1) {
    return 'READ_REG_INVALID'
  } ((error << 2) == 1) {
    return 'MEASMODE_INVALID'
  } ((error << 3) == 1) {
    return 'MAX_RESISTANCE'
  } ((error << 4) == 1) {
    return 'HEATER_FAULT'
  } ((error << 5) == 1) {
    return 'HEATER_SUPPLY'
  }
}

to '_ccs811_reset' {
  '[sensors:i2cWrite]' _ccs811_deviceId ('[data:makeList]' (hexToInt 'FF') (hexToInt '11') (hexToInt 'E5') (hexToInt '72') (hexToInt '8A'))
  waitMillis 2
}

to '_ccs811_setBaseline' baseline {
  local 'highByte' (baseline >> 8)
  local 'lowByte' (baseline & 255)
  '[sensors:i2cWrite]' _ccs811_deviceId ('[data:makeList]' (hexToInt '11') highByte lowByte)
}

to '_ccs811_setDriveMode' {
  if (_ccs811_driveMode > 4) {_ccs811_driveMode = 4}
  local 'setting' (i2cGet _ccs811_deviceId 1)
  setting = (setting & -113)
  setting = (setting | (_ccs811_driveMode << 4))
  '[sensors:i2cWrite]' _ccs811_deviceId ('[data:makeList]' 1 setting)
}

to '_ccs811_sleep' {
  digitalWriteOp _ccs811_wakePin true
}

to '_ccs811_startApp' {
  '[sensors:i2cWrite]' _ccs811_deviceId ('[data:makeList]' (hexToInt 'F4'))
}

to '_ccs811_wakeUp' {
  digitalWriteOp _ccs811_wakePin false
  waitMillis 1
}

to 'inicialitzar sensor pin' wakePin mode {
  _ccs811_deviceId = (hexToInt '5A')
  _ccs811_wakePin = wakePin
  _ccs811_driveMode = mode
  '_ccs811_wakeUp'
  local 'configResult' ('_ccs811_configure')
  if (configResult != 0) {
    sayIt ('[data:join]' 'Error while configuring:' configResult)
  } else {
    sayIt ('[data:join]' 'Baseline: ' ('_ccs811_getBaseline'))
  }
}

to 'update data' {
  if ((i2cGet _ccs811_deviceId 0) == (hexToInt '98')) {
    '[sensors:i2cWrite]' _ccs811_deviceId ('[data:makeList]' 2)
    local 'bytes' (newList 4)
    '[sensors:i2cRead]' _ccs811_deviceId bytes
    _ccs811_CO2 = (((at 1 bytes) << 8) | (at 2 bytes))
    _ccs811_TVOC = (((at 3 bytes) << 8) | (at 4 bytes))
    return (booleanConstant true)
  }
  return (booleanConstant false)
}

module 'Gas (SCD30)' Input
author 'Markus GÃ¤lli'
version 1 0
description 'Implements the interface of the SCD30 environmental sensor
in MicroBlocks according to its spec in
https://www.sensirion.com/fileadmin/user_upload/customers/sensirion/Dokumente/9.5_CO2/Sensirion_CO2_Sensors_SCD30_Interface_Description.pdf

Allows the user to measure
- CO2 in ppm
- temperature in Â°C
- humidity in %.

To get started execute the "SCD30 read loop" block.
It starts the continuous measurement,
waits until the SCD30 could provide a new measurement,
reads the values into the respective global variables,
and displays them.

To calibrate your SCD30 quickly (in 2 minutes)
use the "SCD30 calibrate CO2 to..." block --
read its comment to get you started.

Credits to JosÃ© GarcÃ­a Yeste, the implementation of
the "SDC30 generate CRC" block is taken from his microblocks sgp30 library'
variables temperature humidity co2

	spec ' ' 'SCD30 read loop' 'SCD30 read loop'
	spec ' ' 'SCD30 calibrate in fresh air' 'SCD30 calibrate CO2 to _ ppm with ambient air pressure _' 'num num' '400' '1013'
	spec ' ' 'SCD30 send' 'SCD30 send command _ parameter _' 'num num'
	spec 'r' 'SCD30 read uint16' 'SCD30 read uint16 _' 'num'
	spec 'r' 'SGC30 generate CRC' 'generate CRC _' 'num'
	spec 'r' 'SCD30 float32 to integer' 'SCD30 float32 to integer _ _ _ _' 'num num num num'
	spec ' ' 'SCD30 start measuring with ambient pressure' 'SCD30 start measuring with ambient pressure _' 'num'
	spec ' ' 'SCD30 start measuring' 'SCD30 start measuring'
	spec ' ' 'SCD30 stop measuring' 'SCD30 stop measuring'
	spec ' ' 'SCD30 set measurement interval' 'SCD30 measure each _ second' 'num' '2'
	spec 'r' 'SCD30 measurement interval' 'SCD30 measurement interval'
	spec 'r' 'SCD30 isReady?' 'SCD30 isReady?'
	spec 'r' 'SCD30 check CRC' 'SCD30 check CRC _' 'auto'
	spec ' ' 'SCD30 read measurement' 'SCD30 read measurement'
	spec ' ' 'SCD30 start calibrating' 'SCD30 start calibrating'
	spec 'r' 'SCD30 is calibrating?' 'SCD30 is calibrating?'
	spec ' ' 'SCD30 stop calibrating' 'SCD30 stop calibrating'
	spec ' ' 'SCD30 set forced recalibration value' 'SCD30 set forced recalibration value _' 'num' '400'
	spec 'r' 'SCD30 forced recalibration value' 'SCD30 forced recalibration value'
	spec ' ' 'SCD30 set temperature offset' 'SCD30 set temperature offset _' 'num' '200'
	spec 'r' 'SCD30 temperature offset' 'SCD30 temperature offset'
	spec ' ' 'SCD30 set altitude compensation' 'SCD30 set altitude compensation _' 'num'
	spec 'r' 'SCD30 altitude compensation' 'SCD30 altitude compensation'
	spec 'r' 'SCD30 firmware' 'SCD30 firmware'
	spec ' ' 'SCD30 soft reset' 'SCD30 soft reset'

to 'SCD30 read loop' {
  'SCD30 start measuring with ambient pressure'
  'SCD30 set measurement interval' 2
  forever {
    waitUntil ('SCD30 isReady?')
    'SCD30 read measurement'
    sayIt ('[data:join]' 'CO2:' co2 'ppm, temperature:' temperature 'Â°C, humidity:' humidity '%')
  }
}

to 'SCD30 calibrate in fresh air' ppm mbar {
  comment 'Take your SCD30 to fresh air or some known CO2 concentration.
The default outside CO2 concentration is 400 ppm hence we use
this as the default value for "ppm".
Look up the current ambient air pressure in mbar --
if no value is given it defaults to 1013 mbar.

Start this script with these parameters and let it work for at least 2 minutes.
Afterwards this script will force the SCD30 to accommodate
its CO2 persistent calibration curve accordingly.

The script will continue to run afterwards and should then
show values close to the given ppm.
'
  'SCD30 set measurement interval' 2
  'SCD30 start measuring with ambient pressure' mbar
  resetTimer
  repeatUntil ((timer) > 120000) {
    waitUntil ('SCD30 isReady?')
    'SCD30 read measurement'
    sayIt 'CO2:' co2 '; seconds remaining before forced calibration:' (120 - ((timer) / 1000))
  }
  'SCD30 set forced recalibration value' ppm
  sayIt 'Recalibrated to' ('SCD30 forced recalibration value')
  forever {
    waitUntil ('SCD30 isReady?')
    'SCD30 read measurement'
    sayIt 'CO2:' co2
  }
}

to 'SCD30 send' command parameter {
  local 'cmdList' ('[data:makeList]' (command >> 8) (command & (hexToInt 'FF')))
  if (parameter != '') {
    '[data:addLast]' (parameter >> 8) cmdList
    '[data:addLast]' (parameter & (hexToInt 'FF')) cmdList
    '[data:addLast]' ('SGC30 generate CRC' parameter) cmdList
  }
  '[sensors:i2cWrite]' (hexToInt '61') cmdList
}

to 'SCD30 read uint16' command {
  'SCD30 send' command ''
  waitMillis 3
  local 'response' (newList 2)
  '[sensors:i2cRead]' (hexToInt '61') response
  local 'singleResponse' (((at 1 response) << 8) | (at 2 response))
  return singleResponse
}

to 'SGC30 generate CRC' value {
  comment 'Credits to JosÃ© GarcÃ­a Yeste, the implementation
  of this block is taken from his microblocks sgp30 library'
  local 'buf' ('[data:makeList]' (value >> 8) (value & 255))
  local 'crc' (hexToInt 'FF')
  for i (size buf) {
    crc = (crc ^ (at i buf))
    for i 8 {
      if ((crc & (hexToInt '80')) != 0) {
        crc = ((crc << 1) ^ (hexToInt '31'))
      } else {
        crc = (crc << 1)
      }
    }
  }
  return (crc & 255)
}

to 'SCD30 float32 to integer' byte1 byte2 byte3 byte4 {
  comment 'Only yields the floor of the decimal at the moment, i.e. no values after the "."'
  local 'exponent' 0
  local 'significand' 0
  local 'byte2_mod' 0
  local 'floor' 0
  exponent = (((byte1 << 1) | (byte2 >> 7)) - 127)
  byte2_mod = ((1 << 7) | byte2)
  significand = ((byte2_mod << 16) | ((byte3 << 8) | byte4))
  floor = (significand >> (23 - exponent))
  if ((byte1 >> 7) != 0) {
    floor = (0 - floor)
  }
  return floor
}

to 'SCD30 start measuring with ambient pressure' mbar {
  'SCD30 send' (hexToInt '0010') mbar
}

to 'SCD30 start measuring' {
  comment 'argument = 0 deactivates pressure compensation.'
  'SCD30 start measuring with ambient pressure' 0
}

to 'SCD30 stop measuring' {
  'SCD30 send' (hexToInt '0104') ''
}

to 'SCD30 set measurement interval' second {
  'SCD30 send' (hexToInt '4600') second
}

to 'SCD30 measurement interval' {
  return ('SCD30 read uint16' (hexToInt '4600'))
}

to 'SCD30 isReady?' {
  return (('SCD30 read uint16' (hexToInt '0202')) == 1)
}

to 'SCD30 check CRC' list {
  waitMillis 500
  if (or ((size list) == 0) (((size list) % 3) != 0)) {
    return (booleanConstant false)
  }
  local 'blocks' ((size list) / 3)
  for i blocks {
    local 'toCheck' (((at (((i - 1) * 3) + 1) list) << 8) | (at (((i - 1) * 3) + 2) list))
    local 'result' ('SGC30 generate CRC' toCheck)
    if (result != (at (((i - 1) * 3) + 3) list)) {
      return (booleanConstant false)
    }
  }
  return (booleanConstant true)
}

to 'SCD30 read measurement' {
  comment 'When new measurement data is available it can be read out with this command.
Note that the read header should be send with a delay of > 3ms following the write sequence.
Make sure that the measurement is completed by reading the data ready status bit before read out.'
  local 'all' (newList 18)
  local 'command' (hexToInt '0300')
  local 'cmd' ('[data:makeList]' (command >> 8) (command & (hexToInt 'FF')))
  '[sensors:i2cWrite]' (hexToInt '61') cmd
  waitMillis 3
  '[sensors:i2cRead]' (hexToInt '61') all
  if ('SCD30 check CRC' all) {
    local 'temp' 0
    co2 = ('SCD30 float32 to integer' (at 1 all) (at 2 all) (at 4 all) (at 5 all))
    temperature = ('SCD30 float32 to integer' (at 7 all) (at 8 all) (at 10 all) (at 11 all))
    humidity = ('SCD30 float32 to integer' (at 13 all) (at 14 all) (at 16 all) (at 17 all))
  }
}

to 'SCD30 start calibrating' {
  'SCD30 send' (hexToInt '5306') 1
}

to 'SCD30 is calibrating?' {
  return (('SCD30 read uint16' (hexToInt '5306')) == 1)
}

to 'SCD30 stop calibrating' {
  'SCD30 send' (hexToInt '5306') 0
}

to 'SCD30 set forced recalibration value' ppm {
  'SCD30 send' (hexToInt '5204') ppm
}

to 'SCD30 forced recalibration value' {
  return ('SCD30 read uint16' (hexToInt '5204'))
}

to 'SCD30 set temperature offset' tick {
  comment 'The on-board RH/T sensor is influenced by thermal self-heating
of SCD30 and other electrical components.
Design-in alters the thermal properties of SCD30 such that temperature
and humidity offsets may occur when operating the sensor in end-customer devices.
Compensation of those effects is achievable by writing the temperature offset found
in continuous operation of the device into the sensor.
Temperature offset value is saved in non-volatile memory.
 The last set value will be used for temperature offset compensation after repowering.

Format: uint16 Temperature offset, unit [Â°C x 100], i.e. one tick corresponds to 0.01Â°C'
  'SCD30 send' (hexToInt '5403') tick
}

to 'SCD30 temperature offset' {
  return ('SCD30 read uint16' (hexToInt '5403'))
}

to 'SCD30 set altitude compensation' 'current altitude in meter' {
  comment 'Setting altitude is disregarded when an ambient pressure is given to the sensor
via "SCD30 start measuring with ambient pressure"'
  'SCD30 send' (hexToInt '5102') (v 'current altitude in meter')
}

to 'SCD30 altitude compensation' {
  return ('SCD30 read uint16' (hexToInt '5102'))
}

to 'SCD30 firmware' {
  return ('SCD30 read uint16' (hexToInt 'D100'))
}

to 'SCD30 soft reset' {
  'SCD30 send' (hexToInt '3D04') ''
}

module 'Gas (SGP30)' Input
author 'JosÃ© GarcÃ­a Yeste'
version 1 1 
tags sensor co2 
description 'Support for Sensirion SGP30 Air Quality Sensor.
Returns the CO2 in ppm and TVOC in ppb.

Based on: https://github.com/adafruit/Adafruit_SGP30/blob/master/Adafruit_SGP30.cpp'

variables '_SGP30 inizialized' 

	spec 'r' 'SGP30 connected' 'SGP30 connected'
	spec 'r' 'SGP30 read' 'SGP30 read air quality'
	spec 'r' 'SGP30 read raw' 'SGP30 read raw'
	spec ' ' 'SGP30 setup' 'SGP30 setup'
	spec 'r' 'SGP30 get baseline' 'SGP30 get baseline'
	spec ' ' 'SGP30 set baseline' 'SGP30 set baseline co2 _ tvoc _' 'auto auto' 36885 36209
	spec 'r' '_SGP30 generate CRC' '_SGP30 generate CRC _' 'auto' 400

to 'SGP30 connected' {
  local 'cmd' ('[data:makeList]' (hexToInt '20') (hexToInt '2F'))
  local 'response' (newList 3)
  '[sensors:i2cWrite]' (hexToInt '58') cmd
  waitMillis 10
  '[sensors:i2cRead]' (hexToInt '58') response
  local 'featureset' (((at 1 response) << 8) | (at 2 response))
  return ((featureset & (hexToInt 'F0')) == (hexToInt '20'))
}

to 'SGP30 read' {
  'SGP30 setup'
  local 'cmd' ('[data:makeList]' (hexToInt '20') (hexToInt '08'))
  local 'response' (newList 6)
  '[sensors:i2cWrite]' (hexToInt '58') cmd
  waitMillis 12
  local 'aq' (newList 2)
  '[sensors:i2cRead]' (hexToInt '58') response
  atPut 1 aq (((at 1 response) << 8) | (at 2 response))
  atPut 2 aq (((at 4 response) << 8) | (at 5 response))
  return aq
}

to 'SGP30 setup' {
  if ((v '_SGP30 inizialized') == 0) {
    '_SGP30 inizialized' = 1
    local 'cmd' ('[data:makeList]' (hexToInt '20') (hexToInt '03'))
    '[sensors:i2cWrite]' (hexToInt '58') cmd
    waitMillis 10
  }
}

to 'SGP30 read raw' {
  'SGP30 setup'
  local 'cmd' ('[data:makeList]' (hexToInt '20') (hexToInt '50'))
  local 'response' (newList 6)
  '[sensors:i2cWrite]' (hexToInt '58') cmd
  waitMillis 25
  local 'raw' (newList 2)
  '[sensors:i2cRead]' (hexToInt '58') response
  atPut 1 raw (((at 1 response) << 8) | (at 2 response))
  atPut 2 raw (((at 4 response) << 8) | (at 5 response))
  return raw
}


to 'SGP30 get baseline' {
  'SGP30 setup'
  local 'cmd' ('[data:makeList]' (hexToInt '20') (hexToInt '15'))
  local 'response' (newList 6)
  '[sensors:i2cWrite]' (hexToInt '58') cmd
  waitMillis 10
  local 'baseline' (newList 2)
  '[sensors:i2cRead]' (hexToInt '58') response
  atPut 1 baseline (((at 1 response) << 8) | (at 2 response))
  atPut 2 baseline (((at 4 response) << 8) | (at 5 response))
  return baseline
}

to 'SGP30 set baseline' co2 tvoc {
  'SGP30 setup'
  local 'cmd' ('[data:makeList]' (hexToInt '20') (hexToInt '1E') (tvoc >> 8) (tvoc & 255) ('_SGP30 generate CRC' tvoc) (co2 >> 8) (co2 & 255) ('_SGP30 generate CRC' co2))
  '[sensors:i2cWrite]' (hexToInt '58') cmd
  waitMillis 10
}

to '_SGP30 generate CRC' value {
  local 'buf' ('[data:makeList]' (value >> 8) (value & 255))
  local 'crc' (hexToInt 'FF')
  for i (size buf) {
    crc = (crc ^ (at i buf))
    for i 8 {
      if ((crc & (hexToInt '80')) != 0) {
        crc = ((crc << 1) ^ (hexToInt '31'))
      } else {
        crc = (crc << 1)
      }
    }
  }
  return (crc & 255)
}

script 642 50 {
to 'SGP30 set baseline' {}
}



module 'Gesture (PAJ7620)' Input
author 'JosÃ© GarcÃ­a'
version 1 0 
tags sensor gesture 
description 'Support for PAJ7620 gesture sensor.
The "read" block returns the name of the detected gesture.
Based on github.com/Seeed-Studio/Gesture_PAJ7620'

variables '_paj7620 initialized' 

	spec 'r' 'paj7620 read' 'paj7620 read'
	spec ' ' '_paj7620 setup' '_paj7620 setup'
	spec 'r' 'paj7620 connected' 'paj7620 connected'
	spec ' ' '_paj7620 setup bank0' '_paj7620 setup bank0'
	spec ' ' '_paj7620 setup bank1' '_paj7620 setup bank1'

to '_paj7620 setup' {
  if ('paj7620 connected') {
    '_paj7620 setup bank0'
    '_paj7620 setup bank1'
    i2cSet (hexToInt '73') (hexToInt '65') (hexToInt '12')
    i2cSet (hexToInt '73') (hexToInt 'EF') 0
    '_paj7620 initialized' = 1
  }
}

to '_paj7620 setup bank0' {
  i2cSet (hexToInt '73') (hexToInt 'EF') 0
  local 'i' 1
  local 'list' '3229
3301
3400
3501
3600
3707
3817
3906
3A12
3F00
4002
41FF
4201
462D
470F
483C
4900
4A1E
4B00
4C20
4D00
4E1A
4F14
5000
5110
5200
5C02
5D00
5E10
5F3F
6027
6128
6200
6303
64F7
6503
66D9
6703
6801
69C8
6A40
6D04
6E00
6F00
7080
7100
7200
7300
74F0
7500
8042
8144
8204
8320
8420
8500
8610
8700
8805
8918
8A10
8B01
8C37
8D00
8EF0
8F81
9006
9106
921E
930D
940A
950A
960C
9705
980A
9941
9A14
9B0A
9C3F
9D33
9EAE
9FF9
A048
A113
A210
A308
A430
A519
A610
A708
A824
A904
AA1E
AB1E
CC19
CD0B
CE13
CF64
D021
D10F
D288
E001
E104
E241
E3D6
E400
E50C
E60A
E700
E800
E900
EE07'
  repeatUntil (i > (size list)) {
    local 'reg' ('[data:copyFromTo]' list i (i + 1))
    local 'val' ('[data:copyFromTo]' list (i + 2) (i + 4))
    i2cSet (hexToInt '73') (hexToInt reg) (hexToInt val)
    i += 5
    waitMicros 10
  }
}

to '_paj7620 setup bank1' {
  i2cSet (hexToInt '73') (hexToInt 'EF') 1
  local 'i' 1
  local 'list' '001E
011E
020F
0310
0402
0500
06B0
0704
080D
090E
0A9C
0B04
0C05
0D0F
0E02
0F12
1002
1102
1200
1301
1405
1507
1605
1707
1801
1904
1A05
1B0C
1C2A
1D01
1E00
2100
2200
2300
2501
2600
2739
287F
2908
3003
3100
321A
331A
3407
3507
3601
37FF
3836
3907
3A00
3EFF
3F00
4077
4140
4200
4330
44A0
455C
4600
4700
4858
4A1E
4B1E
4C00
4D00
4EA0
4F80
5000
5100
5200
5300
5400
5780
5910
5A08
5B94
5CE8
5D08
5E3D
5F99
6045
6140
632D
6402
6596
6600
6797
6801
69CD
6A01
6BB0
6C04
6D2C
6E01
6F32
7100
7201
7335
7400
7533
7631
7701
7C84
7D03
7E01'
  repeatUntil (i > (size list)) {
    local 'reg' ('[data:copyFromTo]' list i (i + 1))
    local 'val' ('[data:copyFromTo]' list (i + 2) (i + 4))
    i2cSet (hexToInt '73') (hexToInt reg) (hexToInt val)
    i += 5
    waitMicros 10
  }
}

to 'paj7620 connected' {
  return (and ((i2cGet (hexToInt '73') 0) == 32) ((i2cGet (hexToInt '73') 1) == 118))
}

to 'paj7620 read' {
  if ((v '_paj7620 initialized') == 0) {'_paj7620 setup'}
  local 'msg' '?'
  local 'g' (i2cGet (hexToInt '73') (hexToInt '43'))
  if ((g & 1) != 0) {
    msg = 'right'
  } ((g & 2) != 0) {
    msg = 'left'
  } ((g & 4) != 0) {
    msg = 'up'
  } ((g & 8) != 0) {
    msg = 'down'
  } ((g & 16) != 0) {
    msg = 'fordward'
  } ((g & 32) != 0) {
    msg = 'backward'
  } ((g & 64) != 0) {
    msg = 'clockwise'
  } ((g & 128) != 0) {
    msg = 'anti-clockwise'
  }
  return msg
}

module 'IR Motion (PIR)' Input
author MicroBlocks
version 1 1 
tags sensor motion presence 
description 'Detect motion with a passive infrared (PIR) sensor.'
variables _PIRs 

  spec 'r' 'PIR' 'PIR at pin _ detected movement' 'auto' '10'
  spec 'r' '_PIR' '_PIR at pin _' 'auto' '10'
  spec ' ' '_pirLoop' '_pirLoop'

to PIR pin {
  sendBroadcast '_pirLoop'
  waitUntil (_PIRs != 0)
  return (at 2 ('_PIR' pin))
}

to '_PIR' pin {
  for PIR _PIRs {
    if ((at 1 PIR) == pin) {return PIR}
  }
  local 'PIR' ('[data:makeList]' pin (booleanConstant false))
  '[data:addLast]' PIR _PIRs
  return PIR
}

to '_pirLoop' {
  if (_PIRs == 0) {_PIRs = ('[data:makeList]')}
  forever {
    for PIR _PIRs {
      if (digitalReadOp (at 1 PIR)) {
        if (not (at 2 PIR)) {atPut 2 PIR (booleanConstant true)}
      } else {
        if (at 2 PIR) {atPut 2 PIR (booleanConstant false)}
      }
    }
    waitMillis 5
  }
}

module 'Light & Gesture (APDS9960)' Input
author MicroBlocks
version 1 0 
choices apds9960_lightGain '1x' '4x' '16x' '64x' 
description 'Support for the APDS9960 light, color, and gesture sensor.

The sensor handles a wide range of light values thanks to the ability to change the gain. Its color response is similar to the human eye and it incorporates IR and UV blocking filters. In additional to the light level, it can report the light color as a list of red, green, and blue levels.

The gesture sensor uses reflected infrared light to detect object proximity with a range of a few centimeters. It can also detect the direction of a passing object (e.g. a hand), detecting left, right, up, or down gestures. Gestures can be used to trigger actions in MicroBlocks such as turning some device on and off in response to up and down gestures.'
variables _apds9960_addr _apds9960_gestureState _apds9960_startLR _apds9960_startUD _apds9960_gesture _apds9960_lastGesture 

  spec 'r' 'apds9960_light' 'apds9960 light'
  spec 'r' 'apds9960_color' 'apds9960 color'
  space
  spec ' ' 'apds9960_setLightGain' 'apds9960 set light gain _' 'menu.apds9960_lightGain' '4x'
  spec 'r' 'apds9960_lightGain' 'apds9960 light gain'
  space
  spec 'r' 'apds9960_proximity' 'apds9960 proximity'
  space
  spec 'r' 'apds9960_gestureAvailable' 'apds9960 gesture available'
  spec 'r' 'apds9960_lastGesture' 'apds9960 last gesture'
  space
  spec ' ' '_apds9960_initialize' '_apds9960_initialize'
  spec ' ' '_apds9960_turnOff' '_apds9960_turnOff'
  spec ' ' '_apds9960_turnOnWithoutGestures' '_apds9960_turnOnWithoutGestures'
  spec ' ' '_apds9960_turnOnAll' '_apds9960_turnOnAll'
  space
  spec ' ' '_apds9960_enableGestures' '_apds9960 enable gestures'
  spec ' ' '_apds9960_processGesture' '_apds9960_processGesture'
  spec ' ' '_apds9960_recognizeGesture' '_apds9960_recognizeGesture _ _' 'num num' 0 0
  space
  spec ' ' '_apds9960_unblockStateMachine' '_apds9960_unblockStateMachine'
  spec 'r' '_apds9960_read16bits' '_apds9960_read16bits reg _' 'num' 0

to '_apds9960_enableGestures' {
  if (_apds9960_addr == 0) {'_apds9960_initialize'}
  '_apds9960_turnOff'
  local 'ggain' 3
  local 'val' (ggain << 5)
  local 'gdrive' 0
  local 'val' (val | (gdrive << 3))
  local 'gwait' 3
  local 'val' (val | gwait)
  i2cSet _apds9960_addr (hexToInt 'A3') val
  i2cSet _apds9960_addr (hexToInt 'A6') (hexToInt '84')
  comment 'A non-zero value for _apds9960_gesture indicates that gestures are enabled'
  _apds9960_gesture = 'none'
  '_apds9960_turnOnAll'
}

to '_apds9960_initialize' {
  _apds9960_addr = (hexToInt '39')
  '_apds9960_turnOff'
  comment 'Reg 0x81: Integration time. 224 gives a range of 0 to ~32768 (2^15) in about 90 msecs.'
  i2cSet _apds9960_addr (hexToInt '81') 224
  comment 'Reg 0x8E: PPULSE. 0x87 sends 8 16-usec pulses.'
  i2cSet _apds9960_addr (hexToInt '8E') (hexToInt '87')
  apds9960_setLightGain '4x'
  '_apds9960_turnOnWithoutGestures'
  waitMillis 100
}

to '_apds9960_processGesture' {
  if (_apds9960_addr == 0) {'_apds9960_enableGestures'}
  local 'thresh' 80
  local 'data' (newList 4)
  repeatUntil ((i2cGet _apds9960_addr (hexToInt 'AE')) <= 0) {
    '[sensors:i2cWrite]' _apds9960_addr (hexToInt 'FC')
    '[sensors:i2cRead]' _apds9960_addr data
    comment 'These variables reflect the standard orientation of the Databot (USB cable is down).'
    local 'left' (at 1 data)
    local 'right' (at 2 data)
    local 'up' (at 3 data)
    local 'down' (at 4 data)
    if (0 == _apds9960_gestureState) {
      comment 'State 0: idle; all channels below threshold'
      if (or (or (left > thresh) (right > thresh)) (or (up > thresh) (down > thresh))) {
        _apds9960_startLR = (right - left)
        _apds9960_startUD = (down - up)
        _apds9960_gestureState = 1
      }
    } (1 == _apds9960_gestureState) {
      comment 'State 1: rising; one channel has risen above threshold'
      if (and (and (left > thresh) (right > thresh)) (and (up > thresh) (down > thresh))) {
        _apds9960_gestureState = 2
      }
    } (2 == _apds9960_gestureState) {
      comment 'State 2: all channels above threshold'
      if (or (or (left < thresh) (right < thresh)) (or (up < thresh) (down < thresh))) {
        '_apds9960_recognizeGesture' (right - left) (down - up)
        _apds9960_gestureState = 3
      }
    } else {
      comment 'State 3: falling; one channel had fallen below threshold'
      if (and (and (left < thresh) (right < thresh)) (and (up < thresh) (down < thresh))) {
        _apds9960_gestureState = 0
      }
    }
  }
}

to '_apds9960_read16bits' reg {
  local 'lowByte' (i2cGet _apds9960_addr reg)
  local 'highByte' (i2cGet _apds9960_addr (reg + 1))
  return ((highByte << 8) | lowByte)
}

to '_apds9960_recognizeGesture' endLR endUD {
  local 'minChange' 10
  local 'totalLR' (absoluteValue (_apds9960_startLR - endLR))
  local 'totalUP' (absoluteValue (_apds9960_startUD - endUD))
  if (totalLR > totalUP) {
    if (totalLR < minChange) {return}
    if ((_apds9960_startLR - endLR) < 0) {
      _apds9960_gesture = 'left'
    } else {
      _apds9960_gesture = 'right'
    }
  } else {
    if (totalUP < minChange) {return}
    if ((_apds9960_startUD - endUD) < 0) {
      _apds9960_gesture = 'down'
    } else {
      _apds9960_gesture = 'up'
    }
  }
}

to '_apds9960_turnOff' {
  i2cSet _apds9960_addr (hexToInt '80') 0
}

to '_apds9960_turnOnAll' {
  i2cSet _apds9960_addr (hexToInt '80') (64 | 7)
}

to '_apds9960_turnOnWithoutGestures' {
  i2cSet _apds9960_addr (hexToInt '80') 7
}

to '_apds9960_unblockStateMachine' {
  comment 'If an object is close to the sensor, the state machine
remains in gesture mode. This will unblock it, freeing
the sensor to update the light and color readings.'
  i2cSet _apds9960_addr (hexToInt 'AB') 0
}

to apds9960_color {
  if (_apds9960_addr == 0) {'_apds9960_initialize'}
  '_apds9960_unblockStateMachine'
  local 'r' ('_apds9960_read16bits' (hexToInt '96'))
  local 'g' ('_apds9960_read16bits' (hexToInt '98'))
  local 'b' ('_apds9960_read16bits' (hexToInt '9A'))
  return ('[data:makeList]' r g b)
}

to apds9960_gestureAvailable {
  if (0 == _apds9960_gesture) {'_apds9960_enableGestures'}
  '_apds9960_processGesture'
  _apds9960_lastGesture = _apds9960_gesture
  _apds9960_gesture = 'none'
  if ('none' == _apds9960_lastGesture) {
    return false
  }
  return true
}

to apds9960_lastGesture {
  if (0 == _apds9960_lastGesture) {return 'none'}
  return _apds9960_lastGesture
}

to apds9960_light {
  if (_apds9960_addr == 0) {'_apds9960_initialize'}
  '_apds9960_unblockStateMachine'
  return ('_apds9960_read16bits' (hexToInt '94'))
}

to apds9960_lightGain gain {
  if (_apds9960_addr == 0) {'_apds9960_initialize'}
  local 'gainSetting' ((i2cGet _apds9960_addr (hexToInt '8F')) & 3)
  return (1 << (2 * gainSetting))
}

to apds9960_proximity {
  if (_apds9960_addr == 0) {'_apds9960_initialize'}
  '_apds9960_unblockStateMachine'
  return (i2cGet _apds9960_addr (hexToInt '9C'))
}

to apds9960_setLightGain gain {
  if (_apds9960_addr == 0) {'_apds9960_initialize'}
  local 'drive' 0
  if ('1x' == gain) {
    drive = 0
  } ('4x' == gain) {
    drive = 1
  } ('16x' == gain) {
    drive = 2
  } ('64x' == gain) {
    drive = 3
  }
  local 'val' (i2cGet _apds9960_addr (hexToInt '8F'))
  val = ((val & 252) | (drive & 3))
  i2cSet _apds9960_addr (hexToInt '8F') val
}

module 'Light (BH1750)' Input
author MicroBlocks
version 1 0 
tags light d1mini 
description 'Basic BH1750 ambient light sensor library.
This is the sensor used by the LOLIN D1 mini ambient light shield.'
variables write read 

	spec 'r' 'BH1750 ambient light' 'BH1750 ambient light'

to 'BH1750 ambient light' {
  i2cSet (hexToInt '23') 23 (hexToInt '21')
  read = (newList 2)
  '[sensors:i2cRead]' (hexToInt '23') read
  return (((at 1 read) << 8) | (at 2 read))
}

module Microphone Input
author MicroBlocks
version 1 3 
description 'Microphone, loudness, and clap counting support for boards with built in microphones. The microphone block usually reports values between -512 and 511, with zero for silence. However, very loud sounds may exceed that range on some boards. On the micro:bit v2, the microphone must be turned on before use.'
variables _clapThreshold _loudnessSamples 

	spec 'r' '[sensors:microphone]' 'microphone'
	spec ' ' 'turnOnMicrophone' 'turn on microphone'
	spec 'r' 'loudness' 'loudness'
	spec 'r' 'clapCount' 'clap count'
	spec ' ' 'setClapThreshold' 'set clap threshold _' 'auto' 200
	spec 'r' 'guessClapThreshold' 'estimate clap threshold'
	spec ' ' '_loudnessLoop' '_loudnessLoop'

to '_loudnessLoop' {
  comment 'Sample microphone at ~2000 samples/sec, keeping the most recent N samples.'
  turnOnMicrophone
  waitMillis 20
  forever {
    for i (size _loudnessSamples) {
      atPut i _loudnessSamples ('[sensors:microphone]')
      waitMicros 500
    }
  }
}

to clapCount {
  comment 'Count the number of claps in a sequence.'
  if (_clapThreshold == 0) {
    _clapThreshold = 150
  }
  waitUntil ((loudness) > _clapThreshold)
  local 'count' 1
  forever {
    waitUntil ((loudness) < ((3 * _clapThreshold) / 4))
    resetTimer
    repeatUntil ((loudness) > _clapThreshold) {
      comment 'This loop awaits either the next clap or for a pause, indicating that the claps have ended.'
      if ((timer) > 700) {
        comment 'No clap for a while, return the count.'
        return count
      }
    }
    count += 1
  }
}

to guessClapThreshold {
  comment 'Sample the loudness for three seconds and set
_clapThreshold to 130% of the maxium.'
  local 'maxLoudness' 0
  resetTimer
  repeatUntil ((timer) > 3000) {
    maxLoudness = (maximum maxLoudness (loudness))
  }
  return ((13 * maxLoudness) / 10)
}

to loudness {
  if (_loudnessSamples == 0) {
    comment 'Initialize _loudnessSamples and start sampling.'
    _loudnessSamples = (newList 50)
    sendBroadcast '_loudnessLoop'
  }
  local 'low' 10000
  local 'high' -10000
  for n _loudnessSamples {
    low = (minimum low n)
    high = (maximum high n)
  }
  return (high - low)
}

to setClapThreshold n {
  _clapThreshold = n
}

to turnOnMicrophone {
  if ('micro:bit v2' == (boardType)) {
    comment 'Turn on the microphone and
wait for it to settle down.'
    digitalWriteOp 28 true
    waitMillis 50
  }
}

module Motion Input
author MicroBlocks
version 1 1 
tags acceleration steps motion accelerometer 
description 'Count steps and detect motion in boards with a built-in accelerometer, such as the micro:bit, the Calliope, the Citilab ED1 or the Circuit Playground Express.'
variables _motionSamples _stepCount _stepThreshold _stepMotionHigh 

  spec ' ' 'startStepCounter' 'start step counter'
  spec 'r' 'stepCount' 'step count'
  spec ' ' 'clearStepCount' 'clear step count'
  spec ' ' 'setStepThreshold' 'set step threshold _ (0-50)' 'auto' 10
  spec 'r' 'motion' 'motion'
  spec ' ' '_addSample' '_addSample _' 'auto' '10'
  spec 'r' '_recentAverage' '_recentAverage'
  spec ' ' '_stepCounterLoop' '_stepCounterLoop'

to '_addSample' s {
  if (0 == _motionSamples) {_motionSamples = (newList 12)}
  for i ((size _motionSamples) - 1) {
    atPut i _motionSamples (at (i + 1) _motionSamples)
  }
  atPut (size _motionSamples) _motionSamples s
}

to '_recentAverage' {
  if (0 == _motionSamples) {return 0}
  local 'count' (size _motionSamples)
  local 'total' 0
  for i count {
    total += (at i _motionSamples)
  }
  return (total / count)
}

to '_stepCounterLoop' {
  if (_stepThreshold == 0) {_stepThreshold = 15}
  forever {
    local 'n' (motion)
    if (n > _stepThreshold) {
      if (not _stepMotionHigh) {
        _stepMotionHigh = (booleanConstant true)
        _stepCount += 1
        sendBroadcast 'step'
      }
    } (n < -3) {
      _stepMotionHigh = (booleanConstant false)
    }
    waitMillis 10
  }
}

to clearStepCount {
  _stepCount = 0
}

to motion {
  comment 'Return the change in acceleration since the last call.'
  comment 'Details: The value is the difference between the current
acceleration and the average value of the last N samples.
The result is zero when there are no changes of acceleration.
It goes positive momentarily when the acceleration decreases
(e.g. because the microcontroller is in free fall) and positive
when the acceleration increases (e.g. when the falling micro-
controller is caught).'
  local 'current' ('[sensors:acceleration]')
  local 'result' (current - ('_recentAverage'))
  '_addSample' current
  if ((absoluteValue result) < 3) {
    comment 'Suppress sensor noise'
    result = 0
  }
  return result
}

to setStepThreshold threshold {
  comment 'The lower the threshold, the more sensitive the
step counter is. If the threshold is too low, it will
count extra steps. If it is too high, it will miss steps.'
  _stepThreshold = (threshold + 5)
}

to startStepCounter {
  comment 'Reset the step count to zero and start the
step counter loop.'
  _stepCount = 0
  sendBroadcast '_stepCounterLoop'
}

to stepCount {
  return _stepCount
}

module 'Pulse (MAX30105)' Input
author MicroBlocks
version 1 1 
description ''
variables _max30105_addr _max30105_threshold _max30105_BPM _max30105_lastBeatTime _max30105_state _max30105_min _max30105_max _max30105_recentSamples 

  spec ' ' 'max30105_initialize' 'MAX30105 initialize threshold _' 'num' 130
  spec 'r' 'max30105_BMP' 'MAX30105 pulse (beats/minute)'
  space
  spec ' ' '_max30105_loop' '_max30105_loop'
  spec ' ' '_max30105_readAndProcessData' '_max30105_readAndProcessData'
  spec ' ' '_max30105_detectPeaks' '_max30105_detectPeaks _' 'num' 0
  spec ' ' '_max30105_computeBPM' '_max30105_computeBPM'
  space
  spec ' ' '_max30105_click' '_max30105_click'
  spec 'r' '_max30105_recentAverage' '_max30105_recentAverage _' 'auto' '10'
  spec ' ' '_max30105_bitMask' '_max30105_bitMask _ _ _' 'auto auto auto' 0 0 0

to '_max30105_bitMask' reg mask thing {
  local 'var' (i2cGet _max30105_addr reg)
  var = (var & mask)
  i2cSet _max30105_addr reg (var | thing)
}

to '_max30105_click' {
  comment 'Databot: pin 32'
  digitalWriteOp 32 true
  waitMillis 1
  digitalWriteOp 32 false
}

to '_max30105_computeBPM' {
  local 'now' (millisOp)
  local 'beatMSecs' (now - _max30105_lastBeatTime)
  _max30105_lastBeatTime = now
  if (beatMSecs > 200) {
    _max30105_BPM = (60000 / beatMSecs)
  }
}

to '_max30105_detectPeaks' sample {
  local 'peakGraph' 0
  if (0 == _max30105_state) {
    _max30105_state = 'find max'
  }
  local 'smoothedSample' ('_max30105_recentAverage' sample)
  if ('find max' == _max30105_state) {
    if (sample > _max30105_max) {
      _max30105_max = smoothedSample
    } (sample < (_max30105_max - _max30105_threshold)) {
      _max30105_state = 'find min'
      _max30105_min = smoothedSample
      '_max30105_computeBPM'
      '_max30105_click'
      peakGraph = 2000
    }
  } ('find min' == _max30105_state) {
    if (sample < _max30105_min) {
      _max30105_min = smoothedSample
    } (sample > (_max30105_min + _max30105_threshold)) {
      _max30105_state = 'find max'
      _max30105_max = smoothedSample
    }
  }
  if (((millisOp) - _max30105_lastBeatTime) > 3000) {
    comment 'Set BPM to zero if no beats detected in the past few seconds'
    _max30105_BPM = 0
  }
  comment 'Make this true to graph for debugging...'
  if false {
    printIt peakGraph (smoothedSample - _max30105_min)
  }
}

to '_max30105_loop' {
  forever {
    '_max30105_readAndProcessData'
    waitMillis 20
  }
}

to '_max30105_readAndProcessData' {
  local 'writePtr' (i2cGet _max30105_addr 4)
  local 'readPtr' (i2cGet _max30105_addr 6)
  local 'count' (writePtr - readPtr)
  if (count == 0) {
    return 0
  } (count < 0) {
    count += 32
  }
  local 'data' (newList ((minimum count 10) * 3))
  '[sensors:i2cWrite]' _max30105_addr 7
  '[sensors:i2cRead]' _max30105_addr data
  local 'i' 1
  repeatUntil (i > (size data)) {
    local 'ir value' ((((at i data) & 3) << 16) | (((at (i + 1) data) << 8) | (at (i + 2) data)))
    '_max30105_detectPeaks' (v 'ir value')
    i += 3
  }
}

to '_max30105_recentAverage' newSample {
  if (_max30105_recentSamples == 0) {_max30105_recentSamples = (newList 5)}
  '[data:delete]' 1 _max30105_recentSamples
  '[data:addLast]' newSample _max30105_recentSamples
  local 'sum' 0
  for s _max30105_recentSamples {
    sum += s
  }
  return (sum / (size _max30105_recentSamples))
}

to max30105_BMP {
  if (_max30105_addr == 0) {max30105_initialize 130}
  return _max30105_BPM
}

to max30105_initialize threshold {
  _max30105_addr = (hexToInt '57')
  local 'id' (i2cGet _max30105_addr (hexToInt 'FF'))
  if (id != (hexToInt '15')) {
    sayIt 'MAX30105 is not connected'
    return 0
  }
  _max30105_threshold = threshold
  comment 'soft reset'
  '_max30105_bitMask' (hexToInt '09') (hexToInt 'BF') (hexToInt '40')
  waitMillis 150
  comment 'average of 4 selected'
  '_max30105_bitMask' (hexToInt '08') (hexToInt '1F') (hexToInt '40')
  comment 'enableFIFORollover'
  '_max30105_bitMask' (hexToInt '08') (hexToInt 'EF') (hexToInt '10')
  comment 'ledMode 2 - heart only'
  '_max30105_bitMask' (hexToInt '09') (hexToInt 'F8') (hexToInt '2')
  comment 'ADC range 4096'
  '_max30105_bitMask' (hexToInt '0A') (hexToInt '9F') (hexToInt '20')
  comment 'Sample rate 400'
  '_max30105_bitMask' (hexToInt '0A') (hexToInt 'E3') (hexToInt '0C')
  comment 'Pulse width 411'
  '_max30105_bitMask' (hexToInt '0A') (hexToInt 'FC') (hexToInt '03')
  comment 'LED pulse amplitudes'
  i2cSet _max30105_addr (hexToInt '0C') (hexToInt '1F')
  i2cSet _max30105_addr (hexToInt '0D') (hexToInt '1F')
  '_max30105_bitMask' (hexToInt '11') (hexToInt 'F8') (hexToInt '01')
  '_max30105_bitMask' (hexToInt '11') (hexToInt '8F') ((hexToInt '02') << 4)
  i2cSet _max30105_addr (hexToInt '04') 0
  i2cSet _max30105_addr (hexToInt '05') 0
  sendBroadcast '_max30105_loop'
}

module 'RFID (PN532)' Input
author 'JosÃ© GarcÃ­a Yeste'
version 1 0
description 'Read Radio Frequency Identification (RFID) data from key cards and other electronic tags with the PN532 sensor.'
tags sensor pn532


	spec 'r' 'PN532readRFID' 'read PN532 RFID'
	spec 'r' 'PN532equalRFIDs' 'RFID _ = _' 'str str' '' ''
	spec 'r' 'PN532getFirmwareVersion' 'get PN532 firmware version'
	spec ' ' '_PN532sendCommand' '_PN532sendCommand _' 'auto' 0
	spec ' ' '_PN532readAckFrame' '_PN532readAckFrame'
	spec 'r' '_PN532getResponse' '_PN532getResponse'
	spec 'r' '_PN532checksum' '_PN532checksum _' 'num' 0

to PN532equalRFIDs id1 id2 {
  if (or (id1 == 0) (id1 == 0)) {return (booleanConstant false)}
  if ((size id1) != (size id2)) {return (booleanConstant false)}
  for i (size id1) {
    if ((at i id1) != (at i id2)) {return (booleanConstant false)}
  }
  return (booleanConstant true)
}

to PN532getFirmwareVersion {
  comment 'PN532_COMMAND_GETFIRMWAREVERSION'
  '_PN532sendCommand' ('[data:makeList]' 2)
  '_PN532readAckFrame'
  return ('_PN532getResponse')
}

to PN532readRFID {
  comment 'Contributed by JosÃ© GarcÃ­a Yeste from the Citilab, CornellÃ  (Barcelona)'
  comment 'PN532_COMMAND_SAMCONFIGURATION, 1, 0x14, 1'
  _PN532sendCommand ('[data:makeList]' (hexToInt '14') 1 (hexToInt '14') 1)
  _PN532readAckFrame
  comment 'PN532_COMMAND_INLISTPASSIVETARGET, 1, 0'
  '_PN532sendCommand' ('[data:makeList]' (hexToInt '4A') 1 0)
  '_PN532readAckFrame'
  local 'response' ('_PN532getResponse')
  if (response != 0) {
    return ('[data:copyFromTo]' response 7)
  } else {
    return 0
  }
}

to '_PN532checksum' val {
  return ((('~' val) + 1) & 255)
}

to '_PN532getResponse' {
  local 'response' (newList 64)
  atPut 1 response 64
  '[sensors:i2cRead]' (hexToInt '24') response
  waitMillis 1
  for i 4 {
    if ((at i ('[data:makeList]' 1 0 0 255)) != (at i response)) {return 0}
    local 'length' ((at 5 response) - 3)
    comment '6=length checksum, 7=213, 8=cmd+1'
    return ('[data:copyFromTo]' response 9 (9 + length))
  }
}

to '_PN532readAckFrame' {
  local 'frame' (newList 7)
  atPut 1 frame 6
  '[sensors:i2cRead]' (hexToInt '24') frame
  waitMillis 20
}

to '_PN532sendCommand' cmd {
  local 'checksum' (hexToInt 'D4')
  local 'send' ('[data:makeList]' 5 0 0 (hexToInt 'FF') ((size cmd) + 1) ('_PN532checksum' ((size cmd) + 1)))
  '[data:addLast]' (hexToInt 'D4') send
  send = ('[data:join]' send cmd)
  for i (size cmd) {
    checksum += (at i cmd)
  }
  '[data:addLast]' ('_PN532checksum' checksum) send
  '[data:addLast]' '0' send
  atPut 1 send (((at 1 send) + (size cmd)) + 3)
  '[sensors:i2cWrite]' (hexToInt '24') send
  waitMillis 1
}

module 'RFID (RC522)' Input
author MicroBlocks
version 1 4 
description 'Support for RC522 RFID card with I2C and SPI interfaces.
Based on JosÃ© Garcia RC522 MicroBlocks library which itself was based on:
        https://github.com/m5stack/UIFlow-Code/blob/master/units/_rfid.py
        and Arduino SPI Library: https://github.com/miguelbalboa/rfid/

Tested with:
        https://www.microcenter.com/product/639731/inland-ks0067-rc522-rfid-module-for-arduino
        https://techatronic.com/rfid-rc522-module-rfid-sensor-working-description/
        https://shop.m5stack.com/products/rfid-unit-2-ws1850s
        https://shop.m5stack.com/products/rfid-sensor-unit
'
variables _rc522_mode _rc522_i2cAddr _rc522_initialized _rc522_nssPin 

  spec ' ' 'rc522_initialize_I2C' 'RC522 initialize I2C addr _' 'num' 40
  spec ' ' 'rc522_initialize_SPI' 'RC522 initialize SPI ssPin _' 'num' 17
  spec 'r' 'rc522_connected' 'RC522 is connected'
  space
  spec 'r' 'rc522_card_present' 'RC522 is card present'
  spec 'r' 'rc522_read_uid' 'RC522 card UID'
  space
  spec 'r' 'rc522_equal_ids' 'RC522 _ = _' 'auto auto' 'uid1' 'uid2'
  space
  spec ' ' '_rc522_antenna_on' '_rc522_antenna_on'
  spec 'r' '_rc522_request' '_rc522_request'
  spec 'r' '_rc522_send_to_card' '_rc522_send_to_card _ _' 'auto auto' 0 'list'
  spec ' ' '_rc522_bitset' '_rc522_bitset reg _ mask _' 'num num' 0 128
  spec ' ' '_rc522_bitclear' '_rc522_bitclear reg _ mask _' 'num num' 0 128
  spec 'r' '_rc522_read_reg' '_rc522_read_reg _' 'num' 55
  spec ' ' '_rc522_write_reg' '_rc522_write_reg _ value _' 'num num' 1 15

to '_rc522_antenna_on' {
  local 'value' ('_rc522_read_reg' (hexToInt '14'))
  if ((value & 3) != 3) {
    '_rc522_write_reg' (hexToInt '14') (value | 3)
  }
}

to '_rc522_bitclear' reg mask {
  '_rc522_write_reg' reg (('_rc522_read_reg' reg) & ('~' mask))
}

to '_rc522_bitset' reg mask {
  '_rc522_write_reg' reg (('_rc522_read_reg' reg) | mask)
}

to '_rc522_read_reg' reg {
  local 'result' 0
  if ('SPI' == _rc522_mode) {
    digitalWriteOp _rc522_nssPin false
    spiSend (128 | (reg << 1))
    result = (spiRecv)
    digitalWriteOp _rc522_nssPin true
  } ('I2C' == _rc522_mode) {
    result = (i2cGet _rc522_i2cAddr reg)
  }
  return result
}

to '_rc522_request' {
  '_rc522_write_reg' (hexToInt '0D') 7
  return ('_rc522_send_to_card' (hexToInt '0C') ('[data:makeList]' (hexToInt '26')))
}

to '_rc522_send_to_card' cmd send {
  '_rc522_write_reg' 2 ((hexToInt '77') | (hexToInt '80'))
  '_rc522_bitclear' (hexToInt '04') (hexToInt '80')
  '_rc522_bitset' (hexToInt '0A') (hexToInt '80')
  for i (size send) {
    '_rc522_write_reg' 9 (at i send)
  }
  '_rc522_write_reg' 1 cmd
  '_rc522_bitset' (hexToInt '0D') (hexToInt '80')
  waitMillis 10
  '_rc522_bitclear' (hexToInt '0D') (hexToInt '80')
  local 'response' (newList 1)
  atPut 1 response (('_rc522_read_reg' 6) & (hexToInt '1B'))
  if ((at 1 response) == 0) {
    local 'n' ('_rc522_read_reg' (hexToInt '0A'))
    for i n {
      '[data:addLast]' ('_rc522_read_reg' 9) response
    }
  }
  return response
}

to '_rc522_write_reg' reg value {
  if ('SPI' == _rc522_mode) {
    digitalWriteOp _rc522_nssPin false
    spiSend (reg << 1)
    spiSend value
    digitalWriteOp _rc522_nssPin true
  } ('I2C' == _rc522_mode) {
    i2cSet _rc522_i2cAddr reg value
  }
}

to rc522_card_present {
  local 'res' ('_rc522_request')
  if ((at 1 res) == 0) {
    if ((size res) == 3) {
      return (booleanConstant true)
    } else {
      waitMillis 5
      res = ('_rc522_request')
      return ((size res) == 3)
    }
  } else {
    return (booleanConstant false)
  }
}

to rc522_connected {
  local 'version' ('_rc522_read_reg' (hexToInt '37'))
  if (('[data:find]' version ('[data:makeList]' 21 136 144 145 146 178)) > 0) {
    return true
  } (version > 0) {
    sayIt 'Unknown RC522 Version:' version
    waitMillis 1000
    return true
  } else {
    return false
  }
}

to rc522_equal_ids id1 id2 {
  if (or (id1 == 0) (id2 == 0)) {return (booleanConstant false)}
  if ((size id1) != (size id2)) {return (booleanConstant false)}
  for i (size id1) {
    if ((at i id1) != (at i id2)) {return (booleanConstant false)}
  }
  return (booleanConstant true)
}

to rc522_initialize_I2C i2cAddr {
  _rc522_mode = 'I2C'
  _rc522_i2cAddr = i2cAddr
  if (_rc522_initialized == 0) {
    _rc522_initialized = (booleanConstant true)
    '_rc522_write_reg' 1 (hexToInt 'F')
    waitMillis 50
    '_rc522_write_reg' (hexToInt '2A') (hexToInt '80')
    '_rc522_write_reg' (hexToInt '2B') (hexToInt 'A9')
    '_rc522_write_reg' (hexToInt '2C') (hexToInt '03')
    '_rc522_write_reg' (hexToInt '2D') (hexToInt 'E8')
    '_rc522_write_reg' (hexToInt '15') (hexToInt '40')
    '_rc522_write_reg' (hexToInt '11') (hexToInt '3D')
    '_rc522_antenna_on'
  }
}

to rc522_initialize_SPI ssPin {
  _rc522_mode = 'SPI'
  _rc522_nssPin = ssPin
  if (_rc522_initialized == 0) {
    _rc522_initialized = (booleanConstant true)
    '_rc522_write_reg' 1 (hexToInt 'F')
    waitMillis 1
    '_rc522_write_reg' (hexToInt '2A') (hexToInt '80')
    '_rc522_write_reg' (hexToInt '2B') (hexToInt 'A9')
    '_rc522_write_reg' (hexToInt '2C') (hexToInt '03')
    '_rc522_write_reg' (hexToInt '2D') (hexToInt 'E8')
    '_rc522_write_reg' (hexToInt '15') (hexToInt '40')
    '_rc522_write_reg' (hexToInt '11') (hexToInt '3D')
    '_rc522_antenna_on'
  }
}

to rc522_read_uid {
  if (rc522_card_present) {
    '_rc522_write_reg' (hexToInt '0D') 0
    local 'res' ('_rc522_send_to_card' (hexToInt '0C') ('[data:makeList]' (hexToInt '93') (hexToInt '20')))
    '[data:delete]' 1 res
    '[data:delete]' 'last' res
    return res
  } else {
    return ('[data:makeList]')
  }
}

module 'Soil Moisture (Adafruit)'
author unknown
version 1 0 
description 'Support for the Adafruit I2C Capacitive Soil Moisture sensor.
https://www.adafruit.com/product/4026

The results vary from 0 (dry and hanging free) to close to 700 (sensor held in the hand). The value range in an actual potted plant depends on the soil type and, of course, how wet the soil is. You will have to experiment to find the range for a specific potted plant.

Note: The Arduino code for this is part of the large Adafruit Seesaw library, but it is actually quite simple to use. You send a two-byte read address and it returns a two-byte result value (MSB). The I2C address is 54 (0x36).
'

  spec 'r' 'adafruit_soil_moisture' 'soil moisture'

to adafruit_soil_moisture {
  '[sensors:i2cWrite]' 54 ('[data:makeList]' (hexToInt '0F') (hexToInt '10'))
  waitMillis 5
  local 'data' (newList 2)
  '[sensors:i2cRead]' 54 data
  local 'result' (((at 1 data) << 8) | (at 2 data))
  result = (maximum 0 (result - 323))
  return result
}

module 'Temperature Humidity (DHT11, DHT22)' Input
author MicroBlocks
version 1 2 
tags sensor dht11 dht22 temperature humidity 
description 'Support for the DHT11 and DHT22 environmental sensors. These sensors provide temperature and humidity readings.'
variables _dht_temperature _dht_humidity _dhtData _dhtLastReadTime 

  spec 'r' 'temperature_DHT11' 'temperature (Celsius) DHT11 pin _' 'auto' 4
  spec 'r' 'humidity_DHT11' 'humidity DHT11 pin _' 'auto' 4
  spec 'r' 'temperature_DHT22' 'temperature (Celsius) DHT22 pin _' 'auto' 4
  spec 'r' 'humidity_DHT22' 'humidity DHT22 pin _' 'auto' 4
  spec ' ' '_dhtReadData' '_dhtReadData pin _' 'auto any' 4
  spec 'r' '_dhtChecksumOkay' '_dhtChecksumOkay' 'any'
  spec ' ' '_dhtUpdate' '_dhtUpdate _ isDHT11 _' 'auto bool any' 4 true
  spec 'r' '_dhtReady' '_dhtReady' 'any'

to '_dhtChecksumOkay' {
  if (not (isType _dhtData 'list')) {return (booleanConstant false)}
  local 'checksum' 0
  for i 4 {
    checksum += (at i _dhtData)
  }
  checksum = (checksum & 255)
  return (checksum == (at 5 _dhtData))
}

to '_dhtReadData' pin {
  comment 'Create DHT data array the first time'
  if (_dhtData == 0) {
    _dhtData = (newList 5)
  }
  comment 'fill with 1''s set checksum will be bad if read fails'
  atPut 'all' _dhtData 1
  comment 'Pull pin low for >18msec to request data'
  digitalWriteOp pin false
  waitMillis 20
  local 'useDHTPrimitive' (booleanConstant true)
  if useDHTPrimitive {
    result = ('[sensors:readDHT]' pin)
    if ((booleanConstant false) != result) {
      _dhtData = result
    }
    return 0
  }
  comment 'Read DHT start pulses (H L H L)'
  waitUntil (digitalReadOp pin)
  waitUntil (not (digitalReadOp pin))
  waitUntil (digitalReadOp pin)
  waitUntil (not (digitalReadOp pin))
  local 'i' 1
  local 'byte' 0
  local 'bit' 1
  comment 'Read 40 bits (5 bytes)'
  repeat 40 {
    waitUntil (digitalReadOp pin)
    local 'start' (microsOp)
    waitUntil (not (digitalReadOp pin))
    if (((microsOp) - start) > 40) {
      comment 'Long pulse - append a "1" bit'
      byte += 1
    }
    if (bit == 8) {
      atPut i _dhtData byte
      i += 1
      byte = 0
      bit = 1
    } else {
      byte = (byte << 1)
      bit += 1
    }
    waitUntil (not (digitalReadOp pin))
  }
}

to '_dhtReady' {
  local 'elapsed' ((millisOp) - _dhtLastReadTime)
  return (or (elapsed < 0) (elapsed > 2000))
}

to '_dhtUpdate' pin isDHT11 {
  if ('_dhtReady') {
    _dht_temperature = 0
    _dht_humidity = 0
    '_dhtReadData' pin
    _dhtLastReadTime = (millisOp)
  }
  if ('_dhtChecksumOkay') {
    if isDHT11 {
      _dht_temperature = (at 3 _dhtData)
      _dht_humidity = (at 1 _dhtData)
    } else {
      local 'n' (((at 1 _dhtData) * 256) + (at 2 _dhtData))
      _dht_humidity = ((n + 5) / 10)
      n = ((((at 3 _dhtData) & 127) * 256) + (at 4 _dhtData))
      if (((at 3 _dhtData) & 128) != 0) {
        n = (0 - n)
      }
      _dht_temperature = ((n + 5) / 10)
    }
  }
}

to humidity_DHT11 pin {
  '_dhtUpdate' pin true
  return _dht_humidity
}

to humidity_DHT22 pin {
  '_dhtUpdate' pin false
  return _dht_humidity
}

to temperature_DHT11 pin {
  '_dhtUpdate' pin true
  return _dht_temperature
}

to temperature_DHT22 pin {
  '_dhtUpdate' pin false
  return _dht_temperature
}

module 'Temperature Humidity (DHT12)' Input
author MicroBlocks
version 1 0 
tags environmental temperature humidity d1mini 
description 'Support for the DHT12 sensor, I2C version.

This is the one that comes as a shield for the WEMOS D1 Mini.

Reads temperature in Â°C and humidity as a percentage.

Both values are returned as a list with the first item as the integer part and the second item as the fractional part.
For instance, a temperature of 33.12Â°C will be returned as a list with 33 as the first item and 12 as the second item.
'
variables '_DHT data' 

	spec 'r' 'DHT humidity' 'DHT humidity'
	spec 'r' 'DHT temperature' 'DHT temperature'
	spec 'r' '_DHT checksum' '_DHT checksum'
	spec ' ' '_DHT read data' '_DHT read data'

to 'DHT humidity' {
  '_DHT read data'
  if ('_DHT checksum') {
    return ('[data:makeList]' (at 1 (v '_DHT data')) (at 2 (v '_DHT data')))
  }
}

to 'DHT temperature' {
  '_DHT read data'
  if ('_DHT checksum') {
    return ('[data:makeList]' (at 3 (v '_DHT data')) (at 4 (v '_DHT data')))
  }
}

to '_DHT checksum' {
  return ((at 5 (v '_DHT data')) == ((((at 1 (v '_DHT data')) + (at 2 (v '_DHT data'))) + ((at 3 (v '_DHT data')) + (at 4 (v '_DHT data')))) % 255))
}

to '_DHT read data' {
  if ((v '_DHT data') == 0) {'_DHT data' = (newList 5)}
  comment 'Init reading'
  '[sensors:i2cWrite]' (hexToInt '5C') ('[data:makeList]' 0)
  waitMillis 50
  comment 'Read all data into list'
  '[sensors:i2cRead]' (hexToInt '5C') (v '_DHT data')
}

module 'Temperature Humidity (SH30)' Input
author MicroBlocks
version 1 1 
tags environmental temperature humidity d1mini 
description 'Support for the SH30 environmental sensor.

Reads relative humidity (%) and temperature (Â°C).

This sensor is included as a shield for the WEMOS D1Mini.'
variables '_SH30 data' 

	spec 'r' 'SH30 humidity' 'SH30 humidity'
	spec 'r' 'SH30 temperature' 'SH30 temperature'
	spec ' ' '_SH30 read data' '_SH30 read data'

to 'SH30 humidity' {
  '_SH30 read data'
  return (((((at 4 (v '_SH30 data')) * 256) + (at 5 (v '_SH30 data'))) * 100) / 65535)
}

to 'SH30 temperature' {
  '_SH30 read data'
  return ((((((at 1 (v '_SH30 data')) * 256) + (at 2 (v '_SH30 data'))) * 175) / 65535) - 45)
}

to '_SH30 read data' {
  if ((v '_SH30 data') == 0) {
    comment '0x2220: 2 readings per second, medium repeatability.
0xE000: Start continuous read mode.'
    '[sensors:i2cWrite]' (hexToInt '45') ('[data:makeList]' (hexToInt '22') (hexToInt '20') (hexToInt 'E0') (hexToInt '00'))
    '_SH30 data' = (newList 6)
    waitMillis 250
  }
  comment 'Read all data into _SH30 data'
  '[sensors:i2cRead]' (hexToInt '45') (v '_SH30 data')
}

module 'Temperature Humidity (SHTC3)' Input
author MicroBlocks
version 1 3 
description 'Support for the SHTC3 temperature and relative humidity sensor.'

  spec 'r' 'shtc3_temperature' 'SHTC3 temperature (Â°C)'
  spec 'r' 'shtc3_humidity' 'SHTC3 relative humidity (%)'
  space
  spec ' ' '_shtc3_send_cmd' '_shtc3_send_cmd _' 'num' 0
  spec 'r' '_shtc3_read' '_shtc3_read'
  spec 'r' '_shtc3_crcOkay' '_shtc3_crcOkay _ _ _' 'num num num' 0 0 0

to '_shtc3_crcOkay' b1 b2 b3 {
  local 'crc' 255
  for i 2 {
    if (1 == i) {
      crc = (crc ^ b1)
    } else {
      crc = (crc ^ b2)
    }
    repeat 8 {
      if ((crc & 128) != 0) {
        crc = (((crc << 1) ^ 49) & 255)
      } else {
        crc = (crc << 1)
      }
    }
  }
  return (0 == (crc ^ b3))
}

to '_shtc3_read' {
  local 'SHTC addr' (hexToInt '70')
  comment 'Wakeup'
  '_shtc3_send_cmd' (hexToInt '3517')
  comment 'Read data, temperature first (with clock stretching)'
  '_shtc3_send_cmd' (hexToInt '7CA2')
  local 'sixBytes' (newList 6)
  '[sensors:i2cRead]' (v 'SHTC addr') sixBytes
  comment 'Do not send sleep command; that results in i2c error on next call'
  return sixBytes
}

to '_shtc3_send_cmd' cmd {
  local 'SHTC addr' (hexToInt '70')
  '[sensors:i2cWrite]' (v 'SHTC addr') ('[data:makeList]' ((cmd >> 8) & 255) (cmd & 255))
}

to shtc3_humidity {
  local 'data' ('_shtc3_read')
  local 'high' (at 4 data)
  local 'low' (at 5 data)
  if (not ('_shtc3_crcOkay' high low (at 6 data))) {
    return 0
  }
  local 'humidity' ((100 * ((high << 8) | low)) >> 16)
  if ('Databot' == (boardType)) {
    comment 'Adjust for extra heat from PC board'
    humidity += 10
  }
  return humidity
}

to shtc3_temperature {
  local 'data' ('_shtc3_read')
  local 'high' (at 1 data)
  local 'low' (at 2 data)
  if (not ('_shtc3_crcOkay' high low (at 3 data))) {
    return 0
  }
  local 'temperature' (((175 * ((high << 8) | low)) >> 16) - 45)
  if ('Databot' == (boardType)) {
    temperature += -10
    comment 'Adjust for extra heat from PC board'
  }
  return temperature
}

module 'Touch (microbit)' Input
author MicroBlocks
version 1 0 
description 'Capacitive touch sensing for micro:bit v1 and v2.'
variables _lowCount _isHigh 

	spec 'r' 'touch' 'pin _ touched : threshold _' 'num num' 0 0
	spec 'r' 'logo touched' 'logo touched'

to 'logo touched' {
  if ((boardType) == 'micro:bit') {return (booleanConstant false)}
  return (touch 26 0)
}

to touch pin optionalThreshold {
  comment 'Discharge pin'
  digitalWriteOp pin false
  local 'threshold' 0
  if ((pushArgCount) > 1) {
    threshold = optionalThreshold
  }
  if (threshold <= 0) {
    comment 'Select threshold based on board type'
    if ((boardType) == 'micro:bit') {
      threshold = 9
    } else {
      threshold = 15
    }
  }
  local 'n' 0
  comment 'Wait for pin to become high, incrementing n'
  repeatUntil (digitalReadOp pin) {
    n += 1
    if (n >= threshold) {
      comment 'Long charging time means pin is touched'
      _isHigh = (booleanConstant true)
      _lowCount = 0
      digitalWriteOp pin false
      return _isHigh
    }
  }
  digitalWriteOp touchPin false
  if (_isHigh == 0) {
    _isHigh = (booleanConstant false)
  }
  comment 'count is < threshold so pin not touched'
  if _isHigh {
    comment 'Require several low counts in a row
to exit "isHigh" state to avoid jitter.'
    _lowCount += 1
    if (_lowCount > 2) {
      _isHigh = (booleanConstant false)
    }
  }
  return _isHigh
}

module 'Touch Screen' Input
author MicroBlocks
version 1 0
description 'Mouse pointer support for Boardie and the Linux VM, plus support for QVGA touch screen display on the (discontinued) IoT-Bus Io system.'
tags qvga touch tft

	// Primitives to support the QVGA touch screen display on the IoT-Bus Io system.
	// https://www.oddwires.com/iot-bus-qvga-2-4-tft-touch-display/

	spec 'r' '[tft:tftTouched]'				'TFT touched'
	spec 'r' '[tft:tftTouchX]'				'TFT touch X position'
	spec 'r' '[tft:tftTouchY]'				'TFT touch Y position'
	spec 'r' '[tft:tftTouchPressure]'		'TFT touch pressure'
module Touch Input
author MicroBlocks
version 1 8 
description 'Support for the MPR121 12-channel i2c touch sensor.'
variables _touch_state _touch_isTouched _touch_eventPending _touch_last_touched_pin _touch_last_released_pin 

  spec 'r' 'touch_isTouched' 'is pin _ touched?' 'menu.range:1-12' 1
  space
  spec 'r' 'touch_touch_event' 'pin touch event'
  spec 'r' 'touch_last_touched_pin' 'last touched pin'
  space
  spec 'r' 'touch_release_event' 'pin release event'
  spec 'r' 'touch_last_released_pin' 'last released pin'
  space
  spec 'r' 'touch_state_string' 'touch state string'
  space
  spec ' ' '_touch_init' '_touch_init'
  spec ' ' '_touch_update' '_touch_update'
  spec ' ' '_touch_setRegister' '_touch_setRegister _ to _' 'auto auto' 'hex register' 'hex value'

to '_touch_init' {
  if (isType _touch_isTouched 'list') {
    comment 'Already initialized.'
    return 0
  }
  _touch_isTouched = (newList 12 (booleanConstant false))
  _touch_eventPending = (newList 12 (booleanConstant false))
  _touch_last_touched_pin = -1
  _touch_last_released_pin = -1
  comment 'Soft reset -- sets all registers to defaults'
  '_touch_setRegister' '0x80' '0x63'
  comment 'Set filter parameters'
  '_touch_setRegister' '0x2B' '0x01'
  '_touch_setRegister' '0x2C' '0x01'
  '_touch_setRegister' '0x2D' '0x10'
  '_touch_setRegister' '0x2E' '0x20'
  '_touch_setRegister' '0x2F' '0x01'
  '_touch_setRegister' '0x30' '0x01'
  '_touch_setRegister' '0x31' '0x10'
  '_touch_setRegister' '0x32' '0x20'
  '_touch_setRegister' '0x33' '0x01'
  '_touch_setRegister' '0x34' '0x10'
  '_touch_setRegister' '0x35' '0xFF'
  comment 'Init debounce and config registers'
  '_touch_setRegister' '0x5B' '0x11'
  '_touch_setRegister' '0x5C' '0xFF'
  '_touch_setRegister' '0x5D' '0x30'
  comment 'Set touch/release thresholds'
  local 'touchThreshold' 40
  local 'releaseThreshold' 20
  for i 12 {
    local 'reg' ((hexToInt '40') + (2 * i))
    '_touch_setRegister' (reg - 1) touchThreshold
    '_touch_setRegister' reg releaseThreshold
  }
  comment 'Start tracking all 12 inputs (proximity detection disabled)'
  '_touch_setRegister' '0x5E' '0xCC'
}

to '_touch_setRegister' reg value {
  if (isType reg 'string') {reg = (hexToInt reg)}
  if (isType value 'string') {value = (hexToInt value)}
  i2cSet 90 reg value
}

to '_touch_update' {
  '_touch_init'
  _touch_state = (((i2cGet 90 1) << 8) | (i2cGet 90 0))
  if (_touch_state < 0) {
    comment 'i2c read operation failed'
    _touch_state = 0
  }
  for i 12 {
    local 'isTouchedNow' ((_touch_state & (1 << (i - 1))) != 0)
    if ((at i _touch_isTouched) != isTouchedNow) {
      atPut i _touch_isTouched isTouchedNow
      atPut i _touch_eventPending (booleanConstant true)
    }
  }
  comment 'Leave some time between updates'
  waitMillis 30
}

to touch_isTouched pin {
  if (or (pin < 1) (pin > 12)) {return (booleanConstant false)}
  '_touch_update'
  return ((_touch_state & (1 << (pin - 1))) != 0)
}

to touch_last_released_pin {
  comment 'Return the pin that triggered the last release event.'
  '_touch_init'
  return _touch_last_released_pin
}

to touch_last_touched_pin {
  comment 'Return the pin that triggered the last touch event.'
  '_touch_init'
  return _touch_last_touched_pin
}

to touch_release_event {
  '_touch_update'
  for i 12 {
    if (and (at i _touch_eventPending) ((_touch_state & (1 << (i - 1))) == 0)) {
      atPut i _touch_eventPending (booleanConstant false)
      _touch_last_released_pin = i
      return (booleanConstant true)
    }
  }
  _touch_last_released_pin = -1
  return (booleanConstant false)
}

to touch_state_string {
  '_touch_update'
  local 'pin states' ('[data:makeList]')
  for i 12 {
    if ((_touch_state & (1 << (i - 1))) != 0) {
      '[data:addLast]' '1' (v 'pin states')
    } else {
      '[data:addLast]' '0' (v 'pin states')
    }
  }
  return ('[data:joinStrings]' (v 'pin states'))
}

to touch_touch_event {
  '_touch_update'
  for i 12 {
    if (and (at i _touch_eventPending) ((_touch_state & (1 << (i - 1))) != 0)) {
      atPut i _touch_eventPending (booleanConstant false)
      _touch_last_touched_pin = i
      return (booleanConstant true)
    }
  }
  _touch_last_touched_pin = -1
  return (booleanConstant false)
}

module 'UV (VEML6075)' Output
author MicroBlocks
version 1 0 
description 'Reports levels of UVA and UVB, as well as the approximate UV Index. The UV Index does not account for cloud cover, ozone level, or altitude, all of which are factored into the UV Index levels in weather reports.

Datasheet:
https://cdn.sparkfun.com/assets/3/c/3/2/f/veml6075.pdf'
variables _veml6075_addr 

  spec 'r' 'veml6075_uvIndex' 'UV Index'
  spec 'r' 'veml6075_uva' 'veml6075_uva'
  spec 'r' 'veml6075_uvb' 'veml6075_uvb'
  space
  spec ' ' '_veml6075_init' '_veml6075_init'
  spec 'r' '_veml6075_readReg16' '_veml6075_readReg16 _' 'num' 12
  spec ' ' '_veml6075_writeReg16' '_veml6075_writeReg16 _ value _' 'num num' 0 16

to '_veml6075_init' {
  if (_veml6075_addr != 0) {return 0}
  _veml6075_addr = (hexToInt '10')
  comment '100 mSec sample rate, normal dynamic range'
  '_veml6075_writeReg16' 0 (hexToInt '10')
}

to '_veml6075_readReg16' register {
  local 'buffer' (newList 2)
  '[sensors:i2cWrite]' _veml6075_addr register false
  '[sensors:i2cRead]' _veml6075_addr buffer
  return (((at 2 buffer) << 8) | (at 1 buffer))
}

to '_veml6075_writeReg16' register value {
  '[sensors:i2cWrite]' _veml6075_addr ('[data:makeList]' register (value & 255) ((value >> 8) & 255))
}

to veml6075_uvIndex {
  comment 'Based on calculation from the SparkFun (not Adafruit)
VEML6075 library.'
  return ((((veml6075_uva) / 9) + ((veml6075_uvb) / 8)) / 200)
}

to veml6075_uva {
  '_veml6075_init'
  local 'rawUVA' ('_veml6075_readReg16' 7)
  local 'uvComp1' ('_veml6075_readReg16' 10)
  local 'uvComp2' ('_veml6075_readReg16' 11)
  return (rawUVA - (((222 * uvComp1) + (133 * uvComp2)) / 100))
}

to veml6075_uvb {
  '_veml6075_init'
  local 'rawUVB' ('_veml6075_readReg16' 9)
  local 'uvComp1' ('_veml6075_readReg16' 10)
  local 'uvComp2' ('_veml6075_readReg16' 11)
  return (rawUVB - (((295 * uvComp1) + (175 * uvComp2)) / 100))
}

module Servo Output
author MicroBlocks
version 1 1 
tags servo motor angle rotation position 
description 'Control both positional (angle) and rotational servo motors.'
variables _servoPin _servoPulseWidth 

  spec ' ' 'setServoAngle' 'set servo _ to _ degrees (-90 to 90)' 'num num' 1 90
  spec ' ' 'setServoSpeed' 'set servo _ to speed _ (-100 to 100)' 'num num' 1 100
  spec ' ' 'stopServo' 'stop servo _' 'num' 1
  spec 'r' '_servoIndex' '_servoIndex _' 'num' 1
  spec ' ' '_servoPulse' '_servoPulse pin _ usecs _' 'num num' 1 1500
  spec ' ' '_servoUpdateLoop' '_servoUpdateLoop'

to '_servoIndex' which {
  if (_servoPin == 0) {
    _servoPin = ('[data:makeList]')
    _servoPulseWidth = ('[data:makeList]')
    sendBroadcast '_servoUpdateLoop'
  }
  local 'i' ('[data:find]' which _servoPin)
  if (i < 0) {
    comment 'Add new pin'
    '[data:addLast]' which _servoPin
    '[data:addLast]' '1500' _servoPulseWidth
    i = (size _servoPin)
  }
  return i
}

to '_servoPulse' pin usecs {
  if (usecs == 0) {
    comment 'Servo stopped; do nothing'
    return 0
  }
  usecs = (maximum 850 (minimum usecs 2150))
  comment 'Split wait into a long wait followed by a wait of <= 30 usecs for greater accuracy'
  local 'endTime' ((microsOp) + usecs)
  digitalWriteOp pin true
  waitMicros (usecs - 30)
  waitMicros (endTime - (microsOp))
  digitalWriteOp pin false
}

to '_servoUpdateLoop' {
  forever {
    if (_servoPin != 0) {
      comment 'If the _servoPin list is not 0, update the servos'
      for i (size _servoPin) {
        local 'pin' (at i _servoPin)
        local 'usecs' (at i _servoPulseWidth)
        if (and (pin >= 0) (usecs != 0)) {
          '_servoPulse' pin usecs
        }
      }
      waitMillis 15
    }
  }
}

to setServoAngle which degrees optionalReverse {
  local 'reversed' false
  if ((pushArgCount) > 2) {
    reversed = optionalReverse
  }
  if reversed {
    degrees = (0 - degrees)
  }
  local 'pulseWidth' (1500 - (10 * degrees))
  if ('[io:hasServo]') {
    '[io:setServo]' which pulseWidth
  } else {
    atPut ('_servoIndex' which) _servoPulseWidth pulseWidth
  }
}

to setServoSpeed which speed optionalReverse {
  local 'reversed' false
  if ((pushArgCount) > 2) {
    reversed = optionalReverse
  }
  if reversed {
    speed = (0 - speed)
  }
  local 'pulseWidth' (1500 - (10 * speed))
  if ((absoluteValue speed) < 2) {
    pulseWidth = 0
  }
  if ('[io:hasServo]') {
    '[io:setServo]' which pulseWidth
  } else {
    atPut ('_servoIndex' which) _servoPulseWidth pulseWidth
  }
}

to stopServo which {
  if ('[io:hasServo]') {
    '[io:setServo]' which 0
  } else {
    atPut ('_servoIndex' which) _servoPulseWidth 0
  }
}

module AMRadioTone Output
author MicroBlocks
version 1 0 
depends SquareWave 
tags tone sound music audio note speaker 
description 'Tone library extended to broadcast the tone to a nearby AM radio, as well as playing it through a speaker.

Import this library into any project that uses the normal Tone library to add AM radio broadcasting. Requires a board based an nRF5x processors (such as a micro:bit v1 or v2) or on an ESP32 processor.'
variables _AMToneAntennaPin _AMToneRadioFrequency _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneFrequencies 

	spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'auto num num' 'C' 0 500
	spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
	spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
	spec ' ' 'attachAMAntenna' 'attach AM antenna pin _ radio frequency _' 'num num' 1 533000
	spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
	spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
	spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
	spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
	spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
	spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
  }
  return ('_baseFreqForSemitone' ('[data:find]' ('_trimmedLowercase' note) _toneNoteNames))
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 1000 {
    digitalWriteOp _tonePin false
    '[io:squareWave]' 100000 _AMToneAntennaPin
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    '[io:squareWave]' 0 _AMToneAntennaPin
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 200000) / 2000)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
  local 'cycles' ((ms * 500) / halfCycle)
  repeat cycles {
    digitalWriteOp _tonePin true
    '[io:squareWave]' 0 _AMToneAntennaPin
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    '[io:squareWave]' _AMToneRadioFrequency _AMToneAntennaPin
    waitMicros halfCycle
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'micro:bit') {
      _tonePin = 0
    } ((boardType) == 'micro:bit v2') {
      _tonePin = 27
    } ((boardType) == 'Clue') {
      _tonePin = 21
    } else {
      _tonePin = 0
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to attachAMAntenna pin rfFreq {
  _AMToneAntennaPin = pin
  _AMToneRadioFrequency = rfFreq
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

module Chiptune Output
author MicroBlocks
version 1 0 
description 'Play 1-bit drum sounds and other sound effects on regular digital pins, and 8-bit snares and cymbals on DAC pins, on boards that have them.

It is recommended to mix all pin signals together through 4.7KÎ© resistors and into the positive lead of the audio line. Ground should also pass through a 4.7KÎ© resistor and be connected to the negative lead of the audio line.'

  spec ' ' 'ct kick' 'kick for _ ms on pin _' 'auto auto' 250 4
  spec ' ' 'ct tom' 'tom for _ ms pitch shifted by _ on pin _' 'auto auto auto' 250 1000 4
  space
  spec ' ' 'ct laser' 'laser for _ ms with frequency _ speed _ on pin _' 'auto auto auto auto' 500 500 5 4
  spec ' ' 'ct noise' 'noise for _ ms pitch shifted by _ on pin _' 'auto auto auto' 500 1000 4
  space
  spec ' ' 'ct fadenoise' 'fade noise for _ ms pitch shifted by _ on DAC pin _' 'auto auto auto' 1000 800 10
  spec ' ' 'ct snare' 'snare for _ ms on DAC pin _' 'auto auto' 200 10
  spec ' ' 'ct hihat' 'hihat for _ ms on DAC pin _' 'auto auto' 250 10

to 'ct fadenoise' ms delay pin {
  local 'start' (millisOp)
  for i ('[data:range]' 10000 0 (10000 / ms)) {
    analogWriteOp pin (i / 10)
    waitMicros (random 0 delay)
    analogWriteOp pin 0
    waitMicros (random 0 delay)
    if (((millisOp) - start) >= ms) {
      return ''
    }
  }
}

to 'ct hihat' ms pin {
  'ct fadenoise' ms 250 pin
}

to 'ct kick' ms pin {
  for i ('[data:range]' 1 10000 (100000 / ms)) {
    digitalWriteOp pin true
    waitMicros i
    digitalWriteOp pin false
    waitMicros i
  }
}

to 'ct laser' ms mod speed pin {
  local 'i' 0
  local 'start' (millisOp)
  repeatUntil (((millisOp) - start) >= ms) {
    digitalWriteOp pin true
    waitMicros (i % mod)
    digitalWriteOp pin false
    waitMicros (i % mod)
    i += speed
  }
}

to 'ct noise' ms delay pin {
  local 'start' (millisOp)
  repeatUntil (((millisOp) - start) >= ms) {
    digitalWriteOp pin true
    waitMicros (random 0 delay)
    digitalWriteOp pin false
    waitMicros (random 0 delay)
  }
}

to 'ct snare' ms pin {
  'ct fadenoise' ms 1000 pin 
}

to 'ct tom' ms delay pin {
  for i ('[data:range]' 1 10000 ((50000 + (10 * delay)) / ms)) {
    digitalWriteOp pin true
    waitMicros i
    digitalWriteOp pin false
    waitMicros delay
  }
}

module 'DAC MCP4725' Output
author 'Luis Mateos - @proyectonoise'
version 1 0 
tags DAC MCP4725 
description 'MCP 4725
Digital to Analog Converter 12 bits
'

	spec ' ' 'ADC di' 'DAC MCP4725 - address _ value _ write EEPROM _' 'auto auto bool' 96 1236 false

to 'ADC di' direccion valor eeprom {
  local 'orden' (booleanConstant false)
  if (eeprom == (booleanConstant true)) {
    orden = (hexToInt '60')
  } else {
    orden = (hexToInt '40')
  }
  '[sensors:i2cWrite]' direccion ('[data:makeList]' orden (valor >> 4) ((valor << 4) & (hexToInt 'F0')))
}

module MIDI Output
author MicroBlocks
version 1 4 
choices druminst 'Acoustic Bass Drum' 'Bass Drum 1' 'Side Stick' 'Acoustic Snare' 'Hand Clap' 'Electric Snare' 'Low Floor Tom' 'Closed Hi-Hat' 'High Floor Tom' 'Pedal Hi-Hat' 'Low Tom' 'Open Hi-Hat' 'Low-Mid Tom' 'Hi-Mid Tom' 'Crash Cymbal 1' 'High Tom' 'Ride Cymbal 1' 'Chinese Cymbal' 'Ride Bell' Tambourine 'Splash Cymbal' Cowbell 'Crash Cymbal 2' Vibraslap 'Ride Cymbal 2' 'Hi Bongo' 'Low Bongo' 'Mute Hi Conga' 'Open Hi Conga' 'Low Conga' 'High Timbale' 'Low Timbale' 'High Agogo' 'Low Agogo' Cabasa Maracas 'Short Whistle' 'Long Whistle' 'Short Guiro' 'Long Guiro' Claves 'Hi Wood Block' 'Low Wood Block' 'Mute Cuica' 'Open Cuica' 'Mute Triangle' 'Open Triangle' 
choices instrument piano 'chromatic percussion' organ guitar bass strings ensemble brass reed pipe 'synth lead' 'synth pad' 'synth SFX' ethnic percussive SFX 
choices drumkits standard room power electronic 'TR-808' jazz brush orchestra SFX 'CM-64/CM-32L' 
choices controls 'bank select 1' 'bank select 2' modulation 'portamento time' volume pan expression hold portamento sostenuto soft resonance 'release time' 'attack time' cutoff 'decay time' 'vibrato rate' 'vibrato depth' 'vibrato delay' 'portamento control' 'effect 1' 'effect 2' 
description 'Control MIDI devices. By default, it interfaces the hardware serial port, but it also supports software serial and USB MIDI.

Software Serial Ports
---------------------
You can specify a software serial port using the `set MIDI pin` block. On most boards, however, the default serial pin is going to be pin 1, so there is no need to use the `set MIDI pin` block. Connect pin 5 of the MIDI DIN connector to the serial pin, and pin 4 of the MIDI DIN connector to 3.3v or 5v.

USB MIDI
--------
Alternatively, if you want to use the MIDI library to control a USB MIDI device -or a virtual synth running in your PC, even while MicroBlocks is running- you can do so by setting the `use USB MIDI` flag to true in the `set MIDI pin` block.
'
variables _MIDI_initialized _MIDI_pin _MIDI_drums 

  spec ' ' 'play MIDI note' 'play MIDI note _ for _ ms on channel _ volume _' 'auto auto auto auto' 60 500 1 127
  spec ' ' 'send note' 'set MIDI note _ to _ on channel _ volume _' 'auto bool auto auto' 60 true 1 127
  space
  spec 'r' 'note to MIDI' 'note _ octave _ to MIDI key' 'auto auto' 'c' 0
  space
  spec ' ' 'select MIDI instrument' 'select MIDI instrument _ for channel _' 'auto auto' '10' 2
  spec 'r' 'instrument' 'instrument _ number _' 'menu.instrument menu.range:1-8' 'piano' 1
  spec ' ' 'select MIDI drum kit' 'select MIDI drum kit _' 'menu.drumkits' 'brush'
  space
  spec ' ' 'play MIDI drum' 'play MIDI drum _ for _ ms volume _' 'menu.druminst num num' 'Acoustic Snare' 100 80
  spec 'r' 'drum note' 'drum _' 'menu.druminst' 'Ride Cymbal 2'
  space
  spec ' ' 'change MIDI control' 'change MIDI control _ on channel _ to _' 'menu.controls auto auto' 'modulation' 1 127
  spec ' ' 'pitch bend channel' 'pitch bend MIDI channel _ to _ %' 'auto auto' 1 -50
  space
  spec ' ' 'send MIDI reset' 'send MIDI reset'
  space
  spec ' ' 'send MIDI start playing' 'send MIDI start playing'
  spec ' ' 'send MIDI stop playing' 'send MIDI stop playing'
  spec ' ' 'send MIDI continue playing' 'send MIDI continue playing'
  space
  spec ' ' 'set MIDI pin' 'set MIDI signal to pin _ : use USB MIDI _' 'auto bool' 8 false
  space
  spec ' ' '_MIDI init' '_MIDI init'
  space
  spec ' ' '_MIDI command' '_MIDI command _ channel _ arg1 _ : arg2 _' 'num num num num' 9 1 60 127
  spec ' ' '_MIDI send bytes' '_MIDI send bytes _' 'auto' ''
  space
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_MIDI command' cmd channel arg1 arg2 {
  '_MIDI init'
  local 'cmdByte' ((cmd << 4) | ((channel - 1) & 15))
  local 'oneArgByte' ((pushArgCount) < 4)
  if (_MIDI_pin == 0) {
    if oneArgByte {
      '[serial:write]' ('[data:makeList]' cmdByte arg1)
    } else {
      '[serial:write]' ('[data:makeList]' cmdByte arg1 arg2)
    }
  } (_MIDI_pin == 'USB') {
    if oneArgByte {
      '[serial:midiSend]' cmdByte arg1
    } else {
      '[serial:midiSend]' cmdByte arg1 arg2
    }
  } else {
    '[io:softWriteByte]' cmdByte _MIDI_pin 31250
    '[io:softWriteByte]' arg1 _MIDI_pin 31250
    if (not oneArgByte) {
      '[io:softWriteByte]' arg2 _MIDI_pin 31250
    }
  }
}

to '_MIDI init' {
  if (not _MIDI_initialized) {
    if (_MIDI_pin == 0) {
      '[serial:open]' 31250
    } else {
      '[serial:close]'
    }
    _MIDI_initialized = (booleanConstant true)
  }
}

to '_MIDI send bytes' byteList {
  '_MIDI init'
  if (isType byteList 'number') {
    byteList = ('[data:makeList]' byteList)
  }
  for byte byteList {
    if (_MIDI_pin == 0) {
      '[serial:write]' byte
    } (_MIDI_pin == 'USB') {
      '[serial:midiSend]' byte
    } else {
      '[io:softWriteByte]' byte _MIDI_pin 31250
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'change MIDI control' control channel value {
  local 'controlChangeCmd' 11
  local 'controller' (at ('[data:find]' control ('[data:makeList]' 'bank select 1' 'bank select 2' 'modulation' 'portamento time' 'volume' 'pan' 'expression' 'hold' 'portamento' 'sostenuto' 'soft' 'resonance' 'release time' 'attack time' 'cutoff' 'decay time' 'vibrato rate' 'vibrato depth' 'vibrato delay' 'portamento control' 'effect 1' 'effect 2')) ('[data:makeList]' 0 32 1 5 7 10 11 64 65 66 67 71 72 73 74 75 76 77 78 84 91 93))
  '_MIDI command' controlChangeCmd channel controller value
}

to 'drum note' instrument {
  if (not (isType _MIDI_drums 'list')) {_MIDI_drums = ('[data:split]' 'Acoustic Bass Drum,Bass Drum 1,Side Stick,Acoustic Snare,Hand Clap,Electric Snare,Low Floor Tom,Closed Hi-Hat,High Floor Tom,Pedal Hi-Hat,Low Tom,Open Hi-Hat,Low-Mid Tom,Hi-Mid Tom,Crash Cymbal 1,High Tom,Ride Cymbal 1,Chinese Cymbal,Ride Bell,Tambourine,Splash Cymbal,Cowbell,Crash Cymbal 2,Vibraslap,Ride Cymbal 2,Hi Bongo,Low Bongo,Mute Hi Conga,Open Hi Conga,Low Conga,High Timbale,Low Timbale,High Agogo,Low Agogo,Cabasa,Maracas,Short Whistle,Long Whistle,Short Guiro,Long Guiro,Claves,Hi Wood Block,Low Wood Block,Mute Cuica,Open Cuica,Mute Triangle,Open Triangle' ',')}
  return (('[data:find]' instrument _MIDI_drums) + 34)
}

to instrument instrument number {
  local 'categories' ('[data:split]' 'piano,chromatic percussion,organ,guitar,bass,strings,ensemble,brass,reed,pipe,synth lead,synth pad,synth SFX,ethnic,percussive,SFX' ',')
  return (((('[data:find]' instrument categories) - 1) * 8) + number)
}

to 'note to MIDI' note octave {
  local 'noteNames' ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
  local 'midiKeys' ('[data:makeList]' 60 61 62 63 64 65 66 67 68 69 70 71 59 61 61 63 63 65 64 66 66 68 68 70 70 72)
  return ((at ('[data:find]' ('_trimmedLowercase' note) noteNames) midiKeys) + (octave * 12))
}

to 'pitch bend channel' channel percent {
  local 'pitchBendCmd' 14
  local 'bendMSB' (maximum 0 (minimum (((64 * percent) / 100) + 64) 127))
  '_MIDI command' pitchBendCmd channel 0 bendMSB
}

to 'play MIDI drum' drumName duration volume {
  if (isType drumName 'number') {
    'send note' drumName true 10 volume
  } else {
    'send note' ('drum note' drumName) true 10 volume
  }
  waitMillis (duration - 3)
}

to 'play MIDI note' 'midi note' duration channel volume {
  'send note' (v 'midi note') true channel volume
  waitMillis (duration - 3)
  'send note' (v 'midi note') false channel 0
}

to 'select MIDI drum kit' drumkit {
  local 'programChangeCmd' 12
  '_MIDI command' programChangeCmd 10 ((at ('[data:find]' drumkit ('[data:split]' 'standard,room,power,electronic,TR-808,jazz,brush,orchestra,SFX,CM-64/CM-32L' ',')) ('[data:split]' '1,9,17,25,26,33,41,49,57,128' ',')) - 1)
}

to 'select MIDI instrument' 'instrument number' channel {
  local 'programChangeCmd' 12
  '_MIDI command' programChangeCmd channel ((v 'instrument number') - 1)
}

to 'send MIDI continue playing' {
  '_MIDI send bytes' (hexToInt 'FB')
}

to 'send MIDI reset' {
  '_MIDI send bytes' (hexToInt 'FF')
  '_MIDI send bytes' ('[data:makeList]' (hexToInt 'F0') (hexToInt '7E') (hexToInt '7F') (hexToInt '09') (hexToInt '01') (hexToInt 'F7'))
  comment 'Turn off all notes on all channels'
  for chan 16 {
    for key 128 {
      'send note' (key - 1) false chan 0
    }
  }
}

to 'send MIDI start playing' {
  '_MIDI send bytes' (hexToInt 'FA')
}

to 'send MIDI stop playing' {
  '_MIDI send bytes' (hexToInt 'FC')
}

to 'send note' 'midi note' on/off channel volume {
  if (isType (v 'midi note') 'list') {
    for note (v 'midi note') {
      'send note' note on/off channel volume
    }
  } else {
    local 'noteOnMsg' 9
    if on/off {
      '_MIDI command' noteOnMsg channel (v 'midi note') volume
    } else {
      '_MIDI command' noteOnMsg channel (v 'midi note') 0
    }
  }
}

to 'set MIDI pin' pin USB {
  '[serial:close]'
  if USB {
    _MIDI_pin = 'USB'
  } else {
    _MIDI_pin = pin
  }
  _MIDI_initialized = (booleanConstant false)
  '_MIDI init'
}

module 'OS MP3 Player'
author 'VÃ­ctor Casado'
version 1 0 
tags sound 
choices playModes 'play once' 'repeat all' 'repeat song' 
description 'A library for the OPEN-SMART Serial MP3 Player:

https://es.aliexpress.com/item/32782488336.html

A few hints:

- SD card mut be formatted in FAT16 or FAT32.
- Songs must be named 001xxx.mp3, 002xxx.mp3 and so on.
- Directories currently not supported.
'

  spec ' ' '_OSMP3 send command data' '_OSMP3 send command _ : data _' 'auto auto' '' ''
  spec ' ' 'OS MP3 initialize' 'OS MP3 initialize'
  spec ' ' 'OS MP3 set play mode' 'OS MP3 set play mode _ : number _' 'menu.playModes auto' 'play once' 1
  spec ' ' 'OS MP3 play' 'OS MP3 play'
  spec ' ' 'OS MP3 play song number' 'OS MP3 play song number _' 'auto' 1
  spec ' ' 'OS MP3 pause' 'OS MP3 pause'
  spec ' ' 'OS MP3 stop' 'OS MP3 stop'
  spec ' ' 'OS MP3 next song' 'OS MP3 next song'
  spec ' ' 'OS MP3 previous song' 'OS MP3 previous song'
  spec ' ' 'OS MP3 forward' 'OS MP3 forward'
  spec ' ' 'OS MP3 rewind' 'OS MP3 rewind'
  spec ' ' 'OS MP3 volume up' 'OS MP3 volume up'
  spec ' ' 'OS MP3 volume down' 'OS MP3 volume down'
  spec ' ' 'OS MP3 set volume' 'OS MP3 set volume _ (0-30)' 'auto' 15

to '_OSMP3 send command data' cmd data {
  local 'byteList' ('[data:makeList]')
  if (cmd < (hexToInt '1F')) {
    byteList = ('[data:makeList]' (hexToInt '7E') (hexToInt '02') cmd (hexToInt 'EF'))
  } (cmd < (hexToInt '40')) {
    byteList = ('[data:makeList]' (hexToInt '7E') (hexToInt '03') cmd data (hexToInt 'EF'))
  } (cmd < (hexToInt '50')) {
    byteList = ('[data:makeList]' (hexToInt '7E') (hexToInt '03') cmd (data >> 8) data (hexToInt 'EF'))
  }
  waitMillis 50
  '[serial:write]' ('[data:asByteArray]' byteList)
}

to 'OS MP3 initialize' {
  '[serial:open]' 9600
  '_OSMP3 send command data' (hexToInt '35') (hexToInt '01')
  waitMillis 500
}

to 'OS MP3 set play mode' mode number {
  if (mode == 'repeat all') {
    '_OSMP3 send command data' (hexToInt '33') (hexToInt '00')
  } (mode == 'play once') {
    '_OSMP3 send command data' (hexToInt '33') (hexToInt '01')
  } (mode == 'repeat song') {
    '[serial:write]' ('[data:asByteArray]' ('[data:makeList]' (hexToInt '7E') (hexToInt '04') (hexToInt '33') ((number >> 8) & 255) (number & 255) (hexToInt 'EF')))
  }
}

to 'OS MP3 play' {
  '_OSMP3 send command data' (hexToInt '01')
}

to 'OS MP3 play song number' number {
  '_OSMP3 send command data' (hexToInt '41') number
}

to 'OS MP3 pause' {
  '_OSMP3 send command data' (hexToInt '02')
}

to 'OS MP3 stop' {
  '_OSMP3 send command data' (hexToInt '0E')
}

to 'OS MP3 next song' {
  '_OSMP3 send command data' (hexToInt '03')
}

to 'OS MP3 previous song' {
  '_OSMP3 send command data' (hexToInt '04')
}

to 'OS MP3 forward' {
  '_OSMP3 send command data' (hexToInt '0A')
}

to 'OS MP3 rewind' {
  '_OSMP3 send command data' (hexToInt '0B')
}

to 'OS MP3 volume up' {
  '_OSMP3 send command data' (hexToInt '05')
}

to 'OS MP3 volume down' {
  '_OSMP3 send command data' (hexToInt '06')
}

to 'OS MP3 set volume' volume {
  if (volume < 0) {
    volume = 0
  } (volume > 30) {
    volume = 30
  }
  '_OSMP3 send command data' (hexToInt '31') volume
}
module 'MP3 Player' Output
author MicroBlocks
version 1 10 
choices mp3PlayerType MakerPort 'MakerBit/HyperDuino' DFRobot Octopus 
description 'Support for Octopus (FN-M16P and YX6300 chips) and DFRobot/HyperDuino/MakerBit/MakerPort) MP3 Players (YX5300, A19HFA440, and GD3300B chips).

Sends commands to MP3 player using software serial via any digital pin on any board.

To use the "mp3 play ... until done" block, connect TX of MP3 player to a second pin and set that pin as the optional "rx pin" in the "mp3 initialize" block .
'
variables _mp3UseChecksum _mp3Pin _mp3RxPin 

  spec ' ' 'mp3_initialize' 'mp3 initialize _ pin _ : rx pin _' 'menu.mp3PlayerType num num' 'MakerPort' 20 21
  spec ' ' 'mp3_setVolume' 'mp3 set volume _ (0-30)' 'num' 20
  space
  spec ' ' 'mp3_playTrack' 'mp3 play track _ in folder _' 'num num' 1 1
  spec ' ' 'mp3_playTrackUntilDone' 'mp3 play track _ in folder _ until done' 'num num' 1 1
  space
  spec ' ' 'mp3_nextTrack' 'mp3 play next track'
  spec ' ' 'mp3_repeatAllInFolder' 'mp3 repeat all in folder _' 'num' 1
  space
  spec ' ' 'mp3_pause' 'mp3 pause'
  spec ' ' 'mp3_resume' 'mp3 resume'
  space
  spec ' ' '_mp3_sendMP3Cmd' '_mp3_sendMP3Cmd _ _ _' 'auto num num' '0x0C' 0 0
  spec ' ' '_mp3_waitForResponse' '_mp3_waitForResponse'

to '_mp3_sendMP3Cmd' cmd arg1 arg2 {
  if (_mp3UseChecksum == 0) {
    sayIt 'MP3 Player is not initialized'
    return 0
  }
  if _mp3UseChecksum {
    comment 'Include checksum (10 bytes total)'
    local 'msg' ('[data:makeList]' (hexToInt '7E') (hexToInt 'FF') 6 (hexToInt cmd) 0 arg1 arg2 0 0 (hexToInt 'EF'))
    local 'sum' 0
    for i 6 {
      sum += (at (i + 1) msg)
    }
    sum = (65536 - sum)
    atPut 8 msg ((sum >> 8) & 255)
    atPut 9 msg (sum & 255)
  } else {
    comment 'No checksum (8 bytes total)'
    local 'msg' ('[data:makeList]' (hexToInt '7E') (hexToInt 'FF') 6 (hexToInt cmd) 0 arg1 arg2 (hexToInt 'EF'))
  }
  comment 'Send the command'
  for byte msg {
    '[io:softWriteByte]' byte _mp3Pin 9600
  }
  waitMillis 100
}

to '_mp3_waitForResponse' {
  comment 'Wait for a response on _mp3RxPin.
Note: a low value on _mp3RxPin is the start of a response message.
We do not read the actual message but wait 20 bytes worth of time.'
  if (_mp3RxPin >= 0) {
    local 'endTime' ((millisOp) + 3000)
    repeatUntil (not (digitalReadOp _mp3RxPin)) {
      if ((millisOp) > endTime) {return 0}
    }
    waitMillis 21
  } else {
    comment 'RX pin not set so just wait a few seconds.'
    waitMillis 3000
  }
}

to mp3_initialize type pin optionalRxPin {
  _mp3UseChecksum = ('Octopus' != type)
  _mp3Pin = pin
  _mp3RxPin = -1
  if ((pushArgCount) > 2) {
    _mp3RxPin = optionalRxPin
  }
  comment 'Reset'
  '_mp3_sendMP3Cmd' '0x0C' 0 0
  if (_mp3RxPin >= 0) {
    '_mp3_waitForResponse'
  } else {
    waitMillis 1000
  }
}

to mp3_nextTrack {
  comment 'Skip to the next track in the current folder, wrapping back to the first track.'
  mp3_pause
  comment 'Disable folder repeat'
  '_mp3_sendMP3Cmd' '0x08' 0 0
  waitMillis 50
  '_mp3_sendMP3Cmd' '0x01' 0 0
}

to mp3_pause {
  '_mp3_sendMP3Cmd' '0x0E' 0 0
}

to mp3_playTrack trackNum folderNum {
  comment 'Play the given track in the given folder.
If folder is 0, play the given track at the top level of the SD card.
Folder names must start with two digits, 01-99.
Track names in a folder must start with three digits, 001-999.
Track names at the top level must start with four digits, 0001-9999.
This sets the folder for the "play next track in folder" command.'
  if (folderNum < 1) {
    comment 'Play top-level track (e.g. 0001)'
    '_mp3_sendMP3Cmd' '0x03' 0 trackNum
  } else {
    comment 'Play track in folder'
    '_mp3_sendMP3Cmd' '0x0F' folderNum trackNum
    comment 'Hack: Send command twice to increase reliability on MakerPort v1.00'
    '_mp3_sendMP3Cmd' '0x0F' folderNum trackNum
  }
}

to mp3_playTrackUntilDone trackNum folderNum {
  if (_mp3RxPin < 0) {sayIt 'To use this feature, set the RX pin in "mp3 initialize".'}
  mp3_playTrack trackNum folderNum
  if (_mp3RxPin >= 0) {
    waitUntil (not (digitalReadOp _mp3RxPin))
  } else {
    comment 'RX pin not set so just wait a few seconds.'
    waitMillis 5000
  }
}

to mp3_repeatAllInFolder folderNum {
  comment 'Repeatedly play all files in the given folder. Does not work for top level (folder 0).'
  '_mp3_sendMP3Cmd' '0x17' folderNum folderNum
  mp3_resume
}

to mp3_resume {
  '_mp3_sendMP3Cmd' '0x0D' 0 0
}

to mp3_setVolume level {
  comment 'Range is 0-30'
  '_mp3_sendMP3Cmd' '0x06' 0 level
}

module MultiTone Output
author MicroBlocks
version 1 1 
description 'On boards that support it, play up to four simultaneous voices of music through a single speaker. The best sound quality is obtained by playing through through an amplified external speaker, but you can hear it through the built-in speakers on the micro:bit V2, Circuit Playground Express and Bluefruit, and M5 Stack/Core.

Note: This library does NOT work on the original micro:bit or Calliope mini!

To output the audio waveform, the board must have a DAC (e.g. SAMD21 and ESP32 boards) or fast enough pulse-width modulation (PWM) hardware to simulate a DAC (e.g. nRF52 boards). To tune the output to standard A=440 pitch on boards with different clock speeds, change the tuningConstant variable in _stepForNote.'
variables _multiTonePin _multiToneInitialized _v1 _v2 _v3 _v4 _v1Step _v2Step _v3Step _v4Step 

	spec ' ' 'playNoteOnVoice' 'play note _ octave _ for _ ms voice _' 'auto num num num' 'A' 0 500 1
	spec ' ' 'setMultitonePin' 'set multitone pin _' 'auto' ''
	spec 'r' '_baseFreqForNoteMulti' '_baseFreqForNoteMulti _' 'auto' 'A'
	spec ' ' '_initMultiTone' '_initMultiTone'
	spec ' ' '_multiToneLoop' '_multiToneLoop'
	spec 'r' '_nextSample' '_nextSample'
	spec 'r' '_stepForNote' '_stepForNote _ octave _' 'str num' 'A' 0
	spec 'r' '_uppercaseNote' '_uppercaseNote _' 'auto' ' a '

to '_baseFreqForNoteMulti' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case and may be followed
by # for a sharp or _ for a flat.'
  note = ('_uppercaseNote' note)
  if (note == 'C') {
    return 261626
  } (note == 'D') {
    return 293665
  } (note == 'E') {
    return 329628
  } (note == 'F') {
    return 349228
  } (note == 'G') {
    return 391995
  } (note == 'A') {
    return 440000
  } (note == 'B') {
    return 493883
  }
  if (or (note == 'C#') (note == 'D_')) {
    return 277183
  } (or (note == 'D#') (note == 'E_')) {
    return 311127
  } (or (note == 'F#') (note == 'G_')) {
    return 369994
  } (or (note == 'G#') (note == 'A_')) {
    return 415305
  } (or (note == 'A#') (note == 'B_')) {
    return 466164
  }
  comment 'Unrecognized note names map to 0.1 Hz, which is inaudible.
This helps users find typos in their tunes.'
  return 100
}

to '_initMultiTone' {
  if ((boardType) == 'micro:bit v2') {
    _multiTonePin = 27
  } ((boardType) == 'Clue') {
    _multiTonePin = 21
  } (or ((boardType) == 'Citilab ED1') ((boardType) == 'M5StickC')) {
    _multiTonePin = 26
  } ((boardType) == 'M5Stack-Core') {
    _multiTonePin = 25
  } else {
    _multiTonePin = 0
  }
  _multiToneInitialized = true
}

to '_multiToneLoop' {
  if (not _multiToneInitialized) { '_initMultiTone' }
  comment 'Set initial sample values to virtual zero (the middle of their range).'
  _v1 = 65536
  _v2 = 65536
  _v3 = 65536
  _v4 = 65536
  comment 'Generate and output sound samples. The DAC on the ESP32
is only 8-bits. Other boards have 10-bit DAC or PWM output.'
  if (or ((boardType) == 'Citilab ED1') ((boardType) == 'M5Stack-Core')) {
    forever {
      analogWriteOp _multiTonePin ((('_nextSample') >> 3) + 128)
    }
  } else {
    forever {
      analogWriteOp _multiTonePin (('_nextSample') + 512)
    }
  }
}

to '_nextSample' {
  comment 'Generate up to four triangle waves. v1-v4 hold the current state of
each voice. These numbers range from 0-262143 and are increased by _v1Step-v4Step
each time this function is called. When the state rises above 131072, the output
value begins to decreases back to zero, so the output value for each voice ranges
from 0-131072 with the middle (65536) being "zero". This code has been optimized
to all four voices to be generated fast enough to play in real time on micro:bit v2.'
  _v1 = ((_v1 + _v1Step) & 262143)
  _v2 = ((_v2 + _v2Step) & 262143)
  _v3 = ((_v3 + _v3Step) & 262143)
  _v4 = ((_v4 + _v4Step) & 262143)
  local 'out' 0
  if (_v1 < 131072) {
    out += (_v1 - 65536)
  } else {
    out += (196608 - _v1)
  }
  if (_v2 < 131072) {
    out += (_v2 - 65536)
  } else {
    out += (196608 - _v2)
  }
  if (_v3 < 131072) {
    out += (_v3 - 65536)
  } else {
    out += (196608 - _v3)
  }
  if (_v4 < 131072) {
    out += (_v4 - 65536)
  } else {
    out += (196608 - _v4)
  }
  return (out >> 9)
}

to '_stepForNote' note octave {
  comment 'Return the step size required to generate the given note name in the given octave.
To make the pitches match other instruments, adjust tuningConstant so that an A
in octave zero generates a pitch as close as possible to 440Hz.'
  local 'tuningConstant' 329
  local 'freq' ('_baseFreqForNoteMulti' note)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  return ((freq * tuningConstant) >> 14)
}

to '_uppercaseNote' aString {
  local 'result' (newList (size aString))
  '[data:delete]' 'all' result
  for i (size aString) {
    local 'ch' ('[data:unicodeAt]' i aString)
    if (ch > 32) {
      if (and (97 <= ch) (ch <= 122)) {
        '[data:addLast]' (ch - 32) result
      } else {
        '[data:addLast]' ch result
      }
    }
  }
  return ('[data:unicodeString]' result)
}

to playNoteOnVoice note octave ms voice {
  comment 'Make sure _multiToneLoop is running. Set the step size for the given
voice to start playing the note, wait ms miliseconds, then set step size
to zero to to stop the note.'
  sendBroadcast '_multiToneLoop'
  if (1 == voice) {
    _v1Step = ('_stepForNote' note octave)
    waitMillis ms
    _v1Step = 0
  } (2 == voice) {
    _v2Step = ('_stepForNote' note octave)
    waitMillis ms
    _v2Step = 0
  } (3 == voice) {
    _v3Step = ('_stepForNote' note octave)
    waitMillis ms
    _v3Step = 0
  } (4 == voice) {
    _v4Step = ('_stepForNote' note octave)
    waitMillis ms
    _v4Step = 0
  }
}

to setMultitonePin pin {
  if (pin == '') {
    _multiToneInitialized = false
    return 0
  }
  _multiTonePin = pin
  _multiToneInitialized = true
}

module Pluck Output
author MicroBlocks
version 1 1 
depends Tone 
description 'Uses a simple algorithm to synthesize a plucked-string sound similar to an acoustic guitar (see https://en.wikipedia.org/wiki/KarplusâStrong_string_synthesis).

Note: This library does NOT work on the original micro:bit or Calliope mini!

To output the generated waveform, the board must have a DAC (e.g. SAMD21 and ESP32 boards) or fast enough pulse-width modulation (PWM) hardware to simulate a DAC (e.g. nRF52xxx boards). To tune the output to standard A=440 pitch on boards with different clock speeds, change the tuningConstant variable in _pitchToBufferLength.'
variables _pluckInitialized _pluckPin _pluckShift _pluckOffset 

	spec ' ' 'pluckNote' 'pluck note _ octave _ for _ ms' 'str num num' 'C' 0 3000
	spec ' ' 'pluckMidiKey' 'pluck MIDI key _ for _ msecs' 'num num' 60 3000
	spec ' ' 'setPluckPin' 'set pluck pin _' 'auto' ''
	spec ' ' '_initPluck' '_initPluck'
	spec ' ' '_playPluck' '_playPluck _ for _ msecs' 'num num' 80 3000
	spec 'r' '_pitchToBufferLength' '_pitchToBufferLength _' 'num' 440
	spec 'r' '_midiKeyToPitch' '_midiKeyToPitch _' 'num' 60

to '_initPluck' {
  _pluckShift = 0
  _pluckOffset = 512
  if ((boardType) == 'micro:bit v2') {
    _pluckPin = 27
  } ((boardType) == 'Clue') {
    _pluckPin = 21
  } (or ((boardType) == 'Citilab ED1') ((boardType) == 'M5StickC')) {
    _pluckShift = 3
    _pluckOffset = 128
    _pluckPin = 26
  } ((boardType) == 'M5Stack-Core') {
    _pluckShift = 3
    _pluckOffset = 128
    _pluckPin = 25
  } else {
    _pluckPin = 0
  }
  _pluckInitialized = true
}

to '_midiKeyToPitch' key {
  local 'freq' (at ((key % 12) + 1) ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  return (freq / 1000)
}

to '_pitchToBufferLength' pitch {
  comment 'Adjust the tuning constant so that pluck pitch is correct.
(Compare with a piano or other instrument.)'
  local 'tuningConstant' 21000
  return (maximum 3 (tuningConstant / pitch))
}

to '_playPluck' bufSize msecs {
  if (not _pluckInitialized) {'_initPluck'}
  local 'buf' (newList bufSize)
  for i (bufSize / 5) {
    atPut i buf (random -400 400)
  }
  local 'endTime' ((millisOp) + msecs)
  repeatUntil ((millisOp) > endTime) {
    for i (bufSize - 1) {
      local 'sample' (((at i buf) + (at (i + 1) buf)) / 2)
      atPut i buf sample
      sample = ((sample >> _pluckShift) + _pluckOffset)
      analogWriteOp _pluckPin sample
      waitMicros 20
    }
    atPut bufSize buf (at 1 buf)
  }
}

to pluckMidiKey key msecs {
  local 'pitch' ('_midiKeyToPitch' key)
  '_playPluck' ('_pitchToBufferLength' pitch) msecs
}

to pluckNote note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    comment 'Rest or unrecognized note'
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_playPluck' ('_pitchToBufferLength' (freq / 1000)) ms
}

to setPluckPin pin {
  if (pin == '') {
    _pluckInitialized = false
    return 0
  }
  _pluckPin = pin
  _pluckShift = 0
  _pluckOffset = 512
  _pluckInitialized = true
}

module Rhythm Control
author MicroBlocks
version 1 3 
description 'Sends broadcasts according to a tempo and time signature. Useful to create musical patterns.

Includes abstractions for note durations, bars and beats.'
variables _rhy_tempo _rhy_looping _rhy_pattern _rhy_beat_duration _rhy_measures _rhy_tick 

  spec ' ' 'set tempo to' 'set tempo to _ bpm' 'auto' 200
  spec ' ' 'set time signature to' 'set time signature to _ / _' 'auto auto' 4 4
  spec ' ' 'set up measures' 'set up _ bars pattern' 'auto' 16
  space
  spec ' ' 'start playing' 'start playing'
  spec ' ' 'stop playing' 'stop playing'
  space
  spec ' ' 'rhy broadcast' 'add _ at bar _ beat _' 'auto auto auto' 'kick' 1 1
  spec ' ' 'broadcast remove' 'remove _ from bar _ beat _' 'str auto auto' 'text' 1 1
  space
  spec ' ' 'mute' 'mute _ _' 'str bool' 'text' true
  spec ' ' 'solo' 'solo _ _' 'str bool' 'text' true
  space
  spec 'r' 'current tick for duration' 'current beat'
  spec 'r' 'current bar' 'current bar'
  space
  spec 'r' 'whole duration' 'Â¹ââ'
  spec 'r' 'half duration' 'Â½'
  spec 'r' 'quarter duration' 'Â¼'
  spec 'r' 'eighth duration' 'â'
  spec 'r' 'sixteenth duration' 'Â¹âââ'
  space
  spec 'r' 'dotted' '_ .' 'auto' ''
  spec 'r' 'triplet' 'â¿Â³ _' 'auto' ''
  space
  spec ' ' '_rhythm loop' '_rhythm loop'
  spec 'r' '_rhy duration of note value' '_rhy duration of note value _' 'auto' 4
  spec 'r' '_rhy 2 ^' '_rhy 2 ^ _' 'auto' '10'

to '_rhy 2 ^' n {
  local 'result' 1
  repeat n {
    result = (result * 2)
  }
  return result
}

to '_rhy duration of note value' 'note value' {
  for i (v 'note value') {
    if (('_rhy 2 ^' i) == (v 'note value')) {return (at i ('[data:makeList]' ('half duration') ('quarter duration') ('eighth duration') ('sixteenth duration')))}
  }
  return ('whole duration')
}

to '_rhythm loop' {
  repeatUntil (not _rhy_looping) {
    _rhy_tick = 0
    for bar _rhy_pattern {
      for beat bar {
        local 'start' (millisOp)
        if (not _rhy_looping) {
          stopTask
        }
        for trigger beat {
          if ((0 + trigger) > 30) {
            'send note' (0 + trigger) true 10 80
          } else {
            sendBroadcast trigger
            waitMicros 1000
          }
        }
        waitMillis (_rhy_beat_duration - ((millisOp) - start))
        _rhy_tick += 1
      }
    }
  }
}

to 'broadcast remove' message 'bar number' 'beat number' {
  message = ('[data:join]' message '')
  if ((v 'beat number') == '') {
    for 'each beat' _rhy_measures {
      'broadcast remove' message (v 'bar number') (v 'each beat')
    }
  } ((v 'bar number') == '') {
    for 'each bar' (size _rhy_pattern) {
      'broadcast remove' message (v 'each bar') (v 'beat number')
    }
  } (isType (v 'beat number') 'list') {
    for 'each beat' (v 'beat number') {
      'broadcast remove' message (v 'bar number') (v 'each beat')
    }
  } (isType (v 'bar number') 'list') {
    for 'each bar' (v 'bar number') {
      'broadcast remove' message (v 'each bar') (v 'beat number')
    }
  } else {
    local 'beat' (at (v 'beat number') (at (v 'bar number') _rhy_pattern))
    local 'index' ('[data:find]' message beat)
    if (index > 0) {
      '[data:delete]' index beat
    }
  }
}

to 'current bar' {
  return ((_rhy_tick / _rhy_measures) + 1)
}

to 'current tick for duration' {
  return ((_rhy_tick % _rhy_measures) + 1)
}

to dotted duration {
  return (duration + (duration / 2))
}

to 'eighth duration' {
  if (_rhy_tempo == 0) {_rhy_tempo = 200}
  return (30000 / _rhy_tempo)
}

to 'half duration' {
  if (_rhy_tempo == 0) {_rhy_tempo = 200}
  return (120000 / _rhy_tempo)
}

to mute message on/off {
  message = ('[data:join]' message '')
  if (('[data:find]' '#M#' message) > 0) {
    message = ('[data:copyFromTo]' message 4)
  }
  if (not on/off) {
    message = ('[data:join]' '#M#' message)
  }
  for bar _rhy_pattern {
    for beat bar {
      for i (size beat) {
        if ((at i beat) == message) {if on/off {
          atPut i beat ('[data:join]' '#M#' (at i beat))
        } else {
          atPut i beat ('[data:copyFromTo]' (at i beat) 4)
        }}
      }
    }
  }
}

to 'quarter duration' {
  if (_rhy_tempo == 0) {_rhy_tempo = 200}
  return (60000 / _rhy_tempo)
}

to 'rhy broadcast' message 'bar number' 'beat number' {
  message = ('[data:join]' message '')
  if ((v 'beat number') == '') {
    for 'each beat' _rhy_measures {
      'rhy broadcast' message (v 'bar number') (v 'each beat')
    }
  } ((v 'bar number') == '') {
    for 'each bar' (size _rhy_pattern) {
      'rhy broadcast' message (v 'each bar') (v 'beat number')
    }
  } (isType (v 'beat number') 'list') {
    for 'each beat' (v 'beat number') {
      'rhy broadcast' message (v 'bar number') (v 'each beat')
    }
  } (isType (v 'bar number') 'list') {
    for 'each bar' (v 'bar number') {
      'rhy broadcast' message (v 'each bar') (v 'beat number')
    }
  } else {
    local 'beat' (at (v 'beat number') (at (v 'bar number') _rhy_pattern))
    if (('[data:find]' message beat) < 0) {
      '[data:addLast]' message beat
    }
  }
}

to 'set tempo to' tempo {
  _rhy_tempo = tempo
  if (_rhy_beat_note_value == 0) {
    'set time signature to' 4 4
  }
}

to 'set time signature to' measures 'note value' {
  if (_rhy_tempo == 0) {'set tempo to' 200}
  _rhy_beat_duration = ('_rhy duration of note value' (v 'note value'))
  _rhy_beat_note_value = (v 'note value')
  _rhy_measures = measures
}

to 'set up measures' n {
  _rhy_pattern = ('[data:makeList]')
  for i n {
    '[data:addLast]' ('[data:makeList]') _rhy_pattern
    repeat _rhy_measures {
      '[data:addLast]' ('[data:makeList]') (at i _rhy_pattern)
    }
  }
}

to 'sixteenth duration' {
  if (_rhy_tempo == 0) {_rhy_tempo = 200}
  return (15000 / _rhy_tempo)
}

to solo message on/off {
  message = ('[data:join]' message '')
  mute message false
  for bar _rhy_pattern {
    for beat bar {
      for trigger beat {
        if on/off {
          if (trigger != message) {mute trigger true}
        } else {
          mute trigger false
        }
      }
    }
  }
}

to 'start playing' {
  _rhy_looping = (booleanConstant true)
  sendBroadcast '_rhythm loop'
}

to 'stop playing' {
  _rhy_looping = (booleanConstant false)
}

to triplet duration {
  return ((duration * 2) / 3)
}

to 'whole duration' {
  if (_rhy_tempo == 0) {_rhy_tempo = 200}
  return (240000 / _rhy_tempo)
}

module 'Scales & Chords' Data
author MicroBlocks
version 1 6 
choices scales ionian dorian phrygian lydian mixolydian aeolian locrian 
choices pentatonics major minor 
choices chords major minor diminished 'major 7th' 'minor 7th' Maj7 
choices arpeggio_dst 'MIDI channel' 'tone pin'
description 'Lists of relative semitone intervals for all Western diatonic scales plus the major and minor pentatonic scales.

It also includes intervals for the most common chords and progressions, and an abstraction of the circle of fifths.
'
variables _scales_degrees _scales_circle5ths _tonePin 

  spec 'r' 'scale' '_ scale root _ : steps _' 'menu.scales num num' 'ionian' 60 7
  spec 'r' 'pentatonic scale' 'pentatonic _ scale root _ : steps _' 'menu.pentatonics num num' 'major' 60 7
  space
  spec 'r' 'chord' '_ chord root _ : steps _' 'menu.chords num num' 'major' 60 4
  spec 'r' 'chord2 with roman numeral' '_ chord for root _ : steps _' 'auto auto auto' 'IV' 60 4
  space
  spec ' ' 'arpeggiate' 'arpeggiate _ in order _ duration _ and volume _ on _ _' 'auto auto auto num menu.arpeggio_dst auto' 'aListOfNotes' 'aListOfPositions' 'aDurationOrListOfDurations' 100 'MIDI channel' 1
  space
  spec 'r' 'transposed' '_ transposed _ semitones' 'auto auto' 60 12
  space
  spec 'r' 'degrees' 'chord progression _ with root _ : and _ steps per chord' 'auto auto auto' 'I,IV,viiÂº,iii,vi,ii,V,I' 60 3
  spec 'r' 'rotation' 'rotation _ of circle of 5ths _ M _ m _ Âº' 'auto str str str' 0 '-1,0,1' '-1,0,1' '0'
  space
  spec 'r' '_scales intervals' '_scales intervals _  with root _ and _ steps' 'auto auto auto' 'aList' 60 10
  spec 'r' '_scales degrees' '_scales degrees'
  spec ' ' '_scales_init_circle' '_scales_init_circle'
  spec 'r' '_scales circular item' '_scales circular item _ of _' 'auto auto' '10' ''

to '_scales circular item' n list {
  if (n < 1) {
    return (at ((size list) - ((absoluteValue n) % (size list))) list)
  } else {
    return (at (((n - 1) % (size list)) + 1) list)
  }
}

to '_scales degrees' {
  if (_scales_degrees == 0) {_scales_degrees = ('[data:makeList]' 'I' 'II' 'III' 'IV' 'V' 'VI' 'VII' 'i' 'ii' 'iii' 'iv' 'v' 'vi' 'vii')}
  return _scales_degrees
}

to '_scales intervals' intervals root steps {
  local 'notes' ('[data:makeList]')
  for step steps {
    '[data:addLast]' ((at (((step - 1) % (size intervals)) + 1) intervals) + (root + (12 * ((step - 1) / (size intervals))))) notes
  }
  return notes
}

to '_scales_init_circle' {
  if (_scales_circle5ths == 0) {_scales_circle5ths = ('[data:makeList]' ('[data:makeList]' 'I' 'V' 'II' 'VI' 'III' 'VII' 'bV' 'bII' 'bVI' 'bIII' 'bVII' 'IV') ('[data:makeList]' 'vi' 'iii' 'vii' 'bv' 'bii' 'bvi' 'biii' 'bvii' 'iv' 'i' 'v' 'ii') ('[data:makeList]' 'VIIÂº' 'bVÂº' 'bIIÂº' 'bVIÂº' 'bIIIÂº' 'bVIIÂº' 'IVÂº' 'IÂº' 'VÂº' 'IIÂº' 'VIÂº' 'IIIÂº'))}
}

to arpeggiate 'note list' order duration volume destination channel/pin {
  for i (size order) {
    local 'start' (millisOp)
    if (isType duration 'list') {
      local 'dur' (at i duration)
    } else {
      local 'dur' duration
    }
    if (destination == 'MIDI channel') {
      callCustomCommand 'play MIDI note' ('[data:makeList]' (at (at i order) (v 'note list')) ((dur - ((millisOp) - start)) - 1) channel/pin volume)
    } else {
      if (channel/pin != '') {_tonePin = channel/pin}
      callCustomCommand 'playMIDIKey' ('[data:makeList]' (at (at i order) (v 'note list')) ((dur - ((millisOp) - start)) - 1))
    }
  }
}

to chord which root 'optional steps' {
  local 'steps' (argOrDefault 3 4)
  return ('_scales intervals' (at ('[data:find]' which ('[data:makeList]' 'major' 'minor' 'diminished' 'major 7th' 'minor 7th' 'Maj7')) ('[data:makeList]' ('[data:makeList]' 0 4 7) ('[data:makeList]' 0 3 7) ('[data:makeList]' 0 3 6) ('[data:makeList]' 0 3 7 10) ('[data:makeList]' 0 3 7 10) ('[data:makeList]' 0 4 7 11))) root steps)
}

to 'chord2 with roman numeral' degree root 'optional steps' {
  local 'steps' (argOrDefault 3 3)
  local 'add 7th' (('[data:find]' '7' degree) > 0)
  local 'diminished' ((('[data:find]' 'o' degree) + ('[data:find]' 'Âº' degree)) > 0)
  local 'chord name' ''
  local 'flat' (('[data:find]' 'b' degree) == 1)
  if flat {
    degree = ('[data:copyFromTo]' degree 2 (size degree))
    root += -1
  }
  if (v 'add 7th') {
    degree = ('[data:copyFromTo]' degree 1 ((size degree) - 1))
  }
  if diminished {
    degree = ('[data:copyFromTo]' degree 1 ((size degree) - 1))
  }
  local 'index' ('[data:find]' degree ('_scales degrees'))
  if (index > 7) {
    'chord name' = 'minor'
  } else {
    'chord name' = 'major'
  }
  if (v 'add 7th') {
    'chord name' = ('[data:join]' (v 'chord name') ' 7th')
  }
  if diminished {
    'chord name' = 'diminished'
  }
  return (chord (v 'chord name') (at (((index - 1) % 7) + 1) ('[data:makeList]' (root + 0) (root + 2) (root + 4) (root + 5) (root + 7) (root + 9) (root + 11))) steps)
}

to degrees degrees root 'optional steps' {
  degrees = ('[data:split]' degrees ',')
  local 'steps' (argOrDefault 3 3)
  local 'chords' ('[data:makeList]')
  for i (size degrees) {
    if (isType steps 'list') {
      local 'chord steps' (at i steps)
    } else {
      local 'chord steps' steps
    }
    '[data:addLast]' ('chord2 with roman numeral' (at i degrees) root (v 'chord steps')) chords
  }
  return chords
}

to 'pentatonic scale' which root 'optional steps' {
  local 'steps' (argOrDefault 3 5)
  return ('_scales intervals' (at ('[data:find]' which ('[data:makeList]' 'major' 'minor')) ('[data:makeList]' ('[data:makeList]' 0 2 4 7 9) ('[data:makeList]' 0 3 5 7 10))) root steps)
}

to rotation n majors minors dims {
  '_scales_init_circle'
  local 'degrees' ('[data:makeList]')
  if (majors != '') {
    for index ('[data:split]' majors ',') {
      '[data:addLast]' ('_scales circular item' ((index + n) + 1) (at 1 _scales_circle5ths)) degrees
    }
  }
  if (minors != '') {
    for index ('[data:split]' minors ',') {
      '[data:addLast]' ('_scales circular item' ((index + n) + 1) (at 2 _scales_circle5ths)) degrees
    }
  }
  if (dims != '') {
    for index ('[data:split]' dims ',') {
      '[data:addLast]' ('_scales circular item' ((index + n) + 1) (at 3 _scales_circle5ths)) degrees
    }
  }
  return ('[data:joinStrings]' degrees ',')
}

to scale which root 'optional steps' {
  local 'steps' (argOrDefault 3 7)
  return ('_scales intervals' (at ('[data:find]' which ('[data:makeList]' 'ionian' 'dorian' 'phrygian' 'lydian' 'mixolydian' 'aeolian' 'locrian')) ('[data:makeList]' ('[data:makeList]' 0 2 4 5 7 9 11) ('[data:makeList]' 0 2 3 5 7 9 10) ('[data:makeList]' 0 1 3 5 7 8 10) ('[data:makeList]' 0 2 4 6 7 9 11) ('[data:makeList]' 0 2 4 5 7 9 10) ('[data:makeList]' 0 2 3 5 7 8 10) ('[data:makeList]' 0 1 3 5 6 8 10))) root steps)
}

to transposed 'note or chord' semitones {
  if (isType (v 'note or chord') 'list') {
    local 'notes' (newList (size (v 'note or chord')))
    for i (size (v 'note or chord')) {
      atPut i notes ((at i (v 'note or chord')) + semitones)
    }
    return notes
  } else {
    return ((v 'note or chord') + semitones)
  }
}

module 'Square Wave Chords' Output
author MicroBlocks
version 1 0 
description 'Play square wave chords on three digital pins. It is recommended to mix them together through 4.7KÎ© resistors.'
variables '_digichord harmonies' '_digichord pins' 

  spec ' ' 'digichord chord' 'play chord _ for _ ms' 'auto auto' 'aListOfMIDIkeys' 500
  spec ' ' 'digichord set pins' 'set digital chord pins _ _ _' 'num num num' 4 5 6
  space
  spec ' ' '_digichord harmony 1' '_digichord harmony 1'
  spec ' ' '_digichord harmony 2' '_digichord harmony 2'
  spec ' ' '_digichord harmony 3' '_digichord harmony 3'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0

to '_digichord harmony 1' {
  repeatUntil ((v '_digichord harmonies') == 0) {
    digitalWriteOp (at 1 (v '_digichord pins')) true
    waitMicros (at 1 (v '_digichord harmonies'))
    digitalWriteOp (at 1 (v '_digichord pins')) false
    waitMicros (at 1 (v '_digichord harmonies'))
  }
}

to '_digichord harmony 2' {
  repeatUntil ((v '_digichord harmonies') == 0) {
    digitalWriteOp (at 2 (v '_digichord pins')) true
    waitMicros (at 2 (v '_digichord harmonies'))
    digitalWriteOp (at 2 (v '_digichord pins')) false
    waitMicros (at 2 (v '_digichord harmonies'))
  }
}

to '_digichord harmony 3' {
  repeatUntil ((v '_digichord harmonies') == 0) {
    digitalWriteOp (at 3 (v '_digichord pins')) true
    waitMicros (at 3 (v '_digichord harmonies'))
    digitalWriteOp (at 3 (v '_digichord pins')) false
    waitMicros (at 3 (v '_digichord harmonies'))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to 'digichord chord' chord ms {
  local 'start' (millisOp)
  '_digichord harmonies' = (newList 3)
  for i 3 {
    atPut i (v '_digichord harmonies') ((500000000 / ('_baseFreqForSemitone' (((at i chord) % 12) + 1))) - _toneLoopOverhead)
    sendBroadcast ('[data:join]' '_digichord harmony ' i)
  }
  waitMillis (ms - ((millisOp) - start))
  '_digichord harmonies' = 0
}

to 'digichord set pins' pin1 pin2 pin3 {
  '_digichord pins' = ('[data:makeList]' pin1 pin2 pin3)
}

module WAV Output
author 'JosÃ© GarcÃ­a Yeste'
version 1 3 
description 'Play WAV sound files.
WAV files must be uncompressed, mono or stereo, 8 or 16 bits per sample, sampling rate <= 48000.
Requires a board with a DAC and a file system such as an ESP32.
'

	spec ' ' 'playWAVFile' 'play WAV file _' 'auto' 'filename'
	spec 'r' '_wavChunkID' '_wavChunkID _' 'auto' 'filename'
	spec 'r' '_wavChunkSize' '_wavChunkSize _' 'auto' 'filename'
	spec ' ' '_wavPlayBuffer' '_wavPlayBuffer _ byteCount _ bytesPerSample _ is16Bit _' 'auto num num bool' 'a ByteArray' 0 1 false
	spec ' ' '_wavFail' '_wavFail _' 'auto' ''
	spec 'r' '_wavHeader' '_wavHeader _' 'auto' 'filename'
	spec 'r' '_wavChannels' '_wavChannels _' 'auto' 'a ByteArray'
	spec 'r' '_wavIs16Bit' '_wavIs16Bit _' 'auto' 'a ByteArray'
	spec 'r' '_wavSampleRate' '_wavSampleRate _' 'auto' 'a ByteArray'

to '_wavChannels' header {
  local 'channels' ((at 3 header) | ((at 4 header) << 8))
  if (or (channels < 1) (channels > 2)) {
    '_wavFail' 'Can only play mono or stereo WAV files'
  }
  return channels
}

to '_wavChunkID' filename {
  return ('[data:join]' '' ('[file:readBytes]' 4 filename))
}

to '_wavChunkSize' filename {
  local 'data' ('[file:readBytes]' 4 filename)
  return (((at 1 data) | ((at 2 data) << 8)) | (((at 3 data) << 16) | ((at 4 data) << 24)))
}

to '_wavFail' msg {
  sayIt msg
  halt
}

to '_wavHeader' filename {
  if (('_wavChunkID' filename) != 'RIFF') {'_wavFail' 'Bad WAV file'}
  local 'size' ('_wavChunkSize' filename)
  if (('_wavChunkID' filename) != 'WAVE') {
    '_wavFail' 'Bad WAV file'
  }
  if (('_wavChunkID' filename) != 'fmt ') {
    '_wavFail' 'Bad WAV file'
  }
  local 'size' ('_wavChunkSize' filename)
  local 'header' ('[file:readBytes]' size filename)
  if (or (1 != (at 1 header)) (0 != (at 2 header))) {
    '_wavFail' 'Can only played uncompressed WAV files'
  }
  if (('_wavChunkID' filename) != 'data') {
    '_wavFail' 'Bad WAV file'
  }
  return header
}

to '_wavIs16Bit' header {
  local 'bps' ((at 15 header) | ((at 16 header) << 8))
  if (bps == 8) {
    return false
  } (bps == 16) {
    return true
  }
  '_wavFail' 'WAV file must be 8 or 16 bits per sample'
}

to '_wavPlayBuffer' data byteCount bytesPerSample is16Bit {
  comment 'Write the sound samples in the given ByteArray to the DAC.
The DAC expects unsigned 8-bit samples in the range 0-255.
Samples can be 1, 2, or 4 bytes depending on the combination
of bits/sample (8 or 16) and channels (mono or stereo) but the
last byte of each sample is always the high-order byte of one of
the channels (16-bit samples are little-endian).'
  local 'i' bytesPerSample
  local 'sampleAdjust' 0
  if is16Bit {
    comment '16-bit samples are signed, but the DAC expects unsigned values.
Adding 128 to the high byte of a 16-bit sample converts from a
signed 16-bit sample to an unsigned 8-bit DAC sample.'
    sampleAdjust = 128
  }
  repeatUntil (i > byteCount) {
    local 'sample' (((at i data) + sampleAdjust) & 255)
    if (('[io:dacWrite]' sample) > 0) {
      i += bytesPerSample
    } else {
      waitMillis 1
    }
  }
}

to '_wavSampleRate' header {
  local 'sampleRate' ((at 5 header) | ((at 6 header) << 8))
  if (sampleRate > 48000) {
    '_wavFail' 'Maximum sampling rate is 48000'
  }
  return sampleRate
}

to playWAVFile filename {
  local 'pin' 25
  if ((boardType) == 'Citilab ED1') {
    pin = 26
  }
  if (('[file:fileSize]' filename) == 0) {
    '_wavFail' 'Empty or non-existent WAV file'
  }
  '[file:open]' filename
  local 'header' ('_wavHeader' filename)
  local 'is16Bit' ('_wavIs16Bit' header)
  local 'increment' ('_wavChannels' header)
  if is16Bit {
    increment = (2 * increment)
  }
  '[io:dacInit]' pin ('_wavSampleRate' header)
  local 'bytesRemaining' ('_wavChunkSize' filename)
  local 'data' ('[data:newByteArray]' 100)
  repeatUntil (bytesRemaining <= 0) {
    local 'bytesRead' ('[file:readInto]' data filename)
    '_wavPlayBuffer' data bytesRead increment is16Bit
    bytesRemaining = (bytesRemaining - bytesRead)
  }
  '[file:close]' filename
}

module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  space
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  space
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  space
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

   ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿCGÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ    ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿé ¬@î               ÿ?   ÿÿÿÿ ÿ?                À   à Pÿ¬   &_bss_start <= &_bss_end    /home/runner/work/esp32-arduino-lib-builder/esp32-arduino-lib-builder/esp-idf/components/bootloader_support/src/bootloader_init.c   &_data_start <= &_data_end  sp < &_bss_start    sp < &_data_start   abort() was called at PC 0x%08x
   bootloader_init buffer != NULL  /home/runner/work/esp32-arduino-lib-builder/esp32-arduino-lib-builder/esp-idf/components/bootloader_support/src/bootloader_random.c bootloader_fill_random  Calculated hash Expected hash   handle != NULL  /home/runner/work/esp32-arduino-lib-builder/esp32-arduino-lib-builder/esp-idf/components/bootloader_support/src/bootloader_sha.c    data_len % 4 == 0   pad_bytes % 4 == 0  words_hashed % BLOCK_WORDS == 60/4  words_hashed % BLOCK_WORDS == 0                                                                bootloader_sha256_finish    bootloader_sha256_data  slowclk_cycles < 32767  /home/runner/work/esp32-arduino-lib-builder/esp32-arduino-lib-builder/esp-idf/components/soc/esp32/rtc_time.c   rtc_clk_cal_internal     @À"   0ô?ÿÿÿ   lâú? õ?`ô?ÿÿÿ   ÿóÿÿdô?    hô?Tô?Xô?\ô?X @ @Ü @¬ô?ÿÿü   ô?       ÿ  ÿ  ìÏ@4 @0ô?0ô? ô? ô?      ÿÿ ÿ?  r?¸ @ @à @ @ ÿ?  2 ÿÿ    @?¤ @Pÿ?äÿ?`ÿ?DQ`ÿ  Ì ð?   ¨ô?ÿÿÿ?       ,ô?À ð?,`ö?­­­­0`ö?4`ö?8`ö?ô?    ô?   ô?   `ö?ÿÿ`ö?ÿÿ ÿ  
 ÿÿÿý°ðô??ðÿÿ   ¨ðô?ðô?ÿÿÿ÷ÿÿÿïÛÿÿûÿÿóÿ   Ä ð?ÿÿÿß  ñ?D ð?\ ð?  ÀÀÿÿ?   ó¿ÿÿ2    ÿ  ÈÂ @X @LÄ @ ÿ?|À@ÿ?xÿ?,ÿ?°ÿ?0ð? 0ð?0ð?0ð?\ÿ?Äÿ?ÿ?Øÿ?üÿ?0ð? ð   õ?   |`ö?   ÿÿÿ   ÿ?üÿ?ÿ?`Â @ÿÿÿ  ô¿  À   °Ô @üÿÿ? @½¢@   pâú?ªP  ëëÿÿ|Ú@Ú@Û@ ô?  ô?°!@ø ô?ø0ô?, ô? ô?    ýpâú?   @ ô?  @       p  ô?   |$ ô?ë  p   P»  pk  p;  p  p   \  p¤ô?_Å'¯¡:ØP ô?ô?  è      ô?ô?ô?ô?ÿÿÿÿÿÿñÿÿ?þÿÿÇÿÿÿÿÿÇÿÿÿ?þÿ6A H&(Æ 9  ¡AÿÀ  
@ÿ?ÿ À  
F  y4ö8¬øF ò'k!7ÿ(B B1ÿÀ  ¨"¯  *+  À  2F  !-ÿB B'ÿÀ  ¨"¯  *  À  "  ÿÀ  ¨"¯  *  À  "F  "ÿÀ  $f(1ÿÀ  ¨	ÿªÿ À  	À  ¨	ÿ`"" À  )	_ fH3ÿÀ  ¨	ÿªÿ À  	À  ¨	ÿ`"" À  )	FR   fX1ÿþÀ  ¨	þþªýþ À  	À  ¨	úþ`"" À  )	D üþà VÒ  ÐÍ ² ºøþà Ízõþà zóþà Í+îþà +ìþà ÍKªèþà Kªæþà Í;áþà ;ßþà ±ÖþÀ  ¨ÑþªÓþª À  ©±ÒþÀ  ¨ªª À  ©±ÎþÀ  ¨ªª À  ©±ÊþÀ  ¨ªª À  ©±ÆþÀ  ¨ª À  ¹þÀ  ¨	¡¸þ  À  	À  ¨	µþ`"" À  )	eC ð   6A fE·þÀ  ¨¶þÀ  À  ¨³þ À  ±þÀ  ¨|ÉÀ  À  ¨) À  ð¦þÀ  ¨þÀ  À  ¨¤þ À   þÀ  ¨|9À  À  ¨ À  ð  6A f&þÀ  ¨	þÀ  	þÀ  ¨	|ÈÀ  	ðþÀ  ¨	uþÀ  	þÀ  ¨	|8À  	ð6A þÀ  Ì2,	F  	 |þÀ  	ð   6A !zþ b@  ð  6A  ¨uuþª uþ!" " ( ð  6A ½Í0£ VG3Æ! Pô@ÕP ` @ 3¡ 
@   @ ´¡0ª  @ Â¡° õ â°@ô ªÂ À0õ T W¸º·8W8ª ¢ÊþºPÀ 8â ÂÀÀô #D Ì G¼ÊËG¼·¼   Èþ ª* 
Fx   Ì4@»Âû@ÌÙ°3À° õ°Ðô#  ,DÀ @ »¡ @0à°õ @ @ @ 3¡04 °ÐôNâîÂ Tà­0@õPD  @ Â¡§´ºD·4§4î   âÎþºD DÀTâDÂ 0Pô@=U 7µºU·575D   BÄþºU ®05À@ª - â 3Â À@õÐS W¸º·8W83   2ÃþºPÀ Hâ Â DÀÀôÐØ@Ì ×¼ÊË·<×<F    Èþ #" Æ6 W³F4  õ@Ü2 5 : ·¼ #   tÆ-  ,	 À 	@@ @ U¡PX  	@0°PÐõ 	@  @ 3¡09 PÀôÐâÐ»Â 0õ°ì  @ D¡ç¸Zç¸W¸» ²ËþZàÀÐâÐÂ 00ôÌ3 Ç³Z3W3Ç3F  ÈþZ3 » @X¢À3À@HW3 @ "¡G²W-
 (
Æ  
-
=
ð   6A L½¢¯ÿÌýà -
ð6A &8r ¢ åýÿ§ð ðð6A %> f(! ª  `ª ¡ª ª %Lª¸ýà ð 6A ¶ýÀ  	<À À  	Ñ²ýÀ  ²¯°
  À  À  |	À  ªýÀ  ØÀÍ À  É§ýÀ  È°¼ « À  ©À  ¨À  ð  6A  Ì8F  |ó ¥± "'º|ó-ð  6A &B&" ð  !ýð|òð!ýð  6a 9F    e 1ý06ý?
ýà 
ýà LÝÁý­ýà Ê
ýà |òð  zý9
}ýà 06Àawýj3h`w 89U@2A}75ð6A ¢  oýà ¢  nýà @Ä ½­å/-

kýà ­eóÿ-
ð  6A AgýB V4Afý74aA\ý@B ô3bý300õ
Zýà 
Yýà ýLÝÁ\ý­Uýà ª
Týà ð
Qýà 1PýC @"À1Pý:"ððð6A Iý x¢  Býà 
Aýà 
Fýà 	@ýH |ù8ýð  6A PPt ìx@ìh0ìXµÍ½­%èÿ-
ð@Ä 0³  ¢ åîÿ-
ð|òð|òð|òð6A <"ð 6A V¢Ñ-ýÁ-ý,{¡-ýåê[ ÐV(*ýÀ  ( Àê'ýÀ  0êÀÀ¡$ýºèÚÒ°1®ª ÀÐ @M »F  Ý7;«ð  6A ýÀ  ¨	ý À  	ýÀ  ¨ýªý À  À  ¨ý À  ýÀ  
  À  ±ýÀ    À  À  ¸®ÿÀ  À  ¸­ÿÀ  ý ýÀ  	 ýÀ  	ÿüÀ  	þüÀ  	ýüÀ  ¸	üü À  	úüÀ  ¸	ùü À  	÷üÀ  ¸	öü À  	ôüÀ  ¸I À  À  ¸ðü»¢  À  ÁìüÀ  ¸¯ ° À  À  ØæüÝæü À  À  ÈlyÀ  À  È,	Ì À  ÉÀ  ØÁÛüÀÍÀ  ÉáÙüÀ  ØÁØüÀÝÂ¥ ÀÍ À  ÉÀ  ØÁÔüÀÍ À  ÉÒüÀ  Ø|ìÀÍÀ  ÉÀ  ÈÌ À  ÉÀ  È ¬ À  ©À  ¨°º À  ¹ÅüÀ  ¨ À  ð   6A ¡©üÀ  
lùÀ  
¹üÀ  ¸|ê «À  ©À  ¸¢¯ß »À  ¹À  È|{°¼À  ¹À  ¸»À  ¹«üÀ  ¸ «À  ©¡üÀ  ¸
¦üÀ  
¡üÀ  ¸
¢üÀ  
¡üÀ  
À  
¡üÀ  ¸
üÀ  
¡üÀ  ¸
üÀ  
±üÀ  ¨üªü À  üÀ  ¸
 « À  ©À  ¨À  güÀ  ¨üÀ  À  ¨büÀ  ð6A "è 0³ ­å¸ Ìzð ðð6a y
Düà 
Cüà F   rü ¡ À  w ÿw¨é6üs00ô:4A<üJ300õ"ýLÝÍ­3üà ýLÝÍ.üà 1(ü0&`0ôh:6J300õ#üUýLÝÍ­$üà ýLÝÍ¢ üà AOüÀ  8lb 3À  91LüÀ  B#  $À  "c 
üà (Áà   6a ýíÝÍ½­  + °89>üA=ü4È$  ¨9+ °ÈI½9üA8ü4È$  Ø9+ °øI0ã 27(·(")%ìÿ6A %Øÿ­%ùÿ 6a ±,ü¡ ü%£ÿ=
jÍ¥¢ V
Æ   °I&JÆ Y&ÉÆ  ("2  (BR |°¹f»,4+ °¸(¹)9"&b&F   V ((ª*­%¢ÿððð6Á ¢" ê	²"1ü·3% eÿ=
:	,Í½
¡ ýûà Í²ÓZ¡úûà ­¥ÿ8f8&2"&Ìs("2|òð¡ åwÿZ¢Á ewÿÊ8H0DsD
 ¡ åuÿ B! DF ¢Á åtÿª B!BÄÿF  ""& $âð|òð"¯ð"¯ðð|òð  6A ¢  Öûà Ôûà ¢£èûà ¥ûûÀ  ÿÿ 6a|äG8±¢Â¥ÏÿJ ¡%åÿ ¥ûÿ@´ ­% ©¹È±­eÍÿ:¡åâÿDF  Mæ×CF  @´ ­% ©¹8Ã±­eÊÿ:¡%àÿBÄ2"&74Ø²Á¢ÂåÈÿJ ¡eÞÿÂ¡ ¡«ûà %ôÿ6a f
8"(29) |è
8B(R9) ø78"&³+3 3°#(3)F ))(8ð6A ûà !ûð  6A VÒ ÑûÁû\;¡ûev@ Ò ÑûÁû\K¡û%u@rAF   !ûh``4`UÀPWc!ûÀ  (VBÿ  Aû@H 0 ¢( å-ÿ¢d "W2åÀ  Axû(*%)ZfPwÀ05 f¶f²!zûÀ  I    !wûÀ  IVùð   6a VÑjûÁqû² ¡jû åkãAcûH@4à<|ÌÀÖ\ Â wÌÀ[ÌÀÑfûÁdû² ¡]û ¥h±bû­¥ðÿTû4ùÑ^ûÁZû² ¡Sûef°¤%"ÿ¢a L½­¥íÿ!Iû(  4ÒÑTûÁPû² ¡Hû¥c!IûÀ  (&ô!NûÀ  I!CûÀ  (&ô àC?û¨¥ÿ©"¶éÀ  ð6A 

 0 §R§TÆ  Ê 9F  K @±4;ºº²È0K    ºº²ÈWK F  	¦)¾ªÍ
G:óð"¡ð"¡ð  6A !µúÀ  (#û!"ûÀ  (!û!!ûÀ  ¨ ¯àªuð t &8	&x
&ð"ð2ðð   6A øú ¡÷úº  tñú" ¡ðú'º   t ) ð6A #V¹!û2"# ­¥ûÿJ@B0@@ôÜ$ð!þúð!üúðð  !úúð   6a $7bÈR¯ðPV¢$ eÀÍ½ ¨eYÿ 0Èu0õ0¸A0°009000t	Í	 Ë0À=	;À3 Í½­eÎÿ"RÅ Rd7ð !Üúð   6A ­ " é'Æ   !Õú %7ÿ!Òúð6a @´ 0£ åEÿ : ÌªÆ ² ¡ÍúeTÿËú( ØþÉú(Hþ)Æ ; ³!à¨ª³ØÐ0uª©h½ú »úÐ0
ÀÌÈÀÄÀ¤ Ìc­åÂÿK"ÍG2²­¥Eÿð|òð6á   A@Â   ² ­eØÿð  6 ,Í­úà ½ ¢ åÈÿ±£ú­¥üÿ¨"#7*ª½¢Êà%9ÿ=
Í½úà -

±ú­%úÿ­å>ÿ!úð­%>ÿð   6A 
úà =
­%Þÿìªú'¸-fS(1ú:2oú7¸1ú:27¸1ú:"='¸  
   -
ð6a "a p' ½­e;ÿV*w½­¥³ÿ$ ax !3ÝÍ½¨¥ÙÿVê	X!P@Tª	-
ð¶¨%öÿÆ  F  ¼5h!FamúG&mbÖG&oF   jú'``t eúG)  Uå6ÿ¢a h!F 0ôB   I! @HÀ D`DcøÁíÝÍ½­eÞÿìZJ3@fÀæÎð-
ð-
ð  !Dúð!Búð  !Aúð-
ð   6¡ RÂþb PPtYRPPt ïA@0gf ws hq>úg·Fb Â¡ ­úà ¨©Kdi`¶ å&ÿm
VÚbåÿ}
z¸eÿÆ   r  Ra
PÅ ¸¨eÐÿm
VêRW¸ÆP XRÅYÆ ÂÅ@Ì°bÁiýèØ¡ËÌ¸­eäÿm
VÅ$@ 8+@°HU%ÁXW¸Æ; PXÀRd7%ÉþÌÊÍ¸A­eÁÿm
VjR$72#W³2 R$ 1ù7·eÆþÜj½­%Óÿm
Æ  ²  p§ eÿ2¢$ 2$7:ª,¢Êà¥ÿ=
ú,½
¢ àª¤Îùà ­¥ÿVÖ&"Kð"Å@"°"" ¢ eÓÿ¼
F   b 8bqÚùx qØùx0709"+5@3°8C02A72ÖUF  "'%¯ðb¡F   |ö  r  ÌaÅù ²  p§ %ÿÂ¡ ­«ùà -ð  "¡ð"¡ð  6A Í½*eÞÿ-
ð6!1Äùx
©=
 °cjR ¿ùhg7kX%ZVW·X    ºùô:ü*¡ ¸ùà Í½­¶ùà ½¢ÁX´ùà ²ÁXÊ¥¢ùà Ì:Æ "¡ð(f! 3À9ð 3\õ7µ"¡ð"¡ð  "¡ð"¡ð   6a ù¼F 	ùÀ  h PùùÀ  ùÀ  VHÿùÀ  RèÊ [­ùà èð()ð   6a ­ùÀ  ( $VÿùÀ  ( $Vÿ± e÷ÿ -
ð  6A 0"¹3  ¢ ¥ûÿÆ.   <øW¨T¡ÿxùÀ  vùÀ  	uùoùÀ  mùÀ  VHÿÆ   pùàÀ  	tKDù¹äRÅÀ2Ã@Æ dùÀ  	¡ÿ`ùÀ  `ùYùÀ  WùÀ  VHÿPÌXPRt  PR!UPPtF UùàÀ  	tKDW8æ¦ÆÏÿðð  6A ¡Kù%îÿ² 50£ Aùà # -
ð   6A ­åëÿ8ùÀ  2h öø6ùÀ  h 3ùÀ  ( V8ÿ ¢ eéÿ"  ð6a !5ù­eèÿ½­¥ùÿV
8"¢  #)¡.ùåæÿ1-ù!$ùÀ  9"ùÀ  VHÿ1'ù­åäÿ'ùÀ  !&ù ) À  )¸­%÷ÿ-
Zð ð  6A ½ÍÝùÀ  ù¨iøÀ  ¨ÍøÀ  À  ¨ù À  ¡ùÀ  
tøù À  
À  
¯ oø;t À  
ùùÀ  Æ|   ×èFS øÀ  è	¡±ø ®À  ©	À  è	¡üø ® À  ©	wø* [øüxÀ  ¨	¬øÀ  	¡îøÀ  
Qøëø À  
íøéøÀ  Æ`   føÀ  ¨	~ø À  	¡ßøÀ  
BøÜø À  
À  
¯ =øt À  
¡ÓøÀ  
Uø » À  
ÆF   GxÏøÊøÀ  F çhÌøÆøÀ     ÉøÂøÀ  @øÀ  ¨	Xø À  	¡¹øÀ  
ø¿ø À  
À  
¯ ø{t À  
F' -øÀ  ¨	^øÀ  	øÜ8À  ¨	^øÀ  	   !øÀ  ¢) 8ø À  i ¡øÀ  * ¯ ý÷t À  
øÀ  ¨	ø À  	¡øÀ  
ï÷ø À  
øøÀ  ¡}øå½ÿ
-
ð6A !øÀ  !ø*)ð   6A øøÀ  ð6A 	~øÀ  ð 6A ~øÀ  ¨		ø À  	zøÀ  ¨	yø À  	ð 6A öBM¥H ³¢ÁtøÑtø £¥[þVÂ !røÀ  ¢b ðf!oøÀ  ©ð f"!løÀ  ©ð !jøÀ  ©ð"¡ð   6A  öB  t öS  t V¨ÜòUøÀ  ![ø )00$@302 À  9ð f LøÀ  !Sø )00$p30" À  )ð f" CøÀ  !Kø )00$ 30" À  )ð ;øÀ  !Dø )00$Ð302 À  9ð"¡ð   6A eèÿ-
Z  eéÿ+øÀ  ¨	¶÷ À  	­%òÿåñÿ*eñÿ:åðÿ!øÀ  ¨«ÿÀ  À  ¨'øÀ  åäÿð  6A  ö"  t ö  t V(ÜòøÀ  !ø )00$P302 À  9ð øÀ  !ø )00$ 302 À  9ð"¡ð    @Ä  Ô @LÄ @0ô?@ð?Dð?Hð?Lð?Pð?Tð?Xð?\ð?`ð?dð?lð?pð?tð?xð?|ð?ð?ð?ð?ð? ô?  ÿÅ³¢Ð @(} @Ì @ÿÿ        pâú?¸ @82@ @ @(#  dðõ?¡:ØPHðõ?ÿ¿ÿÿh @ ÿ?      ÿ? ÿ?8 ÿ?@ÿ?T ÿ? ÿ? ÿ?Ø ÿ?ô ÿ?ÿ?\ ð?    ÿßÿÿD ð?ÈÂ @¤ @Ó
@ÿ?T} @ õ?< ð?0 ÿ?ÿ üÿÿÿçÿÿÿûÿ  ô?    ÿÿÿßÿÿÿ¿   ÿÿÿ   p  ÿÿÿÿÿïÿÿÿ    ÿÿÿÿ÷âú?    ÿ  tô?   `          õ? @         0  8@ô? ³  @B    pô?|ô?ÿ?ÀÿÿÿþÿÿÿDà ` ÿ ÿ¿ýÿ°ô?@B `ö?`ö?        ðÿ³  ðI þ  ÿ?ÿ?¨ÿ?hðõ?ÿÿÿÿïÿÿÿÿ ÿÿÿÿÿÿlðõ?4 @ÿïÿÿÿÿô?ß÷?ç   ÿÿÏÿ ô? ÿ?0ô?¿úûÿ¤A @ÿÿ÷ÿÿÿùÿô??Àÿÿÿÿÿ?ÿÇÿÿ 8  þÿ   `ö?  ´ô?ÞCÿÿÿçP @    ´Ä    ¡ 6A ­%¯ø-
¯
_ÿà ð  6A  ¢ e£øº  ¢ eýÿ-
ð  "¯ð   6 %/ J å¶øÂ  ²  ¡ Oÿà ­åûÿ¯%µø½
­e·ø   6A HÿÀ  ð   6A EÿÀ  ¨¡ À  À  ¨|éÀ  ð 6A V;ÿÀ  :ÿÀ  9ÿÀ  8ÿÀ  7ÿÀ  6ÿÀ  5ÿÀ  4ÿÀ  3ÿÀ  ð2ÿÀ  1ÿÀ  0ÿÀ  /ÿÀ  .ÿÀ  -ÿÀ  ,ÿÀ  +ÿÀ  *ÿÀ  ð  6A *ÿà )ÿà $ÿÀ  #ÿñå+Àª!ÿº¢°°õ
!ÿà ð  6A ¢  ÿà  * ¢ ÿþà ²Â÷=°<Âù Ü&¸ØF  Æ  F  "Ê÷= ;-Êù Ìè&²'Ò'Æ  Æ    ¬ ¢  eéÿ%éÿeæÿð   6A 4&(ö8¨F &8&H F B   F  "
íþà ñèþâ¡ ÑçþÁçþÀ²çþ¨èþà 
çþà 
æþà ð6 %ø¥A !Ýþ©½¡Ùþ%*øV
åÁø­eø-
Vz­å÷% ¥èÿåëÿ
Ûþà åtù¥ù{
åù{eùK
å}ù±Îþ
¥wùåtù¥sùËþÀ  ÊþÀ  ÉþÀ  ¨	ÈþÀ  	e?ùå-ø­%Õÿ­åïÿð|òð|òð  6 L±¿þ­Îþà Æ  ) ¢  éP0   iP   È¶Xä¶þ èP0   hP    a-²þ°þ¹Ñ±þÁ±þ\¡±þå±þ°þ¹Ñ°þÁ«þ\¡«þe
¦þ2Ñ¬þÁ¦þ\+¡¦þ%	¦þ2Ñ¨þÁ¡þ\;¡¡þå¡þÁþ ÌÀnþà 
þà þà 
þà þà 
þà !þÀ  þ À  þà À  þÀ  ¡þÀ  
løÀ  
À  À  ¥ãÿ-

|òð  6A þ à°°²A» ²Ëý¡þþà å·÷ @ ÿÿ6a VþÀ  Uþñ{þÀ  ÷èzþÀ  &(
\  \   ðtþ¢) ©  A oþ¨ a %    Ðkþ¨ªª ©%¥   àfþ¨ªª ©¸%6 ð  6A aþÀ  ¸(`þÀ  (À  ¨x^þÀ  xÀ  ¨x[þÀ  xÀ  ¨xXþ À  xÀ  ¨UþªTþ À  À  ¨Qþ ) À  )
PÀ  Èx@©!Kþ   À  x!Gþ F  !<þÀ  ¨²CþBþ À  ²	@À  ¨rP<þ À  rD5þDF  !*þÀ  ¢1þA0þ@ID À  I¢À  2b !-þ"B¬åAþÀ  Xt1þ05 À  9t"À  X 0t"¯  %0" ]À  ) !þÀ  Hr1þ04À  9rÀ  H2¯ 04À  91
þÀ  H!þ $ MÀ  )þÀ  'øô!þÀ  ¹"À  "" ð6A À¼ ¢ %æÿ  t " u" þª " ð 6A !þÀ  ¨!þ *  þ+°Ð)ýý" " gz# ð" " õýª §àª|¸" " ðñýÀ  yq|è"îýð|Ú "" êýà|º "" ÉýÀ  çèbÐlz "" ßý°¢¯ "" Ûý®"" ðÖýÀ  |è",à|¹"" (" ð6A  À Ü ±»ÐË  £0ªÀº  P°©  p    !¦ý  !³ýÀ  ð  6A ed åe V ­ ¥Y ² 
¢ e8 ³ýº¢Á²ýÑ³ýª¥~÷0» £Å » R';,·²,Ò·²
Æ  ¢ðð,ð6¡ )9!¦ýÀ  ( +f,¥ 1¢ýÀ  !¡ý "# "" À  )ýÀ  	!ý "$ð"" À  )	À  	!ý ( %%@"" À  )	!ýÀ  1ý08 À  9À  1ý08À  9" ü²!ýÀ  ( 0ô õ7"|Ó'³
 Æ   "  %{  * Æ åíÿ-
¼F  1{ýÀ  80ô0õ3|Ø7¸	 F  Ìåêÿ    ¢ýÀ  ýñ­e ¡ký ¢¥ ­å~ 81²Á¨ ¨¥w Ì%«ÿ¢Áe¡ "ÂÿaýÀ  "h Lø!`ýÀ  ê( (0Âê8!Zý #Yý¢ å9 's±Wý°" º¥< ¨ ¢¥Q ¨ £åH ð  6A APý7´ÑOýÁPý,ë¡Oýå¡ A:ýÀ  H@HÂþmh@g3ýÀ  R¡ PY À  Rh f-ýÀ  ( R¢ PY À  Rh =ýÀ  ¨<ýª 0 À  À  X6ýÀ  À  ¨3ýª0ä  À  QýÀ  &"(	]	 [PPt¨ W·!Èþ	W	Áý  ÁýF   Á ýF   ÁýF    Áý¡ý ³¢ £åQ÷=
]
¥\ Ì
,ý ¨Â§5! QýÀ  ýÀ  À  Ùü À  ­ýà     3ýà ÿüÀ  ÷èæçæüÀ  R®ÿPYDPD À  IfMÀ  X"­ÿ %À  )!õüÀ  ( 'Að ðð6A 0³  ¢ ¥äÿ º ÍÐª°½A¥E÷-
ð6A áüÀ  ¨çüÀ  À  ¨äüÀ  À  ¨ØüÀ  À  ¨ÖüÀ  À  ¨¡ü À  h ¢ Òüà   Ïüà ÇüÀ  ÷hìð   6A ÌüÀ  ¨ËüÀ  À  ¨Èü À  À  ¨Åü  À" À  À  (ly00Ð3 À  À  (|@@ðD À  À  (ü À  ð   6A ¯üÀ  ¨	¥@ À  		«üªüÀ  wx¦üÀ  ¨	qü À  i ð  6A üÀ  ¨	 üÀ  	² ¢ füà ,K¢ füà Ò LÀ¼ ¢ füà ¬K¢ füà ÌK¢ füà ð  6A   tâ Â  ² ­%ìÿð  |üÀ  (üÀ  À  (üÀ  ð   6A   t00t!PüÀ  ¯¿À  !uüÀ  tüL À  c1DüÀ  "¯ (À  )   1>üÀ  "  ( À  )<*Uüà ð!7üÀ  8L À  !]üÀ  \ü¥  À  ð 6A !+üÀ  L )ð   6A !$üÀ  "  )ð  6A üÀ  ¨Güª  À  À  ®ÿf"¡ F   !üÀ  ¢¡,*üà ð6A !üÀ  ( .ð6A åþÿ&z&*
    !üð!üð  ð!øûð   6A üûÀ  ¨	ßû  0" ( À  )	¢ üà ð  6A !ñûÀ  ( -ð6a B¡@G% aìûÀ  XAü@UA¼û@E À  I¤GA,GG'F  4b)-,}F )]Bb à·Æ  I]Bb àÇ )]Bb àÇL=Â ² ¢ fóûà Ò K¢ fïûà $   QÆûÀ  hAñû@F À  I:Üûà ¤G?,GG% 4b)-Æ} )]Bb · I]Bb àÇ )]Bb ÇÒ Ã¼K¢ fÎûà Ò tK¢ fÊûà ÕÀ" Ý  D( D pÝ ,K¢ fÂûà Ý<K¢ f¾ûà Ý\K¢ fºûà ¥áÿÌ:\
  ¢  «ûà !±û9ð   6A !ûÀ   ôõ'(|Ù'¹	 F  b!¯û (ðð   6A eüÿ': ÂAÂ@(   Æ
 \   ð*)¢¡à I¢¡@ )¢¡@©#)3ððð   6A 1cûÀ  &"H&(8 1ûÀ  2# 002Ã¥óÿ0Â   15ûÀ  2# 00c&!&#+å(ÿ¥(ÿ­)	 \C¢¡@     #¢¡@F  ð#¢¡à©9"2ð   6A HûÀ  oû"  ô " ( @ûÀ  )ð6A  ,A ô " ( dûÀ  )ð   6A ­bûà ¡\ûÀ  
¬  À  
¡.û ¢Wû²1 ?10À1)ûÀ  ûÀ  1Oû09À  2h ¥øÿæ2ûÀ  8!Bû 3!Îú # À  )ð  ûÀ  8!;û 3!áú # À  )ð 6A \   ð eÿ
HF H  ¢  ÛúÀ  ©	¡üúÀ  ¸
&ûP À  
¡õúÀ  
'û'û À  
¡%ûåíÿ­!ûà ¥ÿð6A ûà ¡èúÀ  
û¸ú À  
ûÀ  ¨	¬ À  	¡ÜúÀ  
ûû À  
¡Óúåçÿð6A %Òÿ1ÒúÀ  2# 0; ² ¥çÿ%ÿf¥ÿ2" VÓ ²"¶+(¨2%æÿð f%ÿå}ÿ%Îÿ²"%µÿ¢"åíÿ  f#%õÿð 6A !îúÀ  ô@!ñú*êú¢Õ!¾ú (ð 6A ÿÿ             «£aôo×JP"Ölñ¨8?Æ¿0ª)É¤Øu\þíªP    P  nvs                 ªP  à      otadata             ªP       app0                ªP     / spiffs              ëëÿÿÿÿÿÿÿÿÿÿÿÿÿÿHgùÚK´ê¯7¹FÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿªP    P  nvs                 ªP  à      otadata             ªP        app0                ªP  !    spiffs              ªP  ?    coredump            ëëÿÿÿÿÿÿÿÿÿÿÿÿÿÿ>ó0mJä6+ëÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ// ABCParser.gp - Convert a string in ABC notation to a list of notes.
//
// To do:
//	- parse and apply key signature (e.g. K:Bmin)
//	- test case: http://abcnotation.com/tunePage?a=trillian.mit.edu/~jc/music/abc/mirror/mandozine.com/La_Partida/0000
//
// Pitch:
//   optional: _^=
//   letter (upper or lower)
//   optional: ,'
//
// Chord:
//   set of pitches inside []
//   (optional chord duration follows the closing square bracket)
//
// Duration:
//   <digits>
//   /
//   <digits>
//   (all parts optional)
//
//  Example: playABC 'ABcde/d/c/B/A2'
//  Example: playABC 'C,,C,Ccc''c'''''
//  Example: playABC '[ceg][Acf][Bdg][ceg]2'

defineClass ABCParser noteNames keysigAdjustment input next notes

to playABC s instr beatsPerMinute transposition {
  if (isNil instr) { instr = 'piano' }
  if (isNil beatsPerMinute) { beatsPerMinute = 120 }
  if (isClass instr 'String') {
	instrument = (newSampledInstrument instr)
  } (isClass instr 'Array') {
	instrument = (sampledInstrumentFromSamples instr)
  } else {
	return nil
  }
  scorePlayer = (newScorePlayer instrument beatsPerMinute)
  voice = (parse (new 'ABCParser') s)
  if (notNil transposition) { transpose (new 'ABCParser') voice transposition }
  addVoice scorePlayer voice
  playScore scorePlayer
  return scorePlayer
}

method parse ABCParser s {
  noteNames = (letters 'C D EF G A Bc d ef g a b')
  keysigAdjustment = (newArray 12 0)
  input = (withoutWhitespace this s)
  next = 1
  notes = (list)
  while (next <= (count input)) {
	readNextEvent this
  }
  convertBeatsToMSecs this
  return notes
}

method convertBeatsToMSecs ABCParser {
  // Convert durations from beats to milliseconds and set note start starting times.
  msecsPerBeat = 600
  t = 0
  for n notes {
	msecs = (truncate ((duration n) * msecsPerBeat))
	setDuration n msecs
	if (isAnyClass (key n) 'Array' 'List') {
	  for pair (key n) {
		atPut pair 2 (truncate ((last pair) * msecsPerBeat))
	  }
	}
	setStartTime n t
	t += msecs
  }
}

method transpose ABCParser noteList transposition {
  for n noteList {
	noteOrChord = (key n)
	if (isAnyClass noteOrChord 'List' 'Array') {
	  for pair noteOrChord {
		k = (first pair)
		if (k > 0) {
		  atPut pair 1 (clamp (k + transposition) 1 127)
		}
	  }
	} else {
	  setKey n (clamp (noteOrChord + transposition) 1 127)
	}
  }
}

method withoutWhitespace ABCParser s {
  letters = (list)
  for line (lines s) {
	lineLetters = (letters line)
	if (and ((count lineLetters) > 1) (':' == (at lineLetters 2))) {
	  if ('K' == (at lineLetters 1)) {
		keysig = (list)
		for ch (letters (substring line 3)) {
		  if (ch > ' ') { add keysig ch }
		}
		setKeysignature this (toLowerCase (joinStrings keysig))
	  }
	} else {
	  i = (indexOf lineLetters '%')
	  if (notNil i) { lineLetters = (copyFromTo lineLetters 1 (i - 1)) }
	  addAll letters lineLetters
	}
  }
  result = (list)
  for ch letters {
	// remove whitespace and ABC barlines, repeat signs, ties, and slurs
	if (and (ch > ' ') (not (isOneOf ch '|' ':' '-' '(' ')' '\' '>'))) { add result ch }
  }
  return (toArray result)
}

method setKeysignature ABCParser keysig {
  scale = (array 'c' 'd' 'e' 'f' 'g' 'a' 'b')
  scaleDegree = (indexOf scale (at keysig 1)) // 1-8
  if (and ((count keysig) > 1) ('b' == (at keysig 2))) {
	useFlats = true
  } else {
	useFlats = false
  }
  isMinor = (or (endsWith keysig 'min') (endsWith keysig 'm'))
  if isMinor {
	scaleDegree += 2 // use the key signature of relative major
	if (scaleDegree > 7) { scaleDegree += -7 }
	useFlats = ('#' != (at keysig 2))
  }
  if useFlats {
	keysigTable = (array
	  (array -1  0 -1  0 -1 -1  0 -1  0 -1  0 -1)  // Cb
	  (array  0  0 -1  0 -1  0  0 -1  0 -1  0 -1)  // Db
	  (array  0  0  0  0 -1  0  0  0  0 -1  0 -1)  // Eb
	  (array  0  0  0  0  0  0  0  0  0  0  0 -1)  // F
	  (array -1  0 -1  0 -1  0  0 -1  0 -1  0 -1)  // Gb
	  (array  0  0 -1  0 -1  0  0  0  0 -1  0 -1)  // Ab
	  (array  0  0  0  0 -1  0  0  0  0  0  0 -1)) // Bb
  } else {
	keysigTable = (array
	  (array  0  0  0  0  0  0  0  0  0  0  0  0)  // C
	  (array  1  0  0  0  0  1  0  0  0  0  0  0)  // D
	  (array  1  0  1  0  0  1  0  1  0  0  0  0)  // E
	  (array  1  0  1  0  1  1  0  1  0  1  0  0)  // F#
	  (array  0  0  0  0  0  1  0  0  0  0  0  0)  // G
	  (array  1  0  0  0  0  1  0  1  0  0  0  0)  // A
	  (array  1  0  1  0  0  1  0  1  0  1  0  0)) // B
  }
  keysigAdjustment = (at keysigTable scaleDegree)
}

method readNextEvent ABCParser {
  while ('"' == (peek this)) { // skip comment/chord
	next += 1
	while (and (not (atEnd this)) ('"' != (peek this))) { next += 1 }
	next += 1
  }
  if ('[' == (peek this)) {
	chord = (readChord this)
	ch = (peek this)
	if (or (isDigit ch) ('/' == ch)) {
	  chordDur = (readDuration this)
	  for pitchAndDur chord { // multiply all note durations by chordDur
		atPut pitchAndDur 2 (chordDur * (last pitchAndDur))
	  }
	}
	if ((count chord) > 0) {
	  chordDur = (last (first chord))
	  for pitchAndDur chord {
		chordDur = (min chordDur (last pitchAndDur))
	  }
	  add notes (newScoreNote 0 chord 127 chordDur)
	}
  } else {
	p = (readPitch this)
	dur = (readDuration this)
	add notes (newScoreNote 0 p 127 dur)
  }
}

method readChord ABCParser {
  chord = (list)
  next += 1 // initial '['
  while (not (isOneOf (peek this) ']' '')) {
	p = (readPitch this)
	dur = (readDuration this)
	add chord (array p dur)
  }
  next += 1 // final ']'
  return chord
}

method readPitch ABCParser {
  // Return the midi key number (middle C = 60) for this note.
  // Return zero for a rest (z or Z).
  pitch = 0
  ch = (nextLetter this)
  if (isOneOf ch 'Z' 'z') { return 0 } // rest
  hasNatural = false
  while (isOneOf ch '^' '_' '=') {
	if ('^' == ch) { pitch += 1 }
	if ('_' == ch) { pitch += -1 }
	if ('=' == ch) { pitch = 0; hasNatural = true }
	ch = (nextLetter this)
  }
  if (isNoteName this ch) {
	k = (indexOf noteNames ch)
	if (not hasNatural) {
	  k = (adjustForKeySigniture this k)
	}
	pitch += (59 + k)
  } else {
	findNextNote this // recovery: skip bad note
	return 0 // rest
  }
  ch = (peek this)
  while (isOneOf ch ',' '''') {
	if (',' == ch) { pitch += -12 }
	if ('''' == ch) { pitch += 12 }
	next += 1
	ch = (peek this)
  }
  return pitch
}

method adjustForKeySigniture ABCParser k {
  i = (((k - 1) % 12) + 1)
  return (k + (at keysigAdjustment i))
}

method readDuration ABCParser {
  dur = (max 1 (readInteger this))
  if ('/' == (peek this)) {
	next += 1
	if (isDigit (peek this)) {
	  dur = (dur / (readInteger this))
	} else {
	  dur = (dur / 2)
	}
  }
  return dur
}

method readInteger ABCParser {
  digits = ''
  while (isDigit (peek this)) {
	digits = (join digits (nextLetter this))
  }
  return (toInteger digits)
}

method findNextNote ABCParser {
  // Skip to the start of the next note (or end) to recover from an error.
  while true {
	ch = (peek this)
	if (or
		(atEnd this)
		(isOneOf ch '_' '^' '=' 'z' 'Z')
		(isNoteName this ch)) {
			return
	}
	next += 1
  }
}

method isNoteName ABCParser ch {
  return (or
	(and ('a' <= ch) (ch <= 'g'))
	(and ('A' <= ch) (ch <= 'G')))
}

//*** stream helper methods ***

method atEnd ABCParser { return (next > (count input)) }

method peek ABCParser {
  if (next > (count input)) { return '' }
  return (at input next)
}

method nextLetter ABCParser {
  if (atEnd this) { return '' }
  next += 1
  return (at input (next - 1))
}
defineClass Action function arguments

method function Action { return function }
method arguments Action { return arguments }

classComment Action '
An Action combines a function with zero or more arguments.
The Action can be invoked, possibly with some additonal
arguments, using "call" or "callWith" method, as if it
were a normal function or function name.'

to action func args... {
  // Create an Action that combines the given function and arguments.
  // The function can be either the name of a function or (less commonly)
  // an actual function object, or even another Action object.

  argList = (list)
  for i (argCount) {
    if (i > 1) { add argList (arg i) }
  }
  return (new 'Action' func (toArray argList))
}

method call Action args... {
  // Return the result of calling the Action's function on its
  // arguments and zero or more additional arguments.

  if ((argCount) == 1) {
    return (callWith function arguments)
  }
  allArgs = (toList arguments)
  for i (argCount) {
    if (i > 1) { add allArgs (arg i) }
  }
  return (callWith function (toArray allArgs))
}

method callWith Action argsArray {
  allArgs = (join arguments argsArray)
  return (callWith function allArgs)
}
defineClass Alignment morph rule padding itemAreaSelector sortingOrder vPadding framePaddingX framePaddingY

to newAlignment rule padding itemAreaSelector sortFunction {
  align = (new 'Alignment')
  initialize align nil rule padding itemAreaSelector sortFunction
  return align
}

// info

method fieldInfo Alignment fieldName {
  if ('rule' == fieldName) {
    info = (dictionary)
    atPut info 'type' 'options'
    atPut info 'options' (array 'none' 'column' 'line' 'centered-line' 'multi-column' 'multi-line')
    return info
  }
  return nil
}

method initialize Alignment aMorph aRule aPadding aSelector aFunction {
  if (isNil aRule) {aRule = 'multi-column'}
  if (isNil aPadding) {
    scale = (global 'scale')
    aPadding = (scale * 5)
  }
  if (isNil aSelector) {aSelector = 'fullBounds'}
  morph = aMorph
  rule = aRule
  padding = aPadding
  vPadding = padding
  framePaddingX = padding
  framePaddingY = padding
  itemAreaSelector = aSelector
  sortingOrder = aFunction
}

method rule Alignment {return rule}
method padding Alignment {return padding}
method setPadding Alignment num {padding = num}
method vPadding Alignment {return vPadding}
method setVPadding Alignment num {vPadding = num}
method setItemAreaSelector Alignment aString {itemAreaSelector = aString}
method setSortingOrder Alignment aFunctionOrNil {sortingOrder = aFunctionOrNil}
method framePaddingX Alignment {return framePaddingX}
method framePaddingY Alignment {return framePaddingY}

method setFramePadding Alignment x y {
  framePaddingX = x
  if (notNil y) {framePaddingY = y}
}

method setRule Alignment aString {
  // 'none'
  // 'column'
  // 'line'
  // 'centered-line'
  // 'multi-column'
  // 'multi-line'
  rule = aString
}

method items Alignment {
  items = (list)
  for each (parts morph) {
    if (isVisible each) {
      add items each
    }
  }
  if (isNil sortingOrder) {
    return items
  }
  return (sorted (toArray items) sortingOrder)
}

// layout

method fixLayout Alignment {
  if (rule == 'none') {
    // client did their own layout so just recompute size
    ia = (itemsArea this)
    if (notNil ia) {
      setWidth (bounds morph) ((width ia) + (framePaddingX * 2))
      setHeight (bounds morph) ((height ia) + (framePaddingY * 2))
    }
  } (rule == 'column') {
    arrangeSingleColumn this
  } (rule == 'line') {
    arrangeSingleLine this
  } ( rule == 'centered-line') {
    arrangeCenteredLine this
  } (rule == 'multi-column') {
    arrangeMultiColumn this
  } (rule == 'multi-line') {
    arrangeMultiLine this
  } else {
    error 'unsupported layout rule' rule
  }
  if (notNil (owner morph)) {
    parent = (handler (owner morph))
    if (isClass parent 'ScrollFrame') {
      setPosition morph (left (morph parent)) (top (morph parent))
      updateSliders parent
    }
  }
}

method arrangeMultiColumn Alignment {
  maxBottom = (bottom morph)
  if (and (notNil (owner morph)) (isClass (handler (owner morph)) 'ScrollFrame')) {
    maxBottom = ((bottom (clientArea (handler (owner morph)))) - framePaddingY)
  }
  x = ((left morph) + framePaddingX)
  y = ((top morph) + framePaddingY)
  w = 0
  for item (items this) {
    area = (call itemAreaSelector item)
    newBottom = (+ y (height area))
    if (newBottom > maxBottom) {
      x += (w + padding)
      w = 0
      y = ((top morph) + framePaddingY)
    }
    setPosition item x y
    y += ((height area) + vPadding)
    w = (max w (width area))
  }
  ia = (itemsArea this)
  if (notNil ia) {
    setWidth (bounds morph) ((width ia) + (framePaddingX * 2))
    setHeight (bounds morph) ((height ia) + (framePaddingY * 2))
  }
}

method arrangeMultiLine Alignment {
  maxRight = (right morph)
  if (and (notNil (owner morph)) (isClass (handler (owner morph)) 'ScrollFrame')) {
    maxRight = (right (clientArea (handler (owner morph))))
  }
  x = ((left morph) + framePaddingX)
  y = ((top morph) + framePaddingY)
  h = 0
  for item (items this) {
    area = (call itemAreaSelector item)
    newRight = (+ x (width area))
    if (newRight > maxRight) {
      y += (h + vPadding)
      h = 0
      x = ((left morph) + framePaddingX)
    }
    setPosition item x y
    x += ((width area) + padding)
    h = (max h (height area))
  }
  ia = (itemsArea this)
  if (notNil ia) {
    setWidth (bounds morph) ((width ia) + (framePaddingX * 2))
    setHeight (bounds morph) ((height ia) + (framePaddingY * 2))
  }
}

method arrangeSingleColumn Alignment {
  x = ((left morph) + framePaddingX)
  y = ((top morph) + framePaddingY)
  w = 0
  for item (items this) {
    setPosition item x y
    area = (call itemAreaSelector item)
    y = ((bottom area) + vPadding)
    w = (max w (width area))
  }
  setWidth (bounds morph) (w + (framePaddingX * 2))
  setHeight (bounds morph) (((y - vPadding) - (top morph)) + framePaddingY)
}

method arrangeSingleLine Alignment {
  x = ((left morph) + framePaddingX)
  y = ((top morph) + framePaddingY)
  h = 0
  for item (items this) {
    setPosition item x y
    area = (call itemAreaSelector item)
    x = ((right area) + padding)
    h = (max h (height area))
  }
  setHeight (bounds morph) (h + (framePaddingY * 2))
  setWidth (bounds morph) (((x - padding) - (left morph)) + framePaddingX)
}

method arrangeCenteredLine Alignment {
  // additionally vertically center the elements
  h = 0
  for each (items this) {
    h = (max h (height each))
  }
  setHeight (bounds morph) (h + (framePaddingY * 2))
  x = ((left morph) + framePaddingX)
  y = ((top morph) + framePaddingY)
  for each (items this) {
    setPosition each x (y + ((h - (height each)) / 2))
    area = (call itemAreaSelector each)
    x = ((right area) + padding)
  }
  setWidth (bounds morph) (((x - padding) - (left morph)) + framePaddingX)
}

method adjustSizeToScrollFrame Alignment aScrollFrame {
  if (rule == 'multi-column') {arrangeMultiColumn this}
  if (rule == 'multi-line') {arrangeMultiLine this}
  if (or (isNil aScrollFrame) (isEmpty (parts morph))) {return}
  ca = (clientArea aScrollFrame)
  ia = (expandBy (itemsArea this) padding)
  setWidth (bounds morph) (max (width ia) (width ca))
  setHeight (bounds morph) (max (height ia) (height ca))
}

method itemsArea Alignment {
  // answer the items' bounding box w/o padding
  box = nil
  for item (parts morph) {
    area = (call itemAreaSelector item)
    if (isNil box) {box = (copy area)}
    merge box area
  }
  return box
}
// Animation.gp - An animation acts like a Schedule object.

// Example: Animate morph m from left = 0 to 1000 over half a second:
//   addSchedule (global 'page') (newAnimation 0 1000 500 (action 'setLeft' m))

defineClass Animation startValue endValue duration setter doneAction isDone useFloats startMSecs

to newAnimation startValue endValue duration setter doneAction useFloats {
  if (isNil setter) { setter = 'print' }
  if (isNil useFloats) { useFloats = false }
  result = (new 'Animation')
  setField result 'startValue' startValue
  setField result 'endValue' endValue
  setField result 'duration' (max duration 1)
  setField result 'setter' setter
  setField result 'doneAction' doneAction
  setField result 'isDone' false
  setField result 'useFloats' useFloats
  return result
}

method isDone Animation { return isDone }
method useFloats Animation { return useFloats }
method setUseFloats Animation flag { useFloats = flag }
method op Animation { return (function setter) }

method step Animation {
  if (isNil startMSecs) {
	startMSecs = (toFloat (msecsSinceStart))
  }
  if isDone { return }
  t = (((msecsSinceStart) - startMSecs) / duration)
  if (t > 1) {
	call setter endValue
	if (notNil doneAction) { call doneAction }
	isDone = true
  } else {
	// Cubic, slow-out animation (i.e. start fast and decellerate)
	frac = (1.0 - t) // remaining time fraction; goes from 0 to 1
	delta = (endValue - startValue)
	currentValue = (startValue + (delta * (1.0 - (* frac frac frac))))
	if (not useFloats) { currentValue = (toInteger currentValue) }
	call setter currentValue
  }
}
// AppMaker.gp
// John Maloney, April 2016
//
// Turns a GP project into a stand-alone application.
// To do: allow saving apps for platforms other than current one

// exportApp (new 'AppMaker') nil 'MicroBlocks'

defineClass AppMaker appName

method exportApp AppMaker project name {
  if (isNil name) { name = 'MyApp' }
  dir = (directoryPart name)
  if ('' == dir) { dir = (gpFolder) }
  name = (filePart name)
  embeddedFS = (createEmbeddedFS this project)
  if ('Mac' == (platform)) {
	exportMacApp this dir name embeddedFS
  } else {
	extension = nil
	if ('Win' == (platform)) { extension = '.exe' }
	fileName = (uniqueNameNotIn (join (listDirectories dir) (listFiles dir)) name extension)
	writeExeFile this (join dir '/' fileName) embeddedFS
  }
}

method writeExeFile AppMaker fileName embeddedFS {
  // Write an executable file with the given embedded file system (a ZipFile).

  writeFile fileName (executableWithData this (contents embeddedFS))
  setFileMode fileName (+ (7 << 6) (5 << 3) 5)  // set executable bits
}

method createEmbeddedFS AppMaker project {
  // Return a ZipFile object containing the GP library.

  zip = (create (new 'ZipFile'))
  if (notEmpty (listEmbeddedFiles)) {
	// use embedded file system
	for fn (listEmbeddedFiles) {
	  if (beginsWith fn 'lib/') {
		data = (readEmbeddedFile fn)
		addFile zip fn data true
	  }
	  if ('startup.gp' == fn) {
		startup = (readEmbeddedFile fn)
	  }
	}
	for fn (listEmbeddedFiles) {
	  if (beginsWith fn 'modules/') {
		data = (readEmbeddedFile fn)
		addFile zip fn data true
	  }
	}
  } else {
	// use external file system
	prefix = (directoryPart (appPath))
	if (isEmpty (listFiles (join prefix 'lib'))) {
	  prefix = (join prefix 'runtime/')
	  if (isEmpty (listFiles (join prefix 'lib'))) {
		error 'Could not find library folder'
	  }
	}
	for fn (listFiles (join prefix 'lib')) {
	  if (not (isOneOf fn '.DS_Store' '.' '..')) {
	    fullName = (join 'lib/' fn)
		data = (readFile (join prefix fullName))
		addFile zip fullName data true
	  }
	}
	for fn (listFiles  (join prefix 'modules')) {
	  if (not (isOneOf fn '.DS_Store' '.' '..')) {
	    fullName = (join 'modules/' fn)
		data = (readFile (join prefix fullName))
		addFile zip fullName data true
	  }
	}
	startup = (readFile (join (directoryPart (appPath)) '/runtime/startup.gp'))
  }
  if (notNil project) {
	// add startup.gp and project file
	addFile zip 'startup.gp' (startupFile this) true
	if (notNil project) {
	  addFile zip 'project.gpp' (projectData2 project) true
	}
  } else {
	addFile zip 'startup.gp' startup true
  }
  return zip
}

method startupFile AppMaker {
  return '
to startup {
  setGlobal ''vectorTrails'' true
  openPage true
  openProjectFromFile (newStage) ''project.gpp''
  gc
  print (mem)
  startSteppingSafely (global ''page'') true
}
'
}

method executableWithData AppMaker data {
  appData = (readFile (appPath) true)
  appEnd = (findAppEnd this appData)
  byteCount = (+ appEnd 4 (byteCount data))
  result = (newBinaryData byteCount)
  replaceByteRange result 1 appEnd appData
  replaceByteRange result (appEnd + 1) (appEnd + 4) 'GPFS'
  replaceByteRange result (appEnd + 5) byteCount data
  return result
}

method findAppEnd AppMaker appData {
  // Return the index of 'GPFSPK\03\04'
  for i (byteCount appData) {
	if (and
		(71 == (byteAt appData i))
		(80 == (byteAt appData (i + 1)))
		(70 == (byteAt appData (i + 2)))
		(83 == (byteAt appData (i + 3)))
		(80 == (byteAt appData (i + 4)))
		(75 == (byteAt appData (i + 5)))
		( 3 == (byteAt appData (i + 6)))
		( 4 == (byteAt appData (i + 7)))) {
			return i
		}
  }
  return (byteCount appData)
}

// Macintosh App Bundle Support

method exportMacApp AppMaker dir name embeddedFS {
  // Create a Mac application bundle with the given embedded file system (a ZipFile).

  name = (uniqueNameNotIn (join (listDirectories dir) (listFiles dir)) name '.app')
  appName = (join dir '/' name)
  name = (withoutExtension name)
  makeDirectory appName
  makeDirectory (join appName '/Contents')
  makeDirectory (join appName '/Contents/MacOS')
  makeDirectory (join appName '/Contents/Resources')
  writeFile (join appName '/Contents/info.plist') (macInfoFile this name)
  writeShellScript this name (join appName '/Contents/MacOS/start.sh')
  writeExeFile this (join appName '/Contents/MacOS/' name) embeddedFS
}

method macInfoFile AppMaker name {
  return (join '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleName</key>
	<string>' name '</string>
	<key>CFBundleDisplayName</key>
	<string>' name '</string>
	<key>CFBundleExecutable</key>
	<string>start.sh</string>
	<key>CFBundleIconFile</key>
	<string>AppIcons</string>
</dict>
</plist>
')
}

method writeShellScript AppMaker name fileName {
  shellScript = (join '#!/bin/sh
# This shell script starts GP with the appropriate top-level directory.
# Add >>app.log 2>&1 to redirect stdout and stderr to app.log for debugging.

DIR=`dirname "$0"`
cd "$DIR"
cd ../../..
"$DIR"/"' name '"
')
  writeFile fileName shellScript
  setFileMode fileName (7 << 6) // set executable bits
}
// Array

// queries

method contains Array element {
  comment '
	Return true if any element equals the input.'
  for el this {
    if (el == element) { return true }
  }
  return false
}

method first Array { return (at this 1) }
method last Array { return (at this (count this)) }

method indexOf Array obj startIndex {
  // Return the index of the first occurrence of the given object after
  // startIndex, or nil if not found. startIndex is optional.

  if (isNil startIndex) { startIndex = 0 }
  i = (startIndex + 1) // index *after* startIndex
  if (i < 1) { i = 1 }
  end = (count this)
  while (i <= end) {
    if (obj == (at this i)) { return i }
	i += 1
  }
  return nil
}

method lastIndexOf Array obj startIndex {
  // Return the index of the last occurrence of the given object before
  // startIndex, or nil if not found. startIndex is optional.

  if (isNil startIndex) { startIndex = ((count this) + 1) }
  i = (startIndex - 1) // index *before* startIndex
  if (i > (count this)) { i = (count this) }
  while (i > 0) {
    if (obj == (at this i)) { return i }
	i += -1
  }
  return nil
}

// equality

method '==' Array other {
  if (this === other) { return true }
  if (not (isClass other 'Array')) {
    return false
  }
  if ((count this) != (count other)) {
    return false
  }
  for i (count this) {
    if ((at this i) != (at other i)) {
      return false
    }
  }
  return true
}

// comparison

method '<' Array other {
  n = (min (count this) (count other))
  for i n {
    if ((at this i) < (at other i)) {
      return true
    }
  }
  return ((count this) < (count other))
}

method '<=' Array other { return (or (this < other) (this == other)) }
method '>' Array other { return (and (not (this < other)) (not (this == other))) }
method '>=' Array other { return (not (this < other))}

// searching

method find Array target startIndex {
  // Return the starting index of next occurence of the target
  // array or string following the given index. If target is a
  // string it is converted to an array letters. If startIndex
  // is omitted, it defaults to 1. Return 0 if no match found.

  if (isClass target 'String') { target = (letters target) }
  if (isNil startIndex) { startIndex = 1 }
  if ((count target) == 0) { error 'The target array or string must not be empty' }

  targetFirst = (at target 1)
  targetCount = (count target)
  last = (((count this) - targetCount) + 1)
  i = startIndex
  while (i <= last) {
    if ((at this i) == targetFirst) {
	  match = true
	  j = 2
	  while match {
	    if (j > targetCount) { return i } // found a match!
		if ((at target j) != (at this (+ i j -1))) { match = false }
		j += 1
	  }
	}
	i += 1
  }
  return 0
}

// converting/combining

method toList Array {
  return (new 'List' 1 (count this) (copyArray this) )
}

method toArray Array { return this }

method toBinaryData Array {
  // Return a binary data object with the unsigned byte values in this array.
  // Assume all values in this array are integers in the range [0..255].
  result = (newBinaryData (count this))
  for i (count this) {
	byteAtPut result i (at this i)
  }
  return result
}

method toString Array limit visited {
  if (isNil limit) { limit = 100 }
  if (isNil visited) { visited = (dictionary) }
  if (contains visited this) { return '(array ...)' }
  add visited this
  if (limit > (count this)) { limit = (count this) }
  s = '(array'
  for i limit {
    s = (join s ' ' (toString (at this i) nil visited))
  }
  if (limit < (count this)) { s = (join s ' ...') }
  s = (join s ')')
  return s
}

method copy Array {
  return (copyArray this)
}

method copyWith Array newEl {
  result = (copyArray this ((count this) + 1))
  atPut result (count result) newEl
  return result
}

method copyWithout Array omitEl {
  // Return a copy of this array without any instances of omitEl.
  result = (list)
  for el this {
    if (omitEl != el) { add result el }
  }
  return (toArray result)
}

method copyFromTo Array start end {
  if (and (isNil start) (isNil end)) { return (copyArray this) }
  if (isNil start) { start = 1 }
  if (isNil end) { end = (count this) }
  count = ((end - start) + 1)
  if (count <= 0) { return (array) }
  result = (newArray count)
  for i count {
	atPut result i (at this ((start + i) - 1))
  }
  return result
}

method reversed Array {
  comment '
	Return a copy of this array with the elements in the reverse order.'

  result = (copyArray this)
  n = (count this)
  for i n { atPut result (n - (i - 1)) (at this i) }
  return result
}

method join Array args... {
  comment '
	Return an array with the elements of this array and the argument arrays (or lists) concatenated.'

  count = 0
  for i (argCount) { count += (count (arg i)) }
  result = (newArray count)

  dst = 1
  for i (argCount) {
	arg = (toArray (arg i))
	replaceArrayRange result dst (dst + ((count arg) - 1)) arg
	dst += (count arg)
  }
  return result
}

method joinStrings Array delimiter {
  comment '
	Assuming this is an array of strings, return the result of joining those strings.'

	return (joinStringArray this delimiter)
}

// sorting

method sorted Array sortFunction {
  // Return a sorted version of this array. If sortFunction
  // is not provided, use '<' (i.e. ascending order).
  //
  // Mergesort vs. Quicksort:
  // Quicksort is about 8% faster than MergeSort when using the '<' primitive
  // on a randomly shuffled array of integers (a common case) and about 40%
  // faster if the array is already sorted. However:
  //   1. Mergesort is 45% faster when using a custom sort function (it does fewer comparisions)
  //   2. Mergesort is stable, meaning that the order of equal elements is preserved
  //   3. Mergesort is 49% faster on the worst case for Quicksort (identical elements)

  return (mergeSorted this sortFunction)
}

method isSorted Array {
  for i ((count this) - 1) {
	if ((at this i) > (at this (i + 1))) { return false }
  }
  return true
}

method quicksort Array from to sortFunction {
  // Sort my elements in place. Elements must be comparable using "<", "==", and "!=".'

  if (isNil from) { from = 1 }
  if (isNil to) { to = (count this) }
  if (notNil sortFunction) {
	quicksortCustom this from to sortFunction
	return
  }
  if (to <= from) {
    return nil
  } ((from + 1) == to) {
    if ((at this to) < (at this from)) {
      t = (at this to)
      atPut this to (at this from)
      atPut this from t
    }
    return nil
  }
  v = (at this (half (from + to)))
  bottom = from
  top = to
  while (bottom < top) {
    while ((at this bottom) < v) {
      bottom = (bottom + 1)
    }
    while (v < (at this top)) {
      top = (top - 1)
    }
    if (bottom < top) {
      equal = ((at this bottom) == (at this top))
      if (not equal) {
        t = (at this bottom)
        atPut this bottom (at this top)
        atPut this top t
      }
      if (or ((at this bottom) != v) equal) {
        bottom = (bottom + 1)
      }
      if (or ((at this top) != v) equal) {
        top = (top - 1)
      }
    }
  }
  quicksort this from bottom
  quicksort this (bottom + 1) to
}

method quicksortCustom Array from to sortFunction {
  // Sort my elements in place using sortFunction.

  if (to <= from) {
    return nil
  } ((from + 1) == to) {
    if (call sortFunction (at this to) (at this from)) {
      t = (at this to)
      atPut this to (at this from)
      atPut this from t
    }
    return nil
  }
  v = (at this (half (from + to)))
  bottom = from
  top = to
  while (bottom < top) {
    while (call sortFunction (at this bottom) v) {
      bottom = (bottom + 1)
    }
    while (call sortFunction v (at this top)) {
      top = (top - 1)
    }
    if (bottom < top) {
      equal = ((at this bottom) == (at this top))
      if (not equal) {
        t = (at this bottom)
        atPut this bottom (at this top)
        atPut this top t
      }
      if (or ((at this bottom) != v) equal) {
        bottom = (bottom + 1)
      }
      if (or ((at this top) != v) equal) {
        top = (top - 1)
      }
    }
  }
  quicksortCustom this from bottom sortFunction
  quicksortCustom this (bottom + 1) to sortFunction
}

method mergeSorted Array sortFunction {
  // Return a copy of this array sorted using the given sortFunction or
  // with '<' if sortFunction is not provided.

  n = (count this)
  a = (mergeSortedFirstPass this sortFunction)
  b = (copyArray this) // working copy
  runLen = 2 // start with runs of length 2 (already sorted); merge and double runLen at each step
  while (runLen < n) {
	if (isNil sortFunction) {
	  merge a runLen b
	} else {
	  mergeCustom a runLen b sortFunction
	}
	// swap a and b
	tmp = a
	a = b
	b = tmp
    runLen = (2 * runLen)
  }
  return a
}

method mergeSortedFirstPass Array sortFunction {
  // Return a copy of this array with pairs of adjacent elements in sorted
  // order. This is an optimization of the first step of mergeSort.
  // Optimization: Separate loop using '<' if no sortFunction.

  n = (count this)
  result = (newArray n)
  if ((n % 2) == 1) { atPut result n (at this n) } // odd length; copy last element
  i = 1
  if (isNil sortFunction) {
	while (i < n) {
	  a = (at this i)
	  b = (at this (i + 1))
	  if (b < a) {
		atPut result i b
		atPut result (i + 1) a
	  } else {
		atPut result i a
		atPut result (i + 1) b
	  }
	  i += 2
	}
  } else {
	while (i < n) {
	  a = (at this i)
	  b = (at this (i + 1))
	  if (call sortFunction b a) {
		atPut result i b
		atPut result (i + 1) a
	  } else {
		atPut result i a
		atPut result (i + 1) b
	  }
	  i += 2
	}
  }
  return result
}

method merge Array runLen out {
  // Merge runs of length runLen into out.
  n = (count this)
  i = 1
  while (i <= n) {
	// Merge runs [i..i+runLen) and [i+runLen..i+2*runLen) into out
	end = ((i + (2 * runLen)) - 1)
	if (end > n) { end = n }
	left = i
	right = (i + runLen)
	rightStart = right
	j = left
	while (j <= end) {
	  if (left >= rightStart) {
		replaceArrayRange out j end this right
		j = end
	  } (right > end) {
		replaceArrayRange out j end this left
		j = end
	  } else {
		if ((at this right) < (at this left)) {
		  atPut out j (at this right)
		  right += 1
		} else {
		  atPut out j (at this left)
		  left += 1
		}
	  }
	  j += 1
	}
	i += (2 * runLen)
  }
}

method mergeCustom Array runLen out sortFunction {
  // Merge runs of length runLen into out.
  n = (count this)
  i = 1
  while (i <= n) {
	// Merge runs [i..i+runLen) and [i+runLen..i+2*runLen) into out
	end = ((i + (2 * runLen)) - 1)
	if (end > n) { end = n }
	left = i
	right = (i + runLen)
	rightStart = right
	j = left
	while (j <= end) {
	  if (left >= rightStart) {
		replaceArrayRange out j end this right
		j = end
	  } (right > end) {
		replaceArrayRange out j end this left
		j = end
	  } else {
		if (call sortFunction (at this right) (at this left)) {
		  atPut out j (at this right)
		  right += 1
		} else {
		  atPut out j (at this left)
		  left += 1
		}
	  }
	  j += 1
	}
	i += (2 * runLen)
  }
}

// shifting and replacing

method arrayShift Array shift {
  comment '
	Shift the elements of this array in place right by shift positions.
	If shift is negative, shift left by the absolute value of shift.'

  if (or (isNil shift) (shift == 0)) { return this }

  if (shift > 0) {
    replaceArrayRange this (shift + 1) (count this) this 1
	fillArray this nil 1 shift
  } else {
    end = ((count this) + shift)
    replaceArrayRange this 1 end this ((abs shift) + 1)
	fillArray this nil (end + 1) (count this)
  }
  return this
}

// operations for indexable collections

to isEmpty collection { return ((count collection) == 0) }
to notEmpty collection { return ((count collection) > 0) }

to atRandom collection { return (at collection (rand 1 (count collection))) }

to flattened collection result {
  if (isNil result) { result = (list) }
  for elem collection {
    if (or (isClass elem 'Array') (isClass elem 'List')) {
      flattened elem result
    } else {
      add result elem
    }
  }
  return result
}

to shuffled collection {
  // Return a shuffled copy of the given collection.

  if (isClass collection 'Array') {
	result = (copyArray collection)
  } else {
	result = (toArray collection)
  }
  n = (count result)
  for i n {
	j = (rand i n)
	tmp = (at result j)
	atPut result j (at result i)
	atPut result i tmp
  }
  if (isClass collection 'List') {
	result = (toList result)
  }
  return result
}

// set operations for indexable collections

to union c1 c2 {
  // Return a list containing every element that appears in either c1 or c2.

  if (isClass c1 'Dictionary') { c1 = (keys c1) }
  if (isClass c2 'Dictionary') { c2 = (keys c2) }
  seen = (dictionary)
  result = (list)
  for el (join c1 c2) {
	if (not (contains seen el)) {
	  add result el
	  add seen el
	}
  }
  return result
}

to intersection c1 c2 {
  // Return a list containing the elements that appears in both c1 or c2.

  if (isClass c1 'Dictionary') { c1 = (keys c1) }
  if (isClass c2 'Dictionary') { c2 = (keys c2) }
  result = (list)
  d = (dictionary)
  if ((count c1) < (count c2)) {
	addAll d c1
	src = c2
  } else {
	addAll d c2
	src = c1
  }
  for el src {
	if (contains d el) { add result el }
  }
  return result
}

to withoutAll c1 c2 {
  // Return a list containing the elements of c1 without any of the elements in c2.

  if (isClass c2 'Dictionary') {
	d = c2
  } else {
	d = (dictionary)
	addAll d c2
  }
  result = (list)
  for el c1 {
	if (not (contains d el)) { add result el }
  }
  return result
}
// AuthoringCommands.gp - Commands for the authoring level
//
// Note: By convention, commands that use the implicit receiver are prefixed with "self_"

// instantiation

to instantiate handlerClass destMorph initData {
  result = (new handlerClass)
  for i (objWords result) {
	setField result i 0 // initialize all fields to 0 (not nil)
  }
  if (not (hasField result 'morph')) { // helper class
	if (implements result 'initialize') { initialize result initData }
  	return result
  }
  if (isNil destMorph) { destMorph = (morph (global 'page')) }
  setMorph result (newMorph result)
  resultM = (morph result)
  setGrabRule resultM 'handle'
  bm = (imageNamed (projectForMorph nil) 'ship')
  if (isNil bm) {
	bm = (makeShip (new 'Project'))
  } else {
	bm = (copy bm)
  }
  setCostume resultM bm
  setDrawOnOwner resultM false // draw on the page
  setScale resultM (scale destMorph)
  x = (rand (left destMorph) ((right destMorph) - (width resultM)))
  y = (rand (top destMorph) ((bottom destMorph) - (height resultM)))
  setPosition resultM x y
  if (implements result 'initialize') { initialize result initData }
  if (implements result 'redraw') { redraw result }
  addPart destMorph resultM
  return result
}

to implicitReceiver {
  result = (lastReceiver)
  if (isNil result) {
	// block executed outside of a scripter; use a dummy receiver
	result = (newBox (newMorph))
	setExtent (morph result) 1 1
	redraw result
  }
  return result
}

to isInHand aMorph {
  // Return true if the given morph is owned by the Hand.
  owner = (owner aMorph)
  return (and (notNil owner) (isClass (handler owner) 'Hand'))
}

to self_stopAll { stopAll (global 'page') }

to self_show { show (morph (implicitReceiver)) }
to self_hide { hide (morph (implicitReceiver)) }
to self_comeToFront { comeToFront (morph (implicitReceiver)) }
to self_goBackBy n { goBackBy (morph (implicitReceiver)) n }

to self_say s { say (morph (implicitReceiver)) s }
to self_sayNothing { sayNothing (morph (implicitReceiver)) }

to self_moveBy dx dy {
  if (isNil dx) { dx = 0 }
  if (isNil dy) { dy = 0 }
  m = (morph (implicitReceiver))
  if (isInHand m) { return } // don't move when picked up
  stage = (self_stageMorph)
  if (notNil stage) {
	dx = (dx * (scale stage))
	dy = (0 - (dy * (scale stage)))
  }
  moveBy m dx dy
}

to self_moveInDirection distance degrees {
  if (isNil degrees) { degrees = (rotation (morph (implicitReceiver))) }
  self_moveBy (distance * (cos degrees)) (distance * (sin degrees))
}

to self_bounceOffEdge {
  m = (morph (implicitReceiver))
  stage = (self_stageMorph)
  if (isNil stage) {return}
  fb = (fullBounds m)
  if (containsRectangle (bounds stage) fb) {return}
  dirX = (cos (rotation m))
  dirY = (sin (rotation m))
  if ((left fb) < (left stage)) {
    dirX = (abs dirX)
  }
  if ((right fb) > (right stage)) {
    dirX = (-1 * (abs dirX))
  }
  if ((top fb) < (top stage)) {
    dirY = (-1 * (abs dirY))
  }
  if ((bottom fb) > (bottom stage)) {
    dirY = (abs dirY)
  }
  rotateAndScale m (atan dirY dirX) (scale m)
  keepWithin m (bounds stage)
}

to self_keepInOwner {
  m = (morph (implicitReceiver))
  o = (owner m)
  if (and (notNil o) (not (isClass (handler o) 'Hand'))) {
	keepWithin m (bounds o)
  }
}

to self_setPosition x y {
  m = (morph (implicitReceiver))
  if (isInHand m) { return } // don't move when picked up
  stage = (self_stageMorph)
  if (notNil stage) {
    p = (transform stage x (0 - y))
    x = (first p)
    y = (last p)
  }
  placeRotationCenter m x y
}

to self_getPosition {
  m = (morph (implicitReceiver))
  stage = (self_stageMorph)
  p = (rotationCenter m)
  if (notNil stage) {
	p = (normal stage (first p) (last p))
	atPut p 2 (0 - (at p 2))
  }
  return p
}

to self_setX x { self_setPosition x (last (self_getPosition)) }
to self_setY y { self_setPosition (first (self_getPosition)) y }

to self_getX { return (first (self_getPosition)) }
to self_getY { return (last (self_getPosition)) }

to self_getWidth name {
  m = (morph (implicitReceiver))
  if (or (isNil name) ('' == name)) { return (normalWidth m) }
  bm = (imageNamed name m)
  if (isNil bm) { return 0 }
  return (width bm)
}

to self_getHeight name {
  m = (morph (implicitReceiver))
  if (or (isNil name) ('' == name)) { return (normalHeight m) }
  bm = (imageNamed name m)
  if (isNil bm) { return 0 }
  return (height bm)
}

to self_getProperty property obj {
  if (isNil obj) { obj = (implicitReceiver) }
  if (hasField obj property) {
	return (getField obj property)
  }
  if (hasField obj 'morph') {
	m = (morph obj)
	p = (rotationCenter m)
	stage = (self_stageMorph)
	if (notNil stage) { p = (normal stage (first p) (last p)) }
	if ('x' == property) {
	  return (first p)
	} ('y' == property) {
	  return (- (last p))
	}
  }
  return nil
}

to stageWidth {
  m = (morph (implicitReceiver))
  stage = (self_stageMorph)
  if (notNil stage) { return (normalWidth stage) }
  return (width (morph (global 'page')))
}

to stageHeight {
  m = (morph (implicitReceiver))
  stage = (self_stageMorph)
  if (notNil stage) { return (normalHeight stage) }
  return (height (morph (global 'page')))
}

to self_setAlpha a { setAlpha (morph (implicitReceiver)) (toInteger (255 * (clamp a 0 1))) } // obsolete
to self_setTransparency n { setTransparency (morph (implicitReceiver)) n }

to self_setRotation newRotation {
  m = (morph (implicitReceiver))
  if (isInHand m) { return } // don't move when picked up
  rotateAndScale m newRotation (scale m)
}

to self_setScale newScale {
  m = (morph (implicitReceiver))
  if (isInHand m) { return } // don't move when picked up
  maxDimension = 4000
  minDimension = 1
  minScale = (max (minDimension / (normalWidth m)) (minDimension / (normalHeight m)))
  maxScale = (max (maxDimension / (normalWidth m)) (maxDimension / (normalHeight m)))
  stage = (self_stageMorph)
  if (notNil stage) { normalizedScale = ((scale stage) * newScale) }
  normalizedScale = (clamp normalizedScale minScale maxScale)
  setScale m normalizedScale
}

to self_changeRotation delta { self_setRotation ((self_getRotation) - delta) }
to self_changeScale delta { self_setScale ((self_getScale) + delta) }

to self_getRotation { return (rotation (morph (implicitReceiver))) }

to self_getScale {
  // Return the authoring view of the scale (i.e. without normalization for display resolution)

  m = (morph (implicitReceiver))
  result = (scale m)
  stage = (self_stageMorph)
  if (notNil stage) { result = (result / (scale stage)) }
  return result
}

to self_setDraggable bool {
  if (true == bool) {
	newRule = 'handle'
  } else {
  	newRule = 'defer'
  }
  setGrabRule (morph (implicitReceiver)) newRule
}

to self_grab aHandler {
  if (isNil aHandler) {
	m = (morph (implicitReceiver))
  } (implementes aHandler 'morph') {
	m = (morph aHandler)
  }
  if (and (notNil m) ('handle' == (grabRule m))) {
	grab m
  }
}

to self_addPart part newOwner {
  if (isNil part) { return }
  m = (morph (implicitReceiver))
  stage = (self_stageMorph)
  if (isNil newOwner) { newOwner = m }
  if (not (isClass part 'Morph')) { part = (morph part) }
  if (isClass (handler part) 'Stage') { return }
  if (not (isClass newOwner 'Morph')) { newOwner = (morph newOwner) }
  if (contains (allOwners newOwner) part) { return }
  if (part == newOwner) { return } // you can't be a part of yourself

  if (isOneOf newOwner stage (morph (global 'page'))) {
    setGrabRule part 'handle' // allow grabbing on stage or page
  } else {
    setGrabRule part 'defer' // defer grabbing when added to another sprite
  }
  addPart newOwner part
}

to self_placePart part xInset yInset {
  if (isNil part) { return }
  if (isNil xInset) { xInset = 10 }
  if (isNil yInset) { yInset = 10 }
  if (not (isClass part 'Morph')) { part = (morph part) }
  m = (morph (implicitReceiver))
  self_addPart part m
  scale = (scale m)
  setPosition part ((left m) + (scale * xInset)) ((top m) + (scale * yInset))
}

to self_parts obj {
  if (isNil obj) { obj = (morph (implicitReceiver)) }
  if (not (isClass obj 'Morph')) { obj = (morph obj) }
  result = (list)
  for partM (parts obj) {
	add result (handler partM)
  }
  return result
}

to self_delete part {
  page = (global 'page')
  if (isNil part) { part = (morph (implicitReceiver)) }
  if (not (isClass part 'Morph')) { part = (morph part) }
  setGrabRule part 'handle' // re-enable grabbing
  if (notNil (owner part)) { removePart (owner part) part }
  stopTasksFor page (handler part)
}

to self_instantiate classOrName initData {
  class = nil
  if (isNil classOrName) {
    class = (classOf (implicitReceiver))
  } (isClass classOrName 'Class') {
    class = classOrName
  } else {
    caller = (caller (currentTask))
    if (notNil caller) {
      class = (classNamed (module caller) classOrName)
    }
  }
  if (isNil class) { return nil }

  if (not (contains (fieldNames class) 'morph')) { // helper class optimization
	result = (new class)
	if (notNil (methodNamed class 'initialize')) { initialize result initData }
  	return result
  }

  return (instantiate class (self_stageMorph) initData)
}

to self_owner obj {
  if (isNil obj) { obj = (morph (implicitReceiver)) }
  if (not (isClass obj 'Morph')) { obj = (morph obj) }
  owner = (owner obj)
  if (isNil owner) { return nil }
  return (handler owner)
}

to self_stageMorph {
  stageM = (global 'StageMorph')
  if (notNil stageM) { return stageM }
  stage = (self_stage)
  if (isNil stage) { return nil }
  setGlobal 'StageMorph' (morph stage)
  return (morph stage)
}

to self_stage {
  m = (implicitReceiver)
  stageM = nil
  if (hasField m 'morph') {
	stageM = (ownerThatIsA (morph (implicitReceiver)) 'Stage')
  }
  if (notNil stageM) { return (handler stageM) }
  for p (parts (morph (global 'page'))) {
	if (isClass (handler p) 'ProjectEditor') {
	  return (stage (handler p))
	}
  }
  for p (parts (morph (global 'page'))) {
	if (isClass (handler p) 'Stage') {
	  return (handler p)
	}
  }
  return nil
}

to self_neighbors expansion className {
  // Return the neighboring instances of the receiver within the bounding box of
  // the receiver expanded by the given amount. If expansion is nil or 0, the
  // neighbors must be actually touching the receiver. If className is provided,
  // only neighbors of that class are included in the results.

  if (isNil expansion) { expansion = 0 }
  if (isOneOf className '' '*' 'any class') { className = nil }
  rcvr = (implicitReceiver)
  r = (fullBounds (morph rcvr))
  if (expansion > 0) { r = (expandBy r expansion) }
  stageM = (self_stageMorph)
  if (isNil stageM) { return (list) }

  allNeighbors = (list)
  for m (copy (parts stageM)) {
	if (rectanglesTouch (bounds m) r) {
	  add allNeighbors (handler m)
	}
  }
  remove allNeighbors rcvr

  result = (list)
  for n allNeighbors { // select only neighbors of className
	if (or (isNil className) (className == (className (classOf n)))) {
	  if (or (expansion > 0) (self_touching n)) { // if expansion is 0, must be actually touching
		add result n
	  }
	}
  }
  return result
}

to self_createCostume w h color {
  if (isNil color) { color = (gray 200) }
  m = (morph (implicitReceiver))
  p = (rotationCenter m)
  setCostume m (newBitmap w h color)
  placeRotationCenter m (first p) (last p)
  l = ((first p) - ((w / 2) + (pinX m)))
  t = ((last p) - ((h / 2) + (pinY m)))
  setBounds m (scaledAndRotatedBoundingBox (rect l t w h) (scaleX m) (scaleY m) (rotation m) (first p) (last p))
}

to self_costume name {
  m = (morph (implicitReceiver))
  if (isClass name 'String') {
	bm = (imageNamed name m)
	if (isNil bm) { bm = (costumeData m) }
  } else {
	bm = (costumeData m)
  }
  return (copy bm)
}

to imageNamed name m {
  proj = (projectForMorph m)
  if (isNil proj) { return nil }
  return (imageNamed proj name)
}

to self_setCostume bitmapOrName {
  m = (morph (implicitReceiver))
  if (isClass bitmapOrName 'String') {
	bitmapOrName = (imageNamed bitmapOrName m)
  }
  if (not (isClass bitmapOrName 'Bitmap')) { return }
  p = (rotationCenter m)
  setCostume m bitmapOrName
  placeRotationCenter m (first p) (last p)
}

to self_setTextCostume s c fontName fontSize {
  if (not (isClass s 'String')) { s = (toString s) }
  if (isNil c) { c = (gray 0) }
  if (isNil fontName) { fontName = 'Arial Bold' }
  if (isNil fontSize) { fontSize = 24 }
  setFont fontName fontSize
  w = (min ((stringWidth s) + (round (fontSize / 10))) 1000) // increase width by 10% of font size for italic
  h = (min (fontHeight) 1000)
  bm = (newBitmap w h (withAlpha c 1)) // alpha = 1 allow transparent areas to be touched
  setFont fontName fontSize
  drawString bm s c 0 0
  setCostume (morph (implicitReceiver)) bm
}

to self_snapshotCostume name {
  // Save a snapshot of my current costume to the images tab.

  m = (morph (implicitReceiver))
  proj = (projectForMorph m)
  if (isNil proj) { return }
  saveImageAs proj (takeSnapshot m) name
}

to self_snapshotStage name {
  // Save a snapshot of the stage (and everything on it) to the images tab.

  m = (morph (implicitReceiver))
  stage = (self_stageMorph)
  if (isNil stage) { return }
  proj = (projectForMorph m)
  if (isNil proj) { return }
  saveImageAs proj (takeSnapshot stage) name
}

to self_drawLine x1 y1 x2 y2 color w {
  if (isNil w) { w = 1 }
  m = (morph (implicitReceiver))
  bm = (costumeData m)
  if (not (isClass bm 'Bitmap')) { return }
  pen = (newVectorPen bm m (not (vectorTrails)))
  beginPath pen x1 y1
  lineTo pen x2 y2
  stroke pen color w
}

to self_fillWithColor color {
  // Fill my costume with the given color.
  bm = (costumeData (morph (implicitReceiver)))
  if (not (isClass bm 'Bitmap')) { return }
  fill bm color
  costumeChanged (morph (implicitReceiver))
}

to self_floodFill x y color threshold {
  bm = (costumeData (morph (implicitReceiver)))
  if (not (isClass bm 'Bitmap')) { return }
  floodFill bm (toInteger x) (toInteger y) color threshold
  costumeChanged (morph (implicitReceiver))
}

to self_fillRect x y w h color roundness {
  m = (morph (implicitReceiver))
  x = (toInteger x)
  y = (toInteger y)
  w = (abs (toInteger w))
  h = (abs (toInteger h))
  bm = (costumeData m)
  if (not (isClass bm 'Bitmap')) { return }
  if (and (notNil roundness) (roundness > 0)) {
	fillRoundedRect (newShapeMaker bm) (rect x y w h) roundness color
  } else {
	fillRect bm color x y w h
  }
  costumeChanged m
}

to self_fillCircle cx cy radius color borderWidth borderColor {
  bm = (costumeData (morph (implicitReceiver)))
  if (not (isClass bm 'Bitmap')) { return }
  drawCircle (newShapeMaker bm) cx cy radius color borderWidth borderColor
  costumeChanged (morph (implicitReceiver))
}

to self_drawText s x y color {
  bm = (costumeData (morph (implicitReceiver)))
  if (not (isClass bm 'Bitmap')) { return }
  if (not (isClass s 'String')) { s = (toString s) }
  drawString bm s color x y
  costumeChanged (morph (implicitReceiver))
}

to self_setFont fontName fontSize {
  if (isNil fontName) { fontName = 'Arial' }
  if (isNil fontSize) { fontSize = 24 }
  setFont fontName fontSize
}

to self_getPixel x y bm {
  // Note: Pixel coordinates are 1-based in the authoring system!

  if (isNil bm) { bm = (costumeData (morph (implicitReceiver))) }
  if (not (isClass bm 'Bitmap')) { return }
  return (interpolatedPixel bm x y (color))
}

to self_setPixel x y color bm {
  // Note: Pixel coordinates are 1-based in the authoring system!

  if (notNil bm) { // fast version for offscreen bitmaps
	setPixel bm (x - 1) (y - 1) color
	return
  }
  m = (morph (implicitReceiver))
  bm = (costumeData m)
  setPixel bm (x - 1) (y - 1) color
  costumeChanged m
}

to projectForMorph m {
  for p (parts (morph (global 'page'))) {
	if (isClass (handler p) 'ProjectEditor') {
	  return (project (handler p))
	}
  }
  for p (parts (morph (global 'page'))) {
	if (isClass (handler p) 'Stage') {
	  return (project (handler p))
	}
  }
  return nil
}

to self_drawBitmap bitmapOrName x y scale alpha {
  m = (morph (implicitReceiver))
  if (isClass bitmapOrName 'String') {
	srcBM = (imageNamed bitmapOrName m)
  } else {
	srcBM = bitmapOrName
  }
  if (not (isClass srcBM 'Bitmap')) { return }

  dstBM = (costumeData m)
  if (not (isClass dstBM 'Bitmap')) { return }

  if (and (notNil scale) (1 != scale)) {
	scaledBM = (newBitmap (scale * (width srcBM)) (scale * (height srcBM)))
	warpBitmap scaledBM srcBM (half (width scaledBM)) (half (height scaledBM)) scale scale
	srcBM = scaledBM
  }

  drawBitmap dstBM srcBM x y alpha
  costumeChanged m
}

to self_setPinXY x y { setPin (morph (implicitReceiver)) x y }

to self_mouseX {
  stage = (self_stageMorph)
  if (notNil stage) {
	return (first (normal stage (handX) (handY)))
  } else {
	return (handX)
  }
}

to self_mouseY {
  stage = (self_stageMorph)
  if (notNil stage) {
	return (0 - (last (normal stage (handX) (handY))))
  } else {
	return (handY)
  }
}

to self_distanceToMouse {
  m = (morph (implicitReceiver))
  rc = (rotationCenter m)
  dx = ((handX) - (first rc))
  dy = ((handY) - (last rc))
  dist = (sqrt ((dx * dx) + (dy * dy))) // screen distance
  stage = (self_stageMorph)
  if (notNil stage) { dist = (dist / (scale stage)) }
  return dist
}

to self_directionToMouse {
  m = (morph (implicitReceiver))
  rc = (rotationCenter m) //  in global (screen) coordinates
  dx = ((handX) - (first rc))
  dy = ((handY) - (last rc))
  return (atan (- dy) dx)
}

to self_distanceToSprite other {
  if (isClass other 'String') { other = (self_findInstanceOf other) }
  if (not (hasField other 'morph')) { return 0 }
  otherRC = (rotationCenter (morph other))
  m = (morph (implicitReceiver))
  rc = (rotationCenter m)
  dx = ((first rc) - (first otherRC))
  dy = ((last rc) - (last otherRC))
  dist = (sqrt ((dx * dx) + (dy * dy)))
  stage = (self_stageMorph)
  if (notNil stage) { dist = (dist / (scale stage)) }
  return dist
}

to self_directionToSprite other {
  if (isClass other 'String') { other = (self_findInstanceOf other) }
  if (not (hasField other 'morph')) { return 0 }
  m = (morph (implicitReceiver))
  otherRC = (rotationCenter (morph other))
  myRC = (rotationCenter m)
  dx = ((first otherRC) - (first myRC))
  dy = ((last otherRC) - (last myRC))
  return (atan (- dy) dx)
}

to self_findInstanceOf className {
  // Return an instance of the given class on the stage or nil if there isn't one.
  stage = (self_stageMorph)
  if (notNil stage) {
	for m (parts stage) {
	  if (className == (className (classOf (handler m)))) { return (handler m) }
	}
  }
  for m (parts (morph (hand (global 'page')))) {
	if (isClass (handler m) className) { return (handler m) }
  }
  return nil
}

to self_localMouseX {
  m = (morph (implicitReceiver))
  return (toInteger ((first (normal m (handX) (handY))) + ((normalWidth m) / 2)))
}

to self_localMouseY {
  m = (morph (implicitReceiver))
  return (toInteger ((last (normal m (handX) (handY))) + ((normalHeight m) / 2)))
}

to self_touchingMouse {
  handX = (handX)
  handY = (handY)
  morph = (morph (implicitReceiver))
  if (not (containsPoint (bounds morph) handX handY)) { return false }
  return ((implicitReceiver) == (objectAt (hand (global 'page')) true))
}

to self_touching other {
  if ('edge' == other) {
	stage = (self_stageMorph)
	if (isNil stage) { return false }
	fb = (fullBounds (morph (implicitReceiver)))
	return (not (containsRectangle (bounds stage) fb))
  }
  if ('mouse' == other) {
	return (self_touchingMouse)
  }
  if (isClass other 'String') {
	// if other is a string, return true if this sprite
	// is touching any sprite with the given class name
	for each (self_neighbors 0 other) {
		if (self_touching each) { return true }
	}
	return false
  }
  if (not (isClass other 'Morph')) { other = (morph other) }
  m = (morph (implicitReceiver))
  if (not (intersects (bounds m) (bounds other))) { return false }

  r = (intersection (bounds m) (bounds other))
  if (or ((width r) < 1) ((height r) < 1)) { return false }
  ownerScale = (scale (owner m))
  w = (ceiling ((width r) / ownerScale))
  h = (ceiling ((height r) / ownerScale))
  if (or (w < 1) (h < 1)) { return false }

  xOffset = (- (left r))
  yOffset = (- (top r))
  bm1 = (newBitmap w h)
  draw m bm1 xOffset yOffset (1 / ownerScale)
  bm2 = (newBitmap w h)
  draw other bm2 xOffset yOffset (1 / ownerScale)

  return (bitmapsTouch bm1 bm2)
}

to self_penDown {penDown (morph (implicitReceiver))}
to self_penUp {penUp (morph (implicitReceiver))}
to self_setPenSize num {setPenLineWidth (morph (implicitReceiver)) (max 0 num)}
to self_setPenColor clr {setPenColor (morph (implicitReceiver)) clr}
to self_stampCostume transparency {stampCostume (morph (implicitReceiver)) transparency}
to self_clear {penClear (morph (implicitReceiver))}

to self_penFillArea x y color {
  m = (morph (implicitReceiver))
  target = (penTarget m)
  if (isNil target) { return }
  trails = (requirePenTrails target true)
  trailsBM = (toBitmap trails)
  seedX = (toInteger (x + ((width trailsBM) / 2)))
  seedY = (toInteger (((height trailsBM) / 2) - y))
  if (isNil color) { color = (color (requirePen m)) }
  floodFill trailsBM seedX seedY color
  drawBitmap trails trailsBM 0 0 255 0 // blend mode 'none' so we can fill with transparent)
  changed target
}

to playSound snd {
  if (isClass snd 'String') {
	// argument is the name of a sound
	proj = (projectForMorph (morph (implicitReceiver)))
	if (notNil proj) { snd = (soundNamed proj snd) }
  }
  if (not (isClass snd 'Sound')) { return }
  mixer = (soundMixer (global 'page'))
  addSound mixer snd
  while (isPlaying mixer snd) {
	waitForNextFrame
  }
}

to samplesForSoundNamed sndName {
  proj = (projectForMorph (morph (implicitReceiver)))
  if (notNil proj) { snd = (soundNamed proj sndName) }
  if (isNil snd) { error (join 'No sound named' sndName) }
  return (samples snd)
}

to playSoundSamples samples rate {
  if (isNil rate) { rate = 100 }
  snd = (newSound samples (220.50 * rate) false 'samples')
  mixer = (soundMixer (global 'page'))
  addSound mixer snd
  while (isPlaying mixer snd) {
	waitForNextFrame
  }
}

to stopSound snd {
  removeSound (soundMixer (global 'page')) snd
}

to stopAllSounds {
  stopAllSounds (soundMixer (global 'page'))
}

to fftOfSamples samples useWindow {
  if (isNil useWindow) { useWindow = true }
  n = (count samples)
  if (n < 2) { return (array) }
  if (not (isPowerOfTwo n)) {
	fftSize = 2
	while (and (fftSize <= 8192) ((n >= (2 * fftSize)))) {
		fftSize = (2 * fftSize)
	}
	samples = (copyFromTo samples 1 fftSize)
  }
  return (fft (toArray samples) useWindow)
}

to setPageColor color {
  page = (global 'page')
  setColor page color
  changed page
}

to self_setStageColor color bitmapOrName {
  m = (morph (implicitReceiver))
  stage = (self_stageMorph)
  if (notNil stage) {
	setColor (handler stage) color
	if (isClass bitmapOrName 'String') {
	  bitmapOrName = (imageNamed bitmapOrName m)
	}
	setBackgroundImage (handler stage) bitmapOrName
  } else {
	setPageColor color
  }
}

to points n {
  return (n * (global 'scale'))
}

to showText s {
  if (not (isClass s 'String')) { s = (toString s) }
  openWorkspace (global 'page') s
}

to askUser question defaultAnswer {
  if (isNil defaultAnswer) { defaultAnswer = '' }
  page = (global 'page')
  hand = (hand page)

  // center the dialog on the Stage or page
  centerX = (hCenter (bounds (morph page)))
  centerY = (vCenter (bounds (morph page)))
  for m (allMorphs (morph page)) {
	if (isClass (handler m) 'Stage') {
	  centerX = (hCenter (bounds m))
	  centerY = (vCenter (bounds m))
	}
  }

  p = (new 'Prompter')
  initialize p question defaultAnswer 'line'
  fixLayout p
  setCenter (morph p) centerX centerY
  keepWithin (morph p) (bounds (morph page))
  addPart (morph page) (morph p)
  edit (textBox p) hand
  selectAll (textBox p)
  while (not (isDone p)) {
	waitMSecs 100
  }
  result = (answer p)
  if (notNil (toNumber result nil)) { result = (toNumber result) }
  return result
}

to selectFromMenu itemList {
  if (not (isAnyClass itemList 'Array' 'List')) { return nil }
  if (isEmpty itemList) { return nil }
  resultHolder = (array nil)
  menu = (menu nil (action 'atPut' resultHolder 1) true)
  for item itemList {
	addItem menu item nil nil (thumbnailOrNil item)
  }
  popUpAtHand menu (global 'page')
  while (notNil (owner (morph menu))) {
	waitMSecs 50
  }
  return (first resultHolder)
}

to showMenuFor itemList action {
  if (not (isAnyClass itemList 'Array' 'List')) { return }
  if (isEmpty itemList) { return }
  menu = (menu nil action true)
  for item itemList {
	addItem menu item nil nil (thumbnailOrNil item)
  }
  popUpAtHand menu (global 'page')
}

to thumbnailOrNil anObject {
  thumbSize = (20 * (global 'scale'))
  if (isClass anObject 'Bitmap') {
	return (thumbnail anObject thumbSize thumbSize)
  } (isClass anObject 'Morph') {
	return (thumbnailOrNil (costumeData anObject))
  } (hasField anObject 'morph') {
	return (thumbnailOrNil (getField anObject 'morph'))
  }
  return nil
}

to self_readFile fileName binaryFlag {
  if (true == binaryFlag) {
	return (readFile fileName true)
  }
  data = (readFile fileName)
  if (isNil data) { return nil }
  if (beginsWith data '~=== Begin GP Object Data ===~') {
	return (read (new 'Serializer') (toBinaryData data))
  } (beginsWith data (toBinaryData (array 137 80 78 71))) {
	return (readFrom (new 'PNGReader') (toBinaryData data))
  }
  return data
}

to self_writeFile fileName data {
  if (isAnyClass data 'String' 'BinaryData') {
	writeFile fileName data
  } (isClass data 'Bitmap') {
	writeFile fileName (encodePNG data)
  } else {
	blob = (write (new 'Serializer') data)
	writeFile fileName blob
  }
}

to playNote pitch seconds instrument {
  if (isNil seconds) { seconds = 1 }
  if (isNil instrument) { instrument = 'piano' }
  if (isNumber pitch) {
	k = pitch
  } else {
	k = (toNumber pitch nil)
	if (isNil k) {
	  notes = (parse (new 'ABCParser') pitch)
	  if ((count notes) > 0) {
		k = (key (first notes))
	  }
	}
	if (isNil k) { return } // not a valid pitch
  }
  k = (clamp k 12 127)
  if (seconds < 0) {
	// Negative seconds makes the command return immediately rather than waiting until
	// the note finishes playing. The duration is the absolute value of seconds.
	seconds = (- seconds)
	doNotWait = true
  } else {
	doNotWait = false
  }
  notePlayer = (notePlayer (newSampledInstrument instrument) k (round (1000 * seconds)))
  mixer = (getMixer)
  addSound mixer notePlayer
  if doNotWait {return}
  while (isPlaying mixer notePlayer) {
	waitMSecs 5
  }
}

to speak text voice rate {
  speak (getMixer) text voice rate
}

to stopSpeaking {
  stopSpeaking (getMixer)
}

to self_costumeColor x y {
  m = (morph (implicitReceiver))

  stage = (self_stageMorph)
  if (notNil stage) {
    p = (transform stage x (0 - y))
    x = (first p)
    y = (last p)
  }

  p = (normal m x y)
  localX = (toInteger ((first p) + ((normalWidth m) / 2)))
  localY = (toInteger ((last p) + ((normalHeight m) / 2)))

  bm = (costumeData m)
  if (not (isClass bm 'Bitmap')) { return }
  return (interpolatedPixel bm localX localY (color))
}

to screenColorAt x y {
  stage = (self_stageMorph)
  if (notNil stage) {
    p = (transform stage x (0 - y))
    x = (first p)
    y = (last p)
  }
  bm = (takeSnapshotWithBounds (morph (global 'page')) (rect x y 1 1))
  return (getPixel bm 0 0)
}

to self_beginPath x y {
  m = (morph (implicitReceiver))
  bm = (costumeData m)
  if (not (isClass bm 'Bitmap')) { return }
  pen = (newVectorPen bm m)
  setField m 'vectorPen' pen
  beginPath pen x y
}

to self_setPathDirection angle {
  m = (morph (implicitReceiver))
  pen = (getField m 'vectorPen')
  if (isNil pen) { return }
  setHeading pen angle
}

to self_extendPath distance curvature {
  m = (morph (implicitReceiver))
  pen = (getField m 'vectorPen')
  if (isNil pen) { return }
  forward pen distance curvature
}

to self_turnPath distance degrees radius {
  m = (morph (implicitReceiver))
  pen = (getField m 'vectorPen')
  if (isNil pen) { return }
  turn pen distance degrees radius
}

to self_addLineToPath x y {
  m = (morph (implicitReceiver))
  pen = (getField m 'vectorPen')
  if (isNil pen) { return }
  lineTo pen x y
}

to self_addCurveToPath x y cx cy {
  m = (morph (implicitReceiver))
  pen = (getField m 'vectorPen')
  if (isNil pen) { return }
  curveTo pen x y cx cy
}

to self_strokePath color width jointStyle capStyle {
  m = (morph (implicitReceiver))
  pen = (getField m 'vectorPen')
  if (isNil pen) { return }
  stroke pen color width jointStyle capStyle
}

to self_fillPath color {
  m = (morph (implicitReceiver))
  pen = (getField m 'vectorPen')
  if (isNil pen) { return }
  fill pen color
}
defineClass AuthoringSpecs specsList specsByOp opCategory language translationDictionary

method allOpNames AuthoringSpecs {
  result = (toList (keys specsByOp))
  editor = (findProjectEditor)
  if (notNil editor) {
	addAll result (keys (blockSpecs (project editor)))
  }
  return result
}

// initialization

method initialize AuthoringSpecs {
  // Initialize the specsByOp and opCategory dictionaries.
  // Note: specsByOp maps an op to a list of matching specs.

  clear this
  addSpecs this (initialSpecs this)
  return this
}

method clear AuthoringSpecs {
  specsList = (list)
  specsByOp = (dictionary)
  opCategory = (dictionary)
  language = 'English'
  translationDictionary = nil
  return this
}

method addSpecs AuthoringSpecs newSpecs {
  category = ''
  for entry newSpecs {
	add specsList entry
	if (isClass entry 'String') {
	  if ('-' != entry) { category = entry }
	} else {
	  op = (at entry 2)
	  specsForOp = (at specsByOp op (list))
	  add specsForOp (specForEntry this entry)
	  atPut specsByOp op specsForOp
	  if (not (contains opCategory op)) {
		atPut opCategory op category
	  }
	}
  }
  // special cases for the block finder for blocks that are in multiple categories
  atPut opCategory 'randomColor' 'Color'
  atPut opCategory 'transparent' 'Color'
}

method recordBlockSpec AuthoringSpecs op spec {
  // Record a block spec for the give op. Called when creating/changing functions and methods.
  editor = (findProjectEditor)
  if (isNil editor) { return } // should not happen
  recordBlockSpec (project editor) op spec
}

// queries

method allSpecs AuthoringSpecs {
  result = (list)
  for entry specsList {
	if (isClass entry 'Array') { add result entry }
  }
  return result
}

method specForEntry AuthoringSpecs e {
  // Return a BlockSpec for the given entry array.

  blockType = (at e 1)
  op = (at e 2)
  specString = (at e 3)
  slotTypes = ''
  if ((count e) > 3) { slotTypes = (at e 4) }
  slotDefaults = (array)
  if ((count e) > 4) { slotDefaults = (copyArray e ((count e) - 4) 5) }
  return (blockSpecFromStrings op blockType specString slotTypes slotDefaults)
}

method specForOp AuthoringSpecs op cmdOrReporter {
  // Return a BlockSpec for the given op, or nil if there isn't one.
  // If cmdOrReporter is supplied, use it to disambiguate when there
  // there are multiple blocks specs matching the given op.

  matchingSpecs = (at specsByOp op (array))
  editor = (findProjectEditor)
  if (notNil editor) {
	projectSpecs = (blockSpecs (project editor))
	if (contains projectSpecs op) {
	  // if project defines op, try that first
	  matchingSpecs = (join (array (at projectSpecs op)) matchingSpecs)
    }
  }
  if (isEmpty matchingSpecs) { return nil }
  if (or ((count matchingSpecs) == 1) (isNil cmdOrReporter)) {
	return (translateToCurrentLanguage this (first matchingSpecs))
  }

  // filter by block type
  isReporter = (isClass cmdOrReporter 'Reporter')
  filtered = (list)
  for s matchingSpecs {
	if (isReporter == ('r' == (blockType s))) {
		add filtered s
	}
  }
  if ((count filtered) == 1) { return (translateToCurrentLanguage this (first filtered)) } // unique match
  if (isEmpty filtered) { filtered = matchingSpecs } // revert if no matches

  // filter by arg count
  argCount = (count (argList cmdOrReporter))
  filtered2 = (list)
  for s filtered {
	if (argCount == (slotCount s)) {
		add filtered2 s
	}
  }
  if ((count filtered2) > 0) { return (translateToCurrentLanguage this (first filtered2)) }
  return (translateToCurrentLanguage this (first filtered))
}

method specsFor AuthoringSpecs category {
  // Return a list of BlockSpecs for the given category.

  editor = (findProjectEditor)
  if (notNil editor) {
	if (contains (extraCategories (project editor)) category) {
	  return (specsForCategory (project editor) category)
	}
  }
  result = (list)
  currentCategory = ''
  for entry specsList {
	if (isClass entry 'String') {
	  if ('-' == entry) {
		if (currentCategory == category) { add result '-' }
	  } else {
		currentCategory = entry
	  }
	} (currentCategory == category) {
	  add result (specForEntry this entry)
	}
  }
  return result
}

method categoryFor AuthoringSpecs op {
  return (at opCategory op)
}

method hasTopLevelSpec AuthoringSpecs op {
  return (contains specsByOp op)
}

method setOpCategory AuthoringSpecs op category {
	atPut opCategory op category
}

// block colors

method blockColorForOp AuthoringSpecs op {
  if ('comment' == op) { return (colorHSV 55 0.6 0.93) }
  return (blockColorForCategory this (at opCategory op))
}

method blockColorForCategory AuthoringSpecs cat {
  defaultColor = (color 4 148 220)
  if (isOneOf cat 'Control' 'Functions') {
	if (notNil (global 'controlColor')) { return (global 'controlColor') }
	return (color 230 168 34)
  } ('Variables' == cat) {
	if (notNil (global 'variableColor')) { return (global 'variableColor') }
	return (color 243 118 29)
  } (isOneOf cat 'Operators' 'Math') {
	if (notNil (global 'operatorsColor')) { return (global 'operatorsColor') }
	return (color 98 194 19)
  } ('Obsolete' == cat) {
	return (color 196 15 0)
  }
  if (notNil (global 'defaultColor')) { return (global 'defaultColor') }
  return defaultColor
}

to setBlockColors c1 c2 c3 c4 {
  // Allows experimentation with block colors.
  setGlobal 'controlColor' c1
  setGlobal 'variableColor' c2
  setGlobal 'operatorsColor' c3
  setGlobal 'defaultColor' c4
  fixBlockColors
}

to setBlockTextColor c {
  setGlobal 'blockTextColor' c
  fixBlockColors
}

to resetBlockColors {
  // Revert to original block colors.
  setGlobal 'controlColor' (color 230 168 34)
  setGlobal 'variableColor' (color 243 118 29)
  setGlobal 'operatorsColor' (color 98 194 19)
  setGlobal 'defaultColor' (color 4 148 220)
  setGlobal 'blockTextColor' (gray 255)
  fixBlockColors
}

to fixBlockColors {
  // update colors of existing blocks
  for b (allInstances (class 'Block')) {
	expr = (expression b)
	if (notNil expr) {
	  setBlockColor b (primName expr)
	  redraw b
	}
	textColor = (global 'blockTextColor')
	if (isNil textColor) { textColor = (gray 0) }
	for m (parts (morph b)) {
	  if (isClass (handler m) 'Text') { setColor (handler m) textColor }
	}
  }
}

// translation

method language AuthoringSpecs { return language }
method languageCode AuthoringSpecs { return (languageCodeForName this language) }

method setLanguage AuthoringSpecs newLangOrCode {
  newLang = (languageNameForCode this newLangOrCode)
  translationData = (readEmbeddedFile (join 'translations/' newLang '.txt'))
  if (isNil translationData) {
	// if not embedded file, try reading external file
	translationData = (readFile (join 'translations/' newLang '.txt'))
  }
  if (isNil translationData) {
	// if still nil, we may be in the wrong dir
	translationData = (readFile (join '../translations/' newLang '.txt'))
  }
  if (isNil translationData) {
	language = 'English'
	translationDictionary = nil
  } else {
	language = newLang
	installTranslation this translationData
  }
}

method translateToCurrentLanguage AuthoringSpecs spec {
  if (not (needsTranslation this spec)) { return spec }

  newSpecStrings = (list)
  for s (specs spec) {
	add newSpecStrings (at translationDictionary s s)
  }
  result = (clone spec)
  setField result 'specs' newSpecStrings
  setField result 'slotInfo' (translatedSlotInfo spec)
  return result
}

method needsTranslation AuthoringSpecs spec {
  // Return true if any of the spec strings of spec needs to be translated.

  if (isNil translationDictionary) { return false }
  for s (specs spec) {
	localization = (localizedOrNil s)
	if (and (notNil localization) (localization != '--MISSING--')) {
		return true
	}
  }
  return false
}

method installTranslation AuthoringSpecs translationData langName {
  // Translations data is string consisting of three-line entries:
  //	original string
  //	translated string
  //	<blank line>
  //	...
  // Lines starting with # are treated as comments

  translationDictionary = (dictionary)
  lines = (toList (lines translationData))
  while ((count lines) >= 2) {
	from = (removeFirst lines)
	// ignore comments and blank lines
	while (and
			((count lines) >= 2)
			(or (beginsWith from '#') (from == ''))) {
		from = (removeFirst lines)
	}
	if ((count lines) >= 1) {
		to = (removeFirst lines)
		atPut translationDictionary from to
	}
  }
  if (notNil langName) { language = langName }
}

to localized aString {
  if (isEmpty aString) { return aString }
  localization = (localizedOrNil aString)
  if (or (isNil localization) (localization == '--MISSING--')) {
	return aString
  } else {
	return localization
  }
}

to localizedOrNil aString {
  if (isNil aString) { return nil }
  dict = (getField (authoringSpecs) 'translationDictionary')
  if (isNil dict) {
	return aString
  } else {
	return (at dict aString)
  }
}

// country codes

method languageCodeForName AuthoringSpecs langName {
  // Return the language code for the given language or the argument if no match found.

  for pair (languageCodeList this) {
    if (langName == (first pair)) { return (at pair 2) }
  }
  return langName
}

method languageNameForCode AuthoringSpecs langCode {
  // Return the language name for the given languag codee or the argument if no match found.
  // The language name is the file name of the translation file.

  for pair (languageCodeList this) {
    if (langCode == (at pair 2)) { return (first pair) }
  }
  return langCode
}

method languageCodeList AuthoringSpecs {
  // Return an array of (<languageName> <abbreviation>) pairs."

  return (array
    (array 'English' 'en' )
    (array 'Castellano' 'es' )
    (array 'CatalÃ ' 'ca' )
    (array 'Deutsch' 'de' )
    (array 'FranÃ§ais' 'fr' )
    (array 'Galego' 'gl' )
    (array 'Nederlands' 'nl' )
    (array 'PortuguÃªs (Brasil)' 'pt-br' )
    (array 'PortuguÃªs' 'pt' )
    (array 'TÃ¼rkÃ§e' 'tr' )
    (array 'Uzbek' 'ux' )
    (array 'ÎÎ»Î»Î·Î½Î¹ÎºÎ¬' 'el' )
    (array 'Ð ÑÑÑÐºÐ¸Ð¹' 'ru' )
    (array 'Ø¹Ø±Ø¨Ù' 'ar' )
    (array 'æ¥æ¬èª' 'ja' )
    (array 'ç®ä½ä¸­æ' 'zh' )
  )
}

// authoring specs

method initialSpecs AuthoringSpecs {
  return (array
	'Control'
	  (array ' ' 'animate'				'forever _' 'cmd')
	  (array ' ' 'if'					'if _ _ : else if _ _ : ...' 'bool cmd bool cmd')
	  (array ' ' 'repeat'				'repeat _ _' 'num cmd' 10)
	  (array ' ' 'waitSecs'				'wait : _ seconds' 'num' 0.1)
	  (array ' ' 'waitUntil'			'wait until _' 'bool')
	  (array ' ' 'stopTask'				'stop')
	  (array ' ' 'self_stopAll'			'stop all')
	  (array 'h' 'whenKeyPressed'		'when _ key pressed : _' 'menu.keyMenu var' 'space' 'key')
	  (array 'h' 'whenBroadcastReceived' 'when I receive _ : _' 'str var' 'go' 'data')
	  (array ' ' 'broadcast'			'broadcast _ : with _' 'str auto' 'go')
	  (array ' ' 'broadcastAndWait'		'broadcast _ and wait : with _' 'str auto' 'clear')
	  (array ' ' 'send'					'send _ to _ : with _ ' 'str all auto' 'start')
	  (array 'r' 'gather'				'gather _ : from _ : with _' 'str list auto')
	  (array ' ' 'return'				'return _' 'auto')
	  (array ' ' 'for'					'for _ in _ _' 'var num cmd' 'i' 10)
	  (array 'r' 'range'				'range from _ to _ : by _' 'num num num' 1 10 1)
	  (array ' ' 'while'				'while _ _' 'bool cmd')
	  (array 'h' 'whenClicked'			'when clicked')
	  (array 'h' 'whenDropped'			'when dropped')
	  (array 'h' 'whenTracking'			'when tracking _ _' 'var var' 'mouse x' 'mouse y')
	  (array ' ' 'comment'				'comment _' 'str' 'Use this block to explain your code')

	'Functions'
	  (array 'r' 'function'				'function _' 'cmd')
	  (array 'r' 'function'				'function _ _' 'var cmd' 'a')
	  (array 'r' 'function'				'function _ _ _' 'var var cmd' 'a' 'b')
	  (array 'r' 'action'				'action _ : _ : ...' 'str auto auto')
	  (array ' ' 'call'					'call _ : _ : ...' 'str auto auto')
	  (array 'r' 'call'					'call _ : _ : ...' 'str auto auto')
	  (array ' ' 'return'				'return _' 'auto')
	  (array 'r' 'map'					'map _ over _' 'str list' 'func')
	  (array 'r' 'filter'				'filter _ from _' 'str list' 'func')
	  (array 'r' 'detect'				'detect first _ in _' 'str list' 'func')
	  (array 'r' 'reduce'				'reduce _ over _ seed _' 'str list auto' 'twoInputFunc')

	'Variables'
	  (array 'r' 'shared'			'shared _' 'menu.sharedVarMenu' 'score')
	  (array ' ' 'setShared'		'set shared _ to _' 'menu.sharedVarMenu auto' 'score' 0)
	  (array ' ' 'increaseShared'	'change shared _ by _' 'menu.sharedVarMenu num' 'score' 1)
	  (array 'r' 'my'				'my _' 'menu.myVarMenu' 'n')
	  (array ' ' 'setMy'			'set my _ to _' 'menu.myVarMenu auto' 'n' 0)
	  (array ' ' 'increaseMy'		'change my _ by _' 'menu.myVarMenu num' 'n' 1)
	  (array ' ' 'local'			'let _ be _' 'var auto' 'var')
	  (array 'r' 'v'				'_' 'menu.localVarMenu' 'n')
	  (array ' ' '='				'set _ to _' 'menu.localVarMenu auto' 'n' 0)
	  (array ' ' '+='				'change _ by _' 'menu.localVarMenu num' 'n' 1)

	'Operators'
	  (array 'r' '+'				'_ + _ : + _ : ...' 'num num num' 10 2 10)
	  (array 'r' '-'				'_ â _' 'num num' 10 2)
	  (array 'r' '*'				'_ Ã _ : Ã _ : ...' 'num num num' 10 2 10)
	  (array 'r' '/'				'_ / _' 'num num' 10 2)
	  (array 'r' '%'				'_ mod _' 'num num' 7 5)
	  (array 'r' 'negate'			'â _' 'num' 10)
	  (array 'r' 'rand'				'random _ : to _' 'num num' 10 20)
	  (array 'r' '<'				'_ < _' 'auto auto' 1 2)
	  (array 'r' '<='				'_ <= _' 'auto auto' 1 2)
	  (array 'r' '=='				'_ == _' 'auto auto' 1 2)
	  (array 'r' '!='				'_ != _' 'auto auto' 1 2)
	  (array 'r' '>='				'_ >= _' 'auto auto' 1 2)
	  (array 'r' '>'				'_ > _' 'auto auto' 1 2)
	  (array 'r' 'isBetween'		'is _ between _ and _ ?' 'num num num' 1 1 3)
	  (array 'r' 'and'				'_ and _ : and _ : ...' 'bool bool bool' true false)
	  (array 'r' 'or'				'_ or _ : or _ : ...' 'bool bool bool' true false)
	  (array 'r' 'not'				'not _' 'bool' true)
	  (array 'r' 'booleanConstant'	'_' 'bool' true)
	  (array 'r' 'abs'				'abs _' 'num' -10)
	  (array 'r' 'truncate'			'truncate _' 'num' 1.9)
	  (array 'r' 'round'			'round _ : to _' 'num num' 123.456 0.01)
	  (array 'r' 'floor'			'floor _' 'num' 1.9)
	  (array 'r' 'ceiling'			'ceiling _' 'num' 1.1)
	  (array 'r' 'max'				'max _ : _ : ...' 'num num' 1 2)
	  (array 'r' 'min'				'min _ : _ : ...' 'num num' 1 2)
	  (array 'r' 'clamp'			'clamp _ between _ and _' 'num num num' 12 1 10)
	  (array 'r' 'sqrt'				'sqrt _' 'num' 81)
	  (array 'r' 'isPrime'			'is _ prime?' 'num' 17)
	  (array 'r' 'isAnyClass'		'_ is class _ : or _ : ...' 'auto str.classNameMenu str str str str' 'Hi!' 'String')
	  (array 'r' 'isNil'			'isNil _' 'obj' nil)
	  (array 'r' 'notNil'			'notNil _' 'obj' nil)
	  (array 'r' 'nil'				'nil')
	  (array 'r' 'distanceFromTo'	'distance from x _ y _ to x _ y _' 'num num num num' 0 0 3 4)
	  (array 'r' 'directionFromTo'	'direction from x _ y _ to x _ y _' 'num num num num' 0 0 3 4)
	  (array 'r' 'sin'				'sin _ degrees' 'num' 90)
	  (array 'r' 'cos'				'cos _ degrees' 'num' 90)
	  (array 'r' 'tan'				'tan _ degrees' 'num' 45)
	  (array 'r' 'atan'				'arctan _ _' 'num num' 1 1)
	  (array 'r' 'toRadians'		'to radians _' 'num' 180)
	  (array 'r' 'toDegrees'		'to degrees _' 'num' 3.14159)
	  (array 'r' 'pi'				'pi')
	  (array 'r' 'logBase'			'log _ : base _' 'num num' 100 10)
	  (array 'r' 'raise'			'_ raised to _' 'num num' 10 2)
	  (array 'r' 'e'				'e')
	  (array 'r' 'ln'				'ln _' 'num' 2.718282)
	  (array 'r' 'exp'				'exp _' 'num' 1)
	  (array 'r' 'toFloat'			'to float _' 'num' 10)
	  (array 'r' 'maxInt'			'maxInt')
	  (array 'r' 'minInt'			'minInt')
	  (array 'r' '&'				'_ & _' 'num num' 5 3)
	  (array 'r' '|'				'_ | _' 'num num' 5 3)
	  (array 'r' '^'				'_ ^ _' 'num num' 5 3)
	  (array 'r' '<<'				'_ << _' 'num num' 10 1)
	  (array 'r' '>>'				'_ >> _' 'num num' 10 1)
	  (array 'r' '>>>'				'_ >>> _' 'num num' -1 20)

	'Data'
	  (array 'r' 'list'				'list : _ : ...' 'auto auto auto auto auto auto auto auto auto auto' 1 2 3 4 5 6 7 8 9 10)
	  (array 'r' 'dictionary'		'dictionary')

	  (array 'r' 'count'			'count _' 'str')
	  (array 'r' 'isEmpty'			'is _ empty?' 'data')
	  (array 'r' 'contains'			'does _ contain _ ?' 'data auto')

	  (array 'r' 'first'			'first _' 'list')
	  (array 'r' 'last'				'last _' 'list')
	  (array 'r' 'at'				'_ at _' 'auto auto' nil 1)
	  (array ' ' 'atPut'			'set _ at _ to _' 'data auto auto')
	  (array 'r' 'atRandom'			'at random _' 'str' 'abcde')

	  (array ' ' 'add'				'to _ add _' 'data auto')
	  (array ' ' 'addFirst'			'to _ add _ at start' 'list auto')
	  (array ' ' 'addAll'			'to _ add all _' 'data data')
	  (array ' ' 'remove'			'from _ remove _' 'data auto')

	  (array 'r' 'sorted'			'sorted _' 'data')
	  (array 'r' 'shuffled'			'shuffled _ ' 'data')
	  (array 'r' 'reversed'			'reversed _ ' 'data')
	  (array 'r' 'flattened'		'flattened _ ' 'data')

	  (array 'r' 'join'				'join _ _ : _ : ...' 'auto auto auto auto auto auto auto auto auto auto')

	  (array 'r' 'copy'				'copy _ ' 'data')
	  (array 'r' 'copyFromTo'		'copy _ from _ : to _' 'list num num' nil 1 2)

// 	  (array 'r' 'withoutAll'		'copy _ without any of _' 'data data')
// 	  (array 'r' 'union'			'_ union _' 'data data')
// 	  (array 'r' 'intersection'		'_ intersection _' 'data data')

//	  (array ' ' 'addAt'			'_ at _ insert _' 'list num auto')
//	  (array ' ' 'removeAt'			'_ at _ remove' 'list num')

	  (array 'r' 'indexOf'			'in _ find _ : after _' 'list auto num' nil nil 0)
	  (array 'r' 'lastIndexOf'		'in _ find last _ : before _' 'list auto num' nil nil 100)

	  (array 'r' 'toList'			'to list _ ' 'data')

	'Words'
	  (array 'r' 'letters'			'letters _' 'str' 'Hello')
	  (array 'r' 'words'			'words _' 'str' 'The owl and the pussycat')
	  (array 'r' 'lines'			'lines _' 'str' 'Line 1
Line 2')
	  (array 'r' 'quoted'			'â _ â' 'str' '123')

	  (array 'r' 'join'				'join _ _ : _ : ...' 'str str str' 'Hello, ' 'World!')
	  (array 'r' 'joinStrings'		'join string list _ : separator _' 'list str' nil ' ')

	  (array 'r' 'count'			'count _' 'str' 'GP Rocks!')
	  (array 'r' 'substring'		'substring _ from _ : to _' 'str num num' 'smiles' 2 5)

	  (array 'r' 'space'			'space')
	  (array 'r' 'tab'				'tab')
	  (array 'r' 'newline'			'newline')
	  (array 'r' 'toString'			'to string _ ' 'auto')
	  (array 'r' 'toNumber'			'to number _' 'str' '123')

	  (array 'r' 'toUpperCase'		'to uppercase _' 'str' 'big')
	  (array 'r' 'toLowerCase'		'to lowercase _' 'str' 'SMALL')
	  (array 'r' 'codePoints'		'text to codes _' 'str' 'Cat')
	  (array 'r' 'stringFromCodePoints'	'codes to text _' 'list')

	  (array 'r' 'self_readFile'	'read file _ : binary _' 'str bool' 'fileName.txt' false)
	  (array ' ' 'self_writeFile'	'write file _ _' 'str str' 'fileName.txt' 'testing 1, 2, 3')

	  (array 'r' 'string'			'character _ : ...' 'num' 65)
	  (array 'r' 'canonicalizedWord' 'canonicalize _ ' 'str' 'Hello GP!')

	'Network'
	  (array 'r' 'getData'			'get cloud data user _ key _' 'str str' 'gp' 'test')
	  (array ' ' 'putData'			'put cloud data user _ key _ data _' 'str str str' 'gp' 'test' 'hello!')
	  (array 'r' 'httpGet'			'http host _ : path _ : port _' 'str str num' 'tinlizzie.org' '/' '80')
	  (array 'r' 'jsonStringify'	'json encode _' 'obj')
	  (array 'r' 'jsonParse'		'json decode _' 'str')

	'Table'
	  (array 'r' 'importTableFromFile'	'table from file _ : has headings _ : delimiter _' 'str bool str' 'fileName' true ',')
	  (array 'r' 'uniqueValuesForColumn' 'unique values of _ in column _' 'table auto.columnMenu')
	  (array 'r' 'summarizeColumn'		'summarize _ column _' 'table auto.columnMenu' 'C1')
	  (array 'r' 'filtered'				'filtered _ where _ _ _ : or _ _ _' 'table auto.columnMenu str.comparisonOpMenu auto' nil 'C1' '<' 30)
	  (array 'r' 'sorted'				'sorted _ by column _ : ascending _' 'table auto.columnMenu bool' nil 'C1' true)
	  (array ' ' 'filterInPlace'		'filter _ where _ _ _ : or _ _ _' 'table auto.columnMenu str.comparisonOpMenu auto' nil 'C1' '<' 30)
	  (array ' ' 'sortInPlace'			'sort _ by column _ : ascending _' 'table auto.columnMenu bool' nil 'C1' true)
	  (array ' ' 'viewTable'			'view _ : title _ ' 'table str' nil 'Table')
	  (array 'r' 'count'				'row count _' 'table')
	  (array 'r' 'columnCount'			'column count _' 'table')
	  (array 'r' 'columnNames'			'column names _' 'table')
	  (array 'r' 'firstRowWhere'		'find row of _ where _ is _ : and _ is _ : ...' 'table auto.columnMenu auto auto.columnMenu auto' nil 'C1' 'USA' 'C2' 10)
	  (array 'r' 'table'				'new table with columns : _ : ...' 'str str str str str str' 'C1' 'C2' 'C3' 'C4' 'C5')
	  (array ' ' 'addRow'				'table _ add row _' 'table data')
	  (array ' ' 'renameColumn'			'table _ rename column _ to _' 'table auto.columnMenu str' nil 'C1')
	  (array ' ' 'insertColumnAfter'	'table _ insert column after _ : named _' 'table auto.columnMenu str' nil 'C1')
	  (array ' ' 'removeColumn'			'table _ remove column _' 'table auto.columnMenu' nil 'C1')
	  (array 'r' 'cellAt'				'cell _ row _ col _' 'table auto auto.columnMenu')
	  (array ' ' 'cellAtPut'			'set cell _ row _ col _ to _' 'table auto auto.columnMenu auto')
	  (array ' ' 'exportCSVToFile'		'save _ to file _ : delimiter _' 'table str str' nil nil ',')

	'Motion'
	  (array ' ' 'self_moveInDirection'	'move _ : direction _' 'num num.directionsMenu' 10 0)
	  (array ' ' 'self_changeRotation'	'turn by _' 'num' 15)
	  (array ' ' 'self_setRotation'		'set direction to _' 'num.directionsMenu' 0)
	  (array 'r' 'self_getRotation'		'direction')
	  (array ' ' 'self_setPosition'		'go to x _ y _' 'num num' 0 0)
	  (array ' ' 'self_setX'			'set x position _' 'num' 0)
	  (array ' ' 'self_setY'			'set y position _' 'num' 0)
	  (array 'r' 'self_getX'			'x position')
	  (array 'r' 'self_getY'			'y position')
	  (array ' ' 'self_moveBy'			'move by x _ y _' 'num num' 10 10)
	  (array ' ' 'self_keepInOwner'		'keep on screen')
	  (array ' ' 'self_bounceOffEdge' 'if on edge, bounce')
	  (array ' ' 'self_setDraggable'	'set grabbable _' 'bool' false)
	  (array ' ' 'self_grab'			'grab : _' 'obj')

	'Structure'
	  (array ' ' 'self_instantiate'		'add an instance of _' 'str.classNameMenu auto' 'MyClass' 0)
	  (array 'r' 'self_instantiate'		'new instance of _' 'str.classNameMenu auto' 'MyClass' 0)
	  (array ' ' 'self_delete'			'delete : _' 'obj')
	  (array 'r' 'self_owner'			'owner : of _' 'obj')
	  (array 'r' 'self_stage'			'stage')
	  (array 'r' 'self_parts'			'parts : of _' 'obj')
	  (array ' ' 'self_addPart'			'add part _ : to _' 'obj obj')
	  (array ' ' 'self_placePart'		'place part _ left inset _ top inset _' 'obj num num' nil 10 10)

	'Looks'
	  (array ' ' 'self_setCostume'		'set costume to _' 'menu.imageMenu' 'GP')
	  (array ' ' 'self_setTextCostume'	'set text costume _ : color _ : fontName _ fontSize _' 'auto color str num' 'Hello!' nil 'Arial Bold Italic' 120)
	  (array ' ' 'self_show'			'show')
	  (array ' ' 'self_hide'			'hide')
	  (array ' ' 'self_say'				'say _' 'str' 'Hello!')
	  (array ' ' 'self_sayNothing'		'say nothing')
	  (array ' ' 'self_setScale'		'set scale to _' 'num' 1)
	  (array ' ' 'self_changeScale'		'change scale by _' 'num' 0.5)
	  (array 'r' 'self_getScale'		'scale')
	  (array ' ' 'self_comeToFront'		'come to front')
	  (array ' ' 'self_goBackBy'		'go back by _' 'num' 1)
	  (array ' ' 'self_setTransparency'	'set transparency _' 'num' 50)
	  (array 'r' 'self_getWidth'		'width : of _' 'menu.imageMenu' 'GP')
	  (array 'r' 'self_getHeight'		'height : of _' 'menu.imageMenu' 'GP')
	  (array ' ' 'self_setStageColor'	'set background color _ : image _' 'color menu.imageMenu' nil 'GP')
	  (array 'r' 'self_costume'			'costume : _' 'menu.imageMenu' 'GP')
	  (array ' ' 'self_snapshotCostume'	'snapshot costume : as _' 'str' 'snapshot')
	  (array ' ' 'self_snapshotStage'	'snapshot stage : as _' 'str' 'snapshot')
	  (array ' ' 'self_setPinXY'		'set rotation point x _ y _' 'num num' 0 0)

	'Drawing'
	  (array ' ' 'self_createCostume'	'set width _ height _ : fill _ ' 'num num color' 100 100)
	  (array ' ' 'self_fillWithColor'	'fill _' 'color')
	  (array ' ' 'self_fillRect'		'fill rectangle x _ y _ w _ h _ _ : roundness _' 'num num num num color num' 10 10 50 50 nil 8)
	  (array ' ' 'self_fillCircle'		'fill circle center x _ y _ radius _ _ : border _ _' 'num num num color num color' 50 50 30 nil 4)
	  (array ' ' 'self_drawLine'		'draw line from _ _ to _ _ _ : width _' 'num num num num color num' 0 0 100 150 nil 3)
	  (array ' ' 'self_drawBitmap'		'draw image _ : x _ y _ : scale _ : alpha _' 'menu.imageMenu num num num num' 'GP' 0 0 1 255)
	  (array 'r' 'randomColor'			'random color')
	  (array 'r' 'transparent'			'transparent')
	  (array 'r' 'self_getWidth'		'width : of _' 'menu.imageMenu' 'GP')
	  (array 'r' 'self_getHeight'		'height : of _' 'menu.imageMenu' 'GP')
	  (array ' ' 'self_setFont'			'set font name _ : size _' 'str num' 'Arial' 24)
	  (array 'r' 'fontHeight'			'font height')
	  (array 'r' 'stringWidth'			'string width _' 'str' 'Hello!')
	  (array ' ' 'self_drawText'		'draw text _ x _ y _ _' 'str num num color' 'Hello!' 10 10)
	  (array ' ' 'self_floodFill'		'paint bucket fill x _ y _ _ : threshold _ ' 'num num color num' 50 50 nil 0)

	'Drawing - Paths'
	  (array ' ' 'self_beginPath'		'begin path x _ y _' 'num num' 10 10)
	  (array ' ' 'self_setPathDirection' 'set path direction _ degrees' 'num' 0)
	  (array ' ' 'self_extendPath'		'extend path by _ : curvature _' 'num num' 100 0)
	  (array ' ' 'self_turnPath'		'turn path by _ degrees : radius _' 'num num' 90 0)
	  (array ' ' 'self_addLineToPath'	'to path add line to x _ y _' 'num num' 50 50)
	  (array ' ' 'self_addCurveToPath'	'to path add curve to x _ y _ cx _ cy _' 'num num num num' 50 50 25 0)
	  (array ' ' 'self_strokePath'		'stroke path _ width _ : joint style _ cap style _' 'color num num num' nil 1 0 0)
	  (array ' ' 'self_fillPath'		'fill path _' 'color')

	'Color'
	  (array 'r' 'colorFromSwatch'		'color _' 'color')
	  (array 'r' 'color'				'color r _ g _ b _ : alpha _' 'num num num num' 200 200 200 255)
	  (array 'r' 'gray'					'gray _ : alpha _' 'num num' 200 255)
	  (array 'r' 'randomColor'			'random color')
	  (array 'r' 'transparent'			'transparent')
	  (array 'r' 'red'					'red of _ ' 'color')
	  (array 'r' 'green'				'green of _ ' 'color')
	  (array 'r' 'blue'					'blue of _ ' 'color')
	  (array 'r' 'alpha'				'alpha of _ ' 'color')
	  (array 'r' 'hue'					'hue of _ ' 'color')
	  (array 'r' 'saturation'			'saturation of _ ' 'color')
	  (array 'r' 'brightness'			'brightness of _ ' 'color')
	  (array 'r' 'colorHSV'				'color h _ s _ b _ : alpha _' 'num num num num' 0 1 1 255)

	'Pixels'
	  (array ' ' 'self_createCostume'	'set width _ height _ : fill _ ' 'num num color' 100 100)
	  (array ' ' 'self_copycostume'	'copy costume from _' 'menu.imageMenu' 'GP')
	  (array 'r' 'self_getPixels'	'pixels : from _' 'menu.imageMenu' 'GP')
	  (array 'r' 'self_getPixelXY'	'pixel at x _ y _ : from _ ' 'num num menu.imageMenu' 1 1 'GP')
	  (array 'r' 'getRed'			'red of _' 'pixel' nil)
	  (array 'r' 'getGreen'			'green of _' 'pixel' nil)
	  (array 'r' 'getBlue'			'blue of _' 'pixel' nil)
	  (array ' ' 'setRed'			'set red of _ to _' 'pixel num' nil 255)
	  (array ' ' 'setGreen'			'set green of _ to _' 'pixel num' nil 255)
	  (array ' ' 'setBlue'			'set blue of _ to _' 'pixel num' nil 255)
	  (array ' ' 'setGray'			'set gray of _ to _' 'pixel num' nil 255)
	  (array 'r' 'getX'				'x position of _' 'pixel' nil)
	  (array 'r' 'getY'				'y position of _' 'pixel' nil)
	  (array 'r' 'getColor'			'color of _' 'pixel' nil)
	  (array ' ' 'setColor'			'set color of _ to _' 'pixel color' nil)
	  (array 'r' 'randomColor'		'random color')
	  (array 'r' 'transparent'		'transparent')
	  (array 'r' 'self_getWidth'	'width : of _' 'menu.imageMenu' 'GP')
	  (array 'r' 'self_getHeight'	'height : of _' 'menu.imageMenu' 'GP')
	  (array 'r' 'self_getPixel'	'pixel color at x _ y _ : in _ ' 'num num image' 1 1)
	  (array ' ' 'self_setPixel'	'set pixel color at x _ y _ to _ : in _' 'num num color image' 1 1)

	'Sensing'
	  (array 'r' 'self_mouseX'				'mouse x')
	  (array 'r' 'self_mouseY'				'mouse y')
	  (array 'r' 'handIsDown'				'mouse is down')
	  (array 'r' 'self_directionToMouse'	'direction to mouse')
	  (array 'r' 'self_distanceToMouse'		'distance to mouse')
	  (array 'r' 'self_localMouseX'			'local mouse x')
	  (array 'r' 'self_localMouseY'			'local mouse y')
	  (array 'r' 'keyIsDown'				'key is down _' 'menu.keyDownMenu' 'right arrow')
	  (array 'r' 'stageWidth'				'stage width')
	  (array 'r' 'stageHeight'				'stage height')
	  (array 'r' 'self_directionToSprite'	'direction to _' 'menu.classNameMenu' 'MyClass')
	  (array 'r' 'self_distanceToSprite'	'distance to _' 'menu.classNameMenu' 'MyClass')
	  (array 'r' 'msecsSinceStart'			'timer')
	  (array 'r' 'localDateAndTime'			'date and time')
	  (array 'r' 'self_touching'			'touching _ ?' 'str.touchingMenu' 'edge')
	  (array 'r' 'self_neighbors'			'neighbors : within _ : class _' 'num str.classNameMenu' 0)
	  (array 'r' 'screenColorAt'			'screen color at x _ y _' 'num num' 0 0)
	  (array 'r' 'askUser'					'ask _ : initial answer _' 'str str' 'What is your favorite color?' '')
	  (array 'r' 'selectFromMenu'			'menu selection from _' 'list')
	  (array 'r' 'self_getProperty'			'get _ : of _' 'str.propertyMenu obj' 'n')

	'Pen'
	  (array ' ' 'self_penDown'			'pen down')
	  (array ' ' 'self_penUp'			'pen up')
	  (array ' ' 'self_setPenColor'		'set pen color _' 'color')
	  (array ' ' 'self_setPenSize'		'set pen width _' 'num' 3)
	  (array ' ' 'self_stampCostume'	'stamp costume : transparency _' 'num' 50)
	  (array ' ' 'self_penFillArea'		'pen fill area at x _ y _ : with _' 'num num color' 0 0)
	  (array ' ' 'self_clear'			'clear stamps and pen trails')

	'Sound'
	  (array ' ' 'playSound'			'play sound _' 'menu.soundMenu' 'pop')
	  (array ' ' 'playNote'				'play note _ : seconds _ : instrument _' 'auto num menu.instrumentMenu' 'c' 1 'piano')
	  (array ' ' 'playABC'				'play tune _ : on _ : speed _ : transpose _' 'str menu.instrumentMenu num num' 'ceg [ceg]2' 'piano' 120 5)
	  (array ' ' 'stopAllSounds'		'stop all sounds')
	  (array 'r' 'samplesForSoundNamed'	'samples for _' 'auto.soundMenu' 'pop')
	  (array ' ' 'playSoundSamples'		'play samples _ : rate _' 'array num' nil 100)
	  (array 'r' 'soundInput'			'sound input')
	  (array 'r' 'fftOfSamples'			'frequencies _ : use window _' 'data bool')

	'Music'
	  (array 'r' 'playerForMIDIFile'	'player for MIDI file _' 'str' 'BachPrelude')
	  (array ' ' 'playScore'			'start player _' 'player')
	  (array 'r' 'scoreTime'			'score time player _' 'player')

	  (array 'r' 'trackCount'			'track count _' 'player')
	  (array 'r' 'instrumentNames'		'instrument names')
	  (array 'r' 'instrumentForTrack'	'instrument player _ track _' 'player num' nil 1)
	  (array ' ' 'setInstrumentForTrack' 'set instrument player _ track _ to _' 'player num menu.instrumentMenu' nil 1 'guitar')
	  (array 'r' 'isTrackMuted'			'is muted player _ track _' 'player num' nil 1)
	  (array ' ' 'setTrackMuted'		'set muted player _ track _ to _' 'player num bool' nil 1 true)
	  (array 'r' 'notesForTrack'		'notes of player _ track _' 'player num' nil 1)

	  (array 'r' 'newScoreNote'			'new note start _ key _ loudness _ duration _' 'num num num num' 0 60 80 300)
	  (array 'r' 'startTime'			'start of note _' 'note')
	  (array 'r' 'endTime'				'end of note _' 'note')
	  (array 'r' 'key'					'key of note _' 'note')
	  (array 'r' 'duration'				'duration of note _' 'note')
	  (array 'r' 'velocity'				'loudness of note _' 'note')

	'Serial Port'
	  (array 'r' 'listSerialPorts'		'list serial ports')
	  (array 'r' 'openSerialPort'		'open serial port _ baud rate _' 'str num' '' 115200)
	  (array 'r' 'isOpenSerialPort'		'is serial port _ open?' 'num' 1)
	  (array ' ' 'closeSerialPort'		'close serial port _' 'num' 1)
	  (array 'r' 'readSerialPort'		'read serial port _ : binary _' 'num bool' 1 true)
	  (array ' ' 'writeSerialPort'		'write serial port _ data _' 'num str' 1)

	'File Stream'
	  (array 'r' 'openFilestream'		'open file stream on file _' 'str')
	  (array 'r' 'filestreamReadByte'	'read byte from file stream _' 'filestream')
	  (array 'r' 'filestreamReadLine'	'read line from file stream _' 'filestream')
	  (array ' ' 'closeFilestream'		'close file stream _' 'filestream')

	'Vector Pen'
	  (array 'r' 'self_newVectorPen'	'new vector pen')
	  (array ' ' 'beginPath'			'begin path _ x _ y _' 'pen num num' nil 100 100)
	  (array ' ' 'setHeading'			'set _ direction _ degrees' 'pen num' nil 0)
	  (array ' ' 'goto'					'_ go to x _ y _' 'pen num num' nil 0 0)
	  (array ' ' 'forward'				'move _ by _ : curvature _' 'pen num num' nil 100 0)
	  (array ' ' 'turn'					'turn _ by _ degrees : radius _' 'pen num num' nil 90 0)
	  (array ' ' 'stroke'				'stroke _ _ : width _ : joint _ : cap _' 'pen color num num num' nil nil 1 0 0)
	  (array ' ' 'fill'					'fill _ _' 'pen color')

	'Debugging'
	  (array ' ' 'halt'					'halt : _' 'str')
	  (array ' ' 'error'				'error : _' 'str')
	  (array ' ' 'openExplorer'			'explore _ ' 'auto')
	  (array ' ' 'print'				'console print _ : _ : ...' 'auto auto auto auto auto auto auto auto auto auto' 'Testing 1, 2, 3')
	  (array ' ' 'showText'				'edit text _' 'str' 'Hello, GP!')
	  (array ' ' 'gc'					'collect garbage')
	  (array 'r' 'mem'					'memory usage')
	  (array 'r' 'allInstances'			'all instances of _' 'str' 'String')

	'Developer'
	  (array ' ' 'setBlockColors'		'set block colors _ _ _ _' 'color color color color')
	  (array ' ' 'setBlockTextColor'	'set block text color _' 'color')
	  (array ' ' 'resetBlockColors'		'reset block colors')

	'Generic'
	  (array ' ' 'initialize'			'initialize _' 'this')

	'Macintosh only'
	  (array ' ' 'speak'				'speak _ : voice _ : speed _' 'str menu.voiceNameMenu num' 'Hey, what''s up?' 'Alex' 150)
	  (array ' ' 'stopSpeaking'			'stop speaking')

	'Obsolete'
	  (array 'r' 'self_touchingMouse'	'touching mouse?')
	  (array ' ' 'self_setAlpha'		'set alpha _' 'num' 0.5)
  )
}

to authoringSpecs {
  // Return the global AuthoringSpecs instance.
  if (isNil (global 'authoringSpecs')) {
	setGlobal 'authoringSpecs' (initialize (new 'AuthoringSpecs'))
  }
  return (global 'authoringSpecs')
}
to td {
  b = (block 'command' (color 4 148 220) (newBlockDefinition 'frobnicate' 'Spam'))
  setGrabRule (morph b 'defer')
  h = (block 'hat' (color 230 168 34) 'define' b) // (blockPrototypeForFunction aFunction)
  addPart (global 'page') h
  go
}

to editDefinition aBlock {
  spec = (blockSpec aBlock)
  if (isNil spec) {return}
  func = (functionNamed (blockOp spec))
  argNames = (argNames func)
  b = (block (blockType (blockType spec)) (color 4 148 220) (newBlockDefinition nil nil spec argNames))
  setGrabRule (morph b 'defer')
  h = (block 'hat' (color 230 168 34) 'define' b) // (blockPrototypeForFunction aFunction)
  addPart (global 'page') h
}

// BYOB - support for custom blocks

defineClass BlockDefinition morph type op sections declarations drawer alignment repeater toggle isGeneric isRepeating isShort

to newBlockDefinition aBlockSpec argNames isGeneric {return (initialize (new 'BlockDefinition') aBlockSpec argNames isGeneric)}

method initialize BlockDefinition aBlockSpec argNames generic {
  if (isNil generic) {generic = false}
  op = (blockOp aBlockSpec)
  type = (blockType (blockType aBlockSpec))
  isGeneric = generic
  isShort = true
  morph = (newMorph this)
  alignment = (newAlignment 'column' 0)
  setVPadding alignment (global 'scale')
  setMorph alignment morph
  initializeRepeater this aBlockSpec
  initializeSections this aBlockSpec sec argNames
  if (hasTopLevelSpec (authoringSpecs) op) { // if op matches a top-level spec, don't allow spec changes
    hideDetails this
  } else {
    showDetails this
  }
  return this
}

to blockType blockSpecType {
  if (blockSpecType == 'r') {
    return 'reporter'
  } (blockSpecType == 'h') {
    return 'hat'
  }
  return 'command'
}

method op BlockDefinition {return op}

method initializeSections BlockDefinition aBlockSpec firstSection argNames {
  if (isNil aBlockSpec) {return}
  for i (count (specs aBlockSpec)) {
    if (and (notNil firstSection) (i == 1)) {
      initializeFromSpec firstSection aBlockSpec argNames i (not isGeneric)
    } else {
      sec = (newBlockSectionDefinition)
      if (i == 1) {
        if isGeneric {
          setMin sec 1
        } else {
          setMin sec 2
        }
      }
      initializeFromSpec sec aBlockSpec argNames i (not isGeneric)
      addPart morph (morph sec)
    }
  }
}

method initializeRepeater BlockDefinition aBlockSpec {
  if (isNil aBlockSpec) {
    isRepeating = false
  } else {
    isRepeating = (repeatLastSpec aBlockSpec)
  }
  drawer = (newBlockDrawer this nil 'vertical')
  repeater = (newAlignment 'centered-line' 0 'bounds')
  setMorph repeater (newMorph repeater)
  if isShort {
    hide (morph repeater)
  }
  setPadding repeater (5 * (global 'scale'))
  addPart (morph repeater) (morph drawer)

  scale = (global 'scale')
  labelColor = (global 'blockTextColor')
  if (isNil labelColor) { labelColor = (gray 255) }

  txt = (newText 'repeat last section:' 'Arial' (10 * scale) labelColor)
  addPart (morph repeater) (morph txt)

  corner = 5
  toggle = (toggleButton (action 'toggleRepeat' this) (action 'isRepeating' this) (scale * 20) (scale * 13) (scale * corner) (max 1 (scale / 2)) false false)
  addPart (morph repeater) (morph toggle)
}

method isRepeating BlockDefinition {return isRepeating}

method toggleRepeat BlockDefinition {
  isRepeating = (not isRepeating)
  raise morph 'updateBlockDefinition' this
}

method fixLayout BlockDefinition {
  addPart morph (morph repeater) // make sure repeater is the last part
  fixLayout drawer
  fixLayout repeater
  fixLayout alignment
  raise morph 'layoutChanged' this
}

method updateBlockDefinition BlockDefinition {
  raise morph 'updateBlockDefinition' this
}

// expanding and collapsing:

method canExpand BlockDefinition {
  return true

  // only allow expansion if the previous
  // section is no longer empty
  // unused for now

  last = (lastSection this)
  return (or
    (isNil last)
    ((count (parts last)) > 1)
  )
}

method lastSection BlockDefinition {
  if ((count (parts morph)) < 1) {return nil}
  return (at (parts morph) (- (count (parts morph)) 1))
}

method canCollapse BlockDefinition {
  return ((count (parts morph)) > 2)
}

method expand BlockDefinition {
  addPart morph (morph (newBlockSectionDefinition))
  raise morph 'updateBlockDefinition' this
}

method collapse BlockDefinition {
  destroy (at (parts morph) ((count (parts morph)) - 1))
  raise morph 'updateBlockDefinition' this
}

method clicked BlockDefinition {
  if (isNil (ownerThatIsA morph 'Block')) {return false}
  if isShort {
    showDetails this
  } else {
    hideDetails this
  }
  // typesMenu this
  return true
}

method rightClicked BlockDefinition aHand {
  if (isNil (ownerThatIsA morph 'Block')) {return false}
  contextMenu this
  return true
}

method typesMenu BlockDefinition {
  menu = (menu nil (action 'setType' this) true)
  for tp (array 'command' 'reporter') {
    addItem menu '' tp tp (fullCostume (morph (block tp (color 4 148 220) '                    ')))
  }
  popUp menu (global 'page') (left morph) (bottom morph)
}

method contextMenu BlockDefinition {
  menu = (menu nil this)
  if isShort {
    addItem menu 'show details' 'showDetails'
  } else {
    addItem menu 'hide details' 'hideDetails'
  }
  addLine menu
  for tp (array 'command' 'reporter') {
    addItem menu '' (action 'setType' this tp) tp (fullCostume (morph (block tp (color 4 148 220) '                    ')))
  }
  if (devMode) {
   addItem menu 'set method name' 'setMethodNameUI'
  }
  addLine menu
  addItem menu 'export as image' 'exportAsImage'
  addItem menu 'hide definition' 'hideDefinition'
  addLine menu
  addItem menu 'delete' 'deleteDefinition'
  popUp menu (global 'page') (left morph) (bottom morph)
}

method setType BlockDefinition aTypeString {
  type = aTypeString
  prot = (handler (ownerThatIsA morph 'Block'))
  setField prot 'type' aTypeString
  fixLayoutNow prot
  raise morph 'updateBlockDefinition' this
}

// showing and hiding details

method showDetails BlockDefinition {
  if (hasTopLevelSpec (authoringSpecs) op) { return }
  show (morph repeater)
  for each (parts morph) {
    if (isClass (handler each) 'BlockSectionDefinition') {
      showDetails (handler each)
    }
  }
  fixLayout this
  isShort = false
}

method hideDetails BlockDefinition {
  hide (morph repeater)
  for each (parts morph) {
    if (isClass (handler each) 'BlockSectionDefinition') {
      hideDetails (handler each)
    }
  }
  fixLayout this
  isShort = true
}

method deleteDefinition BlockDefinition {
  blockM = (ownerThatIsA morph 'Block')
  if (notNil blockM) { blockM = (owner blockM) } // get the prototype hat block
  if (and (notNil blockM) (isPrototypeHat (handler blockM))) {
	userDestroy blockM
  }
}

method setMethodNameUI BlockDefinition {
  result = (partThatIs morph 'Text')
  if (notNil result) {
    txt = (text (handler result))
  } else {
    txt = 'selector'
  }
  prompt (page morph) 'method name?' txt 'line' (action 'setMethodName' this)
}

method setMethodName BlockDefinition aName {
  scripter = (scripter (findProjectEditor))
  if (isNil scripter) {return}
  targetClass = (classOf (targetObj scripter))
  if (isNil targetClass) {return}
  oldOp = op

  meth = (methodNamed targetClass op)
  if (isNil meth) {return}
  removeMethodNamed targetClass oldOp
  args = (argNames meth)
  body = (cmdList meth)
  result = (addMethod targetClass aName args body)
  h = (handler (owner morph))
  if (and (isClass h 'Block') ((functionName (function h)) == oldOp)) {
    setField h 'function' result
  }
  op = aName
  renameScriptToAPublicName scripter oldOp aName
}

method exportAsImage BlockDefinition {
  blockM = (ownerThatIsA morph 'Block')
  if (notNil blockM) { blockM = (owner blockM) } // get the prototype hat block
  if (or (isNil blockM) (not (isPrototypeHat (handler blockM)))) { return }
  bnds = (fullBounds blockM)
  bm = (newBitmap (width bnds) (height bnds))
  draw blockM bm (- (left bnds)) (- (top bnds))
  pngData = (encodePNG bm)
  if ('Browser' == (platform)) {
	browserWriteFile pngData (join 'scriptImage' (msecsSinceStart) '.png') 'scriptImage'
  } else {
	fName = (uniqueNameNotIn (listFiles (gpFolder)) 'scriptImage' '.png')
	fName = (fileToWrite fName '.png')
	if ('' == fName) { return }
	if (not (endsWith fName '.png')) { fName = (join fName '.png') }
	writeFile fName pngData
  }
}

method hideDefinition BlockDefinition {
  // Remove this method/function definition from the scripting area.

  pe = (findProjectEditor)
  if (isNil pe) { return }
  scripter = (scripter pe)
  targetClass = (targetClass scripter)
  if (isNil targetClass) { return } // shouldn't happen

  saveScripts scripter
  newScripts = (list)
  for entry (scripts targetClass) {
	cmd = (at entry 3)
	if (isOneOf (primName cmd) 'to' 'method') {
	  if (op != (first (argList cmd))) {
		add newScripts entry
	  }
	} else {
	  add newScripts entry
	}
  }
  setScripts targetClass (toArray newScripts)
  restoreScripts scripter
}

// conversion to spec

method specArray BlockDefinition {
  spec = (list op (blockTypeSpec this) (specString this) (typeString this) (defaults this))
  return (toArray spec)
}

method blockTypeSpec BlockDefinition {
  if (type == 'command') {
    return ' '
  }
  return (at type 1)
}

method specString BlockDefinition {
  spec = ''
  delim = ''
  for each (parts morph) {
    part = (handler each)
    if (isClass part 'BlockSectionDefinition') {
      spec = (join spec delim (specString part))
      delim = ' : '
    }
  }
  if isRepeating {
    spec = (join spec ' : ...')
  }
  return spec
}

method typeString BlockDefinition {
  spec = ''
  delim = ''
  for each (parts morph) {
    part = (handler each)
    if (isClass part 'BlockSectionDefinition') {
      spec = (join spec delim (typeString part))
      delim = ' '
    }
  }
  return spec
}

method defaults BlockDefinition {
  spec = (list)
  for each (parts morph) {
    part = (handler each)
    if (isClass part 'BlockSectionDefinition') {
      addDefaultsTo part spec
    }
  }
  return (toArray spec)
}

method inputNames BlockDefinition {
  parms = (list)
  for each (parts morph) {
    part = (handler each)
    if (isClass part 'BlockSectionDefinition') {
      addInputNamesTo part parms
    }
  }
  return (toArray parms)
}

method newInputName BlockDefinition {
  // answer a default input name that isn't already taken
  already = (inputNames this)
  metasyntactic = (array 'foo' 'bar' 'baz' 'quux' 'garply' 'spam' 'frob' 'corge' 'grault' 'waldo' 'ham' 'eggs' 'plugh' 'fred' 'wibble' 'wobble' 'flob' 'inp' 'parm' 'blah' 'blubb')
  for each metasyntactic {
    if (not (contains already each)) {
      return each
    }
  }
  return (join 'input #' (toString (count already)))
}

defineClass BlockSectionDefinition morph drawer alignment minElements

to newBlockSectionDefinition minElements {return (initialize (new 'BlockSectionDefinition'))}

method initialize BlockSectionDefinition {
  minElements = 0
  morph = (newMorph this)
  drawer = (newBlockDrawer this)
  alignment = (newAlignment 'centered-line' 0 'bounds')
  setPadding alignment (5 * (global 'scale'))
  setMorph alignment morph
  fixLayout this
  return this
}

method setMin BlockSectionDefinition num {
  minElements = num
}

method initializeFromSpec BlockSectionDefinition blockSpec argNames index isMethod {
  max = (count (specs blockSpec))
  if (index <= max) {
    specString = (at (specs blockSpec) index)
  } else {
    specString = (at (specs blockSpec) max)
  }

  slotIndex = 1
  for i (index - 1) {
    if (i > max) {
      slotIndex += (countInputSlots blockSpec (at (specs blockSpec) max))
    } else {
      slotIndex += (countInputSlots blockSpec (at (specs blockSpec) i))
    }
  }

  for w (words specString) {
    if ('_' == w) {
      addInputSlot this blockSpec slotIndex argNames
      slotIndex += 1
    } else {
      addLabelText this w
    }
  }
  fixLayout drawer
  fixLayout this
}

method fixLayout BlockSectionDefinition {
  addPart morph (morph drawer) // make sure drawer is the last part
  fixLayout alignment
}

// expanding and collapsing:

method canExpand BlockSectionDefinition {return true}

method canCollapse BlockSectionDefinition {
  return ((count (parts morph)) > (minElements + 1))
}

method expand BlockSectionDefinition {
  lastIdx = ((count (parts morph)) - 1)
  if (lastIdx > 0) {
    last = (at (parts morph) lastIdx)
    if (isClass (handler last) 'Text') {
      addInput this
      return
    }
  }
  expansionMenu this
}

method collapse BlockSectionDefinition {
  destroy (at (parts morph) ((count (parts morph)) - 1))
  fixLayout drawer
  fixLayout this
  raise morph 'updateBlockDefinition' this
}

method expansionMenu BlockSectionDefinition {
  menu = (menu nil this)
  addItem menu 'label' 'addLabel'
  addItem menu 'input' 'addInput'
  popUp menu (global 'page') (left (morph drawer)) (bottom (morph drawer))
}

// showing and hiding details

method showDetails BlockSectionDefinition {
  show (morph drawer)
  fixLayout drawer
  for each (parts morph) {
	h = (handler each)
    if (isClass h 'Block') {
      for element (parts each) {
        if (isClass (handler element) 'InputDeclaration') {
          show element
        }
      }
      fixLayoutNow h
    } (isClass h 'Text') {
      setEditRule h 'line'
      setGrabRule each 'ignore'

    }
  }
  fixLayout this
}

method hideDetails BlockSectionDefinition {
  hide (morph drawer)
  fixLayout drawer
  for each (parts morph) {
	h = (handler each)
    if (isClass h 'Block') {
      for element (parts each) {
        if (isClass (handler element) 'InputDeclaration') {
          hide element
        }
      }
      fixLayoutNow h
    } (isClass h 'Text') {
      setEditRule h 'static'
      setGrabRule each 'defer'
    }
  }
  fixLayout this
}

// more

method addLabel BlockSectionDefinition {
  txt = (labelText this 'label')
  setEditRule txt 'line'
  addPart morph (morph txt)
  fixLayout drawer
  fixLayout this
  page = (page morph)
  if (notNil page) {
    stopEditingUnfocusedText (hand page)
    edit (keyboard page) txt 1
  }
  selectAll txt
  raise morph 'updateBlockDefinition' this
}

method addLabelText BlockSectionDefinition aString {
  // private
  txt = (labelText this aString)
  setEditRule txt 'line'
  addPart morph (morph txt)
}

method addInput BlockSectionDefinition {
  def = (ownerThatIsA morph 'BlockDefinition')
  if (isNil def) {
    name = 'input'
  } else {
    name = (newInputName (handler def))
  }
  inp = (toBlock (newReporter 'v' name))
  typ = (newInputDeclaration 'auto' '10')
  setGrabRule (morph inp) 'template'
  addPart (morph inp) (morph typ)
  add (last (getField inp 'labelParts')) typ
  addPart morph (morph inp)
  raise morph 'updateBlockDefinition' this
}

method textChanged BlockSectionDefinition {
  // called editing a text field is complete
  raise morph 'updateBlockDefinition' this
}

method textEdited BlockSectionDefinition {
  // called after every character
  fixLayout this
}

method addInputSlot BlockSectionDefinition blockSpec slotIndex argNames {
  // private
  info = (slotInfoForIndex blockSpec slotIndex)
  slotType = (at info 1)
  default = (at info 3) // hint
  menuSelector = (at info 4)

  if (contains (array 'num' 'str' 'auto' 'menu' 'var') slotType) {
    if (isNil default) {
      default = (at info 2)
    }
  } ('bool' == slotType) {
    default = (at info 2)
    if (isNil default) {default = true}
  } (contains (array 'color' cmd) slotType) {
    default = nil
  }

  if (or (isNil argNames) ((count argNames) < slotIndex)) {
    argName = 'args'
  } else {
    argName = (at argNames slotIndex)
  }

  inp = (toBlock (newReporter 'v' argName))
  typ = (newInputDeclaration slotType default)
  hide (morph typ)
  setGrabRule (morph inp) 'template'
  addPart (morph inp) (morph typ)
  add (last (getField inp 'labelParts')) typ
  fixLayoutNow inp
  addPart morph (morph inp)
  fixLayout this
}

method labelText BlockSectionDefinition aString {
  lbl = (labelText (new 'Block') aString)
  setGrabRule (morph lbl) 'ignore'
  return lbl
}

// spec conversion

method specString BlockSectionDefinition {
  spec = ''
  delim = ''
  for each (parts morph) {
    part = (handler each)
    if (isClass part 'Text') {
	  // remove colons from label (colons are reserved for marking optional parameters in spec)
	  label = (joinStrings (copyWithout (letters (text part)) ':'))
	  if (label != (text part)) { setText part label }
      spec = (join spec delim label)
      delim = ' '
    } (isClass part 'Block') { // input
      spec = (join spec delim '_')
      delim = ' '
    }
  }
  return spec
}

method typeString BlockSectionDefinition {
  spec = ''
  delim = ''
  for each (parts morph) {
    part = (handler each)
    if (isClass part 'Block') { // input
      typeInfo = (handler (last (parts each)))
      spec = (join spec delim (typeString typeInfo))
      delim = ' '
    }
  }
  return spec
}

method addDefaultsTo BlockSectionDefinition aList {
  for each (parts morph) {
    part = (handler each)
    if (isClass part 'Block') { // input
      typeInfo = (handler (last (parts each)))
      add aList (defaultValue typeInfo)
    }
  }
}

method addInputNamesTo BlockSectionDefinition aList {
  for each (parts morph) {
    part = (handler each)
    if (isClass part 'Block') { // input
      add aList (first (argList (expression part)))
    }
  }
}

defineClass InputDeclaration morph type typeString default trigger alignment

to newInputDeclaration type default {
  return (initialize (new 'InputDeclaration') type default)
}

method initialize InputDeclaration typeStr defaultValue {
  morph = (newMorph this)
  alignment = (newAlignment 'centered-line' 0 'bounds')
  setPadding alignment (2 * (global 'scale'))
  setMorph alignment morph

  type = (element this typeStr)
  typeString = typeStr
  setContents type defaultValue
  default = defaultValue
  addPart morph (morph type)

  trigger = (downArrowButton this (action 'typesMenu' this))
  addPart morph (morph trigger)

  fixLayout this
  return this
}

method downArrowButton InputDeclaration action {
  // draw down arrow
  w = (12 * (blockScale))
  h = (7 * (blockScale))
  inset = (2 * (blockScale))
  bm = (newBitmap (w + (2 * inset)) (h + (2 * inset)))
  fillArrow (newShapeMaker bm) (rect inset inset w h) 'down' (gray 0)

  // create and return button
  btn = (new 'Trigger' (newMorph) action)
  setTransparentTouch (morph btn) true
  setHandler (morph btn) btn
  replaceCostumes btn bm bm bm
  return btn
}

method setType InputDeclaration typeStr defaultValue {
  if (isNil defaultValue) {
    if (isOneOf typeStr 'auto' 'num') {
      defaultValue = 10
    } ('str' == typeStr) {
      defaultValue = 'text'
    } ('bool' == typeStr) {
      defaultValue = true
    }
  }
  removeAllParts morph
  type = (element this typeStr)
  typeString = typeStr
  default = defaultValue
  setContents type defaultValue
  addPart morph (morph type)

  trigger = (downArrowButton this (action 'typesMenu' this))
  addPart morph (morph trigger)

  fixLayout this
  raise morph 'layoutChanged'
  raise morph 'updateBlockDefinition' this
}

method setDefault InputDeclaration defaultValue {
  // the default value has been changed by the user

  default = defaultValue
  raise morph 'updateBlockDefinition' this
}

method typeString InputDeclaration {
  if (and ('any' == typeString) ('static' == (editRule (getField type 'text')))) {
    return default
  }
  return typeString
}

method defaultValue InputDeclaration {return default}

method fixLayout InputDeclaration {
  fixLayout alignment
}

method element InputDeclaration typeStr blockColor  {
  // adapted from BlockSpec >> inputSlot
  if (isNil typeStr) {typeStr = type}
  if (isNil blockColor) {blockColor = (blockColorForOp (authoringSpecs) 'if')}
  editRule = 'static'
  slotContent = typeStr
  if ('num' == typeStr) {
    editRule = 'numerical'
    slotContent = 42
  }
  if ('str' == typeStr) {
    editRule = 'editable'
    slotContent = 'text'
  }
  if ('auto' == typeStr) {
    editRule = 'auto'
    slotContent = 'auto'
  }
  if ('bool' == typeStr) {
    slotContent = true
    return (newBooleanSlot true)
  }
  if ('color' == typeStr) {
    return (newColorSlot)
  }
  if ('menu' == typeStr) {
    slotContent = 'menu'
  }
  if ('cmd' == typeStr) {
    return (newCommandSlot blockColor)
  }
  if ('var' == typeStr) {
    rep = (toBlock (newReporter 'v' 'v'))
    setGrabRule (morph rep) 'defer'
    return rep
  }
  return (newInputSlot slotContent editRule blockColor)
}

method typesMenu InputDeclaration {
  // slot types: 'auto' 'num' 'str' 'bool' 'color' 'cmd' 'var' 'menu'
  menu = (menu nil (action 'setType' this) true)
  addItem menu 'number/string' 'auto' 'editable number or string'
  addItem menu '' 'bool' 'boolean switch' (fullCostume (morph (element this 'bool')))
  addItem menu '' 'color' 'color patch' (fullCostume (morph (element this 'color')))
  if (devMode) {
    addLine menu
    addItem menu 'number only' 'num'
    addItem menu 'string only' 'str'
  }
  popUp menu (global 'page') (left morph) (bottom morph)
}
// BinaryData

// equality

method '==' BinaryData other {
  if (this === other) {
	return true
  } (not (isClass other 'BinaryData')) {
    return false
  } ((byteCount this) != (byteCount other)) {
    return false
  }
  for i (byteCount this) {
    if ((byteAt this i) != (byteAt other i)) {
      return false
    }
  }
  return true
}

// copying

method copyFromTo BinaryData startIndex endIndex {
  if (isNil startIndex) { startIndex = 1 }
  if (isNil endIndex) { endIndex = (byteCount this) }
  byteCount = ((endIndex - startIndex) + 1)
  if (byteCount <= 0) { return (newBinaryData 0) }
  result = (newBinaryData byteCount)
  replaceByteRange result 1 byteCount this startIndex
  return result
}

method join BinaryData other {
  // Return the concatenation of this BinaryData and the argument.

  result = (newBinaryData ((byteCount this) + (byteCount other)))
  replaceByteRange result 1 (byteCount this) this
  replaceByteRange result ((byteCount this) + 1) (byteCount result) other
  return result
}

// converting

method toArray BinaryData {
  result = (newArray (byteCount this))
  for i (byteCount this) { atPut result i (byteAt this i) }
  return result
}

method toBinaryData BinaryData {
  return this
}

method toString BinaryData {
  return (stringFromByteRange this 1 (byteCount this))
}

method printString BinaryData {
  return (join 'BinaryData' '(' (byteCount this) ' bytes)')
}

// zlib

method zlibEncode BinaryData {
  adler32 = (crc this true)
  compressed = (deflate this)
  result = (newBinaryData ((byteCount compressed) + 6))
  strm = (dataStream result true)
  putUInt8 strm 120
  putUInt8 strm 156 // indicates default compression
  nextPutAll strm compressed
  putUInt32 strm adler32
  return result
}

method zlibDecode BinaryData {
  strm = (dataStream this true)
  header1 = (nextUInt8 strm)
  ignore header1
  header2 = (nextUInt8 strm)
  if ((header2 & 32) > 0) {
	error 'zlib with a preset dictionary is not supported'
  }
  compressed = (nextData strm ((byteCount this) - 6))
  result = (inflate compressed)
  adler32 = (nextUInt32 strm)
  if (adler32 != (crc result true)) {
	error 'bad adler32 checksum in zlib data'
  }
  return result
}
// Block
// Handlers for the GP blocks GUI

defineClass Block morph blockSpec type expression labelParts corner rounding dent inset hatWidth border color expansionLevel function isAlternative layoutNeeded pathCache cacheW cacheH originalColor

to block type color opName {
  block = (new 'Block')
  scale = (blockScale block)

  if (isNil opName) {opName = 'foo'}
  if (isNil type) {type = 'command'} // type can be 'command', 'reporter' or 'hat'
  if (isNil color) {color = (gray 150)}
  labelParts = (list (list))
  for i ((argCount) - 2) {add (at labelParts 1) (arg (i + 2))}
  if ((count (at labelParts 1)) == 0)  {
    labelParts = (list (list (labelText block opName)))
    op = opName
  } else {
    op = (arg 3)
  }
  group = (at labelParts 1)
  for i (count group) {
    part = (at group i)
    if (isClass part 'String') {
      atPut group i (labelText block part)
    } (isClass part 'Command') {
      inp = (newCommandSlot color)
      atPut group i inp
    }
  }
  argValues = (list op)
  for each group {
    if (isAnyClass each 'InputSlot' 'BooleanSlot' 'ColorSlot' 'CommandSlot' 'MicroBitDisplaySlot') {add argValues (contents each)}
  }
  setField block 'type' type
  setField block 'labelParts' labelParts
  setField block 'color' color
  setField block 'corner' 3
  setField block 'rounding' 8
  setField block 'dent' 2
  setField block 'hatWidth' 80
  setField block 'inset' 4
  setField block 'border' 1
  setField block 'expansionLevel' 1
  setField block 'layoutNeeded' true
  morph = (newMorph block)
  if (type == 'command') {
    setField block 'expression' (callWith 'newCommand' (toArray argValues))
  } (type == 'hat') {
    setField block 'expression' (newCommand 'nop')
  } (type == 'reporter') {
    setField block 'expression' (callWith 'newReporter' (toArray argValues))
  }
  setMorph block morph
  setGrabRule morph 'handle'
  setTransparentTouch morph false
  for each group {addPart (morph block) (morph each)}
  layoutChanged block
  fixLayout block
  return block
}

to slot contents isID {
  if (isNil isID) {isID = false}
  if (isAnyClass contents 'Integer' 'Float') {
    inp = (newInputSlot contents 'numerical')
    setGrabRule (morph inp) 'ignore'
    return inp
  } (isClass contents 'String') {
    inp = (newInputSlot contents 'editable')
    setGrabRule (morph inp) 'ignore'
    return inp
  } (isClass contents 'Boolean') {
    inp = (newBooleanSlot contents)
    return inp
  } (isClass contents 'Color') {
    inp = (newColorSlot contents)
    return inp
  } else {
    inp = (newInputSlot contents 'static')
    setID inp isID
    setGrabRule (morph inp) 'defer'
    return inp
  }
}

to blockScale {
  if (isNil (global 'blockScale')) { setGlobal 'blockScale' 1.25 }
  return ((global 'blockScale') * (global 'scale'))
}

to blockExportScale {
  // This variable is controls the scale of exported script PNG files.

  if (isNil (global 'blockExportScale')) { setGlobal 'blockExportScale' 0.65 } // default
  return (global 'blockExportScale')
}

method fixLayoutNow Block {
  layoutNeeded = true
  fixLayout this
}

method fixLayout Block {
  if (isNil layoutNeeded) { layoutNeeded = true }
  if (not layoutNeeded) { return }
  scale = (blockScale)
  wasHighlighted = false

  if (and (isClass (handler (owner morph)) 'ScriptEditor') (notNil (getHighlight morph))) {
	removeHighlight morph
	wasHighlighted = true
  }

  // fix layout of parts
  for m (parts morph) {
	if (isClass (handler m) 'Block') { fixLayout (handler m) }
	if (isClass (handler m) 'CommandSlot') {
	  nestedBlock = (nested (handler m))
	  if (notNil nestedBlock) { fixLayout nestedBlock }
	  fixLayout (handler m)
	}
	if (isClass (handler m) 'InputDeclaration') {
	  fixLayout (handler m)
	}
  }

  space = 3
  vSpace = 3

  break = 450
  lineHeights = (list)
  lines = (list)
  lineArgCount = 0

  left = (left morph)
  h = 0
  w = 0

  if (type == 'hat') {
    indentation = (* scale (+ border space space))
  } (type == 'reporter') {
    indentation = (* scale rounding)
  } (type == 'command') {
    indentation = (* scale (+ border space space border))
  }

  // arrange label parts horizontally and break up into lines
  op = (primName expression)
  breakLineBeforeFirstArg = (isOneOf op '[display:mbDisplay]' 'setNeoPixelColors10')
  maxArgsPerLine = 6
  if ('setNeoPixelColors10' == op) { maxArgsPerLine = 5 }
  currentLine = (list)
  for group labelParts {
    for each group {
      if (isVisible (morph each)) {
        if (isClass each 'CommandSlot') {
          if (notEmpty currentLine) {
          	add lines currentLine
          	add lineHeights h
          }
          fastSetLeft (morph each) (+ left (* scale (+ border corner)))
          add lines (list each)
          add lineHeights (height (morph each))
          currentLine = (list)
          w = 0
          h = 0
        } else {
          isArgSlot = (not (isClass each 'Text'))
          x = (+ left indentation w)
          w += (width (fullBounds (morph each)))
          w += (space * scale)
          if (and breakLineBeforeFirstArg isArgSlot) {
			breakLineBeforeFirstArg = false // only do this once
 			lineArgCount = 10 // force a line break before first arg
		  }
		  if (and breakLineBeforeFirstArg (each == (first group))) {
			lineArgCount = 10 // force a line break after first item of block
		  }
		  if ('if' == op) { lineArgCount = 0 } // never break 'if' blocks
		  if (and
                (notEmpty currentLine)
                (or (w > (break * scale)) (and isArgSlot (lineArgCount >= maxArgsPerLine)))
            ) {
			if (notEmpty currentLine) {
			  add lines currentLine
			  add lineHeights h
			  currentLine = (list)
			}
            h = 0
            x = (+ left indentation)
            w = ((width (fullBounds (morph each))) + (space * scale))
            lineArgCount = 0
          }
          add currentLine each
          h = (max h (height (morph each)))
          fastSetLeft (morph each) x
		  if isArgSlot { lineArgCount += 1 }
        }
      }
    }
  }

  // add the block drawer, if any
  drawer = (drawer this)
  if (notNil drawer) {
    x = (+ left indentation w)
    w += (width (fullBounds (morph drawer)))
    w += (space * scale)
    if (and (w > (break * scale)) (notEmpty currentLine)) {
      if (notEmpty currentLine) {
		add lines currentLine
		add lineHeights h
		currentLine = (list)
	  }
      h = 0
      x = (+ left indentation)
      w = ((width (fullBounds (morph drawer))) + (space * scale))
    }
    add currentLine drawer
    h = (max h (height (morph drawer)))
    fastSetLeft (morph drawer) x
  }

  // add last line
  if (notEmpty currentLine) {
	add lines currentLine
	add lineHeights h
  }

  // determine blockWidth from line data
  blockWidth = 0
  for each lines {
    if (notEmpty each) {
      elem = (last each)
      if (not (isClass elem 'CommandSlot')) {
        blockWidth = (max blockWidth ((right (fullBounds (morph elem))) - left))
      }
    }
  }
  blockHeight = (callWith + (toArray lineHeights))
  blockHeight += (* (count lines) vSpace scale)

  // arrange label parts vertically
  tp = (+ (top morph) (* 2 scale border))
  if (type == 'hat') {
    tp += (hatHeight this)
  }
  line = 0
  for eachLine lines {
    line += 1
    bottom = (+ tp (at lineHeights line) (vSpace * scale))
    for each eachLine {
      fastSetYCenterWithin (morph each) tp bottom
    }
    tp = bottom
  }

  // add extra space below the bottom-most c-slot
  extraSpace = 0
  if (isClass (last (last labelParts)) 'CommandSlot') {
	// adjust space below last command slot
	if (isNil drawer) {
	  extraSpace = (scale * corner)
	} else {
	  // adjust layout of final block drawer in if-else block
	  blockHeight += (-6 * scale)
	  fastMoveBy (morph drawer) 0 (-5 * scale)
	}
  }

  // adjust block width (i.e. right margin)
  if (type == 'command') {
	blockWidth += (-3 * scale)
  } (type == 'hat') {
	blockWidth += (-2 * scale)
  } (type == 'reporter') {
	blockWidth += (-8 * scale)
  }

  if (type == 'command') {
    setWidth (bounds morph) (max (scale * 50) (+ blockWidth indentation (scale * corner)))
    setHeight (bounds morph) (+ blockHeight (* scale corner) (* scale border 4) extraSpace)
  } (type == 'hat') {
    setWidth (bounds morph) (max (scale * (+ hatWidth 20)) (+ blockWidth indentation (scale * corner)))
    setHeight (bounds morph) (+ blockHeight (* scale corner 2) (* scale border) (hatHeight this) extraSpace)
  } (type == 'reporter') {
    setWidth (bounds morph) (max (scale * 20) (+ blockWidth indentation (scale * rounding)))
    setHeight (bounds morph) (+ blockHeight (* scale border 4) extraSpace)
  }

  if ((localized 'RTL') == 'true') { fixLayoutRTL this }

  nb = (next this)
  if (notNil nb) {
    fastSetPosition (morph nb) (left morph) (- (+ (top morph) (height morph)) (scale * corner))
  }
  rerender morph
  if wasHighlighted { addHighlight morph }
  layoutNeeded = false
}

method fixLayoutRTL Block {
	block_width = (width morph)
	if (and (notNil expression) ('if' == (primName expression))) {
	  block_width += (15 * (blockScale))
	}
	block_left = (left (fullBounds morph))
	drawer = (drawer this)
	if (notNil drawer) {
		block_width = (block_width - (width (fullBounds (morph drawer))))
		block_width = (block_width - (3 * (blockScale)))
	}

	for group labelParts {
		for each group {
			if (isVisible (morph each)) {
				word_left = ((left (fullBounds (morph each))) - block_left)
				w = (width (fullBounds (morph each)))
				if (not (isClass each 'CommandSlot')) {
					setLeft (morph each) (block_left + ((block_width - word_left) - w))
				}
			}
		}
	}
}

method drawOn Block ctx {
	if (notNil (getField ctx 'surface')) {
		drawShape this (getShapeMaker ctx)
		return
	}

	if (or (isNil pathCache) (cacheW != (width morph)) (cacheH != (height morph))) {
		// update pathCache
		sm = (newShapeMakerForPathRecording)
		drawShape this sm
		pathCache = (recordedPaths sm)
		cacheW = (width morph)
		cacheH = (height morph)
	}
	drawCachedPaths ctx pathCache (left morph) (top morph)
}

method drawShape Block aShapeMaker {
	scale = (blockScale)
	if (isRecording aShapeMaker) {
		r = (rect 0 0 (width morph) (height morph))
	} else {
		r = (bounds morph)
	}
	if (type == 'command') {
		commandSlots = (commandSlots this)
		if (isEmpty commandSlots) {
			drawBlock aShapeMaker r color (scale * corner) (scale * dent) (scale * inset)
		} else {
			drawBlockWithCommandSlots aShapeMaker r commandSlots color (scale * corner) (scale * dent) (scale * inset)
		}
	} (type == 'reporter') {
		clr = color
		if (getAlternative this) { clr = (lighter color 17) }
		drawReporter aShapeMaker r clr (scale * rounding)
	} (type == 'hat') {
		drawHatBlock aShapeMaker r (scale * hatWidth) color (scale * corner) (scale * dent) (scale * inset)
	}
}

method commandSlots Block {
	result = (list)
	top = (top morph)
	for m (parts morph) {
		if (isClass (handler m) 'CommandSlot') { add result (list ((top m) - top) (height m)) }
	}
	return result
}

method hatHeight Block {
  scale = (blockScale)
  hw = (scale * hatWidth)
  ru = (hw / (sqrt 2))
  return (truncate (ru - (hw / 2)))
}

// accessing

method type Block {return type}
method corner Block {return corner}
method scale Block {return (blockScale)}
method blockSpec Block {return blockSpec}
method function Block {return function}
method isPrototype Block {return (notNil function)}

method bottomLine Block {
  scale = (blockScale)
  return ((bottom morph) - (scale * corner))
}

method blockDefinition Block {
  if (isNil function) {return nil}
  if ((count labelParts) < 1) {return nil}
  def = (first (first labelParts))
  if (not (isClass def 'BlockDefinition')) {return nil}
  return def
}

method editedDefinition Block {
  prot = (editedPrototype this)
  if (notNil prot) {
    return (blockDefinition prot)
  }
  return nil
}

method expression Block className {
  if (isPrototypeHat this) {
    prot = (editedPrototype this)
    parms = (toList (argNames (function prot)))
    body = (next this)
    if (notNil body) {
      body = (expression body)
    }
    if (and (notNil className) (isMethod (function prot))) {
      def = (list 'method' (functionName (function prot)) className)
      removeFirst parms
    } else {
      def = (list 'to' (functionName (function prot)))
    }
    addAll def parms
    add def body
    expr = (callWith 'newCommand' (toArray def))
    return expr
  }
  return expression
}

method isPrototypeHat Block {
  if (type != 'hat') {return false}
  inp = (inputs this)
  if ((count inp) < 1) {return false}
  prot = (first inp)
  if (not (isClass prot 'Block')) {return false}
  return (isPrototype prot)
}

method editedPrototype Block {
  if (type != 'hat') {return nil}
  inp = (inputs this)
  if ((count inp) < 1) {return nil}
  prot = (first inp)
  if (not (isClass prot 'Block')) {return nil}
  if (isPrototype prot) {return prot}
  return nil
}

method contents Block {
  // for compatibility with input slots and command slots
  // in case a 'var' type slot has been renamed by the user
  // we might want to refactor 'expression' to 'contents' at some point
  return expression
}

method inputIndex Block anInput {
  idx = 0
  items = (flattened labelParts)

  // special case for variable assignments
  opName = (primName expression)
  if (or (opName == '=') (opName == '+=')) {
    // transformed assignment blocks represent the variable name as Text,
    // not an InputSlot; in this case, increment the input slot index
    if (and ((count items) > 1) (isClass (at items 2) 'Text')) {idx += 1}
  }

  for each items {
    if (isAnyClass each 'InputSlot' 'BooleanSlot' 'ColorSlot' 'CommandSlot' 'Block' 'MicroBitDisplaySlot') {
      idx += 1
      if (each === anInput) {return idx}
    }
  }
  return nil
}

method inputs Block {
  // disregard variable accessing
  return (filter
    (function each {return (isAnyClass each 'InputSlot' 'BooleanSlot' 'ColorSlot' 'CommandSlot' 'Block' 'MicroBitDisplaySlot')})
    (flattened labelParts)
  )
}

// events

method justDropped Block hand {
  snap this (x hand) (y hand)
}

method snap Block x y {
  scale = (blockScale)
  if (isNil x) {
    fb = (fullBounds morph)
    x = (left fb)
    y = (top fb)
  }
  parent = (handler (owner morph))
  if (isClass parent 'ScriptEditor') {
    b = (targetFor parent this x y)
    if (and (isClass b 'Block') ((type b) != 'reporter')) { // command or hat type targets
      recordDrop parent this b (next b)
      setNext b this
    } (isClass b 'Array') {
      recordDrop parent this b
      b = (at b 1)
      bb = (bottomBlock this)
      setPosition morph (left (morph b)) (+ (scale * corner) ((top (morph b)) - (height (fullBounds (morph this)))))
      setNext bb b
    } (isClass b 'CommandSlot') {
      recordDrop parent this b (nested b)
      setNested b this
    } (notNil b) { // dropped reporter
      tb = (handler (owner (morph b)))
      if (isClass tb 'Block') {
        recordDrop parent this tb nil b
        replaceInput tb b this
      }
    } else { // no snap target, record drop on scripting area
      recordDrop parent this
      if ('reporter' == type) { fixBlockColor this }
    }
    tb = (topBlock this)
    removeStackPart (morph tb)
    removeHighlight (morph tb)
    if (isClass (handler (owner (morph parent))) 'ScrollFrame') {updateSliders (handler (owner (morph parent)))}
  }
}

method aboutToBeGrabbed Block {
  if (isNil (owner morph)) {return}
  tb = (topBlock this)
  se = (ownerThatIsA (morph tb) 'ScriptEditor')
  if (notNil se) {
    stopEditing (handler se)
  }
  removeSignalPart (morph tb)
  removeStackPart (morph tb)
  removeHighlight (morph tb)
  parent = (handler (owner morph))
  if (isClass parent 'Block') {
    if (type == 'reporter') {
      revertToDefaultInput parent this
    } else {
      setNext parent nil
    }
  } (isClass parent 'CommandSlot') {
    setNested parent nil
  }
}

method layoutChanged Block origin {
	changed morph
	layoutNeeded = true
	raise morph 'layoutChanged' origin
}

method inputChanged Block aSlotOrReporter {
  value = (contents aSlotOrReporter)
  if (and (isClass aSlotOrReporter 'Block') ('template' == (grabRule (morph aSlotOrReporter)))) {
    varExpr = (expression aSlotOrReporter)
    if (isOneOf (primName varExpr) 'v' 'my') {
      // this is a 'var' slot; use variable name as input
      value = (first (argList varExpr))
    }
  } else {
    // the user has changed the default value of a formal parameter declaration
    id = (ownerThatIsA (morph aSlotOrReporter) 'InputDeclaration')
    if (notNil id) {
      setDefault (handler id) value
      return
    }
  }
  setArg expression (inputIndex this aSlotOrReporter) value
  raise morph 'scriptChanged' this
}

method expressionChanged Block changedBlock {
  if (isPrototype this) {
    return
  } (or (type == 'reporter') ((type changedBlock) == 'reporter')) {
    idx = (inputIndex this changedBlock)
    if (notNil idx) {
      setArg expression idx (expression changedBlock)
      return
    }
  } (changedBlock == (next this)) {
    setField expression 'nextBlock' (expression changedBlock)
    return
  }
  raise morph 'expressionChanged' changedBlock
}

method clicked Block hand {
  tb = (topBlock this)
  kbd = (keyboard (page hand))
  if (shiftKeyDown kbd) {
    scripts = (ownerThatIsA (owner morph) 'ScriptEditor')
    if (notNil scripts) {
      edit (handler scripts) this
      return
    }
  } (and (devMode) (keyDown kbd 'space')) {
    turnIntoText (topBlock this) hand
    return true
  }

  if (and (contains (array 'template' 'defer') (grabRule morph)) (isRenamableVar this)) {
    userRenameVariable this
    return
  } (isPrototype this) {
    def = (blockDefinition this)
    if (notNil def) {
      return (clicked def hand)
    }
    return true
  } (isPrototypeHat this) {
    prot = (editedPrototype this)
    if (notNil prot) {
      return (clicked prot hand)
    }
  } (isClass (handler (owner morph)) 'BlockOp') {
    return
  }

  cmdList = (expression tb)
  // if this block is in a Scripter, run it in the context of the Scriptor's targetObj
  scripter = (ownerThatIsA morph 'Scripter')
  if (notNil scripter) { targetObj = (targetObj (handler scripter)) }

  if (isRunning (page hand) cmdList targetObj) {
    stopRunning (page hand) cmdList targetObj
  } else {
    launch (page hand) cmdList targetObj (action 'showResult' tb)
  }
  return true
}

method doubleClicked Block hand {
  if (isPrototype this) {
    def = (blockDefinition this)
    if (notNil def) {
      closeUnclickedMenu (page hand) this
      return (doubleClicked def hand)
    }
  } (isPrototypeHat this) {
    prot = (editedPrototype this)
    if (notNil prot) {
      return (doubleClicked prot hand)
    }
  }
  return false
}

method showResult Block result {
  if ((type this) == 'reporter') {
	if (isNil result) {result = 'result is missing'}
	showHint morph (printString result) 300
  } (notNil result) {
	showHint morph (printString result) 300
  }
}

method rightClicked Block aHand {
  se = (ownerThatIsA morph 'ScriptEditor')
  if (notNil se) {
    stopEditing (handler se)
  }
  if (isPrototype this) {
    def = (blockDefinition this)
    if (notNil def) {
      return (rightClicked def hand)
    }
  } (isPrototypeHat this) {
    return (rightClicked (editedPrototype this) aHand)
  }
  popUpAtHand (contextMenu this) (page aHand)
  return true
}

method okayToBeDestroyedByUser Block {
  if (isPrototypeHat this) {
	editor = (findProjectEditor)
	if (isNil editor) { return false }
    function = (function (first (inputs this)))
    if (confirm (global 'page') nil 'Are you sure you want to remove this block definition?') {
	  removedUserDefinedBlock (scripter editor) function
      return true
    }
    return false
  }
  return true
}

// stacking

method next Block {
  items = (count (flattened labelParts))
  offset = 1
  if (and (isVariadic this) (not (isPrototype this))) {offset = 2} // because there is also a drawer
  if (notNil (getHighlight morph)) { offset += 1 }
  if ((count (parts morph)) > (items + (offset - 1))) {
    nxt = (handler (at (parts morph) (+ offset items)))
    if (not (isClass nxt 'Block')) { return nil } // guard against return non-blocks
    return (handler (at (parts morph) (+ offset items)))}
  return nil
}

method previous Block {
  parent = (ownerThatIsA (owner morph) 'Block')
  if (notNil parent) {return (handler parent)}
  return nil
}

method setNext Block another {
  scale = (blockScale)
  removeHighlight morph
  if (notNil another) {removeHighlight (morph another)}
  n = (next this)
  if (notNil n) {remove (parts morph) (morph n)}
  if (isNil another) {
    setField expression 'nextBlock' nil
  } else {
    setPosition (morph another) (left morph) (- (+ (top morph) (height morph)) (scale * corner))
    addPart morph (morph another)
    setField expression 'nextBlock' (expression another)
    if (notNil n) {setNext (bottomBlock another) n}
  }
  if (isPrototypeHat this) {
    prot = (editedPrototype this)
    func = (function prot)
    cmd = nil
    if (isClass another 'Block') {cmd = (expression another)}
    setField func 'cmdList' cmd
    blockStackChanged this
  } else {
    raise morph 'scriptChanged' this
    raise morph 'blockStackChanged' this
  }
}

method blockStackChanged Block another {
  if (isPrototypeHat this) {
    raise morph 'functionBodyChanged' this
    def = (editedDefinition this)
    if (notNil def) {hideDetails def}
  } else {
    raise morph 'blockStackChanged' this
  }
}

method scriptChanged Block {
  if (isPrototypeHat this) {
    raise morph 'functionBodyChanged' this
    def = (editedDefinition this)
    if (notNil def) {hideDetails def}
  } else {
    raise morph 'scriptChanged' this
  }
}

method bottomBlock Block {
  n = (next this)
  if (isNil n) {return this}
  return (bottomBlock n)
}

method topBlock Block {
  if (isNil (owner morph)) { return this }
  t = (handler (owner morph))
  if (isAnyClass t 'Block' 'CommandSlot') {return (topBlock t)}
  return this
}

method stackList Block {
  stack = (list)
  current = this
  while (notNil current) {
    add stack current
    current = (next current)
  }
  return stack
}

method scriptEditor Block {
  se = (handler (owner (morph (topBlock this))))
  if (isClass se 'ScriptEditor') {return se}
  return nil
}

// nesting (inputs)

method replaceInput Block source target {
  if (notNil (owner (morph target))) {removePart (owner (morph target)) (morph target)}
  idx = (indexOf (parts morph) (morph source))
  if (isNil idx) {  // can happen when call has more parameters than prototype has slots
    print 'skipping extra input'
    return
  }
  replaceLabelPart this source target
  atPut (parts morph) idx (morph target)
  setOwner (morph target) morph
  setOwner (morph source) nil
  if (isClass source 'Block') {
    editor = (scriptEditor this)
    addPart (morph editor) (morph source)
    moveBy (morph source) 20 20
  }
  if (isAnyClass target 'InputSlot' 'BooleanSlot' 'ColorSlot') {
    setArg expression (inputIndex this target) (contents target)
  } (isClass target 'Block') {
    setArg expression (inputIndex this target) (expression target)
  }
  layoutChanged this
  if (isClass target 'Block') { fixBlockColor target }
  raise morph 'scriptChanged' this
}

method replaceLabelPart Block source target {
  // private - helper for replaceInput
  for group labelParts {
    for i (count group) {
      if ((at group i) === source) {
        atPut group i target
        return
      }
    }
  }
  error 'label part not found'
}

method revertToDefaultInput Block aReporter {
  oldX = (left (morph aReporter))
  oldY = (top (morph aReporter))
  if (isNil blockSpec) {
    replaceInput this aReporter (slot 10)
  } else {
    replaceInput this aReporter (inputSlot blockSpec (inputIndex this aReporter) color)  }
  setPosition (morph aReporter) oldX oldY
}

// context menu

method contextMenu Block {
  if (isPrototype this) {return nil}
  menu = (menu nil this)
  isInPalette = ('template' == (grabRule morph))
  addItem menu 'explore result' 'explore'
  if (canShowMonitor this) {
    addItem menu 'monitor' 'addMonitor'
  }
  addLine menu
  if (isVariadic this) {
    if (canExpand this) {addItem menu 'expand' 'expand'}
    if (canCollapse this) {addItem menu 'collapse' 'collapse'}
    addLine menu
  }
  if (and isInPalette (isRenamableVar this)) {
    addItem menu 'rename...' 'userRenameVariable'
    addLine menu
  }
  addItem menu 'duplicate' 'grabDuplicate' 'just this one block'
  if (and ('reporter' != type) (notNil (next this))) {
    addItem menu '...all' 'grabDuplicateAll' 'duplicate including all attached blocks'
  }
  addItem menu 'copy to clipboard' 'copyToClipboard'
  addItem menu 'export as image' 'exportAsImage'
  addLine menu
  addItem menu 'show definition...' 'showDefinition'
  addLine menu
  if isInPalette {
	proj = (project (findProjectEditor))
	if (isUserDefinedBlock proj this) {
	  addLine menu
	  if (showingAnExtensionCategory proj this) {
		addItem menu 'remove from palette' (action 'removeFromCurrentCategory' proj this)
	  } else {
		addItem menu 'export to palette...' (action 'exportToExtensionCategory' proj this)
	  }
	}
  }
  if (devMode) {
    addLine menu
    addItem menu 'implementations...' 'browseImplementors'
    addItem menu 'text code...' 'editAsText'
  }
  if (not isInPalette) {
    addLine menu
    addItem menu 'delete' 'delete'
  }
  return menu
}

method grabDuplicate Block {
  dup = (duplicate this)
  if (notNil (next dup)) {setNext dup nil}
  grabTopLeft (morph dup)
}

method grabDuplicateAll Block {
  grabTopLeft (morph (duplicate this))
}

method duplicate Block {
  def = (blockDefinition this)
  if (notNil def) {
    op = (op def)
    spec = (specForOp (authoringSpecs) op)
    if (isNil spec) {spec = (blockSpecFor function)}
    return (blockForSpec spec) spec
  }

  if (notNil blockSpec) {
    dup = (new 'Block')
    initializeForSpec dup blockSpec true
    initializeForNode dup (copy expression)
  } else {
    dup = (toBlock (copy expression))
  }
  fixLayout dup
  setPosition (morph dup) (left morph) (top morph)
  return dup
}

method copyToClipboard Block {
  setClipboard (scriptText this)
}

method scriptText Block useSemicolons {
  useSemicolons = (useSemicolons == true) // useSemicolons is an optional parameter
  pp = (new 'PrettyPrinter')
  if useSemicolons {
    useSemicolons pp
    result = (list)
  } else {
    result = (list 'GP Script' (newline))
  }
  add result (join 'script 10 10 ')
  if (isClass expression 'Reporter') {
	if (isOneOf (primName expression) 'v') {
      varName = (first (argList expression))
      if (varMustBeQuoted varName) {
        varName = (printString varName) // enclose varName in quotes
      }
	  add result (join '(v ' varName ')')
	} else {
	  add result (join '(' (prettyPrint pp expression) ')')
	}
    if (not useSemicolons) { add result (newline) }
  } else {
	add result '{'
    if (not useSemicolons) { add result (newline) }
    add result (prettyPrintList pp expression)
    add result '}'
    if (not useSemicolons) { add result (newline) }
  }
  if (not useSemicolons) { add result (newline) }
  return (joinStrings result)
}

method exportAsImage Block { exportAsImageScaled this }

method exportAsImageScaled Block result isError fName {
  // Save a PNG picture of the given script at the given scale.
  // If result is not nil, include a speech bubble showing the result.

  timer = (newTimer)

  // if block is a function definition hat use its prototype block
  if (isPrototypeHat this) {
	proto = (editedPrototype this)
	if (notNil proto) { this = proto }
  }

  // draw script and bubble at high resolution
  oldScale = (global 'scale')
  setGlobal 'scale' 2 // change global scale temporarily to ensure retina resolution

  // use given block scale
  oldBlockScale = (global 'blockScale')
  scale = (blockExportScale)
  setGlobal 'blockScale' scale

  if (notNil (function this)) {
	scaledScript = (scriptForFunction (function this))
  } else {
    scaledScript = (toBlock (expression this))
  }
  fixLayout scaledScript
  bnds = (fullBounds (morph scaledScript))
  scriptW = (width bnds)
  scriptH = (height bnds)
  if ('reporter' == type) {
    scriptH += (2 * (blockScale)) // padding to align reporter and command block bottoms in Wiki
  }

  // draw the result bubble, if any
  if (notNil result) {
	scaledBubble = (newBubble result 200 'right' isError)
	bubbleW = (width (fullBounds (morph scaledBubble)))
	bubbleH = (height (fullBounds (morph scaledBubble)))
	bubbleInsetX = (5 * scale)
	bubbleInsetY = (5 * scale)
	if ('hat' == type) { bubbleInsetY = ((half (height morph)) + (3 * scale)) }
  } else {
	bubbleW = 0
	bubbleH = 0
	bubbleInsetX = 0
	bubbleInsetY = 0
  }

  // combine the morph and result bubble, if any
  bm = (newBitmap (+ scriptW bubbleW (- bubbleInsetX)) (+ scriptH bubbleH (- bubbleInsetY)))
  ctx = (newGraphicContextOn bm)
  setOffset ctx 0 (bubbleH - bubbleInsetY)
  fullDrawOn (morph scaledScript) ctx
  if (notNil scaledBubble) {
	topMorphWidth = (width (morph scaledScript))
    adjustment = (round (6 * scale)) // needed because bubble bounds is slightly too large
	setOffset ctx ((topMorphWidth - bubbleInsetX) + adjustment) (- adjustment)
	fullDrawOn (morph scaledBubble) ctx
	if ('hat' == type) { bm = (cropTransparent bm) } // remove extra space
  }

  // revert to old scale
  setGlobal 'blockScale' oldBlockScale
  setGlobal 'scale' oldScale

  // save result as a PNG file
  pngData = (encodePNG bm nil (scriptText this))
  if ('Browser' == (platform)) {
    if ((msecs timer) > 4500) {
      // if it has been more than ~4.5 seconds the user must click to allow file save
      inform (global 'page') (localized 'PNG preparation complete.')
    }
	browserWriteFile pngData (join 'scriptImage' (msecsSinceStart) '.png') 'scriptImage'
  } else {
  	if (isNil fName) {
  	  fName = (fileToWrite (join 'scriptImage' (msecsSinceStart) '.png'))
  	}
    if ('' == fName) { return }
	writeFile fName pngData
  }
}

method delete Block {
  if ('reporter' != type) { // hat or command
    nxt = (next this)
    if (and (notNil nxt) (notNil (owner morph))) {
      prev = (ownerThatIsA (owner morph) 'Block')
      cslot = (ownerThatIsA (owner morph) 'CommandSlot')
      scripts = (ownerThatIsA (owner morph) 'ScriptEditor')
      if (and (notNil prev) (=== this (next (handler prev)))) {
        setNext this nil
        setNext (handler prev) nxt
      } (and (notNil cslot) (=== this (nested (handler cslot)))) {
        setNext this nil
        setNested (handler cslot) nxt
      } (notNil scripts) {
        addPart scripts (morph nxt)
      }
    }
  }
  aboutToBeGrabbed this
  removeFromOwner morph
}

method editAsText Block {
  openWorkspace (page morph) (toTextCode this)
}

method turnIntoText Block hand {
  scale = (blockScale)
  owner = (owner morph)
  if (or (isNil owner) (not (isClass (handler owner) 'ScriptEditor'))) {return}
  code = (toTextCode this)
  x = (left morph)
  y = (top morph)
  txt = (newText code 'Arial' ((global 'scale') * 12) (color))
  setEditRule txt 'code'
  setGrabRule (morph txt) 'ignore'
  addSchedule (global 'page') (newAnimation 1.0 0.7 200 (action 'setScaleAround' morph (left morph) (top morph)) (action 'swapTextForBlock' (handler owner) txt this hand) true)
}

method toTextCode Block {
  scripter = (ownerThatIsA morph 'Scripter')
  if (notNil scripter) {
    className = (className (classOf (getField (handler scripter) 'targetObj')))
  }
  pp = (new 'PrettyPrinter')
  code = ''
  nb = (expression this className)
  useBrackets = (and (isClass nb 'Command') (not (isControlStructure nb)))
  if useBrackets { code = (join '{' (newline)) }
  while (notNil nb) {
    code = (join code (prettyPrint pp nb) (newline))
    nb = (nextBlock nb)
  }
  if useBrackets {
  	code = (join code '}')
  } (type == 'reporter') {
	code = (substring code 1 ((count code) - 1)) // remove line break
	code = (join '(' code ')')
  }
  return code
}

method browseImplementors Block {
  name = (primName expression)
  implementors = (implementors name)
  menu = (menu (join 'implementations of' (newline) name) (action 'openClassBrowser' this) true) // reverse call
  for each implementors {
    addItem menu (join each '...') each
  }
  popUpAtHand menu (global 'page')
}

method openClassBrowser Block className {
  if ('<generic>' == className) {
	page = (global 'page')
	brs = (newClassBrowser)
	setPosition (morph brs) (x (hand page)) (y (hand page))
	addPart page brs
    browse brs (globalBlocksName brs) (functionNamed (primName expression) (topLevelModule))
    return
  }
  editor = (ownerThatIsA morph 'ProjectEditor')
  if (notNil editor) {
	cl = (classNamed (module (project (handler editor))) className)
  }
  if (isNil cl) { cl = (class className) }
  browseClass cl (primName expression)
}

method showDefinition Block {
  pe = (findProjectEditor)
  if (isNil pe) { return }
  scripter = (scripter pe)
  targetClass = (targetClass scripter)
  if (isNil targetClass) { return }
  calledFunction = (primName expression)

  if (not (isShowingDefinition this targetClass calledFunction)) {
	if (notNil (methodNamed targetClass calledFunction)) {
	  ref = (newCommand 'method' calledFunction (className targetClass))
	} else {
	  f = (functionNamed (module (project pe)) calledFunction)
	  if (isNil f) { return } // shouldn't happen
	  ref = (newCommand 'to' calledFunction)
	}

	// add the method/function definition to the scripts for targetClass
	entry = (array (rand 50 200) (rand 50 200) ref)
	setScripts targetClass (join (array entry) (scripts targetClass))
	restoreScripts scripter
  }
  scrollToDefinitionOf scripter calledFunction
}

method isShowingDefinition Block aClass calledFunction {
  if (isNil (scripts aClass)) { return false }
  for entry (scripts aClass) {
	cmd = (at entry 3) // third item of entry is command
	if (isOneOf (primName cmd) 'method' 'to') {
	  if (calledFunction == (first (argList cmd))) { return true }
	}
  }
  return false // not found
}

// monitors

method canShowMonitor Block {
  if (or ('reporter' != type) (isPrototype this)) { return false }
  op = (primName expression)
  if (and (isOneOf op 'v' 'my') (notNil (ownerThatIsA morph 'Scripter'))) {
	// can only show monitors on instance variables (not locals)
	varName = (first (argList expression))
	scripter = (ownerThatIsA morph 'Scripter')
	return (and (notNil scripter) (hasField (targetObj (handler scripter)) varName))
  }
  if (isOneOf op 'global' 'shared') { return true }
  return ((count (argList expression)) == 0)
}

method addMonitor Block {
  monitor = (makeMonitor this)
  if (isNil monitor) { return }
  step monitor
  setCenter (morph monitor) (handX) (handY)
  grab (hand (global 'page')) monitor
}

method makeMonitor Block {
  targetObj = nil
  scripter = (ownerThatIsA morph 'Scripter')
  if (isNil scripter) { scripter = (ownerThatIsA morph 'MicroBlocksScripter') }
  if (notNil scripter) { targetObj = (targetObj (handler scripter)) }
  op = (primName expression)
  monitorColor = (blockColorForOp (authoringSpecs) op)
  if (isOneOf op 'v' 'my') {
	varName = (at (argList expression) 1)
	if (and ('this' == varName) (notNil targetObj)) {
	  getter = (action 'id' targetObj)
	  return (newMonitor varName getter monitorColor)
	} (hasField targetObj varName) {
	  getter = (action 'getFieldOrNil' targetObj varName)
	  return (newMonitor (join 'my ' varName) getter monitorColor)
	}
  } ('shared' == op) {
	mod = nil
	if (notNil scripter) { mod = (targetModule (handler scripter)) }
	varName = (at (argList expression) 1)
	getter = (action 'shared' varName mod)
	return (newMonitor varName getter monitorColor)
  } ('global' == op) {
	varName = (at (argList expression) 1)
	getter = (action 'global' varName)
	return (newMonitor varName getter monitorColor)
  } (beginsWith op 'self_') {
	if (isNil targetObj) { return nil }
	getter = (action 'eval' op targetObj)
	label = (first (specs (blockSpec this)))
	return (newMonitor label getter monitorColor)
  } else {
	label = (first (specs (blockSpec this)))
	return (newMonitor label (action op) monitorColor)
  }
  return nil
}

method explore Block {
  page = (global 'page')
  targetObj = nil
  scripter = (ownerThatIsA morph 'Scripter')
  if (notNil scripter) { targetObj = (targetObj (handler scripter)) }

  op = (primName expression)
  if (isOneOf op 'v' 'my') {
	varName = (at (argList expression) 1)
	if (and ('this' == varName) (notNil targetObj)) {
	  obj = targetObj
	} (hasField targetObj varName) {
	  obj = (call 'getField' targetObj varName)
	}
	openExplorer obj
  } else {
	// evaluate as a task so errors give debugger
	cmd = (expression (topBlock this))
	launch page cmd targetObj (action 'openExplorer')
  }
}

// renaming variable getters

method isRenamableVar Block {
  return (and
    (notNil expression)
    ('reporter' == type)
    (isOneOf (primName expression) 'v' 'my')
    (or
      (== 'handle' (grabRule morph))
      (and
        (contains (array 'template' 'defer') (grabRule morph))
        (isAnyClass (handler (owner morph)) 'Block' 'BlockSectionDefinition' 'InputDeclaration')
      )
    )
  )
}

method isReceiverSlotTemplate Block {
  sec = (owner morph)
  if (isClass (handler sec) 'BlockSectionDefinition') {
    def = (owner sec)
    if (isClass (handler def) 'BlockDefinition') {
      if (1 == (indexOf (parts def) sec)) {
        func = (function (handler (owner def)))
        if (not (isMethod func)) {
          return false
        }
        return (2 == (indexOf (parts sec) morph))
      }
    }
  }
  return false
}

method userRenameVariable Block {
  if  (or (not (isRenamableVar this)) (isReceiverSlotTemplate this)) {return}
  freshPrompt (page morph) 'Variable Name?' (at (argList expression) 1) 'line' (action 'renameVariableTo' this)
}

method renameVariableTo Block varName {
  if (or (isNil varName) (== '' varName) (not (isRenamableVar this))) {return}
  oldName = (at (argList expression) 1)
  setArg expression 1 varName
  setText (at (at labelParts 1) 1) varName
  layoutChanged this

  if (notNil (ownerThatIsA morph 'BlockSectionDefinition')) {
    raise morph 'updateBlockDefinition'
    return
  }

  raise morph 'inputChanged' this

  // update the function
  if (notNil (owner morph)) {func = (function (handler (owner morph)))}
  if (isNil func) {return}
  idx = (indexOf (argNames func) oldName)
  atPut (argNames func) idx varName
}

// constructing blocks from commands and reporters

to toBlock commandOrReporter {
  block = (new 'Block')
  initialize block commandOrReporter
  layoutChanged block
  fixLayout block
  return block
}

method labelText Block aString {
  scale = (blockScale)
  fontName =  'Verdana Bold'
  fontSize = (11 * scale)
  if (isOneOf aString '=' '+' '/' 'Ã' 'â' 'â ') { // last three: unicode multiply, minus, not equals
  	fontSize = (13 * scale)
  }
  if ('Linux' == (platform)) {
	fontName = 'Sans Bold'
	fontSize = (round (0.85 * fontSize))
  }
  if ('Browser' == (platform)) {
	fontName = 'Arial Bold'
	fontSize = (fontSize + (2 * scale))
  }
  labelColor = (global 'blockTextColor')
  if (isNil labelColor) { labelColor = (gray 255) }
  if ('comment' == aString) { labelColor = (gray 80) }
  return (newText aString fontName fontSize labelColor)
}

method rawInitialize Block commandOrReporter {
  // disregard any block spec, e.g. if none is found

  scale = (blockScale)
  cslots = (list)
  expression = commandOrReporter
  op = (primName expression)
  type = 'command'
  if (isClass expression 'Reporter') { type = 'reporter' }
  setBlockColor this (primName expression)

  morph = (newMorph this)
  setGrabRule morph 'handle'
  setTransparentTouch morph false
  labelParts = (list (list (labelText this (primName expression))))
  group = (at labelParts 1)
  corner = 3
  rounding = 8
  dent = 2
  inset = 4
  hatWidth = 80
  border = 1
  expansionLevel = 1

  for each (argList expression) {
    if (isClass each 'Command') {
      element = (newCommandSlot color (toBlock each))
      add cslots element
    } (isClass each 'Reporter') {
      element = (toBlock each)
    } else {
      element = (slot each)
    }
    add group element
  }

  // special cases for variables and assignment
  if (isOneOf op 'v' 'my') {
    s = (at (argList expression) 1)
    if ('my' == op) { s = (join 'my ' s) }
    labelParts = (list (list (labelText this s)))
    group = (at labelParts 1)
  }
  if (isOneOf op '=' '+=') {
    varName = (at (argList expression) 1)
    if ('=' == op) {
      labelParts = (list (list (labelText this 'set') (labelText this varName) (labelText this 'to')))
    } else {
      labelParts = (list (list (labelText this 'increase') (labelText this varName) (labelText this 'by')))
    }
    group = (at labelParts 1)
    rhs = (at (argList expression) 2)
    if (isClass rhs 'Reporter') {
      add group (toBlock rhs)
    } else {
      add group (slot rhs)
    }
  }

  for p group { addPart morph (morph p) }
  if (and (type != 'reporter') (notNil (nextBlock expression))) {
    addPart morph (morph (toBlock (nextBlock expression)))
  }
}

method initializeForNode Block commandOrReporter {
  expandTo this commandOrReporter
  slots = (inputs this)
  idx = 0
  for each (argList commandOrReporter) {
    idx += 1
	if (idx <= (count slots)) {
	  slot = (at slots idx)
	} else {
	  slot = (newInputSlot each 'auto')
	}
    if (isClass each 'Command') {
      if (isClass slot 'CommandSlot') {
        setNested slot (toBlock each)
      } else {
        // perhaps we should somehow warn the user here
        replaceInput this slot (newCommandSlot color (toBlock each)) false
      }
    } (isClass each 'Reporter') {
      if (and ('colorSwatch' == (primName each)) (isClass slot 'ColorSlot')) {
        setContents slot (eval each)
      } else {
        replaceInput this slot (toBlock each) false
      }
    } else {
      if (isAnyClass slot 'InputSlot' 'BooleanSlot' 'ColorSlot' 'MicroBitDisplaySlot') {
        setContents slot each true
      } (and (isClass slot 'Block') (isRenamableVar slot)) {
        renameVariableTo slot each
      } (notNil each) {
        error 'cannot set contents of' slot
      }
    }
  }

  // special case for variables
  if (isOneOf (primName commandOrReporter) 'v' 'my') {
    s = (at (argList commandOrReporter) 1)
    if ('my' == op) { s = (join 'my ' s) }
    labelParts = (list (list (labelText this s)))
    removeAllParts morph
    addPart morph (morph (at (at labelParts 1) 1))
  }

  if (and (type != 'reporter') (notNil (nextBlock commandOrReporter))) {
    addPart morph (morph (toBlock (nextBlock commandOrReporter)))
  }
  expression = commandOrReporter
  layoutChanged this
}

method initialize Block commandOrReporter {
  op = (primName commandOrReporter)
  // special case for variables
  if (isOneOf (primName commandOrReporter) 'v' 'my') {
    rawInitialize this commandOrReporter
    s = (at (argList commandOrReporter) 1)
	if ('my' == op) { s = (join 'my ' s) }
    labelParts = (list (list (labelText this s)))
    removeAllParts morph
    addPart morph (morph (at (at labelParts 1) 1))
    expression = commandOrReporter
    layoutChanged this
    return
  }

  spec = (specForOp (authoringSpecs) op commandOrReporter)
  if (and (notNil spec) ((slotCount spec) < (count (argList commandOrReporter))) (not (repeatLastSpec spec))) {
    spec = nil // ignore bad spec: not enough input slots and not expandable
  }
  if (isNil spec) {
    rawInitialize this commandOrReporter
    layoutChanged this
    return
  }
  initializeForSpec this spec true true
  initializeForNode this commandOrReporter
}

to blockForFunction aFunction {
  spec = (specForOp (authoringSpecs) (primName aFunction))
  if (isNil spec) {
	cl = nil
	if ((classIndex aFunction) > 0) { cl = (class (classIndex aFunction)) }
	spec = (blockSpecFor aFunction)
  }
  return (blockForSpec spec)
}

to blockForSpec spec {
  block = (new 'Block')
  spec = (translateToCurrentLanguage (authoringSpecs) spec)
  initializeForSpec block spec
  return block
}

to scriptForFunction aFunction {
  if (isNil aFunction) { return nil }
  hatLabel = (localized 'define')
  if (isMethod aFunction) { hatLabel = 'method' }
  block = (block 'hat' (color 140 0 140) hatLabel (blockPrototypeForFunction aFunction))
  if (notNil (cmdList aFunction)) {
	setNext block (toBlock (cmdList aFunction))
  }
  return block
}

to blockPrototypeForFunction aFunction {
  spec = (specForOp (authoringSpecs) (primName aFunction))
  if (isNil spec) {
	spec = (blockSpecFor aFunction)
  }
  clr = (blockColorForOp (authoringSpecs) (primName aFunction))
  block = (block (blockType (blockType spec)) clr (newBlockDefinition spec (argNames aFunction) (not (isMethod aFunction))))
  setField block 'function' aFunction
  setGrabRule (morph block) 'template'
  return block
}

method initializeForSpec Block spec suppressExpansion {
  scale = (blockScale)

  blockSpec = spec
  type = 'command'
  if (isHat spec) { type = 'hat' }
  if (isReporter spec) { type = 'reporter' }
  setBlockColor this (blockOp blockSpec)

  morph = (newMorph this)
  setGrabRule morph 'handle'
  setTransparentTouch morph false

  corner = 3
  rounding = 8
  dent = 2
  inset = 4
  hatWidth = 80
  border = 1
  expansionLevel = 1

  // create the base label parts
  group = (labelGroup this 1)
  for p group {
    addPart morph (morph p)
  }
  labelParts = (list group)
  addAllLabelParts this

  // expand to the first input slot, if any
  if suppressExpansion {return}
  if (and (repeatLastSpec blockSpec) (== 0 (countInputSlots blockSpec (at (specs blockSpec) 1)))) {
    expand this
  }
}

method labelGroup Block index {
  max = (count (specs blockSpec))
  if (index <= max) {
    specString = (at (specs blockSpec) index)
  } else {
    specString = (at (specs blockSpec) max)
  }
  slotIndex = 1
  for i (index - 1) {
    if (i > max) {
      slotIndex += (countInputSlots blockSpec (at (specs blockSpec) max))
    } else {
      slotIndex += (countInputSlots blockSpec (at (specs blockSpec) i))
    }
  }
  if (isPrototype this) {argNames = (argNames function)}
  group = (list)
  for w (words specString) {
    if ('_' == w) {
      add group (inputSlot blockSpec slotIndex color (isPrototype this) argNames)
      slotIndex += 1
    } else {
      add group (labelText this w)
    }
  }
  if (isEmpty group) {return (list (labelText this ''))}
  return group
}

method setBlockColor Block op {
    color = (blockColorForOp (authoringSpecs) op)
}

method flash Block {
	oldColor = color
	color = (color 255 255 0)
	pathCache = nil
	changed morph
	doOneCycle (global 'page')
	waitMSecs 50
	color = oldColor
	pathCache = nil
	changed morph
	doOneCycle (global 'page')
	waitMSecs 80
}

// expanding and collapsing

method drawer Block {
  if (and (isVariadic this) (not (isPrototype this))) {
    items = (count (flattened labelParts))
    return (handler (at (parts morph) (+ 1 items)))
  }
  return nil
}

method isVariadic Block {
  return (and (notNil blockSpec) (or (repeatLastSpec blockSpec) (> (count (specs blockSpec)) 1)))
}

method canExpand Block {
  return (and (notNil blockSpec) (or (repeatLastSpec blockSpec) (> (count (specs blockSpec)) expansionLevel)))
}

method canCollapse Block {
  return (and (notNil blockSpec) (expansionLevel > 1))
}

method expand Block {
  nb = (next this)
  removeAllParts morph
  expansionLevel += 1
  add labelParts (labelGroup this expansionLevel)
  adjustIfElseBlocks this expression
  addAllLabelParts this
  setNext this nb
  if ('template' == (grabRule morph)) { comeToFront morph } // ensure collapse arrow not covered
}

method expandTo Block commandOrReporter {
  // helper method for initializeForNode
  // expands the blocks so it can accomodate at least the given
  // number of inputs
  numberOfInputs = (count (argList commandOrReporter))
  nb = (next this)
  removeAllParts morph
  while (and ((count (inputs this)) < numberOfInputs) (canExpand this)) {
    expansionLevel += 1
    add labelParts (labelGroup this expansionLevel)
  }
  adjustIfElseBlocks this commandOrReporter
  addAllLabelParts this
  setNext this nb
}

method collapse Block {
  nb = (next this)
  old = (at labelParts expansionLevel)
  removeAt labelParts expansionLevel
  removeAllParts morph
  expansionLevel += -1
  adjustIfElseBlocks this expression
  addAllLabelParts this
  setNext this nb

  // preserve old embedded blocks, if any
  editor = (scriptEditor this)
  if (isNil editor) {return}
  for slot old {
    keep = nil
    if (and (isClass slot 'Block') (!= 'template' (grabRule (morph slot)))) {
      keep = (morph slot)
    } (and (isClass slot 'CommandSlot') (notNil (nested slot))) {
      keep = (morph (nested slot))
    }
    if (notNil keep) {
      addPart (morph editor) keep
      moveBy keep 20 20
    }
  }
}

method ifElseParts Block boolSlot cmdSlot {
  // Helper method for adjustIfElseBlocks. Return a localized set of parts for
  // an ifElse section with the given boolean and command slots.
  // Assume this is an 'if' block.

  setField boolSlot 'displayAsElse' false // set Boolean slot to normal display mode
  result = (labelGroup this 2)
  for i (count result) {
    if (isClass (at result i) 'BooleanSlot') { atPut result i boolSlot }
    if (isClass (at result i) 'CommandSlot') { atPut result i cmdSlot }
  }
  return result
}


method adjustIfElseBlocks Block commandOrReporter {
  // Adjust the parts list of an if statement to show "else" if the final condition is
  // the constant true. Make all intermediate cases "else if <condition>".

  if ('if' != (primName commandOrReporter)) { return } // do nothing this is not an "if" block

  // convert final case to "else" if the condition is the constant true
  args = (argList commandOrReporter)
  isExpanding = ((count labelParts) > ((count args) / 2))
  isCollapsing = ((count labelParts) < ((count args) / 2))
  if isCollapsing { args = (copyFromTo args 1 ((count args) - 2)) } // dropping the last 2 args

  lastCondition = (at args ((count args) - 1))
  if (or isExpanding (and ((count args) > 2) (true == lastCondition))) {
    // final condition is of the form "else if true ..."
    // convert it to a Boolean slot that displays as "else" (localized)
    oldCmdSlot = (last (last labelParts))
    removeLast labelParts
    add labelParts (list (newBooleanSlot true true) oldCmdSlot)
  }

  if ((count labelParts) <= 2) { return } // no intermediate cases

  // convert intermediate cases to "else if <condition>"
  for i (range 2 ((count labelParts) - 1)) {
    parts = (at labelParts i)
    if (and ((count parts) == 2) (isClass (first parts) 'BooleanSlot') (isClass (last parts) 'CommandSlot')) {
      atPut labelParts i (ifElseParts this (first parts) (last parts))
    }
  }
}

method addAllLabelParts Block {
  allParts = (flattened labelParts)
  for p allParts {addPart morph (morph p)}
  if (and (isVariadic this) (not (isPrototype this))) {addPart morph (morph (newBlockDrawer this))}

  // create a new expression with the matching number of empty argument slots
  cmdAndArgs = (list (blockOp blockSpec))
  for p allParts {
    if (isAnyClass p 'InputSlot' 'BooleanSlot' 'ColorSlot' 'CommandSlot' 'Block' 'MicroBitDisplaySlot') {
      add cmdAndArgs nil
    }
  }

  cmdAndArgs = (toArray cmdAndArgs)
  if (isReporter blockSpec) {
    expression = (callWith 'newReporter' cmdAndArgs)
  } else {
    expression = (callWith 'newCommand' cmdAndArgs)
  }

  // update the expression's arguments' values with the actual input values
  // since these could have changed in the meantime (e.g. if the user typed
  // in something different)
  if (not (isPrototype this)) {
    for p allParts {
      if (isAnyClass p 'InputSlot' 'BooleanSlot' 'ColorSlot' 'CommandSlot' 'Block' 'MicroBitDisplaySlot') {
        inputChanged this p
      }
    }
  }
  layoutChanged this
  if (not (isPrototype this)) {
    raise morph 'expressionChanged' this
  }
}

// editing block prototypes (function definitions)

method updateBlockDefinition Block aBlockDefinition {
  if (isRenamableVar this) {
    raise morph 'updateBlockDefinition'
    return
  }

  if (isNil function) {return} // to do: raise an error

  // update the function
  setField function 'argNames' (inputNames aBlockDefinition)

  // update the block spec
  sp = (callWith 'blockSpecFromStrings' (specArray aBlockDefinition))
  recordBlockSpec (authoringSpecs) (primName function) sp

  // notify interested editors
  raise morph 'blockPrototypeChanged' this
}

method containsPrim Block aPrimName {
  for each (allMorphs morph) {
    hdl = (handler each)
    if (and (isClass hdl 'Block') (== aPrimName (primName (expression hdl)))) {
      return true
    }
  }
  return false
}

method setContents Block obj {nop} // only used for 'var' type input slots

// zebra-coloring for reporter blocks

method color Block {return color}

method getAlternative Block {
  if (isNil isAlternative) {isAlternative = false}
  return isAlternative
}

method fixBlockColor Block {
  if (and (type == 'reporter') (notNil (owner morph))) {
    parent = (handler (owner morph))
    oldAlternative = isAlternative
    if (and (isClass parent 'Block') ((color parent) == color)) {
      isAlternative = (not (getAlternative parent))
    } else {
      isAlternative = false
    }
    if (isAlternative != oldAlternative) {
	  pathCache = nil
      changed morph
      fixPartColors this
    }
  }
}

method fixPartColors Block {
  for m (parts morph) {
    if (isClass (handler m) 'Block') {
      fixBlockColor (handler m)
    }
  }
}

// keyboard accessibility hooks

method trigger Block {
  if (and ('template' == (grabRule morph)) (isRenamableVar this)) {
    userRenameVariable this
  }
}
defineClass BlockDrawer morph target orientation

to newBlockDrawer aBlock horizontalOrVertical {
  return (initialize (new 'BlockDrawer') aBlock horizontalOrVertical)
}

method initialize BlockDrawer aBlock horizontalOrVertical {
  morph = (newMorph this)
  target = aBlock
  orientation = horizontalOrVertical
  if (isNil orientation) { orientation = 'horizontal' }
  setTransparentTouch morph true // allow clicks anywhere in bounds rectangle
  fixLayout this
  return this
}

method fixLayout BlockDrawer {
  if (notNil target) {
    hasMore = (canExpand target)
    hasLess = (canCollapse target)
  } else {
    hasMore = true
    hasLess = true
  }
  size = (13 * (blockScale))
  unit = (half size)
  extra = 0
  if (orientation == 'horizontal') {
	if (and hasMore hasLess) { extra = (unit + (floor (size / 3))) }
	setExtent morph (+ unit extra) size
  } else {
	if (and hasMore hasLess) { extra = (unit + (floor (size / 5))) }
	setExtent morph size (+ unit extra)
  }
}

method drawOn BlockDrawer ctx {
  if (notNil target) {
    hasMore = (canExpand target)
    hasLess = (canCollapse target)
  } else {
    hasMore = true
    hasLess = true
  }
  size = (13 * (blockScale))
  unit = (half size)
  clr = (gray 0 220)

  pen = (getShapeMaker ctx)
  x = (left morph)
  y = (top morph)
  offset = 0
  if hasLess { // draw left arrow
	if (orientation == 'horizontal') {
	  fillArrow pen (rect x y unit size) 'left' clr
	  offset = (unit + (floor (size / 3)))
	} else {
	  fillArrow pen (rect x y size unit) 'up' clr
	  offset = (unit + (floor (size / 5)))
	}
  }
  if hasMore { // draw right arrow
	if (orientation == 'horizontal') {
	  fillArrow pen (rect (x + offset) y unit size) 'right' clr
	} else {
	  fillArrow pen (rect x (y + offset) size unit) 'down' clr
	}
  }
}

method handEnter BlockDrawer aHand {
  setCursor 'pointer'
}

method handLeave BlockDrawer aHand {
  setCursor 'default'
  // handEnter happens before handLeave, so cursor wouldn't go back to finger
  // when you move between two buttons without any space in between. A temporary
  // solution is to re-trigger handEnter on the new morph under the hand.
  handEnter (objectAt aHand) aHand
}

method clicked BlockDrawer aHand {
  if (isNil target) {return false}
  hasMore = (canExpand target)
  hasLess = (canCollapse target)
  if (and hasMore hasLess) {
    if (orientation == 'horizontal') {
      if ((x aHand) > (hCenter (bounds morph))) {
        expand target
      } else {
        collapse target
      }
    } else { // 'vertical'
      if ((y aHand) > (vCenter (bounds morph))) {
        expand target
      } else {
        collapse target
      }
    }
  } else { // single arrow
    if hasLess {
      collapse target
    } else {
      expand target
    }
  }
  return true
}

// keyboard accessibility hooks

method trigger BlockDrawer {
  if (isNil target) {return}
  if (canExpand target) {
    expand target
  } (canCollapse target) {
    collapse target
  }
}

method collapse BlockDrawer {
  if (isNil target) {return}
  if (canCollapse target) {collapse target}
}
// a window around a script editor pane

defineClass BlockEditor morph window scripts scriptsFrame

method initialize BlockEditor contents {
  scale = (global 'scale')
  if (not (isClass contents 'Block')) {contents = nil}
  window = (window 'Block Editor')
  morph = (morph window)
  setHandler morph this
  setMinExtent morph (scale * 100) (scale * 150)

  scripts = (newScriptEditor 10 10)
  if (notNil contents) {
    setPosition (morph contents) 10 10
    addPart (morph scripts) (morph contents)
  }
  scriptsFrame = (scrollFrame scripts (gray 220))
  addPart morph (morph scriptsFrame)

  setExtent morph (scale * 250) (scale * 330)
}

method fixLayout BlockEditor {
  fixLayout window
  clientArea = (clientArea window)
  setPosition (morph scriptsFrame) (left clientArea) (top clientArea)
  setExtent (morph scriptsFrame) (width clientArea) (height clientArea)
}

method redraw BlockEditor {
  redraw window
  fixLayout this
}

to openBlockEditor page contents {
  be = (new 'BlockEditor')
  initialize be contents
  setPosition (morph be) (x (hand page)) (y (hand page))
  addPart page be
}
// BlockSearchBox - A widget for finding blocks

defineClass BlockSearchBox morph searchText menu

method morph BlockSearchBox { return morph }

to newBlockSearchBox w h {
  return (initialize (new 'BlockSearchBox') w h)
}

method initialize BlockSearchBox w h {
  scale = (global 'scale')
  morph = (newMorph this)

  bm = (newBitmap (w * scale) (h * scale) (gray 240))
  setCostume morph bm
  outlineRectangle (newShapeMaker bm) (bounds morph) (1 * scale) (gray 150)
  drawBitmap bm (searchIcon this) (2 * scale) (2 * scale) 130
  costumeChanged morph

  searchText = (newText)
  setFont searchText nil (13 * scale)
  setColor searchText (gray 30)
  setEditRule searchText 'editable' // 'line' does not work; shift key is inserted as character
  setGrabRule (morph searchText) 'ignore'
  setPosition (morph searchText) (20 * scale) (2 * scale)
  addPart morph (morph searchText)

  return this
}

method handDownOn BlockSearchBox hand {
  edit searchText hand
  return true
}

method textEdited BlockSearchBox {
  s = (text searchText)
  if ('' == s) {
	closeUnclickedMenu (global 'page') this
	return
  }
  if (endsWith s (newline)) { // workaround because 'line' editRule does not work
	setText searchText (substring s 1 ((count s) - 1))
  }
  showMenu this (findMatchingSpecs this (text searchText))
  return true
}

method findMatchingSpecs BlockSearchBox prefix {
  maxMatches = 10
  result = (list)
  entries = (dictionary)
  authoringSpecs = (authoringSpecs)
  for entry (allSpecs authoringSpecs) {
    fType = (at entry 1)
    if (or (isNil types) (contains types fType)) {
      fName = (at entry 2)
      spec = (at entry 3)
      if (beginsWith fName prefix) {
        if (not (contains entries fName)) {
          add entries fName
          add result (specForEntry authoringSpecs entry)
        }
      } else {
        specWords = (copyWithout (words spec) '_')
        s = (joinStringArray specWords ' ')
        if (or (beginsWith s prefix) (allWordsMatch this (words prefix) specWords)) {
          if (not (contains entries fName)) {
            add entries fName
            add result (specForEntry authoringSpecs entry)
          }
        }
      }
      if ((count result) >= maxMatches) {return result}
    }
  }
  return result
}

method allWordsMatch BlockSearchBox soughtWords specWords {
  // Return true if every sought word is a prefix of some word in specWords.
  for sought soughtWords {
    match = false
    for w specWords {
      if (beginsWith w sought) { match = true }
    }
    if (not match) { return false }
  }
  return true
}

// block selection menu

method showMenu BlockSearchBox specList {
  if (notNil menu) { destroy (morph menu) }
  menu = (menu nil this)
  setField menu 'returnFocus' searchText
  for spec specList {
	aBlock = (blockForSpec spec)
	addItem menu (fullCostume (morph aBlock)) (action 'grabBlock' this aBlock)
  }
  popUp menu (page morph) (left morph) (bottom morph) true // suppress focus
}

method grabBlock BlockSearchBox aBlock {
  op = (primName (expression aBlock))
  showBlockCategory (categoryFor (authoringSpecs) op)
  grab (hand (global 'page')) aBlock
  setText searchText ''
}

method step BlockSearchBox {
  // Clear the search text when the menu goes away.
  if ('' != (text searchText)) {
	if (or (isNil menu) (isNil (owner (morph menu)))) {
	  setText searchText ''
	  menu = nil
	}
  }
}

// magnifying glass icon

method searchIcon BlockSearchBox {
  icon = (newBitmap 30 30)
  p = (newVectorPen icon)
  beginPath p 12 3
  turn p 360 9
  stroke p (gray 150) 3
  beginPath p 19 18
  setHeading p 45
  forward p 13
  stroke p (gray 150) 3
  if (2 != (global 'scale')) {
	icon = (scaleAndRotate icon ((global 'scale') / 2))
  }
  return icon
}
// Support for block specs and slot information

// The following functions do nothing. They are used to record the block spec
// and slot information associated with a function or method.

defineClass BlockSpec blockType blockOp specs repeatLastSpec slotInfo

classComment BlockSpec '
A BlockSpec object records information about the format, keywords,
input slots, and possible extensions for a given block.

The blockType is one of " " (command), "r" (reporter), "c" (c-shaped)
or "h" (hat block).

A spec string has the text that appears on the block, possibly
with one or more underscore characters indicating input slots.

The specs field holds an array containing one or more spec strings.
The first spec is the base spec for the block. Any additional spec
strings reflect possible extensions of that block. Each extension
spec string have includes one or more input slots and possible additional
text.

If repeatLastSpec is true, the the block can be extended to an
arbibrary length by repeating the final spec as many times as
necessary.

The slotInfo field holds an array of records (arrays) that
define the input slots. Each record holds the slot type (string),
a default value for the slot, an optional hint string, and an
optional menu selector. The current slot types are: num, str, bool,
cmd, var, menu, or any. For slots of type any, the hint string is
displayed as a suggestion to the user (e.g. "list or array").
'

method blockType BlockSpec { return blockType }
method blockOp BlockSpec { return blockOp }
method specs BlockSpec { return specs }
method repeatLastSpec BlockSpec { return repeatLastSpec }
method isHat BlockSpec { return ('h' == blockType) }
method isReporter BlockSpec { return ('r' == blockType) }
method slotCount BlockSpec { return (count slotInfo) }

method hintAt BlockSpec i {
  if (i > (count slotInfo)) { return '' }
  return (at (at slotInfo i) 3)
}

to blockSpecFor function {
  if (isClass function 'String') {
    function = (functionNamed function)
  }
  if (not (isClass function 'Function')) {
    error 'Argument must be a function name or Function'
  }
  return (initializeForFunction (new 'BlockSpec') function)
}

to blockSpecFromStrings blockOp blockType specString typeString defaults {
  specs = (splitWith specString ':')
  for i (count specs) {
    atPut specs i (trim (at specs i))
  }
  repeatLastSpec = false
  if (and ((count specs) > 0) ('...' == (last specs))) {
	repeatLastSpec = true
    specs = (copyArray specs ((count specs) - 1))
  }
  result = (new 'BlockSpec' blockType blockOp specs repeatLastSpec (array))
  setSlotInfo result typeString defaults
  return result
}

method setSlotInfo BlockSpec typeString defaults {
  types = (words typeString)
  for i (count types) {
    parts = (splitWith (at types i) '.')
	if ((count parts) > 1) {
	  atPut types i (joinStringArray parts ' ')
	}
  }
  n = (max (count types) (count defaults) (countAllSpecSlots this))
  slotInfo = (newArray n)
  for i n {
    type = nil
	default = nil
	hint = nil
	menuSelector = nil
	if (i <= (count types)) { type = (at types i) }
	if (i <= (count defaults)) { default = (at defaults i) }
	if (isNil type) {
	  if (isNumber default) {
		type = 'num'
	  } else {
	    type = 'any'
	    if (isClass default 'String') { hint = default }
	    default = nil
	  }
	} else {
	  w = (words type)
	  type = (first w)
	  if ((count w) == 2) {
		menuSelector = (at w 2)
	  }
	  if (not (contains (array 'num' 'str' 'auto' 'bool' 'color' 'cmd' 'var' 'menu' 'microbitDisplay') type)) {
		hint = type
		type = 'any'
	  }
	}
    atPut slotInfo i (array type default hint menuSelector)
  }
}

method copyWithOp BlockSpec newOp oldName newName {
  // Return a deep copy of this BlockSpec with newOp as its blockOp and
  // newName substituted for oldName in both spec strings and the slot info.

  result = (clone this)
  setField result 'blockOp' newOp

  newSlotInfo = (copy slotInfo)
  for i (count newSlotInfo) {
	newEntry = (copy (at slotInfo i))
	for j (count newEntry) {
	  if ((at newEntry j) == oldName) {
		atPut newEntry j newName
	  }
	}
	atPut newSlotInfo i newEntry
  }
  setField result 'slotInfo' newSlotInfo

  newSpecs = (copy specs)
  for i (count newSpecs) {
	if ((at newSpecs i) == oldName) {
		atPut newSpecs i newName
	}
  }
  setField result 'specs' newSpecs
  return result
}

method inputSlot BlockSpec slotIndex blockColor isFormalParameter argNames {
  if (isNil isFormalParameter) {isFormalParameter = false}
  info = (slotInfoForIndex this slotIndex)
  editRule = 'static'
  slotType = (at info 1)
  if isFormalParameter {slotType = 'var'}
  slotContent = (at info 3) // hint
  menuSelector = (at info 4)
  if ('num' == slotType) {
    editRule = 'numerical'
    slotContent = (at info 2)
  }
  if ('str' == slotType) {
    editRule = 'editable'
    slotContent = (at info 2)
  }
  if ('auto' == slotType) {
    editRule = 'auto'
    slotContent = (at info 2)
  }
  if ('bool' == slotType) {
    slotContent = (at info 2)
    if (isNil slotContent) {slotContent = true}
    return (newBooleanSlot slotContent)
  }
  if ('color' == slotType) {
    return (newColorSlot)
  }
  if ('microbitDisplay' == slotType) {
    slotContent = (at info 2)
    return (newMicroBitDisplaySlot slotContent)
  }
  if ('menu' == slotType) {
    slotContent = (at info 2)
  }
  if ('cmd' == slotType) {
    return (newCommandSlot blockColor)
  }
  if ('var' == slotType) {
    if isFormalParameter {
      if (or (isNil argNames) ((count argNames) < slotIndex)) {
        argName = 'args'
      } else {
        argName = (at argNames slotIndex)
      }
      rep = (toBlock (newReporter 'v' argName))
    } else {
      rep = (toBlock (newReporter 'v' (at info 2)))
    }
    setGrabRule (morph rep) 'template'
    return rep
  }
  inp = (newInputSlot slotContent editRule blockColor menuSelector)
  setGrabRule (morph inp) 'ignore'
  return inp
}

method slotInfoForIndex BlockSpec slotIndex {
  if (slotIndex <= (count slotInfo)) {
    return (at slotInfo slotIndex)
  }
  if (not repeatLastSpec) { error 'Slot index is out of range' }
  repeatedSlotCount = (countInputSlots this (last specs))
  if (repeatedSlotCount == 0) { error 'The repeated slot spec must have at least one input slot' }
  firstRepeatedSlot = ((((count slotInfo) - repeatedSlotCount)) + 1)
  i = (firstRepeatedSlot + ((slotIndex - firstRepeatedSlot) % repeatedSlotCount))
  if (i < 1) { return (array 'auto' '' nil nil) } // default if no slot info
  return (at slotInfo i)
}

method translatedSlotInfo BlockSpec {
  // Return a copy of my slotInfo with the default string values translated.
  // However, do not translate default values for slots with menus.

  result = (clone slotInfo)
  for i (count result) {
    entry = (at result i)
    slotDefault = (at entry 2)
    slotMenu = (at entry 4)
    if (and (isClass slotDefault 'String') (isNil slotMenu)) {
      newEntry = (clone entry)
      atPut newEntry 2 (localized slotDefault)
      atPut result i newEntry
    }
  }
  return result
}

method initializeForFunction BlockSpec function {
  blockOp = (functionName function)
  blockType = ' '
  if (returnsValue function) { blockType = 'r' }
  collectSpecs this function
  collectSlotInfo this function
  if ((count specs) == 0) { error 'empty spec list' }
  if repeatLastSpec {
    if ((countInputSlots this (last specs)) == 0) {
      error 'no input slots in the repeated last spec'
    }
  }
  return this
}

method collectSpecs BlockSpec function {
  repeatLastSpec = false
  if ((count (argNames function)) > 0) {
    repeatLastSpec = (endsWith (last (argNames function)) '...')
  }
  if (isInfix this function) {
	specs = (array (join '_ ' (functionName function) ' _'))
	return
  }
  if (isNil (functionName function)) {
	parts = (list '')
  }  else {
	parts = (list (separateCamelCase (functionName function)))
  }
  for argName (argNames function) {
	if (not (endsWith argName '...')) {
	  if ('this' != argName) {
		add parts ' '
		add parts argName
	  }
	  add parts ' _'
	}
  }
  specs = (array (joinStringArray (toArray parts)))
  if repeatLastSpec {
	specs = (copyWith specs '_')
  }
}

method isInfix BlockSpec function {
  if ((count (argNames function)) != 2) { return false }
  if (isNil (functionName function)) { return false }
  for ch (letters (functionName function)) {
    if (not (isSymbol ch)) { return false }
  }
  return true
}

method collectSlotInfo BlockSpec function {
  n = (countAllSpecSlots this)
  slotInfo = (newArray n)
  for i n {
    type = 'auto'
	default = 1
	hint = nil
	if (and (i == 1) (isMethod function)) {
	  className = (className (class (classIndex function)))
	  if ('String' == className) {
		default = 'Hello'
	  } ('Boolean' == className) {
		type = 'bool'
		default = false
	  } ('Color' == className) {
		type = 'color'
	  } ('Integer' == className) {
		default = 1
	  } ('Float' == className) {
		default = 1.0
	  } else {
		type = 'any'
		default = nil
		hint = 'this'
	  }
	}
    atPut slotInfo i (array type default hint nil)
  }
}

method countAllSpecSlots BlockSpec {
  // Return the total number input slots in all slot specs.
  return (countInputSlots this (joinStringArray specs))
}

method countInputSlots BlockSpec specString {
  // Return the number of underscores (input slots) in the given string.
  result = 0
  for w (words specString) {
	if ('_' == w) { result += 1 }
  }
  return result
}

method specDefinitionString BlockSpec className {
  // Return a spec definition string for an exported class.
  // The className argument is provided for methods; it is nil for shared functions.

  result = (list 'spec')
  add result (printString blockType)
  add result (printString blockOp)

  specString = ''
  for i (count specs) {
	specString = (join specString (at specs i))
	if (i < (count specs)) { specString = (join specString ' : ') }
  }
  if repeatLastSpec  { specString = (join specString ' : ...') }
  add result (printString specString)

  if (not (isEmpty slotInfo)) {
	slotTypes = (list)
	defaultValues = (list)
	for info slotInfo {
	  slotType = (at info 1)
	  if (isOneOf slotType 'auto' 'menu' 'str') {
		add defaultValues (printString (at info 2))
	  } (isOneOf slotType 'bool' 'num' 'microbitDisplay') {
		add defaultValues (toString (at info 2))
	  } else {
		add defaultValues 'nil'
	  }
	  if (notNil (at info 4)) { // has a menu
		slotType = (join slotType '.' (at info 4))
	  }
	  add slotTypes slotType
	}
	if (notNil className) { atPut slotTypes 1 className } // for methods, first type is the class name
	add result (printString (joinStrings slotTypes ' '))

	// remove trailing nil's from defaultValues, then add them
	while (and (notEmpty defaultValues) ('nil' == (last defaultValues))) {
		removeLast defaultValues
	}
	for v defaultValues { add result v }
  }
  return (joinStrings result ' ')
}

method updateClassHint BlockSpec aDictionary {
  // Use the given dictionary to map the hint slot of my first slot (the receiver of a method)
  // from and old to new class name if there is an entry for the hint in the given dictionary.

  if (isEmpty slotInfo) { return }
  oldClassName = (at (first slotInfo) 3)
  if (contains aDictionary oldClassName) {
	atPut (first slotInfo) 3 (at aDictionary oldClassName)
  }
}
defineClass BlocksPalette morph alignment

method alignment BlocksPalette { return alignment }

to newBlocksPalette {
  return (initialize (new 'BlocksPalette'))
}

method initialize BlocksPalette {
  order = (function b1 b2 {
    return ((primName (expression (handler b1))) < (primName (expression  (handler b2))))
  })
  morph = (newMorph this)
  setTransparentTouch morph true // optimization
  alignment = (newAlignment 'multi-column' nil 'bounds' order)
  setMorph alignment morph
  return this
}

method adjustSizeToScrollFrame BlocksPalette aScrollFrame {
  adjustSizeToScrollFrame alignment aScrollFrame
}

method cleanUp BlocksPalette {
  fixLayout alignment
}

method layoutChanged BlocksPalette {
  changed morph
}

method wantsDropOf BlocksPalette aHandler {
  return (isAnyClass aHandler 'Block' 'Monitor')
}

method justReceivedDrop BlocksPalette aHandler {
  // Delete Blocks or Monitors dropped on the palette.

  wantsToRaise = (and (isClass aHandler 'Block') (isPrototypeHat aHandler))
  if (userDestroy (morph aHandler)) {
    if wantsToRaise { raise morph 'reactToMethodDelete' this }
  } else {
    grab (hand (global 'page')) aHandler
  }
}
// Boolean input slot for blocks

to booleanConstant b { return b }

defineClass BooleanSlot morph contents displayAsElse

to newBooleanSlot defaultValue isElse {
	return (initialize (new 'BooleanSlot') defaultValue isElse)
}

method initialize BooleanSlot defaultValue isElse {
	contents = (true == defaultValue)
	displayAsElse = (true == isElse)
	morph = (newMorph this)
	setExtent morph (23 * (blockScale)) (13 * (blockScale))
	return this
}

method contents BooleanSlot { return contents }

method setContents BooleanSlot newValue {
	if (not (isClass newValue 'Boolean')) { return }
	contents = newValue
	raise morph 'inputChanged' this
	changed morph
}

method toggleState BooleanSlot {
	if displayAsElse { return } // don't toggle when used as 'else' in an if block
	if (not (isClass contents 'Boolean')) { contents = false }
	setContents this (not contents)
}

// drawing

method drawOn BooleanSlot ctx {
	scale = (blockScale)
	if (and displayAsElse contents) {
		// used to display a true boolean slot as 'else' in the final case of an 'if' block
		elseLabel = (labelText (new 'Block') (localized 'else'))
		setPosition (morph elseLabel) (left morph) (top morph)
		drawOn elseLabel ctx
		return
	}
	borderWidth = (max 1 (half scale))
	sliderSize = (height morph)
	corner = (8 * scale)
	r = (bounds morph)
	sm = (getShapeMaker ctx)
	if contents {
		c = (color 100 200 100) // green
		offset = ((width morph) - sliderSize)
	} else {
		c = (color 200 100 100) // red
		offset = 0
	}
	if contents { c = (color 0 200 0) }
	r = (bounds morph)
	fillRoundedRect sm r corner c borderWidth (gray 80) (gray 80)
	sliderRect = (rect ((left r) + offset) (top r) sliderSize sliderSize)
	fillRoundedRect sm sliderRect corner (gray 130) borderWidth (gray 80) (gray 80)
}

// replacement rule

method isReplaceableByReporter BooleanSlot {
	if displayAsElse { return false } // not replaceable when used as 'else' in an if block
	owner = (handler (owner morph))
	if (and (isClass owner 'Block') ('booleanConstant' == (primName (expression owner)))) {
		// Don't allow replacing the boolean slot in a boolean constant reporter
		return false
	}
	return true
}

// events

method clicked BooleanSlot aHand { toggleState this; return true }

// keyboard accessibility hooks

method trigger BooleanSlot { clicked this nil }
// morphic box handler, used as mixin in a variety of morphs

defineClass Box morph color corner border isInset hasFrame

to newBox morph color corner border isInset hasFrame {
  result = (initialize (new 'Box'))
  if (notNil morph) {
  	setField result 'morph' morph
  	setHandler morph result
  }
  if (notNil color) { setField result 'color' color }
  if (notNil corner) { setField result 'corner' corner }
  if (notNil border) { setField result 'border' border }
  if (notNil isInset) { setField result 'isInset' isInset }
  if (notNil hasFrame) { setField result 'hasFrame' hasFrame }
  return result
}

method initialize Box {
  scale = (global 'scale')
  morph = (newMorph this)
  color = (color 70 160 180)
  corner = (scale * 4)
  border = 0
  isInset = true
  hasFrame = false
  setExtent morph (60 * scale) (40 * scale)
  return this
}

method color Box {return color}
method setColor Box aColor {color = aColor}
method corner Box {return corner}
method setCorner Box num {corner = num}
method border Box {return border}
method setBorder Box num {border = num}
method isInset Box {return isInset}
method setInset Box bool {isInset = bool}
method setFrame Box bool {hasFrame = bool}

method drawOn Box aContext {
  if (0 == (alpha color)) { return }
  drawButton (getShapeMaker aContext) (left morph) (top morph) (width morph) (height morph) color corner border isInset
}

method redraw Box {
  bm = (newBitmap (width morph) (height morph))
  if (0 == (alpha color)) {return}
  drawButton (newShapeMaker bm) 0 0 (width morph) (height morph) color corner border isInset
  setCostume morph bm
}
// Button.gp - Simple button

defineClass Button morph clickAction offCostume onCostume isOn hint

to newButton label action {
  return (initialize (new 'Button') label action)
}

method initialize Button label action {
  if (isNil label) { label = 'Button' }
  if (isNil action) { action = (action 'toggle' this) }
  morph = (newMorph this)
  setGrabRule morph 'ignore'
  setLabel this label
  clickAction = action
  isOn = false
  return this
}

method toggle Button { setOn this (not isOn) }
method isOn Button { return isOn }

method setHint Button aStringOrNil { hint = aStringOrNil }
method hint Button { return hint }

method setOn Button bool {
  isOn = (true == bool)
  if (and isOn (notNil onCostume)) {
	setCostume morph onCostume
  } else {
	setCostume morph offCostume
  }
}

method setLabel Button label offColor onColor minWidth minHeight fontName fontSize fontColor {
  if (isNil offColor) { offColor = (gray 140) }
  if (isNil onColor) { onColor = (lighter offColor 15) }
  offBM = (makeCostume this label offColor minWidth minHeight fontName fontSize fontColor)
  onBM = (makeCostume this label onColor minWidth minHeight fontName fontSize fontColor)
  setCostumes this offBM onBM
}

method setCostumes Button offBM onBM {
  offCostume = offBM
  onCostume = onBM
  setCostume morph offCostume
}

// button costumes

method makeCostume Button label color minWidth minHeight fontName fontSize fontColor {
  // Draw a button with the given label and color. The label can be a String or a Bitmap.
  scale = (global 'scale')
  if (isNil label) { label = 'Click!' }
  if (isNil color) { color = (gray 130) }
  if (isNil minWidth) { minWidth = 10 }
  if (isNil minHeight) { minHeight = 10 }
  if (isNil fontName) { fontName = 'Arial Bold' }
  if (isNil fontSize) { fontSize = (scale * 13) }
  if ('Linux' == (platform)) { fontSize = (scale * 11) }
  if (isNil fontColor) { fontColor = (gray 255) }

  borderColor = (gray 80)
  borderW = scale
  cornerRadius = (5 * scale)
  hPadding = (14 * scale)
  vPadding = (10 * scale)

  if (isClass label 'String') {
	setFont fontName fontSize
	labelBitmap = (newBitmap (stringWidth label) (fontHeight) (gray 255 0))
	drawString labelBitmap label fontColor
  } else {
	labelBitmap = label
  }

  w = (max minWidth ((width labelBitmap) + hPadding))
  h = (max minHeight ((height labelBitmap) + vPadding))

  bm = (newBitmap w h)
  fillRoundedRect (newVectorPen bm) (rect 0 0 w h) cornerRadius color borderW borderColor
  drawBitmap bm labelBitmap (half (w - (width labelBitmap))) (half (h - (height labelBitmap)))
  return bm
}

// events

method handDownOn Button hand {
  if (notNil clickAction) {
	call clickAction this
  }
  return true
}

method handEnter Button aHand {
  setCursor 'pointer'
  if (notNil onCostume) {
	setCostume morph onCostume
  }
  if (notNil hint) {
	addSchedule (global 'page') (schedule (action 'showTooltip' morph hint) 500)
  }
}

method handLeave Button aHand {
  setCursor 'default'
  // handEnter happens before handLeave, so cursor wouldn't go back to finger
  // when you move between two buttons without any space in between. A temporary
  // solution is to re-trigger handEnter on the new morph under the hand.
  handEnter (objectAt aHand) aHand
  setOn this isOn
  if (notNil hint) {removeTooltip (page aHand)}
  removeSchedulesFor (global 'page') 'showTooltip' morph
}
// CachedTexture
// Browser only!
// Cached texture (i.e. canvas) for fast drawing when a morph is carried by the hand.
//
// John Maloney, June 2021

defineClass CachedTexture morph shadowOffset cachedTexture

to newCachedTexture aHandler {
	return (initialize (new 'CachedTexture') aHandler)
}

method initialize CachedTexture aHandler {
	aMorph = (morph aHandler)
	if (isClass (handler aMorph) 'Block') { fixLayout (handler aMorph) }

	// draw aMorph on the texture
	fb = (fullBounds aMorph)
	cachedTexture = (newTexture (width fb) (height fb) (gray 0 0))
	ctx = (newGraphicContextOn cachedTexture)
	setOffset ctx (0 - (left fb)) (0 - (top fb))
	fullDrawOn aMorph ctx

	shadowOffset = (7 * (global 'scale'))
	morph = (newMorph this)
	setExtent morph ((width fb) + shadowOffset) ((height fb) + shadowOffset)
	setPosition morph (left fb) (top fb)
	return this
}

method drawOn CachedTexture ctx {
	// always draw with shadow
	shadowColor = (gray 0 60)
	shadowBlur = (1 * (global 'scale'))
	browserSetShadow shadowColor shadowOffset shadowBlur

	drawTexture ctx cachedTexture (left morph) (top morph)
	browserClearShadow
}
// basic Morphic text editing handler

defineClass Caret morph target slot originalContents

method slot Caret {return slot}
method originalContents Caret {return originalContents}
method target Caret {return target}

method initialize Caret aText initialSlot {
  morph = (newMorph this)
  setFPS morph 2
  if (notNil aText) {
    edit this aText initialSlot
	showKeyboard true
  }
}

method redraw Caret {
  setCostume morph (newBitmap (width morph) (height morph) (color))
}

method step Caret {
  if (isVisible morph) {
    hide morph
  } else {
    show morph
  }
  if ('Browser' == (platform)) {
	s = (browserGetDroppedText)
	if (notNil s) { insertRight this s }
  }
}

method edit Caret aText initialSlot {
  slot = initialSlot
  if (isNil slot) {slot = 1}
  target = aText
  setCaret target this
  originalContents = (text target)
  unmark target
  adjustSize this
  addPart (morph target) morph
  gotoSlot this
}

method adjustSize Caret {
  setFont (fontName target) (fontSize target)
  setExtent morph 2 (fontHeight)
}

to gotoSlot anObject { } // hack: backstop method to avoid errors if caret is nil

method gotoSlot Caret index {
  // index is optional, and can be used to set the slot
  if (notNil index) {slot = index}
  pos = (slotPosition target slot)
  setPosition morph (at pos 1) (at pos 2)
  updateMark this
  scrollIntoView this
}

method scrollIntoView Caret {
  parent = (parentHandler (morph target))
  if (isClass parent 'ScrollFrame') {
    scrollIntoView parent (bounds morph)
  }
}

// events

method keyDown Caret evt keyboard {
  parent = (parentHandler (morph target))
  if (not (isAnyClass parent 'ScriptFocus' 'BlockSearchBox')) {
    closeUnclickedMenu (page keyboard) this
  }

  charCode = (at evt 'char')
  if (and (32 <= charCode) (charCode < 127)) {
  	ch = (string (at evt 'char'))
	code = -1
  } else {
	ch = ''
	code = (at evt 'keycode')
  }

  modifiers = (at evt 'modifierKeys')
  shiftDown = ((modifiers & 1) != 0) // shift flag = 1
  cmdOrControl = ((modifiers & 10) != 0) // control flag = 2, cmd flag = 8
  editingCode = ((editRule target) == 'code')

  if (8 == code) { deleteLeft this // delete
  }  (9 == code) { tabToNextEntryField this shiftDown // tab
  } (13 == code) { enterKey this // enter
  } (27 == code) { // escape
	cancel this
	raise (morph target) 'cancelled' target
  } (37 == code) { moveLeft this shiftDown // left arrow
  } (38 == code) { moveUp this shiftDown // up arrow
  } (39 == code) { moveRight this shiftDown // right arrow
  } (40 == code) { moveDown this shiftDown // down arrow'
  } (46 == code) { deleteRight this // Window's Delete key
  } (76 == code) { deleteRight this // incorrect Window's Delete key code before v250

  } (and ('a' == ch) cmdOrControl) {
    selectAll target
    gotoSlot this (1 + (count (text target)))
  } (and ('c' == ch) cmdOrControl) {
    copyToClipboard this false
  } (and ('s' == ch) cmdOrControl) {
    raise (morph target) 'accepted' target
    accept this
    gotoSlot this (1 + (count (text target)))
  } (and ('v' == ch) cmdOrControl) {
    pasteFromClipboard this
  } (and ('x' == ch) cmdOrControl) {
    copyToClipboard this true
  } (and ('z' == ch) cmdOrControl) {
    cancel this
    raise (morph target) 'cancelled' target
  } (and ('b' == ch) cmdOrControl editingCode) {
    blockifyIt target
  } (and ('m' == ch) cmdOrControl editingCode) {
    browseImplementors target
  } (and ('d' == ch) cmdOrControl editingCode) {
    doIt target
  } (and ('p' == ch) cmdOrControl editingCode) {
    printIt target
  } (and ('i' == ch) cmdOrControl editingCode) {
    inspectIt target
  } (and ('e' == ch) cmdOrControl editingCode) {
    exploreIt target
  }
}

method keyUp Caret evt keyboard {
  nop
}

method textinput Caret evt keyboard {
  old = (text target)
  insertRight this (at evt 'text')
  if (and ('numerical' == (editRule target)) (not (representsANumber (text target)))) {
	setText target old
	moveLeft this
  }
}

method moveRight Caret shiftDown {
  updateMarkingMode this shiftDown
  slot += 1
  slot = (min slot (+ 1 (count (text target))))
  gotoSlot this
}

method moveLeft Caret shiftDown {
  updateMarkingMode this shiftDown
  slot += -1
  slot = (max slot 1)
  gotoSlot this
}

method moveDown Caret shiftDown {
  if ((editRule target) == 'line') {
    raise (morph target) 'downArrow' target
    return
  }
  if ((+ 1 (bottom morph) (borderY target) (abs (shadowOffsetY target))) > (bottom (morph target))) {return}
  updateMarkingMode this shiftDown
  slot = (slotAt target (+ 5 (left morph)) (+ 1 (bottom morph)))
  gotoSlot this
}

method moveUp Caret shiftDown {
  if ((editRule target) == 'line') {
    raise (morph target) 'upArrow' target
    return
  }
  updateMarkingMode this shiftDown
  slot = (slotAt target (+ 5 (left morph)) (+ -1 (top morph)))
  gotoSlot this
}

method insertRight Caret string {
  if (notNil (startMark target)) {
    em = (endMark target)
    if (isNil em) {em = (startMark target)}
    begin = (min (startMark target) em)
    end = (max (startMark target) em)
    before = (substring (text target) 1 (begin - 1))
    after = (substring (text target) end)
    setText target (join before string after)
    slot = (begin + (count string))
  } else {
    before = (substring (text target) 1 (slot - 1))
    after = (substring (text target) slot)
    setText target (join before string after)
    slot += (count string)
  }
  slot = (min slot ((count (text target)) + 1))
  gotoSlot this
}

method deleteLeft Caret {
  if (and (notNil (startMark target)) (notNil (endMark target))) {
    begin = (min (startMark target) (endMark target))
    end = (max (startMark target) (endMark target))
    before = (substring (text target) 1 (begin - 1))
    after = (substring (text target) (max 1 end))
    setText target (join before after)
    slot = begin
  } else {
    slot += -1
    if (slot < 1) {
      slot = 1
      return
    }
    before = (substring (text target) 1 (slot - 1))
    after = (substring (text target) (slot + 1))
    setText target (join before after)
  }
  gotoSlot this
}

method deleteRight Caret {
  if (and (notNil (startMark target)) (notNil (endMark target))) {
	deleteLeft this
	return
  }
  before = (substring (text target) 1 (slot - 1))
  after = (substring (text target) (slot + 1))
  setText target (join before after)
}

method enterKey Caret {
  if (or ((editRule target) == 'editable') ((editRule target) == 'code')){
    insertRight this (newline)
    showKeyboard true  // keep keyboard up on iOS
  } else {
    raise (morph target) 'accepted' target
    accept this
  }
}

method tabToNextEntryField Caret shiftDown {
  page = (page morph)
  if (isNil page) { return }
  isEditField = (function item {return (and (isClass (handler item) 'Text') ((editRule (handler item)) != 'static'))})
  fields = (filter isEditField (allMorphs (morph page)))
  idx = (indexOf fields (morph target))
  if shiftDown {
    idx += -1
    if (idx < 1) {idx = (count fields)}
  } else {
    idx += 1
    if (idx > (count fields)) {idx = 1}
  }
  stopEditingUnfocusedText (hand page)
  trgt = (handler (at fields idx))
  edit (keyboard page) trgt 1
  selectAll trgt
}

method accept Caret {
  stopEditing target
  raise (morph target) 'textChanged' target
}

method cancel Caret {
  setText target originalContents
  parent = (parentHandler (morph target))
  stopEditing target
  if (isClass parent 'ScriptFocus') {
    cancelled parent
  }
}

// clipboard

method copyToClipboard Caret cutFlag {
  selected = (selected target)
  if (selected != '') {
    setClipboard selected
	if cutFlag { deleteLeft this }
  }
}

method pasteFromClipboard Caret {
  s = (readClipboard)
  if (s != '') { insertRight this s }
}

// marking

method updateMarkingMode Caret shiftPressed {
  if shiftPressed {
    if (isNil (startMark target)) {setStartMark target slot}
  } else {
    unmark target
  }
}

method updateMark Caret {
  if (isNil (startMark target)) {return}
  setEndMark target slot
  changed (morph target)
}

// destroying

method destroy Caret {
  parent = (parentHandler (morph target))
  unmark target
  setCaret target nil
  showKeyboard false
  destroy morph
  if (isClass parent 'ScriptFocus') {
    destroy parent
  }
}

defineClass CategorySelector morph fontName fontSize selectAction items selectedIndex hoverIndex

to newCategorySelector aList anAction {
	// Create a new block category or library selector.
	// Optional anAction is called when a selection is made.

	if (isNil aList) { aList = (list) }
	return (initialize (new 'CategorySelector') aList anAction)
}

method initialize CategorySelector aList anAction {
	morph = (newMorph this)
	setTransparentTouch morph true
	setClipping morph true
	setFPS morph 10
	selectAction = anAction
	items = aList
	selectedIndex = 0
	setFont this 'Arial Bold' 16
	h = ((count items) * (itemHeight this))
	setExtent morph 300 (clamp h 100 500)
	return this
}

method updateMorphContents CategorySelector {
	// For compatability with ListBox. Ignored.
}

method setFont CategorySelector fName fSize {
  if (notNil fName) { fontName = fName }
  if (notNil fSize) { fontSize = ((global 'scale') * fSize) }
  changed morph
}

method collection CategorySelector { return items }

method setCollection CategorySelector itemNames {
	oldSelection = (selection this)
	items = itemNames
	select this oldSelection
	setExtent morph nil ((count items) * (itemHeight this))
}

method heightForItems CategorySelector {
  return ((count items) * (itemHeight this))
}

method drawOn CategorySelector ctx {
	scale = (global 'scale')
	bgColor = (gray 240)
	white = (gray 255)
	black = (gray 0)

	insetX = (20 * scale)
	insetY = (2 * scale)

	itemH = (itemHeight this)
	swatchInsetX = (4 * scale)
	swatchInsetY = (2 * scale)
	swatchW = (10 * scale)
	swatchH = (itemH - (3 * scale))

	x = (left morph)
	y = ((top morph) + scale)
	w = (width morph)
	for i (count items) {
		catColor = (blockColorForCategory (authoringSpecs) (at items i))
		itemC = bgColor
		textC = black
		drawSwatch = true
		if (i == selectedIndex) {
			itemC = catColor
			textC = white
			drawSwatch = false
		} (i == hoverIndex) {
			itemC = (lighter catColor 40)
			textC = white
			drawSwatch = false
		}
		fillRect ctx itemC x (y + scale) w (itemH - scale)
		label = (localized (at items i))
		setFont ctx fontName fontSize
		drawString ctx label textC (x + insetX) (y + insetY)
		if drawSwatch {
			fillRect ctx catColor (x + swatchInsetX) (y + swatchInsetY) swatchW swatchH
		}
		y += itemH
	}
}

method selection CategorySelector {
	if (or (selectedIndex < 1) (selectedIndex > (count items))) {
		return nil
	}
	return (at items selectedIndex)
}

method select CategorySelector itemName {
	for i (count items) {
		if (itemName == (at items i)) {
			selectedIndex = i
			changed morph
			if (notNil selectAction) { call selectAction selection }
			return
		}
	}
	selectedIndex = 0
	changed morph
}

method itemHeight CategorySelector {
	return (fontSize + 10)
}

method handDownOn CategorySelector aHand {
	i = (truncate (((y aHand) - (top morph)) / (itemHeight this)))
	if (and (i >= 0) (i < (count items))) {
		selectedIndex = (i + 1)
		if (notNil selectAction) { call selectAction selection }
		hoverIndex = 0
		changed morph
	}
	return true
}

method step CategorySelector {
	hand = (hand (global 'page'))
	if (isBusy hand) { return }
	handX = (x hand)
	handY = (y hand)
	oldHoverIndex = hoverIndex
	if (not (containsPoint (bounds morph) handX handY)) {
		hoverIndex = 0
	} else {
		i = (truncate ((handY - (top morph)) / (itemHeight this)))
		if (and (i >= 0) (i < (count items))) {
			hoverIndex = (i + 1)
		} else {
			hoverIndex = 0
		}
	}
	if (hoverIndex != oldHoverIndex) { changed morph }
}

method categoryUnderHand CategorySelector {
	hand = (hand (global 'page'))
	if (isBusy hand) { return nil }
	handX = (x hand)
	handY = (y hand)
	if (containsPoint (bounds morph) handX handY) {
		i = (truncate ((handY - (top morph)) / (itemHeight this)))
		if (and (i >= 0) (i < (count items))) { return (at items (i + 1)) }
	}
	return nil
}

// context menu

method rightClicked CategorySelector {
	handDownOn this (hand (global 'page'))
	item = (selection this)
	if (notNil item) {
		raise morph 'handleListContextRequest' (array this item)
	}
	return true
}
defineClass Class className classIndex fieldNames methods comments scripts module

method className Class { return className }
method classIndex Class { return classIndex }
method fieldNames Class { return fieldNames }
method methods Class { return methods }
method comments Class { return comments }
method scripts Class { return scripts }
method module Class { return module }
method setScripts Class newScripts { scripts = (toArray newScripts) }

// creation

to newClass name fields module {
  // Create a new class and install it in the class table.

  if (isNil fields) { fields = (array) }
  cl = (new 'Class')
  setField cl 'className' name
  setField cl 'classIndex' i
  setField cl 'fieldNames' (copy (toArray fields))
  setField cl 'methods' (array)
  setField cl 'comments' (array)
  setField cl 'scripts' nil
  setField cl 'module' module
  addClass cl // install class in the class table
  return cl
}

// utilities

method fieldNameCount Class {
  return (count fieldNames)
}

method setName Class newName {
  if (not (canChange this)) { return (problem this 'You cannot modify this class') }
  if (className == newName) { return } // no change
  if (notNil (classNamed module newName)) {
	return (problem this (join 'There is already a class named "' newName '"'))
  }
  className = newName
}

method canChange Class {
  // You can only change (i.e. add/remove/rename instance variables) a class
  // if the virtual machine does not depend it having a particular format.

  return (classIndex > (classIndex (class 'LargeInteger')))
}

method toString Class {
  return (join '<Class ' className '>')
}

// method operations

method methodNames Class {
  result = (list)
  for f methods {
    add result (functionName f)
  }
  return result
}

method methodNamed Class methodName {
  for f methods {
    if ((functionName f) == methodName) { return f }
  }
  return nil
}

method removeMethodNamed Class methodName {
  mList = (list)
  for m methods {
    if ((functionName m) != methodName) { add mList m }
  }
  methods = (toArray mList)
  clearMethodCaches
}

method addMethod Class methodName parameterNames body {
  // Add a method with the given name, parameter names, and body, and return it.
  // The last argument, which must be nil or a Command, is the body of the method.

  if ((argCount) < 2) { error 'A method name is required.' }
  if (and (notNil body) (not (isClass body 'Command'))) {
	error 'Method body must be a Command'
  }
  if (and (notNil parameterNames) ((count parameterNames) > 0)) {
	atPut parameterNames 1 'this' // replace Class name in parameter list with 'this'
  } else {
	parameterNames = (array 'this')
  }

  localVars = (toList (keys (collectLocals body)))
  removeAll localVars parameterNames
  removeAll localVars fieldNames

  // add this method, replacing the old version, if any
  result = (new 'Function' methodName classIndex (toArray parameterNames) (toArray localVars) body module)
  if (notNil (methodNamed this methodName)) {
	removeMethodNamed this methodName
  }
  methods = (copyWith methods result)

  return result
}

// user-defined classes

method isUserDefined Class {
  return (not (module === (topLevelModule)))
}

// field operations

method addField Class fieldName {
  // Add a new field to a class (at the end), updating all extant instances.

  if (not (canChange this)) { return (problem this 'You cannot modify this class') }
  if (not (isClass fieldName 'String')) { return (problem this 'The field name must be a string') }
  if (contains fieldNames fieldName) { return } // already has that field
  oldInstances = (toArray (allInstances this))
  fieldNames = (copyWith fieldNames fieldName)
  newInstances = (newArray (count oldInstances))
  for i (count oldInstances) {
    oldObj = (at oldInstances i)
    newObj = (new this)
	for j (objWords oldObj) {
	  setField newObj j (getField oldObj j)
	}
    atPut newInstances i newObj
  }
  replaceObjects oldInstances newInstances
  gc
  clearCaches this
}

method deleteField Class fieldName {
  // Delete a field from a class, updating all extant instances.

  if (not (canChange this)) { return (problem this 'You cannot modify this class') }
  if (varReferenced this fieldName false) {
    return (problem this (join 'Field name still in use: ' fieldName))
  }
  deletedIndex = (indexOf fieldNames fieldName)
  if (isNil deletedIndex) { return } // fieldName already deleted

  oldInstances = (toArray (allInstances this))
  newInstances = (newArray (count oldInstances))

  fieldNames = (copyWithout fieldNames fieldName)
  for i (count oldInstances) {
    oldObj = (at oldInstances i)
    newObj = (new this)
	dst = 1
	for j (objWords oldObj) {
	  if (j != deletedIndex) {
		if (dst <= (objWords newObj)) { // in case of oldObj is a larger, obsolete instance
		  setField newObj dst (getField oldObj j)
		}
	    dst += 1
	  }
	}
    atPut newInstances i newObj
  }
  replaceObjects oldInstances newInstances
  oldInstances = nil
  newInstances = nil
  gc
  clearCaches this
}

method renameField Class oldName newName {
  // Rename a field, updating all references to that variable in
  // all methods of this class.

  if (not (canChange this)) { return (problem this 'You cannot modify this class') }
  if (not (and (isClass oldName 'String') (isClass newName 'String'))) {
    return (problem this 'Field names must be strings')
  }
  if (or (contains fieldNames newName) (varReferenced this newName true)) {
    return (problem this (join 'Field name already in use: ' newName))
  }

  i = (indexOf fieldNames oldName)
  if (isNil i) {
    return (problem this (join 'Class does not have a field named: ' oldName))
  }

  atPut fieldNames i newName // change field name

  // update references to oldName in all methods
  varNameIndex = ((fieldNameCount (class 'Command')) + 1)
  for m methods {
    for ref (refsOfVariable m oldName) {
	  setField ref varNameIndex newName
	  clearCache ref
	}
  }
  clearCaches this
}

method clearCaches Class {
  // Clear the caches in all my methods. This must be done when fields
  // are added to or removed from the class.

  for m methods {
	for b (allBlocks (cmdList m)) { clearCache b }
  }
}

method problem Class reason {
  page = (global 'page')
  if (isNil page) {
    error reason
  } else {
    inform page reason
  }
  return nil
}

method varReferenced Class varName forRename {
  // Return true if the given variable name is referenced by any method in this class.

  for m methods {
    if (contains (argNames m) varName) { return true }
    if (contains (localNames m) varName) { return true }
  }
  if (notNil scripts) {
	for entry scripts {
	  cmd = (at entry 3)
	  for b (allBlocks cmd) {
		if (isOneOf (primName b) 'v' 'my' '=' '+=') {
		  if (varName == (first (argList b))) { return true }
		}
		if (and forRename (isOneOf (primName b) 'local' 'for')) {
		  // when renaming a field variable, avoid conflicts with local variables
		  if (varName == (first (argList b))) { return true }
		}
	  }
	}
  }
  return false
}

// scripts

method scriptString Class oldFormat {
  if (isNil oldFormat) { oldFormat = false }
  newline = (newline)
  result = (list)

  // add class definition
  if oldFormat {
	add result (join 'defineClass ' (printString className))
	for fn fieldNames {
	  add result (join ' ' (printString fn))
	}
	add result (join newline newline)
  }
  if (isNil scripts) { return (joinStrings result) }

  // add scripts
  pp = (new 'PrettyPrinter')
  for entry scripts {
    x = (toInteger (at entry 1))
    y = (toInteger (at entry 2))
    expr = (at entry 3)
    if oldFormat {
	  add result (join 'script ' x ' ' y ' ')
    } else {
	  add result (join 'script ' (printString className) ' ' x ' ' y ' ')
	}
    if (isClass expr 'Reporter') {
	  if (isOneOf (primName expr) 'v' 'my') {
		add result (join '(v ' (first (argList expr)) ')')
	  } else {
		add result (join '(' (prettyPrint pp expr) ')')
      }
	  add result newline
    } else {
      add result (join '{' newline)
      add result (prettyPrintList pp expr)
      add result (join '}' newline)
    }
    add result newline
  }
  return (joinStrings result)
}

// Class copy/paste

method scriptStringWithDefinitionBodies Class {
  if (isNil scripts) { return '' }

  newline = (newline)
  result = (list)

  // add scripts
  pp = (new 'PrettyPrinter')
  for entry scripts {
	x = (toInteger (at entry 1))
	y = (toInteger (at entry 2))
	expr = (at entry 3)
	add result (join 'script ' (printString className) ' ' x ' ' y ' ')

	if (isClass expr 'Reporter') {
	  op = (primName expr)
	  if (isOneOf op 'v' 'my') {
		add result (join '(v ' (first (argList expr)) ')')
	  } else {
		add result (join '(' (prettyPrint pp expr) ')')
	  }
	  add result newline
	} else {
	  add result (join '{' newline)
	  op = (primName expr)
	  if ('method' == op) {
		add result (prettyPrintMethod pp (methodNamed this (first (argList expr))))
	  } ('to' == op) {
		add result (prettyPrintFunction pp (functionNamed (first (argList expr))))
	  } else {
		add result (prettyPrintList pp expr)
	  }
	  add result (join '}' newline)
	}
	add result newline
  }
  return (joinStrings result)
}

// Class exporting

method defStringForFunctionsDefinedInClass Class {
  // For class export. Return a string containing the definition of
  // any shared functions included in this class's scripting area.

  result = (list)
  pp = (new 'PrettyPrinter')
  for fName (functionsDefinedInClass this) {
	add result (prettyPrintFunction pp (functionNamed fName))
	add result (newline)
  }
  return (joinStrings result)
}

method specStringForFunctionsAndMethodsDefinedInClass Class {
  // Return a string containing the specs for all methods of this class
  // plus any shared functions included in its scripting area.

  newline = (newline)
  result = (list)
  for m methods {
	spec = (specForOp (authoringSpecs) (functionName m))
	if (notNil spec) {
	  add result (specDefinitionString spec className)
	}
  }
  for fName (functionsDefinedInClass this) {
	spec = (specForOp (authoringSpecs) fName)
	add result (specDefinitionString spec)
  }
  add result (newline)
  return (joinStrings result (newline))
}

method functionsDefinedInClass Class {
  // Return a list of names for all functions defined in this class.

  result = (list)
  for entry scripts {
	expr = (at entry 3)
	if (and (isClass expr 'Command') ('to' == (primName expr))) {
	  add result (first (argList expr))
	}
  }
  return result
}
// Browse a single GP class

defineClass ClassBrowser morph window viewedClass fields fieldsFrame methods methodsFrame scripts scriptsFrame currentFunction editedFunction wasEdited

to browseClass aClass methodName {
  if ('<primitive>' == aClass) {
    showPrimitive (newSystemPalette) methodName
    return
  }
  page = (global 'page')
  brs = (newClassBrowser)
  setPosition (morph brs) (x (hand page)) (y (hand page))
  addPart page brs
  if ('<generic>' == aClass) {
    aClass = (globalBlocksName brs)
  }
  if (aClass == (globalBlocksName brs)) {
    browse brs (globalBlocksName brs) (functionNamed methodName (topLevelModule))
  } (notNil aClass) {
    if (isClass aClass 'String') { aClass = (class aClass) }
    browse brs aClass (methodNamed aClass methodName)
  }
}

to newClassBrowser {
  return (initialize (new 'ClassBrowser'))
}

method initialize ClassBrowser {
  scale = (global 'scale')
  window = (window 'Class Browser')
  bg = (gray 240)
  morph = (morph window)
  setHandler morph this
  setMinExtent morph (scale * 300) (scale * 200)

  fields = (listBox (array) (action 'fieldRepresentation' this) (action 'selectField' this) bg nil nil 230)
  fieldsFrame = (scrollFrame fields bg)
  addPart morph (morph fieldsFrame)

  methods = (listBox (array) 'blockForFunction' (action 'selectMethod' this) bg (action 'blockify' this) nil 230)
  methodsFrame = (scrollFrame methods bg)
  addPart morph (morph methodsFrame)

  scripts = (newScriptEditor 10 10)
  scriptsFrame = (scrollFrame scripts bg)
  addPart morph (morph scriptsFrame)

  wasEdited = false
  setExtent morph (scale * 400) (scale * 300)
  return this
}

method globalBlocksName ClassBrowser { return '<Global Blocks>' }

method classListName ClassBrowser aClass {
  if (aClass == (globalBlocksName this)) {return aClass}
  return (className aClass)
}

method sortedFunctions ClassBrowser {
  return (sorted (functions (topLevelModule)) (function f1 f2 { return ((functionName f1) < (functionName f2)) }))
}

method fixLayout ClassBrowser {
  fieldsWidth = (action 'spaceBoundedBy' window 350 30 (width morph))
  methodsWidth = (action 'width' (morph fieldsFrame))

  fixLayout window
  packer = (newPanePacker (clientArea window) ((border window) / (global 'scale')))
  packPanesH packer fieldsFrame fieldsWidth scriptsFrame 'rest'
  packPanesH packer methodsFrame methodsWidth scriptsFrame 'rest'
  packPanesV packer fieldsFrame '30%' methodsFrame 'rest'
  packPanesV packer scriptsFrame '100%'
  finishPacking packer
}

method redraw ClassBrowser {
  redraw window
  fixLayout this
}

method blockify ClassBrowser aFunction {
  page = (page morph)
  if (isNil (cmdList aFunction)) { return } // empty function
  block = (toBlock (cmdList aFunction))
  setPosition (morph block) (x (hand page)) (y (hand page))
  addPart page block
}

method browse ClassBrowser aClass methodOrName {
  selectMethod this nil
  viewedClass = aClass
  if (aClass == (globalBlocksName this)) {
    setLabelString window 'Global Variables and Blocks'
    setCollection fields (variableNames (sessionModule))
  } else {
    setLabelString window (join 'Class Browser: ' (className aClass))
    setCollection fields (fieldNames aClass)
  }
  setCollection methods (sortedMethods this aClass)
  if (notNil methodOrName) {
    if (isClass methodOrName 'String') {
      select methods (methodNamed aClass methodOrName)
    } else {
      select methods methodOrName
    }
    if (notNil (selectedMorph methods)) {
      scrollIntoView methodsFrame (bounds (selectedMorph methods))
    }
  }
}

method selectField ClassBrowser fieldName {
  if (shiftKeyDown (keyboard (handler (root morph)))) {
    unselectFields this
    return
  }
  setCollection methods (accessors this fieldName)
}

method unselectFields ClassBrowser {
  select fields nil
  mth = (array)
  if (notNil viewedClass) { mth = (sortedMethods this viewedClass) }
  setCollection methods mth
}

method accessors ClassBrowser fieldName {
  result = (list)
  for m (sortedMethods this viewedClass) {
    if (contains (varsUsed m) fieldName) {add result m}
  }
  return (toArray result)
}

method fieldRepresentation ClassBrowser fieldName {
  if (viewedClass == (globalBlocksName this)) {
    return (newReporter 'global' fieldName)
  }
  return (newReporter 'my' fieldName)
}

method sortedMethods ClassBrowser aClass {
  if (aClass == (globalBlocksName this)) {return (sortedFunctions this)}
  return (sorted (methods aClass) (function f1 f2 { return ((functionName f1) < (functionName f2)) }))
}

method selectMethod ClassBrowser aFunction {
  if wasEdited {
  msg = 'This function has been edited.
Save it?'
  if (confirm (page morph) 'Save Changes?' msg) {
      saveEditedFunction this
    }
  }
  currentFunction = aFunction
  editedFunction = nil
  if (notNil currentFunction) { editedFunction = (copy aFunction) }
  wasEdited = false
  refreshEditedFunction this
}

method refreshEditedFunction ClassBrowser {
  removeAllParts (morph scripts)
  if (isNil editedFunction) {return}
  block = (scriptForFunction editedFunction)
  setGrabRule (morph block)'ignore'
  setPosition (morph block) (left (morph scripts)) (top (morph scripts))
  off = ((global 'scale') * 10)
  moveBy (morph block) off off
  addPart (morph scripts) (morph block)
  frame = (handler (owner (morph scripts)))
  setPosition (morph scripts) (left (morph frame)) (top (morph frame))
  updateSliders frame
}

// field unselect

method handDownOn ClassBrowser hand {
  // Unselect the selected field, if any, if user clicks below the last field in fieldsFrame.

  if (containsPoint (bounds (morph fieldsFrame)) (x hand) (y hand)) { unselectFields this }
  return false
}

// top bar menu

method rightClicked ClassBrowser aHand {
  popUpAtHand (contextMenu this) (page aHand)
  return true
}

method contextMenu ClassBrowser {
  menu = (menu nil this)
  addItem menu 'find system block matching...' (action 'findBlock' (newSystemPalette))
  addItem menu 'find primitives matching...' (action 'findPrimitive' (newSystemPalette))
  return menu
}

// context menus

method handleContextRequest ClassBrowser origin {
  if (origin == fieldsFrame) {
    menu = (fieldListContextMenu this)
  } (origin == methodsFrame) {
    menu = (methodListContextMenu this)
  }
  if (notNil menu) {
    popUpAtHand menu (global 'page')
  }
}

method handleListContextRequest ClassBrowser anArray {
  origin = (first anArray)
  dta = (data (last anArray))
  if (origin == fields) {
    menu = (fieldContextMenu this dta)
  } (origin == methods) {
    menu = (methodContextMenu this dta)
  }
  if (notNil menu) {
    popUpAtHand menu (global 'page')
  }
}

method fieldListContextMenu ClassBrowser {
  menu = (menu nil this)
  if (notNil (selection fields)) {
    addLine menu
    addItem menu 'unselect' (action 'unselectFields' this)
  }
  return menu
}

method fieldContextMenu ClassBrowser fieldName {
  menu = (menu nil this)
  addBlock this (toBlock (fieldRepresentation this fieldName)) menu
  if (notNil (selection fields)) {
    addItem menu 'unselect' (action 'unselectFields' this)
  }
  return menu
}

method methodListContextMenu ClassBrowser {
  menu = (menu nil this)
  if (notNil viewedClass) {
    addItem menu 'make a block...' 'makeNewBlock' (join 'add a new method to class ' (classListName this viewedClass))
  }
  return menu
}

method methodContextMenu ClassBrowser aFunction {
  menu = (menu nil this)
  addBlock this (blockForFunction aFunction) menu
  addItem menu 'delete...' (action 'deleteFunction' this aFunction viewedClass)
  addItem menu 'other implementations...' (action 'browseImplementors' this aFunction viewedClass)
  if (notNil viewedClass) {
    addLine menu
    addItem menu 'make a block...' 'makeNewBlock' (join 'add a new method to class ' (classListName this viewedClass))
  }
  return menu
}

method addBlock ClassBrowser aBlock menu {
  addItem menu (fullCostume (morph aBlock)) (action 'grab' this aBlock) 'pick up this block and use it in a script'
}

method grab ClassBrowser aBlock {
  h = (hand (global 'page'))
  setCenter (morph aBlock) (x h) (y h)
  grab h aBlock
}

method makeNewBlock ClassBrowser {
  page = (global 'page')
  if (isNil viewedClass) {return}
  name = (prompt page 'Enter a new block name:' 'myBlock')
  if (name == '') {return}
  if (viewedClass == (globalBlocksName this)) {
    for f (functions (topLevelModule)) {
      if (name == (functionName f)) {
        inform page (join 'a global block named' (newline) name (newline)'already exists')
        return
      }
    }
    func = (defineFunctionInModule (topLevelModule) name)
    setCollection methods (sortedFunctions this)
  } else {
    for f (methods viewedClass) {
      if (name == (functionName f)) {
        inform page (join 'a block named' (newline) name (newline) 'already exists in class' (newline) (className viewedClass))
        return
      }
    }
    func = (addMethod viewedClass name)
    spec = (blockSpecFromStrings name ' ' (join name ' _') (className viewedClass))
    setCollection methods (sortedMethods this viewedClass)
  }
  select methods func
  scrollIntoView methodsFrame (bounds (selectedMorph methods))
}

method deleteFunction ClassBrowser method class {
  if (viewedClass == (globalBlocksName this)) {
    if (confirm (global 'page') nil (join 'Are you sure you want to delete the global block named' (newline) (functionName method) '?')) {
      remove (globalFuncs) (functionName method)
      if (method == (selection methods)) {
        select methods nil
        selectMethod this nil
      }
      setCollection methods (sortedMethods this class)
    }
  } else {
    if (confirm (global 'page') nil (join 'Are you sure you want to delete the block named' (newline) (functionName method) (newline) (join 'from class ' (classListName this class) '?'))) {
      removeMethodNamed class (functionName method)
      if (method == (selection methods)) {
        select methods nil
        selectMethod this nil
      }
      setCollection methods (sortedMethods this class)
    }
  }
}

method browseImplementors ClassBrowser method class {
  name = (functionName method)
  implementors = (implementors name)
  others = (list)
  if (isClass viewedClass 'Class') { selectedClassName = (className viewedClass) }
  for each implementors {
    if (each != selectedClassName) {add others each}
  }
  if (isEmpty others) {
    inform (global 'page') (join name (newline) 'is not implemented' (newline) 'anywhere else')
    return
  }
  menu = (menu (join 'other implementations of' (newline) name) (action 'openBrowserOnOtherImplementation' this name) true) // reverse call
  for each others {
    addItem menu (join each '...') each
  }
  popUpAtHand menu (global 'page')
}

method openBrowserOnOtherImplementation ClassBrowser functionName aClassName {
  browseClass aClassName functionName
}

// reflect user edits

method wasEdited ClassBrowser { return wasEdited }

method functionBodyChanged ClassBrowser {
  wasEdited = true
}

method saveEditedFunction ClassBrowser {
  setField currentFunction 'argNames' (argNames editedFunction)
  updateCmdList currentFunction (cmdList editedFunction)
  editedFunction = (copy currentFunction)
  wasEdited = false
  for item (parts (morph methods)) {
    meth = (data (handler item))
    if (meth == currentFunction) {
      (replaceCostumes (handler item) nil nil nil)
      refresh (handler item)
      if (currentfunction == (selection methods)) {
        selectMethod this currentFunction
      }
    }
  }
  selectMethod this currentFunction
}

method revertEditedFunction ClassBrowser {
  wasEdited = false
  selectMethod this currentFunction
}

// serialization

method preSerialize ClassBrowser { preSerialize scripts }
method postSerialize ClassBrowser { postSerialize scripts }
defineClass CloudDataServer userNames server

// start (new 'CloudDataServer')

to cloudDataHost {
  if (notNil (global 'cloudDataHost')) { return (global 'cloudDataHost') }
//  return '208.82.117.98'
//  return '127.0.0.1'
  return '104.236.119.50' // digial ocean
}

to cloudDataPort { return 2002 }

to putData user key data compressFlag {
  if (isNil data) { return }
  blob = (write (new 'Serializer') data)
  if compressFlag { blob = (deflate blob) }
  msg = (newRemoteMessage 'put' user key)
  add (blobs msg) blob
  callServer msg (cloudDataHost) (cloudDataPort)
}

to getData user key decompressFlag {
  msg = (newRemoteMessage 'get' user key)
  reply = (callServer msg (cloudDataHost) (cloudDataPort))
  if (and (notNil reply) ((count (blobs reply)) > 0)) {
	blob = (first (blobs reply))
	if decompressFlag { blob = (inflate blob) }
	return (read (new 'Serializer') blob)
  }
  return nil
}

to getDataServerStats {
  msg = (newRemoteMessage 'stats')
  reply = (callServer msg (cloudDataHost) (cloudDataPort))
  if (isNil reply) { return nil }
  return (args reply)
}

method start CloudDataServer port {
  if (isNil port) { port = 2002 }
  collectUserNames this
  server = (newMessageServer (action 'handleMessage' this) port)
  startServer server
}

method collectUserNames CloudDataServer {
  userNames = (list)
  for n (listDirectories 'cloudServer') {
	if (not (beginsWith n '.')) { add userNames n }
  }
  print 'Registered users:' userNames
}

method handleMessage CloudDataServer msg connection {
  cmd = (command msg)
//  print (dateString) cmd (remoteAddress (socket connection))
  if ('get' == cmd) {
    response = (handleGet this msg)
  } ('put' == cmd) {
    response = (handlePut this msg)
  } ('stats' == cmd) {
    response = (handleStats this msg)
  } else {
	response = (newRemoteMessage 'unknownCommand' cmd)
  }
  sendFinalMessage connection response
}

method handleGet CloudDataServer msg {
  if ((count (args msg)) < 2) {
	return (newRemoteMessage 'notEnoughArguments' (command msg))
  }
  user = (at (args msg) 1)
  key = (at (args msg) 2)
  if (not (and (isClass user 'String') (isClass key 'String'))) {
	return (newRemoteMessage 'arguments must be strings')
  }
  user = (canonicalizedWord user)
  if (not (contains userNames user)) {
	return (newRemoteMessage 'unknownUser' user)
  }
  data = (readFile (join './cloudServer/' (safeFileName this user) '/' (safeFileName this key)) true)
  if (isNil data) {
	return (newRemoteMessage 'fileNotFound' key)
  }
  response = (newRemoteMessage 'ok')
  add (blobs response) data
  return response
}

method handlePut CloudDataServer msg {
  if (or ((count (args msg)) < 2) ((count (blobs msg)) < 1)) {
	return (newRemoteMessage 'notEnoughArguments' (command msg))
  }
  user = (at (args msg) 1)
  key = (at (args msg) 2)
  if (not (and (isClass user 'String') (isClass key 'String'))) {
	return (newRemoteMessage 'arguments must be strings')
  }
  user = (canonicalizedWord user)
  if (not (contains userNames user)) {
	return (newRemoteMessage 'unknownUser' user)
  }
  data = (at (blobs msg) 1)
  writeFile (join './cloudServer/' (safeFileName this user) '/' (safeFileName this key)) data
  return (newRemoteMessage 'ok')
}

method handleStats CloudDataServer msg {
  return (newRemoteMessage 'ok'
	'uptime' (timeSince (startSecs server))
	'connections' (connectionCount server)
	'requestCount' (requestCount server)
	'gcCount' (last (memStats)))
}

method safeFileName CloudDataServer s {
  result = (letters s)
  for i (count result) {
	ch = (at result i)
	if (or ('/' == ch) ('\' == ch)) { atPut result i '-' }
	if ('.' == ch) { atPut result i ',' }
  }
  return (joinStrings result)
}
// Color

defineClass Color r g b a

method red Color { return r }
method green Color { return g }
method blue Color { return b }
method alpha Color { return a }
method setAlpha Color newAlpha { if (isNil newAlpha) { a = 255 } else { a = newAlpha }}

to color r g b a {
  if (or (isNil r) (r < 0)) { r = 0 }
  if (or (isNil g) (g < 0)) { g = 0 }
  if (or (isNil b) (b < 0)) { b = 0 }
  if (or (isNil a) (a > 255)) { a = 255 }
  r = (toInteger r)
  g = (toInteger g)
  b = (toInteger b)
  a = (toInteger a)
  if (r > 255) { r = 255 }
  if (g > 255) { g = 255 }
  if (b > 255) { b = 255 }
  if (a < 0) { a = 0 }
  return (new 'Color' r g b a)
}

to colorSwatch r g b a { return (color r g b a) }
to colorFromSwatch c { return c }

to gray level alpha {
  return (color level level level alpha)
}

to randomColor {
  return (new 'Color' (rand 0 255) (rand 0 255) (rand 0 255) 255)
}

to colorFrom aValue {
  a = ((aValue >> 24) & 255)
  r = ((aValue >> 16) & 255)
  g = ((aValue >> 8) & 255)
  b = ((aValue >> 0) & 255)
  return (new 'Color' r g b a)
}

to transparent {
  return (color 255 255 255 0)
}

// converting

method toString Color {
  if (a == 255) {
	if (and (g == r) (b == r)) {
	  return (join '(gray ' r ')')
	} else {
	  return (join '(color ' r ' ' g ' ' b ')')
	}
  }
  return (join '(color ' r ' ' g ' ' b ' ' a ')')
}

method pixelValue Color {
  return (| ((toLargeInteger (a & 255)) << 24) ((r & 255) << 16) ((g & 255) << 8) (b & 255))
}

method pixelRGB Color {
  return (+ ((r & 255) << 16) ((g & 255) << 8) (b & 255))
}

method inverted Color {
  // Return the RGB inverse of this color with the same alpha.
  return (color (255 - r) (255 - g) (255 - b) a)
}

// copying

method copy Color { return (new 'Color' r g b a) }
method withAlpha Color alpha { return (new 'Color' r g b (clamp (toInteger alpha)) 0 255) }

// mixing

method mixed Color percent otherColor {
  // Return a copy of this color mixed with another color.
  p2 = (100 - percent)
  return (color
    (((r * percent) + ((red otherColor) * p2)) / 100)
    (((g * percent) + ((green otherColor) * p2)) / 100)
    (((b * percent) + ((blue otherColor) * p2)) / 100)
  )
}

method lighter Color percent {
  // Return an rgb-interpolated lighter copy of this color.
  if (isNil percent) { percent = 20 }
  return (mixedPercentWithGray this percent 255)
}

method darker Color percent {
  // Return an rgb-interpolated lighter copy of this color.
  if (isNil percent) { percent = 30 }
  return (mixedPercentWithGray this percent 0)
}

method mixedPercentWithGray Color percent gray {
  percent = (clamp (round percent) 0 100)
  invPercent = (100 - percent)
  scaledGray = (percent * gray)
  return (new 'Color'
    (round (((r * invPercent) + scaledGray) / 100))
    (round (((g * invPercent) + scaledGray) / 100))
    (round (((b * invPercent) + scaledGray) / 100))
    a)
}

to colorHSV h s v alpha {
  // Return a color with the given hue, saturation, and brightness.

  if (isNil alpha) { alpha = 255 }
  h = (h % 360)
  if (h < 0) { h += 360 }
  s = (toFloat (clamp s 0 1))
  v = (toFloat (clamp v 0 1))

  i = (truncate (h / 60.0))
  f = ((h / 60.0) - i)
  p = (v * (1 - s))
  q = (v * (1 - (s * f)))
  t = (v * (1 - (s * (1 - f))))

  if (i == 0) {
    r = v; g = t; b = p
  } (i == 1) {
    r = q; g = v; b = p
  } (i == 2) {
    r = p; g = v; b = t
  } (i == 3) {
    r = p; g = q; b = v
  } (i == 4) {
    r = t; g = p; b = v
  } (i == 5) {
    r = v; g = p; b = q
  }
  a = (clamp (toInteger alpha) 0 255)
  return (new 'Color' (truncate (255 * r)) (truncate (255 * g)) (truncate (255 * b)) a)
}

method hue Color {
  if (a == 0) { return 0 }
  return (at (hsv this) 1)
}

method saturation Color {
  if (a == 0) { return 0 }
  return (at (hsv this) 2)
}

method brightness Color {
  if (a == 0) { return 0 }
  return (at (hsv this) 3)
}

method hsv Color {
  // Return an array containing the hue, saturation, and brightness for this color.

  min = (min r g b)
  max = (max r g b)
  if (max == min) { return (array 0 0 (max / 255.0)) } // gray; hue arbitrarily reported as zero
  if (r == min) {
    f = (g - b)
	i = 3
  } (g == min) {
    f = (b - r)
	i = 5
  } (b == min) {
    f = (r - g)
	i = 1
  }
  hue = ((60.0 * (i - ((toFloat f) / (max - min)))) % 360)
  sat = 0
  if (max > 0) { sat = ((toFloat (max - min)) / max) }
  bri = (max / 255.0)
  return (array hue sat bri)
}

method shiftHue Color n {
  hsv = (hsv this)
  newHue = ((at hsv 1) + n)
  return (colorHSV newHue (at hsv 2) (at hsv 3))
}

method shiftSaturation Color n {
  hsv = (hsv this)
  newSaturation = ((at hsv 2) + (n / 100.0))
  return (colorHSV (at hsv 1) newSaturation (at hsv 3))
}

method shiftBrightness Color n {
  hsv = (hsv this)
  newBrightness = ((at hsv 3) + (n / 100.0))
  return (colorHSV (at hsv 1) (at hsv 2) newBrightness)
}

// equality

method == Color other {
  return (and
	(isClass other 'Color')
    (r == (red other))
    (g == (green other))
    (b == (blue other))
    (a == (alpha other))
  )
}

method thumbnail Color w h {
  // Return a bitmap of the given dimensions and this color (for compatability with Bitmap).
  return (newBitmap w h this)
}
defineClass ColorPicker morph action paletteBM lastColor grayPalette colorPalette slider swatch rText gText bText

to newColorPicker action initialColor {
  // If there is already a ColorPicker on the screen, return it.
  // Otherwise, create and return a new one.

  for m (parts (morph (global 'page'))) {
	if (isClass (handler m) 'ColorPicker') {
      picker = (handler m)
	  setAction picker action
	  if (notNil initialColor) {
	    setField picker 'lastColor' initialColor
	    selectColor picker initialColor true
	  }
	  changed (morph picker)
	  return picker
	}
  }
  return (initialize (new 'ColorPicker') action initialColor)
}

method setAction ColorPicker anAction { action = anAction }

method initialize ColorPicker anAction initialColor {
  morph = (newMorph this)
  setGrabRule morph 'ignore'
  setCostume morph (drawFrame this 297 158)
  addGrayPalette this 10 10 200 10
  addColorPalette this 10 25 200 128
  addSlider this 220 25 10 128
  addSwatch this 240 25 50 50
  addTransparentButton this 244 141
  addCloseButton this 273 5
  addReadouts this 250 85
  action = anAction
  if (notNil initialColor) {
	lastColor = initialColor
	selectColor this initialColor true
  }
  return this
}

method drawOn ColorPicker ctx {
  r = (bounds morph)
  drawBitmap ctx (costumeData morph) (left r) (top r) // frame

  r = (bounds colorPalette)
  drawBitmap ctx (costumeData colorPalette) (left r) (top r)

  r = (bounds grayPalette)
  drawBitmap ctx (costumeData grayPalette) (left r) (top r)
}

method drawFrame ColorPicker w h {
  scale = (global 'scale')
  w = (w * scale)
  h = (h * scale)
  cornerRadius = (4 * scale)
  fillColor = (gray 200)
  border = (2 * scale)
  frameColor = (gray 100)
  bm = (newBitmap (w + (2 * border)) (h + (2 * border)))
  fillRoundedRect (newShapeMaker bm) (rect 0 0 (width bm) (height bm)) cornerRadius fillColor border frameColor frameColor
  return bm
}

method addGrayPalette ColorPicker x y w h {
  scale = (global 'scale')
  x = (x * scale)
  y = (y * scale)
  w = (w * scale)
  h = (h * scale)

  grayPalette = (newMorph this)
  bm = (newBitmap w h)
  for i w {
	// grayscale ramp with a few extra full black/full white pixels at the ends
    xOffset = (i - 10)
    c = (gray ((255 * xOffset) / (w - 20)))
    fillRect bm c (i - 1) 0 1 h
  }
  setCostume grayPalette bm
  setPosition grayPalette x y
  addPart morph grayPalette
}

method addColorPalette ColorPicker x y w h {
  scale = (global 'scale')
  x = (x * scale)
  y = (y * scale)
  w = (w * scale)
  h = (h * scale)

  paletteBM = (newBitmap w h) // cache of color palette at full brightness
  drawColorPalette this paletteBM 1

  colorPalette = (newMorph this)
  bm = (newBitmap w h)
  setCostume colorPalette bm
  setPosition colorPalette x y
  addPart morph colorPalette
}

method addSlider ColorPicker x y w h {
  scale = (global 'scale')
  x = (x * scale)
  y = (y * scale)
  w = (w * scale)
  h = (h * scale)

  slider = (slider 'vertical' h (action 'setBrightness' this) w 0 100 50)
  setPosition (morph slider) x y
  addPart morph (morph slider)
  slider changed
}

method addSwatch ColorPicker x y w h {
  scale = (global 'scale')
  x = (x * scale)
  y = (y * scale)
  w = (w * scale)
  h = (h * scale)

  swatch = (newMorph)
  setExtent swatch w h
  setPosition swatch x y
  setCostume swatch (gray 255)
  addPart morph swatch
}

method addTransparentButton ColorPicker x y {
  scale = (global 'scale')
  b = (pushButton 'Trans.' (gray 100) (action 'setTransparent' this))
  setPosition (morph b) (x * scale) (y * scale)
  addPart morph (morph b)
}

method setTransparent ColorPicker {
  if (notNil action) { call action (transparent) }
}

method addCloseButton ColorPicker x y {
  scale = (global 'scale')
  x = (x * scale)
  y = (y * scale)

  closeBtn = (pushButton 'X' (color 140 100 100) (action 'destroy' (morph this)))
  setPosition (morph closeBtn) x y
  addPart morph (morph closeBtn)
}

method addReadouts ColorPicker x y {
  scale = (global 'scale')
  x = ((left swatch) + (4 * scale))
  y = ((bottom swatch) + (10 * scale))
  fontSize = (13 * scale)
  rText = (newText 'R   0' 'Courier Bold' fontSize)
  gText = (newText 'G   0' 'Courier Bold' fontSize)
  bText = (newText 'B   0' 'Courier Bold' fontSize)
  setPosition (morph rText) x y
  setPosition (morph gText) x (y + (13 * scale))
  setPosition (morph bText) x (y + (26 * scale))
  addPart morph (morph rText)
  addPart morph (morph gText)
  addPart morph (morph bText)
}

method setBrightness ColorPicker n {
  n = (clamp (n / 100.0) 0 1)
  n = (1.0 - (n * n)) // use a quadratic function that spread out brighter end of range
  bm = (costumeData colorPalette)
  fill bm (gray 0)
  alpha = (clamp (toInteger (255 * n)) 0 255)
  drawBitmap bm paletteBM 0 0 alpha
  setCostume colorPalette bm
  if (notNil lastColor) {
	c = (colorHSV (hue lastColor) (saturation lastColor) (alpha / 255))
	selectColor this c false
  }
}

method handDownOn ColorPicker aHand {
  x = (x aHand)
  y = (y aHand)
  if (or (containsPoint (bounds grayPalette) x y)
		 (containsPoint (bounds colorPalette) x y)) {
	focusOn aHand this
	handMoveFocus this aHand
  } else {
	grab aHand this
  }
  return true
}

method handMoveFocus ColorPicker aHand {
  bm = (takeSnapshotWithBounds (morph (global 'page')) (rect (handX) (handY) 1 1))
  lastColor = (getPixel bm 0 0)
  selectColor this lastColor true
}

method selectColor ColorPicker c updateSlider {
  setCostume swatch c
  updateRGBReadouts this c
  if updateSlider { setValue slider (100.0 * (sqrt (1.0 - (brightness c)))) }
  if (notNil action) { call action c }
  changed morph
}

method updateRGBReadouts ColorPicker c {
  setText rText (join 'R ' (leftPadded (toString (red c)) 3 '0'))
  setText gText (join 'G ' (leftPadded (toString (green c)) 3 '0'))
  setText bText (join 'B ' (leftPadded (toString (blue c)) 3 '0'))
}

method drawColorPalette ColorPicker bm brightness {
  w = (width bm)
  h = (height bm)
  pixels = (getField bm 'pixelData')
  for x w {
    for y h {
	  hue = ((toFloat (360 * x)) / w)
	  sat = ((toFloat y) / h)
	  setBitmapHSV this pixels ((w * (y - 1)) + x) hue sat brightness
	}
  }
}

method setBitmapHSV ColorPicker pixelData pixelIndex h s v {
  // Optimized version of colorHSV for building a color palette (2x faster).
  // Assumes h, s, v are floats in ranges 0..360 (h) and 0..1 (s and v).

  h = (h % 360.0)
  i = (truncate (h / 60.0)) // integer 0..5
  f = ((h / 60.0) - i) // fractional part
  p = (v * (1 - s))
  q = (v * (1 - (s * f)))
  t = (v * (1 - (s * (1 - f))))

  if (i == 0) {
    r = v; g = t; b = p
  } (i == 1) {
    r = q; g = v; b = p
  } (i == 2) {
    r = p; g = v; b = t
  } (i == 3) {
    r = p; g = q; b = v
  } (i == 4) {
    r = t; g = p; b = v
  } (i == 5) {
    r = v; g = p; b = q
  }
  setPixelRGBA pixelData pixelIndex (truncate (255 * r)) (truncate (255 * g)) (truncate (255 * b)) 255
}
// editable color slot for blocks

defineClass ColorSlot morph contents

to newColorSlot {
  return (initialize (new 'ColorSlot'))
}

method initialize ColorSlot {
  morph = (newMorph this)
  setHandler morph this
  setGrabRule morph 'defer'
  setTransparentTouch morph true
  contents = (color 35 190 30)
  size = (16 * (blockScale))
  setExtent morph size size
  return this
}

method contents ColorSlot { return contents }

method setContents ColorSlot aColor {
  if (isNil aColor) { aColor = (color 35 190 30) }
  if (isClass aColor 'Integer') {
  	aColor = (color ((aColor >> 16) & 255) ((aColor >> 8) & 255) (aColor & 255))
  } (not (isClass aColor 'Color')) {
	aColor = (color 255 0 255)
  }
  contents = aColor
  changed morph
  raise morph 'inputChanged' this
}

method drawOnSquare ColorSlot ctx {
	borderWidth = (blockScale)
	r = (bounds morph)
	sm = (getShapeMaker ctx)
 	fillRectangle sm r contents
 	outlineRectangle sm r borderWidth (gray 80)
}

method drawOn ColorSlot ctx {
	borderWidth = (blockScale)
	r = (bounds morph)
	radius = (half (width r))
	drawCircle (getShapeMaker ctx) (hCenter r) (vCenter r) radius contents borderWidth (gray 0)
}

// events

method clicked ColorSlot aHand {
  if (notNil (ownerThatIsA morph 'InputDeclaration')) { return }
  page = (global 'page')
  cp = (newColorPicker (action 'setContents' this) contents)
  setPosition (morph cp) (left morph) ((bottom morph) + (2 * (global 'scale')))
  keepWithin (morph cp) (bounds (morph page))
  addPart page cp
  return true
}

// keyboard accessibility hooks

method trigger ColorSlot {
  clicked this
}
// Command and Reporter

defineClass Command primName lineno fileName cache cachedClassID nextBlock

method primName Command { return primName }
method nextBlock Command { return nextBlock }
method fileName Command { return fileName }
method lineno Command { return lineno }
method toString Command { return (join '<Commmand ' primName '>') }

method eval Command obj module {
  func = (functionFor obj this)
  if (notNil module) { setField func 'module' module }
  return (call func)
}

to newCommand op {
  comment '
	Create a commmand for the given operation. Any additional arguments
	are used as the arguments of the new command.'

  fixedFields = (fieldNameCount (class 'Command'))
  nargs = ((argCount) - 1)
  cmd = (newIndexable 'Command' nargs)
  setField cmd 'primName' op
  setField cmd 'lineno' 1
  setField cmd 'fileName' ''
  for i nargs {
    setField cmd (fixedFields + i) (arg (i + 1))
  }
  return cmd
}

method toReporter Command {
  result = (newIndexable 'Reporter' ((count this) - (fieldNameCount (classOf this))))
  for i (count this) {
    arg = (getField this i)
	if (or (isClass arg 'Command') (isClass arg 'Reporter')) {
	  setField result i (copy arg)
	} else {
      setField result i arg
	}
  }
  return result
}

method isControlStructure Command {
  // Return true if this is a command list or has a command list as an argument.

  if (notNil nextBlock) { return true }
  if (isOneOf primName 'if' 'repeat' 'while' 'for' 'animate' 'waitUntil' 'return' 'uninterruptedly') {
  	return true
  }
  for arg (argList this) {
    if (isClass arg 'Command') { return true }
  }
  return false
}

method copy Command {
  result = (clone this)
  clearCache result
  last = (count this)
  i = (fieldNameCount (classOf this)) // i is index of 'nextBlock' field
  while (i <= last) {
    arg = (getField this i)
	if (or (isClass arg 'Command') (isClass arg 'Reporter')) {
	  setField result i (copy arg)
	}
	i += 1
  }
  return result
}

method clearCache Command {
  cache = nil
  cachedClassID = nil
}

method allBlocks Command result {
  if (isNil result) { result = (list) }
  add result this
  for arg (argList this) {
    if (isAnyClass arg 'Command' 'Reporter') { allBlocks arg result }
  }
  allBlocks nextBlock result
  return result
}

to allBlocks Nil result {
  if (isNil result) { result = (list) }
  return result
}

// equality

method '==' Command other {
  if (this === other) { return true }
  if (not (isClass other 'Command')) { return false }
  if (primName != (primName other)) { return false }
  if (nextBlock != (nextBlock other))  { return false }
  if ((count this) != (count other)) { return false }

  // compare arg lists
  fixedFields = (fieldNameCount (class 'Command'))
  nargs = ((count this) - fixedFields)
  for i nargs {
	argIndex = (fixedFields + i)
    if ((getField this argIndex) != (getField other argIndex)) { return false }
  }
  return true
}

// serialization

method serializedFieldNames Command { return (array 'primName' 'nextBlock') }

method serialize Command {
  fixedFields = (fieldNameCount (classOf this))
  nargs = ((count this) - fixedFields)
  result = (newArray (nargs + 2))
  atPut result 1 primName
  atPut result 2 nextBlock
  for i nargs {
    atPut result (i + 2) (getField this (fixedFields + i))
  }
  return result
}

method deserialize Command fieldNames extraFields {
  fileName = ''
  lineno = 1
  primName = (at fieldNames 'primName')
  nextBlock = (at fieldNames 'nextBlock')
  fixedFields = (fieldNameCount (classOf this))
  for i (count extraFields) {
    setField this (fixedFields + i) (at extraFields i)
  }
  return this
}

defineClass Reporter primName lineno fileName cache cachedClassID nextBlock

method primName Reporter { return primName }
method nextBlock Reporter { return nextBlock }
method fileName Reporter { return fileName }
method lineno Reporter { return lineno }
method toString Reporter { return (join '<Reporter ' primName '>') }
method toReporter Reporter { return this }

method eval Reporter obj module {
  if (isControlStructure this) {
	return (eval (toCommand this) obj module)
  }
  return (eval (newCommand 'return' this) obj module)
}

to newReporter op {
  comment '
	Create a reporter for the given operation. Any additional arguments
	are used as the arguments of the new reporter.'

  fixedFields = (fieldNameCount (class 'Reporter'))
  nargs = ((argCount) - 1)
  rep = (newIndexable 'Reporter' nargs)
  setField rep 'primName' op
  setField rep 'lineno' 1
  setField rep 'fileName' ''
  for i nargs {
    setField rep (fixedFields + i) (arg (i + 1))
  }
  return rep
}

method toCommand Reporter {
  result = (newIndexable 'Command' ((count this) - (fieldNameCount (classOf this))))
  for i (count this) {
    arg = (getField this i)
	if (or (isClass arg 'Command') (isClass arg 'Reporter')) {
	  setField result i (copy arg)
	} else {
      setField result i arg
	}
  }
  return result
}

method isControlStructure Reporter {
  // Return true if this is a command list or has a command list as an argument.

  if (notNil nextBlock) { return true }
  if (isOneOf primName 'if' 'repeat' 'while' 'for' 'animate' 'waitUntil' 'return' 'uninterruptedly') {
  	return true
  }
  for arg (argList this) {
    if (isClass arg 'Command') { return true }
  }
  return false
}

method copy Reporter {
  result = (clone this)
  clearCache result
  last = (count this)
  i = (fieldNameCount (classOf this)) // i is index of 'nextBlock' field
  while (i <= last) {
    arg = (getField this i)
	if (or (isClass arg 'Command') (isClass arg 'Reporter')) {
	  setField result i (copy arg)
	}
	i += 1
  }
  return result
}

method clearCache Reporter {
  cache = nil
  cachedClassID = nil
}

method allBlocks Reporter result {
  if (isNil result) { result = (list) }
  add result this
  for arg (argList this) {
    if (isAnyClass arg 'Command' 'Reporter') { allBlocks arg result }
  }
  allBlocks nextBlock result
  return result
}

// equality

method '==' Reporter other {
  if (this === other) { return true }
  if (not (isClass other 'Reporter')) { return false }
  if (primName != (primName other)) { return false }
  if (nextBlock != (nextBlock other))  { return false }
  if ((count this) != (count other)) { return false }

  // compare arg lists
  fixedFields = (fieldNameCount (class 'Reporter'))
  nargs = ((count this) - fixedFields)
  for i nargs {
	argIndex = (fixedFields + i)
    if ((getField this argIndex) != (getField other argIndex)) { return false }
  }
  return true
}

// serialization

method serializedFieldNames Reporter { return (array 'primName') }

method serialize Reporter {
  fixedFields = (fieldNameCount (classOf this))
  nargs = ((count this) - fixedFields)
  result = (newArray (nargs + 1))
  atPut result 1 primName
  for i nargs {
    atPut result (i + 1) (getField this (fixedFields + i))
  }
  return result
}

method deserialize Reporter fieldNames extraFields {
  fileName = ''
  lineno = 1
  primName = (at fieldNames 'primName')
  fixedFields = (fieldNameCount (classOf this))
  for i (count extraFields) {
    setField this (fixedFields + i) (at extraFields i)
  }
  return this
}

// arguments

to argList cmdOrReporter {
  comment '
	Return the argument list of the given command or reporter.'

  fixedFields = (fieldNameCount (class 'Command'))
  nargs = ((count cmdOrReporter) - fixedFields)
  if (nargs <= 0) { return (array) }
  result = (newArray nargs)
  for i nargs {
    atPut result i (getField cmdOrReporter (fixedFields + i))
  }
  return result
}

to setArg cmdOrReporter n val {
  fixedFields = (fieldNameCount (class 'Command'))
  i = (fixedFields + n)
  if (or (i < 1) (i > (count cmdOrReporter))) { return } // shouldn't happen
  setField cmdOrReporter (fixedFields + n) val
}
// C-shaped block slots

defineClass CommandSlot morph corner color

to newCommandSlot color nestedBlock {
  result = (new 'CommandSlot')
  initialize result color nestedBlock
  fixLayout result
  return result
}

method initialize CommandSlot blockColor nestedBlock {
  corner = 3
  color = blockColor
  morph = (newMorph this)
  setTransparentTouch morph false
  if (isNil nestedBlock) { return }
  addPart morph (morph nestedBlock)
}

method drawOn CommandSlot ctx { } // do nothing

method fixLayout CommandSlot {
  scale = (blockScale)

  nested = (nested this)
  if (isNil nested) {
	h = (scale * 16)
  } else {
	insetX = (+ (left morph) (scale * 5) 0)
	if (scale < 3) { insetX += 1 }
	insetY = (+ (top morph) scale 0)
    fixLayout nested // fix layout of nested blocks before computing height
    h = (+ (scale * corner) (height (fullBounds (morph nested))))
    setPosition (morph nested) (floor insetX) (floor insetY)
  }
  w = (30 * scale)
  setExtent morph w h
  layoutChanged this
}

// accessing

method scaledCorner CommandSlot {
  return (corner * (blockScale))
}

method contents CommandSlot {
  nst = (nested this)
  if (notNil nst) {return (expression nst)}
  return nil
}

method setContents CommandSlot obj {nop} // only used for 'command' type input slot declarations

// stacking

method nested CommandSlot {
  if ((count (parts morph)) == 0) {return nil}
  return (handler (at (parts morph) 1))
}

method setNested CommandSlot aBlock {
  if (notNil aBlock) {removeHighlight (morph aBlock)}
  n = (nested this)
  if (notNil n) {remove (parts morph) (morph n)}
  if (notNil aBlock) {
    addPart morph (morph aBlock)
    if (notNil n) {setNext (bottomBlock aBlock) n}
  }
  fixLayout this
  raise morph 'inputChanged' this
  raise morph 'blockStackChanged' this
}

method topBlock CommandSlot {
  t = (handler (owner morph))
  if (not (isClass t 'Block')) { return this }
  return (topBlock t)
}

method stackList CommandSlot {
  nested = (nested this)
  if (isNil nested) {return (list)}
  return (stackList nested)
}

// events

method scriptChanged CommandSlot aBlock {
  layoutChanged this
  if (isClass (handler (owner morph)) 'Block') {
	scriptChanged (handler (owner morph))
  }
}

method layoutChanged CommandSlot {
  if (notNil (owner morph)) {
	owningBlock = (handler (owner morph))
	if (isClass owningBlock 'Block') { layoutChanged owningBlock }
  }
}

method expressionChanged CommandSlot changedBlock {
  parent = (handler (owner morph))
  if (and (changedBlock == (nested this)) (isClass parent 'Block')) {
    setArg (expression parent) (inputIndex parent this) (expression changedBlock)
    return
  }
  raise morph 'expressionChanged' changedBlock
}
// Float32Array and UInt32Array

defineClass Float32Array data

to float32Array args... {
  data = (newBinaryData (4 * (argCount)))
  for i (argCount) {
    float32AtPut data ((4 * i) - 3) (arg i)
  }
  return (new 'Float32Array' data)
}

method at Float32Array index {
  return (float32At data ((4 * (index - 1)) + 1))
}

method atPut Float32Array index value {
  float32AtPut data ((4 * (index - 1)) + 1) value
}

method count Float32Array {
  return ((byteCount data) / 4)
}

// converting

to toFloat32Array aCollection {
  data = (newBinaryData (4 * (count aCollection)))
  for i (count aCollection) {
    float32AtPut data ((4 * i) - 3) (at aCollection i)
  }
  return (new 'Float32Array' data)
}

method toArray Float32Array {
  result = (newArray (count this))
  for i (count this) { atPut result i (at this i) }
  return result
}

method toString Float32Array {
  list = (list)
  add list '('
  for i (count this) {
    add list (toString (at this i))
    if (i < (count this)) {
       add list ' '
    }
  }
  add list ')'
  return (joinStringArray (toArray list))
}

// UInt32Array

defineClass UInt32Array data

method at UInt32Array index {
  return (uint32At data ((4 * (index - 1)) + 1))
}

method atPut UInt32Array index value {
  uint32AtPut data ((4 * (index - 1)) + 1) value
}

method count UInt32Array {
  return ((byteCount data) / 4)
}

method join UInt32Array otherArray {
  if ((classOf otherArray) != (classOf this)) {error 'data class mismatch'}
  otherData = (getField otherArray 'data')
  newData = (newBinaryData ((byteCount data) + (byteCount otherData)))
  replaceByteRange newData 1 (byteCount data) data
  replaceByteRange newData ((byteCount data) + 1) (byteCount newData) otherData
  return (new (classOf this) newData)
}

method fillArray UInt32Array val startIndex endIndex {
  if (isNil startIndex) {startIndex = 1}
  if (isNil endIndex) {endIndex = ((byteCount data) / 4)}
  for i ((endIndex - startIndex) + 1) {
    atPut this ((i + startIndex) - 1) val
  }
}

// converting

to toUInt32Array aCollection {
  data = (newBinaryData (4 * (count aCollection)))
  for i (count aCollection) {
    uint32AtPut data ((4 * i) - 3) (at aCollection i)
  }
  return (new 'UInt32Array' data)
}

method toArray UInt32Array {
  result = (newArray (count this))
  for i (count this) { atPut result i (at this i) }
  return result
}

method toString UInt32Array {
  list = (list)
  add list '('
  for i (count this) {
    add list (toString (at this i))
    if (i < (count this)) {
       add list ' '
    }
  }
  add list ')'
  return (joinStringArray (toArray list))
}
// DataStream - streaming interface to binary data

defineClass DataStream data position bigEndian

method data DataStream { return data }
method position DataStream { return position }
method remaining DataStream { return ((byteCount data) - position) }
method setPosition DataStream n { position = (clamp n 0 (byteCount data)) }
method bigEndian DataStream { return bigEndian }

to dataStream data bigEndian {
  if (isNil bigEndian) { bigEndian = false }
  return (new 'DataStream' data 0 bigEndian)
}

method atEnd DataStream {
  return (position >= (byteCount data))
}

method skip DataStream n {
  position += n
  if (position < 0) { position = 0 }
}

method nextInt8 DataStream {
  result = (nextUInt16 this)
  if (result > 127) { result += -256 }
  return result
}

method nextUInt8 DataStream {
  position += 1
  result = (byteAt data position)
  return result
}

method nextInt16 DataStream {
  result = (nextUInt16 this)
  if (result > 32767) { result += -65536 }
  return result
}

method nextUInt16 DataStream {
  if bigEndian {
   b1 = (byteAt data (position + 1))
   b2 = (byteAt data (position + 2))
  } else {
   b2 = (byteAt data (position + 1))
   b1 = (byteAt data (position + 2))
  }
  position += 2
  return ((b1 << 8) | b2)
}

method nextInt DataStream {
  // Assumes value fits into a 31-bit GP Integer object. See nextUInt32.
  result = (intAt data (position + 1) bigEndian)
  position += 4
  return result
}

method nextUInt32 DataStream {
  // Returns a LargeInteger if result does not fit into a GP Integer.
  result = (uint32At data (position + 1) bigEndian)
  position += 4
  return result
}

method nextFloat32 DataStream {
  result = (float32At data (position + 1) bigEndian)
  position += 4
  return result
}

method nextData DataStream byteCount {
  result = (newBinaryData byteCount)
  replaceByteRange result 1 byteCount data (position + 1)
  position += byteCount
  return result
}

method nextString DataStream byteCount {
  return (toString (nextData this byteCount))
}

method nextNullTerminatedString DataStream { return (nextStringUpTo this 0) }

method nextStringUpTo DataStream terminator {
  // Return a string consisting of the bytes up to the given terminator byte
  // or stream end. The terminator is consumed, but not included in the result.

  bytes = (list)
  while (not (atEnd this)) {
	ch = (nextUInt8 this)
	if (ch == terminator) {
	  return (toString (toBinaryData (toArray bytes)))
	}
	add bytes ch
  }
  return (toString (toBinaryData (toArray bytes)))
}

method putInt DataStream value {
  if ((position + 4) > (byteCount data)) { grow this }
  intAtPut data (position + 1) value bigEndian
  position += 4
}

method putUInt8 DataStream value {
  if ((position + 1) > (byteCount data)) { grow this }
  position += 1
  byteAtPut data position value
}

method putUInt16 DataStream value {
  if ((position + 2) > (byteCount data)) { grow this }
  if bigEndian {
	byteAtPut data (position + 1) ((value >> 8) & 255)
	byteAtPut data (position + 2) (value & 255)
  } else {
	byteAtPut data (position + 1) (value & 255)
	byteAtPut data (position + 2) ((value >> 8) & 255)
  }
  position += 2
}

method putUInt32 DataStream value {
  if ((position + 4) > (byteCount data)) { grow this }
  uint32AtPut data (position + 1) value bigEndian
  position += 4
}

method putFloat32 DataStream value {
  if ((position + 4) > (byteCount data)) { grow this }
  float32AtPut data (position + 1) value bigEndian
  position += 4
}

method nextPutAll DataStream stringOrData from to {
  if (isNil from) { from = 1 }
  if (isNil to) { to = (byteCount stringOrData) }
  newPos = (position + ((to - from) + 1))
  if (newPos > (byteCount data)) { grow this newPos }
  replaceByteRange data (position + 1) newPos stringOrData from
  position = newPos
}

method grow DataStream delta {
  if (isNil delta) { delta = (max 8 (byteCount data)) }
  newSize = ((byteCount data) + delta)
  newData = (newBinaryData newSize)
  replaceByteRange newData 1 (byteCount data) data
  data = newData
}

method contents DataStream {
  result = (newBinaryData position)
  replaceByteRange result 1 position data
  return result
}

method stringContents DataStream {
  return (stringFromByteRange data 1 position)
}
// Debugger - Can be used from either the command line or a morphic UI.

defineClass Debugger debugeeTask vars morph window reasonText reasonPane buttonsPane callsFrame codeFrame fileAndLineFrame varsFrame valueFrame originalCmds

method stack Debugger { return (stack debugeeTask) }

to debug {
  comment 'To debug the last error, make an debugger instance like this:
	  db = (debug)
	and invoke debugging commands on db (use "cmds db" to list the debugging commands).'

  if (isNil (debugeeTask)) {
	print 'There is no debugee task to debug.'
	return
  }
  db = (new 'Debugger' (debugeeTask))
  gc
  cmds db
  calls db
  if (notNil (global 'page')) { addPart (global 'page') db }
  return db
}

to printStackTrace aTask {
  if (isNil aTask) { aTask = (currentTask) }
  db = (new 'Debugger' aTask)
  calls db
}

method cmds Debugger {
  print 'Welcome to the GP debugger! Commands:'
  print '  cmds db - print this list of debugger commands'
  print '  calls db - print the call stack'
  print '  receiver db - returns the last receiver object'
  print '  arg db - returns the specified arg on the last frame'
  print '  show db [n] - show the N-th stack frame (frame 1 (the default) is the most recently called function)'
  print '  proceed db - continue from the point where execution was halted'
  print '  singleStep db - execute the next command and stop'
  print '  restart db n - restart the N-th function call'
  print '  showStack db - show the stack as a bunch of numbers (very low level)'
}

method calls Debugger {
  frames = (frameList this)
  b = (getField debugeeTask 'currentBlock')
  if (isNil b) {
    print 'Debuggee is done.'
    return
  }
  print '-------------'
  if (isEmpty frames) {
    print 'Top level.'
  }
  frameCount = (count frames)
  if (frameCount > 100) {
	print '(Big stack; showing only the last 100 frames)'
	startFrame = (frameCount - 100)
	for i (range startFrame (count frames)) {
	  printCall this (at frames i)
	}
  } else {
	for i (count frames) {
	  printCall this (at frames i)
	}
  }
  printCurrentBlock this
  print '-------------'
}

method show Debugger n {
  stack = (stack debugeeTask)
  frames = (frameList this)
  if ((count frames) == 0) {
    print 'No function calls on debugee stack.'
	return
  }
  if (isNil n) { n = 1 }
  n = (clamp n 1 (count frames))
  mp = (at frames n)
  print '-----' n '-----'
  printCall this mp

  func = (at stack (mp + 1))
  argNames = (argNames func)
  localNames = (localNames func)

  fp = (at stack (mp - 1))
  argCount = (((mp - fp) - 1) - (count localNames))
  if (argCount > 0) { print ' Arguments:' }
  for i argCount {
    arg = (at stack ((fp + i) - 1))
	if (i <= (count argNames)) {
	  print '  ' (at argNames i) ':' arg
    } else {
	  print '  ' i ':' arg
    }
  }

  localCount = (count localNames)
  if (localCount > 0) { print ' Locals:' }
  for i localCount {
    v = (at stack ((mp - i) - 1))
	print '  ' (at localNames i) ':' v
  }
  print '-------------'
}

method receiver Debugger {
  stack = (stack debugeeTask)
  if (isNil stack) { return nil }
  mp = (getField debugeeTask 'mp')
  fp = (at stack (mp - 1))
  return (at stack fp)
}

method arg Debugger n {
  if (isNil n) { n = 1 }
  stack = (stack debugeeTask)
  mp = (getField debugeeTask 'mp')
  if (0 == mp) {
	print 'No calls on stack.'
	return
  }
  fp = (at stack (mp - 1))
  func = (at stack (mp + 1))
  localNames = (localNames func)
  argCount = (((mp - fp) - 1) - (count localNames))
  if (or (n < 1) (n > argCount)) {
	print 'The argument index must be 1 to' argCount
	return
  }
  return (at stack (fp + (n - 1)))
}

method singleStep Debugger {
  resumeDebuggee this true
  calls this
}

method proceed Debugger {
  resumeDebuggee this
  calls this
}

method resumeDebuggee Debugger doSingleStep {
  setField debugeeTask 'waitReason' nil
  setField debugeeTask 'taskToResume' (currentTask)
  resume debugeeTask doSingleStep
}

method restart Debugger n {
  frames = (frameList this)
  if ((count frames) == 0) {
    print 'No function calls on debugee stack.'
	return
  }
  mp = (at frames n)
  func = (at (stack debugeeTask) (mp + 1))
  sp = (mp + 5)

  setField debugeeTask 'sp' sp
  setField debugeeTask 'fp' sp
  setField debugeeTask 'mp' mp
  setField debugeeTask 'currentBlock' true // must be non-nil
  setField debugeeTask 'nextBlock' (cmdList func)
  resumeDebuggee this
  calls this
}

method showStack Debugger {
  stack = (stack debugeeTask)
  sp = (getField debugeeTask 'sp')
  for i sp {
    print (join '' i ':') (carefulPrint this (at stack i))
  }
}

method printCurrentBlock Debugger {
  // Print the block that just executed (or failed).

  stack = (stack debugeeTask)
  b = (getField debugeeTask 'currentBlock')
  if (isNil b) { return }
  sp = (getField debugeeTask 'sp')
  i = (getField debugeeTask 'fp')
  out = (list '  -> ')
  add out (fileAndLine this b)
  add out (primName b)
  while (i < sp) {
    add out (join ' ' (carefulPrint this (at stack i)))
	i += 1
  }
  print (joinStrings out)
}

method printCall Debugger mp {
  // Print the call name, fileName and lineNumber, and arguments.
  print (callString this mp true)
}

method callString Debugger mp showFileAndLine {
  // Return a string containing the call name, fileName and lineNumber, and arguments.

  stack = (stack debugeeTask)
  b = (at stack (mp + 3))
  args = (argsForCall this mp)
  out = (list)
  if showFileAndLine { add out (fileAndLine this b) }
  add out (withUserSpec this (toString (primName b)))

  for i (count args) { add out (join ' ' (carefulPrint this (at args i))) }
  return (joinStrings out)
}

method withUserSpec Debugger op {
  editor = (findProjectEditor)
  if (notNil editor) {
	spec = (at (blockSpecs (project editor)) op)
	if (notNil spec) { return (first (specs spec)) }
  }
  return op
}

method fileAndLine Debugger b {
  return (join '(' (filePart (fileName b)) ':' (lineno b) ') ')
}

method argsForCall Debugger mp {
  // Argument list for the given method or function call frame.

  stack = (stack debugeeTask)
  func = (at stack (mp + 1))
  localNames = (localNames func)

  fp = (at stack (mp - 1))
  argCount = (((mp - fp) - 1) - (count localNames))
  args = (list)
  for i argCount { add args (at stack ((fp + i) - 1)) }
  return args
}

method carefulPrint Debugger obj {
  if (and (isClass obj 'String') ((byteCount obj) < 100)) { return obj }
  if (implements obj 'toString') { // don't trust object's toString method
    return (join '<' (className (classOf obj)) '>')
  }
  return (toString obj) // primitive toString
}

method frameList Debugger {
  // List of call frames (i.e. mp values) for the function/method call stack.

  stack = (stack debugeeTask)
  if (isNil stack) { return (array) }
  frames = (list)
  mp = (getField debugeeTask 'mp')
  while (mp > 1) {
    add frames mp
    mp = (at stack (mp + 2))
  }
  frames = (reversed (toArray frames))
  return frames
}

// Morphic UI support starts here

method morph Debugger {
  // Build the UI when the debugger is first added to a page.
  if (isNil morph) {
    buildUI this
    updateStack this
	calls this // print call stack in console
  }
  return morph
}

method buildUI Debugger {
  scale = (global 'scale')
  window = (window 'Debugger')
  morph = (morph window)
  setHandler morph this
  setFPS morph 1
  clr = (clientColor window)
  fontSize = 15

  reasonPane = (newBox nil (gray 250) nil nil false false)
  addPart morph (morph reasonPane)

  buttonsPane = (newBox nil (gray 250) nil nil false false)
  addPart morph (morph buttonsPane)

  reasonText = (newText 'Reason:' 'Arial' (scale * fontSize))
  setEditRule reasonText 'static'
  addPart morph (morph reasonText)

//   addPart (morph buttonsPane) (makeButton this 'Enter' 'doEnter')
//   addPart (morph buttonsPane) (makeButton this 'Exit' 'doExit')
  addPart (morph buttonsPane) (makeButton this 'Step' 'doStep')
  addPart (morph buttonsPane) (makeButton this 'Resume' 'doGo')

  lbox = (listBox (array) nil (action 'selectCall' this) clr)
  setFont lbox 'Arial' fontSize
  callsFrame = (scrollFrame lbox clr)
  addPart morph (morph callsFrame)

  codePane = (newScriptEditor 10 10)
  codeFrame = (scrollFrame codePane (gray 220))
  addPart morph (morph codeFrame)

  fileAndLineFrame = (makeDBTextBox this clr)
  setEditRule fileAndLineFrame 'static'
  addPart morph (morph fileAndLineFrame)

  lbox = (listBox (array) nil (action 'selectVar' this) clr (action 'inspectVar' this))
  setFont lbox 'Arial' fontSize
  varsFrame = (scrollFrame lbox clr)
  addPart morph (morph varsFrame)

  valueFrame = (scrollFrame (makeDBTextBox this) clr)
  addPart morph (morph valueFrame)

  setMinExtent morph (scale * 400) (scale * 300)
  setExtent morph (scale * 450) (scale * 500)
  setPosition morph 5 (scale * 25)
  if (notNil (global 'page')) {
	setXCenter morph (hCenter (bounds (morph (global 'page'))))
  }
}

// button actions

method doEnter Debugger { stepTask this }
method doExit Debugger { stepTask this (findMP this true) }
method doStep Debugger {
  if (shiftKeyDown (keyboard (global 'page'))) {
	stepTask this // enter
  } else {
	stepTask this (findMP this false)
  }
}

method doGo Debugger {
  page = (handler (root morph))
  destroy morph
  setField debugeeTask 'waitReason' nil
  setField debugeeTask 'taskToResume' nil
  addTask (getField page 'taskMaster') debugeeTask
}

method stepTask Debugger targetMP {
  timer = (newTimer)
  setField debugeeTask 'errorReason' nil
  resumeDebuggee this true
  if (notNil targetMP) {
	while ((getField debugeeTask 'mp') > targetMP) {
      resumeDebuggee this true
	  if ((msecs timer) > 2000) {
		updateStack this
		setText reasonText 'Step timed out. Looping?'
		return
	  }
    }
  }
  updateStack this
  updateSelectedVar this
}

method updateSelectedVar Debugger {
  varList = (contents varsFrame)
  selectedVar = (selection varList)
  if (and (notNil selectedVar) (contains (collection varList) selectedVar)) {
	select varList selectedVar
  } else {
	select varList nil
  }
}

method findMP Debugger forExit {
  frames = (frameList this)
  if (isEmpty frames) { return nil }
  callIndex = (selectionIndex (contents callsFrame))
  if (isNil callIndex) { callIndex = (count frames) }
  if forExit {
    if (callIndex <= 1) { return nil }
    callIndex += -1
  }
  return (at frames callIndex)
}

method updateStack Debugger {
  updateReason this
  calls = (list)
  frames = (frameList this)
  if ((count frames) > 100) {
	print 'Large stack; showing only the first 100 frames'
	frames = (copyFromTo frames 1 100)
	calls this // print call stack in console
  }
  b = nil
  if (notNil debugeeTask) { b = (getField debugeeTask 'currentBlock') }
  if (isNil b) {
    add calls 'Debuggee is done.'
  } (isEmpty frames) {
    add calls 'No calls on stack'
  } else {
    for i (count frames) {
      add calls (callString this (at frames i) false)
    }
  }
  callsList = (contents callsFrame)
  setCollection callsList calls
  if (not (isEmpty calls)) {
	select callsList (last calls)
  }
}

method updateReason Debugger {
  reason = (errorReason debugeeTask)
  stack = (stack debugeeTask)
  fp = (getField debugeeTask 'fp')
  sp = (getField debugeeTask 'sp')
  if (isNil reason) {
  	setText reasonText ''
  	return
  } ('Halted' == reason) {
	cmd = (getField debugeeTask 'currentBlock')
	if ('error' == (primName cmd)) { reason = 'Error' }
	if (sp > fp) {
	  reasonStrings = (list (join reason ':'))
	  for i (range (getField debugeeTask 'fp') ((getField debugeeTask 'sp') - 1)) {
		add reasonStrings (carefulPrint this (at stack i))
	  }
	  reason = (joinStrings reasonStrings ' ')
	}
  } (beginsWith reason 'Undefined function: ') {
	reason = (join (substring reason 21) ' is not defined')
	if (sp > fp) {
	  firstArg = (at stack fp)
	  reason = (join reason ' for ' firstArg)
	}
  } else {
	reason = (join 'Primitive failed: ' reason)
  }
  setText reasonText (join reason (newline) '(To ignore, just close this window by clicking on the "X".)')
}

method selectCall Debugger ignored {
  showCallIndex this (selectionIndex (contents callsFrame))
}

method showCallIndex Debugger callIndex {
  setCollection (contents varsFrame) (array)
//  select (contents varsFrame) nil
  setText (contents valueFrame) ''
  setText fileAndLineFrame ''

  scriptsPane = (morph (contents codeFrame))
  removeAllParts scriptsPane

  vars = (dictionary)
  allVarNames = (list)

  frames = (frameList this)
  if (isEmpty frames) { return }
  mp = (at frames callIndex)

  stack = (stack debugeeTask)
  func = (at stack (mp + 1))
  showCode this func callIndex
  argNames = (argNames func)
  localNames = (localNames func)

  fp = (at stack (mp - 1))
  rcvr = (at stack fp)
  argCount = (((mp - fp) - 1) - (count localNames))
  for i argCount {
	if (i <= (count argNames)) {
	  varName = (at argNames i)
    } else {
	  varName = (join 'arg' i)
    }
    varIndex = ((fp + i) - 1)
    atPut vars varName varIndex
    add allVarNames varName
  }
  for i (count localNames) {
	varName = (at localNames i)
	varIndex = ((mp - i) - 1)
	atPut vars varName varIndex
	add allVarNames varName
  }
  allVarNames = (sorted allVarNames)
  if (contains allVarNames 'this') {
	remove allVarNames 'this'
	addFirst allVarNames 'this'
  }
  setCodeContext (contents valueFrame) rcvr
  setCollection (contents varsFrame) allVarNames
  updateSelectedVar this
}

method showCode Debugger func callIndex {
  scriptsPane = (morph (contents codeFrame))
  removeAllParts scriptsPane
  scrollToX codeFrame 0
  scrollToY codeFrame 0

  originalCmds = (copy (cmdList func))
  blockList = (toBlock (cmdList func))
  if (== 'hat' (type blockList)) {
    hat = blockList
  } else {
    hat = (block 'hat' (color 140 0 140) 'define' (blockPrototypeForFunction func))
    setNext hat blockList
  }
  bnds = (bounds scriptsPane)
  setPosition (morph hat) ((left bnds) + 20) ((top bnds) + 20)
  addPart scriptsPane (morph hat)

  updateSliders codeFrame

  // highlight
  currentBlock = (getCurrentBlock this callIndex)
  for m (allMorphs (morph blockList)) {
    if (isClass (handler m) 'Block') {
      if (currentBlock === (expression (handler m))) {
        setField (handler m) 'color' (color 230 230 0)
        redraw (handler m)
        for each (parts m) {
          if (isClass (handler each) 'CommandSlot') {
            setField (handler each) 'color' (color 230 230 0)
            redraw (handler each)
          }
        }
      }
    }
  }

  // update file and line number
  s = 'NO BLOCK'
  if (notNil currentBlock) {
    s = (filePart (fileName currentBlock))
	if (isNil s) { s = '<prompt>' }
	if (endsWith s '.gp') { s = (substring s 1 ((count s) - 3)) }
    s = (join s ':' (lineno currentBlock))
  }
  setText fileAndLineFrame s
}

method getCurrentBlock Debugger callIndex {
  stack = (stack debugeeTask)
  sp = (getField debugeeTask 'sp')
  frames = (frameList this)
  if (callIndex >= (count frames)) {
	b = (getField debugeeTask 'currentBlock')
	if (and (isNil b) (sp > 2)) {
	  b = (at stack (sp - 2))
	  if (not (isAnyClass b 'Command' 'Reporter')) {
		b = (getField debugeeTask 'nextBlock')
	  }
	}
  } else {
    callerMP = (at frames (callIndex + 1))
    b = (at stack (callerMP + 3))
  }
  return b
}

method selectVar Debugger varName {
  stack = (stack debugeeTask)
  varValue = (at stack (at vars varName))
  setText (contents valueFrame) (toString varValue)
}

method inspectVar Debugger varName {
  stack = (stack debugeeTask)
  varValue = (at stack (at vars varName))
  ins = (inspectorOn varValue)
  page = (handler (root morph))
  setPosition (morph ins) (x (hand page)) (y (hand page))
  addPart (morph page) (morph ins)
}

method makeButton Debugger label selector {
  scale = (global 'scale')
  w = (scale * 65)
  h = (scale * 23)
  nbm = (buttonBody this label w h false)
  hbm = (buttonBody this label w h true)
  b = (new 'Trigger' nil (action selector this) nbm hbm hbm)
  setData b label
  setMorph b (newMorph b)
  setCostume (morph b) nbm
  setGrabRule (morph b) 'ignore'
  return (morph b)
}

method buttonBody Debugger label w h highlight {
  scale = (global 'scale')
  fillColor = (gray 230)
  borderColor = (gray 120)
  textColor = (gray 100)
  border = (scale * 1)
  radius = (scale * 4)
  if (true == highlight) {
    fillColor = (darker fillColor 15)
	textColor = (darker textColor 15)
  }
  bm = (newBitmap w h)
  fillRoundedRect (newShapeMaker bm) (rect 0 0 (width bm) (height bm)) radius fillColor border borderColor borderColor
  labelBM = (stringImage label 'Arial Bold' (scale * 14) textColor)
  x = ((w - (width labelBM)) / 2)
  y = ((h - (height labelBM)) / 2)
  drawBitmap bm labelBM x y
  return bm
}

method makeDBTextBox Debugger clr {
  textBox = (newText)
  setFont textBox nil ((global 'scale') * 15)
  setBorders textBox 5 5 true
  setEditRule textBox 'code'
  setGrabRule (morph textBox) 'ignore'
  if (notNil clr) { setColor textBox nil nil clr }
  return textBox
}

method redraw Debugger {
  fixLayout window
  redraw window
  fixLayout this
  fixButtonLayout this
}

method fixLayout Debugger {
  packer = (newPanePacker (clientArea window))
  packPanesH packer reasonPane '100%'
  packPanesH packer callsFrame 220 buttonsPane '100%'
  packPanesH packer callsFrame 220 codeFrame '100%'
  packPanesH packer fileAndLineFrame 220 valueFrame '100%'
  packPanesH packer varsFrame 220
  packPanesV packer reasonPane 40 callsFrame '100%' fileAndLineFrame 24 varsFrame 105
  packPanesV packer reasonPane 40 buttonsPane 37 codeFrame '100%' valueFrame 105
  finishPacking packer
  scale = (global 'scale')
  bnds = (bounds (morph window))
  setPosition (morph reasonText) ((left bnds) + (10 * scale)) ((top bnds) + (25 * scale))
}

method fixButtonLayout Debugger {
  buttons = (parts (morph buttonsPane))

  r = (bounds (morph buttonsPane))
  extraW = (width r)
  for b buttons { extraW += (- (width b)) }
  interButtonSpace = (max 5 (extraW / ((count buttons) + 1)))

  x = (+ (left r) interButtonSpace 1)
  y = ((top r) + ((global 'scale') * 7))
  for b buttons {
    setPosition b x y
	x += ((width b) + interButtonSpace)
  }
}

// code edit propagation

method step Debugger {
  // If the users has edited the current script, notify the ProjectEditor, if any.

  if (notNil originalCmds) {
	scriptsPane = (morph (contents codeFrame))
	hat = nil
	for m (parts scriptsPane) {
	  h = (handler m)
	  if (and (isClass h 'Block') ('hat' == (type h))) { hat = h }
	}
	if (and (notNil hat) (notNil (next hat))) {
	  body = (expression (next hat))
	  if (not (body == originalCmds)) {
		editor = (findProjectEditor)
		if (notNil editor) {
		  restoreScripts (scripter editor)
		}
		originalCmds = (copy body)
	  }
	}
  }
}
// Dictionary

defineClass Dictionary tally keys values

classComment Dictionary '
A Dictionary is a flexible data object that can be used:

  1. to associate names with values (use atPut/at with string keys)
  2. as a set of unique objects (use add/remove/contains)
  3. as a sparse array (use atPut/at with integer keys)
  4. as a histogram to record the number times a particular value occurs (use add/remove/sortedPairs)'

classComment Dictionary '
Implementation details: A Dictionary is repesented as a hash table.
Keys and values are kept in two parallel arrays, with values[i] being the
value associated with key[i]. When used as a set or histogram, the presence
of a key indicates inclusion of that key in the set and the value is the
number of times that key has been added.'

to dictionary args... {
  comment '
    Return a new Dictionary containing the given keys.'
  keys = (newArray 20)
  values = (newArray 20)
  result = (new 'Dictionary' 0 keys values)
  for i (argCount) { add result (arg i) }
  return result
}

method count Dictionary {
  comment '
	Return the number of items in this dictionary.'

	return tally
}

method contains Dictionary k {
  comment '
	Return true if this dictionary has an entry for the given key.'

  i = (scanForKeyOrNil this k)
  return (notNil (at keys i))
}

method at Dictionary k defaultValue {
  comment '
	Return the value associated with the given key or defaultValue
	if there is no entry for that key.'

  i = (scanForKeyOrNil this k)
  v = (at values i)
  if (isNil v) { return defaultValue }
  return v
}

method atPut Dictionary k v {
  comment '
	Add a key and value to this dictionary.'

  i = (scanForKeyOrNil this k)
  if (isNil (at keys i)) {
    atNewIndexPut this i k v
  } else {
    atPut values i v
  }
}

method add Dictionary k n {
  comment '
	Add the given key. This method allows a Dictionary be used like a set.
	Also, count how many times a given key has been added. This can be useful
	for building building histograms (e.g. the number of times the word
	"the" appears in set of words.) The optional second parameter allows
	the count for a key to be incremented by numbers other than one.'

  if (isNil n) { n = 1 }
  i = (scanForKeyOrNil this k)
  if (isNil (at keys i)) {
    newValue = n
  } else {
    newValue = ((at values i) + n)
  }
  atPut this k newValue
}

method addAll Dictionary elements {
  comment '
	Add the contents of the given dictionary, list, or array.'

  if (isClass elements 'Dictionary') {
    newKeys = (keys elements)
	for k (count newKeys) {
	  atPut this k (at elements k)
	}
  } else {
    if (not (or (isClass elements 'Array') (isClass elements 'List'))) {
      elements = (toArray elements)
    }
    for i (count elements) { add this (at elements i) }
  }
}

method remove Dictionary k {
  comment '
	Remove the given key and its associated value.'

  i = (scanForKeyOrNil this k)
  if (isNil (at keys i)) { return } // key not found
  atPut keys i nil
  atPut values i nil
  tally = (tally - 1)
  fixCollisions this i
}

method removeAll Dictionary elements {
  comment '
	Remove the contents of the given dictionary, list, or array.'

  if (isClass elements 'Dictionary') {
    elements = (keys elements)
  }
  if (not (or (isClass elements 'Array') (isClass elements 'List'))) {
    elements = (toArray elements)
  }
  for i (count elements) { remove this (at elements i) }
}

// converting

method copy Dictionary {
  result = (clone this)
  setField result 'keys' (copyArray keys)
  setField result 'values' (copyArray values)
  return result
}

method keys Dictionary {
  comment '
	Return an array containing all keys (unsorted).'

  result = (list)
  for i (count keys) {
    k = (at keys i)
	if (notNil k) { add result k }
  }
  return (toArray result)
}

method values Dictionary {
  comment '
	Return an array with all values (unsorted).'

  result = (list)
  for i (count keys) {
    k = (at keys i)
	if (notNil k) { add result (at values i) }
  }
  return (toArray result)
}

method keyAtValue Dictionary value {
  comment '
	Return a key that has the given value, or nil if there is none.
	Note: Does linear search of the keys, so can be slow for large Dictionaries.'

  for i (count keys) {
	if ((at values i) == value) { return (at keys i) }
  }
  return nil
}

method sortedPairs Dictionary sortByKey {
  comment '
	Return a sorted array of pairs (two-element arrays) for my contents.
	If sortByKey is true, the pairs are (key, value).
	Otherwise, the pairs are (value, key). Either way,
	the pairs are sorted by their first element.'

  result = (list)
  if (true == sortByKey) {
    for i (count keys) {
      if (notNil (at keys i)) { add result (array (at keys i) (at values i)) }
    }
  } else {
    for i (count keys) {
      if (notNil (at keys i)) { add result (array (at values i) (at keys i)) }
    }
  }
  sortFunction = (function a b { return ((at a 1) <= (at b 1)) })
  result = (sorted (toArray result) sortFunction)
  return result
}

method toString Dictionary limit visited {
  if (isNil limit) { limit = 200 }
  if (isNil visited) { visited = (dictionary) }
  if (contains visited this) { return '(dictionary ...)' }
  add visited this
  result = (list '(dictionary')
  for pair (reversed (sortedPairs this)) {
	if ((count result) > limit) {
	  add result ')'
	  return (joinStrings result)
	}
	count = (at pair 1)
	k = (at pair 2)
	if (and (isClass k 'String') (k <= ' ')) { k = (printString k) } // quote whitespace characters
	add result (join '   '  (toString k nil visited) ' ' (toString count nil visited) )
  }
  add result ')'
  return (joinStrings result)
}

// serialization

method serializedFieldNames Dictionary { return (array) }

method serialize Dictionary {
  result = (list)
  for k (keys this) {
    add result k
	add result (at this k)
  }
  return (toArray result)
}

method deserialize Dictionary fieldDict extraFields {
  // Details: extraFields is an array of alternating keys and values.

  count = (count extraFields)
  tally = 0
  keys = (newArray (max count 5))
  values = (newArray (max count 5))

  i = 1
  while (i < count) {
    atPut this (at extraFields i) (at extraFields (i + 1))
	i += 2
  }
}

// implementation helpers

method atNewIndexPut Dictionary i k v {
  comment '
	Add new key and value pair at the given index (assumed to currently
	contain nil). Increase the tally and grow if more than 3/4 full.'

  atPut keys i k
  atPut values i v
  tally += 1
  if (((count keys) * 3) < (tally * 4)) {
    comment 'Double in size if over 3/4 full to avoid performance degradation'
    grow this (2 * (count keys))
  }
}

method grow Dictionary newSize {
  comment '
	Grow to the given size. Dictionaries grow automatically as entries are added,
	so this method is usually not called by the client. However, when building
	very large dictionaries (thousands of entries), it can improve performance
	by a factor of two or more to grow the dictionary in advance to about 1.5
	times the expected number of entries.'

  newSize = (max newSize (2 * (count keys)))
  oldKeys = keys
  oldValues = values
  keys = (newArray newSize)
  values = (newArray newSize)
  tally = 0
  for i (count oldKeys) {
    k = (at oldKeys i)
    if (notNil k) { atPut this k (at oldValues i) }
  }
}

method scanForKeyOrNil Dictionary k {
  comment '
	Return the index for k, or the index of a nil slot
	if k is not in this dictonary.'

  useEquality = (isAnyClass k 'String' 'Float' 'Integer' 'LargeInteger')
  i = (((hash k) % (count keys)) + 1)
  end = (i - 1)
  if (end == 0) { end = (count keys) }
  while true {
    thisKey = (at keys i)
    if (isNil thisKey) { return i }
	if (k === thisKey) { return i }
	if (and useEquality (thisKey == k)) { return i }
	if (i == end) { error 'no free space' }
	i = ((i % (count keys)) + 1)
  }
}

method fixCollisions Dictionary freeIndex {
  comment '
	Called when a key is removed, leaving an empty slot.
	Find a key that was pushed down due to collisions
	and move it into the free slot. This may need to
	be done repeatedly to handle a chain of collisions.
	The process stops when it reaches an empty slot.'

  i = ((freeIndex % (count keys)) + 1)
  while true {
    k = (at keys i)
    if (isNil k) { return } // found an empty slot, so done!
	if ((((hash k) % (count keys)) + 1) != i) {
	  if ((scanForKeyOrNil this k) == freeIndex) {
        atPut keys freeIndex k
	    atPut values freeIndex (at values i)
		atPut keys i nil
	    atPut values i nil
		freeIndex = i
	  }
    }
	i = ((i % (count keys)) + 1)
  }
}
// DropRecord - restores a script / block to how it was
// before a particular block was dropped on it

defineClass DropRecord block target next input

method restore DropRecord aScriptEditor {
  // "undrop"
  if ('reporter' == (type block)) {
    if (notNil target) {
      replaceInput target block input
      fixBlockColor target
    }
  } else { // command or hat
    if (isClass target 'Array') { // top of command block
      addPart (morph aScriptEditor) (morph (first target))
    } (isClass target 'CommandSlot') {
      setNested target next
    } (notNil target) { // bottom of command or hat block
      setNext target next
    }
  }
  grab aScriptEditor block
}
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Copyright 2019 John Maloney, Bernat Romagosa, and Jens MÃ¶nig

// ESPTool.gp - Uploader for ESP8266 and ESP32
// See https://github.com/espressif/esptool/wiki/Serial-Protocol#reading-flash
// John Maloney, September, 2019

defineClass ESPTool port recvBuf closeWhenDone status success allInOneBinary

to newESPTool { return (initialize (new 'ESPTool')) }

method initialize ESPTool {
	status = ''
	port = nil
	recvBuf = (newBinaryData)
	closeWhenDone = true
	success = false
	allInOneBinary = false
	return this
}

method status ESPTool { return status } // return a status/progress string
method success ESPTool { return success } // return true if upload was successful

method setAllInOneBinary ESPTool aBoolean { allInOneBinary = aBoolean }

// Serial Port

method openPort ESPTool portName boardName {
	baudRate = (baudForBoard this boardName)
	closePort this
	port = (safelyRun (action 'openSerialPort' portName baudRate))
	if (not (isClass port 'Integer')) { port = nil } // failed
	if ('Browser' == (platform)) { waitMSecs 100 } // let browser callback complete
	return (notNil port)
}

// Maximum reliable baud rates & upload test results:
// esp8266 - 230400 (26.2; 14.8 compressed) connects, but not reliable at 460800
// d1mini - 921600 (10.2; 8.4 compressed)
// esp32 - 460800 (18.2; 11.3 compressed)
// ed1 - 230400 (26.4; 17.0 compressed) does not connect reliably at 460800
// m5stack - 460800 (18.2; 11.8 compressed)
// m5stick - 230400 (26.1; 15.3 compressed) does not connect reliably at 460800
// m5atom - 115200 (42.5; 28.3 compressed) connects, but not reliable at 230400

method baudForBoard ESPTool boardName {
	if ('ESP8266' == boardName) { return 230400
	} ('D1-Mini' == boardName) { return 921600
	} ('ESP32' == boardName) { return 230400
	} ('Citilab ED1' == boardName) { return 230400
	} ('M5Stack-Core' == boardName) { return 230400
	} ('M5StickC' == boardName) { return 230400
	} ('M5StickC+' == boardName) { return 230400
	} ('M5Atom-Matrix' == boardName) { return 115200
	} ('Databot' == boardName) { return 230400
	} ('Mbits' == boardName) { return 230400
	}
	return 115200
}

method setPort ESPTool portID {
	// Use an existing (open) serial port. Used when invoked from the browser or Chromebook.
	initialize this
	port = portID
	closeWhenDone = false
}

method closePort ESPTool {
	if (notNil port) { closeSerialPort port }
	port = nil
	recvBuf = (newBinaryData)
}

// Connecting

method connect ESPTool {
	// Enter boot mode and connect to the ROM boot loader.

	status = 'Connecting...'
	repeat 30 {
		enterBootMode this
		waitMSecs 30
		recvBuf = (newBinaryData)
		repeat 10 {
			sendSyncMsg this
			waitMSecs 30
			msg = (nextSLIPMsg this)
			if (notNil msg) {
				clearReceiveBuffer this
				print 'Connected'
				return true
			}
		}
	}
	print 'Could not connect. Board did not respond.'
	return false
}

method sendSyncMsg ESPTool {
	// Send an ESPTool SYNC message to allow ESP board to detect the baud rate.

	data = (list 7 7 18 32) // four bytes: 0x07 0x07 0x12 0x20
	repeat 32 { add data (hex '55') } // 32 x 0x55 (to allow ESP to detect baud rate)
	sendCmd this 8 data
}

// Chip Control

method enterBootMode ESPTool {
	// Use the RTS/DTR lines to force the chip into bootloader mode.
	// Set DTR, then toggle RTS to reset the chip.
	// Note: RTS and DTR are inverted by transistors on the board.

	if (isNil port) { return }
	setSerialPortDTR port false		// IO0 = high
	setSerialPortRTS port true		// EN = low (chip in reset)
	waitMSecs 200 // might need to increase to 220 msecs on some chips
	setSerialPortDTR port true		// IO0 = low
	setSerialPortRTS port false		// EN = high (exit reset)
	waitMSecs 100 // might need to increase to 450 msecs on some chips
	setSerialPortDTR port false		// IO0 = high
}

method exitBootMode ESPTool {
	// Reset the chip in normal mode so that it runs the MicroBlocks virtual machine.

	setSerialPortDTR port false		// IO0 = high for reset in normal (not boot) mode
	setSerialPortRTS port true		// EN = low (chip in reset)
	waitMSecs 100
	setSerialPortRTS port false		// EN = high (exit reset)
}

// About SLIP:
// Each SLIP packet begins and ends with 0xC0 (192). Within the packet, all occurrences of
// 0xC0 and 0xDB are replaced with 0xDB 0xDC (219 220) and 0xDB 0xDD (219 221), respectively.

// SLIP Message Receiving

method waitForMsg ESPTool timeout {
	if (isNil timeout) { timeout = 10000 }
	startTime = (msecsSinceStart)
	while (((msecsSinceStart) - startTime) < timeout) {
		msg = (nextSLIPMsg this)
		if (notNil msg) { return msg }
		waitMSecs 10
	}
	return nil
}

method nextSLIPMsg ESPTool {
	// Return the next complete SLIP message or nil. The returned message does not
	// include the start and end bytes and escaped byte pairs have been processed.

	if (isNil port) { return nil }
	data = (readSerialPort port true)
	if (notNil data) {
		recvBuf = (join recvBuf data)
	}
	startIndex = (nextFrameByte this 1)
	if (isNil startIndex) {
		recvBuf = (newBinaryData 0) // no message start found; discard entire buffer
		return nil
	}
	endIndex = (nextFrameByte this (startIndex + 1))
	if (isNil endIndex) {
		if (startIndex > 1) { recvBuf = (copyFromTo recvBuf startIndex) } // discard bytes before start
		return nil
	}

	// received a complete message
	result = (unescapeMsg this startIndex endIndex)
	recvBuf = (copyFromTo recvBuf (endIndex + 1))
	return result
}

method nextFrameByte ESPTool startIndex {
	// Return the index of the next SLIP frame byte after startIndex in recvBuf.
	// Return nil if there isn't one.

	end = (byteCount recvBuf)
	i = startIndex
	while (i <= end) {
		if (192 == (byteAt recvBuf i)) { return i } // SLIP frame mark byte (192 = 0xC0)
		i += 1
	}
	return nil
}

method unescapeMsg ESPTool startIndex endIndex {
	// Return a list of the bytes between the given indices in recvBuf
	// with escaped byte pairs replaced with their original byte values.

	result = (list)
	i = (startIndex + 1)
	while (i < endIndex) {
		b = (byteAt recvBuf i)
		if (219 == b) { // SLIP escape byte (219 = 0xDB)
			nextB = (byteAt recvBuf i)
			if (220 == nextB) { add result 192 } // escaped SLIP start byte (192 = 0xC0)
			if (221 == nextB) { add result 219 } // escaped SLIP escape byte (219 = 0xDB)
			i += 2
		} else {
			add result b
			i += 1
		}
	}
	return result
}

method clearReceiveBuffer ESPTool {
	// Discard any buffered data from the serial port and clear the receive buffer.

	data = true
	while (notNil data) {
		waitMSecs 10 // allow time for any leftover data to arrive
		data = (readSerialPort port true)
	}
	recvBuf = (newBinaryData)
}

method errorResponse ESPTool {
	// Return true if we got an error or timed out.

	msg = (waitForMsg this)
	if (isNil msg) {
		print 'No response from board'
		return true
	}
	if ((count msg) < 10) {
		print 'Incomplete response from board'
		return true
	}
	if (0 != (at msg 9)) {
		print 'Board reported error:' (at msg 10)
		return true
	}
	return false // all good!
}

// SLIP Message Sending

method sendCmd ESPTool cmd data checksum {
	// Send the given command to the board with the given data.
	// Both data and checksum are optional.

	if (isNil data) { data = (list) }
	if (isClass data 'BinaryData') { data = (toArray data) }

	byteCount = (count data)
	msg = (list 0 cmd (byteCount & 255) ((byteCount >> 8) & 255))
	if (notNil checksum) {
		add32Int this msg checksum
	} else {
		repeat 4 { add msg 0 }
	}
	addAll msg data
	sendSLIPMsg this msg
}

method sendSLIPMsg ESPTool msg {
	escaped = (list)
	add escaped 192 // SLIP start byte
	for b msg {
		if (192 == b) { // escape SLIP end byte
			add escaped 219
			add escaped 220
		} (219 == b) { // escape SLIP escape byte
			add escaped 219
			add escaped 221
		} else {
			add escaped b
		}
	}
	add escaped 192 // SLIP end byte
	writeSerialPort port (toBinaryData (toArray escaped))
}

method add32Int ESPTool msg n {
	// Append the 32-bit integer n to the given message in little-endian byte order.

	repeat 4 {
		add msg (n & 255)
		n = (n >> 8)
	}
}

// Utilities

method chipType ESPTool {
	dateReg1 = (readRegister this '60000078')
	if ('0x00062000' == dateReg1) { return 'ESP8266' }
	if ('0x15122500' == dateReg1) { return 'ESP32' }
	if ('0x00000500' == dateReg1) {
		dateReg2 = (readRegister this '3f400074')
		if ('0x19031400' == dateReg2) { return 'ESP32-S2' }
	}
	return nil // unrecognized chip
}

method eraseFlash ESPTool {
	status = (localized 'Erasing Flash...')
	clearReceiveBuffer this
	sendCmd this (hex 'd0')
	msg = (waitForMsg this 30000) // long timeout because erasing Flash takes time
	ok = (and (notNil msg) ((count msg) > 9) (0 == (at msg 9)))
	return ok
}

method readRegister ESPTool hexAddr {
	// Read the given register (supplied as a hex string such as '3ff0005c').

	clearReceiveBuffer this
	sendCmd this 10 (hexToBytes this hexAddr)
	msg = (waitForMsg this)
	if (or (isNil msg) ((count msg) < 10)) { return -1 } // no response
	if (0 != (at msg 9)) { return (0 - (at msg 10)) } // return error code (negative)
	return (bytesAsHex this (reversed (copyFromTo msg 5 8)))
}

method hexToBytes ESPTool s {
	// Convert a hexadecimal value into a list of byte values in little-endian order.

	if (beginsWith s '0x') { s = (substring s 3) } // remove optional leading '0x'
	result = (list)
	i = ((count s) - 1)
	while (i >= 0) {
		if (0 == i) { // single character (odd-length string)
			add result (hex (substring s 1 1))
		} else {
			add result (hex (substring s i (i + 1)))
		}
		i += -2
	}
	return result
}

method bytesAsHex ESPTool bytes {
	out = (list '0x')
	for b (toArray bytes) {
		hex = (toLowerCase (toStringBase16 b))
		if ((count hex) < 2) { hex = (join '0' hex) }
		add out hex
	}
	return (joinStrings out '')
}

// Installing Firmware

method installFirmware ESPTool boardName eraseFlag downloadFlag vmData {
	// Install the firmware for the current board, erasing Flash if optional eraseFlag is true.
	// If optional downloadFlag is true, download the latest version from the server.
	// Assume the board is connected.

	if (isNil eraseFlag) { eraseFlag = false }
	if (isNil downloadFlag) { downloadFlag = false }

	if (isNil vmData) { vmData = (readVMData this boardName downloadFlag) }
	if (isNil vmData) { return }

	if (or (isOneOf boardName 'ESP8266' 'D1-Mini')
		(notNil (findSubstring 'nodemcu' boardName))
		(notNil (findSubstring '8266' boardName))
	) {
		ok = (uploadESP8266VM this vmData eraseFlag)
	} else {
		ok = (uploadESP32VM this vmData eraseFlag)
	}

	if ok {
		status = (localized 'Done')
		success = true
	} else {
		status = (localized 'Failed')
		if closeWhenDone { closePort this }
		enableAutoConnect (smallRuntime) false
		return
	}

	waitMSecs 200 // allow time for final flash write to complete (40 msecs minimum on d1 mini)
	exitBootMode this
	waitMSecs 1500
	if closeWhenDone { closePort this }
	enableAutoConnect (smallRuntime) success
}

method readVMData ESPTool boardName downloadFlag {
	vmName = (vmNameForBoard this boardName)
	if (isNil vmName) {
		print 'Unknown board:' boardName
		return nil
	}

	if downloadFlag {
		status = 'Fetching...'
		vmData = (httpGetBinary 'microblocks.fun' (join '/downloads/latest/vm/' vmName))
	} else {
		vmData = (readEmbeddedFile (join 'precompiled/' vmName) true)
	}
	if (or (isNil vmData) ((byteCount vmData) < 10000)) {
		print 'Could not fetch or read VM'
		return nil
	}
	return vmData
}

method vmNameForBoard ESPTool boardName {
	if ('ESP8266' == boardName) { return 'vm_nodemcu.bin'
	} ('D1-Mini' == boardName) { return 'vm_nodemcu.bin'
	} ('ESP32' == boardName) { return 'vm_esp32.bin'
	} ('Citilab ED1' == boardName) { return 'vm_citilab-ed1.bin'
	} ('M5Stack-Core' == boardName) { return 'vm_m5stack.bin'
	} ('M5StickC' == boardName) { return 'vm_m5stick.bin'
	} ('M5StickC+' == boardName) { return 'vm_m5stick+.bin'
	} ('M5Atom-Matrix' == boardName) { return 'vm_m5atom.bin'
	} ('Databot' == boardName) { return 'vm_databot.bin'
	} ('Mbits' == boardName) { return 'vm_mbits.bin'
	}
	return nil
}

// Uploading data to the board

method uploadESP8266VM ESPTool vmData eraseFlag {
	if (isNil eraseFlag) { eraseFlag = false }

	ok = (connect this)
	if (not ok) { return false }

	ok = (uploadStub this)
	if (not ok) { return false }

	if eraseFlag { eraseFlash this }

	uploadCompressed this 0 vmData
	return true
}

method uploadESP32VM ESPTool vmData eraseFlag {
	if (isNil eraseFlag) { eraseFlag = false }

	ok = (connect this)
	if (not ok) { return false }

	ok = (uploadStub this)
	if (not ok) { return false }

	ok = (setFlashParameters this)
	if (not ok) { return false }

	if eraseFlag { eraseFlash this }

	if allInOneBinary {
		uploadCompressed this 0 vmData // binary includes all subparts and loads at address 0
		return true
	}

	data = (readEmbeddedFile (join 'esp32/bootloader_dio_40m.bin') true)
	uploadCompressed this (hex '1000') data

	data = (readEmbeddedFile (join 'esp32/boot_app0.bin') true)
	uploadCompressed this (hex 'e000') data

	if ((byteCount vmData) > 1000000) {
		data = (readEmbeddedFile (join 'esp32/partitions2MB.bin') true)
	} else {
		data = (readEmbeddedFile (join 'esp32/partitions.bin') true)
	}
	uploadCompressed this (hex '8000') data

	uploadCompressed this (hex '10000') vmData
	return true
}

method uploadCompressed ESPTool startAddr data {
	// Upload the given binary data to Flash at the given address with deflate compression.
	// Note: The total packet size after SLIP escaping cannot exceed 1024 bytes.
	// The number of extra bytes for escape sequences depends on the the contents.
	// The packet size 800 was chosen based on testing with all the current VM's
	// and leaves a reasonable margin for data that requires more escape sequences
	// while minimizing the total number of packets sent to minimize upload time.

	start = (msecsSinceStart)

	packetSize = 800 // 800 is good; 900 works; 984 fails
	compressedData = (zlibEncode data)
	compressedBytecount = (byteCount compressedData)
	packetCount = (ceiling (compressedBytecount / packetSize))

	args = (list)
	add32Int this args (byteCount data) // uncompressed size
	add32Int this args packetCount
	add32Int this args packetSize
	add32Int this args startAddr
	sendCmd this (hex '10') args
	if (errorResponse this) { return }

	status = ''
	percentDone = 0

	sent = 0
	seqNum = 0
	while (sent < compressedBytecount) {
		bytesToSend = (min packetSize (compressedBytecount - sent))
		args = (list)
		add32Int this args bytesToSend
		add32Int this args seqNum
		repeat 8 { add args 0 }
		checksum = (hex 'EF')
		for i bytesToSend {
			byte = (byteAt compressedData (sent + i))
			checksum = (checksum ^ byte)
			add args byte
		}
		sendCmd this (hex '11') args checksum
		if (errorResponse this) { return }
		sent += bytesToSend
		percentDone = (round ((100 * sent) / compressedBytecount))
		status = (join '' percentDone '%')
		seqNum += 1
	}
//	print ((msecsSinceStart) - start) 'msecs'
}

method uploadUncompressed ESPTool startAddr flashData {
	// Upload the uncompressed binary data to Flash at the given address.

	totalBytes = (byteCount flashData)
	packetSize = 512
	packetCount = (ceiling (totalBytes / packetSize))
	eraseSize = totalBytes

	args = (list)
	add32Int this args eraseSize
	add32Int this args packetCount
	add32Int this args packetSize
	add32Int this args startAddr
	sendCmd this 2 args
	if (errorResponse this) { return }

	status = ''
	percentDone = 0

	sent = 0
	seqNum = 0
	while (sent < totalBytes) {
		bytesToSend = (min packetSize (totalBytes - sent))
		args = (list)
		add32Int this args bytesToSend
		add32Int this args seqNum
		repeat 8 { add args 0 }
		checksum = (hex 'EF')
		for i bytesToSend {
			byte = (byteAt flashData (sent + i))
			checksum = (checksum ^ byte)
			add args byte
		}
		sendCmd this 3 args checksum
		if (errorResponse this) { return }
		sent += bytesToSend
		percentDone = (round ((100 * sent) / totalBytes))
		status = (join '' percentDone '%')
		seqNum += 1
	}
}

method setFlashParameters ESPTool {
	// Assumes Flash is 4 MB for now. (Later, could detect the actual size.)
	// Of John's boards, all are 4 MB except the M5Stack, which is 16 MB.
	// Other parameters are fixed.

	args = (list)
	add32Int this args 0 // Flash ID
	add32Int this args (4 * (1024 * 1024)) // total size; assume 4 MB
	add32Int this args (64 * 1024) // block size
	add32Int this args (4 * 1024) // sector size
	add32Int this args 256 // page size
	add32Int this args (hex 'ffff') // status mask
	sendCmd this (hex '0b') args
	return (not (errorResponse this))
}

// Stub uploading

method uploadStub ESPTool {
	// Upload and start the RAM bootloader stub. This bootloader includes more features
	// such as compressed data uploading and the ability to erase all of Flash memory.

	type = (chipType this)
	print 'Chip type:' type

	if ('ESP8266' == type) {
		stub = (esp8266_stub this)
	} ('ESP32' == type) {
		stub = (esp32_stub this)
	} ('ESP32-S2' == type) {
		stub = (esp32_S2_stub this)
	} else {
		print 'Error: Unknown chip type'
		return false
	}
	uploadToRAM this (at stub 'text_start') (at stub 'text')
	uploadToRAM this (at stub 'data_start') (at stub 'data')
	ok = (startStub this (at stub 'entry'))
	return ok
}

method uploadToRAM ESPTool hexStartAddr ramData {
	// Upload the given binary data to RAM at the given address.

	totalBytes = (byteCount ramData)
	packetSize = 900 // must be well under 1024 to allow for header and SLIP escaping
	packetCount = (ceiling (totalBytes / packetSize))

	args = (list)
	add32Int this args totalBytes
	add32Int this args packetCount
	add32Int this args packetSize
	addAll args (hexToBytes this hexStartAddr)
	sendCmd this 5 args // start RAM upload
	if (errorResponse this) { return }

	sent = 0
	seqNum = 0
	while (sent < totalBytes) {
		bytesToSend = (min packetSize (totalBytes - sent))
		args = (list)
		add32Int this args bytesToSend
		add32Int this args seqNum
		repeat 8 { add args 0 }
		checksum = (hex 'EF')
		for i bytesToSend {
			byte = (byteAt ramData (sent + i))
			checksum = (checksum ^ byte)
			add args byte
		}
		sendCmd this 7 args checksum // send RAM data
		if (errorResponse this) { return }
		sent += bytesToSend
		seqNum += 1
	}
}

method startStub ESPTool hexStartAddr {
	args = (list 0 0 0 0)
	addAll args (hexToBytes this hexStartAddr)
	sendCmd this 6 args
	waitForMsg this // wait for and discard response to start command
	msg = (waitForMsg this) // wait for four byte stub startup message: 'OHAI'
	if (or (isNil msg) (msg != (list 79 72 65 73))) {
		print 'Error: Stub did not repsond'
		return false
	}
	print 'Stub started'
	return true
}

// Stub code

method esp8266_stub ESPTool {
	result = (dictionary)
	atPut result 'text' (base64Decode '
qBAAQAH//0Z0AAAAkIH/PwgB/z+AgAAAhIAAAEBAAABIQf8/lIH/PzH5/xLB8CAgdAJhA4XnATKv
/pZyA1H0/0H2/zH0/yAgdDA1gEpVwCAAaANCFQBAMPQbQ0BA9MAgAEJVADo2wCAAIkMAIhUAMev/
ICD0N5I/Ieb/Meb/Qen/OjLAIABoA1Hm/yeWEoYAAAAAAMAgACkEwCAAWQNGAgDAIABZBMAgACkD
Mdv/OiIMA8AgADJSAAgxEsEQDfAAoA0AAJiB/z8Agf4/T0hBSais/z+krP8/KOAQQOz5EEAMAABg
//8AAAAQAAAAAAEAAAAAAYyAAAAQQAAAAAD//wBAAAAAgf4/BIH+PxAnAAAUAABg//8PAKis/z8I
gf4/uKz/PwCAAAA4KQAAkI//PwiD/z8Qg/8/rKz/P5yv/z8wnf8/iK//P5gbAAAACAAAYAkAAFAO
AABQEgAAPCkAALCs/z+0rP8/1Kr/PzspAADwgf8/DK//P5Cu/z+ACwAAEK7/P5Ct/z8BAAAAAAAA
ALAVAADx/wAAmKz/P5iq/z+8DwBAiA8AQKgPAEBYPwBAREYAQCxMAEB4SABAAEoAQLRJAEDMLgBA
2DkAQEjfAECQ4QBATCYAQIRJAEAhvP+SoRCQEcAiYSMioAACYUPCYULSYUHiYUDyYT8B6f/AAAAh
sv8xs/8MBAYBAABJAksiNzL4xa0BIqCMDEMqIUWgAcWsASF8/8F6/zGr/yoswCAAyQIhqP8MBDkC
Maj/DFIB2f/AAAAxpv8ioQHAIABIAyAkIMAgACkDIqAgAdP/wAAAAdL/wAAAAdL/wAAAcZ3/UZ7/
QZ7/MZ7/YqEADAIBzf/AAAAhnP8xYv8qI8AgADgCFnP/wCAA2AIMA8AgADkCDBIiQYQiDQEMJCJB
hUJRQzJhIiaSCRwzNxIghggAAAAiDQMyDQKAIhEwIiBmQhEoLcAgACgCImEiBgEAHCIiUUPFoAEi
oIQaIgyDhZMBIg0D8g0CgCIR8PIgIX//97ITIqDARY4BIqDuxY0BBZ4BRtz/AAAyDQEM0ieTAgaR
ADcyTmZjAsawAPZzIGYzAsZlAPZDCGYjAsZKAEavAGZDAgZ7AGZTAoaPAIarAAySJ5MCBoYANzII
ZnMCxowAhqYAZpMCRoQADLInkwJGeQBGogAcMieTAsY4ADcyKGazAoZCABwCNzIKDPInkwIGLQAG
mgAcEieTAoZLABwiJ5MCRmMARpUAIqDRJxMsNzIJIqDQJxMYxpAAACKg0ieTAoYkACKg0yeTAkZ+
BUaLAAwczB/GUAUGhwAAJo8CxoQAhlAFAXX/wAAA+sycIsaAAAAAICxBAXL/wAAAVlIf8t/w8CzA
zC+GWQUAIDD0VhP+4Tf/hgMAICD1AWr/wAAAVhId4P/A8CzA9z7qhgMAICxBAWP/wAAAVpIb8t/w
8CzAVq/+RkoFDA7CoMAmjwJGbACGSgUAAGa/AoZIBQZIAGa/AoY0BcZiAMKgASa/AgZhACItBDEj
/+KgAMKgwiezAsZfADhdKC3FcQHGLAUAAEKgAWa/MDItBCEa/+KgAMKgwjeyAsZWACg9IMOCOF0o
LUJhMQVvATEE/0IhMeljMtMrySMgToPNBIZKACH+/gwOMgIAwqDG55MChkkAOC3IUvLP8PAzwCKg
wDDCkyLNGD0CYqDvxgEAQgMAGzNAZjAgQ8D3JPEyDQVSDQQiDQaAMxEAIhFQQyBAMiAiDQcMDoAi
ATAiICAmwDKgwSDDk0Y0AAAh5f4MDjICAMKgxueTAsYvADgywqDI5xMCBi0A4kIAyFIGKwAcggwO
DBwnHwIGKACG+QQAZk8CRv8EBiEAZr8CBgAFxgEAAABmTwKG/wQMDsKgwIYeAAAAZr8CRv0EBhgA
Udz+DA5IBQwT8s/wLQ7wI5NAPpMwIhDCoMbnklJh1v7tAngGwqDJ9zdF8DAUDA7CoMCSzRjnEw4G
DQA6KSgCSzMpBEtEDBIwh8D3M+3MEkbmBEkFiQaG5AQAAGaPAoboBAwcDA7GAQAAAOKgAMKg/8Ag
dAVeAeAgdMVdAQVuAVYMxyINAQzzNxIxJzMVZkICxrAEZmIChrUEJjICxhT/BhoAABwjN5ICxqoE
MqDSNxJHHBM3EgJGDv9GGgAhr/7oPdItAgHb/sAAACGt/sAgADgCIaz+ICMQ4CKC0D0ghYkBPQIt
DAHU/sAAACKj6AHR/sAAAMb+/gAAUi0FQi0EMi0DKC1FaQEG+v4AMg0DIg0CgDMRIDMgMsPwIs0Y
RUgBxvP+AAAAUs0YUmEkIg0DMg0CgCIRMCIgIsLwImEqDB+GdQQhkf5xsP6yIgBhTP6CoAMiJwKS
ISqCYSewxsAnOQQMGqJhJ7JhNgU6AbIhNnGH/lIhJGIhKnBLwMpEalULhFJhJYJhK4cEAsZOBHe7
AkZNBJjtoi0QUi0VKG2SYSiiYSZSYSk8U8h94i0U+P0nswKG7wMxdv4wIqAoAqACADFc/gwODBLp
k+mDKdMpo+JhJv0O4mEozQ5GBgByIScME3BhBHzEYEOTbQQ5Yl0LciEkRuEDAIIhJJIhJSFN/pe4
2TIIABt4OYKGBgCiIScMIzBqEHzFDBRgRYNtBDliXQuG1QNyISRSISUhQv5Xt9tSBwD4glmSgC8R
HPNaIkJhMVJhNLJhNhvXhXcBDBNCITFSITSyITZWEgEioCAgVRBWhQDwIDQiwvggNYPw9EGL/wwS
YUj+AB9AAFKhVzYPAA9AQPCRDAbwYoMwZiCcRgwfBgEAAADSISQhJv4sQzliXQsGnQBdC7Y8IAYP
AAAAciEnfMNwYQQMEmAjg20CDDMGFgBdC9IhJEYAAP0GgiElh73bG90LLSICAAAcQAAioYvMIO4g
tjzkbQ9xEv7gICQptyAhQSnH4ONBwsz9VkIgwCAkJzwqxhEAAACSISd8w5BhBAwSYCODbQIMUyEF
/jlifQ0GlQMAAABdC9IhJEYAAP0GoiElp73RG90LLSICAAAcQAAioYvMIO4gwCAkJzzhwCAkAAJA
4OCRIq/4IMwQ8qAAFpwGhgwAAAByISd8w3BhBAwSYCODbQIMYwbn/9IhJF0LgiElh73gG90LLSIC
AAAcQAAioSDuIIvMtozkIeX9wsz4+jIh/P0qI+JCAODoQYYMAAAAkiEnDBOQYQR8xGA0g20DDHPG
1P/SISRdC6IhJSHY/ae93UHv/TINAPoiSiIyQgAb3Rv/9k8Chtz/IQb+fPbyEhwiEh0gZjBgYPRn
nwfGHgDSISRdCyxzxkAAAAC2jCKGDwAAAHIhJ3zDcGEEDBJgI4NtAjwzBrv/XQvSISTGAAAAAP0G
giElh73ZG90LLSICAAAcQAAioYvMIO4gtozkbQ/gkHSSYSjg6EHCzPj9BkYCADxDhtMC0iEkXQsh
g/0nte+iISgLb6JFABtVFoYHVpz4hhwADJPGygJdC9IhJEYAAP0GIXn9J7XqhgYAciEnfMNwYQQM
EmAjg20CLGPGmP8AANIhJF0LgiElh73ekW790GjAUCnAZ7IBbQJnvwFtD00G0D0gUCUgUmE0YmE1
smE2AdT9wAAAYiE1UiE0siE2at1qVWBvwFZm+UbPAv0GJjIIRgQAANIhJF0LDKMhh/05Yn0NRhYD
DA8mEgLGIAAioSAiZxFCoCAhmv1CZxIyoAVSYTRiYTVyYTOyYTYBvv3AAAByITOyITZiITVSITQ9
ByKgkEKgCEJDWAsiGzNWUv8ioHAyoAkyR+gLIht3VlL/HJRyoViRbf0MeEYCAAB6IpoigkIALQMb
MkeT8SGC/TGC/QyEBgEAQkIAGyI3kveGYAEhf/36IiICACc8HUYPAAAAoiEnfMOgYQQMEmAjg20C
DLMGU//SISRdCyF0/foiYiElZ73bG90LPTIDAAAcQAAzoTDuIDICAIvMNzzhIWz9QWz9+iIyAgAM
EgATQAAioUBPoAsi4CIQMMzAAANA4OCRSAQxRf0qJDA/oCJjERv/9j8Cht7/IV/9QqEgDANSYTSy
YTYBgP3AAAB9DQwPUiE0siE2RhUAAACCISd8w4BhBAwSYCODbQIM4wazAnIhJF0LkiEll7fgG3cL
JyICAAAcQAAioSDuIIvMtjzkIUv9QSr9+iIiAgDgMCQqRCFI/cLM/SokMkIA4ONBG/8hI/0yIhM3
P9McMzJiE90HbQ9GHAEATAQyoAAiwURSYTRiYTWyYTZyYTMBW/3AAAByITOBFf0ioWCAh4JBNv0q
KPoiDAMiwhiCYTIBU/3AAACCITIhMf1CpIAqKPoiDAMiwhgBTf3AAACoz4IhMvAqoCIiEYr/omEt
ImEuTQ9SITRiITVyITOyITbGAwAiD1gb/xAioDIiERszMmIRMiEuQC/ANzLmDAIpESkBrQIME+BD
EZLBREr5mA9KQSop8CIRGzMpFJqqZrPlMf78OiKMEvYqKiHu/EKm0EBHgoLIWCqIIqC8KiSCYSwM
CXzzQmE5ImEwxkMAXQvSISRGAAD9BiwzxpkAAACiISyCCgCCYTcWiA4QKKB4Ahv3+QL9CAwC8CIR
ImE4QiE4cCAEImEvC/9AIiBwcUFWX/4Mp4c3O3B4EZB3IAB3EXBwMUIhMHJhLwwacc78ABhAAKqh
KoRwiJDw+hFyo/+GAgAAQiEvqiJCWAD6iCe38gYgAHIhOSCAlIqHoqCwQcH8qohAiJBymAzMZzJY
DH0DMsP+IClBobv88qSwxgoAIIAEgIfAQiE5fPeAhzCKhPCIgKCIkHKYDMx3MlgMMHMgMsP+giE3
C4iCYTdCITcMuCAhQYeUyCAgBCB3wHz6IiE5cHowenIipLAqdyGm/CB3kJJXDEIhLBuZG0RCYSxy
IS6XFwLGvf+CIS0mKAIGmQDGgQAM4seyAsYwAJIhJdApwKYiAgYmACG7/OAwlEGV/CojQCKQIhIM
ADIRMCAxlvIAMCkxFjIFJzwCRiQAhhIAAAyjx7NEkbD8fPgAA0DgYJFgYAQgKDAqJpoiQCKQIpIM
G3PWggYrYz0HZ7zdhgYAoiEnfMOgYQQMEmAjg20CHAPGdf4AANIhJF0LYiElZ73eIg0AGz0AHEAA
IqEg7iCLzAzi3QPHMgLG2v8GCAAAACINAYs8ABNAADKhIg0AK90AHEAAIqEgIyAg7iDCzBAhjfzg
MJRhZ/wqI2AikDISDAAzETAgMZaiADA5MSAghEYJAAAAgYT8DKR89xs0AARA4ECRQEAEICcwKiSK
ImAikCKSDE0DliL+AANA4OCRMMzAImEoDPMnIxQhUvxyISj6MiF2/Bv/KiNyQgCGMwCCIShmuBrc
fxwJkmEoBgEA0iEkXQscEyFH/Hz2OWJGQP4xbPwqIyLC8CICACJhJic8G4YNAKIhJ3zDoGEEDBJg
I4NtAhwjBjX+0iEkXQtiISVnveAb3QstIgIAciEmABxAACKhi8wg7iB3POGCISYxWfySISgMFgAY
QABmoZozC2Yyw/DgJhBiAwAACEDg4JEqZiFR/IDMwCovMqAAZrkNMSX88EOAMU38OjQyAwBNBlJh
NGJhNbJhNgFi/MAAAGIhNVIhNGr/siE2RgAADA9xGfxCJxFiJxJqZGe/AgZ5//eWB0YCANIhJF0L
HFOGyf/xOvwhO/w9D1JhNGJhNbJhNnJhMwFO/MAAAHIhMyEk/DInEUInEjo/AUn8wAAAsiE2YiE1
UiE0MQP8KMMLIinD8QH8eM/WZ7jGPQFiISUM4tA2wKZDDkHO+1A0wKYjAgZNAIYzAseyAkYuAKYj
AgYlAEH1++AglEAikCISvAAyETAgMZYCATApMRZCBSc8AoYkAMYSAAAADKPHs0R8+JKksAADQOBg
kWBgBCAoMCommiJAIpAikgwbc9aCBitjPQdnvN2GBgByISd8w3BhBAwSYCODbQIcc8bU/QAA0iEk
XQuCISWHvd4iDQAbPQAcQAAioSDuIIvMDOLdA8cyAsbb/wYIAAAAIg0BizwAE0AAMqEiDQAr3QAc
QAAioSAjICDuIMLMEEHI++AglEAikCISvAAiESDwMZaPACApMfDwhMYIAAyjfPdipLAbIwADQOAw
kTAwBPD3MPrzav9A/5Dynww9ApYv/gACQODgkSDMwCKg//eiAsZAAIYCAAAcgwbTANIhJF0LIYL7
J7Xv8kUAbQ8bVcbqAAzixzIZMg0BIg0AgDMRICMgABxAACKhIO4gK93CzBAxo/vgIJSqIjAikCIS
DAAiESAwMSApMdYTAgykGyQABEDgQJFAQAQwOTA6NEGY+4ozQDOQMpMMTQKW8/39AwACQODgkSDM
wHeDfGKgDsc2GkINASINAIBEESAkIAAcQAAioSDuINLNAsLMEEGJ++AglKoiQCKQQhIMAEQRQCAx
QEkx1hICDKYbRgAGQOBgkWBgBCApMComYX77iiJgIpAikgxtBJby/TJFAAAEQODgkUDMwHcCCBtV
/QJGAgAAACJFAStVRnP/8GCEZvYChrMAIq7/KmYhmvvgZhFqIigCImEmIZj7ciEmamL4BhaXBXc8
HQYOAAAAgiEnfMOAYQQMEmAjg20CHJMGW/3SISRdC5IhJZe94BvdCy0iAgCiISYAHEAAIqGLzCDu
IKc84WIhJgwSABZAACKhCyLgIhBgzMAABkDg4JEq/wzix7ICRjAAciEl0CfApiIChiUAQUz74CCU
QCKQItIPIhIMADIRMCAxluIAMCkxFjIFJzwCRiQAhhIADKPHs0WRb/uCr/8AA0DgYJFgYAQgKDAq
JpoiQCKQIpIMG3PWggYrYz0HZ7zdhgYAgiEnfMOAYQQMEmAjg20CHKPGK/0AANIhJF0LkiEll73e
Ig0AGz0AHEAAIqEg7iCLzAzi3QPHMgJG2/8GCAAAACINAYs8ABNAADKhIg0AK90AHEAAIqEgIyAg
7iDCzBBhH/vgIJRgIpAi0g8yEgwAMxEwIDGWggAwOTEgIITGCACBRPsMpHz3GzQABEDgQJFAQAQg
JzAqJIoiYCKQIpIMTQOWIv4AA0Dg4JEwzMAxOvvgIhEqMzgDMmEmMTj7oiEmKiMoAiJhKBYKBqc8
HkYOAHIhJ3zDcGEEDBJgI4NtAhyzxvf8AAAA0iEkXQuCISWHvd0b3QstIgIAkiEmABxAACKhi8wg
7iCXPOGiISYMEgAaQAAioWIhKAsi4CIQKmYACkDg4JGgzMBiYShxAvuCIShwdcCSISsx//qAJ8CQ
IhA6InJhKT0FJ7UBPQJBtvr6M20PN7RsBhIAIeD6LFM5YgZuADxTId36fQ05YgwmRmwAXQvSISRG
AAD9BiGr+ie14aIhKWIhKHIhK2AqwDHp+nAiECojIgIAG6oiRQCiYSkbVQtvVh/9hgsAMgIAYsb9
MkUAMgIBMkUBMgICOyIyRQI7VfY244z2MgIAMkUAZiYFIgIBIkUBalX9BqKgsHz5gqSwcqEAxr3+
AAAhvPoosgfiAgaW/MAgJCc8IEYPAIIhJ3zDgGEEDBJgI4NtAiwDBqz8AABdC9IhJEYAAP0GkiEl
l73ZG90LLSICAAAcQAAioYvMIO4gwCAkJzzhwCAkAAJA4OCRfIIgzBB9DUYBAAALd8LM+KIhJHe6
AvaM8SHQ+jHQ+k0MUmE0cmEzsmE2RZMACyKyITZyITNSITQg7hAMDxZMBoYMAAAAgiEnfMOAYQQM
EmAjg20CLJMGDwByISRdC5IhJZe34Bt3CyciAgAAHEAAIqEg7iCLzLaM5OAwdMLM+ODoQYYKAKIh
J3zDoGEEDBJgI4NtAiyjIX/6OWKGDwAAAHIhJF0LYiElZ7fZMgcAG3dBefob/yikgCIRMCIgKaT2
TwfG3f9yISRdCyFy+iwjOWIMBoYBAHIhJF0LfPYmFhRLJsxiRgMAC3fCzPiCISR3uAL2jPGBaPoh
mPoxmPrJeE0MUmE0YmE1cmEzgmEysmE2xYQAgiEykiEooiEmCyKZ6JIhKeDiEKJoEHIhM6IhJFIh
NLIhNmIhNfn44mgUkmgVoNfAsMXA/QaWVg4xhfr42C0MBX0A8OD0TQLw8PV9DAx4YiE1siE2RiUA
AACSAgCiAgLq6ZICAeqZmu76/uICA5qamv+anuICBJr/mp7iAgWa/5qe4gIGmv+anuICB5r/mu7q
/4siOpJHOcBAI0GwIrCwkGBGAgAAMgIAGyI67ur/Kjm9Akcz7zFn+i0OQmExYmE1cmEzgmEysmE2
RXQAMWH67QItD8VzAEIhMXIhM7IhNkB3wIIhMkFa+mIhNf0CjIctC7A4wMbm/wAAAP8RISH66u/p
0v0G3Fb4ovDuwHzv4PeDRgIAAAAADAzdDPKv/TFN+lIhKigjYiEk0CLA0FXA2mbRKfopIzgNCy9S
YSpxJ/rKUyAvIGJhJFkNIC8FcDXAzKJC04BSoAFAJYMWkgDBHvotDMUoAMkNgiEq0QX6jPgoPRay
APAvMfAiwNYiAMaD+9aPACKgxyldBjsAAFaPDig9zBJGavoioMiGAAAioMkpXcZm+igtjBIGZfoh
B/oBNPrAAAABN/rAAACGYPrIPcwcxl76IqPoAS76wAAAwAwABlv6AAEw+sAAACDPg8ar+sgt+D3w
LCAgILTMEkar+sYu+zItAyItAoUyADKgAAwcIMODRir7eH1obVhdSE04PSgtDAwBF/rAAADtAgwS
4MKTBib7ARH6wAAADAwGIPsAKC04PcAgADkCDA7NDgYf+yHg+UhdOC1JAiHe+TkCBvb/Udz5DAQ4
BcKgyDDEgyHY+T0MDBxJBUkCMMSDBhD7xzICxvL9xvn9KD0W4vHGL/oCIUOSoRDCIULSIUHiIUDy
IT+aEQ3wAAAIAABgHAAAYAAAAGAQAABgIfz/EsHw6QHAIADoAgkxySHZESH4/8AgAMgCwMB0nOzR
svlGBAAAADH0/8AgACgDOA0gIHTAAwALzGYM6ob0/yHv/wgxwCAA6QLIIdgR6AESwRAN8AAAAPgC
AGAQAgBgAAIAYAAAAAgh/P/AIAA4AjAwJFZD/yH5/0H6/8AgADkCMff/wCAASQPAIABIA1Z0/8Ag
ACgCDBMgIAQwIjAN8AAAgAAAAABA////AAQCAGASwfDCYQLBiPkCYQMiLAQWcgdF+v8WEgcQESDF
+f8WYv8h4/8x9P/AIAA5AsAgADgCVnP/OEwM9QwSQYb5N6ULOCxQMxDMM0Hq/xwCOCxh1v9AUxHA
IAA4BjAwJFZD/zHm/zA1EFHl/8AgADkFMdD/wCAASQPAIABIA1Z0/zhMIDPAOUw4LCojKSwIMcgh
EsEQDfAATEoAQBLB4MlhwWL5+TH4POlBCXHZUe0C97MB/QMWDwTYHNrf0NxBBgEAAADF8/8oTKYS
BCgsJ63yhe7/FpL/KBzwTyDgPiAB7v/AAACMMiKgxClcKBxIPPoi8ETAKRxJPAhxyGHYUehB+DES
wSAN8P8PAABRSPkSwfAJMQwUQkUAMExBSSVB+v85FSk1MDC0SiIqIyAsQSlFDAIiZQUBevnAAAAI
MTKgxSAjkxLBEA3wAAAAMDsAQBLB8AkxMqDAN5IRIqDbAfv/wAAAIqDcRgQAAAAAMqDbN5IIAfb/
wAAAIqDdAfT/wAAACDESwRAN8AAAABLB8Mkh2REJMc0COtJGAgAAIgwAwswBxfr/15zzAiEDwiEC
2BESwRAN8AAAWBAAAHAQAAAYmABAHEsAQDSYAEAAmQBAkfv/EsHgyWHpQfkxCXHZUZARwO0CItEQ
zQMB9f/AAADxGPnGCQDdDMe/Ad0PTQ09AS0OAfD/wAAA/DJNDRAxICLREAHt/8AAANru0MzAVkz9
IeX/MtEQGiIB6P/AAAAh4v8cAxoiRfX/LQwGAQAAACKgY5He/5oRCHHIYdhR6EH4MRLBIA3wABLB
8CKgwAkxAbv/wAAACDESwRAN8AAAAGwQAABoEAAAdBAAAHgQAAB8EAAAgBAAAJAQAACYDwBAjDsA
QBLB4JH8//kx/QIhx//JYdlRCXHpQZARwBoiOQIx8v8sAhozSQNB8P/S0RAaRMKgAFJkAMJtGgHw
/8AAAGHq/yHf+BpmaAZnsgLGSAAtDQG3/8AAACG0/zHl/ypBGjNJA0Y9AAAAYbD/Md//GmZoBhoz
6APAJsDnsgIg4iBh3f89ARpmWQZNDvAvIAGp/8AAADHY/xozWAOMogwEQm0W7QSGEgAAAEHS/+r/
GkRZBEXx/z0OLQEF5P+F8P9NDj0B0C0gAZz/wAAAYcr/6swaZlgGIZX/GiIoAie8vTHD/1AswBoz
OAM3sgJG3v+G6v9CoABCTWwhuv8QIoABwP/AAABWAv9huv8iDWwQZoA4BkUHAPfiEfZODkGy/xpE
6jQiQwAb7sbx/zKv/jeSwSZOKSF9/9A9IBAigAGA/8AAAEXo/yF4/xwDGiLF2v+F5/8sAgHL+MAA
AIYFAGFz/1ItGhpmaAZntchXPAIG2f/G7/8AkaH/mhEIcchh2FHoQfgxEsEgDfBdAkKgwCgDR5UO
zDIMEoYGAAwCKQN84g3wJhIFJiIRxgsAQqDbLQVHlSkMIikDBggAIqDcJ5UIDBIpAy0EDfAAQqDd
fPJHlQsMEikDIqDbDfAAfPIN8AAAtiMwbQJQ9kBA80BHtSlQRMAAFEAAM6EMAjc2BDBmwBsi8CIR
MDFBC0RWxP43NgEbIg3wAIyTDfA3NgwMEg3wAAAAAABESVYwDAIN8LYjKFDyQEDzQEe1F1BEwAAU
QAAzoTcyAjAiwDAxQULE/1YE/zcyAjAiwA3wzFMAAABESVYwDAIN8AAAAAAUQObECSAzgQAioQ3w
AAAAMqEMAg3wAA==')

	atPut result 'data' (base64Decode '
CIH+PwUFBAACAwcAAwMLAFHnEECH5xBAtecQQFToEEAF9xBAuugQQBDpEEBc6RBABfcQQCLqEECf
6hBAYOsQQAX3EEAF9xBA+OsQQAX3EEDX7hBAn+8QQNjvEEAF9xBABfcQQHXwEEAF9xBAW/EQQAHy
EEBA8xBA//MQQND0EEAF9xBABfcQQAX3EEAF9xBA/vUQQAX3EED09hBAL+0QQCfoEEBC9RBAS+oQ
QJjpEEAF9xBAiPYQQM/2EEAF9xBABfcQQAX3EEAF9xBABfcQQAX3EEAF9xBABfcQQMDpEED/6RBA
WvUQQAEAAAACAAAAAwAAAAQAAAAFAAAABwAAAAkAAAANAAAAEQAAABkAAAAhAAAAMQAAAEEAAABh
AAAAgQAAAMEAAAABAQAAgQEAAAECAAABAwAAAQQAAAEGAAABCAAAAQwAAAEQAAABGAAAASAAAAEw
AAABQAAAAWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAA
AAQAAAAEAAAABQAAAAUAAAAGAAAABgAAAAcAAAAHAAAACAAAAAgAAAAJAAAACQAAAAoAAAAKAAAA
CwAAAAsAAAAMAAAADAAAAA0AAAANAAAAAAAAAAAAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJ
AAAACgAAAAsAAAANAAAADwAAABEAAAATAAAAFwAAABsAAAAfAAAAIwAAACsAAAAzAAAAOwAAAEMA
AABTAAAAYwAAAHMAAACDAAAAowAAAMMAAADjAAAAAgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAgAAAAMAAAADAAAA
AwAAAAMAAAAEAAAABAAAAAQAAAAEAAAABQAAAAUAAAAFAAAABQAAAAAAAAAAAAAAAAAAABAREgAI
BwkGCgULBAwDDQIOAQ8AAQEAAAEAAAAEAAAA')

	atPut result 'text_start' '0x4010e000'
	atPut result 'data_start' '0x3fffaca8'
	atPut result 'entry' '0x4010e004'
	return result
}

method esp32_stub ESPTool {
	result = (dictionary)
	atPut result 'text' (base64Decode '
CAD0PxwA9D8AAPQ/pOv9PxAA9D82QQAh+v/AIAA4AkH5/8AgACgEICB0nOIGBQAAAEH1/4H2/8Ag
AKgEiAigoHTgCAALImYC54b0/yHx/8AgADkCHfAAAPgg9D/4MPQ/NkEAkf3/wCAAiAmAgCRWSP+R
+v/AIACICYCAJFZI/x3wAAAAECD0PwAg9D8AAAAINkEA5fz/Ifv/DAjAIACJApH7/4H5/8AgAJJo
AMAgAJgIVnn/wCAAiAJ88oAiMCAgBB3wAAAAAEA2QQBl/P8Wmv+B7f+R/P/AIACZCMAgAJgIVnn/
HfAAAAAAAAEAAIAAmMD9P////wAEIPQ/NkEAIfz/MiIEFkMFZfj/FuoEpfv/OEIM+AwUUfT/N6gL
OCKAMxDMM1Hy/xwEiCJAOBEl8/+B8P+AgxAx8P/AIACJAzHS/8AgAFJjAMAgAFgDVnX/OEJAM8A5
QjgiSkNJIh3wAJDA/T8IQP0/gIAAAISAAABAQAAASID9P5TA/T82QQCx+P8goHSlrwCWWgWB9v+R
9v+goHSQmIDAIACyKQCR8/+QiICSGACQkPQbycDA9MAgAMJYAJqbwCAAokkAkhgAgez/gID0l5hH
gef/kef/oer/mpjAIADICbHn/4ecGoYCAHzohxrhhgkAAAAAwCAAiQrAIAC5CUYCAMAgALkKwCAA
iQmR2v+aiAwJwCAAklgAHfAAAFAtBkA2QQBBtf9YNFAzYxbjA1gUWlNQXEGGAACl7P+IRKYYBIgk
h6XyJeX/Fpr/qBQwwyAgsiCB8v/gCACMOiKgxClUKBQ6IikUKDQwMsA5NB3wAAgg9D8AAEAAcOL6
P0gkBkDwIgZANmEAJd7/rQGB/P/gCAA9CgwS7OqIAZKiAJCIEIkB5eL/kfL/ofP/wCAAiAmgiCDA
IACCaQCyIQCh7/+B8P/gCACgI4Md8AAA/w8AADZBAIGJ/5KgAZJIADCcQZJoApH6/zJoASk4MDC0
miIqMzA8QQwCOUgpWDKgxWX4/6Ajkx3wAAAALJIAQDZBAIKgwK0Ch5IOoqDbgfv/4AgAoqDchgMA
gqDbh5IIgff/4AgAoqDdgfT/4AgAHfAAAAA2QQA6MgYCAACiAgAbIuX7/zeS9B3wAAAAEAAAWBAA
AHzaBUDYLgZAnNoFQBzbBUA2ISGi0RCB+v/gCACGCQAAUfb/vQFQQ2PNBK0Cgfb/4AgA/CrNBL0B
otEQgfP/4AgASiJAM8BWY/2h7P+y0RAaqoHu/+AIAKHp/xwLGqol+P8tAwYBAAAAIqBjHfAAAAA2
QQCioMCBzP/gCACtAjCzIOX1/6KgwIHI/+AIAB3wAGwQAABoEAAAcBAAAHQQAAB4EAAA/GcAQNCS
AEAIaABANkEhYfn/gfn/GmZJBhqIYtEQDAQsClkIQmYagfb/4AgAUfH/gcn/GlVYBVe4AsYzAK0G
gcf/4AgAge3/cen/Goh6UVkIBiQAgej/QHPAGoiICL0BcHhjzQcgoiCBvv/gCACMynHg/wwFUmYW
enGGCwAAcLcgEKEgZfT/cMcgvQGtBoG1/+AIAHoiekQ3tNSB1/9QdMAaiIgIhzerBvH/AAwKokZs
gdL/GoiiKACB0v/gCABW6v6xpf+iBmwau6V7APfqDPZFCVq3oksAG1WG8/9867eayWZFCFImGje1
Ale0qaGa/70GGqqBnP/gCAChl/8cCxqqpez/LAqBwP/gCAAd8AAAwPw/T0hBSajr/T984QtAFOAL
QAwA9D84QPQ///8AAAAAAQCMgAAAEEAAAABAAAAAwPw/BMD8PxAnAAAUAPQ/8P//AKjr/T8IwPw/
sMD9P3xoAEDsZwBAWIYAQGwqBkA4MgZAFCwGQMwsBkBMLAZANIUAQMyQAEB4LgZAMO8FQFiSAEBM
ggBANsEAId7/DAoiYQhCoACB7v/gCAAh2f8x2v8GAQAASQJLIjcy+AxLosEgpeD/Mej+Ien+QdT/
KiPAIAA5ArHS/yGO/gwMoqAFQmIAgeD/4AgAQc7/UqEBwCAAKAQsClAiIMAgACkEgYL/4AgAgdn/
4AgAIcf/wCAAKALMuhzEQCIQIsL4DBQgpIMMC4HS/+AIAPHA/9FK/8HA/7Gu/uKhAAwKgc3/4AgA
Ib3/DAUqMyGr/mLSK8AgACgDFnL/wCAAKAMMFMAgAFkDQkEQQgIBDCdCQRFyUQlZUSaUBxw3dxQe
RggAQgIDcgICgEQRcEQgZkQSSCLAIABIBElRhgEAAEKgEkJRCaKgwIEY/+AIAAyLosEQ5cj/QgID
cgICgEQRcEQgcZ//cHD0R7cXoqDAJcT/oqDupcP/oqDAgQz/4AgABtz/cgIBDNmXlwKGnwB3OU5m
ZwJGyAD2dyBmNwLGcQD2RwhmJwJGVwAGJgBmRwJGhQBmVwKGpABGIgAMmZeXAsaXAHc5CGZ3Akam
AEYdAGaXAoaZAAy5l5cCRoIABhkAHDmXlwIGQgB3OSpmtwLGTwAcCXc5DAz57QWXlwKGNgDGEAAc
GZeXAgZXABwkR5cCBm0AhgsAkqDSl5cCxjIAdzkQkqDQlxckkqDRlxcxxgQAAACSoNOXlwIGOwGS
oNSXlwKGSADtBXKg/0aiAAwXViQogXL/4AgAoHSDhp0AAAAmhAQMFwabAEIiAnIiA3CUIJCQtFa5
/uWq/3BEgJwaBvj/AKCsQYFm/+AIAFY6/XLX8HCkwMwnhnEAAKCA9FYY/kYEAKCg9YFf/+AIAFYq
+4FJ/4B3wIFI/3CkwHc45MYDAACgrEGBVv/gCABWOvly1/BwpMBWp/5GYQByoMAmhAKGfADtBUZT
AAAAJrT1BlQAcqABJrQChnYAsiIDoiICJbH/BgkAAHKgASa0AgZxAJE0/0IiBFDlIHKgwke5AgZt
ALhSqCIMF6Wk/6B1g8ZoAAwZZrQsSEKhKv/tBXKgwke6AgZkAHgyuFKoInB0gpnhJaL/QRH+mOFZ
ZELUK3kkoJWDfQkGWwCRDP7tBaIJAHKgxhYKFnhZmCJCxPBAmcCioMCQepMMCpKg74YCAACqsrIL
GBuqsJkwRyryogIFQgIEgKoRQKogQgIG7QUARBGgpCBCAgeARAGgRCBAmcBCoMGQdJOGQwBB9P3t
BZIEAHKgxhYJEJg0cqDIVokPkkQAeFQGPAAAHIntBQwXlxQCxjgA6GL4cthSyEK4MqgigQb/4AgA
7QqgdYNGMgAMFyZEAsYvAKgivQWB/v7gCACGDwAA7QVyoMAmtAIGKgBIIngywCAAeQQMB4YmAGZE
Akao/+0FcqDABiMAAAwXJrQCRiAAQeX+mFJ4IpkEQeP+eQR9BYYbALHg/gwX2AtCxPCdBUCXk9B1
k3CZEO0FcqDGVjkFgdr+cqDJyAhHPEhAoBRyoMD8+n0KDB9GAgB6kphpS3eZCp0Peq1w7MBHN+0W
GeOpC+kIhor/DBdmhBaRy/6ioMhICVJpAJHH/kClg1JpAKB1g+0FcKB06dEljf/o0eCgdKWM/6Kg
wIEw/uAIAFYHwEICAQz3dxRBRzcUZkQChngAZmQCBn8AJjQCxvj+xh8AHCd3lALGcgBHNwwcF3eU
AkY6AIby/gAAcqDSdxRPcqDUdxRzRu7+AAAAuDKhrP54IrnBgbj+4AgAIan+kar+wCAAKAK4wSBE
NcAiEZAiECAkILCygq0FcLvCga/+4AgAoqPogaz+4AgABt3+AADSIgXCIgSyIgOoImWS/0bY/gCy
AgNCAgKAuxFAuyCyy/Ciwhjlcf8G0v5CAgNyAgKARBFwRCBxef1CxPCYN5BEYxbkspgXmpSQnEEG
AgCSYQ5lXf+SIQ6iJwSmGgSoJ6ep62VV/xaa/6InAUDEILLCGIGP/uAIABZKACKgxClXKBdKIikX
KDdAQsBJN8a4/nICA5ICAoB3EZB3IELCGHLH8AwcBiAAkXX+IXn94ikAcmEH4CLAImEGKCYMGie3
AQw6meGpwenR5VX/qMEhbP6pAejRoWv+vQTCwRzywRjdAoF0/uAIAM0KuCaocZjhoLvAuSagd8C4
CapEqGGquwusoKwguQmgrwUgu8DMmtLbgAwe0K6DFuoArQKZ4cnBJWL/mOHIwSkJgTz9KDiMp8Cf
McCZwNYpAFay9tbMAIE3/UKgx0lYRhYAAABWTAUWIqJBMv0ioMgpVMaF/oEv/SKgySlYBoP+KCJW
cqCtBYFS/uAIAKE+/oFM/uAIAIFP/uAIAEZ7/gAoMhZynq0FgUr+4AgAoqPogUT+4AgA4AIABnT+
FlL7hnL+HfA2QQCdAoKgwCgDh5kPzDIMEoYHAAwCKQN84oYOACYSByYiFoYDAAAAgqDbgCkjh5km
DCIpA3zyRgcAIqDcJ5kIDBIpAy0IhgMAgqDdfPKHmQYMEikDIqDbHfAAAA==')

	atPut result 'data' (base64Decode 'CMD8Pw==')
	atPut result 'text_start' '0x400be000'
	atPut result 'data_start' '0x3ffdeba8'
	atPut result 'entry' '0x400be594'
	return result
}

method esp32_S2_stub ESPTool {
	result = (dictionary)
	atPut result 'text' (base64Decode '
CAAAYBwAAGAAAABgrCv+PxAAAGA2QQAh+v/AIAA4AkH5/8AgACgEICCUnOIGBQAAAEH1/4H2/8Ag
AKgEiAigoHTgCAALImYC54b0/yHx/8AgADkCHfAAAFQgQD9UMEA/NkEAkf3/wCAAiAmAgCRWSP+R
+v/AIACICYCAJFZI/x3wAAAALCBAPwAgQD8AAAAINkEA5fz/Ifv/DAjAIACJApH7/4H5/8AgAJJo
AMAgAJgIVnn/wCAAiAJ88oAiMCAgBB3wAAAAAEA2QQBl/P8Wmv+B7f+R/P/AIACZCMAgAJgIVnn/
HfAAAAAAAAEAAIAAmAD+P////wAEIEA/NkEAIfz/MiIEFkMFZfj/FuoEpfv/OEIM+AwUUfT/N6gL
OCKAMxDMM1Hy/xwEiCJAOBEl8/+B8P+AgxAx8P/AIACJAzHS/8AgAFJjAMAgAFgDVnX/OEJAM8A5
QjgiSkNJIh3wAJAA/j8IgP0/gIAAAISAAABAQAAASMD9P5QA/j82QQCx+P8goHRl1wCWWgWB9v+R
9v+goHSQmIDAIACyKQCR8/+QiICSGACQkPQbycDA9MAgAMJYAJqbwCAAokkAkhgAgez/gID0l5hH
gef/kef/oer/mpjAIADICbHn/4ecGoYCAHzohxrhhgkAAAAAwCAAiQrAIAC5CUYCAMAgALkKwCAA
iQmR2v+aiAwJwCAAklgAHfAAABT9/z/4/P8/hDIBQLTxAECQMgFAwPEAQDZBADH5/zIDAGYjKTH4
/4zSqAOB9//gCACiogCGBgAAoqIAgfT/4AgAqAOB8//gCABGBQAAACwKjIKB8P/gCACGAQAAgez/
4AgAHfDwK/4/sCv+P4wxAUA2QQAh/P+B4//IAqgIsfr/gfv/4AgADAiJAh3wQCsBQDZBAIHb/4II
AGYoCYHy/4gIjBjl/P8MCoH5/+AIAB3wKCsBQDZBAK0CIdH/IgIAZiIykej/iAkbKCkJkef/DAKK
maJJAILIwQwZgCmDIIB0zIgir0AqqqCJg4zYJfj/BgIAAAAAge7/4AgAHfAAAAA2QQCCoMCtAoeS
DaKg22X6/6Kg3EYDAAAAgqDbh5IFZfn/oqDd5fj/HfAAADZBADoyBgIAAKICABsiZfz/N5L0HfAA
ADZBAKKgwKX2/yCiIDCzIKX9/6KgwKX1/5AAAACoK/4/pCv+PwAyAUDsMQFAMDMBQDZhAHzIrQKH
ky0xof/GBQAAqAMMHL0Bgff/4AgAgRn/ogEAiAjgCACoA4Hz/+AIAOYa3cYKAAAAZgMmDAPNAQwr
MmEAge7/4AgAmAGB6P83mQ2oCGYaCDHm/8AgAKJDAJkIHfDMcQFANkEAQT//WDRQM2MW4wNYFFpT
UFxBhgAAJc//iESmGASIJIel8qXH/xaa/6gUMMMgILIggfL/4AgAjDoioMQpVCgUOiIpFCg0MDLA
OTQd8ABw4vo/CCBAPwAAQACEYgFApGIBQDZhAKXA/zH5/xCxIDCjIIH6/+AIAE0KDBLsuogBkqIA
kIgQiQHlxP+R8v+h8v/AIACICaCIIMAgAIkJuAGtA4Hv/+AIAKAkgx3wAAD/DwAANkEAgRL/kqAB
kkgAMJxBkmgCkfr/MmgBKTgwMLSaIiozMDxBDAI5SClYMqDFJfj/oCOTHfAAAAAAEAAAWBAAAGxS
AECMcgFAjFIAQAxTAEA2ISGi0RCB+v/gCACGCQAAUfb/vQFQQ2PNBK0Cgfb/4AgA/CrNBL0BotEQ
gfP/4AgASiJAM8BWY/2h7P+y0RAaqoHu/+AIAKHp/xwLGqrl3/8tAwYBAAAAIqBjHfAAAABsEAAA
aBAAAHAQAAB0EAAAeBAAAPArAUA2QSFh+/+B+/8QZoBCZgBCoAAaiGLREK0EWQhCZholyv9R8/+B
0/8aVVgFV7gCxjMArQaB0f/gCACB7/9x6/8aiHpRWQhGJACB6v9Ac8AaiIgIvQFweGPNByCiIIHI
/+AIAIzKceL/DAVSZhZ6cYYLAABwtyAQoSAl1/9wxyC9Aa0Ggb//4AgAeiJ6RDe01IHZ/1B0wBqI
iAiHN6sG8f8ADAqiRmyB1P8aiKIoAIHT/+AIAFbq/rGv/6IGbBq7JY0A9+oM9kUJWreiSwAbVYbz
/7Kv/reayGZFCFImGje1Ale0qKGk/2C2IBCqgIGm/+AIAKGg/xwLGqolz/8MGiW8/x3wAAAA/T9P
SEFJ9Cv+P3yBAkBIPAFAiIMCQAgACGAUgAJADAAAYDhAQD///wAAAAABABAnAAAogUA/AAAAgIyA
AAAQQAAAAEAAAAAA/T8EAP0/FAAAYPD//wD0K/4/CAD9P7AA/j9c8gBA0PEAQKTxAEDUMgFAWDIB
QKDkAEAEcAFAAHUBQIjYAECASQFA6DUBQOw7AUCAAAFA7HABQGxxAUAMcQFAhCkBQHh2AUDgdwFA
lHYBQAAwAEBoAAFANsEAIdH/DAoiYQhCoACB5v/gCAAhzP8xzf8GAQAASQJLIjcy+AxLosEgJcD/
MYL+IYP+Qcf/KiPAIAA5AiEo/kkCIan+sgIAZitgIaj+wf7+qAIMFYEA/+AIAAycPAsMCoHS/+AI
ALG7/wwMDJqB0P/gCACiogCBof7gCACxtv+oAoHM/+AIAKgCgZn+4AgAqAKByf/gCABBsf/AIAAo
BFAiIMAgACkEBgoAALGt/wwMDFqBv//gCABBqv9SoQHAIAAoBCwKUCIgwCAAKQSBi/7gCACBuv/g
CAAho//AIAAoAsy6HMRAIhAiwvgMFCCkgwwLgbP/4AgA8Zz/0S3/wZz/sS7+4qEADAqBrv/gCAAh
nP9BLP4qM1LUK8YVAAAAAIHK/mIIAGBgdBaGBKKiAMAgACJIAIFv/uAIAKGO/4Gi/+AIAIGh/+AI
AHGL/3zowCAAYicAoYn/gGYQwCAAYmcAgZv/4AgAgZv/4AgArQKBmv/gCADAIAAoAxYi+sAgACgD
DAcMFsAgAHkDYkEQYgIBDChiQRGCUQl5USaWCBw3dxYfRggAAGICA3ICAoBmEXBmIGZGEWgiwCAA
aAZpUUYBAAAcJmJRCaKgwOWc/wyLosEQ5aP/ggIDYgICgIgRYIggYWj/YGD0h7YXoqDApZ//oqDu
JZ//oqDAJZr/Bt3/AAAAYgIBDNd3lgKGpQBnN05mZgJGzgD2diBmNgKGdQD2RghmJgLGWAAGJgBm
RgJGiQBmVgKGqgBGIgAMl3eWAsadAGc3CGZ2AoasAEYdAGaWAoafAAy3d5YCRocABhkAHDd3lgIG
QwBnNytmtgLGUQAcB2c3DAz3DA93lgKGNwDGEAAcF3eWAsZaABwnd5YCBnEAhgsAAHKg0neWAoYz
AGc3D3Kg0HcWI3Kg0XcWNIYEAAByoNN3lgIGRAFyoNR3lgJGTAAMD3Kg/0aoAAwXVqgpgmEOgUH/
4AgAiOGgeINGogAAJogEDBcGoABiIgJyIgNwhiCAgLRWuP6lov9wZoCcGgb4/wCgrEGBNf/gCABW
Ov1y1/BwpsDMJ4Z2AACggPRWGP5GBACgoPWBLv/gCABWKvuBDv+Ad8CBDf9wpsB3OOTGAwAAoKxB
gSX/4AgAVjr5ctfwcKbAVqf+RmYAcqDAJogChoEADA9GWAAAACa49QZZAAwXJrgCxnsAuDKoImKg
ACWk/6B2g8Z3AHKgASa4AoZ1AIH8/mIiBPKgAHKgwme4AoZxALhSqCIMFqWc/wwHoHaTxmwAkqAB
ZrgwYiIEgfH+8qAAcqDCZ7gCRmcAeDK4UqgicHaCmdGlmf9hef0MCJjRiWZi1it5JqCYg30Jxl0A
AABhc/0MD5IGAHKgxveZAoZZAHhWaCKCyPCAZsCSoMBgeZNioO+GAgAA+pKSCRgb/5BmMIcv8pIC
BYICBICZEYCZIIICBgwPAIgRkJggggIHgIgBkIgggGbAgqDBYHiThkUAYVr9cqDGggYA/QgWiBCI
NgwPcqDI9xgCxj4AgkYAeFZGPAAchgwPDBdnGALGOQD4cuhi2FLIQrgyqCKBzP7gCAD9CgwK8HqD
xjIAAAAMFyZIAsYvAKgiDAuBw/7gCACGDwAADA9yoMAmuAIGKgBoIngywCAAeQZ9D4YmAGZIAkaj
/wwPcqDABiMAAAwXJrgCRiAAYaj+iFJ4IokGYab+eQYMB4YbAADBo/4MD+gMDBeCyPBtD4Bnk+B/
k3BmEHKgxveWUrGc/nKgydgLhz1HgJAUcqDA95k+DB9GAgCaYmhmS5lpCm0Pmq6QfcCHOe0W1uGp
DHkLhoX/DBdmiBaRjv4MBogJoqDIaQmRiv6ApoNpCaB2gwwPcKB08mEMJWf/8iEM8KB0pWb/oqDA
ZWH/Vqe+YgIBgqAPhxZEZzgUZkYCxnwAZmYChoIAJjYCBvP+xiMAHCd3lgIGdwBnNwwcF3eWAgZB
AMbs/gAAcqDSdxZfcqDUd5YCBiAAxuf+AAAAgUP9YggAZiYCBuT+iDKhY/5oIoJhDoF2/uAIACFn
/pFo/sAgACgCiOEgtDXAIhGQIhAgKyCAIoKtB2CywoF0/uAIAKKj6IFq/uAIAEbT/gAA0iIFwiIE
siIDqCKlgP+Gzv4AsgIDYgICgLsRYLsgssvwosIYZWf/Rsj+YgIDcgICgGYRcGYggWP+4AgAcdf8
YsbwiDeAZmMWFrCIF4qGgIxBhgEAieHlNP+I4ZInBKYZBJgnl6jtJS3/Fpr/oicBYMYgssIYgVT+
4AgAFkoAIqDEKVcoF2oiKRcoN2BiwGk3gU7+4AgAhqz+AHICA4ICAoB3EYB3IGLCGHLH8AwZBiEA
AIEw/iHW/OIoAHJhB+AiwCJhBiglDBkntwEMOYnhmdHpwSUt/5jRISf+6MGhJ/69BpkB8sEY3QLC
wRyBOP7gCACdCrglqHGI4aC7wLkloHfAuAiqZqhhqrsLqaCpILkIoK8FILvAzJrC24AMHcCtgxYa
ASCiIIJhDpJhDeVW/4jhmNEpCCg0jKeQjzGQiMDWKABWsvbWiQBioMdpVAYTAABWiQQWMp8ioMiG
AAAioMkpVEZ5/gAoIlbynSU+/6H2/YEL/uAIAIEW/uAIAIZy/gAAACgyFiKcZTz/oqPogQP+4AgA
4AIABmz+AAAAFsL7xmn+HfA2QQCdAoKgwCgDh5kPzDIMEoYHAAwCKQN84oYOACYSByYiFoYDAAAA
gqDbgCkjh5kmDCIpA3zyRgcAIqDcJ5kIDBIpAy0IhgMAgqDdfPKHmQYMEikDIqDbHfAAAA==')

	atPut result 'data' (base64Decode 'CAD9Pw==')
	atPut result 'text_start' '0x40028000'
	atPut result 'data_start' '0x3ffe2bf4'
	atPut result 'entry' '0x4002872c'
	return result
}
// Experimental GP FileList
//
// To do:

defineClass FileList morph window directoryName buttonsPane listPane contentPane shortcutsPane

to newFileList {
  return (initialize (new 'FileList') '.')
}

to openFileList {
  page = (global 'page')
  if (isNil page) {
    newPage = true
    page = (newPage 1000 800)
    open page true
  }

  fileList = (newFileList)

  addPart page fileList
  if (newPage == true) {
    startStepping page
  }
}

method initialize FileList path {
  directoryName = path
  if (isNil directoryName) {directoryName = '.'}

  scale = (global 'scale')
  window = (window 'FileList')
  morph = (morph window)
  setHandler morph this
  clr = (clientColor window)

  buttonsPane = (newBox nil (gray 250) nil nil false false)
  addPart morph (morph buttonsPane)
  addPart (morph buttonsPane) (makeButton this 'Delete' 'doDelete')

  lbox = (listBox (listFiles directoryName) nil (action 'updateListSelection' this) clr)
  setFont lbox 'Arial'
  listPane = (scrollFrame lbox clr)
  addPart morph (morph listPane)
  setGrabRule (morph listPane) 'ignore'

  text = (newText)
  setEditRule text 'editable'
  contentPane = (scrollFrame text (color 255 255 255))
  addPart morph (morph contentPane)

  lbox = (listBox (array directoryName 'Documents') nil (action 'updateShortcutSelection' this) clr)
  setFont lbox 'Arial'
  shortcutsPane = (scrollFrame lbox clr)
  addPart morph (morph shortcutsPane)
  setGrabRule (morph shortcutsPane) 'ignore'
  select lbox directoryName

  contentPane = (scrollFrame text (color 255 255 255))
  addPart morph (morph contentPane)
  setGrabRule (morph contentPane) 'ignore'

  setMinExtent morph (scale * 200) (scale * 150)
  setExtent morph (scale * 400) (scale * 300)

  return this

}

method updateListSelection FileList {
  file = (selection (contents listPane))
  if (isNil file) {
    setText (contents contentPane) ''
  }
  if ((byteAt directoryName (count directoryName)) != (byteAt '/' 1)) {
    file = (join directoryName '/' file)
  } else {
    file = (join directoryName file)
  }
  str = (readFile file)
  if ((classOf str) == (class 'String')) {
    setText (contents contentPane) str
  }
}

method updateShortcutSelection FileList {
  selection = (selection (contents shortcutsPane))
  if (notNil selection) {
    dir = selection
  } else {
    dir = (selection (contents shortcutsPane))
  }
  if ((classOf dir) == (class 'String')) {
    directoryName = dir
    setCollection (contents listPane) (listFiles directoryName)
    select (contents listPane) nil
    updateListSelection this
  }
}

method makeButton FileList label selector {
  scale = (global 'scale')
  w = (scale * 54)
  h = (scale * 18)
  nbm = (buttonBody this label w h false)
  hbm = (buttonBody this label w h true)
  b = (new 'Trigger' nil (action selector this) nbm hbm hbm)
  setData b label
  setMorph b (newMorph b)
  setCostume (morph b) nbm
  return (morph b)
}

method buttonBody FileList label w h highlight {
  scale = (global 'scale')
  fillColor = (gray 230)
  borderColor = (gray 120)
  textColor = (gray 100)
  border = (scale * 1)
  radius = (scale * 4)
  if (true == highlight) {
    fillColor = (darker fillColor 15)
	textColor = (darker textColor 15)
  }
  bm = (newBitmap w h)
  fillRoundedRect (newShapeMaker bm) (rect 0 0 w h) radius fillColor border borderColor borderColor
  labelBM = (stringImage label 'Arial Bold' (scale * 10) textColor)
  x = ((w - (width labelBM)) / 2)
  y = ((h - (height labelBM)) / 2)
  drawBitmap bm labelBM x y
  return bm
}

method doDelete FileList {
  file = (selection (contents listPane))
  if (isNil file) {
    setText (contents contentPane) ''
  }
  if ((byteAt directoryName (count directoryName)) != (byteAt '/' 1)) {
    file = (join directoryName '/' file)
  } else {
    file = (join directoryName file)
  }
  deleteFile file

  updateShortcutSelection this
}

// Layout

method redraw FileList {
  fixLayout window
  redraw window
  fixLayout this
  fixButtonLayout this
}

method fixLayout FileList {
  packer = (newPanePacker (clientArea window))
  packPanesH packer contentPane '100%'
  packPanesH packer shortcutsPane '30%' listPane '70%'
  packPanesH packer buttonsPane '30%'
  packPanesV packer listPane '40%' contentPane '60%'
  packPanesV packer buttonsPane '10%' shortcutsPane '30%' contentPane '60%'
  finishPacking packer
}

method fixButtonLayout FileList {
  buttons = (parts (morph buttonsPane))

  r = (bounds (morph buttonsPane))
  y = (((height r) / 2) + (top r))
  extraW = (width r)
  for b buttons { extraW += (- (width b)) }
  interButtonSpace = (max 5 (extraW / ((count buttons) + 1)))

  x = (+ (left r) interButtonSpace 1)
  for b buttons {
    setLeft b x
    x += ((width b) + interButtonSpace)
    setYCenter b y
  }
}
// FilePicker.gp - Dialog box for specifying files for opening or saving.

defineClass FilePicker morph window folderReadout listPane parentButton newFolderButton nameLabel nameField cancelButton okayButton topDir currentDir action forSaving extensions isDone answer

to pickFileToOpen anAction defaultPath extensionList {
  // Pick an existing file to open starting at defaultPath, if provided. If anAction is not
  // nil, invoke it on the full path of the choosen file. If it is nil, wait synchronously
  // until a file is chosen and return its full path, or the empty string if no file is chosen.

  return (pickFile anAction defaultPath extensionList false)
}

to fileToWrite defaultPath extensionList {
  // Ask the user to enter a file name and location for writing. If provided, defaultPath is
  // offered as a starting point. Wait synchronously until a file is specified and return its
  // full path, or the empty string if the user cancels the operation.

  if (and (isClass extensionList 'String') (notNil defaultPath) ((count defaultPath) > 0)) {
	// there is a single extension and the default path is not nil or empty
	extension = extensionList
	if (not (endsWith defaultPath extension)) {
	  // addpend the extension to the default path
	  defaultPath = (join defaultPath extension)
	}
  }
  return (pickFile nil defaultPath extensionList true)
}

to pickFile anAction defaultPath extensionList saveFlag {
  if (isNil saveFlag) { saveFlag = false }
  page = (global 'page')
  picker = (initialize (new 'FilePicker') anAction defaultPath extensionList saveFlag)
  addPart page picker
  pickerM = (morph picker)
  setPosition pickerM (half ((width page) - (width pickerM))) (40 * (global 'scale'))

  if (and saveFlag (isNil anAction)) {
	// modal version -- waits until done and returns result or nil
    setField (hand page) 'lastTouchTime' nil
    while (not (isDone picker)) { doOneCycle page }
    destroy pickerM
    return (answer picker)
  }
}

// function to return the user's GP folder

to gpFolder {
  if ('iOS' == (platform)) { return '.' }
  path = (userHomePath)

  hidden = (global 'hideFolderShortcuts')
  if (and (notNil hidden) (contains hidden 'GP')) { return '/' } // if GP hidden, use computer

  // Look for <home>/Documents
  if (contains (listDirectories path) 'Documents') {
	path = (join path '/Documents')
  }
  if (not (contains (listDirectories path) 'GP')) {
	// create the GP folder if it does not already exist
	makeDirectory (join path '/GP')
  }
  if (contains (listDirectories path) 'GP') {
	path = (join path '/GP')
  }
  return path
}

to gpExamplesFolder {
  return (join (absolutePath '.') '/Examples')
}

// support for synchronous ("modal") calls

method destroyedMorph FilePicker { isDone = true }
method isDone FilePicker { return isDone }
method answer FilePicker { return answer }

// initialization

method initialize FilePicker anAction defaultPath extensionList saveFlag {
  if (isNil defaultPath) { defaultPath = (absolutePath '.') }
  if (isNil saveFlag) { saveFlag = false }
  scale = (global 'scale')

  forSaving = saveFlag
  if forSaving {
	title = 'File Save'
  } else {
	title = 'File Open'
  }
  window = (window title)
  morph = (morph window)
  setHandler morph this
  setClipping morph true
  clr = (gray 250)

  action = anAction
  extensions = extensionList
  topDir = ''
  isDone = false
  answer = ''

  lbox = (listBox (array) nil (action 'fileOrFolderSelected' this) clr)
  onDoubleClick lbox (action 'fileOrFolderDoubleClicked' this)
  setFont lbox 'Arial' 16
  listPane = (scrollFrame lbox clr)
  addPart morph (morph listPane)
  setGrabRule (morph listPane) 'ignore'

  addShortcutButtons this
  addFolderReadoutAndParentButton this
  if forSaving { addFileNameField this (filePart defaultPath) }
  okayButton = (textButton this 0 0 'Okay' 'okay')
  cancelButton = (textButton this 0 0 'Cancel' (action 'destroy' morph))

  setMinExtent morph (460 * scale) (366 * scale)
  setExtent morph (460 * scale) (366 * scale)

  if forSaving {
	defaultPath = (directoryPart defaultPath)
	if (isEmpty defaultPath) { defaultPath = (gpFolder) }
	if ('Browser' == (platform)) { defaultPath = 'Downloads' }
  }
  if (and ((count defaultPath) > 1) (endsWith defaultPath '/')) {
	defaultPath = (substring defaultPath 1 ((count defaultPath) - 1))
  }
  showFolder this defaultPath true
  return this
}

method addFolderReadoutAndParentButton FilePicker {
  scale = (global 'scale')
  x = (110 * scale)
  y = (32 * scale)

  folderReadout = (newText 'Folder Readout')
  setFont folderReadout 'Arial Bold' (16 * scale)
  setGrabRule (morph folderReadout) 'ignore'
  setPosition (morph folderReadout) x y
  addPart morph (morph folderReadout)

  parentButton = (textButton this 0 0 '<' 'parentFolder')
  parentButtonM = (morph parentButton)
  setTop parentButtonM (y + (3 * scale))
  setLeft parentButtonM (x - ((width parentButtonM) + (13 * scale)))
  addPart morph parentButtonM
}

method addFileNameField FilePicker defaultName {
  scale = (global 'scale')
  x = (110 * scale)
  y = (32 * scale)

  // name label
  nameLabel = (newText 'File name:')
  setFont nameLabel 'Arial Bold' (15 * scale)
  setGrabRule (morph nameLabel) 'ignore'
  addPart morph (morph nameLabel)

  // name field
  border = (2 * scale)
  nameField = (newText defaultName)
  setFont nameField 'Arial' (15 * scale)
  setBorders nameField border border true
  setEditRule nameField 'line'
  setGrabRule (morph nameField) 'ignore'
  nameField = (scrollFrame nameField (gray 250) true)
  setExtent (morph nameField) (213 * scale) (18 * scale)
  addPart morph (morph nameField)
}

method addShortcutButtons FilePicker {
  scale = (global 'scale')
  hidden = (global 'hideFolderShortcuts')
  if (isNil hidden) { hidden = (array) }

  showGP = (and
	(not (contains hidden 'GP'))
	('Browser' != (platform)))
  showExamples = (and
	(not (contains hidden 'Examples'))
	(not forSaving)
	(isClass extensions 'Array')
	(contains extensions '.gpp'))
  showDesktop = (not (contains hidden 'Desktop'))
  showDownloads = (and
	(not (contains hidden 'Downloads'))
	('Linux' != (platform)))
  showcComputer = (not (contains hidden 'Computer'))

  buttonX = ((left morph) + (22 * scale))
  buttonY = ((top morph) + (55 * scale))
  dy = (60 * scale)
  if showGP {
	addIconButton this buttonX buttonY 'gpFolderIcon' (action 'setGPFolder' this) 'GP'
	buttonY += dy
  }
  if showExamples {
	addIconButton this buttonX buttonY 'examplesIcon' (action 'setExamples' this)
	buttonY += dy
  }
  if (not (isOneOf (platform) 'Browser' 'iOS')) {
	if showDesktop {
	  addIconButton this buttonX buttonY 'desktopIcon' (action 'setDesktop' this)
	  buttonY += dy
	}
	if showDownloads {
	  addIconButton this buttonX buttonY 'downloadsIcon' (action 'setDownloads' this)
	  buttonY += dy
	}
	if showcComputer {
	  addIconButton this buttonX buttonY 'computerIcon' (action 'setComputer' this)
	  buttonY += dy
	}
  }
  newFolderButton = (textButton this (buttonX + (2 * scale)) buttonY 'New Folder' 'newFolder')
}

method addIconButton FilePicker x y iconName anAction label {
  if (isNil label) {
	s = iconName
	if (endsWith s 'Icon') { s = (substring s 1 ((count s) - 4)) }
	s = (join (toUpperCase (substring s 1 1)) (substring s 2))
	label = s
  }
  scale = (global 'scale')
  iconBM = (scaleAndRotate (call iconName (new 'FilePickerIcons')) (0.75 * scale))
  bm = (newBitmap (62 * scale) (40 * scale))
  drawBitmap bm iconBM (half ((width bm) - (width iconBM))) 0
  setFont 'Arial Bold' (12 * scale)
  labelX = (half ((width bm) - (stringWidth label)))
  labelY = ((height bm) - (fontHeight))
  drawString bm label (gray 0) labelX labelY

  button = (newButton '' anAction)
  setLabel button bm (gray 225) (gray 245)
  setPosition (morph button) x y
  addPart morph (morph button)
  return button
}

method textButton FilePicker x y label selectorOrAction {
  if (isClass selectorOrAction 'String') {
	selectorOrAction = (action selectorOrAction this)
  }
  result = (pushButton label (gray 130) selectorOrAction)
  setPosition (morph result) x y
  addPart morph (morph result)
  return result
}

// actions

method setComputer FilePicker {
  showFolder this '/' true
}

method setDesktop FilePicker {
  showFolder this (join (userHomePath) '/Desktop') true
}

method setDownloads FilePicker {
  showFolder this (join (userHomePath) '/Downloads') true
}

method setExamples FilePicker {
  showFolder this (gpExamplesFolder) true
}

method setGPFolder FilePicker {
  showFolder this (gpFolder) true
}

method parentFolder FilePicker {
  i = (lastIndexOf (letters currentDir) '/')
  if (isNil i) { return }
  newPath = (substring currentDir 1 (i - 1))
  showFolder this newPath false
}

method showFolder FilePicker path isTop {
  currentDir = path
  if isTop { topDir = path }
  setText folderReadout (filePart path)
  newContents = (list)
  for dir (sorted (listDirectories currentDir)) {
	if (not (beginsWith dir '.')) {
	  add newContents (join '[ ] ' dir)
	}
  }
  for fn (sorted (listFiles currentDir)) {
	if (not (beginsWith fn '.')) {
	  if (or (isNil extensions) (hasExtension fn extensions)) {
		add newContents fn
	  }
	}
  }
  updateParentAndNewFolderButtons this
  setCollection (contents listPane) newContents
}

method newFolder FilePicker {
  newFolderName = (prompt (global 'page') 'Folder name?')
  if ('' == newFolderName) { return }
  for ch (letters newFolderName) {
	if (isOneOf ch '.' '/' '\' ':') { error 'Bad folder name' }
  }
  newPath = (join currentDir '/' newFolderName)
  makeDirectory newPath
  showFolder this newPath false
}

method okay FilePicker {
  removeFromOwner morph
  answer = ''
  if forSaving {
	answer = (join currentDir '/' (text (contents nameField)))
  } else {
	sel = (selection (contents listPane))
	if (and (notNil sel) (not (beginsWith sel '[ ] '))) {
	  answer = (join currentDir '/' sel)
	}
  }
  if (and (notNil action) ('' != answer)) { call action answer }
  isDone = true
}

method fileOrFolderSelected FilePicker {
  sel = (selection (contents listPane))
  if (beginsWith sel '[ ] ') {
	sel = (substring sel 5)
	if (or (endsWith sel ':')) {
	  showFolder this sel true
	} else {
	  showFolder this (join currentDir '/' sel) false
	}
  }
}

method fileOrFolderDoubleClicked FilePicker {
  sel = (selection (contents listPane))
  if (beginsWith sel '[ ] ') {
	sel = (substring sel 5)
	if (or (endsWith sel ':')) {
	  showFolder this sel true
	} else {
	  showFolder this (join currentDir '/' sel) false
	}
  } else { // file selected
	if (not forSaving) {
	  if (notNil action) { call action (join currentDir '/' sel) }
	  removeFromOwner morph
	}
  }
}

method updateParentAndNewFolderButtons FilePicker {
  // parent button
  if (and (beginsWith currentDir topDir) ((count currentDir) > (count topDir))) {
	show (morph parentButton)
  } else {
	hide (morph parentButton)
  }

  // new folder button
  if (notNil newFolderButton) {
	if (and forSaving
			('Browser' != (platform))
			(not (contains (splitWith currentDir '/') 'runtime'))
			(currentDir != '/')
	) {
	  show (morph newFolderButton)
	} else {
	  hide (morph newFolderButton)
	}
  }
}

// Layout

method redraw FilePicker {
  scale = (global 'scale')
  fixLayout window
  redraw window
  topInset = (24 * scale)
  inset = (6 * scale)
  bm = (costumeData morph)
  fillRect bm (gray 230) inset topInset ((width bm) - (inset + inset)) ((height bm) - (topInset + inset))
  costumeChanged morph
  fixLayout this
}

method fixLayout FilePicker {
  scale = (global 'scale')

  // file list
  topInset = (55 * scale)
  bottomInset = (40 * scale)
  leftInset = (110 * scale)
  rightInset = (20 * scale)
  setPosition (morph listPane) ((left morph) + leftInset) ((top morph) + topInset)
  setExtent (morph listPane) ((width morph) - (leftInset + rightInset)) ((height morph) - (topInset + bottomInset))

  // nameLabel and nameField
  if (notNil nameLabel) {
	x = ((left morph) + leftInset)
	y = ((bottom morph) - (32 * scale))
	setPosition (morph nameField) x y

	x += (- ((width (morph nameLabel)) + (8 * scale)))
	y = (y - (1 * scale))
	setPosition (morph nameLabel) x y
  }

  // okay and cancel buttons
  space = (10 * scale)
  y = ((bottom morph) - (28 * scale))
  x = ((right morph) - ((width (morph okayButton)) + (25 * scale)))
  setPosition (morph okayButton) x y
  x = (x - ((width (morph cancelButton)) + space))
  setPosition (morph cancelButton) x y
}

defineClass FilePickerIcons

method computerIcon FilePickerIcons {
  data = '
iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAGcUlEQVR4nO2Wy6tlVxHGf1VrrX3O7dtv
88BoREFMJomdYAh5GFQkqAiBDJzoSBD/AkGMD4wggjNn4siBEyHRmZqBIebhJKAziRNjOklHu5Pc9O17
ztlr1cPB6did7oAgiZlYk713wV7721999VXB/+M9Drky8fnvP/oz4KP/4b1nfvO9Bx96xwHc/51f3rJ7
5PDP773j5tuO7S5xG0gq2YAMShTOHvR8/IlnHwe+8tgPvnTmHQPwmW/+4uHjJ4998YMfev8NJ08evn6/
O6RSM7CoeHTqNHHikPD88+dOv/TimZc2q/Xmv/jms7//0Ze/8eZDffNm9P7J2z7+sduOLha8semQyTIL
SWDZOTotWUsgPTl10wduvO/WG2/UUBBwMSwr4DQKFk4qSEAolCgEzvl58Mivn7iagXu/++iP0+2rx44d
PSGCIIKQZApkgoLkpWolICQAgaACZJIiSEJKIgiZlyhOAhD29s7vSal/Bp556uEHH6oAGfGJrz1wz8nj
u0tEAiJoUyM8qFIIdSBpFJKklLI9NRwkESqeQDp9JEWFkKAUxV0RhSQZFmjK8de7f+qnj/zhUgkygn/u
z6xwZq88/cSTvPr6HlUaNYNIhQx0UpokHgVRoYqBK5ZO1YaTBB1CUa1EGCYF686Ja49x7513MDVlHU5G
vBVAacrBOmgkrSw5deoOliikYwKHasMKFHOkFgRHom45FsPY5goVz8Rw0sAAteTM2TO0pdIdRn8bAO5J
UPDYsHPkGLY5YK8D0aEpm6iICBAkUHUrBlOhioAHpkBAaiKpRGxVqKUw7SxY9URT6OMKAOGBzYNegiaF
1f4F7rnrbq659gRThZEwBXiFRfm3CsFgCGiBAjhQEsYAvXh6JLz44qv87rd/JFMYAtNCCb+cAXdMhEVR
UiArnN+see25fSRAJyezog7RHJFKtS2ObELmgAFQoDg9lUl8m4rCtLPDoiYjBxqFPgfpfhkD4UTA3IWS
wTBhdcGIAG0JLkxhZAXzSpPkYAStKqyCmAoZgMa2bRGGwzChVmf9xj6zJdkLcxiqhYjLAKQFGoK0ZGQi
MWPeyQCVRvbOXBbUdIjBSoTqhpVGFkeG4iLoSEQLwSCsoMWYN0CpWA7SB02EMRtpb9GAs5aOjoK6El4g
EymFuTuqE0U7lhU3o5SKtIkxBqVCeIIM+qgwOZiDGKtNsGjKZsz0SEwTDHpJ4vISpDvmSUmlNCfSOTCn
iaDieDb6nFtPaAUhubB2ShHmNbRqiNWLbToYVik5I1KYo5C2FeZmDrIE6eUKDbgjEaR3VtoY3YnRmatC
GFVB0tl3QzPpOaEi9HRKKURXsnQ0lDE6uCELRSQY7ghK2gYJJQl8rK5mYLUKcnTqYcMlGVGQ1WAquR3H
JJM0kERl4FYp4tgmGCRTT3wSiitZC2M2rGy7tUrSpiURfdufoVcz0AjaiV0ywEdSTTC2Vio9t80uA03B
QkC2ZjLmgWWhThVfGX2RFEs2B4Y2o7WJIcKmO2aBAelvowGvyVjPF91DyCqINnrfCs0SahqIECb0DJZS
kWVjxys9nRGDFo3ZHBbCVBuekF1YH8x4CcIcRK5kIOg9aZPSfTBiw/COb5LWCuHG2VfO8fSTz7BoC6bS
kATXxHEyFRuDqS6Y586dd9/ODde9j41PmCYinZ1FxTaOSqVrXO2ERWDuRlEHr3iAUBlzZ0Thb399gZtv
uhWpoKqIO1kqmUkTochguOIxOP3C37nu+mswSzyCMlUsCqmFDYPa30YD+yNYSjK6sGHDa+f22D15hMBR
lC88+ABHj+xgNqhVwAUHMguizkIam0gQo1+YOX3mZXrvTLuNc2f+gUlHVCmmWHClBoJFBLZY0CS45sS1
PPXk06z3Z0ZsmGSx3WfEkWmCPrCiVIfQBBHEwJlRqaAFcSgSjCocOnSYU7ffwsqDYkGEkH7FOD4YzlSD
de/cedfd3PfZTxO+AZbUpsQYeElibLWCVawmZRhORcIpk+CSpFVaNXwGz5lpucv+/nlePv0KZs6Ifmkc
f+Rz39aMmGNeHax93tUInvvLn0ChaCPSyKFQHXNoVEYxKoKZbr29JAsN0gpdt1tIkUJVQWswPEgKYpBF
KcuaGVsEAvDh+7/1APB1YIf/Xfzq+cd++BNh601HgOuA42x3i3czAngDOAvsCVsWGtu/ny4CejcjgQ6s
L17f2/gXyOtCx6O7RQgAAAAASUVORK5CYII='
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method desktopIcon FilePickerIcons {
  data = '
iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAGcUlEQVR4nO2Wy6tlVxHGf1VrrX3O7dtv
88BoREFMJomdYAh5GFQkqAiBDJzoSBD/AkGMD4wggjNn4siBEyHRmZqBIebhJKAziRNjOklHu5Pc9O17
ztlr1cPB6did7oAgiZlYk713wV7721999VXB/+M9Drky8fnvP/oz4KP/4b1nfvO9Bx96xwHc/51f3rJ7
5PDP773j5tuO7S5xG0gq2YAMShTOHvR8/IlnHwe+8tgPvnTmHQPwmW/+4uHjJ4998YMfev8NJ08evn6/
O6RSM7CoeHTqNHHikPD88+dOv/TimZc2q/Xmv/jms7//0Ze/8eZDffNm9P7J2z7+sduOLha8semQyTIL
SWDZOTotWUsgPTl10wduvO/WG2/UUBBwMSwr4DQKFk4qSEAolCgEzvl58Mivn7iagXu/++iP0+2rx44d
PSGCIIKQZApkgoLkpWolICQAgaACZJIiSEJKIgiZlyhOAhD29s7vSal/Bp556uEHH6oAGfGJrz1wz8nj
u0tEAiJoUyM8qFIIdSBpFJKklLI9NRwkESqeQDp9JEWFkKAUxV0RhSQZFmjK8de7f+qnj/zhUgkygn/u
z6xwZq88/cSTvPr6HlUaNYNIhQx0UpokHgVRoYqBK5ZO1YaTBB1CUa1EGCYF686Ja49x7513MDVlHU5G
vBVAacrBOmgkrSw5deoOliikYwKHasMKFHOkFgRHom45FsPY5goVz8Rw0sAAteTM2TO0pdIdRn8bAO5J
UPDYsHPkGLY5YK8D0aEpm6iICBAkUHUrBlOhioAHpkBAaiKpRGxVqKUw7SxY9URT6OMKAOGBzYNegiaF
1f4F7rnrbq659gRThZEwBXiFRfm3CsFgCGiBAjhQEsYAvXh6JLz44qv87rd/JFMYAtNCCb+cAXdMhEVR
UiArnN+see25fSRAJyezog7RHJFKtS2ObELmgAFQoDg9lUl8m4rCtLPDoiYjBxqFPgfpfhkD4UTA3IWS
wTBhdcGIAG0JLkxhZAXzSpPkYAStKqyCmAoZgMa2bRGGwzChVmf9xj6zJdkLcxiqhYjLAKQFGoK0ZGQi
MWPeyQCVRvbOXBbUdIjBSoTqhpVGFkeG4iLoSEQLwSCsoMWYN0CpWA7SB02EMRtpb9GAs5aOjoK6El4g
EymFuTuqE0U7lhU3o5SKtIkxBqVCeIIM+qgwOZiDGKtNsGjKZsz0SEwTDHpJ4vISpDvmSUmlNCfSOTCn
iaDieDb6nFtPaAUhubB2ShHmNbRqiNWLbToYVik5I1KYo5C2FeZmDrIE6eUKDbgjEaR3VtoY3YnRmatC
GFVB0tl3QzPpOaEi9HRKKURXsnQ0lDE6uCELRSQY7ghK2gYJJQl8rK5mYLUKcnTqYcMlGVGQ1WAquR3H
JJM0kERl4FYp4tgmGCRTT3wSiitZC2M2rGy7tUrSpiURfdufoVcz0AjaiV0ywEdSTTC2Vio9t80uA03B
QkC2ZjLmgWWhThVfGX2RFEs2B4Y2o7WJIcKmO2aBAelvowGvyVjPF91DyCqINnrfCs0SahqIECb0DJZS
kWVjxys9nRGDFo3ZHBbCVBuekF1YH8x4CcIcRK5kIOg9aZPSfTBiw/COb5LWCuHG2VfO8fSTz7BoC6bS
kATXxHEyFRuDqS6Y586dd9/ODde9j41PmCYinZ1FxTaOSqVrXO2ERWDuRlEHr3iAUBlzZ0Thb399gZtv
uhWpoKqIO1kqmUkTochguOIxOP3C37nu+mswSzyCMlUsCqmFDYPa30YD+yNYSjK6sGHDa+f22D15hMBR
lC88+ABHj+xgNqhVwAUHMguizkIam0gQo1+YOX3mZXrvTLuNc2f+gUlHVCmmWHClBoJFBLZY0CS45sS1
PPXk06z3Z0ZsmGSx3WfEkWmCPrCiVIfQBBHEwJlRqaAFcSgSjCocOnSYU7ffwsqDYkGEkH7FOD4YzlSD
de/cedfd3PfZTxO+AZbUpsQYeElibLWCVawmZRhORcIpk+CSpFVaNXwGz5lpucv+/nlePv0KZs6Ifmkc
f+Rz39aMmGNeHax93tUInvvLn0ChaCPSyKFQHXNoVEYxKoKZbr29JAsN0gpdt1tIkUJVQWswPEgKYpBF
KcuaGVsEAvDh+7/1APB1YIf/Xfzq+cd++BNh601HgOuA42x3i3czAngDOAvsCVsWGtu/ny4CejcjgQ6s
L17f2/gXyOtCx6O7RQgAAAAASUVORK5CYII='
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method downloadsIcon FilePickerIcons {
  data = '
iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAHSklEQVR4nO2W249fVRXHP2vvc87v9+tM
O+20UGg77fTKTVEiGhS8xAfUhIQIiS/6ZGL8C0yMeImYGBPffDM++eCLCcgbCRFJxWKioCAWaMVO7xcK
zHRmfr9zzt57reXDFFqKiYkBefH7ci7JOftzvt+11zrwf33AkmtvfOmHj/4C2Pcfnnvm8R888NB7DnDv
93794an107+85+M33zEzNURLRjzgNeBGtMjFcfKnDj77FPC1J370lXPvGcDnv/2rhzfOzty3Y+eN22Zn
p7euJAUPVG4Uq1BLVE3DpnXC8eOvnzpz+tyZbtJ2/8Waz/7uJ1/91lsX1VsnOaVP3/GRA3dsGAy41CVw
Z+gRxyie2NAMacWQ5Hz0pu1zn7l9bi5YAAGVQvEKUGoixRQPIAYWIFrEUJb7zCOPHXy3A/d8/9Gfupav
z8xs2CSCIILguAu4QwDxK2k5IDgAhhAEcMdFEAcXRxDcr1jsGCAsLS0vSayeB575w8MPPFQBuNmd37j/
7tmNU0NEDMyomxpTo5KIBQWcmojjxBjX3moK4ggV6oArKTsxCCZGjAHVgARwnFyM4LJxMennfv7I769E
4Ga8ttIzQem1QiwhVU/witoV9Yi4EppImqxy9OgpXn9jkdQu4yXQjBpu3LqVPft3M5yKiEVCrFDtyRKx
4nhwrMs0daA1xc3eCRDrwLg1ahwPQsnC0J3iRhFjqqp57oWXuHDiLFu2Xs/c9hsYNfuQILTdCm8uj3nq
4NPcvH8/e/btprOMKxQKlQZUC/UwkBRy+jcAqo4RUesITUPjhWwVwRWLzm+f/BOj0RQ33XwrIUaqsJZ7
Boaj9WxrppidneXEydMcO32aT971CWIIBBUUR6OTEwQXUr4CENaiNEqf6UpGPaJ9JqtQvEBVc+jQ82yY
mWHLthsITYW6stxOWFxeZXFpmaXxmN6NUNXsmp9nejTLoYN/xMXwCnpLTMaGu5AFmkHA9GoHVCkiDGLA
BUycIkplFUdfWWDdsGH97GakQC+Zvs/c94VP4YDXaxvl8ceeZjSahqhMz26EUPjLiy9x6y23oSEyiJns
mWCR1BuuegXATDGDPgnRDWsiFUKrzvHzF9g5N4erohWoVvTdmL8ePkFdBSiONUKbnGpk4I5IZHr9RhZO
nCbt7YhUeFXjyemtEELETK9E4MUIJsTg5OCI9RRNnDl9is0zm4lZySWgxSFn+qKgieJKjhnLhYJixfAS
0ZLRUrFl8yYW/nmGTKQvPa6ZGrC+4OWqCEyVVhIhR4IGtIkEMSZdTwwNRRqEjr5z+rajbTukbsg5Eysw
dSarS3iBalRTixBiQT2QujFtHl8u3AAFUnTs6ghclaJO9ECsFXNo1SnFqWrD3MjJ2DW3gz237qYJ8PfD
x4hR6Fuoq8KDD36ZHGHhyDEWFi7QmCISUK/xUpF0bUt7NFzjNTWgipjhmpiEmpgzJgWpa/pSkFgA48mn
D/Hiqy+zd/d+ggjJlRgjlgIvHH2FY68u8Pq5i8xt34XVFeJOrAOOY7kjhnU4hubJ2w6EtxyYTIzV1Y6c
WkpwskUaqdfyMhAR9uyc5+LZN7hw9iSmRnSldJlJSZz8xynOn32Tndt3EeqakpQ2ZQaDBhGlGYwwS8Da
hPKrAUyVGmNq0xRNHFCSUxVh83Ub6VUpySgacTF2zs1x9MhJLr5xkWJG7jvOnjjHwrFTbL9+OylA0cJ4
nBkvr3DddVvIxZj0hVKMrhhZ/d0OaOVM2p62VzDBKyGOBoym1tFbT++KWsGDs2Nujj8/9wIXLyyzOFnl
1MJJ5ubnKaJwudOVoGzaPENsakoSxqsdGg0rea1BvdMBIyVHJJAtk7Qla2J1aYX9B/bS9y1pMqHPRuqN
pmq4ZX4/L798hMN/O8LWuR0kVURqcoLUJ6ztmNt9gMXVjl4SU8Oa0ilSKrLL253wbQeiQJ8KdXBEa9RA
qFhaXOKmW24nJyf1kB06N7wKbN02x7bt8wyqhlEtqGZSHtOXjts+djtLl1YpnWFWkUrAQ6STTEj+7hpY
yQaqlD7QhR5T6CSxnDvG3YQ777mL9TMjxpcuUfoJVpQKiB7oU0/XOpeWJ4ym13P33Z9lZZIZj8fEgeCl
0HuLhEC0QDGu7QPGwIwyGBBzppIaFUNSxD1TrOf8mTPs3TfPzn27OXb4CJfaDludYMEZDIfMTG9g34f2
0DQDTpw9hWdjVAu9KoSAWWGiRiyGmeB6zTgeZ6WpjFIKjQ/w6JhPEIZYBMsdJ8+fZVAN2f/hAwyraWRU
EXOhy067usJqu8xrS4t4qairQu5BvacZToEFpDilKNnSlf+B3V/8bnCz3vrJuNV+KpihrEKAGGrMW9JK
gEopCoUJS0uvUSGUEqhFyNEZhLU5kEKBAlkiVRBCZbQrHU5ECngMxGHlbmsEAjB/73fuB74JjPjf6TfH
n/jxz+RyIa4Hrgc2AvF9XtiAS8BFYElYc6Fm7euby0DvpxxIQHv5+MHqX/OFuc65fm3hAAAAAElFTkSu
QmCC'
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method examplesIcon FilePickerIcons {
  data = '
iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAG3klEQVR4nO2Vy69eVRnGf+9aa+/vOz2n
Pee0tCCltGiBWgNY0MQoGqOGoDEhMmCiIxPjX2BixEvExJg4c2YcOXBiAjpQiSgSjGFEDAFj0UQ5vVku
DW3Pd77LXuu9ODglLS2JiQGZ+EzW3it7rfXs533W+8D/8S5Drp747Hcf+wlw+D+se+bx7zz48NtO4L5v
/fyO5Z0rP733w0eOrS6PMW1IJKIDwsmeeW1a46mnn30K+NIT33vo7NtG4FNf/9kja7tXP3/Tze+5cffu
lesn1SASJRz1gnml9D3rO4SNjXOnzpw+e2Yxmy/+izOf/cMPvvi1N17KGw+t1o8fu+u2Y7tGIy4uKkQw
jkzgaFR29WPm4kgNPnj7/gOfuPPAgeQJBEwUjQIYHRl1IxKIgyfInnGMzaHx6C+fvlaBe7/92A/D9Mur
q7vWRRBEEIIIgQhIIHG5WgEIAYAjJAEiCBEkICQQhIjLEgcOCBcubF6QXJ4DnvnTIw8+XADC/UNfeeBj
u9eWx4g4uNP1HW5OkYwnA4KOTBDknLd3dQMJhIIFEEZtQU6Ci5NzwiwhCYKgqZNC1s5X++SPH/3j5RKE
O69OBmYYgxXEK1IGUhS6MCwyEkbqM30KzDKShSKKaKLFgpI6jMAYEM+kXDAbaJJxDSIFvmj0XWLuRri/
mUDuEtO50xFEErQJ4wg0HBVnpetpgFVHSiChuBYQSDkYcCSMIiNMgoU3wkBRiiXMlG6cqAatvgUBs8DJ
mC9IfU/WgRdePMHLZ04z18pSXmJlZZlbbz3E3hv20iUgGpoSJTJiyslXXuXEP08xmU6YThYsLY1ZW13j
9iO3MV4d0SqkEGq7ioCbo0OjZqeTTAyNX/36Sfbt28tNh95H6jqyKpPFguf/+jfS8Rf5yEfvYUe/TAtn
1hrP/fl5prOBfXuuY339epZGhUErFy5u8cTvn+Iz99/HaFxoAv0o4XalAmaoCKOcCAGX4Ob33szetX1I
QOqMKEvs7pZYXd/J1mTOk799hvs/92k0OY//5ncc3H+QGw4eQIrTIuFiSN+xvuc66HpG2WnRSJ6pgxNm
VyjghjsMVcjheJ/JaYlqICXAhM6VKGBeWFleYd/+m2gR6FQ5eMtt7FpeRcW3ry2CGjQTSjZEjcgdUYPB
lZQy7lcQCHWSC9IFLYLiA2YVs0qRDlqlpREZA28MIogrGoYWRSJQjKSBpIzTCM1IVuoASmbQATGhE6EN
SuibPGDMpZJaJlnC+gwRSE60Zoj05FSxKJgqORdSN6I1BQnMArzStEBnoAaitCHoijDojMGdkhIo1Bz4
lSUIM9SCHIncGR4wN2esTsKJKGiN7fKUjBDMBkNdqFWwS1fSEiRtqBVyVJBE80xoplbQcCI7YfkqD5gh
7oRVZqkjt0a0SnMHV3ICCWNqRoqgRYeZM1eFBK0lBhrigmoDN6RPCEHzRgDeFuS0g8CxNrtWgdnMiVYp
K0rkjEZG50qXg9j+ik4uNR5R3J0cxjA4c2uMFz10hexpe31VbDurEDH60RI2VEiAp2sV6HC69WXCodZG
VgEMk4y0gJRBFDHBQnAcdacNC2xQYodgc6X1QbZgmCmpGKXrUHNmg5LVUSDsLTxgJWjzASjkEKIIdB2t
NXIBDSihIIKrMKuVOgiMO0Zdj0bQotFFR1WDXujKdkhZFaZbC5aXM64GIlcr4NQadH2iWsO8sRhm2Hnb
TjacCCF3hZIKo9IzpuASDM2YWcOHRJd75jNF2xwxZUsKlMRgM5bHHbpoJCnU5Nd2wiwwVKXvwFvHyq5d
3Hr4CHv27GQ2OJMLm2ycOMXWbIKnzMIag4NqIoUwysF0PmW01HH0A+9nfW0NSUu8+sprbJx8iaoJSZkF
jVIveyC94YFJczBDh8QiDdx19zGmMeP4xj84c/ZfNAnuvPsoe9ZX2Tx/jtnWFK8Vb87FzYucf33G3hv3
c8c9x2iLYOPkyxw/fhxNlaNHb2eIOZIS2RPqXO0BZ+SOjkbk1ijScfLMKaIlLJSSCtPNTWaT1zl05DDH
7r6LljMvHf87aSw88NAXEIWXz53m9IkTkApiMC6wOZmwOZniEczMyeq4C2FXxfG0GX1xVJU+RkQOPGYI
YzyDt4bl4ORLJzjbJ9CCliAvlL+88CLiRu4FkyBa0BWlDWAx0I+XwROigarRvF6O41vu/2YK98GH2XRu
w3Jyx9iCBDl1eMypkwTFUIOOwtagFATVtN3bczBKji0yNSkoNMmUJKTizCcLgowoRE7kcYnwbQYCcOi+
bzwAfBVY4n+HX2w88f0fySUj7gT2AWtAfocPduAi8BpwQdhWoWP77/tLhN5JBFCB+aXx3cW/AeX3f9I8
jvGZAAAAAElFTkSuQmCC'
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method gpFolderIcon FilePickerIcons {
  data = '
iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAGeUlEQVR4nO2W28umVRnGf/e91nreb+ZT
ZyMlbsZtGyEdEwqCbEMH0saUDPTAjoLoLwgi25BBBJ11Fh11IFGgWRCFB4kRHnnQ2ZibHCgRsnBmvvne
93nWujcdvOpMM0IQmifdJ88G1rOu57qu+7oX/L/e4ZILX3zmu4/+BHjPf1j31G+/c++DbzmAO7/1i1t3
L73kp3d8+ObbD+3u4DaQVLIBGZQovLLf84knn34C+NLj37vv5bcMwKe+/vBDh48euuuaa6+86ujRS67Y
6w6p1AwsKh6dOk0cOSicPPmPv770t5dfmteb+b/Y8+nf/+CBr73+UF+/Gb1/7Pbb3nf7ZasVp+cOmexk
IQksO5dNO2wkkJ588P1XH/v48WPHNBQEXAzLCjiNgoWTChIQCiUKgXNmGTzy2JMXM3DHtx/9Ybp9+dCh
y46IIIggJJkCmaAgeU6tBIQEIBBUgExSBElISQQh8xzFSQDCqVNnTkmpfwKe+uND9z5YATLiQ1+556NH
D+/uIBIQQZsa4UGVQqgDSaOQJKWU7VfDQRKh4gmk00dSVAgJSlHcFVFIkmGBphx+tfsnf/zIH85JkBH8
fW9hjbN4RaIjdUGz0tJ5+OFfcfDADjopTRKPgqhQxVjWgy/edxc//9mvueMTH+HKay5HoqCl4r4wpBCW
pCYxD6ambMLJiH8HUJqyvwkaSapgQ9jJxDL4wPFbuOLIUaxAMUdqQXAkKmf2zqAlufn4LTzz7PNEBNcc
u5o5BulgGNUVd6PtKN1h9DcB4J4EBY8ZnSamNEZUNB3RLX3iggPZnapAGj0D80INuPa6GznxzIvs95kb
rr+BDEddcBIvyeigKfRxDoBupQxsGcw28Cz4MhguWBrUhoXiYXSCLAIKJmApmCdLJqaClMqNN93EX557
medOPAuaZIUlOuv9IFMYAtNKCT+fAXdMhFVRUiAkMXFqVMYSKIaJoiNZMIRK8a2xUsC8c/rV04wloDiH
3nU5f37hRa5673UQ4FpYlcHIgUahL0G6nwMQ4UTA0oWSQUyFijAHaEtmFw6akRXcK1WSjQW1KAxheOEL
939uy6e+1nYGJ545Sa0OI8nayJ4sYagWIs4DkBZoCNKSkUmNBUslA1QazJ2xUgoOMZhFKG64NsoB5TeP
/Y7ugUYiWgiM/TML9z/weZYZKBVsQVxoIozFSDtPgnBnIx0dBXXFp4JKIKWwdMdkIrXjWXEzSqlInTAb
aFFuvfU2EMOtQhMwY+/sGc7Og1VT5rGgpVBVwaCXJM6XIN0xT0oqpTmRsPGkiaDiRAZLz608tSAky+IU
FbpBLYZ4xRXUBuaVGIGgLFFIg+7bls4SpJcLPOCORJDeWWujjEGIsVSFMCyMTGffHc1kZENFGBkUVcZQ
sgwkBLMB4UQRpATDHUGJMVP0IEngY30xA+t1kKNTLzGyFMwLsh5MJcmAzKRJBQEVw71QxLEeGEkbCa1S
Qrfru7MZjgBVkml1AF/61qShFzPQCNqRXTKg90FNxTBMCj4S8wJi2zBKAQkyAuvb7Kit4htjTEnxZL02
+mamtYkh20wpFhiQ/iYe8JqMzQJUSgrZBNFG7wNXZ0mnpoEIYVv6V1JhaqyiYumMHLRsdHOYhGlqeEJ2
YX+Z2d0thDmIXMhA0HvSJqX7wGNQteFz0loh3IjeWWQ7lqfS2EFxSdycnomNwVRXjM729GTOvCimiUhn
d6dh80Cl0jXeSEJ9nYEisHSjaSLe8AChMpbBMoMyQU4YwpzB7IMeYK5oCgeaEGEgAzQxgWGJzUFEpZuS
WphloD0v9sDeCHYksWh0nZl8xZBO4PTR+eepU5SS2xyoAi4EkKmIBk0qPRLEqVk4O3d670y7jRzGIs6B
sqKYYsGFHghWEdhqRRmDKg2XQHohc3DX3Z8FVUQMWa1g6YxSaA6uiYggBsZMkQpaEYcXnjvB4g6qRBhr
D4oFEUL6BeN4fzhTDcyMKVdkSSLXCDs8++LzxBh4SWJsvYJVrCZlGE5FwimT4JKkVVo1vIPnwrSzC6GI
JWbOiH7uPHDDp7+pGbHEst7f+LKrEThnQaFoI3JD31Oojjk0KmcXoyKY6TbbS7LSwOdCVwODIYWqgtZg
szeTFMQgi1J2amZsEQjA9Xd+4x7gq8AB/nf1y5OPf/9HwrYTLgXeDRwGytu8cQCngVeAU8KWhcb27yfe
mOhvWyXQgc1r13e2/gVQdXt4J1UXiQAAAABJRU5ErkJggg=='
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method homeIcon FilePickerIcons {
  data = '
iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAGwElEQVR4nO2WzY9mRRnFf09V3ft2093T
PTPdAwMMYYAw+IGIwZVojAuiiUpk4UZXJsa/wMSIHxETY+LOnXHlwo0J6I6EBAmokCABDJgQ0DDKMMOH
gWG6+31vVT0fLl5gYCAxMSAbn03de5O6z6lzTp0q+H99wCUXfvjCj+76JXDNf5j34N0/vO329xzALd//
zfVrG+u/uvmT1924ubaCaUciEQMQTvbMy/st7rv/kfuAr9/z46+eec8AfO47v75j69DmFy+/4uilhw6t
X7zbDCJRwlEvmDfKOHLwIuHkyX899/ypM89P88X0X/R85Pc//dq333gpbzz01j594w3X3nhgNuO1qUEE
K5EJHI3GgXGFhTjSgo+fuOzYZz527FjyBAImikYBjIGMuhEJxMETZM84xrnaufN397+TgZt/cNfPwvQb
m5sHDoogiCAEEQIRkEDivFoBCAGAIyQBIggRJCAkEISI8xQHDghnz547K7k8Djz4xztuu70AhPtN37z1
U4e21lYQcXBnGAfcnCIZTwYEA5kgyDkv/+oGEggFCyCM1oOcBBcn54RZQhIEQVcnhWy92uyzv7jzgfMS
hDsv7VbmGNUK4g0plRSFIQyLjISRxsyYglqDxx5/khdPn2LMM645cZyrjx9HSsaoiGdSLphVumRcg0iB
T51xSCzcCHcA0hsA8pDYXyw1Dhd6F6QH2p1unTEXAqEtlAceeJAscMP1N3HNtddx5sxL3H3v/VSdKDID
yUzeaRZ0VcQC78qwkmhAb+8CwCwwT0w60UmUULo75obkoHaHGjzx5NNsbW6zfegIEMg4cOyKq7h0+xKe
PXmaRetU72CJ8CB1MA9MgnkLTKH1CwC4OVo7k3YsMlY73QQNhTLQLWHemcRQYGNzA0uChqAWdGC2sU63
QCRhLeG9QwqiQPXGfN+JELrAOEu4+Vs8YIaKMMuJEHAJVIzihV6dNBpdCqkFBw5vUadYup1lA7NOr50y
DFRtNBKjON0AB0uZWe706CTPtOqE2XkA7oY71CbkcHzMFITJIQ0BJoyuy9U0CHMWbpScYApiyHTPtF5p
sdyk3aCrUIpBD6IMRAuqKyll3O0tHlAnuZBT0FMgXlFrmDVQiHmj9oT2YGfrAOf254RWLAxNHeudRZ+4
7OhRomesd1pNCEadnE6maiWsMwBeldC3ecBYSGPqjaiOWYYIJCdqMzSNRGpoCKsb6xzZPoiRUFUigt6N
jfWR2eoaNYzeDaOyN3VCjEXfp7qjKWgW1By4vZUBM9RiGRqD4aHsq9G6E9KxcBY1aAvn7Hxi8/BBzu1X
zIWpCrVPrM42OFfnhHaaZqwZQqJ6JrTQGkzVWdBRSxd4wAxxJ6wxTwO5d1yUWhK4UhJIGLumpAhy2kTV
mMzIKVErbFy8yWK+oPcGpsgsIeJ0WwLxPpHTRQSO9fk7GZjPnb29id4WaAq6Z3TeST0Ih4hglEKRwqMP
P0RKiRyGNqXh/Oneh+gaiCUomV6NRTfcHRFjnK3i3pbbwt+FgQFnOLhGOLTWKZFQFJWMtICUeeWVFzn1
j+dxEza3EuqOtk7yhLvw8B8e4fiHr+TQ5hbTvpIGZRhGuiwzJaujQNh5D7yZA1aCvqhAIYcQgyBpoLXO
6dOneOqpv7GSYXtnh53DO0yqzKzAOLDihcNHjvDCiy/w+J+fIAhOfOQElx/dxgKiCft1Ym0t42ogciED
TmvBMCaadcw7JQ3YFPzl0cdorXPVsSuYra6QSGTJlACTwNRoEWjv7Owc5fDhS9jbfZWnH/srZ/65zYc+
8VFEGmsrAzp1khRa8ncmYRaoTRkH8D5gGYRCqHD5ZVczDgMGKIqHI2YEhYjEIMLqIHRTJAUbm+usrZ/g
2WdPo5OTx0LzhKTMRKe0d/HAbndWJFAfaGlitBldGj4kdvd2QRI5B6ZKLgImOBCRkOQMUmgeIEaJjCeh
lEKeCdGVKsZqnpE1oc6FHnBm7uhsRu6dIgMmjrTMl7/yJWZpZXmfEUVmM6iNnjODgaVARBAFZSJLgVQQ
gyzGE39/BlLCXZmbk9VxF+JtEriz342xOKrKGDMiBx5znnn6JGVYnm6WA+9Lr6AFLUHuilEQN/IomASh
haEoVsGiMq6sgSdEA1Wje3vzOC7HP/+9FO7V63x/YXUtuWPsQYKcBjwWtN0ExVCDgcJeVQqC6lL/noNZ
cmzKtKSg0CVTkpCKs9idCDKiEDmRV0qELxEIwJW3fPdW4FvAKv+7+u3Je37yc2GZhhvAEWALyO9zYwde
A14GzgpLFgaWqx9fB/R+VgANWLw+frD1bzxSo16udU7bAAAAAElFTkSuQmCC'
  return (readFrom (new 'PNGReader') (base64Decode data))
}
// Float

method toInteger Float { return (truncate this) }
method toNumber Float { return this }

method floor Float {
  result = (integerPart this)
  if (and (this < 0) ((this - result) < 0)) {
	if (result == -1073741824) { result = (toFloat result) }
    result += -1
  }
  return result
}

method ceiling Float {
  result = (integerPart this)
  if (and (this > 0) ((this - result) > 0)) {
	if (result == 1073741823) { result = (toFloat result) }
    result += 1
  }
  return result
}

method integerPart Float {
  result = (this - (this % 1))
  if (and (-1073741824.0 <= result) (result <= 1073741823.0)) {
	result = (truncate result) // result fits in Integer
  }
  return result
}

method fractionPart Float { return (this % 1) }

method round Float precision {
  // Return the nearest muliple of precision or
  // the nearest integer if precision is nil.

  if (isNil precision) {
	if (this > 0) {
	  return (integerPart (this + 0.5))
	} else {
	  return (integerPart (this - 0.5))
	}
  } else {
	return (precision * (round (this / precision)))
  }
}
defineClass Function functionName classIndex argNames localNames cmdList module

method functionName Function { return functionName }
method primName Function { return functionName }
method classIndex Function { return classIndex }
method argNames Function { return argNames }
method localNames Function { return localNames }
method cmdList Function { return cmdList }
method module Function { return module }
method setModule Function m { module = m }
method isMethod Function { return (0 != classIndex) }

method toString Function {
  if (isNil functionName) { return '<Function>' }
  return (join '<Function ' functionName '>')
}

method allCalls Function {
  comment '
	Return a dictionary with the names of all functions called by this one.'

  result = (dictionary)
  if (isNil cmdList) { return result }
  todo = (list cmdList)
  while ((count todo) > 0) {
    cmd = (removeFirst todo)
    add result (primName cmd)
    args = (argList cmd)
	for i (count args) {
      arg = (at args i)
      if (isClass arg 'Command') { add todo arg }
      if (isClass arg 'Reporter') { add todo arg }
	}
	if (notNil (nextBlock cmd)) { add todo (nextBlock cmd) }
  }
  return result
}

method globalVarsUsed Function {
  comment '
	Return a list of all global variables used by this function.'

  result = (toList (varsUsed this))
  removeAll result argNames

  varNameIndex = ((fieldNameCount (class 'Command')) + 1)
  for ref (allVariableRefs this) {
    if (isOneOf (primName ref) 'local' 'for') {
      remove result (getField ref varNameIndex)
    }
  }
  return result
}

method varsUsed Function {
  comment '
	Return a list of all variable names referenced by this function.'

  varNameIndex = ((fieldNameCount (class 'Command')) + 1)
  vars = (dictionary)
  for ref (allVariableRefs this) {
    add vars (getField ref varNameIndex)
  }
  return (keys vars)
}

method refsOfVariable Function varName {
  comment '
	Return a list of all commands and reporters that reference the given variable.'

  varNameIndex = ((fieldNameCount (class 'Command')) + 1)
  result = (list)
  for ref (allVariableRefs this) {
    if ((getField ref varNameIndex) == varName) { add result ref }
  }
  return result
}

method allVariableRefs Function {
  comment '
	Return a list of all commands and reporters that reference variables.'

  result = (list)
  if (isNil cmdList) { return result }
  todo = (list cmdList)
  while ((count todo) > 0) {
    cmd = (removeFirst todo)
	op = (primName cmd)
    args = (argList cmd)
    if (isOneOf op 'v' '=' '+=' 'local' 'for') { add result cmd }
	for i (count args) {
      arg = (at args i)
      if (isClass arg 'Command') { add todo arg }
      if (isClass arg 'Reporter') { add todo arg }
	}
	if (notNil (nextBlock cmd)) { add todo (nextBlock cmd) }
  }
  return result
}

method returnsValue Function {
  comment '
	Return true if this function contains a return statement with an argument.'

  if (isNil cmdList) { return false }
  todo = (list cmdList)
  while ((count todo) > 0) {
    cmd = (removeFirst todo)
	if (and ('return' == (primName cmd)) ((count (argList cmd)) > 0)) {
	  return true
	}
    args = (argList cmd)
	for i (count args) {
      arg = (at args i)
      if (isClass arg 'Command') { add todo arg }
      if (isClass arg 'Reporter') { add todo arg }
	}
	if (notNil (nextBlock cmd)) { add todo (nextBlock cmd) }
  }
  return false
}

method updateCmdList Function newCmdList {
  // Update the command list of this function or method after editing.
  // If the list of local variables used in the command list has
  // changed, update localNames.

  for b (allBlocks cmdList) { clearCache b }
  if (isNil newCmdList) {
	localNames = (array)
	cmdList = nil
	return
  }
  if (isClass newCmdList 'Reporter') {
	newCmdList = (toCommand newCmdList)
  }
  cmdList = newCmdList
  newLocals = (collectLocals cmdList)
  removeAll newLocals argNames
  if (isMethod this) {
	removeAll newLocals (fieldNames (class classIndex))
  }
  newLocals = (sorted (keys newLocals))
  if (newLocals != (sorted localNames)) {
	localNames = newLocals
  }
  for b (allBlocks cmdList) { clearCache b }
}

// copying

method copy Function {
  body = nil
  if (notNil cmdList) {
	body = (copy cmdList)
  }
  return (new 'Function'
    functionName
    classIndex
    (copy argNames)
    (copy localNames)
    body
    module
  )
}

// function creation

to newFunction funcName paramNames body module {
  if (isNil paramNames) { paramNames = (array) }
  if (not (or (isNil body) (isClass body 'Command'))) {
	error 'Function body must be a Command or nil'
  }
  localVars = (toList (keys (collectLocals body)))
  removeAll localVars paramNames
  if (isNil module) { module = (topLevelModule) }
  return (new 'Function' funcName 0 (copy (toArray paramNames)) (toArray localVars) body module)
}

to functionFor obj args... {
  // Return an anonymous function to be run in the context of the given object,
  // thus allowing the function to access the object's instance variables.
  // The last argument, which must be a Command, is the body of the function.
  // Any arguments between the first and last argument are addional argument
  // names for the function.

  if ((argCount) < 2) { error 'Not enough arguments' }

  argNames = (list)
  if (notNil obj) { add argNames 'this' }
  if ((argCount) > 2) {
    for i (range 2 ((argCount) - 1)) {
      add argNames (arg i)
	}
  }

  body = (arg (argCount))
  if (not (or (isNil body) (isClass body 'Command'))) {
	error 'Function body must be a Command or nil'
  }

  localVars = (toList (keys (collectLocals body)))
  removeAll localVars argNames
  removeAll localVars (fieldNames (classOf obj))

  if (isNil obj) {
	classIndex = 0 // function is not attached to any class
	mod = (thisModule)
  } else {
	classIndex = (classIndex (classOf obj))
	mod = (module (classOf obj))
  }
  return (new 'Function' '' classIndex (toArray argNames) (toArray localVars) body mod)
}

to collectLocals cmdOrReporter result {
  // Return a dictionary of all local variables used in the given command or
  // reporter, but do not include variables inside function or method definitions.

  if (isNil result) { result = (dictionary) }
  if (isNil cmdOrReporter) { return result }
  argList = (argList cmdOrReporter)
  op = (primName cmdOrReporter)
  if (isOneOf op 'v' '=' '+=' 'local' 'for') {
	if ((count argList) > 0) {
	  varName = (first argList)
	  if (varName != 'this') { add result varName }
	}
  }
  if (not (isOneOf (primName cmdOrReporter) 'function' 'method')) {
	for arg argList {
	  if (isAnyClass arg 'Command' 'Reporter') { collectLocals arg result }
	}
  }
  if (notNil (nextBlock cmdOrReporter)) { collectLocals (nextBlock cmdOrReporter) result }
  return result
}

to collectLocals2 cmdOrReporter cls result defs used strBuffer {
  // Return a dictionary of all local variables used in the given command or
  // reporter, but do not include variables inside function or method definitions.

  if (isNil cmdOrReporter) { // empty function/method body
	if (isNil result) { return (dictionary) }
	return result
  }
  argList = (argList cmdOrReporter)
  primName = (primName cmdOrReporter)
  if (isNil defs) {
    wasTopLevel = true
    result = (dictionary)
    defs = (dictionary)
    used = (dictionary)
    argNames = (argNames cmdOrReporter)
    if (isClass cmdOrReporter 'Function') { addAll defs argNames }
    if (notNil cls) { addAll defs (fieldNames cls) }

    strBuffer = (list) // of lines
  }

  if ((count argList) > 0) {
    varName = (first argList)
    if ('=' == primName) {
//      if (varName != 'this') { add result varName }
      add defs varName
    } ('+=' == primName) {
//      if (varName != 'this') { add result varName }
      if (isNil (at defs varName)) { add strBuffer (join 'variable ' varName ' used before initialized') }
    } ('for' == primName) {
//      if (varName != 'this') { add result varName }
      if (notNil (at defs varName)) { add strBuffer (join 'variable ' varName ' used in nested for loops') }
      add defs varName
    } ('v' == primName) {
      if (varName != 'this') {
        if (isNil (at defs varName)) { add strBuffer (join 'variable ' varName ' used before initialized') }
        add used varName
      }
    }
  }

  if (isClass cmdOrReporter 'Function') {
    collectLocals2 (cmdList cmdOrReporter) cls result defs used strBuffer
  } else {
	isAnonymousFunction = (and ('function' == primName) (isClass (last argList) 'Command'))
    if (not (or (isOneOf primName 'to' 'method') isAnonymousFunction)) {
      for arg argList {
        if (isAnyClass arg 'Command' 'Reporter') { collectLocals2 arg cls result defs used strBuffer }
      }
      if ('for' == primName) { remove defs varName }
    }
    if (notNil (nextBlock cmdOrReporter)) { collectLocals2 (nextBlock cmdOrReporter) cls result defs used strBuffer }
  }
  if wasTopLevel {
    for c (keys used) { remove defs c }
    remove defs 'this'
    if (notNil cls) { removeAll defs (fieldNames cls) }
    for d (keys defs) {
      if ((indexOf argNames d) > 0) {
        // If you want to check unused arguments for functions, uncomment below.
        // add strBuffer (join 'variable ' d ' passed but not used.')
      } else {
        add strBuffer (join 'variable ' d ' defined but not used.')
      }
    }
    if ((count strBuffer) > 0) {
      if (notNil cls) {
        print (join (functionName cmdOrReporter) ' of ' (className cls) ' has:')
      } else {
        print (join (functionName cmdOrReporter) ' has:')
      }
      for s strBuffer { print '  ' s }
    }
  }
  return result
}

to checkUninitializedVariables {
  a = 42
  for c (classes) {
    for m (methods c) {
      collectLocals2 m c
    }
  }
  for f (functions) {
    collectLocals2 f
  }
}

method removeFieldsFromLocals Function fieldNames {
  // Remove the given field names from this function's localNames.
  newLocals = (toList localNames)
  for f fieldNames { remove newLocals f }
  localNames = (toArray newLocals)
}

// finding functions

to functions { return (globalFuncs) }

to functionNamed funcName module {
  comment '
	Return a generic function with the given name, or nil if the function is not found.
	If module is provided, search only that module for the function.'

  functionList = (list)
  if (notNil module) {
	functionList = (functions module)
  } else {
	editor = (findProjectEditor)
	if (notNil editor) {
	  addAll functionList (functions (module (project editor)))
	}
	addAll functionList (functions (topLevelModule))
	addAll functionList (functions (sessionModule)) // for use during debugging from console
  }
  for i (count functionList) {
    f = (at functionList i)
    if ((functionName f) == funcName) { return f }
  }
  if (contains (primitives) funcName) { return funcName }
  return nil
}
// GraphicContext -- drawing state for Morphs
//
//	surface - a bitmap or nil; if nil, draw directly to the screen
//	clipRect - the current clipping rectangle
//	fontName, fontSize - current font settings
//	offsetX, offsetY - offset from the top-left of surface (in global coordinates)
//	savedState - a stack of clipping rectangles
//
// Offsets are absolute, not relative to the current offset.
// Clipping is additive. Each call to setClip intersects the new rectangle
// with the existing clipping rectangle.
//
// John Maloney, February 2021

defineClass GraphicContext surface fontName fontSize clipRect offsetX offsetY shapeMaker savedState

to newGraphicContextOnScreen clipRect {
	ctx = (newGraphicContextOn nil)
	if (notNil clipRect) { setClip ctx clipRect }
	return ctx
}

to newGraphicContextOn aBitmapOrNil {
	return (initialize (new 'GraphicContext') aBitmapOrNil)
}

method initialize GraphicContext aBitmapOrNil {
	surface = aBitmapOrNil
	fontName = 'Arial'
	fontSize = 36
	clipRect = (rect 0 0 (width this) (height this))
	offsetX = 0
	offsetY = 0
	shapeMaker = (newShapeMaker surface)
	savedState = (list)
	return this
}

method surface GraphicContext { return surface }

method width GraphicContext {
	if (notNil surface) { return (width surface) }
	return (at (windowSize) 3)
}

method height GraphicContext {
	if (notNil surface) { return (height surface) }
	return (at (windowSize) 4)
}

method intersectsClip GraphicContext aRect {
	// Return true if the given rectangle intersects the current clipping rectangle.

	if (or (offsetX != 0) (offsetY != 0)) {
		return (intersects aRect (translatedBy clipRect (- offsetX) (- offsetY)))
	}
	return (intersects aRect clipRect)
}

method setClip GraphicContext aRect {
	// Make the new clipping rectangle be the intersection of the current
	// clipping rectangle and the given rectangle. The new clipping rectangle
	// will always be within the current one.

	if (or (0 != offsetX) (0 != offsetY)) {
		aRect = (translatedBy aRect offsetX offsetY)
	}
	clipRect = (roundToIntegers (intersection clipRect aRect))
}

method setFont GraphicContext fName fSize {
	// Set the font name, font size, or both. Nil arguments are ignored,
	// so you can change just one of these without changing the other.

	if (notNil fName) { fontName = fName }
	if (notNil fSize) { fontSize = fSize }
	setFont fontName fontSize
}

method setOffset GraphicContext x y {
	// Set the offset (from the top-left of the surface) used for drawing operations.

	offsetX = x
	offsetY = y
}

method saveState GraphicContext {
	// Push the current drawing state.

	addFirst savedState (list clipRect offsetX offsetY)
}

method restoreState GraphicContext {
	// Restore the previous drawing state.

	if (notEmpty savedState) {
		oldState = (removeFirst savedState)
		clipRect = (at oldState 1)
		offsetX = (at oldState 2)
		offsetY = (at oldState 3)
	}
}

method getShapeMaker GraphicContext {
	// Get a ShapeMaker for vector drawing.

	pen = (pen shapeMaker)
	setOffset pen offsetX offsetY
	setClipRect pen clipRect
	return shapeMaker
}

// graphics operations

method clear GraphicContext aColor {
	if (isNil aColor) { aColor = (gray 255) }
	fillRect surface aColor 0 0 (width this) (height this)
}

method drawBitmap GraphicContext aBitmap x y {
	if (isNil x) { x = 0 }
	if (isNil y) { y = 0 }
	alpha = 255
	blendMode = 1 // alpha blending
	drawBitmap surface aBitmap (x + offsetX) (y + offsetY) alpha blendMode clipRect
}

method warpBitmap GraphicContext aBitmap x y scaleX scaleY {
	if (isNil x) { x = 0 }
	if (isNil y) { y = 0 }
	centerX = (+ x offsetX (half (scaleX * (width aBitmap))))
	centerY = (+ y offsetY (half (scaleY * (height aBitmap))))
	alpha = 255
	blendMode = 1 // alpha blending
	warpBitmap surface aBitmap centerX centerY scaleX scaleY 0 clipRect
}

method fillRect GraphicContext color x y w h blendMode {
	if (isNil blendMode) {
		if ((alpha color) < 255) { blendMode = 1 } else { blendMode = 0 }
	}
	if (and (1 == blendMode) (0 == (alpha color))) { return } // fully transparent
	r = (intersection clipRect (rect (x + offsetX) (y + offsetY) w h))
	if (and ((width r) > 0) ((height r) > 0)) {
		fillRect surface color (left r) (top r) (width r) (height r) blendMode
	}
}

method drawString GraphicContext aString aColor x y {
	if (isNil aColor) { aColor = (gray 0) }
	if (isNil x) { x = 0 }
	if (isNil y) { y = 0 }
	setFont fontName fontSize
	drawString surface aString aColor (x + offsetX) (y + offsetY) clipRect
}

method drawTexture GraphicContext aTexture x y {
	if (isNil x) { x = 0 }
	if (isNil y) { y = 0 }
	alpha = 255
	degrees = 0
	flip = 0
	blendMode = 1 // alpha blending

	showTexture surface aTexture (x + offsetX) (y + offsetY) alpha 1 1 degrees flip blendMode clipRect
}

method show GraphicContext {
	// For debugging. Display my surface, if any, on the screen and flip screen buffer.

	if (notNil surface) { clearBuffer (gray 255) } // clear screen before displaying surface
	if (isClass surface 'Bitmap') {
		drawBitmap nil surface
	} (isClass surface 'Texture') {
		showTexture nil surface
	}
	flipBuffer
}

// cached path drawing

method drawCachedPaths GraphicContext pathList x y {
	// Draw cached paths to the screen.

	if (notNil surface){ return } // do nothing if not screen

	for p pathList {
		op = (at p 1)
		path = (at p 2)
		vectorSetPathOffset x y
		if ('stroke' == op) {
			vectorStrokePath nil path (at p 3) (at p 4) (at p 5) (at p 6) clipRect
		} ('fill' == op) {
			vectorFillPath nil path (at p 3) clipRect
		} ('strokeAndFill' == op) {
			vectorFillPath nil path (at p 3) clipRect
			vectorStrokePath nil path (at p 4) (at p 5) 0 0 clipRect
		}
	}
}
// morphic grip handlers, used for sliders and resizing handles

defineClass Grip morph trigger orientation gripInset within offsetX offsetY

method setGripInset Grip n { gripInset = n }

method fieldInfo Grip fieldName {
  if ('orientation' == fieldName) {
    info = (dictionary)
    atPut info 'type' 'options'
    atPut info 'options' (array 'horizontal' 'vertical')
    return info
  }
  return nil
}

to newGrip orientation width height {
  if (isNil width) {width = 20}
  if (isNil height) {height = 20}
  bt = (new 'Trigger' nil 'nop')
  m = (newMorph)
  setGrabRule m 'ignore'
  setMorph bt m
  setWidth (bounds m) width
  setHeight (bounds m) height
  grip = (new 'Grip' m bt orientation 0)
  setHandler m grip
  setRenderer bt grip
  replaceCostumes grip
  return grip
}

method handEnter Grip aHand {
	handEnter trigger aHand
	if (orientation == 'vertical') {
		setCursor 'ns-resize'
	} (orientation == 'horizontal') {
		setCursor 'ew-resize'
	} else {
		setCursor 'nwse-resize'
	}
}
method handLeave Grip aHand {handLeave trigger aHand}
method clicked Grip {return true}
method rightClicked Grip {return true}

method stayWithin Grip aConstraint {
  // aConstraint can be either a Morph, a Rectangle, a two-number array or
  // anything that is callable, such as a string (selector) a function or an action,
  // and that will answer either a Morph, Rectangle or two-number array.
  // Two-number arrays are taken to represent the minimum coordinates, e.g. for
  // resizing handles
  within = aConstraint
}

method handDownOn Grip aHand {
  focusOn aHand this
  offsetX = ((x aHand) - (left morph))
  offsetY = ((y aHand) - (top morph))
  return (handDownOn trigger aHand)
}

method handMoveFocus Grip aHand {
  newX = (((x aHand) - offsetX) + gripInset)
  newY = (((y aHand) - offsetY) + gripInset)
  if (orientation == 'horizontal') {
    fastSetLeft morph newX
  } (orientation == 'vertical') {
    fastSetTop morph newY
  } else {
    fastSetPosition morph newX newY
  }
  trigger this
}

method constrainTo Grip anArea {
  // private
  if (isNil anArea) {return}
  if (isClass anArea 'Morph') {
    keepWithin morph (bounds anArea)
  } (isClass anArea 'Rectangle') {
    keepWithin morph anArea
  } (isClass anArea 'Array') {
    stayRightBelow morph (at anArea 1) (at anArea 2)
  } else {
    constrainTo this (call anArea)
  }
}

method trigger Grip {
  constrainTo this within
  trigger trigger
}

method replaceCostumes Grip normalCostume highlightCostume pressedCostume {
  replaceCostumes trigger normalCostume highlightCostume pressedCostume
}

method clearCostumes Grip { clearCostumes trigger }
method removeCostume Grip costumeName {removeCostume trigger costumeName}
method normalCostume Grip {return (newBitmap (width morph) (height morph) (color 200 200 255))}
method highlightCostume Grip {return (newBitmap (width morph) (height morph) (color 200 255 200))}
method pressedCostume Grip {return (newBitmap (width morph) (height morph) (color 255 200 200))}

method updateCostumes Grip {
  clearCostumes trigger
  highlight trigger
  normal trigger
}

to resizeHandle target orientation {
  if (isNil orientation) {orientation = 'free'}
  m = (newMorph)
  setGrabRule m 'ignore'
  setTransparentTouch m true

  bt = (new 'Trigger')
  setMorph bt m
  grip = (new 'Grip' m bt orientation 0)
  drawResizeCostumes grip
  setHandler m grip
  stayWithin grip (action 'resizingConstraint' (morph target) (width m) (height m))

  if (orientation == 'vertical') {
    action = (action 'setHeightToBottom' (morph target) m)
    fastSetBottom m (bottom (morph target))
    fastSetXCenter m (hCenter (bounds (morph target)))
  } (orientation == 'horizontal') {
    action = (action 'setWidthToRight' (morph target) m)
    fastSetRight m (right (morph target))
    fastSetYCenter m (vCenter (bounds (morph target)))
  } else {
    action = (action 'setExtentToRightBottom' (morph target) m)
    if (isClass target 'Window') {
      setGripInset grip (border target)
    }
    fastSetRight m (right (morph target))
    fastSetBottom m (bottom (morph target))
  }
  setAction bt action

  addPart (morph target) m
  return grip
}

to moveHandle target {
  m = (newMorph)
  setGrabRule m 'ignore'
  setTransparentTouch m true
  bt = (new 'Trigger')
  setMorph bt m
  grip = (new 'Grip' m bt 'horizontal' 0)
  drawResizeCostumes grip
  setField grip 'orientation' 'free'
  gotoCenterOf m (morph target)
  setHandler m grip
  setAction bt (action 'gotoCenterOf' (morph target) m)
  page = (global 'page')
  closeUnclickedMenu page grip
  addPart page grip
  setField page 'activeMenu' grip
  return grip
}

to pinHandle target {
  m = (newMorph)
  setGrabRule m 'ignore'
  setTransparentTouch m true
  bt = (new 'Trigger')
  setMorph bt m
  grip = (new 'Grip' m bt 'free' 0)
  drawCrosshairsCostumes grip
  rp = (rotationCenter (morph target))
  setCenter m (first rp) (last rp)
  setHandler m grip
  setAction bt (action 'setRotationCenterTo' (morph target) m)
  page = (global 'page')
  closeUnclickedMenu page grip
  addPart page grip
  setField page 'activeMenu' grip
  return grip
}

to scalingHandle target {
  m = (newMorph)
  setGrabRule m 'ignore'
  setTransparentTouch m true
  bt = (new 'Trigger')
  setMorph bt m
  grip = (new 'Grip' m bt 'free' 0)
  drawSquareHotSpotCostumes grip
  rp = (rotationCenter (morph target))
  setCenter m (first rp) (last rp)
  dist = ((width (morph target)) / 2)
  rot = (rotation (morph target))
  moveBy m (dist * (cos rot)) (-1 * (dist * (sin rot)))
  setHandler m grip
  setAction bt (action 'scaleTo' (morph target) m)
  page = (global 'page')
  closeUnclickedMenu page grip
  addPart page grip
  setField page 'activeMenu' grip
  return grip
}

to rotationHandle target {
  m = (newMorph)
  setGrabRule m 'ignore'
  setTransparentTouch m true
  bt = (new 'Trigger')
  setMorph bt m
  grip = (new 'Grip' m bt 'free' 0)
  drawRoundHotSpotCostumes grip
  rp = (rotationCenter (morph target))
  setCenter m (first rp) (last rp)
  dist = ((width (morph target)) / 2)
  rot = (rotation (morph target))
  moveBy m (dist * (cos rot)) (-1 * (dist * (sin rot)))
  setHandler m grip
  setAction bt (action 'pointTo' (morph target) m)
  page = (global 'page')
  closeUnclickedMenu page grip
  addPart page grip
  setField page 'activeMenu' grip
  return grip
}

method drawResizeCostumes Grip {
  scale = (global 'scale')
  size = (scale * 15)
  nbm = (newBitmap size size)
  hbm = (newBitmap size size)
  drawResizer (newShapeMaker nbm) 0 0 size size orientation false
  drawResizer (newShapeMaker hbm) 0 0 size size orientation true
  replaceCostumes trigger nbm hbm hbm
  setWidth (bounds morph) (width nbm)
  setHeight (bounds morph) (height nbm)
}

method drawCrosshairsCostumes Grip {
  scale = (global 'scale')
  size = (30 * scale)
  bigCircle = (12 * scale)
  smallCircle = (10 * scale)
  color = (gray 0 180)
  nbm = (newBitmap size size)
  hbm = (newBitmap size size)
  circleWithCrosshairs (newShapeMaker nbm) size bigCircle color
  circleWithCrosshairs (newShapeMaker hbm) size smallCircle color
  replaceCostumes trigger nbm hbm hbm
  setWidth (bounds morph) (width nbm)
  setHeight (bounds morph) (height nbm)
}

method drawRoundHotSpotCostumes Grip {
  scale = (global 'scale')
  size = (24 * scale)
  center = (size / 2)
  bigCircle = (10 * scale)
  smallCircle = (8 * scale)
  color = (gray 0)
  nbm = (newBitmap size size)
  hbm = (newBitmap size size)
  drawCircle (newShapeMaker nbm) center center bigCircle nil (size / 6) color
  drawCircle (newShapeMaker hbm) center center smallCircle nil (size / 6) color
  replaceCostumes trigger nbm hbm hbm
  setWidth (bounds morph) (width nbm)
  setHeight (bounds morph) (height nbm)
}

method drawSquareHotSpotCostumes Grip {
  scale = (global 'scale')
  size = (20 * scale)
  inset = (2 * scale)
  smaller = (size - (2 * inset))
  rect = (rect 0 0 size size)
  color = (gray 0)
  nbm = (newBitmap size size)
  hbm = (newBitmap size size)
  outlineRectangle (newShapeMaker nbm) (rect 0 0 size size) (size / 6) color
  outlineRectangle (newShapeMaker hbm) (rect inset inset smaller smaller) (size / 6) color
  replaceCostumes trigger nbm hbm hbm
  setWidth (bounds morph) (width nbm)
  setHeight (bounds morph) (height nbm)
}

method drawPaneResizingCostumes Grip {
  w = (width morph)
  h = (height morph)
  oldBM = (normalCostume trigger)
  if (and (h == (height oldBM)) (w == (width oldBM))) { return }
  hc = (color 180 180 255 150)
  nbm = (newBitmap w h)
  hbm = (newBitmap w h hc)
  replaceCostumes trigger nbm hbm
  if (== this (focus (hand (global 'page')))) {
    highlight trigger
  }
}

// serialization

method preSerialize Grip {
  preSerialize trigger
}

method postSerialize Grip {
  postSerialize trigger
}
defineClass HTTPFetcher socket received headers body

method oldFetch HTTPFetcher host path port {
  // Old code
if (isNil path) { path = '/' }
if (isNil port) { port = 80 }
socket = (openClientSocket host port)
if (isNil socket) { return '' }
nl = (string 13 10)
request = (join
'GET ' path ' HTTP/1.1' nl
'Host: ' host nl nl)
writeSocket socket request
waitMSecs 1000 // wait a bit
response = (list)
count = 1 // start loop
while (count > 0) {
chunk = (readSocket socket)
count = (byteCount chunk)
//	print count
if (count > 0) { add response chunk }
}
closeSocket socket
return (joinStrings response)
}

to httpGet host path port {
	if (isNil path) { path = '/' }
	if (isNil port) { port = 80 }
	if ('Browser' == (platform)) {
		url = (join 'http://' host path)
		if (80 != port) { url = (join url ':' port) }
		return (toString (httpGetInBrowser url))
	}
	socket = (openClientSocket host port)
	if (isNil socket) { return '' }
	nl = (string 13 10)
	request = (join
		'GET ' path ' HTTP/1.1' nl
		'Host: ' host nl nl)
	writeSocket socket request
	waitMSecs 1000 // wait a bit
	response = (list)
	count = 1 // start loop
	while (count > 0) {
		chunk = (readSocket socket)
		count = (byteCount chunk)
		if (count > 0) {
			add response chunk
			waitMSecs 50
		}
	}
	closeSocket socket
	return (joinStrings response)
}

to httpGetInBrowser url timeout {
	if (isNil timeout) { timeout = 1000 }
	if (and (beginsWith (browserURL) 'https:') (beginsWith url 'http:')) { // switch to 'https'
		url = (join 'https://' (substring url 8))
	}
	requestID = (startFetch url)
	start = (msecsSinceStart)
	while (((msecsSinceStart) - start) < timeout) {
		result = (fetchResult requestID)
		if (false == result) { return '' } // request failed
		if (notNil result) { return result } // request completed
		waitMSecs 20
	}
}

to httpBody response {
	if (isClass response 'BinaryData') {
		return (httpBinaryBody response)
	}
	lines = (lines response)
	i = (indexOf lines '')
	if (isNil i) { return '' } // no body
	return (joinStrings (copyFromTo lines (i + 1)) (newline))
}

to httpGetBinary host path port {
	if (isNil path) { path = '/' }
	if (isNil port) { port = 80 }
	if ('Browser' == (platform)) {
		url = (join 'http://' host path)
		if (80 != port) { url = (join url ':' port) }
		return (toString (httpGetInBrowser url))
	}
	socket = (openClientSocket host port)
	if (isNil socket) { return '' }
	nl = (string 13 10)
	request = (join
		'GET ' path ' HTTP/1.1' nl
		'Host: ' host nl
		'Accept:' 'application/octet-stream' nl nl)
	writeSocket socket request
	waitMSecs 1000 // wait a bit
	response = (newBinaryData)
	count = 1 // start loop
	while (count > 0) {
		chunk = (readSocket socket true)
		count = (byteCount chunk)
		if (count == 0) {
			waitMSecs 600
			chunk = (readSocket socket true)
			count = (byteCount chunk)
		}
		if (count > 0) {
			response = (join response chunk)
			waitMSecs 50
		}
	}
	closeSocket socket
	return (httpBinaryBody response)
}

to httpBinaryBody data {
	for i (byteCount data) {
		// find the end of the header (byte sequence 13 10 13 10)
		if (and
			(13 == (byteAt data i))
			(10 == (byteAt data (i + 1)))
			(13 == (byteAt data (i + 2)))
			(10 == (byteAt data (i + 3)))
		) {
			// return the body of the response as binary data
			return (copyFromTo data (i + 4))
		}
	}
	return data // no header; assume data is the body
}

to httpHeaders response {
	headers = (list)
	for line (lines response) {
		if ('' == line) { return (joinStrings headers (newline)) }
		add headers line
	}
	return response // no body
}

to httpPut data host path port contentType {
	if (isNil path) { path = '/' }
	if (isNil port) { port = 80 }
	if (isNil contentType) { contentType = 'application/octet-stream' }
	socket = (openClientSocket host port)
	if (isNil socket) { return '' }
	nl = (string 13 10)
	request = (join
		'PUT ' path ' HTTP/1.1' nl
		'Host: ' host nl
		'Content-type: ' contentType nl
		'Content-length: ' (toString (count data)) nl nl)
	request = (join (toBinaryData request) (toBinaryData data))

	// send the request, including body data, if any
	while ((byteCount request) > 0) {
		written = (writeSocket socket request)
		if (0 == written) {
			waitMSecs 10 // wait a bit
		} (written < 0) {
			request = (toBinaryData '') // socket closed
		} else {
			request = (copyFromTo request (written + 1))
		}
	}

	response = (list)
	count = 1 // start loop
	while (count > 0) {
		chunk = (readSocket socket)
		count = 0
		if (notNil chunk) { count = (byteCount chunk) }
		if (count > 0) {
			add response chunk
			waitMSecs 50
		}
	}
	closeSocket socket
	return (joinStrings response)
}
// editable input slot for blocks

defineClass InputSlot morph text contents color menuSelector menuRange isStatic isAuto isID isMonospace pathCache cacheW cacheH

to newInputSlot default editRule blockColor menuSelector {
  if (isNil default) {default = ''}
  if (isNil editRule) {editRule = 'line'}
  return (initialize (new 'InputSlot') default editRule blockColor menuSelector)
}

method initialize InputSlot default editRule blockColor slotMenu {
  isID = false
  isMonospace = false
  scale = (blockScale)
  morph = (newMorph this)
  text = (newText '')
  addPart morph (morph text)
  if ('auto' == editRule) {
	// 'auto' slots switch between number or string depending on their contents
	editRule = 'line'
	isAuto = true
  } else {
	isAuto = false
  }
  setEditRule text editRule
  setTextFont this
  if (editRule == 'numerical') {
    setBorders text (scale * 5) 0
  } else {
    setBorders text (scale * 3) scale
  }
  if (editRule == 'static') {
    contents = default
    if (notNil blockColor) { color = (lighter blockColor 75) }
  }
  if (and (notNil slotMenu) (beginsWith slotMenu 'range:')) {
    // integer range such as 'range:1-3'
    pair = (splitWith (substring slotMenu 7) '-')
    if (and (2 == (count pair)) (allDigits (first pair)) (allDigits (last pair))) {
      menuRange = (array (toInteger (first pair)) (toInteger (last pair)))
      slotMenu = 'rangeMenu'
    }
  }
  menuSelector = slotMenu
  isStatic = (isOneOf menuSelector 'sharedVarMenu' 'myVarMenu' 'localVarMenu' 'allVarsMenu' 'propertyMenu')
  if (and isAuto (isClass default 'String') ('' != default) (representsANumber default)) {
	default = (toNumber default)
  }
  setContents this default
  fixLayout this
  return this
}

method morph InputSlot {return morph}
method setID InputSlot bool {isID = bool}
method color InputSlot {return color}
method isMonospace InputSlot {return isMonospace}
method setMonospace InputSlot bool {isMonospace = bool}

method contents InputSlot {
  if ((editRule text) == 'static') {
    if isID {return contents}
    if (isNil menuSelector) { return nil } // default is just a hint; value is nil
    return contents
  }
  return contents
}

method setContents InputSlot data fixStringOnlyNum {
  // Set the contents of this slot to data.
  // If the slot is auto, the optional argument fixStringOnlyNum is true,
  // and data is a string that represents a number, change the slot
  // to 'string only'. This is needed when recreating blocks from code
  // where an auto input slot had been manually changed to 'string only'.

  if (and isAuto (true == fixStringOnlyNum)) {
    if (and (isClass data 'String') ('' != data) (representsANumber data)) {
      isAuto = false
      setEditRule text 'editable'
      setTextFont this
    }
  }
  if (and (notNil menuSelector) (not (isVarSlot this)) (isClass data 'String')) {
    setText text (localized (toString data))
  } else {
    setText text (toString data)
  }
  if isAuto {
    scale = (blockScale)
    isNumber = (and (representsANumber (text text)) (notNil (toNumber (text text) nil)))
    if isNumber {
      data = (toNumber data)
      setBorders text (scale * 5) 0
    } else {
      setBorders text (scale * 3) scale
    }
    fixLayout this
  }
  contents = data
  raise morph 'inputChanged' this
}

method setTextFont InputSlot {
  scale = (blockScale)
  fontName = 'Arial'
  fontSize = 11
  if isMonospace {
    if ('Browser' == (platform)) {
      fontSize = 11
      fontName = 'monospace'
    } ('Win' == (platform)) {
      fontSize = 12
      fontName = 'Lucida Console' // Lucida Console or Consolas
    } ('Mac' == (platform)) {
      fontSize = 11
      fontName = 'Menlo Regular'
    } ('Linux' == (platform)) {
      fontSize = 10
      fontName = 'DejaVu Sans Mono'
    }
  }
  if ('Linux' == (platform)) { fontSize += -1 }
  setFont text fontName (fontSize * (blockScale))
}

method isVarSlot InputSlot {
  if (isNil (owner morph)) { return false }
  owner = (handler (owner morph))
  if (or (not (isClass owner 'Block')) (isNil (expression owner))) { return false }
  return (isOneOf (primName (expression owner)) '=' '+=')
}

method fixLayout InputSlot {
  scale = (blockScale)
  h = (height (morph text))
  w = ((width (morph text)) + 1)
  if ('Linux' == (platform)) { h += scale }
  if (notNil menuSelector) {w += (fontSize text)} // leave room for down-arrow
  textX = (left morph)
  textY = ((top morph) + 1)
  setPosition (morph text) textX textY
  setExtent morph w h
  pathCache = nil
  raise morph 'layoutChanged' this
}

method drawOn InputSlot ctx {
  if (notNil (getField ctx 'surface')) {
    drawShape this (getShapeMaker ctx)
    return
  }

  if (or (isNil pathCache) (cacheW != (width morph)) (cacheH != (height morph))) {
    // update pathCache
    sm = (newShapeMakerForPathRecording)
    drawShape this sm
    pathCache = (recordedPaths sm)
    cacheW = (width morph)
    cacheH = (height morph)
  }
  drawCachedPaths ctx pathCache (left morph) (top morph)
}

method drawShape InputSlot aShapeMaker {
  scale = (blockScale)
  border = (max 1 (scale / 2))

  isNumber = ((editRule text) == 'numerical')
  if (and (isAuto == true) (representsANumber (text text))) {
    isNumber = (notNil (toNumber (text text) nil))
  }

  white = (gray 255)
  gray = (gray 180)
  corner = scale

  if (isRecording aShapeMaker) {
    r = (rect 0 0 (width morph) (height morph))
  } else {
    r = (bounds morph)
  }

  if isNumber {
    corner = (((height morph) / 2) - 1)
    fillRoundedRect aShapeMaker r corner white border gray white
  } ((editRule text) == 'static') {
    c = (gray 220)
    if (notNil color) { c = color }
    fillRoundedRect aShapeMaker r corner c border (darker c) (lighter c)
  } else {
    fillRoundedRect aShapeMaker r corner white border gray white
  }
  if (notNil menuSelector) { // draw down-arrow
	fontH = (fontSize text)
    border = scale
    x = (left r)
    y = (top r)
    x += (((width morph) - fontH) - border)
    y += (((height morph) / 4) + border)
    w = (fontH - (2 * border))
    h = ((fontH / 2) + border)
    clr = (gray 0)
	fillArrow aShapeMaker (rect x y w h) 'down' clr
  }
}

// events

method layoutChanged InputSlot {fixLayout this}

method textChanged InputSlot {
  if ((editRule text) == 'numerical') {
    setContents this (toNumber (text text))
  } else {
   setContents this (text text)
  }
}

method clicked InputSlot aHand {
  if (notNil menuSelector) {
    if (or ((x aHand) >= ((right morph) - (fontSize text))) isStatic) {
	  menu = (call menuSelector this)
	  if (notNil menu) { popUpAtHand menu (page aHand) }
      return true
    }
  }
  return false
}

method clickedForEdit InputSlot aText {selectAll aText}

method scrubAnyway InputSlot aText {
  if (and (isAuto == true) (representsANumber (text text)) (notNil (toNumber (text aText) nil))) {
    startScrubbing aText
  }
}

method wantsDropOf InputSlot aHandler {
    return (isClass aHandler 'Text')
}

method justReceivedDrop InputSlot aText {
  setText text (text aText)
  destroy (morph aText)
}

// range menu

method rangeMenu InputSlot {
  menu = (menu nil (action 'setContents' this) true)
  for i (range (first menuRange) (last menuRange)) {
	addItem menu (toNumber i) i
  }
  return menu
}

// menus

method directionsMenu InputSlot {
  menu = (menu nil (action 'setContents' this) true)
  addItem menu 'right (0)' 0
  addItem menu 'left (180)' 180
  addItem menu 'up (90)' 90
  addItem menu 'down (-90)' -90
  return menu
}

method imageMenu InputSlot {
  editorM = (ownerThatIsA morph 'ProjectEditor')
  if (isNil editorM) { return }
  menu = (menu nil (action 'setContents' this) true)
  for img (images (project (handler editorM))) {
	addItem menu (name img)
  }
  return menu
}

method soundMenu InputSlot {
  editorM = (ownerThatIsA morph 'ProjectEditor')
  if (isNil editorM) { return }
  menu = (menu nil (action 'setContents' this) true)
  for snd (sounds (project (handler editorM))) {
	addItem menu (name snd)
  }
  return menu
}

method instrumentMenu InputSlot {
  menu = (menu nil (action 'setContents' this) true)
  for instrName (instrumentNames (newSampledInstrument 'piano')) {
	addItem menu instrName
  }
  return menu
}

method classNameMenu InputSlot {
  menu = (menu nil (action 'setContents' this) true)
  for cl (classes) {
    if (isUserDefined cl) {
	  addItem menu (className cl)
	}
  }
  return menu
}

method touchingMenu InputSlot {
  menu = (classNameMenu this)
  addLine menu
  addItem menu 'any class'
  addLine menu
  addItem menu 'edge'
  addItem menu 'mouse'
  return menu
}

method keyDownMenu InputSlot {
  return (keyMenu this true)
}

method keyMenu InputSlot forKeyDown {
  if (isNil forKeyDown) { forKeyDown = false }
  menu = (menu nil (action 'setContents' this) true)
  addItem menu 'space'
  addItem menu 'delete'
  addLine menu
  addItem menu 'right arrow'
  addItem menu 'left arrow'
  addItem menu 'down arrow'
  addItem menu 'up arrow'
  addLine menu
  for k (letters '0123456789') { addItem menu k }
  addLine menu
  for k (letters 'abcdefghijklmnopqrstuvwxyz') { addItem menu k }
  addLine menu
  if forKeyDown { // shift keys don't generate keyDown events
	addItem menu 'shift'
  } else {
	addItem menu 'any'
  }
  return menu
}

method sharedVarMenu InputSlot {
  menu = (menu nil (action 'setContents' this) true)
  scripter = (ownerThatIsA morph 'Scripter')
  if (isNil scripter) { scripter = (ownerThatIsA morph 'MicroBlocksScripter') }
  if (isNil scripter) { return menu }
  varNames = (copyWithout (variableNames (targetModule (handler scripter))) 'extensions')
  for varName varNames {
	addItem menu varName varName
  }
  return menu
}

method myVarMenu InputSlot {
  menu = (menu nil (action 'setContents' this) true)

  scripter = (ownerThatIsA morph 'Scripter')
  if (notNil scripter) {
    targetObj = (targetObj (handler scripter))
	if (notNil targetObj) {
      for varName (fieldNames (classOf targetObj)) {
		if ('morph' != varName) {
		  addItem menu varName varName
		}
      }
	}
  }
  return menu
}

method localVarMenu InputSlot {
  menu = (menu nil (action 'setContents' this) true)

  myBlock = (handler (ownerThatIsA morph 'Block'))
  localVars = (collectLocals (expression (topBlock myBlock)))
  for field (fieldNames (classOf targetObj)) { remove localVars field }
  if (notEmpty localVars) {
	localVars = (sorted (keys localVars))
	for varName localVars {
	  addItem menu varName varName
	}
  }
  return menu
}

method allVarsMenu InputSlot {
  menu = (menu nil (action 'setContents' this) true)

  // shared vars
  scripter = (ownerThatIsA morph 'Scripter')
  if (isNil scripter) { scripter = (ownerThatIsA morph 'MicroBlocksScripter') }
  if (notNil scripter) {
	varNames = (copyWithout (variableNames (targetModule (handler scripter))) 'extensions')
	for varName varNames {
	  addItem menu varName varName
	}
	if ((count varNames) > 0) { addLine menu }
  }

  // local vars
  myBlock = (handler (ownerThatIsA morph 'Block'))
  localVars = (collectLocals (expression (topBlock myBlock)))
  for field (fieldNames (classOf targetObj)) { remove localVars field }
  if (notEmpty localVars) {
	localVars = (sorted (keys localVars))
	for varName localVars {
	  addItem menu varName varName
	}
  }
  return menu
}

method columnMenu InputSlot {
  // Menu of column names for a table.

  // Look for a table in a field variable
  scripter = (ownerThatIsA morph 'Scripter')
  if (notNil scripter) {
    targetObj = (targetObj (handler scripter))
	myBlock = (handler (ownerThatIsA morph 'Block'))
	myTable = (valueOfFirstVarReporter this myBlock targetObj)
  }
  menu = (menu nil (action 'setContents' this) true)
  if (notNil myTable) {
	for colName (columnNames myTable) {
	  addItem menu colName colName
	}
  } else {
	for i 10 {
	  colName = (join 'C' i)
	  addItem menu colName colName
	}
  }
  return menu
}

method propertyMenu InputSlot {
  // Menu of property names for a sprite.

  // Look for a sprite in a field variable
  scripter = (ownerThatIsA morph 'Scripter')
  if (notNil scripter) {
    targetObj = (targetObj (handler scripter))
	myBlock = (handler (ownerThatIsA morph 'Block'))
	mySprite = (valueOfFirstVarReporter this myBlock targetObj)
	if (isNil mySprite) { mySprite = targetObj }
  }
  menu = (menu nil (action 'setContents' this) true)
  if (hasField mySprite 'morph') { // sprite properties
	for propName (array 'x' 'y') {
	  addItem menu propName propName
	}
	addLine menu
  }
  if (notNil mySprite) {
	for fieldName (fieldNames (classOf mySprite)) {
	  if (fieldName != 'morph') { addItem menu fieldName fieldName }
	}
  }
  return menu
}

method valueOfFirstVarReporter InputSlot aBlock targetObj {
  for arg (argList (expression aBlock)) {
	if (isClass arg 'Reporter') {
	  op = (primName arg)
	  if (isOneOf op 'v' 'my') {
		varName = (first (argList arg))
		if (hasField targetObj varName) {
		  return (getField targetObj varName)
		}
	  } (isOneOf op 'shared' 'global') {
		varName = (first (argList arg))
		return (global varName)
	  }
	}
  }
  return nil
}

method comparisonOpMenu InputSlot {
  // Menu of common comparison operators.

  menu = (menu nil (action 'setContents' this) true)
  for op (array '<' '<=' '=' '!=' '>' '>=') {
	addItem menu op op
  }
  return menu
}

method voiceNameMenu InputSlot {
  voiceNames = (list 'Agnes' 'Albert' 'Alex' 'Alice' 'Allison' 'Alva' 'Amelie' 'Anna' 'Ava' 'Bad News'
  	'Bahh' 'Bells' 'Boing' 'Bruce' 'Bubbles' 'Carmit' 'Cellos' 'Damayanti' 'Daniel' 'Deranged' 'Diego'
	'Ellen' 'Fiona' 'Fred' 'Good News' 'Hysterical' 'Ioana' 'Joana' 'Junior' 'Kanya' 'Karen' 'Kathy' 'Kyoko'
	'Laura' 'Lekha' 'Luciana' 'Maged' 'Mariska' 'Mei-Jia' 'Melina' 'Milena' 'Moira' 'Monica' 'Nora'
	'Paulina' 'Pipe Organ' 'Princess' 'Ralph' 'Samantha' 'Sara' 'Satu' 'Sin-ji' 'Susan' 'Tessa' 'Thomas'
	'Ting-Ting' 'Tom' 'Trinoids' 'Veena' 'Vicki' 'Victoria' 'Whisper' 'Xander' 'Yelda' 'Yuna'
	'Zarvox' 'Zosia' 'Zuzana')

  menu = (menu nil (action 'setContents' this) true)
  for v voiceNames {
	addItem menu v v
  }
  return menu
}

// context menu - type switching

method rightClicked InputSlot aHand {
  popUpAtHand (contextMenu this) (page aHand)
  return true
}

method contextMenu InputSlot {
  menu = (menu 'Input type:')
  addSlotSwitchItems this menu
  return menu
}

method addSlotSwitchItems InputSlot aMenu {
  rule = (editRule text)
  if isAuto {
	addItem aMenu 'string only' (action 'switchType' this 'editable')
	addItem aMenu 'number only' (action 'switchType' this 'numerical')
  } ('numerical' == rule) {
	addItem aMenu 'string only' (action 'switchType' this 'editable')
	addItem aMenu 'string or number' (action 'switchType' this 'auto')
  } else {
	addItem aMenu 'number only' (action 'switchType' this 'numerical')
	addItem aMenu 'string or number' (action 'switchType' this 'auto')
  }
}

method switchType InputSlot editRule {
  dta = (contents this)
  if (editRule == 'auto') {
	isAuto = true
	setEditRule text 'line'
	dta = (toString dta)
  } else {
	isAuto = false
	setEditRule text editRule
	if (editRule == 'numerical') {
	  dta = (toNumber dta)
	} else {
	  dta = (toString dta)
	}
  }
  setTextFont this
  setContents this dta
}

// replacement rule

to isReplaceableByReporter anInput {return true}
method isReplaceableByReporter InputSlot {return (not isStatic)}
method setIsStatic InputSlot bool {isStatic = bool}

// keyboard accessability hooks

method trigger InputSlot returnFocus {
  if (notNil menuSelector) {
    menu = (call menuSelector this)
    setField menu 'returnFocus' returnFocus
    popUp menu (page morph) (left morph) (bottom morph)
  } ('static' != (editRule text)) {
    edit (keyboard (page morph)) text 1
    selectAll text
  } else {
    redraw returnFocus
  }
}
// explore GP objects

defineClass Inspector morph window contents listBox listFrame tabs tabsFrame readouts fieldFrame evalBox evalFrame

method initialize Inspector {
  scale = (global 'scale')
  window = (window (labelName this))
  clr = (clientColor window)
  border = (border window)
  morph = (morph window)
  setHandler morph this
  setMinExtent morph (scale * 130) (scale * 100)
  setFPS morph 3

  listBox = (listBox (fieldNames this) 'toString' (action 'selectField' this) clr (action 'inspectField' this))
  listFrame = (scrollFrame listBox clr)
  addPart morph (morph listFrame)

  tabs = (tabBar (array 'basic') nil (action 'tab' this))
  tabsFrame = (newMorph)
  setClipping tabsFrame true true
  addPart tabsFrame (morph tabs)
  addPart morph tabsFrame
  hide tabsFrame

  basicReadout = (newText)
  setBorders basicReadout border border true
  setEditRule basicReadout 'code'
  setCodeContext basicReadout contents
  setGrabRule (morph basicReadout) 'ignore'

  readouts = (dictionary)
  atPut readouts 'basic' basicReadout

  fieldFrame = (scrollFrame basicReadout clr)
  addPart morph (morph fieldFrame)

  evalBox = (newText)
  setBorders evalBox border border true
  setEditRule evalBox 'code'
  setCodeContext evalBox contents
  setGrabRule (morph evalBox) 'ignore'
  evalFrame = (scrollFrame evalBox clr)
  addPart morph (morph evalFrame)

  setExtent morph (scale * 250) (scale * 180)
  setPosition morph 5 57

  setFramePadding (alignment tabs) (4 * scale)
  fixLayout (alignment tabs)
  select tabs 'basic'
}

method fixLayout Inspector {
  fixLayout window
  clientArea = (clientArea window)
  border = (border window)

  setPosition (morph listFrame) (left clientArea) (top clientArea)
  setExtent (morph listFrame) (min ((width clientArea) / 3) (+ 12 (itemWidth listBox))) (height clientArea)

  tp = (top clientArea)
  w = (- (- (width clientArea) (width (morph listFrame))) border)
  h = 0
  if (isVisible tabsFrame) {
    h = (height (morph tabs))
    setPosition tabsFrame (+ (right (morph listFrame)) border) tp
    setExtent tabsFrame w h
    tp = (bottom tabsFrame)
  }

  setPosition (morph fieldFrame) (+ (right (morph listFrame)) border) tp
  setExtent (morph fieldFrame) w ((((height clientArea) / 3) * 2) - h)

  setPosition (morph evalFrame) (left (morph fieldFrame)) (+ (bottom (morph fieldFrame)) border)
  setExtent (morph evalFrame) w ((bottom clientArea) - (+ border (bottom (morph fieldFrame))))
}

method redraw Inspector {
  redraw window
  fixLayout this
}

method selectField Inspector aFieldName {
  basicReadout = (at readouts 'basic')
  readouts = (dictionary)
  atPut readouts 'basic' basicReadout

  if (shiftKeyDown (keyboard (handler (root morph)))) {
    select listBox nil
    setText (at readouts 'basic') ''
    select tabs 'basic'
    return
  }

  val = (getField contents aFieldName)
  setText (at readouts 'basic') (printString val)
  info = (fieldInfo contents aFieldName)
  if (notNil info) {
    atPut readouts (at info 'type') (readoutFor this info)
  }
  if (isClass val 'Boolean') {
    atPut readouts 'switch' (switchReadout this)
    setCollection tabs (keys readouts)
  } else {
    setCollection tabs (keys readouts)
  }
  if (2 > (count (keys readouts))) {
    hide tabsFrame
  } else {
    show tabsFrame
  }
  select tabs (last (keys readouts))
  fixLayout this
}

method labelName Inspector {
  if (contains (array 65 97 69 101 73 105 79 111 85 117) (byteAt (className (classOf contents)) 1)) {
    pref = 'an '
  } else {
    pref = 'a '
  }
  if (or (isNil contents) (true === contents) (false === contents)
		 (isClass contents 'Integer') (isClass contents 'Float')
		 (isClass contents 'String') (isClass contents 'ExternalReferences')) {
	cts = (join ': ' (printString contents))
  } else {
    cts = ''
  }
  return (join pref (className (classOf contents)) cts)
}

method fieldNames Inspector {
  if (isAnyClass contents 'String' 'Float' 'ExternalReference' 'BinaryData') {
    return (array)
  }
  fieldNames = (fieldNames (classOf contents))
  n = (min 1000 (objWords contents))
  slotNames = (newArray n)
  for i n {
    if (i <= (count fieldNames)) {
      slotName = (at fieldNames i)
    } else {
      slotName = i
    }
    atPut slotNames i slotName
  }
  return slotNames
}

method tab Inspector tabName {
  padding = (border window)
  if (tabName == 'basic') {padding = 0}
  setContents fieldFrame (at readouts tabName) padding
}

method inspectField Inspector aFieldName {
  page = (handler (root morph))
  ins = (inspectorOn (getField contents aFieldName))
  setPosition (morph ins) (x (hand page)) (y (hand page))
  addPart (morph page) (morph ins)
}

method textChanged Inspector origin {if (origin === (at readouts 'basic')) {pushCurrentField this}}

method pushCurrentField Inspector {
  fieldName = (selection listBox)
  if (isNil fieldName) {return}
  result = (eval (join '(id ' (text (at readouts 'basic')) ')') contents)
  setField contents fieldName result
  selectField this fieldName
}

method step Inspector {
  fieldName = (selection listBox)

  // update window label
  lbl = (labelName this)
  if (!= lbl (labelString window)) {
    setLabelString window lbl
  }

  // update fieldNames
  fieldNames = (fieldNames this)
  if (!= fieldNames (collection listBox)) {
    setCollection listBox fieldNames
    if (not (contains fieldNames fieldName)) {
      fieldName = nil
      setText (at readouts 'basic') ''
    }
    select listBox fieldName
  }

  // update readout
  if (isNil fieldName) {return}
  basicReadout = (at readouts 'basic')
  if (isVisible (morph basicReadout)) {
    result = (printString (getField contents fieldName))
    if (or (notNil (caret basicReadout)) (result == (text basicReadout))) {return}
    setText basicReadout result
  } else {
    update (at readouts (selection tabs))
  }
}

to inspectorOn anObject {
  ins = (new 'Inspector' nil nil anObject)
  initialize ins
  return ins
}

to openInspector obj {
  page = (global 'page')
  if (isNil page) {
    inspect obj
	return
  }
  addPart page (inspectorOn obj)
}

// context menus

method rightClicked Inspector hand {
  popUpAtHand (contextMenu this) (page hand)
  return true
}

method handleListContextRequest Inspector anArray {
  dta = (data (last anArray))
  popUpAtHand (fieldContextMenu this dta) (global 'page')
}

method contextMenu Inspector {
  menu = (menu nil this)
  addItem menu 'explore' (action 'openExplorer' contents)
  addLine menu
  addItem menu (join 'browse class: ' (className (classOf contents))) (action 'browseClass' this (classOf contents))
  return menu
}

method fieldContextMenu Inspector fieldName {
  cls = (classOf (getField contents fieldName))
  menu = (menu fieldName this)
  addItem menu 'explore' (action 'openExplorer' (getField contents fieldName))
  addItem menu 'inspect' (action 'inspectField' this fieldName)
  addItem menu (join 'browse class: ' (className cls)) (action 'browseClass' this cls)
  return menu
}

method browseClass Inspector aClass {
  page = (page morph)
  brs = (newClassBrowser)
  setPosition (morph brs) (x (hand page)) (y (hand page))
  addPart page brs
  browse brs aClass
}

// readouts

to fieldInfo fieldName {return nil}

method switchReadout Inspector {
  scale = (global 'scale')
  toggle = (toggleButton (action 'toggleField' this) (action 'getField' contents (selection listBox)) (scale * 20) (scale * 13) (scale * 5) (max 1 (scale / 2)) false)
  return (readout 'switch' contents (selection listBox) toggle 'refresh')
}

method toggleField Inspector {
  fieldName = (selection listBox)
  setField contents fieldName (not (getField contents fieldName))
}

method readoutFor Inspector info {
  if ('options' == (at info 'type')) {
    options = (listBox (at info 'options') 'id' (action 'setField' contents (selection listBox)))
    return (readout 'options' contents (selection listBox) options 'select')
  }
  error 'unsupported info type' (at info 'type')
}

method currentSelection Inspector {
  // answer the value of the currently selected field, if any
  fieldName = (selection listBox)
  if (isNil fieldName) {return nil}
  return (getField contents fieldName)
}

method currentHighlight Inspector {
  // answer the value of the currently highlighted field, if any
  hl = (highlighted listBox)
  if (isNil hl) {return nil}
  fieldName = (data hl)
  return (getField contents fieldName)
}

method connectors Inspector {
  tp = (top (morph listFrame))
  bt = (bottom (morph listFrame))
  x = (hCenter (bounds (morph listFrame)))
  result = (list)
  for item (parts (morph listBox)) {
    fieldName = (data (handler item))
    dta = (getField contents fieldName)
    y = (min bt (max tp (vCenter (bounds item))))
    add result (array dta (array x y))
  }
  return result
}
// InstanceIcon.gp - reprepesents a non-morphic object instance in the instances pane

defineClass InstanceIcon morph target toggle thumb

method target InstanceIcon { return target }

method initialize InstanceIcon aHandler onSelect query {
  if (isNil onSelect) {onSelect = 'nop'}
  if (isNil query) {query = (function {return false})}
  target = aHandler
  scale = (global 'scale')
  toggle = (createToggle this onSelect query)
  morph = (morph toggle)
  setHandler morph this
  addPart morph (morph (thumbnailFor aHandler))
  fixLayout this
  return this
}

method createToggle InstanceIcon onSelect query {
  scale = (global 'scale')
  clr = (gray 200)
  size = (scale * 46)
  corner = (scale * 3)
  border = scale
  fbm = (buttonBitmap nil (color 0 0 0 0) size size false corner border false true)
  pbm = (buttonBitmap nil clr size size false corner border false false)
  tbm = (buttonBitmap nil clr size size false corner border true false)
  trigger = (new 'Trigger' nil onSelect fbm tbm pbm)
  m = (newMorph)
  setMorph trigger m
  setWidth (bounds m) size
  setHeight (bounds m) size
  tg = (new 'Toggle' m trigger query 'handEnter')
  setHandler m tg
  refresh tg
  return tg
}

method fixLayout InstanceIcon {
  setCenter (first (parts morph)) (hCenter (bounds morph)) (vCenter (bounds morph))
}

method handDownOn InstanceIcon aHand {return (handDownOn toggle aHand)}
method handEnter InstanceIcon aHand {handEnter toggle aHand}
method handLeave InstanceIcon aHand {handLeave toggle aHand}
method clicked InstanceIcon {return (clicked toggle)}
method doubleClicked InstanceIcon {return (doubleClicked toggle)}
method setHint InstanceIcon aStringOrNil {setHint toggle aStringOrNil}
method rightClicked InstanceIcon {return (rightClicked toggle)}
method refresh InstanceIcon {refresh toggle}
// Integer

// truncation and rounding

method floor Integer { return this }
method ceiling Integer { return this }
method integerPart Integer { return this }
method fractionPart Integer { return 0 }

method round Integer precision {
  // Return the nearest muliple of precision or this integer if precision is nil.

  if (isNil precision) { return this }
  return (integerPart (round (toFloat this) precision))
}

// conversion

method toInteger Integer { return this }
method toNumber Integer { return this }

method toStringDisabled Integer {
  comment '
	Convert an integer to a string. This is disabled since the toString primitive
	handles that and, when printing large arrays of numbers, performance can matter.
	But it''s good to have a GP version of this code. When we have a Squeak-like primitive
	mechanism that falls through to the GP code we can reinstate this method, prefixed by
	a call to the primitive.'

  if (this == 0) {
    return '0'
  }
  if (this < 0) {
    return (join '-' (abs this))
  }
  result = (list)
  v = this
  while (v > 0) {
    r = (v % 10)
    addFirst result (at (array '0' '1' '2' '3' '4' '5' '6' '7' '8' '9') (r + 1))
    v = (truncate (v / 10))
  }
  return (joinStringArray (toArray result))
}

method toStringBase16 Integer {
  comment '
	Convert an integer to a hexadecimal string.'

  if (this == 0) { return '0' }
  if (this < 0) { return (join '-' (toStringBase16 (abs this))) }
  hexDigits = (array '0' '1' '2' '3' '4' '5' '6' '7' '8' '9' 'A' 'B' 'C' 'D' 'E' 'F')
  result = (list)
  n = this
  while (n > 0) {
    addFirst result (at hexDigits ((n % 16) + 1))
    n = (truncate (n / 16))
  }
  return (joinStringArray (toArray result))
}

method toStringBase2 Integer {
  comment '
	Convert this integer to a binary string.'

  result = (list)
  n = this
  if (n == 0) { return '0' }
  negative = (n < 0)
  if negative { n = (0 - n) }
  while (n > 0) {
	if ((n & 1) == 1) {
	  addFirst result '1'
	} else {
	  addFirst result '0'
	}
	n = (n >> 1)
  }
  if negative { addFirst result '-' }
  return (joinStringArray (toArray result))
}

// divisors

method gcd Integer num {
  x = (abs this)
  y = (abs num)
  if (y > x) {
    temp = x
    x = y
    y = temp
  }
  while true {
    x = (% x y)
    if (x == 0) { return y }
    y = (% y x)
    if (y == 0) { return x }
  }
}

method lcm Integer num {
  return ((this * num) / (gcd this num))
}

method primeFactors Integer {
  n = (abs this)
  if (n < 2) { return (list n) }
  last = (toInteger (sqrt n))
  result = (list)
  factor = 2
  while (factor <= last) {
	while (0 == (n % factor)) {
	  add result factor
	  n = (n / factor)
	}
	factor += 1
  }
  if (n != 1) { add result n }
  return result
}

method isPowerOfTwo Integer {
  if (this < 1) { return false }
  return (0 == (this & (this - 1)))
}

// prime numbers

method isPrime Integer {
  n = this
  if (n < 2) { return false }
  if (n == 2) { return true }
  if ((n % 2) == 0) { return false }
  i = 3
  while ((i * i) <= n) {
    if ((n % i) == 0) { return false }
    i += 2
  }
  return true
}

method primeAfter Integer {
  n = this
  while (not (isPrime n)) { n += 1 }
  return n
}

// bit operations

method highBit Integer {
  shifted = this
  bitNo = 0
  while (shifted >= 65536) {
    shifted = (shifted >> 16)
    bitNo = (bitNo + 16)
  }
  if (shifted >= 256) {
    shifted = (shifted >> 8)
    bitNo = (bitNo + 8)
  }
  return (bitNo + (highBitOfByte shifted))
}

method highBitOfByte Integer {
  //highBitOfByteArray = (array 0 1 2 2 3 3 3 3 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8)
  if (this == 0) {
    return 0
  } (this < 2) {
    return 1
  } (this < 4) {
    return 2
  } (this < 8) {
    return 3
  } (this < 16) {
    return 4
  } (this < 32) {
    return 5
  } (this < 64) {
    return 6
  } (this < 128) {
    return 7
  } else {
    return 8
  }
}

method digitLength Integer {
  if (and (this < 256) (this > -256)) {return 1}
  if (and (this < 65536) (this > -65536)) {return 2}
  if (and (this < 16777216) (this > -16777216)) {return 3}
  return 4
}

method digitAt Integer index {
  // Compatibility with LargeInteger.  Significant bytes are at higher indices
  if (index > 4) {return 0}
  if (this < 0) {
    if (this == -1073741824) {
      // Can't negate minVal -- treat specially
      return (at (array 0 0 0 64) index)
    }
    v = (0 - this)
  } else {
    v = this
  }
  return ((v >> ((index - 1) * 8)) & 255)
}
defineClass LargeInteger data negative

method '==' LargeInteger other {
  if (this === other) { return true }
  if (isClass other 'LargeInteger') {
    oData = (getField other 'data')
    if ((negative == true) != ((getField other 'negative') == true)) {return false}
    if ((byteCount data) != (byteCount oData)) {return false}
    for i (byteCount data) {
      if ((byteAt data i) != (byteAt oData i)) {return false}
    }
    return true
  }
  return (other == this)
}

method '<<' LargeInteger amount {
  if (amount < 0) {return (this >> (0 - amount))}
  count = (byteCount data)
  bitOffset = (amount % 8)
  if (((byteAt data 1) << bitOffset) >= 256) {
    extra = 1
  } else {
    extra = 0
  }
  byteOffset = ((truncate (amount / 8)) + extra)
  newCount = (count + byteOffset)
  new = (newBinaryData newCount)

  carry = 0
  for i count {
    j = (count - (i - 1))
    byte = (byteAt data j)
    shifted = (byte << bitOffset)
    byteAtPut new (j + extra) ((shifted & 255) + carry)
    carry = ((shifted >> 8) & 255)
  }
  if (extra == 1) {byteAtPut new 1 carry}
  return (normalize (new 'LargeInteger' new))
}

method '>>>' LargeInteger amount { return (this >> amount) }

method '>>' LargeInteger amount {
  if (amount < 0) {return (this << (0 - amount))}
  count = (byteCount data)
  bitOffset = (amount % 8)
  if (((byteAt data 1) >> bitOffset) == 0) {
    extra = 1
  } else {
    extra = 0
  }
  byteOffset = ((truncate (amount / 8)) + extra)
  newCount = (- count byteOffset)
  new = (newBinaryData newCount)

  if (extra == 1) {
    byte = (byteAt data 1)
    carry = ((byte & ((1 << bitOffset) - 1)) << (8 - bitOffset))
  } else {
    carry = 0
  }
  for i newCount {
    byte = (byteAt data (i + extra))
    shifted = (byte >> bitOffset)
    byteAtPut new i (carry + shifted)
    carry = ((byte & ((1 << bitOffset) - 1)) << (8 - bitOffset))
  }
  return (normalize (new 'LargeInteger' new))
}

method '|' LargeInteger ... {
  max = (byteCount data)
  for i (argCount) {
    bc = (digitLength (arg i))
    if (max < bc) {max = bc}
  }
  new = (newBinaryData max)
  replaceByteRange new ((max - (byteCount data)) + 1) (byteCount new) data 1
  for i ((argCount) - 1) {
    other = (arg (i + 1))
    if ((classOf other) == (classOf 1)) {
      oData = (getField (toLargeInteger other) 'data')
    } else {
      oData = (getField other 'data')
    }
    for j (byteCount oData) {
      oInd = ((byteCount oData) - (j - 1))
      ind = (max - (j - 1))
      byteAtPut new ind ((byteAt new ind) | (byteAt oData oInd))
    }
  }
  return (normalize (new 'LargeInteger' new))
}

method '&' LargeInteger ... {
  max = (byteCount data)
  for i (argCount) {
    bc = (digitLength (arg i))
    if (max < bc) {max = bc}
  }
  new = (newBinaryData max)
  replaceByteRange new ((max - (byteCount data)) + 1) (byteCount new) data 1
  for i ((argCount) - 1) {
    other = (arg (i + 1))
    if ((classOf other) == (classOf 1)) {
      oData = (getField (toLargeInteger other) 'data')
    } else {
      oData = (getField other 'data')
    }
    diff = (max - (byteCount oData))
    for j diff {
      byteAtPut new j 0
    }
    for j (byteCount oData) {
      oInd = ((byteCount oData) - (j - 1))
      ind = (max - (j - 1))
      byteAtPut new ind ((byteAt new ind) & (byteAt oData oInd))
    }
  }
  return (normalize (new 'LargeInteger' new))
}

method '^' LargeInteger other {
  // bit xor. placeholder for crc 32
  new = (newBinaryData 4)
  for i 4 {
    byteAtPut new (5 - i) (((digitAt this i) ^ (digitAt other i)) & 255)
  }
  return (normalize (new 'LargeInteger' new))
}

method normalize LargeInteger {
  i = 1
  count = (byteCount data)
  while (and (i <= count) ((byteAt data i) == 0)) {
    i += 1
  }
  digits = (count - (i - 1))
  if (or (digits <= 3) (and (digits == 4) ((byteAt data 1) < 64))) {
    val = 0
    for j count {
      val = (val << 8)
      val += (byteAt data j)
    }
    return val
  }
  if (i == 1) {return this}
  new = (newBinaryData (count - (i - 1)))
  replaceByteRange new 1 (byteCount new) data i
  data = new
  return this
}

method digitLength LargeInteger {
  return (byteCount data)
}

method digitAt LargeInteger i {
  // significant bytes are at the higher indices
  c = (byteCount data)
  if (i > c) { return 0 }
  return (byteAt data ((c - i) + 1))
}

method toString LargeInteger {
  return (join '<LargeInteger 0x' (toStringBase16 this) '>')
}

method toStringBase16 LargeInteger {
  if ((byteCount data) == 0) {return '0'}
  digits = (array '0' '1' '2' '3' '4' '5' '6' '7' '8' '9' 'A' 'B' 'C' 'D' 'E' 'F')
  result = (newArray ((byteCount data) * 2))
  for i (byteCount data) {
    byte = (byteAt data i)
    atPut result ((i * 2) - 1) (at digits ((truncate (byte / 16)) + 1))
    atPut result (i * 2)       (at digits ((byte % 16) + 1))
  }
  return (joinStringArray result)
}

to largeInteger ... {
  data = (newBinaryData (argCount))
  for i (argCount) {
    byteAtPut data i (arg i)
  }
  return (new 'LargeInteger' data)
}

to toLargeInteger anInteger {
  if ((classOf anInteger) == (class 'LargeInteger')) {return anInteger}
  count = (digitLength anInteger)
  data = (newBinaryData count)
  for i count {
    j = (count - (i - 1))
    byteAtPut data j (anInteger % 256)
    anInteger = (truncate (anInteger / 256))
  }
  return (new 'LargeInteger' data)
}
defineClass List first last contents

to list args... {
  if (0 == (argCount)) {
	// common case of calling list with no arguments: client is building up a list
	// return an empty list with capacity to add a few items before growing
	return (new 'List' 1 0 (newArray 4))
  }
  result  = (new 'List' 1 0 (newArray (argCount)))
  for i (argCount) { add result (arg i) }
  return result
}

// queries

method count List { return ((last - first) + 1) }

method isEmpty List { return (last < first) }
method notEmpty List { return (last >= first) }

method contains List obj {
  // Return true if any element equals the given object.
  for i (count this) {
    if ((at this i) == obj) { return true }
  }
  return false
}

// adding

method add List obj {
  // Add obj to the end of this list.
  if (last == (count contents)) { // no room at end
    if (first > 1) {
	  // shift contents down to 1
	  arrayShift contents (1 - first)
	  last = ((last - first) + 1)
	  first = 1
	} else {
	  // grow contents (to double size, min 8)
	  n = (count contents)
	  if (n < 4) { n = 4 }
	  contents = (copyArray contents (2 * n))
	}
  }
  last += 1
  atPut contents last obj
}

method addFirst List obj {
  // Add obj to the start of this list.
  if (first == 1) { // no room at first
    if (last == (count contents)) {
	  // grow contents (to double size, min 8)
	  n = (count contents)
	  if (n < 4) { n = 4 }
	  contents = (copyArray contents (2 * n))
    }
	// shift contents to the end
	shift = ((count contents) - last)
	arrayShift contents shift
	last = (last + shift)
	first = (first + shift)
  }
  first = (first - 1)
  atPut contents first obj
  return obj
}

method addAll List other {
  for each other {
	add this each
  }
}

method addAt List index obj {
  if (index <= 1) { return (addFirst this obj) }
  if (index > (count this)) { return (add this obj) }
  if (last == (count contents)) {
    contents = (copyArray contents (2 * (count contents)))
  }
  i = ((first + index) - 1)
  replaceArrayRange contents (i + 1) (last + 1) contents i
  atPut contents i obj
  last += 1
  return obj
}

// removing

method remove List obj {
  idx = (indexOf this obj)
  while (notNil idx) {
    removeAt this idx
    idx = (indexOf this obj idx)
  }
}

method removeAt List index {
  if (or (index < 1) (index > (count this))) { return }
  if (index == 1) {
	atPut contents first nil
    first += 1
  } else {
    i = (first + (index - 1))
    replaceArrayRange contents i (last - 1) contents (i + 1)
    atPut contents last nil
    last += -1
  }
}

method removeAll List other {
  if (isNil other) { // remove all elements
    first = 1
	last = 0
	contents = (newArray 10)
  } else {
    for i (count other) {
      remove this (at other i)
	}
  }
}

// indexed access

method at List index {
  i = ((first + index) - 1)
  if (or (i < first) (i > last)) { error 'List index out of range:' index }
  return (at contents i)
}

method atPut List index obj {
  i = ((first + index) - 1)
  if (or (i < first) (i > last)) { error 'List index out of range:' index }
  atPut contents ((first + index) - 1) obj
}

method first List {
  if (last < first) { error 'List is empty' }
  return (at contents first)
}

method last List {
  if (last < first) { error 'List is empty' }
  return (at contents last)
}

method removeFirst List {
  if (last < first) { error 'List is empty' }
  result = (at contents first)
  atPut contents first nil
  first += 1
  return result
}

method removeLast List {
  if (last < first) { error 'List is empty' }
  result = (at contents last)
  atPut contents last nil
  last += -1
  return result
}

method indexOf List obj startIndex {
  // Return the index of the first occurrence of the given object after
  // startIndex, or nil if not found. startIndex is optional.

  if (isNil startIndex) { startIndex = 0 }
  i = (first + startIndex) // index *after* startIndex
  if (i < 1) { i = 1 }
  while (i <= last) {
    if (obj == (at contents i)) { return ((i - first) + 1) }
	i += 1
  }
  return nil
}

method lastIndexOf List obj startIndex {
  // Return the index of the last occurrence of the given object before
  // startIndex, or nil if not found. startIndex is optional.

  if (isNil startIndex) { startIndex = ((count this) + 1) }
  i = ((first + startIndex) - 2) // index *before* startIndex
  if (i > (count this)) { i = (count this) }
  while (i >= first) {
    if (obj == (at contents i)) { return ((i - first) + 1) }
	i += -1
  }
  return nil
}

// equality

method '==' List other {
  if (this === other) { return true }
  if (not (isClass other 'List')) {
    return false
  }
  if ((count this) != (count other)) {
    return false
  }
  for i (count this) {
    if ((at this i) != (at other i)) {
      return false
    }
  }
  return true
}

// comparison

method '<' List other {
  n = (min (count this) (count other))
  for i n {
    if ((at this i) < (at other i)) {
      return true
    }
  }
  return ((count this) < (count other))
}

method '<=' List other { return (or (this < other) (this == other)) }
method '>' List other { return (and (not (this < other)) (not (this == other))) }
method '>=' List other { return (not (this < other))}

// converting

method toArray List {
  result = (newArray (count this))
  for i (count this) {
    atPut result i (at this i)
  }
  return result
}

method toList List { return this }

method toString List limit visited {
  if (isNil limit) { limit = 100 }
  if (isNil visited) { visited = (dictionary) }
  if (contains visited this) { return '(list ...)' }
  add visited this
  if (limit > (count this)) { limit = (count this) }
  s = '(list'
  for i limit {
    s = (join s ' ' (toString (at this i) nil visited))
  }
  if (limit < (count this)) { s = (join s ' ...') }
  s = (join s ')')
  return s
}

method reversed List {
  result = (list)
  size = (count this)
  for i size {
    add result (at this (size - (i - 1)))
  }
  return result
}

method join List args... {
  comment '
	Return a new list that contains the contents of this list and the
	contents of all argument lists or arrays (i.e. concatenate all lists/arrays).'

  result = (list)
  for i (argCount) { addAll result (arg i) }
  return result
}

method joinStrings List delimiter {
  comment '
	Assuming this is a list of strings, return the result of joining those strings.'

  if (last < first) { return '' }
  return (joinStringArray contents delimiter first last)
}

method copy List {
  result = (clone this)
  setField result 'contents' (copyArray contents)
  return result
}

method copyFromTo List start end {
  if (and (isNil start) (isNil end)) {
	return (copy this)
  }
  if (isNil start) { start = 1 }
  if (isNil end) { end = (count this) }
  count = ((end - start) + 1)
  if (count <= 0) { return (list) }
  result = (list)
  for i count {
	add result (at this ((start + i) - 1))
  }
  return result
}

// sorting

method sorted List sortFunction {
  comment '
	Return a sorted copy of this list.'

  return (toList (sorted (toArray this) sortFunction))
}

// serialization

method serializedFieldNames List { return (array) }
method serialize List { return (toArray this) }

method deserialize List fieldDict extraFields {
  contents = extraFields
  first = 1
  last = (count contents)
}
// Morphic ListBox handler

defineClass ListBox morph collection onSelect getEntry selection bgColor fontName fontSize txtClrNormal bgClrNormal txtClrReady bgClrReady txtClrSelected bgClrSelected normalAlpha paddingX paddingY itemWidth minWidth onDoubleClick getHint highlighted

to listBox aCollection getEntry onSelect bgColor onDoubleClick getHint normalAlpha {
  if (isNil getEntry) {getEntry = 'id'}
  if (isNil onSelect) {onSelect = 'nop'}
  if (isNil bgColor) {bgColor = (color 255 255 255)}
  if (isNil normalAlpha) {normalAlpha = 255}

  lb = (new 'ListBox' nil aCollection onSelect getEntry nil bgColor)
  onDoubleClick lb onDoubleClick
  setField lb 'getHint' getHint
  initialize lb normalAlpha
  buildMorph lb
  return lb
}

method initialize ListBox alpha {
  scale = (global 'scale')
  fontName = 'Arial'
  fontSize = (scale * 12)
  txtClrNormal = (color)
  bgClrNormal = bgColor
  txtClrReady = txtClrNormal
  bgClrReady = (darker bgClrNormal 8)
  txtClrSelected = bgClrNormal
  bgClrSelected = (darker bgClrNormal 55)
  paddingX = (scale * 6)
  paddingY = scale
  minWidth = 0
  normalAlpha = alpha
}

method collection ListBox { return collection }
method selection ListBox {return selection}
method isSelecting ListBox anObject {return (selection == anObject)}
method onSelect ListBox anAction {onSelect = anAction}
method onDoubleClick ListBox anAction {onDoubleClick = anAction}
method highlighted ListBox {return highlighted}
method setNormalAlpha ListBox num {normalAlpha = num}

method buildMorph ListBox {
  if (notNil morph) {destroy morph}
  morph = (newMorph this)
  setTransparentTouch morph true
  updateMorphContents this
}

method selectionIndex ListBox {
  for i (count (parts morph)) {
    item = (handler (at (parts morph) i))
	if (isOn item) { return i }
  }
  return nil
}

method select ListBox aListItem silently {
  if (isNil silently) {silently = false}
  selection = aListItem
  for i (count (parts morph)) {
    hdl = (handler (at (parts morph) i))
    if (implements hdl 'refresh') {refresh hdl true}
  }
  if (not silently) {
    if (notNil selection) {call onSelect selection}
  }
}

method selectedMorph ListBox {
  // private - answer the currently selected morph
  // so it can be scrolled into view
  for item (parts morph) {if (isOn (handler item)) {return item}}
  return nil
}

method highlightOn ListBox aListItem {highlighted = aListItem}

method highlightOff ListBox aListItem {
  if (highlighted === aListItem) {
    highlighted = nil
  }
}

method setCollection ListBox aCollection anActionForHint {
  if (isNil anActionForHint) {anActionForHint = getHint}
  collection = aCollection
  getHint = anActionForHint
  updateMorphContents this
}

method setHint ListBox listItem aStringOrNil {setHint (listItem this listItem) aStringOrNil}

method setFont ListBox fName fSize {
  if (notNil fName) { fontName = fName }
  if (notNil fSize) { fontSize = ((global 'scale') * fSize) }
  updateMorphContents this
}

method updateMorphContents ListBox {
  changed morph

  // remove all existing list items, if any
  repeat (count (parts morph)) {destroy (at (parts morph) 1)}
  setWidth (bounds morph) 1

  // create and position items and measure dimensions
  itemWidth = 0
  height = 0
  setFont fontName fontSize
  x = (left morph)
  y = ((top morph) + (3 * (global 'scale')))
  for item collection {
    lbl = (normalCostume this item)
    li = (listItem this item)
    setHeight (bounds (morph li)) (height lbl)
    replaceCostumes li lbl
    setPosition (morph li) x y
    addPart morph (morph li)
    itemWidth = (max itemWidth (width lbl))
    height += (height lbl)
    y += (height lbl)
  }
  setWidth (bounds morph) (max itemWidth minWidth)
  setHeight (bounds morph) height

  // create a new background bitmap
  // --- commented out to preserve resources ---
  // bg = (newBitmap (max 1 (width morph)) (max 1 height) bgColor)
  // setCostume morph bg false true // don't resize

  // set width and refresh every item
  for i (count (parts morph)) {
    item = (handler (at (parts morph) i))
    setWidth (bounds (morph item)) (width morph)
    refresh item
  }

  // update sliders, if any
  owner = (owner morph)
  if (and (notNil owner) (isClass (handler owner) 'ScrollFrame'))  {updateSliders (handler owner)}

  changed morph
}

method setMinWidth ListBox newWidth {
  if (newWidth == minWidth) {return}
  minWidth = (max newWidth itemWidth)
  setWidth (bounds morph) minWidth

  // create a new background bitmap
  // --- commented out to preserve resources ---
  // bg = (newBitmap (max 1 (width morph)) (max 1 (height morph)) bgColor)
  // setCostume morph bg false true // don't resize

  for i (count (parts morph)) {
    item = (handler (at (parts morph) i))
    removeCostume item 'highlight'
    removeCostume item 'pressed'
    setWidth (bounds (morph item)) minWidth
    refresh item
  }
}

method itemWidth ListBox {return itemWidth}

method allWidth ListBox {
  // answer the ideal width which can show every item without scrolling horizontally
  w = (+ itemWidth (2 * paddingX))
  parent = (handler (owner morph))
  if (isClass parent 'ScrollFrame') {
    += w (width (morph (getField parent 'vSlider')))
  }
  return w
}

method listItem ListBox item {
  tr = (new 'Trigger' nil (action 'select' this item))
  if (notNil onDoubleClick) {onDoubleClick tr (action onDoubleClick item)}
  if (notNil getHint) {setHint tr (call getHint item)}
  setData tr item
  setRenderer tr this
  m = (newMorph)
  setMorph tr m
  setTransparentTouch m true
  li = (new 'Toggle' m tr (action 'isSelecting' this item) 'handEnter')
  setHandler m li
  setClipping m true
  return li
}

method normalCostume ListBox data accessor {
  // optimized for text list items
  // oldCode: {return (itemCostume this data txtClrNormal nil normalAlpha accessor)}

  if (isNil accessor) {accessor = getEntry}
  dta = (call accessor data)
  if (isClass dta 'String') {
    return (stringImage dta fontName fontSize txtClrNormal nil nil nil nil paddingX paddingY)
  } (isClass dta 'Bitmap') {
    bm = (newBitmap (+ (* 2 paddingX) (width dta)) (+ (height dta) (* 2 paddingY)) bgClrNormal)
    drawBitmap bm dta paddingX paddingY normalAlpha
    return bm
  } (isClass dta 'Array') {
    return (stringImage (at dta 1) fontName fontSize txtClrNormal nil nil nil nil paddingX paddingY)
  }
  return (itemCostume this dta txtClrNormal nil normalAlpha 'id')
}

method highlightCostume ListBox data accessor {
	if (isClass data 'Array') {
		return (itemCostume this (at data 1) txtClrSelected bgClrSelected 255 accessor)
	} else {
		return (itemCostume this data txtClrSelected bgClrSelected 255 accessor)
	}
}
method pressedCostume ListBox data accessor {
	if (isClass data 'Array') {
		return (itemCostume this (at data 1) txtClrReady bgClrReady 255 accessor)
	} else {
		return (itemCostume this data txtClrReady bgClrReady 255 accessor)
	}
}

method itemCostume ListBox data foregroundColor backgroundColor alpha accessor {
  // private - return a bitmap representing a list item
  if (isNil accessor) {accessor = getEntry}
  dta = (call accessor data)
  if (isClass dta 'Bitmap') {
    bm = (newBitmap (max (+ (* 2 paddingX) (width dta)) (width morph)) (+ (height dta) (* 2 paddingY)) backgroundColor)
    drawBitmap bm dta paddingX paddingY alpha
    return bm
  } (isClass dta 'Morph') {
    return (itemCostume this (fullCostume dta) foregroundColor backgroundColor alpha 'id')
  } (hasField dta 'morph') {
    return (itemCostume this (fullCostume (getField dta 'morph')) foregroundColor backgroundColor alpha 'id')
  } (isAnyClass dta 'Command' 'Reporter') {
    return (itemCostume this (fullCostume (morph (toBlock dta))) foregroundColor backgroundColor alpha 'id')
  } (isClass dta 'String') {
    return (itemCostume this (stringImage dta fontName fontSize foregroundColor) foregroundColor backgroundColor alpha 'id')
  } else {
    return (itemCostume this (toString dta) foregroundColor backgroundColor alpha 'id')
  }
}

// arrow key navigation

method arrowKey ListBox dx dy scrollFrame {
	index = (selectionIndex this)
	if (and
		((count collection) > 0)
		(isNil index)
	) {
		select this (first collection) true
	}
	if (dy < 0) {
		if (index < (count collection)) {
			select this (at collection (index + 1)) true
		}
	} (dy > 0) {
		if (index > 1) {
			select this (at collection (index - 1)) true
		}
	}
}

// context menu

method handleContextRequest ListBox item {
  raise morph 'handleListContextRequest' (array this item)
}

// serialization

method preSerialize ListBox {
  removeAllParts morph
  setCostume morph nil
}

method postSerialize ListBox {
  updateMorphContents this
  select this selection true
}
// MIDIFileReader.gp - Create a ScorePlayer from a MIDI file.

to playMidi fName instrName {
  play (playerForMIDIFile fName instrName)
}

to playerForMIDIFile fName instrName {
  // Return a player for the given MIDI file. If instrName is not nil,
  // play all voices on that instrument.

  if (not (endsWith fName '.mid')) { fName = (join fName '.mid') }
  if (not (contains (letters fName) '/')) { fName = (join (runtimeFolder 'midi/') fName) }
  midi = (decodeMIDI (new 'MIDIFileReader') (readFile fName true))

  defaultInstrName = instrName
  if (isNil defaultInstrName) { defaultInstrName = 'guitar' }
  player = (newScorePlayer (newSampledInstrument defaultInstrName))

  tracks = (tracks midi)
  for i (count tracks) {
	if (isNil instrName) {
	  addVoice player (at tracks i) (instrForTrack midi i)
	} else {
	  addVoice player (at tracks i) // use the instrument specified by caller
	}
  }
  for track (drumTracks midi) {
	addVoice player track (newSampledInstrument 'drums')
  }
  if (notNil (tempo midi)) {
	setTempo player (tempo midi)
  }
  return player
}

defineClass MIDIFileReader msecsPerTick tempo tracks trackPrograms drumTracks cmd

method tempo MIDIFileReader { return tempo }
method tracks MIDIFileReader { return tracks }
method drumTracks MIDIFileReader { return drumTracks }

method decodeMIDI MIDIFileReader data {
  tracks = (list)
  trackPrograms = (list)
  drumTracks = (list)
  stream = (dataStream data true)
  readHeaderChunk this stream
  while (not (atEnd stream)) {
	chunkType = (nextString stream 4)
	chunkSize = (nextUInt32 stream)
	if ('MTrk' == chunkType) {
	  trackData = (nextData stream chunkSize)
	  readTrack this (dataStream trackData true)
	} else {
	  print 'Skipping unexpected chunk type' chunkType
	  skip stream chunkSize
	}
  }
  return this
}

method instrForTrack MIDIFileReader trackIndex {
  instrName = 'guitar' // default
  if (trackIndex <= (count trackPrograms)) {
	p = (at trackPrograms trackIndex)
	if (p < 8) { instrName = 'guitar' // nicer than our current piano
	} (p == 12) { instrName = 'marimba'
	} (p < 16) { instrName = 'vibraphone'
	} (p < 24) { instrName = 'organ'
	} (p < 32) { instrName = 'guitar'
	} (p < 40) { instrName = 'bass'
	} (p < 48) { instrName = 'guitar' // nicer than current strings
	} (p < 56) { instrName = 'guitar' // nicer than current strings
	} (p < 64) { instrName = 'brass'
	} (p < 68) { instrName = 'sax'
	} (p < 71) { instrName = 'bassoon'
	} (p < 72) { instrName = 'clarinet'
	}
  }
  return (newSampledInstrument instrName)
}

method readHeaderChunk MIDIFileReader stream {
  chunkType = (nextString stream 4)
  chunkSize = (nextUInt32 stream)
  if (or ('MThd' != chunkType) (6 < chunkSize)) {
	error 'Bad MIDI header; not a MIDI file?'
  }
  format = (nextUInt16 stream)
  trackCount = (nextUInt16 stream)
  division = (nextUInt16 stream)
  if (format == 2) {
	print 'Format 2 MIDI file: tracks are independent'
  } (format > 2) {
	print 'Unknown MIDI file format:' format
  }
  if (division < 32768) {
	ticksPerBeat = division
  } else {
	print 'Ignoring SMTPE time unit'
	ticksPerBeat = 600
  }
  msecsPerTick = (600 / ticksPerBeat) // 100 beats/minute
}

method readTrack MIDIFileReader stream {
  events = (list)
  t = 0 // current time in beats
  program = nil
  isDrums = false
  cmd = nil // clear running status
  while (not (atEnd stream)) {
	deltaT = (readVarInt this stream)
	t += (deltaT * msecsPerTick)
	byte = (nextUInt8 stream)
	if (byte == 255) {
	  readMetaEvent this stream t
	} (isOneOf byte 240 247) {
	  // System exclusive messages in MIDI files appear to be extremely rare.
	  error 'MIDIFileReader does not yet handle system exclusive messages:' byte
	} (byte > 248) {
	  // real-time message; ignore
	} else {
	  evt = (readEvent this stream byte)
	  cmd = (first evt)
	  if (and (128 <= cmd) (cmd <= 159)) {
		// collect noteOn and noteOff events
		add events (array (round t) evt)
		if ((cmd & 15) == 9) { isDrums = true } // channel 9 is always drums
	  } (and (192 <= cmd) (cmd <= 207)) {
		if (isNil program) { program = (at evt 2) } // first program event determines track instrument
	  }
	}
  }
  noteList = (createNotes this events)
  if ((count noteList) > 0) {
	if isDrums {
	  add drumTracks noteList
	} else {
	  add tracks noteList
	  if (isNil program) { program = 0 }
	  add trackPrograms program
	}
  }
}

method readMetaEvent MIDIFileReader stream t {
  // Read and discard a meta event of the form: 255 <type> <len> <data bytes...>

  type = (nextUInt8 stream)
  len = (readVarInt this stream)
  if (and (1 <= type) (type <= 15)) {
	// meta event types 1-15 are reserved for string data
	printMetaInfo = false // make true to print string meta events
	if printMetaInfo {
	  print (nextString stream len)
	} else {
	  skip stream len
	}
  } else {
	if (and (81 == type) (isNil tempo)) { // extract tempo from the first tempo event
	  // Note: Some MIDI files contain many tempo changes. Later, these could
	  // be collected into a tempo change track for use by the ScorePlayer.
	  usecsPerBeat = (nextUInt8 stream)
	  usecsPerBeat = ((usecsPerBeat << 8) + (nextUInt8 stream))
	  usecsPerBeat = ((usecsPerBeat << 8) + (nextUInt8 stream))
	  tempo = (round (60000000 / usecsPerBeat))
	  skip stream -3
	}
	skip stream len
  }
}

method readEvent MIDIFileReader stream byte {
  // Return an array containing a MIDI command byte followed by one or two argument bytes.

  if (byte < 128) {
	if (notNil cmd) {
	  skip stream -1 // running status; use the last cmd and position stream to first arg byte
	} else { // should not happen in a well-formed MIDI file
	  print 'No previous command for running status; skipping to the next command byte'
	  while (and (byte < 128) ((remaining stream) > 0)) {
		byte = (nextUInt8 stream)
	  }
	  cmd = byte
	}
  } else {
	cmd = byte // start of a new command
  }
  type = ((cmd >> 4) & 15)
  if (or (type == 12) (type == 13)) { // one arg byte
	return (array cmd (nextUInt8 stream))
  } (type < 15) { // two arg bytes
	return (array cmd (nextUInt8 stream) (nextUInt8 stream))
  }
  error 'Unexpected command byte:' cmd
}

method readVarInt MIDIFileReader stream {
  // Read a variable-length unsigned integer. Each byte has seven bits of the result.
  // If the most significant bit is set, then additional byte(s) follow. The maximum
  // number of bytes is four, resulting in a 28-bit integer.

  result = 0
  repeat 4 { // at most four bytes
	byte = (nextUInt8 stream)
	result = ((result << 7) + (byte & 127))
	if (byte < 128) { return result }
  }
  return result
}

method createNotes MIDIFileReader cmdList {
  // Convert a list of MIDI commands into a sequence of Note objects.

  soundingNotes = (list)
  result = (list)
  for pair cmdList {
	t = (first pair)
	evt = (last pair)
	cmd = ((first evt) & 240)
	key = (at evt 2)
	vel = (at evt 3)
	if (and (144 == cmd) (vel > 0)) { // noteOn
	  note = (newScoreNote t key vel 123) // 123 is a placeholder; the actual duration is set later
	  add soundingNotes note
	  add result note
	} (or (128 == cmd) (and (144 == cmd) (vel == 0))) { // noteOff
	  note = (findNoteForKey this soundingNotes key)
	  if (notNil note) {
		dur = (max 1 (t - (startTime note)))
		setDuration note dur
		remove soundingNotes note
	  }
	} else {
	  print 'Unexpected cmd in createNotes:' cmd
	}
  }
  return result
}

method findNoteForKey MIDIFileReader soundingNotes key {
  for n soundingNotes {
	if (key == (key n)) { return n }
  }
  return nil
}
// MediaViewer.gp - Media and Notes viewer for use in ProjectEditor

defineClass MediaViewer morph project type listFrame notesFrame resizer

method type MediaViewer { return type }

to newMediaViewer aProject viewerType {
  return (initialize (new 'MediaViewer') aProject viewerType)
}

method initialize MediaViewer aProject viewerType {
  scale = (global 'scale')
  project = aProject
  type = viewerType
  morph = (newMorph this)
  if ('Images' == viewerType) {
	addImportButton this 'image'
	addPaintButton this
	addMediaList this (images project)
  } ('Sounds' == viewerType) {
	addImportButton this 'sound'
	addMediaList this (sounds project)
  } ('Notes' == viewerType) {
	addNotes this
  }
  setMinExtent morph (scale * 235) (scale * 200)
  resizer = (resizeHandle this 'horizontal')
  return this
}

// notes

method saveNotes MediaViewer {
  if (notNil notesFrame) {
    setNotes project (contentsWithoutCRs (contents notesFrame))
  }
}

method redraw MediaViewer {
  fillColor = (gray 220)
  borderColor = (gray 150)
  borderWidth = (2 * (global 'scale'))
  bm = (newBitmap (width morph) (height morph) fillColor)
  outlineRectangle (newShapeMaker bm) (rect 0 0 (width morph) (height morph)) borderWidth borderColor
  setCostume morph bm
  fixLayout this
}

method addImportButton MediaViewer mediaType {
  if ('Browser' == (platform)) { return } // import on browser is via drag-n-drop
  scale = (global 'scale')
  label = (join 'Add ' mediaType ' from file')
  btn = (pushButton label (gray 120) (action 'importMediaFile' this mediaType))
  setPosition (morph btn) (12 * scale) (15 * scale)
  addPart morph (morph btn)
}

method addPaintButton MediaViewer {
  scale = (global 'scale')
  label = (join 'Paint new image')
  btn = (pushButton label (gray 120) (action 'openPaintEditor' this))
  setPosition (morph btn) (140 * scale) (15 * scale)
  if ('Browser' == (platform)) { setPosition (morph btn) (12 * scale) (15 * scale) }
  addPart morph (morph btn)
}

method addMediaList MediaViewer mediaItems {
  menuIcon = (menuIcon this)
  soundIcon = (soundIcon this)
  listFrame = (scrollFrame (newBox) (gray 240))
  contentsM = (morph (contents listFrame))
  setExtent contentsM 0 0
  for el mediaItems {
	item = (intialize (new 'MediaItem') el menuIcon soundIcon)
	addPart contentsM (morph item)
  }
  fixLayout this
  addPart morph (morph listFrame)
}

method addNotes MediaViewer {
  scale = (global 'scale')
  textBox = (newText '' 'Arial' (18 * scale))
  setEditRule textBox 'editable'
  setGrabRule (morph textBox) 'ignore'
  setBorders textBox 10 10
  notesFrame = (scrollFrame textBox (gray 235))
  setPosition (morph notesFrame) (10 * scale) (10 * scale)
  setExtent (morph notesFrame) 500 800
  setText textBox (notes project)
  addPart morph (morph notesFrame)
}

method importMediaFile MediaViewer mediaType {
  editor = (projectEditor this)
  if (notNil editor) { importMediaFile editor mediaType }
}

method textChanged MediaViewer txt {
  if (notNil notesFrame) {
	rightMargin = (5 * (global 'scale'))
	wrapLinesToWidth (contents notesFrame) (max 100 ((width (morph notesFrame)) - rightMargin))
	saveNotes this
  }
  itemM = (ownerThatIsA (morph txt) 'MediaItem')
  if (notNil itemM) { // edit name of a media item
	item = (item (handler itemM))
	setName item (text txt)
  }
}

// editors

method openPaintEditor MediaViewer {
  editor = (projectEditor this)
  if (isNil editor) { return }
  openPaintEditorOn origImg (action 'saveEditedImage' editor)
}

method projectEditor MediaViewer {
  editor = (ownerThatIsA morph 'ProjectEditor')
  if (isNil editor) { return nil }
  return (handler editor)
}

// layout

method fixLayout MediaViewer {
  scale = (global 'scale')
  border = (2 * scale)
  rightMargin = (5 * scale)

  if (notNil resizer) {
	setRight (morph resizer) ((right morph) - border)
	setBottom (morph resizer) ((bottom morph) - border)
	addPart morph (morph resizer) // bring to front
  }
  if (notNil listFrame) {
	  m = (morph listFrame)
	  setInsetInOwner m border (40 * scale)
	  setExtent m ((right morph) - ((left m) + border)) ((bottom morph) - ((top m) + border))
	  fixListItemLayout this
  }
  if (notNil notesFrame) {
	  m = (morph notesFrame)
	  setInsetInOwner m border border
	  setExtent m ((right morph) - ((left m) + border)) ((bottom morph) - ((top m) + border))
	  wrapLinesToWidth (contents notesFrame) (max 100 ((width m) - rightMargin))
  }
  if (notNil (morph resizer)) {
	size = (10 * scale)
    setLeft (morph resizer) ((right morph) - border)
    setTop (morph resizer) (top morph)
    setExtent (morph resizer) size (height morph)
    drawPaneResizingCostumes resizer
  }
  editor = (projectEditor this)
  if (notNil editor) { fixLayout editor }
}

method fixListItemLayout MediaViewer {
  itemWidth = (max 100 (width (morph listFrame)))
  listContents = (morph (contents listFrame))
  y = (top listContents)
  for itemM (parts listContents) {
	setItemWidth (handler itemM) itemWidth
	setPosition itemM (left listContents) y
	y += ((height (fullBounds itemM)) + 5)
  }
  updateSliders listFrame
}

method menuIcon MediaViewer {
  data = '
AAAAAAAAAAAAAgMAAAc/e6zP7f397c+sej8HAAADAgAAAAAAAAAAAAAAAAAAAAAABQAAKYzd///////9
/f//////3YwpAAAFAAAAAAAAAAAAAAAAAAACAgAZl/v///z3+v////////r3/P//+5cZAAICAAAAAAAA
AAAAAAADAABc7v//9vv////45dzc5fj////79v//7lwAAAMAAAAAAAAAAAADAACa///3/P//0IdIIg4G
Bg4iSIfQ///89///mgAAAwAAAAAAAAADAAC1//z4//+8SQIAAAAAAAAAAAAAAkm9///4/P+1AAADAAAA
AAACAAC1//r6/+lUAAAABAQDAgICAgMEBAAAAFTp//r6/7UAAAIAAAAAAgCa//n7/8IXAAEEAQAAAAAA
AAAAAAABBAEAF8L/+/n/mgACAAAABQBc//z6/7UAAAYBAAAAAAAAAAAAAAAAAAABBgAAtf/6/P9cAAUA
AgAZ7v/4/8IAAAUAAAAAAAAAAAAAAAAAAAAAAAAFAADC//j/7hkAAgMAl//3/+kXAAUBAwMDAwMDAwMD
AwMDAwMDAwMDAgUAF+n/9/+XAAMAKPv//P9UAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwBU//z/+ykA
AIv/9v+9AAECAGOajpGQkJCQkJCQkJCQkJCQkJKMFgADAL3/9v+MAAfd//v/SQAEAgC5////////////
/////////////ykABwBJ//v/3Qc///z/0AEAAQIAuf////////////////////////8pAAQAAtD//P8/
e//3/4YABAABAGSajpGQkJCQkJCQkJCQkJCQkJKMFgABBACH//f/eqz/+v9IAAQAAAEAAAAAAAAAAAAA
AAAAAAAAAAAAAAABAAQASP/6/6zP///4IgADAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQADACL4///P
7f//5g4AAgABAGSajpGRkZGRkZGRkZGRkZGRkJOMFgABAgAO5f//7f39/9wFAAIAAgC6////////////
/////////////ykAAwEABtz//f39/f/cBgACAAIAuv////////////////////////8pAAMBAAbc//39
7f//5g4AAgABAGSajpGRkZGRkZGRkZGRkZGRkJOMFgABAgAO5v//7c////giAAMAAAEAAAAAAAAAAAAA
AAAAAAAAAAAAAAABAAMAIvj//8+s//r/SAAEAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAEj/+v+s
e//3/4YABAABAGWckJOTk5OTk5OTk5OTk5OTkpSOFgABBACH//f/e0D//P/QAQABAgC5////////////
/////////////ykABAAC0P/8/z8H3f/7/0kABAIAuf////////////////////////8pAAcASf/7/90H
AIz/9v+8AAECAGSajpGRkZGRkZGRkZGRkZGRkJKMFgADAL3/9v+MAAAo+//8/1QABgAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAHAFT//P/7KAADAJf/9//pFwAFAQMDAwMDAwMDAwMDAwMDAwMDAwIFABfp//f/lwAD
AgAZ7v/4/8IAAAUAAAAAAAAAAAAAAAAAAAAAAAAFAADC//j/7hkAAgAFAFz//Pr/tQAABgEAAAAAAAAA
AAAAAAAAAAEGAAC1//r8/1wABQAAAAIAmv/5+//CFwABBAEAAAAAAAAAAAAAAQQBABfC//v5/5oAAgAA
AAACAAC1//r6/+lUAAAABAQDAgICAgMEBAAAAFTp//r6/7QAAAIAAAAAAAMAALX//Pj//7xJAQAAAAAA
AAAAAAABSbz///j8/7UAAAMAAAAAAAAAAwAAmv//9/z//9CGSCIOBgYOIkiH0P///Pf//5oAAAMAAAAA
AAAAAAADAABc7v//9vv////45dzc5fj////79v//7lwAAAMAAAAAAAAAAAAAAAICABmX+////Pf6////
////+vf8///7lxkAAgIAAAAAAAAAAAAAAAAAAAUAACiM3f///////f3//////92LKAAABQAAAAAAAAAA
AAAAAAAAAAAAAgMAAAdAe6zP7f397c+se0AHAAADAgAAAAAAAAAAAA=='
  bm = (newBitmap 40 40)
  applyAlphaChannel bm (base64Decode data) (gray 130)
  return bm
}

method soundIcon MediaViewer {
  data = '
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAgAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB
BAAABAEAAAAAAAAAAAAAAAAAAAAAAAABBAMEAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAgAACAkAAAEAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAwAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAHrg4nsAAAEAAAAAAAAAAAAAAAAA
AAEAAGW2mB0ABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAACk
/////2IABAAAAAAAAAAAAAAAAAAAAwB9////4BIAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAABQAOwv/6/Pf/qwADAAAAAAAAAAAAAAAAAAIABuD/9/f/tQAAAQAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAJdz/+v//+/+sAAIAAAAAAAAAAAAAAAAA
AgAE2//8//r/dgAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEEAD3w//r/
///7/6sAAwAAAAAAAAAAAAAAAAAABABx//z//f/8KQAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAACAgBb///6//////v/rAADAAAAAAAAAAAAAQQCAwMAAACo//r/+v/AAAABAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAev//+///////+/+sAAMAAAAAAAAAAAEAAAAA
AAICAA3k//z/+/9jAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAJf//vz/////
///7/6wAAwAAAAAAAAABAABqvqUoAAMFAEv//v/8/+QNAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAFAAe5//z+//////////v/rAADAAAAAAAAAAMAev///+oYAAMDAKD/+v/6/3oABAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAbz//6////////////+/+sAAMAAAAAAAACAALa//j3
/7QAAAQAG/H//f3/5xQAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQUANOv/+v//////////
///7/6wAAwAAAAAAAAEAANH//P/7/2YABAUAe//6//v/egAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAICAE34//r///////////////v/rAADAAAAAAAAAAQAZP/8//z/6REABAAR5//9/P/bBgACAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAABv///7////////////////+/+sAAMAAAADBAIAAQEAp//6
//r/iwAEBAB7//v//P9UAAQAAAAAAAAAAAIEAwMDAwMDAwMDAwMDAwMDBgAAif///P//////////////
///7/6wAAwABAQAAAAIAAwAY8P/9/f/0IAAFABrw//77/68AAgAAAAAAAAADAAAAAAAAAAAAAAAAAAAA
AAAAA63//P3///////////////////v/rAACAQAALEMLAAMABQBw//v/+/+PAAMEAJv/+v7/8x8AAwAA
AAAAAQAQMS8vMDAwMDAwMDAwMC8wLjPC//v+////////////////////+/+sAAMBAIn//9wpAAMBAAbZ
//z9/+sSAAYAQf/+/vz/ZgAEAAAAAAIAV+v//f7+/v7+/v7+/v7+/v79///7////////////////////
///7/6wABgBA///5/8kAAAEEAGf//P/7/2QABgAF2f/8+/+vAAEBAAACAB35////////////////////
/////f////////////////////////v/rAAHAG3/+f/6/2EABAIAC+L//fv/vQABBACR//v9/+gSAAIA
AAQASf/6/v7+/v7+/v7+/v7+/v7+/v7/////////////////////////+/+sAAYAM////vz/1gYAAQQA
jP/6/v/2JAAHAEv//v7+/0AABAAABABI//7/////////////////////////////////////////////
///7/6wAAwMAm//6//z/XAAEAwA2///+/P9nAAYAF+v//vv/dwAFAAAEAEj//f//////////////////
//////////////////////////////v/rAACAwAh9f/++/+6AAECAATV//z7/6YAAgEAwP/7+/+nAAMA
AAQASP/9////////////////////////////////////////////////+/+sAAMAAwCW//v+//kkAAMD
AJX/+/z/2gcABQCP//r8/88AAAEABABI//3/////////////////////////////////////////////
///7/6wAAwAEADj///78/2MABAQAW//9/f/5JQAHAGP//P3/6hQAAgAEAEj//f//////////////////
//////////////////////////////v/rAADAAEAAdP//Pv/ogADAwAu/P/+/f9IAAgAQP///f/8LAAD
AAQASP/9////////////////////////////////////////////////+/+sAAMAAAQAl//7/P/QAgAD
ABDk//37/2oACAAn+//9//9DAAQABABI//3/////////////////////////////////////////////
///7/6wAAwAABQBj//v+/+wZAAMAAMz//Pr/hgAHABbu//z9/1YABAAEAEj//f//////////////////
//////////////////////////////v/rAADAAAEAD7//v7//TAABAEAtv/7+/+aAAYACuH//Pz/ZgAE
AAQASP/9////////////////////////////////////////////////+/+sAAMAAAMAKvz//f//PwAE
AwCn//v7/6cABQAF2f/8/P9wAAQABABI//3/////////////////////////////////////////////
///7/6wAAwAAAwAh9f/9/v9JAAQDAKD/+/v/rgAEAALV//z8/3YABAAEAEj//f//////////////////
//////////////////////////////v/rAADAAADACH2//3+/0gABAMAoP/7+/+tAAQAAtX//Pz/dgAE
AAQASP/9////////////////////////////////////////////////+/+sAAMAAAMALP3//f//PgAE
AgCp//v7/6UABQAF2v/8/P9vAAQABABI//3/////////////////////////////////////////////
///7/6wAAwAABABC//7+//stAAMBALn/+/v/mAAGAAzj//z8/2QABAAEAEj//f//////////////////
//////////////////////////////v/rAADAAAFAGn/+/3/6RUAAwABz//8+v+DAAcAGO///P3/VAAE
AAQASP/9////////////////////////////////////////////////+/+sAAMAAAQAn//7/P/KAAAD
ABPo//37/2YACAAq/f/9//9AAAQABABI//3/////////////////////////////////////////////
///7/6wAAwACAAba//36/5sAAwMAMv7//v7/RAAIAET//v3/+ykAAwAEAEj//f//////////////////
//////////////////////////////v/rAADAAQARP///vz/WQAEBABj//39//YgAAcAaf/8/f/nEAAC
AAQASP/9////////////////////////////////////////////////+/+sAAMAAwCl//v9//QcAAMC
AJ7/+/z/1QMABQCV//r8/8sAAAEABABH//3/////////////////////////////////////////////
///7/6wAAgQAL/7//vv/rgACAgAJ3f/8+/+eAAMAAMb//Pv/oQADAAAEAEv//f//////////////////
//////////////////////////////v/rAADAQCv//v//f9NAAQEAED//v79/10ABwAc8P/++/9wAAUA
AAMANf/9+fv6+vr6+vr6+vr6+vr6+vv/////////////////////////+/+sAAYAN/////v/yQAAAQQA
mP/6/v/xHQAHAFT//f7//zoABAAAAQAApP////////////////////////7+////////////////////
///7/6wABwBV//n8+/9NAAQCABXs//37/7IAAgMAnP/7/P/hDAACAAAAAQACYI+LjIyMjIyMjIyMjIyM
jYar///8//////////////////////v/rAAFABfw////tAABAAQAdv/8//z/WAAGAArg//z7/6cAAgAA
AAAAAQAAAAAAAAAAAAAAAAAAAAAAAABw///7////////////////////+/+sAAIDAD7L5qcRAAICABDm
//38/+AJAAYATP/9/v3/WwAEAAAAAAAAAQQEBAQEBAQEBAQEBAQEBAQFAgBX/v/6////////////////
///7/6wAAwACAAAPAAACAAUAgv/6//v/gAAEAwCn//v+/+0YAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAABBAA16//5//////////////////v/rAADAAADAAACAgAEACj7//79/+kVAAUAJfj//vr/owADAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAh2P/6////////////////+/+sAAMAAAABAgAAAQAAvf/7
//r/eQAEBACL//v//f9HAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAKuv/7/v//////////
///7/6wAAwAAAAAAAAAEAHP/+//7/9sGAAQAG/H//fz/0QAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAABQAAoP///f////////////v/rAADAAAAAAAAAQAAyP/8//z/UAAEBACN//r//P9qAAQAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAfv//+///////////+/+sAAMAAAAAAAAAAgC2//b4
/58AAgQAKPr//vz/3QsAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgEAYf//+v//////
///7/6wAAwAAAAAAAAADADn1///MCQADAQC1//v/+/9oAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAQQAQ/X/+v////////v/rAADAAAAAAAAAAACACV4aAwAAgUAXv/8//z/1wMAAQAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAKN7/+v//////+/+sAAMAAAAAAAAAAAACAAAA
AAIDAB3y//3//f9QAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAE8j/+/7/
///7/6wAAwAAAAAAAAAAAAADBQUBAQAAvv/6//r/rgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAUAAqr//f3///v/qwADAAAAAAAAAAAAAAAAAAADAH//+v/8//AaAAMAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAIz///z/+/+uAAIAAAAAAAAAAAAAAAAA
AQAA0P/8//v/XwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAG7/
//n1/50ABAAAAAAAAAAAAAAAAAABAQC7//b5/54AAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAIDAE35///4MQADAAAAAAAAAAAAAAAAAAADADv1///BBAACAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEEACqNjiwAAgAAAAAAAAAAAAAAAAAA
AAACACJxXgcAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE
AAAAAAIAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAADBAQDAAAAAAAAAAAAAAAAAAAAAAAAAAADBQUBAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=='
  bm = (newBitmap 80 80)
  applyAlphaChannel bm (base64Decode data) (gray 90)
  return bm
}

defineClass MediaItem morph item menuButton

method item MediaItem { return item }

method intialize MediaItem imageOrSound menuIcon soundIcon {
  // scale = (global 'scale')
  morph = (newMorph this)
  item = imageOrSound
  addThumbnail this soundIcon
  addMenuButton this menuIcon
  addNameLine this
  addDetailsLine this
  return this
}

method addThumbnail MediaItem soundIcon {
  scale = (global 'scale')
  if (isClass item 'Sound') {
	if (isNil soundIcon) { return }
	thumbnail = soundIcon
  } else {
	thumbnail = (thumbnail item 80 80)
  }
  m = (newMorph)
  setCostume m thumbnail
  if (isClass item 'Sound') {
	setHandler m (new 'Trigger' m (action 'toggleSound' this))
	setTransparentTouch m true
  } (isClass item 'Bitmap') {
	setHandler m (new 'Trigger' m (action 'setImage' this))
	setTransparentTouch m true
  }
  if (scale != 2) { setScale m (scale / 2) }
  setPosition m (10 * scale) (10 * scale)
  addPart morph m
}

method addNameLine MediaItem {
  scale = (global 'scale')
  fontSize = (15 * scale)
  textBox = (newText (name item) 'Arial' fontSize)
  setEditRule textBox 'line'
  setPosition (morph textBox) (60 * scale) (14 * scale)
  addPart morph (morph textBox)
}

method addDetailsLine MediaItem {
  scale = (global 'scale')
  fontSize = (11 * scale)
  if (isClass item 'Bitmap') {
	byteCount = (byteCount (pixelData item))
	details = (join '' (width item) 'x' (height item))
  } (isClass item 'Sound') {
	byteCount = (4 * (count (samples item)))
	secs = ((count (samples item)) / (samplingRate item))
	details = (join (toString secs 2) ' seconds')
  } else {
	byteCount = 0
	details = ''
  }
  if (byteCount < 1000) {
	sizeString = (join '  (' byteCount ' bytes)')
  } else {
	sizeString = (join '  (' (round (byteCount / 1000)) ' kb)')
  }
  if (isClass item 'Sound') {
	rate = (truncate ((samplingRate item) / 1000))
	sizeString = (join sizeString ' ' rate 'k')
  }
  line1 = (newText (join details sizeString) 'Arial' fontSize)
  setEditRule line1 'static'
  setPosition (morph line1) (61 * scale) (32 * scale)
  addPart morph (morph line1)
}

// thumbnail click actions

method toggleSound MediaItem {
  if (not (isClass item 'Sound')) { return }
  mixer = (soundMixer (global 'page'))
  if (isPlaying mixer item) {
	removeSound mixer item
  } else {
	addSound mixer item
  }
}

method setImage MediaItem {
  if (not (isClass item 'Bitmap')) { return }
  editor = (projectEditor this)
  if (isNil editor) { return nil }
  scripter = (scripter editor)
  if (and (notNil scripter) (notNil (targetObj scripter))) {
	m = (morph (targetObj scripter))
	p = (rotationCenter m)
	penWasDown = (isPenDown m)
	if penWasDown { penUp m }
	setCostume m item
	placeRotationCenter m (first p) (last p)
	if penWasDown { penDown m }
  }
}

// menu

method addMenuButton MediaItem soundIcon {
  scale = (global 'scale')
  menuButton = (new 'Trigger' (newMorph) (action 'contextMenu' this))
  setHandler (morph menuButton) menuButton
  m = (morph menuButton)
  setTransparentTouch m true
  setCostume m soundIcon
  if (scale != 2) { setScale m (scale / 2) }
  setPosition m (200 * scale) (10 * scale)
  addPart morph m
}

method contextMenu MediaItem {
  menu = (menu nil this)
  if (isClass item 'Bitmap') {
  	addItem menu 'edit' 'editItem'
  }
  addItem menu 'export' 'export'
  addLine menu
  addItem menu 'delete' 'delete'
  popUpAtHand menu (global 'page')
}

method editItem MediaItem {
  editor = (projectEditor this)
  if (isNil editor) { return }
  if (isClass item 'Bitmap') {
	openPaintEditorOn item (action 'saveEditedImage' editor)
  }
}

method export MediaItem {
 if (isClass item 'Bitmap') {
	fName = (fileToWrite (name item) '.png')
	if ('' == fName) { return }

	ppi = (prompt (global 'page') 'Pixels per inch:' '100')
	if ('' == ppi) { ppi = '100' }

	data = (encodePNG item (toInteger ppi))
	if (not (endsWith fName '.png')) { fName = (join fName '.png') }
	writeFile fName data
  } (isClass item 'Sound') {
	fName = (fileToWrite (name item) '.wav')
	if ('' == fName) { return }

	if (not (endsWith fName '.wav')) { fName = (join fName '.wav') }
	writeFile fName (encodeWAV item)
  }
}

method delete MediaItem {
  editor = (projectEditor this)
  if (isNil editor) { return }
  if (isClass item 'Bitmap') { remove (images (project editor)) item }
  if (isClass item 'Sound') { remove (sounds (project editor)) item }
  refreshTab editor
}

method projectEditor MediaItem {
  editor = (ownerThatIsA morph 'ProjectEditor')
  if (isNil editor) { return nil }
  return (handler editor)
}

// layout

method setItemWidth MediaItem newWidth {
  // Set my bounds width and update my menu button position.
  // Called when MediaList layout changes.
  scale = (global 'scale')
  setExtent morph newWidth nil
  m = (morph menuButton)
  setPosition m ((right morph) - ((width m) + (18 * scale))) (top m)
}
// Morphic Menu handler

defineClass Menu morph label target items reverseCall selection returnFocus

to menu label target reverseCall returnFocus {
  if (isNil reverseCall) {reverseCall = false}
  return (new 'Menu' nil (localized label) target (list) reverseCall)
}

method addItemNonlocalized Menu itemLabel itemAction itemHint itemThumb {
  addItem this itemLabel itemAction itemHint itemThumb false
}

method addItem Menu itemLabel itemAction itemHint itemThumb localizeFlag {
  if (isNil itemAction) { itemAction = itemLabel }
  if (isNil localizeFlag) { localizeFlag = true }
  if (not (isAnyClass itemLabel 'Bitmap' 'String')) {
	itemLabel = (toString itemLabel)
  }
  if (and (isClass itemLabel 'String') localizeFlag) {
        itemLabel = (localized itemLabel)
  }
  add items (array itemLabel itemAction itemHint itemThumb)
}

method addLine Menu lineWidth {
  if (isNil lineWidth) {lineWidth = 1}
  if (lastItemIsLine this) { return }
  add items (array (array 0 lineWidth))
}

method lastItemIsLine Menu {
  if ((count items) == 0) { return true }
  lastItem = (last items)
  return (and (isClass lastItem 'Array') ((count lastItem) == 1) ((count (first lastItem)) == 2))
}

method popUp Menu page x y noFocus {
  if (or (isNil noFocus) (not (isClass noFocus 'Boolean'))) {noFocus = false}
  buildMorph this page y
  showMenu page this x y
  if (not noFocus) {focus this}
}

method popUpAtHand Menu page noFocus {
  popUp this page  (x (hand page)) (y (hand page)) noFocus
}

to popUpAtHand {
  // allows (context-) menus to be "nil"
  nop
}

method waitForSelection Menu {
	// Pop up menu and wait until a selection is made or menu is closed.

	page = (global 'page')
	popUpAtHand this page
	while (notNil (owner morph)) { doOneCycle page }
}

method rightClicked Menu {return true}

method itemLabel Menu labelPic thumbPic bgColor itemWidth itemPaddingH itemPaddingV {
  // private - answer a bitmap containg both the labelPic and the thumbPic
  if (and (isNil bgColor) (isNil thumbPic)) {return labelPic}
  if (isNil itemWidth) {itemWidth = 0}
  if (isNil itemPaddingH) {itemPaddingH = 0}
  if (isNil itemPaddingV) {itemPaddingV = 0}
  thWidth = 0
  thHeight = 0
  padding = 0
  if (notNil thumbPic) {
    thWidth = (width thumbPic)
    thHeight = (height thumbPic)
    padding = (* 3 (global 'scale'))
  }
  result = (newBitmap
    (max itemWidth (+ padding (width labelPic) thWidth))
    (+ (max (height labelPic) thHeight) (* 2 itemPaddingV))
  )
  if (notNil bgColor) {fill result bgColor}
  if (notNil thumbPic) {drawBitmap result thumbPic itemPaddingH (((height result) - thHeight) / 2)}
  drawBitmap result labelPic (+ padding thWidth itemPaddingH) (((height result) - (height labelPic)) / 2)
  return result
}

method buildMorph Menu page yPos {
  scale =  (global 'scale')

  // settings, to be refactored later to somewhere else
  labelFontName = 'Arial Bold'
  fontName = 'Arial'
  fontSize = (scale * 16)
  if ('Linux' == (platform)) { fontSize = (scale * 13) }
  border = (scale * 1)
  corner = (scale * 2)
  labelPadding = (scale * 4)
  itemPaddingV = (scale * 1)
  itemPaddingH = (scale * 3)
  color = (gray 255)
  labelTextColor = (gray 255)
  labelBackgroundColor = (gray 60)
  borderColor = labelBackgroundColor
  itemTextColorNormal = (gray 0)
  itemTextColorHighlighted = itemTextColorNormal
  itemTextColorPressed = (gray 255)
  itemBackgroundColorHighlighted = (gray 210)
  itemBackgroundColorPressed = (gray 100)

  minHeight = (min (scale * 100) (height (morph page)))
  maxHeight = ((height (morph page)) - 100)

  if (notNil morph) {destroy morph}

  // create raw label bitmap - lbl
  lbl = label
  if (isClass lbl 'String') {
    lbl = (stringImage lbl labelFontName fontSize labelTextColor 'center' (darker labelTextColor 80) nil nil nil nil labelBackgroundColor)
  }
  lblHeight = 0
  lblWidth = 0
  if (isClass lbl 'Bitmap') {
    lblHeight = (+ (height lbl) (* labelPadding 2))
    lblWidth = (width lbl)
  }
  menuWidth = (+ lblWidth (* labelPadding 2))
  menuHeight = lblHeight

  // measure item labels, determine menu dimensions
  itemLbls = (newArray (count items))
  for i (count items) {
    tuple = (at items i)
    itemLbl = (at tuple 1)
    itemThm = nil
    if (> (count tuple) 3) {itemThm = (at tuple 4)}
    if (isClass itemLbl 'String') {
      itemLbl = (stringImage itemLbl fontName fontSize itemTextColorNormal)
      itemLbl = (itemLabel this itemLbl itemThm)
      menuWidth = (max menuWidth (+ (width itemLbl) (* itemPaddingH 2)))
      menuHeight += (+ (height itemLbl) (* itemPaddingV 2))
    } (isClass itemLbl 'Bitmap') {
      itemLbl = (itemLabel this itemLbl itemThm)
      menuWidth = (max menuWidth (+ (width itemLbl) (* itemPaddingH 2)))
      menuHeight += (+ (height itemLbl) (* itemPaddingV 2))
    } (isClass itemLbl 'Array') {
      if ((at itemLbl 1) == 0) { // line
        menuHeight += (* scale (at itemLbl 2))
      }
    }
    atPut itemLbls i itemLbl
  }

  widgetHeight = (min menuHeight maxHeight)
  widgetWidth = menuWidth
  if (widgetHeight < menuHeight) {
    widgetWidth += (scale * 10) // slider thickness
  }

  // create the actual menu Morph
  morph = (newMorph this)
  bg = (newBitmap (+ widgetWidth border border) (+ widgetHeight border border))

  pen = (newShapeMaker bg)
  area = (rect 0 0 (width bg) (height bg))
  fillRoundedRect pen area corner borderColor 1 frameColor
  setWidth (bounds morph) (width bg)
  setHeight (bounds morph) (height bg)

  // create full label bitmap
  if (isClass lbl 'Bitmap') {
    fullLabel = (newBitmap widgetWidth lblHeight)
    fill fullLabel labelBackgroundColor
    x = (((width fullLabel) - (width lbl)) / 2)
    y = (((height fullLabel) - (height lbl)) / 2)
    drawBitmap fullLabel lbl x y

    // render full label on menu
    drawBitmap bg fullLabel border (+ border corner)
  } else {
    fullLabel = (rect)
  }
  y = (+ (height fullLabel) border)
  setCostume morph bg

  if (widgetHeight < menuHeight) {
    box = (newBox nil (transparent) 0 0 false false)
    container = (morph box)
    setExtent container menuWidth (menuHeight - lblHeight)
    scrollFrame = (scrollFrame box)
    setExtent (morph scrollFrame) widgetWidth (widgetHeight - lblHeight)
    setPosition (morph scrollFrame) border (+ (height fullLabel) border)
    addPart morph (morph scrollFrame)
    updateSliders scrollFrame
    setAlpha (morph (getField scrollFrame 'vSlider')) 255
    y = (top (morph box))
  } else {
    container = morph
  }

  // create and position actual menu items
  for i (count items) {
    tuple = (at items i)
    itemThm = nil
    if (> (count tuple) 3) {itemThm = (at tuple 4)}
    ilbl = (at itemLbls i)
    if (isClass ilbl 'Bitmap') {
      nbm = (itemLabel this ilbl nil color menuWidth itemPaddingH itemPaddingV)
      if (isClass (at tuple 1) 'String') {ilbl = (stringImage (at tuple 1) fontName fontSize itemTextColorHighlighted)}
      hbm = (itemLabel this ilbl itemThm itemBackgroundColorHighlighted menuWidth itemPaddingH itemPaddingV)
      if (isClass (at tuple 1) 'String') {ilbl = (stringImage (at tuple 1) fontName fontSize itemTextColorPressed)}
      pbm = (itemLabel this ilbl itemThm itemBackgroundColorPressed menuWidth itemPaddingH itemPaddingV)
      if reverseCall {
        itemAction = (action target (at tuple 2))
      } else {
        itemAction = (action (at tuple 2) target)
      }
      action = (array
        (action 'unfocus' this)
        (action 'destroy' morph)
        itemAction)
      item = (new 'Trigger' nil action nbm hbm pbm)
      setHint item (localized (at tuple 3))
      m = (newMorph item)
      setMorph item m
      normal item
      setWidth (bounds m) (width nbm)
      setHeight (bounds m) (height nbm)
      setTransparentTouch m true
      setPosition m border y
      addPart container m
        y += (height nbm)
    } (isClass ilbl 'Array') {
      if ((at ilbl 1) == 0) {
        y += (scale * (at ilbl 2))
      }
    }
  }
}

// keyboard accessibility hooks - experimental
// uses the 'selection' and 'returnFocus' fields

method focus Menu {
  page = (page morph)
//  if (notNil fallbackFocus) {
//    stopEditing (keyboard page)
//  }
  selectFirstItem this
  focusOn (keyboard page) this
}

method unfocus Menu {
  page = (global 'page')
  clearActiveMenu page
  if ((focus (keyboard page)) === this) {
      stopEditing (keyboard page)
  }
}

method destroyedMorph Menu {unfocus this}

method keyDown Menu evt keyboard {
  code = (at evt 'keycode')
  if (13 == code) { trigger this // enter
  } (27 == code) { cancel this // escape
  } (32 == code) { trigger this // space
  } (37 == code) { selectPreviousItem this // left arrow
  } (38 == code) { selectPreviousItem this // up arrow
  } (39 == code) { selectNextItem this // right arrow
  } (40 == code) { selectNextItem this // down arrow'
  }
}

method keyUp Menu evt keyboard {nop}

method textinput Menu evt keyboard {
  // to be used for keyboard shortcuts
  // char = (at evt 'text')
  // jumpTo this char
}

method triggers Menu {
  result = (list)
  for m (parts morph) {
    if (isClass (handler m) 'Trigger') {
      add result (handler m)
    } (isClass (handler m) 'ScrollFrame') {
      for p (parts (morph (contents (handler m)))) {
        if (isClass (handler p) 'Trigger') {
          add result (handler p)
        }
      }
    }
  }
  return result
}

method selectFirstItem Menu {
  triggers = (triggers this)
  if (notEmpty triggers) {select this (first triggers)}
}

method selectNextItem Menu {
  triggers = (triggers this)
  if (isEmpty triggers) { return }
  idx = (indexOf triggers selection)
  if (or (isNil idx) (idx >= (count triggers))) {
    sel = (first triggers)
  } else {
    sel = (at triggers (idx + 1))
  }
  select this sel
}

method selectPreviousItem Menu {
  triggers = (triggers this)
  if (isEmpty triggers) { return }
  idx = (indexOf triggers selection)
  if (isNil idx) {
    sel = (first triggers)
  } (idx <= 1) {
    sel = (last triggers)
  } else {
    sel = (at triggers (idx - 1))
  }
  select this sel
}

method select Menu trigger {
  if (notNil selection) {normal selection}
  selection = trigger
  highlight selection
  scrollIntoView (morph trigger)
}

method trigger Menu {
  if (isNil selection) {
    selectFirstItem this
  } else {
    trigger selection
  }
}

method cancel Menu {
  page = (page morph)
  unfocus this
  destroy morph
  if (notNil returnFocus) {
    focusOn (keyboard page) returnFocus
    redraw returnFocus
  }
}
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Copyright 2019 John Maloney, Bernat Romagosa, and Jens MÃ¶nig

defineClass MicroBitDisplaySlot morph display paintMode inset stride ledWidth ledHeight

to newMicroBitDisplaySlot anInteger {
	return (initialize (new 'MicroBitDisplaySlot') anInteger)
}

method initialize MicroBitDisplaySlot anInteger {
	morph = (newMorph this)
	setHandler morph this
	setGrabRule morph 'defer'
	setTransparentTouch morph true
	display = (newArray 25 false)
	inset = 0
	stride = 15
	ledWidth = 9
	ledHeight = 12
	if (notNil anInteger) { setContents this anInteger }
	redraw this
	return this
}

method contents MicroBitDisplaySlot {
	result = 0
	shift = 0
	for y 5 {
		for x 5 {
			index = ((5 * (y - 1)) + x)
			if (at display index) {
				result = (result | (1 << shift))
			}
			shift += 1
		}
	}
	return result
}

method setContents MicroBitDisplaySlot anInteger {
	fillArray display 0
	shift = 0
	for y 5 {
		for x 5 {
			val = ((anInteger & (1 << shift)) != 0)
			index = ((5 * (y - 1)) + x)
			atPut display index val
			shift += 1
		}
	}
	redraw this
	raise morph 'inputChanged' this
}

method redraw MicroBitDisplaySlot {
	scale = (blockScale)
	bgColor = (colorHSV 235 0.62 0.80)
	offColor = (colorHSV 235 0.62 0.40)
	onColor = (colorHSV 0 1.0 0.9)
	bm = (costumeData morph)
	if (isNil bm) { bm = (newBitmap (69 * scale) (72 * scale) bgColor) }
	for y 5 {
		for x 5 {
			index = ((5 * (y - 1)) + x)
			c = offColor
			if (at display index) { c = onColor }
			left = (inset + ((x - 1) * stride))
			top = (inset + ((y - 1) * (stride - 1)))
			fillRect bm c (left * scale) (top * scale) (ledWidth * scale) (ledHeight * scale)
		}
	}
	setCostume morph bm
}

// events

method handEnter MicroBitDisplaySlot aHand { setCursor 'crosshair' }
method handLeave MicroBitDisplaySlot aHand { setCursor 'default' }

method handDownOn MicroBitDisplaySlot aHand {
	// Start drawing on the LED display.

	setCursor 'crosshair'
	focusOn aHand this
	paintMode = true
	index = (ledIndex this aHand)
	if (notNil index) {
		paintMode = (not (at display index))
	}
	handMoveFocus this aHand
	return true
}

method handMoveFocus MicroBitDisplaySlot aHand {
	// Draw on the LED display as the mouse moves.

	index = (ledIndex this aHand)
	if (notNil index) {
		atPut display index paintMode
		redraw this
		raise morph 'inputChanged' this
		// xxx update underlying block
	}
	return true
}

method ledIndex MicroBitDisplaySlot aHand {
	// Return an array with the x,y pair of the LED under the hand.
	// Return nil if hand is not over any LED.

	scale = (blockScale)
	normalizedX = ((((x aHand) - (left morph)) / scale) - inset)
	normalizedY = ((((y aHand) - (top morph)) / scale) - inset)
	if (or (normalizedX < 0) (normalizedY < 0)) { return nil }
	if ((normalizedX % stride) >= ledWidth) { return nil }
	if ((normalizedY % stride) >= ledHeight) { return nil }

	col = (truncate (normalizedX / stride))
	row = (truncate (normalizedY / stride))
	if (or (col > 4) (row > 4)) { return nil }

	return (((row * 5) + col) + 1)
}
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Copyright 2019 John Maloney, Bernat Romagosa, and Jens MÃ¶nig

// MicroBlocksAppMaker.gp
// John Maloney, June 2018
//
// Build stand-alone MicroBlocks application.

defineClass MicroBlocksAppMaker

method buildApps MicroBlocksAppMaker {

	system = (detect (function each { return (isOneOf each 'win' 'linux32bit' 'linux64bit' 'raspberryPi' 'mac') }) (commandLine))
	embeddedFS = (createEmbeddedFS this system)

	if (notNil system) {
		if (system == 'win') { system = 'win.exe' }
		writeExeFile this (join 'gp-' system) embeddedFS (join '../apps/ublocks-' system)
		if (system == 'mac') {
			writeMacApp this 'gp-mac' embeddedFS '../apps'
		}
	} else {
		writeExeFile this 'gp-win.exe' embeddedFS '../apps/ublocks-win.exe'
		writeExeFile this 'gp-linux32bit' embeddedFS '../apps/ublocks-linux32bit'
		writeExeFile this 'gp-linux64bit' embeddedFS '../apps/ublocks-linux64bit'
		writeExeFile this 'gp-raspberryPi' embeddedFS '../apps/ublocks-raspberryPi'
		writeExeFile this 'gp-mac' embeddedFS '../apps/ublocks-mac'
		writeMacApp this 'gp-mac' embeddedFS '../apps'
	}
	print 'Done!'
}

method createEmbeddedFS MicroBlocksAppMaker system {
	// Return a ZipFile object containing the embedded file system.

	zip = (create (new 'ZipFile'))
	addVersionFileToEmbeddedFS this zip
	libDir = (join (directoryPart (appPath)) 'runtime/lib')
	addFolderToEmbeddedFS this libDir 'lib' zip
	addFolderToEmbeddedFS this '../ide' 'lib' zip // note: must add MicroBlocks ide after GP lib
	addFolderToEmbeddedFS this '../gp/Examples' 'Examples' zip
	addFolderToEmbeddedFS this '../gp/Libraries' 'Libraries' zip
	addFolderToEmbeddedFS this '../precompiled' 'precompiled' zip
	addFolderToEmbeddedFS this '../translations' 'translations' zip
	addFolderToEmbeddedFS this '../esp32' 'esp32' zip
	return zip
}

method addVersionFileToEmbeddedFS MicroBlocksAppMaker zip {
	fileName = 'versions'
	data = (readFile (join (directoryPart (appPath)) 'runtime/' fileName) true)
	if (notNil data) {
		addFile zip fileName data true
	}
}

method addFolderToEmbeddedFS MicroBlocksAppMaker srcFolder dstFolder zip {
	// Add the files from srcFolder to dstFilder in the given ZipFile object.

	dirs = (listDirectories srcFolder)
	for fn (listFiles srcFolder) {
		if (and (not (isOneOf fn '.DS_Store' '.' '..'))
				(not (contains dirs fn))
				(not (beginsWith fn '.'))) {
			data = (readFile (join srcFolder '/' fn) true)
			addFile zip (join dstFolder '/' fn) data true
		}
	}
	for fn dirs {
		if ('node_modules' != fn) {
			addFolderToEmbeddedFS this (join srcFolder '/' fn) (join dstFolder '/' fn) zip
		}
	}
}

method writeExeFile MicroBlocksAppMaker srcAppPath embeddedFS dstPath {
	// Create an executable file that combines the given GP virtual macine
	// with the given embedded file system (a ZipFile).

	print 'Writing' dstPath '...'
	appData = (readFile srcAppPath true)
	if (notNil embeddedFS) {
		writeFile dstPath (executableWithData this appData (contents embeddedFS))
	} else {
		writeFile dstPath appData
	}
	setFileMode dstPath (+ (7 << 6) (5 << 3) 5) // set executable bits
}

method executableWithData MicroBlocksAppMaker appData embeddedFSData {
	appEnd = (findAppEnd this appData)
	byteCount = (+ appEnd 4 (byteCount embeddedFSData))
	result = (newBinaryData byteCount)
	replaceByteRange result 1 appEnd appData
	replaceByteRange result (appEnd + 1) (appEnd + 4) 'GPFS'
	replaceByteRange result (appEnd + 5) byteCount embeddedFSData
	return result
}

method findAppEnd MicroBlocksAppMaker appData {
	// Return the index of 'GPFSPK\03\04'
	for i (byteCount appData) {
		if (and
			(71 == (byteAt appData i))
			(80 == (byteAt appData (i + 1)))
			(70 == (byteAt appData (i + 2)))
			(83 == (byteAt appData (i + 3)))
			(80 == (byteAt appData (i + 4)))
			(75 == (byteAt appData (i + 5)))
			( 3 == (byteAt appData (i + 6)))
			( 4 == (byteAt appData (i + 7)))) {
				return i
			}
	}
	return (byteCount appData)
}

// Macintosh App Creation

method writeMacApp MicroBlocksAppMaker srcAppPath embeddedFS dstPath {
	// Create a Mac application bundle that combines the given GP virtual macine
	// with the given embedded file system (a ZipFile).

	name = 'MicroBlocks'
	appName = (join dstPath '/' name '.app')
	makeDirectory appName
	makeDirectory (join appName '/Contents')
	makeDirectory (join appName '/Contents/MacOS')
	makeDirectory (join appName '/Contents/Resources')
	writeFile (join appName '/Contents/info.plist') (macInfoFile this name)
	writeExeFile this srcAppPath nil (join appName '/Contents/MacOS/' name)
	writeFile (join appName '/Contents/Resources/fs.data') (contents embeddedFS)
	writeFile (join appName '/Contents/Resources/MicroBlocks.icns') (readFile 'MicroBlocks.icns' true)
}

method macInfoFile MicroBlocksAppMaker name {
	return '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">

<dict>
	<key>CFBundleName</key>
	<string>MicroBlocks</string>
	<key>CFBundleExecutable</key>
	<string>MicroBlocks</string>
	<key>CFBundleIconFile</key>
	<string>MicroBlocks</string>

	<key>NSHighResolutionCapable</key><true/>

	<key>CFBundleIdentifier</key>
	<string>org.gpblocks.MicroBlocks</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>

	<key>CFBundleDocumentTypes</key>
	<array>
		<dict>
			<key>CFBundleTypeName</key>
			<string>MicroBlocks Project File</string>
			<key>LSHandlerRank</key>
			<string>Owner</string>
			<key>CFBundleTypeRole</key>
			<string>Editor</string>
			<key>LSItemContentTypes</key>
			<array>
				<!-- MicroBlocks specific extensions (see UTExportedTypeDeclarations) -->
			<string>org.gpblocks.gp.gpp</string>
			</array>
		</dict>

		<dict>
			<key>CFBundleTypeName</key>
			<string>Media File</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSHandlerRank</key>
			<string>Alternate</string>
			<key>LSItemContentTypes</key>
			<array>
				<string>public.data</string>
			</array>
		</dict>

	</array>

	<key>UTExportedTypeDeclarations</key>
	<array>
		<dict>
			<key>UTTypeIdentifier</key>
			<string>org.gpblocks.gp.gpp</string>
			<key>UTTypeDescription</key>
			<string>GP Project File</string>
			<key>UTTypeTagSpecification</key>
			<dict>
				<key>public.filename-extension</key>
				<string>gpp</string>
				<key>public.mime-type</key>
				<string>application/octet-stream</string>
			</dict>
			<key>UTTypeConformsTo</key>
			<array>
				<string>public.data</string>
			</array>
		</dict>
	</array>

</dict>
</plist>
'
}
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Copyright 2019 John Maloney, Bernat Romagosa, and Jens MÃ¶nig

// MicroBlocksCompiler.gp - A blocks compiler for microBlocks
// John Maloney, April, 2017

defineClass SmallCompiler opcodes argNames localVars trueObj falseObj zeroObj oneObj stringClassID

method initialize SmallCompiler {
	initOpcodes this
	argNames = (dictionary)
	localVars = (dictionary)
	falseObj = 0
	trueObj = 4
	zeroObj = ((0 << 1) | 1)
	oneObj = ((1 << 1) | 1)
	stringClassID = 4
	return this
}

method dumpTranslationTemplate SmallCompiler {
	result = (list)
	for item (microBlocksSpecs this) {
		if (isClass item 'Array') {
			add result (at item 3)
			add result (at item 3)
			add result ''
		}
	}
	writeFile 'microBlocksTranlationTemplate.txt' (joinStrings result (newline))
}

method microBlocksSpecs SmallCompiler {
	return (array
	'Output'
		(array ' ' 'setUserLED'			'set user LED _' 'bool' true)
		(array ' ' 'sayIt'				'say _ : _ : ...' 'auto auto auto auto auto auto auto auto auto auto' 123 '' '')
		(array ' ' 'printIt'			'graph _ : _ : ...' 'auto auto auto auto auto auto auto auto auto auto' 100)
	'Input'
		(array 'r' 'buttonA'			'button A')
		(array 'r' 'buttonB'			'button B')
		'-'
		(array 'r' 'timer'				'timer')
		(array ' ' 'resetTimer'			'reset timer')
		'-'
		(array 'r' 'millisOp'			'milliseconds')
		(array 'r' 'microsOp'			'microseconds')
		'-'
		(array 'r' 'boardType'				'board type')
		(array 'r' '[misc:connectedToIDE]'	'connected to IDE')
	'Pins'
		(array 'r' 'digitalReadOp'		'read digital pin _ : pullup _' 'num bool' 1 false)
		(array 'r' 'analogReadOp'		'read analog pin _ : pullup _' 'num bool' 1 false)
		'-'
		(array ' ' 'digitalWriteOp'		'set digital pin _ to _' 'num bool' 1 true)
		(array ' ' 'analogWriteOp'		'set pin _ to _' 'num num' 1 1023)
		'-'
		(array 'r' 'analogPins'			'analog pins')
		(array 'r' 'digitalPins'		'digital pins')
	'Comm'
		(array 'r' 'i2cGet'				'i2c get device _ register _' 'num num')
		(array ' ' 'i2cSet'				'i2c set device _ register _ to _' 'num num num')
		'-'
		(array ' ' '[sensors:i2cRead]'	'i2c device _ read list _' 'num auto')
		(array ' ' '[sensors:i2cWrite]'	'i2c device _ write list _ : stop _' 'num auto bool')
		'-'
		(array ' ' 'spiSend'				'spi send _' 'num' 0)
		(array 'r' 'spiRecv'				'spi receive')
		(array ' ' '[sensors:spiSetup]'		'spi setup speed _ : mode _ : rpi channel _ : bit order _' 'num num num str' 1000000 0 0 'MSB')
		(array ' ' '[sensors:spiExchange]'	'spi exchange bytes _' 'auto' 'aByteArray')
		'-'
		(array ' ' '[serial:open]'			'serial open _ baud' 'num' 9600)
		(array ' ' '[serial:close]'			'serial close')
		(array 'r' '[serial:read]'			'serial read')
		(array ' ' '[serial:write]'			'serial write _' 'auto' 'anIntegerStringListOrByteArray')
		(array 'r' '[serial:writeBytes]'	'serial write _ starting at _' 'auto num' 'aStringListOrByteArray' 1)
		'-'
		(array ' ' '[io:softWriteByte]'		'soft serial write byte _ pin _ baud _' 'num num num' '85' 2 9600)
	'Control'
		(array 'h' 'whenStarted'		'when started')
		(array 'h' 'whenButtonPressed'	'when button _ pressed' 'menu.buttonMenu' 'A')
		(array ' ' 'forever'			'forever _' 'cmd')
		(array ' ' 'repeat'				'repeat _ _' 'num cmd' 10)
		(array ' ' 'waitMillis'			'wait _ millisecs' 'num' 500)
		'-'
		(array ' ' 'if'					'if _ _ : else if _ _ : ...' 'bool cmd bool cmd')
		'-'
		(array 'h' 'whenCondition'		'when _' 'bool')
		(array ' ' 'waitUntil'			'wait until _' 'bool')
		'-'
		(array ' ' 'return'				'return _' 'auto' 0)
		'-'
		(array 'h' 'whenBroadcastReceived'	'when _ received' 'str.broadcastMenu' 'go!')
		(array ' ' 'sendBroadcast'		'broadcast _' 'str.broadcastMenu' 'go!' '')
		'-'
		(array ' ' 'comment'			'comment _' 'str' 'How this works...')
		(array 'r' '[data:range]'		'range _ to _ : by _' 'num num num' 1 10 2)
		(array ' ' 'for'				'for _ in _ _' 'var num cmd' 'i' 10)
		(array ' ' 'repeatUntil'		'repeat until _ _' 'bool cmd' false)
		'-'
		(array ' ' 'stopTask'			'stop this task')
		(array ' ' 'stopAll'			'stop other tasks')
	'Control-Advanced'
		(array ' ' 'waitMicros'			'wait _ microsecs' 'num' 1000)
		'-'
		(array 'r' 'getLastBroadcast'	'last message')
		(array 'r' 'argOrDefault'		'arg _ default _' 'num auto' 1 'default')
		'-'
		(array ' ' 'callCustomCommand'	'call _ : with _' 'str.functionNameMenu str' 'function name' 'parameter list')
		(array 'r' 'callCustomReporter'	'call _ : with _' 'str.functionNameMenu str' 'function name' 'parameter list')
	'Operators'
		(array 'r' '+'					'_ + _' 'num num' 10 2)
		(array 'r' '-'					'_ â _' 'num num' 10 2)
		(array 'r' '*'					'_ Ã _' 'num num' 10 2)
		(array 'r' '/'					'_ / _' 'num num' 10 2)
		(array 'r' '%'					'_ mod _' 'num num' 10 2)
		'-'
		(array 'r' 'absoluteValue'		'abs _ ' 'num' -10)
		(array 'r' 'minimum'			'min _ _ : _ : ...' 'num num num' 1 2)
		(array 'r' 'maximum'			'max _ _ : _ : ...' 'num num num' 1 2)
		(array 'r' 'random'				'random _ to _' 'num num' 1 10)
		'-'
		(array 'r' '<'					'_ < _' 'num num' 3 4)
		(array 'r' '<='					'_ <= _' 'num num' 3 4)
		(array 'r' '=='					'_ = _' 'auto auto' 3 4)
		(array 'r' '!='					'_ â  _' 'auto auto' 3 4)
		(array 'r' '>='					'_ >= _' 'num num' 3 4)
		(array 'r' '>'					'_ > _' 'num num' 3 4)
		'-'
		(array 'r' 'booleanConstant'	'_' 'bool' true)
		(array 'r' 'not'				'not _' 'bool' true)
		(array 'r' 'and'				'_ and _' 'bool bool' true false)
		(array 'r' 'or'					'_ or _ ' 'bool bool' true false)
		'-'
		(array 'r' 'isType'				'_ is a _' 'auto menu.typesMenu' 123 'number')
		(array 'r' '[data:convertType]'	'convert _ to _' 'auto menu.typesMenu' 123 'number')
	'Operators-Advanced'
		(array 'r' '[misc:rescale]'		'rescale _ from ( _ , _ ) to ( _ , _ )' 'num num num num num' 3 0 10 0 100)
		'-'
		(array 'r' 'hexToInt'			'hex _' 'str' '3F')
		'-'
		(array 'r' '&'					'_ & _' 'num num' 1 3)
		(array 'r' '|'					'_ | _' 'num num' 1 2)
		(array 'r' '^'					'_ ^ _' 'num num' 1 3)
		(array 'r' '~'					'~ _' 'num' 1 3)
		(array 'r' '<<'					'_ << _' 'num num' 3 2)
		(array 'r' '>>'					'_ >> _' 'num num' -100 2)
	'Variables'
		(array 'r' 'v'					'_' 'menu.allVarsMenu' 'n')
		(array ' ' '='					'set _ to _' 'menu.allVarsMenu auto' 'n' 0)
		(array ' ' '+='					'change _ by _' 'menu.allVarsMenu num' 'n' 1)
		(array ' ' 'local'				'initialize local _ to _' 'var auto' 'var' 0)
	'Data'
		(array 'r' 'at'					'item _ of _' 'auto.itemOfMenu str' 1 'Rosa')
		(array 'r' 'size'				'length of _' 'str' 'Rosa')
		(array 'r' '[data:join]'		'join _ _ : _ : ...' 'str str str' 'micro' 'blocks')
		'-'
		(array 'r' '[data:makeList]'	'list : _ : ...' 'auto auto auto' 'cat' 'dog' 'bird')
		(array ' ' '[data:addLast]'		'add _ to list _' 'auto auto' 'fish')
		'-'
		(array ' ' 'atPut'				'replace item _ of list _ with _' 'auto.replaceItemMenu str auto' 1 nil 10)
		(array ' ' '[data:delete]'		'delete item _ of list _' 'auto.replaceItemMenu str' 1)
		'-'
		(array 'r' '[data:find]'		'find _ in _ : starting at _' 'auto str num' 'a' 'cat' 1)
		(array 'r' '[data:copyFromTo]'	'copy _ from _ : to _' 'str num num' 'smiles' 2 5)
		(array 'r' '[data:split]'		'split _ by _' 'str str' 'A,B,C' ',')
	'Data-Advanced'
		(array 'r' '[data:joinStrings]'	'join items of list _ : separator _' 'auto str' nil ' ')
		'-'
		(array 'r' '[data:unicodeAt]'		'unicode _ of _' 'num str' 2 'cat')
		(array 'r' '[data:unicodeString]'	'string from unicode _' 'num' 65)
		'-'
		(array 'r' 'newList'				'new list length _ : with all _' 'num auto' 10 0)
		(array 'r' '[data:newByteArray]'	'new byte array _ : with all _' 'num num' 5 0)
		(array 'r' '[data:asByteArray]'		'as byte array _' 'auto' 'aByteListOrString')
		(array 'r' '[data:freeMemory]'		'free memory')

	// The following block specs allow primitives to be rendered correctly
	// even if the primitive spec was not included in the project or library.
	// This allows MicroBlocks to correctly render scripts in older projects.

	'Prims-Deprecated (not in palette)'
		(array 'r' 'newArray'				'new list length _' 'num' 10)
		(array ' ' 'fillArray'				'fill list _ with _' 'str auto' nil 0)
		(array ' ' 'fillList'				'fill list _ with _' 'str auto' nil 0)
	'Prims-Display (not in palette)'
		(array ' ' '[display:mbDisplay]'	'display _' 'microbitDisplay')
		(array ' ' '[display:mbDisplayOff]'	'clear display')
		(array ' ' '[display:mbPlot]'		'plot x _ y _' 'num num' 3 3)
		(array ' ' '[display:mbUnplot]'		'unplot x _ y _' 'num num' 3 3)
		(array ' ' '[display:mbDrawShape]'		'draw shape _ at x _ y _' 'num num num' 31 1 1)
		(array 'r' '[display:mbShapeForLetter]'	'shape for letter _' 'str' 'A')
		(array ' ' '[display:mbEnableDisplay]'	'enable LED display _' 'bool' false)
		(array ' ' '[display:neoPixelSetPin]'	'set NeoPixel pin _ is RGBW _' 'auto bool' '' false)
		(array ' ' '[display:neoPixelSend]'		'send NeoPixel rgb _' 'num' 5)
	'Prims-Sensing (not in palette)'
		(array 'r' '[sensors:acceleration]'	'acceleration')
		(array 'r' '[display:lightLevel]'	'light level')
		(array 'r' '[sensors:temperature]'	'temperature (Â°C)')
		(array 'r' '[sensors:tiltX]'		'tilt x')
		(array 'r' '[sensors:tiltY]'		'tilt y')
		(array 'r' '[sensors:tiltZ]'		'tilt z')
		(array 'r' '[sensors:microphone]'	'microphone')
		(array ' ' '[sensors:i2cSetClockSpeed]'	'set i2c clock speed _' 'num' 400000)
	'Prims-Variables (not in palette)'
		(array 'r' '[vars:varExists]'	'variable named _ exists?' 'str' 'var')
		(array 'r' '[vars:varNamed]'	'value of variable named _' 'str' 'var')
		(array ' ' '[vars:setVarNamed]'	'set variable named _ to _' 'str auto' 'var' 0)
	'Prims-JSON (not in palette)'
		(array 'r' '[misc:jsonGet]'		'json _ . _' 'str str' '{ "x": 1, "y": [41, 42, 43] }' 'y.2')
		(array 'r' '[misc:jsonCount]'	'json count _ . _' 'str str' '[1, [4, 5, 6, 7], 3]' '')
		(array 'r' '[misc:jsonValueAt]'	'json value _ . _ at _' 'str str num' '{ "x": 1, "y": 42 }' '' 2)
		(array 'r' '[misc:jsonKeyAt]'	'json key _ . _ at _' 'str str num' '{ "x": 1, "y": 42 }' '' 2)
	'Prims-Binary Data (not in palette)'
		(array 'r' '[misc:byteCount]'	'byte count _' 'str' 'binary data')
		(array 'r' '[misc:byteAt]'		'byte _ of _' 'num str' 1 'binary data')
	'Prims-Advanced (not in palette)'
		(array ' ' 'noop'				'no op')
		(array ' ' 'ignoreArgs'			'ignore : _ : ...' 'auto' 0)
		(array 'r' 'pushArgCount'		'arg count')
		(array 'r' 'getArg'				'arg _' 'num' 0)
		(array 'r' 'longMult'			'( _ * _ ) >> _' 'num num num' 1024 2048 10)
		(array 'r' '[misc:sin]'			'fixed sine _' 'num' 9000)
		(array 'r' '[misc:sqrt]'		'fixed sqrt _' 'num' 2)

		(array 'r' '[sensors:touchRead]' 'capacitive sensor _' 'num' 1)
		(array 'r' '[sensors:readDHT]'	'read DHT data pin _' 'num' 1)

		(array 'r' '[io:hasTone]'		'has tone support')
		(array ' ' '[io:playTone]'		'play tone pin _ frequency _' 'num num' 0 440)
		(array ' ' '[io:dacInit]'		'init DAC pin _ sample rate _' 'num num' 25 11025)
		(array 'r' '[io:dacWrite]'		'DAC write _ : starting at _' 'num num' 128 1)

		(array 'r' '[io:hasServo]'		'has servo support')
		(array ' ' '[io:setServo]'		'set servo pin _ to _ usecs' 'num num' 0 1500)

		(array 'r' '[net:hasWiFi]'		'has WiFi support')
		(array ' ' '[net:startWiFi]'	'start WiFi _ password _ : be hotspot _ : IP _ gateway _ subnet _' 'auto auto bool auto auto auto' 'SSID' 'MyPassword' true '192.168.1.42' '192.168.1.1' '255.255.255.0')
		(array ' ' '[net:stopWiFi]'		'stop WiFi')
		(array 'r' '[net:wifiStatus]'	'WiFi status')
		(array 'r' '[net:myIPAddress]'	'my IP address')
		(array 'r' '[net:myMAC]'		'my MAC address')

		(array 'r' '[net:startSSIDscan]'		'scan SSID list')
		(array 'r' '[net:getSSID]'				'get SSID number _' 'num' 1)

		(array ' ' '[net:httpConnect]'			'connect to httpÜ// _ : port _' 'auto num' 'microblocks.fun' 80)
		(array 'r' '[net:httpIsConnected]'		'is HTTP connected?')
		(array ' ' '[net:httpRequest]'			'_ request httpÜ// _ / _ : body _' 'menu.requestTypes auto auto str' 'GET' 'microblocks.fun' 'example.txt' '')
		(array 'r' '[net:httpResponse]'			'HTTP response')
		(array ' ' '[net:httpClose]'			'close HTTP connection')
		(array ' ' '[net:startHttpServer]'		'start HTTP server')
		(array ' ' '[net:stopHttpServer]'		'stop HTTP server')
		(array 'r' '[net:httpServerGetRequest]'	'HTTP server request : binary data _ : port _' 'bool num' false 8080)
		(array ' ' '[net:respondToHttpRequest]'	'respond _ to HTTP server request : with body _ : and headers _' 'auto str str' '200 OK' 'Welcome to the MicroBlocks HTTP server' 'Content-Type: text/plain')

		(array ' ' '[net:udpStart]'				'UDP start port _' 'auto' 5000)
		(array ' ' '[net:udpStop]'				'UDP stop')
		(array ' ' '[net:udpSendPacket]'		'UDP send packet _ to ip _ port _' 'auto auto num' 'Hello!' '255.255.255.255' 5000)
		(array 'r' '[net:udpReceivePacket]'		'UDP receive packet : binary data _' 'bool' false)
		(array 'r' '[net:udpRemoteIPAddress]'	'UDP remote IP address')
		(array 'r' '[net:udpRemotePort]'		'UDP remote port')

		(array ' ' '[tft:setBacklight]'		'set TFT backlight _ (0-10)' 'num' 10)
		(array ' ' '[tft:getWidth]'			'TFT width')
		(array ' ' '[tft:getHeight]'		'TFT height')
		(array ' ' '[tft:setPixel]'			'set TFT pixel x _ y _ to _' 'num num num' 50 32 16711680)
		(array ' ' '[tft:line]'				'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num num' 12 8 25 15 255)
		(array ' ' '[tft:rect]'				'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num num bool' 10 10 40 30 65280 false)
		(array ' ' '[tft:roundedRect]'		'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num num bool' 10 10 40 30 8 12255317 false)
		(array ' ' '[tft:circle]'			'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num num bool' 60 100 30 65535 false)
		(array ' ' '[tft:triangle]'			'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num num bool' 20 20 30 80 60 5 5592354 false)
		(array ' ' '[tft:text]'				'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num num num bool' 'Hello World!' 0 80 16777215 1 false)
		(array ' ' '[tft:deferUpdates]'		'defer TFT display updates')
		(array ' ' '[tft:resumeUpdates]'	'resume TFT display updates')

		(array ' ' '[tft:mergeBitmap]'		'mergeBitmap _ width _ buffer _ scale _ alphaIndex _ destX _ destY _' 'auto num auto num num num num')
		(array ' ' '[tft:drawBuffer]'		'drawBuffer _ palette _ scale _ : srcX _ srcY _ copyWidth _ copyHeight _' 'auto auto num num num num num')

		(array 'r' '[tft:tftTouched]'		'TFT touched')
		(array 'r' '[tft:tftTouchX]'		'TFT touch X position')
		(array 'r' '[tft:tftTouchY]'		'TFT touch Y position')
		(array 'r' '[tft:tftTouchPressure]'	'TFT touch pressure')

		(array ' ' '[file:open]'			'open file _' 'str')
		(array ' ' '[file:close]'			'close file _' 'str')
		(array ' ' '[file:delete]'			'delete file _' 'str')
		(array 'r' '[file:endOfFile]'		'end of file _' 'str')
		(array 'r' '[file:readLine]'		'next line of file _' 'str')
		(array 'r' '[file:readBytes]'		'next _ bytes of file _ : starting at _' 'num str num' 100 '' 0)
		(array 'r' '[file:readInto]'		'read into _ from file _' 'str str' 'a ByteArray' '')
		(array 'r' '[file:readPosition]'	'read position of file _' 'str')
		(array ' ' '[file:setReadPosition]'	'set read position _ of file _' 'num str')
		(array ' ' '[file:appendLine]'		'append line _ to file _' 'str str')
		(array ' ' '[file:appendBytes]'		'append bytes _ to file _' 'str str')
		(array 'r' '[file:fileSize]'		'size of file _' 'str')
		(array ' ' '[file:startList]'		'start file list _' 'str' 'dir')
		(array 'r' '[file:nextInList]'		'next file in list')
		(array 'r' '[file:systemInfo]'		'file system info')

		(array ' ' '[radio:sendInteger]'			'radio send number _' 'num' 123)
		(array ' ' '[radio:sendString]'				'radio send string _' 'str' 'Hello!')
		(array ' ' '[radio:sendPair]'				'radio send pair _ = _' 'str num' 'light' 10)
		(array 'r' '[radio:messageReceived]'		'radio message received?')
		(array 'r' '[radio:receivedInteger]'		'radio last number')
		(array 'r' '[radio:receivedString]'			'radio last string')
		(array 'r' '[radio:receivedMessageType]'	'radio last message type')
		(array ' ' '[radio:setGroup]'				'radio set group _' 'num' 0)
		(array ' ' '[radio:setChannel]'				'radio set channel (0-83) _' 'num' 7)
		(array ' ' '[radio:setPower]'				'radio set power (0-7) _' 'num' 4)
		(array 'r' '[radio:signalStrength]'			'radio last signal strength')
		(array 'r' '[radio:packetReceive]'			'radio receive packet _' 'str' '32-element list')
		(array ' ' '[radio:packetSend]'				'radio send packet _' 'str' '32-element list')
		(array ' ' '[radio:disableRadio]'			'disable radio')

		(array ' ' '[1wire:init]'			'oneWire init pin _' 'num' 0)
		(array ' ' '[1wire:scanStart]'		'oneWire scan start')
		(array 'r' '[1wire:scanNext]'		'oneWire scan next _' 'str' 'addressByteArray')
		(array ' ' '[1wire:select]'			'oneWire select address _' 'str' 'addressByteArray')
		(array ' ' '[1wire:selectAll]'		'oneWire select all')
		(array ' ' '[1wire:writeByte]'		'oneWire write byte _ : power _' 'num bool' 0 false)
		(array 'r' '[1wire:readByte]'		'oneWire read byte')
		(array 'r' '[1wire:crc8]'			'oneWire crc8 _ : byte count _' 'str num' 'aByteArray' 8)
		(array 'r' '[1wire:crc16]'			'oneWire crc16 _ : byte count _' 'str num' 'aByteArray' 8)
	)
}

method initMicroBlocksSpecs SmallCompiler {
	authoringSpecs = (authoringSpecs)
	if (isEmpty (specsFor authoringSpecs 'Output')) {
		clear authoringSpecs
		addSpecs authoringSpecs (microBlocksSpecs this)
	}
}

method opcodes SmallCompiler { return opcodes }

method initOpcodes SmallCompiler {
	// Initialize the opcode dictionary. Note: This must match the opcode table in interp.c!

	opcodeDefinitions = '
		halt 0
		noop 1
		pushImmediate 2		// true, false, and ints that fit in 24 bits
		pushBigImmediate 3	// ints that do not fit in 24 bits
		pushLiteral 4		// string or array constant from literals frame
		pushVar 5
		storeVar 6
		incrementVar 7
		pushArgCount 8
		pushArg 9
		storeArg 10
		incrementArg 11
		pushLocal 12
		storeLocal 13
		incrementLocal 14
		pop 15
		jmp 16
		jmpTrue 17
		jmpFalse 18
		decrementAndJmp 19
		callFunction 20
		returnResult 21
		waitMicros 22
		waitMillis 23
		sendBroadcast 24
		recvBroadcast 25
		stopAll 26
		forLoop 27
		initLocals 28
		getArg 29
		getLastBroadcast 30
		jmpOr 31
		jmpAnd 32
		minimum 33
		maximum 34
		< 35
		<= 36
		== 37
		!= 38
		>= 39
		> 40
		not 41
		+ 42
		- 43
		* 44
		/ 45
		% 46
		absoluteValue 47
		random 48
		hexToInt 49
		& 50
		| 51
		^ 52
		~ 53
		<< 54
		>> 55
		longMult 56
		isType 57
		waitUntil 58
		ignoreArgs 59
		newList 60
	RESERVED 61
		fillList 62
		at 63
		atPut 64
		size 65
	RESERVED 66
	RESERVED 67
	RESERVED 68
	RESERVED 69
		millisOp 70
		microsOp 71
		timer 72
		resetTimer 73
		sayIt 74
		printIt 75
		boardType 76
		comment 77
		argOrDefault 78
	RESERVED 79
		analogPins 80
		digitalPins 81
		analogReadOp 82
		analogWriteOp 83
		digitalReadOp 84
		digitalWriteOp 85
		digitalSet 86
		digitalClear 87
		buttonA 88
		buttonB 89
		setUserLED 90
		i2cSet 91
		i2cGet 92
		spiSend 93
		spiRecv 94
	RESERVED 95
	RESERVED 96
	RESERVED 97
	RESERVED 98
	RESERVED 99
	RESERVED 100
	RESERVED 101
	RESERVED 102
	RESERVED 103
	RESERVED 104
	RESERVED 105
	RESERVED 106
	RESERVED 107
	RESERVED 108
	RESERVED 109
	RESERVED 110
	RESERVED 111
	RESERVED 112
	RESERVED 113
	RESERVED 114
	RESERVED 115
	RESERVED 116
	RESERVED 117
	RESERVED 118
	RESERVED 119
	RESERVED 120
	RESERVED 121
	RESERVED 122
	RESERVED 123
		callCustomCommand 124
		callCustomReporter 125
		callCommandPrimitive 126
		callReporterPrimitive 127
		metadata 240'
	opcodes = (dictionary)
	for line (lines opcodeDefinitions) {
		words = (words line)
		if (and ((count words) > 1) ('RESERVED' != (first words))) {
			atPut opcodes (at words 1) (toInteger (at words 2))
		}
	}

	// renamed opcodes:
	atPut opcodes 'newArray' 60
	atPut opcodes 'fillArray' 62
}

// instruction generation: entry point

method instructionsFor SmallCompiler aBlockOrFunction {
	// Return a list of instructions for the given block, script, or function.
	// Add a 'halt' if needed and append any literals (e.g. strings) used.

	if (and (isClass aBlockOrFunction 'Block') (isPrototypeHat aBlockOrFunction)) {
		// function definition hat: get its function
		aBlockOrFunction = (function (editedPrototype aBlockOrFunction))
	}

	argNames = (dictionary)
	if (isClass aBlockOrFunction 'Function') {
		func = aBlockOrFunction
		for a (argNames func) {
			atPut argNames a (count argNames)
		}
		cmdOrReporter = (cmdList func)
		if (isNil cmdOrReporter) { // a function hat without any blocks
			cmdOrReporter = (newCommand 'noop')
		}
	} (or (isClass aBlockOrFunction 'Command') (isClass aBlockOrFunction 'Reporter')) {
		cmdOrReporter = aBlockOrFunction
	} else {
		cmdOrReporter = (expression aBlockOrFunction)
	}

	assignFunctionIDs (smallRuntime)
	collectVars this cmdOrReporter

	result = (list (array 'initLocals' (count localVars)))
	if (isClass cmdOrReporter 'Command') {
		op = (primName cmdOrReporter)
		if ('whenCondition' == op) {
			addAll result (instructionsForWhenCondition this cmdOrReporter)
		} ('whenButtonPressed' == op) {
			addAll result (instructionsForCmdList this (nextBlock cmdOrReporter))
			add result (array 'halt' 0)
		} ('whenStarted' == op) {
			addAll result (instructionsForCmdList this (nextBlock cmdOrReporter))
			add result (array 'halt' 0)
		} ('whenBroadcastReceived' == op) {
			addAll result (instructionsForExpression this (first (argList cmdOrReporter)))
			add result (array 'recvBroadcast' 1)
			addAll result (instructionsForCmdList this (nextBlock cmdOrReporter))
			add result (array 'halt' 0)
		} (isClass aBlockOrFunction 'Function') {
			if (or ('noop' != (primName cmdOrReporter)) (notNil (nextBlock cmdOrReporter))) {
				if (isEmpty (argNames func)) {
					add result (array 'pushLiteral' (functionName func))
					add result (array 'recvBroadcast' 1)
				}
				addAll result (instructionsForCmdList this cmdOrReporter)
			}
			add result (array 'pushImmediate' falseObj)
			add result (array 'returnResult' 0)
		} else {
			addAll result (instructionsForCmdList this cmdOrReporter)
			add result (array 'halt' 0)
		}
	} else {
		addAll result (instructionsForCmdList this (newReporter 'return' cmdOrReporter))
	}
	if (and
		((count result) == 2)
		(isOneOf (first (first result)) 'halt' 'stopAll')) {
			// In general, just looking at the final instructon isn't enough because
			// it could just be the end of a conditional body that is jumped
			// over; in that case, we need the final halt as the jump target.
			removeLast result // remove the final halt
	}
	appendLiterals this result
	appendDecompilerMetadata this aBlockOrFunction result
	return result
}

// instruction generation: when hat block

method instructionsForWhenCondition SmallCompiler cmdOrReporter {
	condition = (instructionsForExpression this (first (argList cmdOrReporter)))
	body = (instructionsForCmdList this (nextBlock cmdOrReporter))
	result = (list)

	// wait until condition becomes true
	addAll result (instructionsForExpression this 10)
	add result (array 'waitMillis' 1)
	addAll result condition
	add result (array 'jmpFalse' (0 - ((count condition) + 3)))

	addAll result body

	// loop back to condition test
	add result (array 'jmp' (0 - ((count result) + 1)))
	return result
}

// instruction generation: command lists and control structures

method instructionsForCmdList SmallCompiler cmdList {
	result = (list)
	cmd = cmdList
	while (notNil cmd) {
		addAll result (instructionsForCmd this cmd)
		cmd = (nextBlock cmd)
	}
	return result
}

method instructionsForCmd SmallCompiler cmd {
	result = (list)
	op = (primName cmd)
	args = (argList cmd)
	if (isOneOf op '=' 'local') {
		addAll result (instructionsForExpression this (at args 2))
		add result (setVar this (first args))
	} ('+=' == op) {
		addAll result (instructionsForExpression this (at args 2))
		add result (incrementVar this (first args))
	} ('return' == op) {
		if (0 == (count args)) {
			add result (array 'pushImmediate' zeroObj)
		} else {
			addAll result (instructionsForExpression this (at args 1))
		}
		add result (array 'returnResult' 0)
	} ('stopTask' == op) {
		add result (array 'halt' 0)
	} ('forever' == op) {
		return (instructionsForForever this args)
	} ('if' == op) {
		return (instructionsForIf this args)
	} ('repeat' == op) {
		return (instructionsForRepeat this args)
	} ('repeatUntil' == op) {
		return (instructionsForRepeatUntil this args)
	} ('waitUntil' == op) {
		return (instructionsForWaitUntil this args)
	} ('for' == op) {
		return (instructionsForForLoop this args)
	} (and ('digitalWriteOp' == op) (isClass (first args) 'Integer') (isClass (last args) 'Boolean')) {
		pinNum = ((first args) & 255)
		if (true == (last args)) {
			add result (array 'digitalSet' pinNum)
		} else {
			add result (array 'digitalClear' pinNum)
		}
		return result
	} ('sendBroadcastSimple' == op) {
		return (primitive this 'sendBroadcast' args true)
	} ('comment' == op) {
		// skip comments; do not generate any code
		// xxx remove this case later to store comments (once the VM supports them)
	} ('ignoreArgs' == op) {
		for arg args {
			addAll result (instructionsForExpression this arg)
		}
		add result (array 'ignoreArgs' (count args))
		return result
	} (isOneOf op 'callCustomCommand' 'callCustomReporter') {
		for arg args {
			addAll result (instructionsForExpression this arg)
		}
		add result (array op (count args))
		if ('callCustomCommand' == op) {
			add result (array 'pop' 1) // discard the return value
		}
		return result
	} (isFunctionCall this op) {
		return (instructionsForFunctionCall this op args true)
	} else {
		return (primitive this op args true)
	}
	return result
}

method instructionsForIf SmallCompiler args {
	result = (list)
	jumpsToFix = (list)
	i = 1
	while (i < (count args)) {
		finalCase = ((i + 2) >= (count args)) // true if this is the final case in the if statement
		test = (at args i)
		body = (instructionsForCmdList this (at args (i + 1)))
		if (or (true != test) (not finalCase) (i == 1)) {
			addAll result (instructionsForExpression this test)
			offset = (count body)
			if (not finalCase) { offset += 1 }
			add result (array 'jmpFalse' offset)
		}
		addAll result body
		if (not finalCase) {
			jumpToEnd = (array 'jmp' (count result)) // jump offset to be fixed later
			add jumpsToFix jumpToEnd
			add result jumpToEnd
		}
		i += 2
	}
	instructionCount = (count result)
	for jumpInstruction jumpsToFix {
		atPut jumpInstruction 2 (instructionCount - ((at jumpInstruction 2) + 1)) // fix jump offset
	}
	return result
}

method instructionsForForever SmallCompiler args {
	result = (instructionsForCmdList this (at args 1))
	add result (array 'jmp' (0 - ((count result) + 1)))
	return result
}

method instructionsForRepeat SmallCompiler args {
	result = (instructionsForExpression this (at args 1)) // loop count
	body = (instructionsForCmdList this (at args 2))
	add result (array 'jmp' (count body))
	addAll result body
	add result (array 'decrementAndJmp' (0 - ((count body) + 1)))
	return result
}

method instructionsForRepeatUntil SmallCompiler args {
	result = (list)
	conditionTest = (instructionsForExpression this (at args 1))
	body = (instructionsForCmdList this (at args 2))
	add result (array 'jmp' (count body))
	addAll result body
	addAll result conditionTest
	add result (array 'jmpFalse' (0 - (+ (count body) (count conditionTest) 1)))
	return result
}

method instructionsForWaitUntil SmallCompiler args {
	result = (list)
	conditionTest = (instructionsForExpression this (at args 1))
	addAll result conditionTest
	add result (array 'waitUntil' (0 - (+ (count conditionTest) 1)))
	return result
}

method instructionsForForLoop SmallCompiler args {
	result = (instructionsForExpression this (at args 2))
	loopVarIndex = (at localVars (first args))
	body = (instructionsForCmdList this (at args 3))
	addAll result (array
		(array 'pushImmediate' falseObj) // this will be N, the total loop count
		(array 'pushImmediate' falseObj) // this will be a decrementing loop counter
		(array 'jmp' (count body)))
	addAll result body
	addAll result (array
		(array 'forLoop' loopVarIndex)
		(array 'jmp' (0 - ((count body) + 2)))
		(array 'pop' 3))
	return result
}

// instruction generation: expressions

method instructionsForExpression SmallCompiler expr {
	// immediate values
	if (true == expr) {
		return (list (array 'pushImmediate' trueObj))
	} (false == expr) {
		return (list (array 'pushImmediate' falseObj))
	} (isNil expr) {
		return (list (array 'pushImmediate' zeroObj))
	} (isClass expr 'Integer') {
		if (and (-4194304 <= expr) (expr <= 4194303)) { // 23-bit encoded as 24 bit int object
			return (list (array 'pushImmediate' (((expr << 1) | 1) & (hex 'FFFFFF')) ))
		} else {
			// pushBigImmediate instruction followed by a 4-byte integer object
			return (list (array 'pushBigImmediate' 0) expr)
		}
	} (isClass expr 'String') {
		return (list (array 'pushLiteral' expr))
	} (isClass expr 'Float') {
		error 'Floats are not supported'
	} (isClass expr 'Color') {
		return (instructionsForExpression this (pixelRGB expr))
	}

	// expressions
	op = (primName expr)
	args = (argList expr)
	if ('v' == op) { // variable
		return (list (getVar this (first args)))
	} ('booleanConstant' == op) {
		if (first args) {
			return (list (array 'pushImmediate' trueObj))
		} else {
			return (list (array 'pushImmediate' falseObj))
		}
	} ('colorSwatch' == op) {
		c = (color (at args 1) (at args 2) (at args 3))
		return (instructionsForExpression this (pixelRGB c))
	} ('and' == op) {
		return (instructionsForAnd this args)
	} ('or' == op) {
		return (instructionsForOr this args)
	} (isFunctionCall this op) {
		return (instructionsForFunctionCall this op args false)
	} else {
		return (primitive this op args false)
	}
}

method instructionsForAnd SmallCompiler args {
	tests = (list)
	totalInstrCount = 0
	for expr args {
		instrList = (instructionsForExpression this expr)
		add tests instrList
		totalInstrCount += ((count instrList) + 1)
	}
	totalInstrCount += -1 // no jump required after final arg

	result = (list)
	for i (count tests) {
		addAll result (at tests i)
		if (i < (count tests)) {
			add result (array 'jmpAnd' (totalInstrCount - ((count result) + 1)))
		}
	}
	return result
}

method instructionsForOr SmallCompiler args {
	tests = (list)
	totalInstrCount = 0
	for expr args {
		instrList = (instructionsForExpression this expr)
		add tests instrList
		totalInstrCount += ((count instrList) + 1)
	}
	totalInstrCount += -1 // no jump required after final arg

	result = (list)
	for i (count tests) {
		addAll result (at tests i)
		if (i < (count tests)) {
			add result (array 'jmpOr' (totalInstrCount - ((count result) + 1)))
		}
	}
	return result
}

method instructionsForAndOLD SmallCompiler args { // xxx remove later
	tests = (list)
	totalInstrCount = 3 // final three instructions
	for expr args {
		instrList = (instructionsForExpression this expr)
		add tests instrList
		totalInstrCount += ((count instrList) + 1)
	}
	result = (list)
	for t tests {
		addAll result t
		add result (array 'jmpFalse' (totalInstrCount - ((count result) + 2)))
	}
	add result (array 'pushImmediate' trueObj) // all conditions were true: push result
	add result (array 'jmp' 1) // skip over false case
	add result (array 'pushImmediate' falseObj) // some condition was false: push result
	return result
}

method instructionsForOrOLD SmallCompiler args { // xxx remove later
	tests = (list)
	totalInstrCount = 3 // final three instructions
	for expr args {
		instrList = (instructionsForExpression this expr)
		add tests instrList
		totalInstrCount += ((count instrList) + 1)
	}
	result = (list)
	for t tests {
		addAll result t
		add result (array 'jmpTrue' (totalInstrCount - ((count result) + 2)))
	}
	add result (array 'pushImmediate' falseObj) // all conditions were false: push result
	add result (array 'jmp' 1) // skip over true case
	add result (array 'pushImmediate' trueObj) // some condition was true: push result
	return result
}

// instruction generation utility methods

method primitive SmallCompiler op args isCommand {
	result = (list)
	if ('print' == op) { op = 'printIt' }
	if (contains opcodes op) {
		for arg args {
			addAll result (instructionsForExpression this arg)
		}
		add result (array op (count args))
	} (and (beginsWith op '[') (endsWith op ']')) {
		// named primitives of the form '[primSetName:primName]'
		i = (findFirst op ':')
		if (notNil i) {
			primSetName = (substring op 2 (i - 1))
			primName = (substring op (i + 1) ((count op) - 1))
			add result (array 'pushLiteral' primSetName)
			add result (array 'pushLiteral' primName)
			for arg args {
				addAll result (instructionsForExpression this arg)
			}
			if isCommand {
				add result (array 'callCommandPrimitive' ((count args) + 2))
			} else {
				add result (array 'callReporterPrimitive' ((count args) + 2))
			}
		}
	} else {
		print 'Skipping unknown op:' op
		if (not isCommand) {
			add result (array 'pushImmediate' zeroObj) // missing reporter; push dummy result
		}
	}
	return result
}

// Variables

method collectVars SmallCompiler cmdOrReporter {
	sharedVars = (allVariableNames (project (scripter (smallRuntime))))

	localVars = (dictionary)
	todo = (list cmdOrReporter)
	while ((count todo) > 0) {
		cmd = (removeFirst todo)
		if (isOneOf (primName cmd) 'local' 'for') {
			// explicit local variables and 'for' loop indexes are always local
			varName = (first (argList cmd))
			if (contains argNames varName) {
				print 'Warning: Local variable overrides parameter:' varName
			}
			if (not (contains localVars varName)) {
				atPut localVars varName (count localVars)
			}
		} (isOneOf (primName cmd) 'v' '=' '+=') {
			// undeclared variables that are not global (shared) are treated as local
			varName = (first (argList cmd))
			if (not (or
				(contains sharedVars varName)
				(contains argNames varName)
				(contains localVars varName))) {
					atPut localVars varName (count localVars)
			}
		}
		for arg (argList cmd) {
			if (isAnyClass arg 'Command' 'Reporter') {
				add todo arg
			}
		}
		if (notNil (nextBlock cmd)) { add todo (nextBlock cmd) }
	}
}

method getVar SmallCompiler varName {
	if (notNil (at localVars varName)) {
		return (array 'pushLocal' (at localVars varName))
	} (notNil (at argNames varName)) {
		return (array 'pushArg' (at argNames varName))
	}
	globalID = (globalVarIndex this varName)
	if (notNil globalID) { return (array 'pushVar' globalID) }
}

method setVar SmallCompiler varName {
	if (notNil (at localVars varName)) {
		return (array 'storeLocal' (at localVars varName))
	} (notNil (at argNames varName)) {
		return (array 'storeArg' (at argNames varName))
	}
	globalID = (globalVarIndex this varName)
	if (notNil globalID) { return (array 'storeVar' globalID) }
}

method incrementVar SmallCompiler varName {
	if (notNil (at localVars varName)) {
		return (array 'incrementLocal' (at localVars varName))
	} (notNil (at argNames varName)) {
		return (array 'incrementArg' (at argNames varName))
	}
	globalID = (globalVarIndex this varName)
	if (notNil globalID) { return (array 'incrementVar' globalID) }
}

method globalVarIndex SmallCompiler varName {
	varNames = (allVariableNames (project (scripter (smallRuntime))))
	id = (indexOf varNames varName)
	if (isNil id) {
		error 'Unknown variable' varName
	}
	if (id >= 100) { error 'Id' id 'for variable' varName 'is out of range' }
	return (id - 1) // VM uses zero-based index
}

// function calls

method isFunctionCall SmallCompiler op {
	return (notNil (lookupChunkID (smallRuntime) op))
}

method instructionsForFunctionCall SmallCompiler op args isCmd {
	result = (list)
	callee = (lookupChunkID (smallRuntime) op)
	for arg args {
		addAll result (instructionsForExpression this arg)
	}
	add result (array 'callFunction' (((callee & 255) << 8) | ((count args) & 255)))
	if isCmd { add result (array 'pop' 1) } // discard the return value
	return result
}

// literal values (strings and large integers )

method appendLiterals SmallCompiler instructions {
	// For now, strings and integers too large for pushImmediate are the only literals.
	// Perhaps add support for constant literal arrays later.

	literals = (list)
	literalOffsets = (dictionary)
	nextOffset = (count instructions)
	for ip (count instructions) {
		instr = (at instructions ip)
		if (and (isClass instr 'Array') ('pushLiteral' == (first instr))) {
			literal = (at instr 2)
			litOffset = (at literalOffsets literal)
			if (isNil litOffset) {
				litOffset = nextOffset
				add literals literal
				atPut literalOffsets literal litOffset
				nextOffset += (wordsForLiteral this literal)
			}
			atPut instr 2 (litOffset - ip)
			atPut instructions ip (copyWith instr literal) // retain literal string for use by "show instructions"
		}
	}
	addAll instructions literals
}

method wordsForLiteral SmallCompiler literal {
	headerWords = 1
	if (isClass literal 'String') {
		return (headerWords + (floor (((byteCount literal) + 4) / 4)))
	}
	error 'Illegal literal type:' literal
}

// metadata for the deompiler

method appendDecompilerMetadata SmallCompiler aBlockOrFunction instructionList {
	// Append a tab-delimited list of local variables to instructionList.
	// This string is part of the optional metadata used by the decompiler.

	// the 'metadata' pseudo instruction marks the start of the decompiler meta data
	add instructionList (array 'metadata' 0)

	// add local variable names
	varNames = (list)
	for pair (sortedPairs localVars) {
		add varNames (copyReplacing (last pair)) '	' ' ' // replace tabs with spaces in var name
	}
	add instructionList (joinStrings varNames (string 9)) // tab delimited string

	// add function info
	if (isClass aBlockOrFunction 'Function') {
		add instructionList (metaInfoForFunction (project (scripter (smallRuntime))) aBlockOrFunction)
		argNames = (argNames aBlockOrFunction)
		if (notEmpty argNames) {
			add instructionList (joinStrings argNames (string 9)) // tab delimited string
		}
	}
}

// binary code generation

method addBytesForInstructionTo SmallCompiler instr bytes {
	// Append the bytes for the given instruction to bytes (little endian).

	opcode = (at opcodes (first instr))
	if (isNil opcode) { error 'Unknown opcode:' (first instr) }
	add bytes opcode
	arg = (at instr 2)
	if (not (and (-16777216 <= arg) (arg <= 16777215))) {
		error 'Argument does not fit in 24 bits'
	}
	add bytes (arg & 255)
	add bytes ((arg >> 8) & 255)
	add bytes ((arg >> 16) & 255)
}

method addBytesForIntegerLiteralTo SmallCompiler n bytes {
	// Append the bytes for the given integer to bytes (little endian).
	// Note: n is converted to a integer object, the equivalent of ((n << 1) | 1)

	add bytes (((n << 1) | 1) & 255)
	add bytes ((n >> 7) & 255)
	add bytes ((n >> 15) & 255)
	add bytes ((n >> 23) & 255)
}

method addBytesForStringLiteral SmallCompiler s bytes {
	// Append the bytes for the given string to bytes.

	byteCount = (byteCount s)
	wordCount = (floor ((byteCount + 4) / 4))
	headerWord = ((wordCount << 4) | stringClassID);
	repeat 4 { // add header bytes, little endian
		add bytes (headerWord & 255)
		headerWord = (headerWord >> 8)
	}
	for i byteCount {
		add bytes (byteAt s i)
	}
	repeat (4 - (byteCount % 4)) { // pad with zeros to next word boundary
		add bytes 0
	}
}
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// Copyright 2021 John Maloney, Bernat Romagosa, and Jens MÃ¶nig
//
// Display graph data

defineClass MicroBlocksDataGraph morph window zoomButtons lastDataIndex zeroAtBottom dataScale

to newMicroBlocksDataGraph { return (initialize (new 'MicroBlocksDataGraph')) }

method initialize MicroBlocksDataGraph {
	scale = (global 'scale')
	window = (window 'Data Graph')
	morph = (morph window)
	setHandler morph this
	setMinExtent morph (scale * 140) (scale * 50)
	setExtent morph (scale * 200) (scale * 120)
	addZoomButtons this
	lastDataIndex = 0
	zeroAtBottom = false
	dataScale = 1
	setFPS morph 20
	return this
}

method step MicroBlocksDataGraph {
	if ((lastDataIndex (smallRuntime)) == lastDataIndex) { return }
	lastDataIndex = (lastDataIndex (smallRuntime))
	changed morph
}

// zoom buttons

method addZoomButtons MicroBlocksDataGraph {
	editor = (first (allInstances 'MicroBlocksEditor')) // used editor to make buttons
	zoomButtons = (array
		(newZoomButton editor 'zoomIn' (action 'increaseGraphScale' this))
		(newZoomButton editor 'restoreZoom' (action 'normalGraphScale' this))
		(newZoomButton editor 'zoomOut' (action 'decreaseGraphScale' this)))
	for button zoomButtons {
		addPart morph (morph button)
	}
	fixZoomButtonsLayout this
}

method fixZoomButtonsLayout MicroBlocksDataGraph {
	right = ((right morph) - (12 * (global 'scale')))
	bottom = ((bottom morph) - (8 * (global 'scale')))
	for button zoomButtons {
		right = (right - (width (morph button)))
		setLeft (morph button) right
		setTop (morph button) ((bottom - (height (morph button))) - 5)
	}
}

method normalGraphScale MicroBlocksDataGraph {
	dataScale = 1
	changed morph
}

method graphScales MicroBlocksDataGraph {
	return (array 0.1 0.25 0.5 1 2 4 10 20 40 100 200)
}

method increaseGraphScale MicroBlocksDataGraph {
	// Magnify the data by decreasing the range of the graph.
	for newScale (reversed (graphScales this)) {
		if (newScale < dataScale) { // first entry less than current scale
			dataScale = newScale
			changed morph
			return
		}
	}
}

method decreaseGraphScale MicroBlocksDataGraph {
	// Shrink the data by increasing the range of graph.
	for newScale (graphScales this) {
		if (newScale > dataScale) { // first entry greater than current scale
			dataScale = newScale
			changed morph
			return
		}
	}
}

// drawing

method redraw MicroBlocksDataGraph {
	fixLayout window
	fixZoomButtonsLayout this
	changed morph
}

method graphArea MicroBlocksDataGraph {
	scale = (global 'scale')
	inset = (5 * scale)
	topInset = (24 * scale)
	left = ((left morph) + inset)
	top = ((top morph) + topInset)
	w = ((width morph) - (2 * inset))
	h = ((height morph) - (topInset + inset))
	return (rect left top w h)
}

method drawOn MicroBlocksDataGraph ctx {
  scale = (global 'scale')
  radius = (4 * scale)

  // draw window frame
  fillRoundedRect (getShapeMaker ctx) (bounds morph) radius (gray 80)

  // clear graph area
  bgColor = (gray 240)
  fillRoundedRect (getShapeMaker ctx) (graphArea this) radius bgColor

  // draw the data
  drawData this ctx
}

method drawData MicroBlocksDataGraph ctx {
	drawGrid this ctx
	colors = (list (color 200 0 0) (color 0 110 0) (color 0 0 200) (gray 30) (color 0 170 170) (color 180 0 180))
	sequences = (extractSequences this)
	for i (min (count sequences) (count colors)) {
		graphSequence this ctx (at sequences i) (at colors i)
	}
}

method extractSequences MicroBlocksDataGraph {
	loggedData = (loggedData (smallRuntime) (pointCount this))
	sequences = (list)
	for line loggedData {
		items = (splitWith line ' ')
		while ((count sequences) < (count items)) {
			add sequences (list)
		}
		for i (count items) {
			val = (at items i)
			if ('true' == val) {
				add (at sequences i) 100 // map true to 100 (useful for graphing digital pins)
			} ('false' == val) {
				add (at sequences i) 0 // map false to 0 (useful for graphing digital pins)
			} (representsANumber val) {
				add (at sequences i) (toNumber val)
			}
		}
	}
	return sequences
}

method leftInset MicroBlocksDataGraph { return (52 * (global 'scale')) }

method pointCount MicroBlocksDataGraph {
	// Return the number of data points that will fit the current window size.

	scale = (global 'scale')
	lineW = scale
	return (toInteger (((width (graphArea this)) - ((leftInset this) + lineW)) / lineW))
}

method graphSequence MicroBlocksDataGraph ctx seq aColor {
	if (isEmpty seq) { return }
	scale = (global 'scale')
	lineW = (2 * scale)
	yScale = (scale / dataScale)

	graphBnds = (graphArea this)
	graphBnds = (insetBy graphBnds (half lineW))
	right = (right graphBnds)
	top = (top graphBnds)
	bottom = (bottom graphBnds)
	if zeroAtBottom {
		yOrigin = (((top graphBnds) + (height graphBnds)) - (9 * scale))
	} else {
		yOrigin = ((top + (half (height graphBnds))) + 1)
	}

	lineW = scale
	pen = (pen (getShapeMaker ctx))
	x = ((left graphBnds) + (leftInset this))
	pointCount = (pointCount this)
	i = (max 1 ((count seq) - pointCount))
	isFirstPoint = true
	while (and (i < (count seq)) (x <= right)) {
		n = (at seq i)
		y = (yOrigin - (n * yScale))
		if (y < top) { y = top }
		if (y > bottom) { y = bottom }
		if isFirstPoint {
			beginPath pen x y
			isFirstPoint = false
		} else {
			goto pen x y
		}
		x += scale
		i += 1
	}
	stroke pen aColor lineW
}

method drawGrid MicroBlocksDataGraph ctx {
	scale = (global 'scale')
	lineW = scale
	yScale = (scale / dataScale)

	lineStep = (round (25 * dataScale))
	heavyLineStep = (4 * lineStep)
	if (0.5 == dataScale) { lineStep = 10; heavyLineStep = 50 }
	if (0.25 >= dataScale) { lineStep = 5;  heavyLineStep = 25 }

	graphBnds = (graphArea this)
	graphBnds = (insetBy graphBnds (half lineW))
	left = ((left graphBnds) + (leftInset this))
	right = (right graphBnds)

	if zeroAtBottom {
		yOrigin = (((top graphBnds) + (height graphBnds)) - (10 * scale))
		max = (((height graphBnds) - (16 * scale)) / yScale)
		for offset (range 0 max lineStep) {
			c = (gray 220)
			if ((offset % heavyLineStep) == 0) { c = (gray 190) } // darker lines for multiples of heavyLineStep
			y = (yOrigin - (offset * yScale))
			fillRect ctx c left y (right - left) lineW
			drawLabel this ctx (toString offset) left y
		}
	} else {
		yOrigin = ((top graphBnds) + (half (height graphBnds)))
		max = (((half (height graphBnds)) - 10) / yScale)
		for offset (range 0 max lineStep) {
			c = (gray 220)
			if ((offset % heavyLineStep) == 0) { c = (gray 190) } // darker lines for multiples of heavyLineStep
			y = (yOrigin - (offset * yScale))
			fillRect ctx c left y (right - left) lineW
			drawLabel this ctx (toString offset) left y
			y = (yOrigin + (offset * yScale))
			fillRect ctx c left y (right - left) lineW
			drawLabel this ctx (toString (- offset)) left y
		}
	}
}

method drawLabel MicroBlocksDataGraph ctx label left y {
	scale = (global 'scale')
	fontName = 'Arial'
	fontSize = (13 * scale)

	setFont ctx fontName fontSize
	x = (left - ((stringWidth label) + (7 * scale)))
	drawString ctx label (gray 100) x (y - (half (fontSize + scale)))
}

// context menu

method rightClicked MicroBlocksDataGraph aHand {
	popUpAtHand (contextMenu this) (global 'page')
	return true
}

method contextMenu MicroBlocksDataGraph {
	menu = (menu 'Graph' this)
	addItem menu 'clear graph' 'clearGraph'
	addLine menu
	if zeroAtBottom {
		addItem menu 'zero in middle' 'toggleZeroAtBottom'
	} else {
		addItem menu 'zero at bottom' 'toggleZeroAtBottom'
	}
	addLine menu
	addItem menu 'export data to CSV file' 'exportData'
	addItem menu 'import data from CSV file' 'importData'
	if (devMode) {
		addItem menu 'copy graph data to clipboard' 'copyDataToClipboard'
		addLine menu
		addItem menu 'set serial delay' (action 'serialDelayMenu' (smallRuntime))
	}
	return menu
}

method clearGraph MicroBlocksDataGraph {
	clearLoggedData (smallRuntime)
}

method toggleZeroAtBottom MicroBlocksDataGraph {
	zeroAtBottom = (not zeroAtBottom)
	redraw this
}

method exportData MicroBlocksDataGraph {
	// collect data as .csv entries
	result = (list)
	for entry (loggedData (smallRuntime)) {
		csvLine = (list)
		items = (splitWith entry ' ')
		for i (count items) {
			val = (at items i)
			if ('false' == val) {
				add csvLine '0' // map false to 0 (useful for graphing digital pins)
			} ('true' == val) {
				add csvLine '100' // map true to 100 (useful for graphing digital pins)
			} (representsANumber val) {
				add csvLine (toString (toNumber val))
			} else {
				add csvLine val
			}
			if (i < (count items)) { add csvLine ', ' }
		}
		add result (joinStrings csvLine)
	}
	data = (joinStrings result (newline))

	if ('Browser' == (platform)) {
		browserWriteFile data 'data.csv' 'graphData'
		return
	}

	fileName = (fileToWrite 'data')
	if (isEmpty fileName) { return }
	if (not (endsWith fileName '.csv' )) { fileName = (join fileName '.csv') }
	writeFile fileName data
}

method importData MicroBlocksDataGraph {
	pickFileToOpen (action 'importDataFromCSVFile' this) (gpFolder) (array '.csv' '.txt')
}

method importDataFromCSVFile MicroBlocksDataGraph fileName {
	data = (readFile fileName)
	if (isNil data) { return } // could not read file
	data = (joinStrings (splitWith data ',')) // remove commas
	clearLoggedData (smallRuntime)
	for entry (lines data) { addLoggedData (smallRuntime) entry }
}

method copyDataToClipboard MicroBlocksDataGraph {
  data = (loggedData (smallRuntime))
  setClipboard (joinStrings data (newline))
}

method showRecentData MicroBlocksDataGraph {
  data = (loggedData (smallRuntime) 100) // get the most recent 100 entries
  ws = (openWorkspace (global 'page') (joinStrings data (newline)))
  setTitle ws 'Recent Data'
  setFont ws 'Arial' (16 * (global 'scale'))
}
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Copyright 2019 John Maloney, Bernat Romagosa, and Jens MÃ¶nig

// MicroBlocksDecompiler.gp - Decompiles bytecodes back to scripts and functions
// John Maloney, March, 2020

// To do:
// [x] make compiler store local variable names
// [x] make compiler store function spec and parameter names
// [x] make decompiler read and use local names
// [x] make decompiler read and use parameter names
// [x] make decompiler use function spec
// [ ] store comments (separately from scripts)

defineClass MicroBlocksDecompiler chunks vars funcs module reporters opcodes controlStructures code stack msgName localNames argNames functionInfo

to newDecompiler {
	return (initialize (new 'MicroBlocksDecompiler'))
}

method initialize MicroBlocksDecompiler {
	chunks = (list) // list of (chunkID, chunkType, chunkData)
	vars = (dictionary) // global var ID -> name
	funcs = (dictionary) // chunk ID -> function name
	return this
}

// Testing

to decompileBytecodes chunkID chunkType chunkData {
	// For testing...
	decompiler = (newDecompiler)
	addNamesFromRuntime decompiler chunkID chunkType chunkData
	return (decompile decompiler chunkID chunkType chunkData)
}

method addNamesFromRuntime MicroBlocksDecompiler {
	// For testing. Add var and fuction names from current project.

	initialize this

	allVars = (allVariableNames (project (scripter (smallRuntime))))
	for i (count allVars) {
		atPut vars (i - 1) (at allVars i)
	}
	for pair (sortedPairs (getField (smallRuntime) 'chunkIDs')) {
		fName = (last pair)
		if (isClass fName 'String') {
			chunkID = (first (first pair))
			atPut funcs chunkID fName
		}
	}
}

// Collecting vars and chunks

method addChunk MicroBlocksDecompiler chunkID chunkType chunkData {
	add chunks (array chunkID chunkType chunkData)
}

method addVar MicroBlocksDecompiler varID varName {
	atPut vars varID varName
}

method decompileProject MicroBlocksDecompiler {
	// Return the decompiled project.
	// Called after collecting chunks and var names from the board.

	project = (newMicroBlocksProject)
	module = (main project)
	for varName (values vars) { addVariable module varName }

	// pass 1: assign function names
	for chunk chunks {
		chunkID = (at chunk 1)
		chunkType = (at chunk 2)
		chunkData = (at chunk 3)
		if (3 == chunkType) {
			atPut funcs chunkID (nameForFunction this chunkID chunkData)
		}
	}

	// pass 2: generate code and add functions and scripts in new project module
	scripts = (list)
	for chunk chunks {
		chunkID = (at chunk 1)
		chunkType = (at chunk 2)
		chunkData = (at chunk 3)
		gpCode = (decompile this chunkID chunkType chunkData)
		if (isClass gpCode 'Function') {
			addFunctionToProject this gpCode chunkID project
		} ('comment' == (primName gpCode)) {
			// ignore stand-alone comments
		} else {
			add scripts (array (rand 50 400) (rand 50 300) gpCode)
		}
	}
	setScripts module scripts

	updatePrimitives project
	fixFunctionLocals project

	return project
}

method addFunctionToProject MicroBlocksDecompiler aFunc chunkID project {
	funcName = (functionName aFunc)
	targetLib = module

	if ((count functionInfo) >= 6) { // use function info if available
		// set the target library for this function
		libName = (at functionInfo 1)
		libCat = (at functionInfo 2)
		if (libName != '') {
			if (isNil (libraryNamed project libName)) { // create library module
				targetLib = (newMicroBlocksModule libName)
				setField targetLib 'moduleCategory' libCat
				setVersion targetLib (array 0 0) // unknown version
				addLibrary project targetLib
			}
			targetLib = (libraryNamed project libName)
		}

		 // create blockspec from function info
		blockType = (at functionInfo 3)
		specString = (at functionInfo 5)
		typeString = (at functionInfo 6)
		defaults = (list)
		spec = (blockSpecFromStrings funcName blockType specString typeString defaults)
	} else { // no function info, so generate a blockspec
		specString = funcName
		typeString = ''
		defaults = (list)
		for argName (argNames aFunc) {
			specString = (join specString ' _')
			typeString = (join typeString ' auto')
		}
		spec = (blockSpecFromStrings funcName ' ' specString typeString defaults)
	}

	// add the function and its blockspec
	addFunction targetLib aFunc
	add (blockList targetLib) funcName
	recordBlockSpec project funcName spec
}

method nameForFunction MicroBlocksDecompiler chunkID chunkData {
	// If the function has a recvBroadcast opcode (i.e. it has no arguments)
	// then use that as the function name. Otherwise, generate a name based on chunkID.

	fName = (extractFunctionName this chunkData)
	if (isNil fName) { fName = (join 'func' chunkID) }
	return fName
}

method extractFunctionName MicroBlocksDecompiler chunkData {
	extractOpcodes this chunkData
	if (and ((count opcodes) >= 3)
			('recvBroadcast' == (cmdOp this (at opcodes 3)))
			('pushLiteral' == (cmdOp this (at opcodes 2)))) {
				return (cmdArg this (at opcodes 2))
	}
	if ((count functionInfo) > 3) { return (at functionInfo 4) }
	return nil
}

// Decompiling

method decompile MicroBlocksDecompiler chunkID chunkType chunkData {
	// Approach:
	//	0. Convert chunkData into sequence of opcode tuples
	//	1. find and replace loops
	//	2. find and replace if's (recursively)
	//	3. walk the entire tree and generate code

	extractOpcodes this chunkData
	controlStructures = (newArray (count opcodes))
	findLoops this
	findIfs this
	fixLocals this

	printChunkInfo = false
	if printChunkInfo {
		fName = ''
		if (3 == chunkType) { fName = (at funcs chunkID 'unknown function') }
		print 'decompiling' chunkID chunkType fName
	}

	debug = false
	if debug {
		print '----'
		printSequence2 this
		print '----'
		printSequence3 this 1 (count opcodes) 0
		print '----'
	}

	if (cmdIs this (last opcodes) 'halt' 0) { removeLast opcodes }  // remove final halt
	gpCode = (codeForSequence this 1 (count opcodes))
	gpCode = (removePrefix this gpCode)
	if (3 == chunkType) { gpCode = (removeFinalReturn this gpCode) }
	gpCode = (addHatBlock this chunkID chunkType gpCode)
	if (isNil gpCode) {
		return (newCommand 'comment' 'Stand-alone comment')
	}
	fixBooleanAndColorArgs this gpCode
	if debug { print (prettyPrint this gpCode) }
	return gpCode
}

method extractOpcodes MicroBlocksDecompiler chunkData {
	opcodes = (list)
	msgName = nil
	for i (range 1 (count chunkData) 4) {
		op = (at chunkData i)
		arg = (+
			((at chunkData (i + 3)) << 16)
			((at chunkData (i + 2)) << 8)
			 (at chunkData (i + 1)))
		arg = ((arg << 7) >> 7) // shift to sign-extend arg
		addr = (floor ((i + 3) / 4))
		add opcodes (array addr op arg)
	}
	lastInstruction = (readLiteralStrings this)
	hasMetadata = (readDecompilerMetadata this lastInstruction)
	opcodes = (copyFromTo opcodes 1 lastInstruction)
	getOpNames this
	decodeImmediates this
	if (not hasMetadata) { findArgs this } // no metadata; generate argument names if needed
}

method removePrefix MicroBlocksDecompiler gpCode {
	// Remove possible recvBroadcast prefix from parameterless functions and broadcast hats.

	if (isNil gpCode) { return }

	if ('recvBroadcast' == (primName gpCode)) {
		// remove 'recvBroadcast' from a parameterless function
		msgName = (first (argList gpCode)) // record the message name
		gpCode = (nextBlock gpCode)
	}
	return gpCode
}

method removeFinalReturn MicroBlocksDecompiler gpCode {
	// Return possible final 'return false' from the code for a function.

	if (isNil gpCode) { return nil }

	// find the last two commands:
	lastCmd = gpCode
	while (notNil (nextBlock lastCmd)) {
		nextToLastCmd = lastCmd
		lastCmd = (nextBlock lastCmd)
	}

	// if the last command is a 'return false', remove it
	if (and ('return' == (primName lastCmd)) (false == (first (argList lastCmd)))) {
		if (gpCode == lastCmd) { return nil } // the return was the only command
		setField nextToLastCmd 'nextBlock' nil
	}
	return gpCode
}

// Command tuple operations

method cmdOp MicroBlocksDecompiler cmd { return (at cmd 2) }
method cmdArg MicroBlocksDecompiler cmd { return (at cmd 3) }

method jumpTarget MicroBlocksDecompiler jmpCmd {
	// Return the target index of the given jump command.

	return (+ (at jmpCmd 1) (cmdArg this jmpCmd) 1)
}

method cmdIs MicroBlocksDecompiler cmd op arg {
	// Return true of the given command has the given op and argument.

	return (and (notNil cmd) (op == (at cmd 2)) (arg == (at cmd 3)))
}

// Debugging

method printSequence2 MicroBlocksDecompiler {
	for i (count controlStructures) {
		cmd = (at opcodes i)
		line = (join '' i ': ' (cmdOp this cmd) ' ' (cmdArg this cmd))
		cntr = (at controlStructures i)
		if (notNil cntr) { line = (join line ' ' cntr) }
		print line
	}
}

method printSequence3 MicroBlocksDecompiler start end indent {
	spaces = (joinStrings (newArray indent ' '))
	i = start
	while (i <= end) {
		ctrl = (at controlStructures i)
		atPut controlStructures i nil // avoid infinite recursion on 'forever' and 'waitUntil'
		if (notNil ctrl) {
			op = (first ctrl)
			if ('if' == op) {
				print (join spaces op)
				printSequence3 this (at ctrl 3) (at ctrl 4) (indent + 4)
			} ('if-else' == op) {
				print (join spaces op)
				printSequence3 this (at ctrl 3) (at ctrl 4) (indent + 4)
				print (join spaces 'else')
				printSequence3 this (at ctrl 5) (at ctrl 6) (indent + 4)
			} (isOneOf op 'for' 'forever' 'repeat') {
				print (join spaces op)
				printSequence3 this (at ctrl 3) (at ctrl 4) (indent + 4)
			} ('repeatUntil' == op) {
				print (join spaces 'until')
				printSequence3 this (at ctrl 3) (at ctrl 4) (indent + 4)
				print (join spaces 'do')
				printSequence3 this (at ctrl 5) (at ctrl 6) (indent + 4)
			} ('waitUntil' == op) {
				print (join spaces 'wait until')
				printSequence3 this (at ctrl 3) (at ctrl 4) (indent + 4)
			} ('whenCondition' == op) {
				print 'when:'
				printSequence3 this (at ctrl 3) (at ctrl 4) (indent + 4)
				print 'then:'
				printSequence3 this (at ctrl 5) (at ctrl 6) (indent + 4)
 			} else {
 				print (join spaces op)
			}
			atPut controlStructures i ctrl // restore ctrl to controlStructure
			i = ((at ctrl 2) + 1)
		} else {
			cmd = (at opcodes i)
			print (join spaces (cmdOp this cmd) ' ' (cmdArg this cmd))
			i += 1
		}
	}
}

method prettyPrint MicroBlocksDecompiler expression {
	// Used during debugging to print the GP code output of the decompiler.

	pp = (new 'PrettyPrinter')
	if (isClass expression 'Reporter') {
		if (isOneOf (primName expression) 'v') {
			return (join '(v ' (first (argList expression)) ')')
		} else {
			return (join '(' (prettyPrint pp expression) ')')
		}
	} (isClass expression 'Function') {
		return (prettyPrintFunction pp expression)
	} else {
		return (prettyPrintList pp expression)
	}
	return '???' // should not get here
}

// Helper methods

method readLiteralStrings MicroBlocksDecompiler {
	// Replace offsets in 'pushLiteral' instructions with the actual literal strings.
	// Return the index of the last instruction in opcodes.

	result = (count opcodes)
	for i (count opcodes) {
		if (i > result) { return result }
		instr = (at opcodes i)
		if (240 == (cmdOp this instr)) { return (i - 1) } // pseudo opcode that marks start of metadata
		if (4 == (cmdOp this instr)) { // pushLiteralOpcode
			literalIndex = (+ i (cmdArg this instr) 1)
			if (literalIndex <= result) {
				result = (literalIndex - 1)
			}
			literalString = (readLiteral this literalIndex)
			atPut instr 3 literalString // insert the literal into instruction
			litWords = (floor (((byteCount literalString) + 3) / 4))
		}
	}
	return result
}

method readLiteral MicroBlocksDecompiler literalIndex {
	// Return the literal string starting at the given index in the opcode list.

	header = (at opcodes literalIndex)
	lowByte = (at header 2)
	if (4 != (lowByte & 15)) {
		print 'bad string literal (should not happen)'
		return ''
	}
	highBytes = (at header 3)
	wordCount = ((highBytes << 4) | (lowByte >> 4))
	bytes = (list)
	for i (range (literalIndex + 1) (literalIndex + wordCount)) {
		instr = (at opcodes i)
		add bytes (at instr 2)
		highBytes = (at instr 3)
		add bytes (highBytes & 255)
		add bytes ((highBytes >> 8) & 255)
		add bytes ((highBytes >> 16) & 255)
	}
	while (and (notEmpty bytes) (0 == (last bytes))) {
		removeLast bytes // remove trailing zero bytes
	}
	return (callWith 'string' (toArray bytes))
}

method readDecompilerMetadata MicroBlocksDecompiler lastInstruction {
	// Read decompiler metadata, if any, and return true if found.

	localNames = (array)
	argNames = (array)
	functionInfo = (array)

	end = (count opcodes)
	i = lastInstruction
	while (240 != (cmdOp this (at opcodes i))) {
		i += 1
		if (i > end) { return false } // no meta information
	}
	i += 1 // skip the meta info marker (opcode 240)
	if (i < end) {
		s = (readLiteral this i)
		localNames = (splitWith s (string 9))
		i += ((floor ((byteCount s) / 4)) + 2)
	}
	if (i < end) {
		s = (readLiteral this i)
		functionInfo = (splitWith s (string 9))
		i += ((floor ((byteCount s) / 4)) + 2)
	}
	if (i < end) {
		s = (readLiteral this i)
		argNames = (splitWith s (string 9))
		i += ((floor ((byteCount s) / 4)) + 2)
	}
	return true
}

method findArgs MicroBlocksDecompiler {
	maxArgIndex = -1
	for cmd opcodes {
		if (isOneOf (cmdOp this cmd) 'pushArg' 'storeArg' 'incrementArg') {
			argIndex = (cmdArg this cmd)
			if (argIndex > maxArgIndex) { maxArgIndex = argIndex }
		}
	}
	argNames = (list)
	i = 0
	while (i <= maxArgIndex) {
		add argNames (join 'A' (i + 1))
		i += 1
	}
}

method getOpNames MicroBlocksDecompiler {
	// Replace the numerical opcode of each opcode entry with its name except
	// for entries immediately following a pushBigImmediate instruction, which
	// are inline integer constants.

	opcodeDefs = (opcodes (initialize (new 'SmallCompiler')))
	opcodeToName = (range 0 255)
	for p (sortedPairs opcodeDefs false) {
		atPut opcodeToName ((first p) + 1) (last p)
	}
	for i (count opcodes) {
		op = nil
		if ('pushBigImmediate' != lastOp) {
			instr = (at opcodes i)
			op = (at opcodeToName ((at instr 2) + 1))
			atPut instr 2 op
		}
		lastOp = op
	}
}

method decodeImmediates MicroBlocksDecompiler {
	// Decode values encoded in pushImmediate instructions (true, false, or small integer.)

	for i (count opcodes) {
		instr = (at opcodes i)
		if ('pushImmediate' == (cmdOp this instr)) {
			val = (last instr)
			decoded = val
			if (1 == (val & 1)) {
				decoded = (floor (val / 2)) // small integer
			} (0 == val) {
				decoded = false
			} (4 == val) {
				decoded = true
			} else {
				print 'cannot decode immediate value:' val
			}
			atPut instr 3 decoded
		}
	}
}

method recordControlStructure MicroBlocksDecompiler i newRec {
	// Record a control structure record for the given index.
	// When multiple control structures share the same starting index
	// (e.g. nested 'forever' loops), collect them in a 'multiple' record.

	existing = (at controlStructures i)
	if (isNil existing) { // most common case
		atPut controlStructures i newRec
		return
	}
	// handle multiple control structures with the same starting index
	newEnd = (max (at existing 2) (at newRec 2))
	if ('multiple' == (first existing)) {
		// append to existing 'multiple' record
		add existing newRec
		atPut existing 2 newEnd
	} else {
		// convert to a 'multiple' record listing both existing and new records
		atPut controlStructures i (list 'multiple' newEnd existing newRec)
	}
}

// GPCode transformations

method addHatBlock MicroBlocksDecompiler chunkID chunkType gpCode {
	// Prefix given code with a hat block based on chunkType and return the result.

	result = gpCode
	// chunk types 1 and 2 are command and reporter blocks without a hat
	if (3 == chunkType) {
		// Note: result is Function object
		if (not (contains funcs chunkID)) {
			// this happens during testing when decompiling a single function
			if ((count functionInfo) > 3) {
				atPut funcs chunkID (at functionInfo 4)
			}
		}
		fName = (at funcs chunkID 'unknown function') // should never see "unknown function"
		result = (newFunction fName argNames gpCode module)
	} (4 == chunkType) {
		result = (newCommand 'whenStarted')
		setField result 'nextBlock' gpCode
	} (5 == chunkType) {
		// whenCondition hat; already added
	} (6 == chunkType) {
		result = (newCommand 'whenBroadcastReceived' msgName)
		setField result 'nextBlock' gpCode
	} (7 == chunkType) {
		result = (newCommand 'whenButtonPressed' 'A')
		setField result 'nextBlock' gpCode
	} (8 == chunkType) {
		result = (newCommand 'whenButtonPressed' 'B')
		setField result 'nextBlock' gpCode
	} (9 == chunkType) {
		result = (newCommand 'whenButtonPressed' 'A+B')
		setField result 'nextBlock' gpCode
	}
	return result
}

method fixBooleanAndColorArgs MicroBlocksDecompiler gpCode {
	for block (allBlocks gpCode) {
		spec = (specForOp (authoringSpecs) (primName block))
		if (isNil spec) {
			// make up a default spec
			spec = (blockSpecFromStrings (primName block) '' '' '' (array))
		}
		args = (argList block)
		for i (min (slotCount spec) (count args)) {
			slotType = (first (slotInfoForIndex spec i))
			val = (at args i)
			if (and ('color' == slotType) (isClass val 'Integer')) {
				c = (color ((val >> 16) & 255)  ((val >> 8) & 255) (val & 255))
				setArg block i c
			} (and ('bool' != slotType) (isClass val 'Boolean') ) {
				setArg block i (newReporter 'booleanConstant' val)
			}
			info = (slotInfoForIndex spec i)
		}
	}
}

// Loops

method findLoops MicroBlocksDecompiler {
	// Create entries for all loop constructs in the opcode sequence.

	i = 1
	while (i <= (count opcodes)) {
		cmd = (at opcodes i)
		if (and (isOneOf (cmdOp this cmd) 'jmp' 'jmpFalse' 'decrementAndJmp' 'waitUntil')
				((cmdArg this cmd) < 0)) {
			// a jump instruction with a negative offset marks the end of a loop
			loopType = (loopTypeAt this i opcodes)
			if ('ignore' == loopType) {
				loopRec = nil
				loopEnd = i
			} ('whenCondition' == loopType) {
				loopStart = 2
				loopEnd = i
				conditionStart = 4
				conditionEnd = (i - 1)
				bodyStart = (i + 1)
				bodyEnd = ((count opcodes) - 1)
				loopRec = (array 'whenCondition' (count opcodes) conditionStart conditionEnd bodyStart bodyEnd)
			} ('repeatUntil' == loopType) {
				bodyStart = (jumpTarget this cmd)
				loopStart = (bodyStart - 1)
				conditionStart = (jumpTarget this (at opcodes loopStart))
				conditionEnd = (i - 1)
				bodyEnd = (conditionStart - 1)
				loopEnd = i
				loopRec = (array 'repeatUntil' loopEnd conditionStart conditionEnd bodyStart bodyEnd)
			} ('waitUntil' == loopType) {
				loopStart = (jumpTarget this cmd)
				loopEnd = i
				conditionStart = loopStart
				conditionEnd = (i - 1)
				loopRec = (array 'waitUntil' loopEnd conditionStart conditionEnd)
			} else {
				bodyStart = (jumpTarget this cmd)
				bodyEnd = (i - 1)
				loopStart = bodyStart
				loopEnd = i
				if ('for' == loopType) {
					loopStart = (bodyStart - 3)
					bodyEnd = (i - 2)
					loopEnd = (i + 1)
					if (notNil (at controlStructures (bodyStart - 1))) {
						cmd2 = (at controlStructures (bodyStart - 1))
						if ('repeatUntil' == (first cmd2)) {
							// fix waitUntil (xxx can be removed eventually)
							rec = (array 'waitUntil' (at cmd2 6) (at cmd2 5) ((at cmd2 6) - 1))
							recordControlStructure this bodyStart rec
							atPut controlStructures (bodyStart - 1) nil
						}
					}
				} ('repeat' == loopType) {
					loopStart = (bodyStart - 1)
				}
				loopRec = (array loopType loopEnd bodyStart bodyEnd)
				if ('for' == loopType) {
					forIndexVar = (cmdArg this (at opcodes (i - 1)))
					loopRec = (copyWith loopRec forIndexVar)
				}
			}
			if (notNil loopRec) { recordControlStructure this loopStart loopRec }
			i = (loopEnd + 1)
		} else {
			i += 1
		}
	}
}

method loopTypeAt MicroBlocksDecompiler i seq {
	// Return the loop type based on the pattern of jumps starting at i in the given sequence.

	cmd = (at seq i)
	op = (cmdOp this cmd)
	if ('decrementAndJmp' == op) { return 'repeat' }
	if ('waitUntil' == op) { return 'waitUntil' }
	if ('jmp' == op) {
		if ('forLoop' == (cmdOp this (at seq (i - 1)))) {
			return 'for'
		} (and (i == (count opcodes)) (2 == (jumpTarget this cmd))) {
			return 'ignore' // ignore the final jump of a 'whenCondition'
		} else {
			return 'forever'
		}
	}
	if ('jmpFalse' == op) {
		loopStart = (i + (cmdArg this cmd))
		if (and (1 == loopStart)
				('jmp' == (cmdOp this (last seq)))
				(2 == (jumpTarget this (last seq)))) {
					return 'whenCondition'
		}
		if ('jmp' == (cmdOp this (at seq loopStart))) {
			// xxx remove this test once compiler generates 'waitUntil' opcodes
			return 'repeatUntil'
		} else {
			return 'waitUntil'
		}
	}
	return 'unknown loop type'
}

// Conditionals

method findIfs MicroBlocksDecompiler {
	// Create entries for all "if" and "if-else" constructs in the opcode sequence.

	for i (count opcodes) {
		cmd = (at opcodes i)
		if (and ('jmpFalse' == (cmdOp this cmd)) ((cmdArg this cmd) >= 0) (not (isAnd this opcodes cmd))) {
			trueStart = (i + 1)
			trueEnd = ((jumpTarget this cmd) - 1)
			lastCmdOfTrue = (at opcodes trueEnd)
			if ('jmp' == (cmdOp this lastCmdOfTrue)) {
				falseStart = (trueEnd + 1)
				falseEnd = ((jumpTarget this lastCmdOfTrue) - 1)
				conditionalRec = (array 'if-else' falseEnd trueStart (trueEnd - 1) falseStart falseEnd)
			} else {
				conditionalRec = (array 'if' trueEnd trueStart trueEnd)
			}
			recordControlStructure this i conditionalRec
		}
	}
}

method isAnd MicroBlocksDecompiler seq cmd {
	// Return true if the subsequence starting with cmd is was generated by an "and" expression.

	if ('jmpFalse' != (cmdOp this cmd)) { return false }
	i = (jumpTarget this cmd)
	if (i > (count seq)) { return false }
	cmdBeforeEnd = (at seq (i - 1))
	endCmd = (at seq i)
	return (and
		(cmdIs this cmdBeforeEnd 'jmp' 1)
		(cmdIs this endCmd 'pushImmediate' false))
}

// Locals

method fixLocals MicroBlocksDecompiler {
	// Replace the first "set" of a local variable with "declareLocal".

	declared = (dictionary)
	for cmd opcodes {
		if ('storeLocal' == (cmdOp this cmd)) {
			vIndex = (cmdArg this cmd)
			if (not (contains declared vIndex)) {
				atPut cmd 2 'declareLocal'
				add declared vIndex
			}
		}
	}
}

// Decoding

method codeForSequence MicroBlocksDecompiler start end {
	// Decode the given sequence of opecodes and return a GP Reporter (if it is an expression)
	// or a GP Command (if it is a command or sequence of commands). The opcode sequence must
	// be complete and well-formed (e.g. if it encodes a command sequence it should leave the
	// stack empty) and does not contain any control structures (loops or if statements).

	if (isNil reporters) { buildReporterDictionary this }

	// save state so it can be restored after a recursive call
	oldCode = code
	oldStack = stack

	code = (list)
	stack = (list)
	i = start
	while (i <= end) {
		cmd = (at opcodes i)
		op = (cmdOp this cmd)
		next = (i + 1)
		if (notNil (at controlStructures i)) {
			ctrl = (at controlStructures i)
			op = (first ctrl)
			next = ((at ctrl 2) + 1)
		}
		if (isOneOf op 'jmpFalse' 'jmpTrue') { // old style "and" or "or" reporter
			i = (decodeOldANDorORreporter this op i)
		} (isOneOf op 'jmpAnd' 'jmpOr') { // new style "and" or "or" reporter
			i = (decodeNewANDorORreporter this op i)
		} ('pushBigImmediate' == op) {
			nextCmd = (at opcodes (i + 1))
			add stack ((((at nextCmd 3) << 8) | (at nextCmd 2)) >> 1) // convert obj to int
			i += 2
		} ('callFunction' == op) {
			cmdArg = (cmdArg this cmd)
			argCount = (cmdArg & 255)
			chunkID = ((cmdArg >> 8) & 255)
			fName = (at funcs chunkID 'unknown function') // should never see "unknown function"
			isReporter = (not (cmdIs this (at opcodes (i + 1)) 'pop' 1))
			if isReporter {
				add stack (buildCmdOrReporter this fName argCount true)
				i += 1
			} else {
				add code (buildCmdOrReporter this fName argCount false)
				i += 2
			}
		} ('multiple' == op) {
			// Remove and process the outer-most control structure (the last one in the list).
			// This does  a recursive call to codeForSequence, but with one fewer control
			// structures in the 'multiple' list. Recursion terminates when there are no more
			// control structures.
			cmd = (removeLast ctrl)
			if ((count ctrl) < 3) { atPut controlStructures i nil }
			op = (first cmd)
			next = ((at cmd 2) + 1)
			if ('forever' == op) {
				body = (codeForSequence this (at cmd 3) (at cmd 4))
				add code (newCommand 'forever' body)
			} ('repeat' == op) {
				if (and ((count ctrl) > 2) ('repeatUntil' == (first (last ctrl)))) {
					// fix waitUntil inside a repeat (xxx can remove eventually)
					cmd2 = (removeLast ctrl)
					rec = (array 'waitUntil' (at cmd2 6) (at cmd2 5) ((at cmd2 6) - 1))
					recordControlStructure this (i + 1) rec
				}
				body = (codeForSequence this (at cmd 3) (at cmd 4))
				add code (newCommand 'repeat' (removeLast stack) body)
			} ('repeatUntil' == op) {
				if (and ((count ctrl) > 2) ('repeatUntil' == (first (last ctrl)))) {
					// fix waitUntil inside a repeat (xxx can remove eventually)
					cmd2 = (removeLast ctrl)
					rec = (array 'waitUntil' (at cmd2 6) (at cmd2 5) ((at cmd2 6) - 1))
					recordControlStructure this (i + 1) rec
				}
				condition = (codeForSequence this (at cmd 3) (at cmd 4))
				body = (codeForSequence this (at cmd 5) (at cmd 6))
				add code (newCommand 'repeatUntil' condition body)
			} ('waitUntil' == op) {
				condition = (codeForSequence this (at cmd 3) (at cmd 4))
				add code (newCommand 'waitUntil' condition)
			}
			i = next
		} (isOneOf op 'callCustomCommand' 'callCustomReporter') {
			isReporter = (not (cmdIs this (at opcodes (i + 1)) 'pop' 1))
			decodeCmd this i
			if isReporter {
				i += 1
			} else {
				i += 2
			}
		} else {
			decodeCmd this i
			i = next
		}
	}

	result = nil
	if (and (isEmpty code) ((count stack) == 1)) {
		result = (first stack) // result is a reporter
	} else {
		// result is a command or squence of commands; stack should be empty
		if (not (isEmpty stack)) { error 'incomplete sequence?' }
		if (notEmpty code) {
			lastCmd = nil
			for cmd code {  // chain all commands together
				if (notNil lastCmd) {
					setField lastCmd 'nextBlock' cmd
				}
				lastCmd = cmd
			}
			result = (first code)
		}
	}

	// restore state and return the result
	code = oldCode
	stack = oldStack
	return result
}

method decodeOldANDorORreporter MicroBlocksDecompiler op i {
	// Decode an old-style AND or OR reporter (before jmpAnd/jmpOr).

	if ('jmpFalse' == op) { gpOp = 'and' } else { gpOp = 'or' }
	target = (jumpTarget this (at opcodes i))
	i += 1
	start = i
	while (not (and
		(op == (cmdOp this (at opcodes i)))
		(target == (jumpTarget this (at opcodes i))) )) {
			// find the jump at the end of the first argument
			i += 1
	}
	end = (i - 1)
	arg1 = (removeLast stack)
	arg2 = (codeForSequence this start end)
	add stack (newReporter gpOp arg1 arg2)
	return (i + 4)
}

method decodeNewANDorORreporter MicroBlocksDecompiler op i {
	// Decode an new AND or OR reporter (using jmpAnd/jmpOr).

	if ('jmpAnd' == op) { gpOp = 'and' } else { gpOp = 'or' }
	start = (i + 1)
	end = (i + (cmdArg this (at opcodes i)))
	arg1 = (removeLast stack)
	arg2 = (codeForSequence this start end)
	add stack (newReporter gpOp arg1 arg2)
	return (end + 1)
}

method decodeCmd MicroBlocksDecompiler i {
	cmd = (at opcodes i)
	cmdArg = (cmdArg this cmd)
	op = (cmdOp this cmd)
	if (notNil (at controlStructures i)) {
		ctrl = (at controlStructures i)
		cmd = ctrl
		op = (first cmd)
		atPut controlStructures i nil // avoid infinite recursion on 'forever' and 'waitUntil'
	}

	if ('halt' == op) {
		add code (newCommand 'stopTask')
	} (isOneOf op 'pushImmediate' 'pushLiteral') {
		add stack cmdArg

	// Variables
	} ('pushVar' == op) {
		add stack (newReporter 'v' (globalVarName this cmdArg))
	} ('storeVar' == op) {
		add code (newCommand '=' (globalVarName this cmdArg) (removeLast stack))
	} ('incrementVar' == op) {
		add code (newCommand '+=' (globalVarName this cmdArg) (removeLast stack))
	} ('pushArgCount' == op) {
		add stack (newReporter 'pushArgCount')
	} ('pushArg' == op) {
		add stack (newReporter 'v' (argName this cmdArg))
	} ('storeArg' == op) {
		add code (newCommand '=' (argName this cmdArg) (removeLast stack))
	} ('incrementArg' == op) {
		add code (newCommand '+=' (argName this cmdArg) (removeLast stack))
	} ('pushLocal' == op) {
		add stack (newReporter 'v' (localVarName this cmdArg))
	} ('storeLocal' == op) {
		add code (newCommand '=' (localVarName this cmdArg) (removeLast stack))
	} ('incrementLocal' == op) {
		add code (newCommand '+=' (localVarName this cmdArg) (removeLast stack))
	} ('declareLocal' == op) {
		add code (newCommand 'local' (localVarName this cmdArg) (removeLast stack))

	} ('initLocals' == op) {
		// skip
	} ('pop' == op) {
		add code (buildCmdOrReporter this 'ignoreArgs' cmdArg false)
	} ('returnResult' == op) {
		add code (buildCmdOrReporter this 'return' 1 false)
	} ('digitalSet' == op) {
		add code (newCommand 'digitalWriteOp' cmdArg true)
	} ('digitalClear' == op) {
		add code (newCommand 'digitalWriteOp' cmdArg false)

	} ('if' == op) {
		add code (newCommand 'if'
			(removeLast stack)
			(codeForSequence this (at cmd 3) (at cmd 4)))
	} ('if-else' == op) {
		ifPart = (codeForSequence this (at cmd 3) (at cmd 4))
		elsePart = (codeForSequence this (at cmd 5) (at cmd 6))
		if (and (notNil elsePart) ('if' == (primName elsePart))) {
			// combine nested if's
			argList = (list 'if' (removeLast stack) ifPart)
			addAll argList (argList elsePart)
			add code (callWith 'newCommand' (toArray argList))
		} else {
			add code (newCommand 'if' (removeLast stack) ifPart true elsePart)
		}
	} ('for' == op) {
		body = (codeForSequence this (at cmd 3) (at cmd 4))
		indexVarName = (localVarName this (at cmd 5))
		add code (newCommand 'for' indexVarName (removeLast stack) body)
	} ('forever' == op) {
		body = (codeForSequence this (at cmd 3) (at cmd 4))
		add code (newCommand 'forever' body)
	} ('repeat' == op) {
		body = (codeForSequence this (at cmd 3) (at cmd 4))
		add code (newCommand 'repeat' (removeLast stack) body)
	} ('repeatUntil' == op) {
		condition = (codeForSequence this (at cmd 3) (at cmd 4))
		body = (codeForSequence this (at cmd 5) (at cmd 6))
		add code (newCommand 'repeatUntil' condition body)
	} ('waitUntil' == op) {
		condition = (codeForSequence this (at cmd 3) (at cmd 4))
		add code (newCommand 'waitUntil' condition)
	} ('whenCondition' == op) {
		condition = (codeForSequence this (at cmd 3) (at cmd 4))
		body = (codeForSequence this (at cmd 5) (at cmd 6))
		whenHat = (newCommand 'whenCondition' condition)
		if (notNil body) {
			setField whenHat 'nextBlock' body
		}
		add code whenHat

	// everything else
	} (contains reporters op) {
		add stack (buildCmdOrReporter this op cmdArg true)
	} else {
		add code (buildCmdOrReporter this op cmdArg false)
	}
	if (notNil ctrl) { atPut controlStructures i ctrl } // restore ctrl to controlStructure
}

method buildCmdOrReporter MicroBlocksDecompiler op argCount isReporter {
	// Return a GP Command or Reporter for the given op taking argCount items from the stack.
	// If optional isReporter arg is not supplied, look up the op in the reporters dictionary.

	if (or ('callCommandPrimitive' == op) ('callReporterPrimitive' == op)) {
		argsStart = ((count stack) - (argCount - 1))
		primName = (at stack argsStart)
		primSet = (at stack (argsStart + 1))
		op = (join '[' primName ':' primSet ']')
		removeAt stack argsStart
		removeAt stack argsStart
		argCount += -2
	}

	if isReporter {
		result = (newIndexable 'Reporter' argCount)
	} else {
		result = (newIndexable 'Command' argCount)
	}
	setField result 'primName' op
	setField result 'lineno' 1
	setField result 'fileName' ''

	j = (count result) // index of last arg
	repeat argCount {
		setField result j (removeLast stack)
		j += -1
	}
	return result
}

method globalVarName MicroBlocksDecompiler vIndex {
	if (contains vars vIndex) { return (at vars vIndex) }
	return (join 'V' vIndex)
}

method localVarName MicroBlocksDecompiler vIndex {
	if (and (0 <= vIndex) (vIndex < (count localNames))) {
		return (at localNames (vIndex + 1))
	}
	return (join 'L' vIndex)
}

method argName MicroBlocksDecompiler vIndex {
	if (and (0 <= vIndex) (vIndex < (count argNames))) {
		return (at argNames (vIndex + 1))
	}
	return (join 'A' vIndex)
}

// Helper Methods

method buildReporterDictionary MicroBlocksDecompiler {
	// Build a dictionary of the MicroBlocks built-in reporters. This is used to
	// decide whether a given opcode is a reporter or a command.

	reporters = (dictionary)
	add reporters 'pushArgCount'
	add reporters 'getArg'
	add reporters 'callReporterPrimitive'
	for spec (microBlocksSpecs (new 'SmallCompiler')) {
		if (and (isClass spec 'Array') ('r' == (first spec))) {
			op = (at spec 2)
			if (not (beginsWith op '[')) { add reporters (at spec 2) }
		}
	}
}
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Copyright 2019 John Maloney, Bernat Romagosa, and Jens MÃ¶nig

// MicroBlocksEditor.gp - Top-level window for the MicroBlocks IDE
// John Maloney, January, 2018

to startup { openMicroBlocksEditor } // run at startup if not in interactive mode

to uload fileName {
  // Reload a top level module file when working on MicroBlocks. The 'lib/' prefix and '.gp'
  // suffix can be omitted. Example: "reload 'List'"

  if (not (endsWith fileName '.gp')) { fileName = (join fileName '.gp') }
  if (contains (listFiles '../ide') fileName) {
	fileName = (join '../ide/' fileName)
  } (contains (listFiles 'ide') fileName) {
	fileName = (join 'ide/' fileName)
  } else {
	fileName = (join '../gp/runtime/lib/' fileName)
  }
  return (load fileName (topLevelModule))
}

defineClass MicroBlocksEditor morph fileName scripter leftItems title rightItems tipBar zoomButtons indicator nextIndicatorUpdateMSecs progressIndicator lastStatus httpServer lastProjectFolder lastScriptPicFolder boardLibAutoLoadDisabled autoDecompile showHiddenBlocks frameRate frameCount lastFrameTime newerVersion putNextDroppedFileOnBoard isDownloading trashcan overlay

method fileName MicroBlocksEditor { return fileName }
method project MicroBlocksEditor { return (project scripter) }
method scripter MicroBlocksEditor { return scripter }
method httpServer MicroBlocksEditor { return httpServer }
method lastScriptPicFolder MicroBlocksEditor { return lastScriptPicFolder }
method setLastScriptPicFolder MicroBlocksEditor dir { lastScriptPicFolder = dir }

to openMicroBlocksEditor devMode {
  if (isNil devMode) { devMode = false }
  page = (newPage 1000 600)
  setDevMode page devMode
  toggleMorphicMenu (hand page) (contains (commandLine) '--allowMorphMenu')
  setGlobal 'page' page
  tryRetina = true
  open page tryRetina 'MicroBlocks'
  editor = (initialize (new 'MicroBlocksEditor') (emptyProject))
  addPart page editor
  redrawAll (global 'page')
  readVersionFile (smallRuntime)
  applyUserPreferences editor
  pageResized editor
  developerModeChanged editor
  if ('Browser' == (platform)) {
    // attempt to extra project or scripts from URL; does nothing if absent
    importFromURL editor (browserURL)
  }
  startSteppingSafely page
}

to findMicroBlocksEditor {
  page = (global 'page')
  if (notNil page) {
	for p (parts (morph page)) {
	  if (isClass (handler p) 'MicroBlocksEditor') { return (handler p) }
	}
  }
  return nil
}

method initialize MicroBlocksEditor {
  scale = (global 'scale')
  morph = (newMorph this)
  httpServer = (newMicroBlocksHTTPServer)
  addTopBarParts this
  scripter = (initialize (new 'MicroBlocksScripter') this)
  lastProjectFolder = 'Examples'
  addPart morph (morph scripter)
  addTipBar this
  addZoomButtons this
  clearProject this
  fixLayout this
  nextIndicatorUpdateMSecs = 0
  setFPS morph 200
  newerVersion = 'unknown'
  putNextDroppedFileOnBoard = false
  return this
}

method scaleChanged MicroBlocksEditor {
  // Called when the window resolution changes.

  removeHint (global 'page')
  removeAllParts morph

  // save the state of the current scripter
  if (2 == (global 'scale')) { oldScale = 1 } else { oldScale = 2 }
  saveScripts scripter (oldScale * (global 'blockScale'))
  oldProject = (project scripter)
  oldCategory = (currentCategory scripter)
  oldLibrary = (currentLibrary scripter)

  // make a new scripter and restore old scripter state
  scripter = (initialize (new 'MicroBlocksScripter') this)
  setProject scripter oldProject
  updateLibraryList scripter
  if (notNil oldCategory) { selectCategory scripter oldCategory }
  if (notNil oldLibrary) { selectLibrary scripter oldLibrary }
  languageChanged scripter
  sendStopAll (smallRuntime)
  initialize (smallRuntime) scripter

  // rebuild the editor
  addLogo this
  addTopBarParts this
  addPart morph (morph title)
  addPart morph (morph scripter)
  addTipBar this
  addZoomButtons this

  fixLayout scripter
  lastStatus = nil // force update
  fixLayout this
}

// trashcan

method showTrashcan MicroBlocksEditor purpose {
  hideTrashcan this // just in case, prevent trashcans from stacking
  palette = (blockPalette (scripter this))
  paletteArea = (clientArea (handler (owner (morph palette))))
  trashcan = (newMorph)
  overlay = (newMorph)
  if (purpose == 'hide') {
	  setCostume trashcan (hideDefinitionIcon this)
  } (purpose == 'delete') {
	  setCostume trashcan (trashcanIcon this)
  } (purpose == 'hideAndDelete') {
	  setCostume trashcan (hideAndDeleteIcon this)
  }
  addPart (morph palette) overlay
  addPart (morph palette) trashcan
  setCenter trashcan (((width paletteArea) / 2) + (left paletteArea)) (((height paletteArea) / 2) + (top paletteArea))
  setPosition overlay (left paletteArea) (top paletteArea)
  setExtent overlay (width paletteArea) (height paletteArea)
  setCostume overlay (gray 0 20)
}

method hideTrashcan MicroBlocksEditor {
  if (notNil trashcan) { destroy trashcan }
  if (notNil overlay) { destroy overlay }
}

// top bar parts

method addTopBarParts MicroBlocksEditor {
  scale = (global 'scale')

  leftItems = (list)
  add leftItems (140 * scale)
  add leftItems (addIconButton this (languageButtonIcon this) 'languageMenu' 'Language')
  add leftItems (addIconButton this (settingsButtonIcon this) 'settingsMenu' 'MicroBlocks')
  add leftItems (addIconButton this (projectButtonIcon this) 'projectMenu' 'File')
  add leftItems (addIconButton this (graphIcon this) 'showGraph' 'Graph')
  add leftItems (addIconButton this (connectButtonIcon this) 'connectToBoard' 'Connect')
  indicator = (last leftItems)

  if (isNil title) {
    // only add the logo and title the first time
    addLogo this
    title = (newText '' 'Arial' (17 * scale))
    addPart morph (morph title)
  }

  rightItems = (list)

  addFrameRate = (contains (commandLine) '--allowMorphMenu')
  if addFrameRate {
	frameRate = (newText '0 fps' 'Arial' (14 * scale))
	addPart morph (morph frameRate)
	add rightItems frameRate
	add rightItems (16 * scale)
  }

  add rightItems (addIconButton this (newBitmap 0 0) 'noop' 'Progress' 36)
  progressIndicator = (last rightItems)
  add rightItems (3 * scale)

  add rightItems (addIconButton this (startButtonIcon this) 'startAll' 'Start' 36)
  add rightItems (addIconButton this (stopButtonIcon this) 'stopAndSyncScripts' 'Stop' 36)
  add rightItems (7 * scale)
}

method addLogo MicroBlocksEditor {
  logoM = (newMorph)
  setCostume logoM (logoAndText this)
  setPosition logoM 0 0
  addPart morph logoM
}

method textButton MicroBlocksEditor label selector {
  label = (localized label)
  scale = (global 'scale')
  setFont 'Arial Bold' (16 * scale)
  if ('Linux' == (platform)) { setFont 'Arial Bold' (13 * scale) }
  w = ((stringWidth label) + (10 * scale))
  h = (41 * scale)
  labelY = (12 * scale)
  bm1 = (newBitmap w h (topBarBlue this))
  drawString bm1 label (gray 60) (5 * scale) labelY
  bm2 = (newBitmap w h (topBarBlueHighlight this))
  drawString bm2 label (gray 40) (5 * scale) labelY
  button = (newButton '' (action selector this))
  setCostumes button bm1 bm2
  addPart morph (morph button)
  return button
}

// zoom buttons

method addZoomButtons MicroBlocksEditor {
  zoomButtons = (array
	(newZoomButton this 'zoomIn')
	(newZoomButton this 'restoreZoom')
	(newZoomButton this 'zoomOut'))
  for button zoomButtons {
	addPart morph (morph button)
  }
  addZoomButtonHints this
  fixZoomButtonsLayout this
}

method newZoomButton MicroBlocksEditor selector action {
  if (isNil action) {
    action = (action selector this)
  }
  scale = (global 'scale')
  icon = (call (action (join selector 'Icon') this))
  w = (30 * scale)
  h = (30 * scale)
  x = (half (w - (width icon)))
  y = (5 * scale)
  bm1 = (newBitmap w h (transparent))
  drawBitmap bm1 icon x y
  //bm2 = (newBitmap w h (topBarBlueHighlight this))
  //drawBitmap bm2 icon x y
  button = (newButton '' action)
  setCostumes button bm1
  return button
}

method addZoomButtonHints MicroBlocksEditor {
  // add zoom button hints in current language
  setHint (at zoomButtons 1) (localized 'Increase block size')
  setHint (at zoomButtons 2) (localized 'Restore block size to 100%')
  setHint (at zoomButtons 3) (localized 'Decrease block size')
}

method restoreZoom MicroBlocksEditor {
  setBlockScalePercent this 100
}

method zoomIn MicroBlocksEditor {
  zoomLevels = (list 50 75 100 125 150 200 250)
  currentZoom = ((global 'blockScale') * 100)
  for percent zoomLevels {
  	if (percent > currentZoom) { // first entry greater than current zoom level
      setBlockScalePercent this percent
      return
    }
  }
}

method zoomOut MicroBlocksEditor {
  zoomLevels = (list 50 75 100 125 150 200 250)
  currentZoom = ((global 'blockScale') * 100)
  for percent (reversed zoomLevels) {
  	if (percent < currentZoom) { // first entry less than current zoom level
      setBlockScalePercent this percent
      return
    }
  }
}

method setBlockScalePercent MicroBlocksEditor newPercent {
  setBlockScalePercent (scriptEditor scripter) newPercent
  syncScripts (smallRuntime)
}

method fixZoomButtonsLayout MicroBlocksEditor {
  right = ((right morph) - 15)
  bottom = (((bottom morph) - (height (morph tipBar))) - 10)
  for button zoomButtons {
	right = (right - (width (morph button)))
    setLeft (morph button) right
    setTop (morph button) ((bottom - (height (morph button))) - 5)
  }
}

// tip bar

method addTipBar MicroBlocksEditor {
  tipBar = (initialize (new 'MicroBlocksTipBar'))
  setGlobal 'tipBar' tipBar
  setTitle tipBar 'an element'
  setTip tipBar 'some tip about it'
  addPart morph (morph tipBar)
}

// project operations

method downloadInProgress MicroBlocksEditor {
  if isDownloading {
    existingPrompt = (findMorph 'Prompter')
    if (notNil existingPrompt) { cancel (handler existingPrompt) }
    inform 'Downloading code to board. Please wait.' nil nil true
  }
  return isDownloading
}

method canReplaceCurrentProject MicroBlocksEditor {
  if (downloadInProgress this) {return false }
  return (or
	(not (hasUserCode (project scripter)))
	(confirm (global 'page') nil 'Discard current project?'))
}

method newProject MicroBlocksEditor {
  if (not (canReplaceCurrentProject this)) { return }
  clearProject this
  installBoardSpecificBlocks (smallRuntime)
  updateLibraryList scripter
  fileName = ''
  updateTitle this
}

method clearProject MicroBlocksEditor {
  // Remove old project morphs and classes and reset global state.

  closeAllDialogs this
  setText title ''
  fileName = ''
  createEmptyProject scripter
  if (isRunning httpServer) {
	clearVars httpServer
  }
  clearLoggedData (smallRuntime)
}

method closeAllDialogs MicroBlocksEditor {
  pageM = (morph (global 'page'))
  for p (copy (parts pageM)) {
	// remove explorers, table views -- everything but the MicroBlocksEditor
	if (p != morph) { removePart pageM p }
  }
  doOneCycle (global 'page') // force redisplay
}

method openProjectMenu MicroBlocksEditor {
  if (downloadInProgress this) {return }

  fp = (findMorph 'MicroBlocksFilePicker')
  if (notNil fp) { destroy fp }
  pickFileToOpen (action 'openProjectFromFile' this) lastProjectFolder (array '.ubp' '.gpp')
}

method openProjectFromFile MicroBlocksEditor location {
  // Open a project with the given file path or URL.
  if (beginsWith location '//') {
    lastProjectFolder = 'Examples'
  } else {
    lastProjectFolder = (directoryPart location)
  }

  if (not (canReplaceCurrentProject this)) { return }

  if (beginsWith location '//') {
	data = (readEmbeddedFile (substring location 3) true)
  } else {
	data = (readFile location true)
  }
  if (isNil data) {
	error (join (localized 'Could not read: ') location)
  }
  openProject this data location
}

method openProject MicroBlocksEditor projectData projectName updateLibraries {
  if (downloadInProgress this) { return }
  fileName = projectName
  updateTitle this
  if (endsWith projectName '.gpp') {
	// read old project
	mainClass = nil
	proj = (readProject (emptyProject) projectData)
	if ((count (classes (module proj))) > 0) {
		mainClass = (first (classes (module proj)))
	}
	loadOldProjectFromClass scripter mainClass (blockSpecs proj)
  } else {
	loadNewProjectFromData scripter (toString projectData) updateLibraries
  }
  updateLibraryList scripter
  developerModeChanged scripter
  saveAllChunksAfterLoad (smallRuntime)
}

method openFromBoard MicroBlocksEditor {
  if (not (canReplaceCurrentProject this)) { return }
  clearProject this
  fileName = ''
  updateTitle this
  updateLibraryList scripter
  readCodeFromNextBoardConnected (smallRuntime)
}

method saveProjectToFile MicroBlocksEditor {
  fp = (findMorph 'MicroBlocksFilePicker')
  if (notNil fp) { destroy fp }
  saveProject this nil
}

method copyProjectURLToClipboard MicroBlocksEditor {
  // Copy a URL encoding of this project to the clipboard.

  saveScripts scripter
  codeString = (codeString (project scripter))
  if (notNil title) {
    projName = (text title)
    codeString = (join 'projectName ''' projName '''' (newline) (newline) codeString)
  }
  setClipboard (join
    'https://microblocks.fun/run/microblocks.html#project='
	(urlEncode codeString true)
  )
}

method saveProject MicroBlocksEditor fName {
  saveScripts scripter

  if (and (isNil fName) (notNil fileName)) {
	fName = fileName
	if (beginsWith fName '//Examples') {
	  // if an example was opened, do a "save as" into the Microblocks folder
	  fName = (join (gpFolder) '/' (filePart fileName))
	}
  }

  if ('Browser' == (platform)) {
	if (or (isNil fName) ('' == fName)) { fName = 'Untitled' }
	i = (findLast fName '/')
	if (notNil i) { fName = (substring fName (i + 1)) }
	if (not (endsWith fName '.ubp')) { fName = (join fName '.ubp') }
	browserWriteFile (codeString (project scripter)) fName 'project'
	return
  }

  fName = (fileToWrite (withoutExtension fName) (array '.ubp'))
  if ('' == (filePart fName)) { return false }

  if (and
	(not (isAbsolutePath this fName))
	(not (beginsWith fName (gpFolder)))) {
	  fName = (join (gpFolder) '/' fName)
  }
  if (not (endsWith fName '.ubp')) { fName = (join fName '.ubp') }

  fileName = fName

  lastProjectFolder = (directoryPart fileName)

  updateTitle this
  if (canWriteProject this fileName) {
    writeFile fileName (codeString (project scripter))
  }
}

method canWriteProject MicroBlocksEditor fName {
  return (or
   (isNil (readFile fName))
   (confirm (global 'page') nil 'Overwrite project?'))
}

method isAbsolutePath MicroBlocksEditor fName {
  // Return true if this string is an absolute file path.
  letters = (letters fName)
  count = (count letters)
  if (and (count >= 1) ('/' == (first letters))) { return true } // Mac, Linux
  if (and (count >= 3) (':' == (at letters 2)) (isOneOf (at letters 3) '/' '\')) {
	return true // Win
  }
  return false
}

// board control buttons

method connectToBoard MicroBlocksEditor { selectPort (smallRuntime) }
method stopAndSyncScripts MicroBlocksEditor { stopAndSyncScripts (smallRuntime) }
method startAll MicroBlocksEditor { sendStartAll (smallRuntime) }

// project title

method updateTitle MicroBlocksEditor {
  projName = (withoutExtension (filePart fileName))
  setText title projName
  redraw title
  centerTitle this
}

method centerTitle MicroBlocksEditor {
  scale = (global 'scale')
  left = (right (morph (last leftItems)))
  right = (left (morph (first rightItems)))
  titleM = (morph title)
  setCenter titleM (half (left + right)) (21 * scale)

  // hide title if insufficient space
  if (((width titleM) + (8 * scale)) > (right - left)) {
	hide titleM
  } else {
	show titleM
  }
}

// stepping

method step MicroBlocksEditor {
  if ('Browser' == (platform)) {
	checkForBrowserResize this
	processBrowserDroppedFile this
	processBrowserFileSave this
  }
  processDroppedFiles this

  if (((msecsSinceStart) > nextIndicatorUpdateMSecs)) {
    updateIndicator this
    nextIndicatorUpdateMSecs = ((msecsSinceStart) + 200)
  }

  if (not (busy (smallRuntime))) { processMessages (smallRuntime) }
  if (isRunning httpServer) {
	step httpServer
  }
  if ('unknown' == newerVersion) {
    launch (global 'page') (newCommand 'checkLatestVersion' this) // start version check
    newerVersion = nil
  } (notNil newerVersion) {
    reportNewerVersion this
    newerVersion = nil
  }
  if (notNil frameRate) {
	updateFPS this
  }
}

method updateFPS MicroBlocksEditor {
	if (isNil lastFrameTime) { lastFrameTime = 0 }
	if (isNil frameCount) { frameCount = 0 }
	if (frameCount > 5) {
		now = (msecsSinceStart)
		frameMSecs = (now - lastFrameTime)
		msecsPerFrame = (round ((frameCount * 1000) / frameMSecs))
		setText frameRate (join '' msecsPerFrame ' fps')
		frameCount = 1
		lastFrameTime = now
	} else {
		frameCount += 1
	}
}

// Progress indicator

method drawProgressIndicator MicroBlocksEditor bm phase downloadProgress {
	scale = (global 'scale')
	radius = (13 * scale)
	cx = (half (width bm))
	cy = ((half (height bm)) + scale)
	bgColor = (topBarBlue this)
	if (1 == phase) {
		lightGray = (mixed (gray 0) 5 bgColor)
		darkGray = (mixed (gray 0) 15 bgColor)
	} (2 == phase) {
		lightGray = (mixed (gray 0) 10 bgColor)
		darkGray = (mixed (gray 0) 25 bgColor)
	} (3 == phase) {
		lightGray = (mixed (gray 0) 25 bgColor)
		darkGray = (mixed (gray 0) 50 bgColor)
	}

	fill bm bgColor
	if (and (3 == phase) (downloadProgress >= 1)) { return }

	// background circle
	drawCircle (newShapeMaker bm) cx cy radius lightGray

	// draw progress pie chart
	degrees = (round (360 * downloadProgress))
	oneDegreeDistance = ((* 2 (pi) radius) / 360.0)
	pen = (pen (newShapeMaker bm))
	beginPath pen cx cy
	setHeading pen 270
	forward pen radius
	turn pen 90
	repeat degrees {
	  forward pen oneDegreeDistance
	  turn pen 1
	}
	goto pen cx cy
	fill pen darkGray
}

method showDownloadProgress MicroBlocksEditor phase downloadProgress {
	isDownloading = (downloadProgress < 1)
	bm1 = (getField progressIndicator 'offCostume')
	drawProgressIndicator this bm1 phase downloadProgress
	bm2 = (getField progressIndicator 'onCostume')
	drawProgressIndicator this bm2 phase downloadProgress
	costumeChanged (morph progressIndicator)
	updateDisplay (global 'page') // update the display
}

// Connection indicator

method drawIndicator MicroBlocksEditor bm bgColor isConnected {
	scale = (global 'scale')
	fill bm bgColor
	if isConnected {
		cx = (half (width bm))
		cy = ((half (height bm)) + scale)
		radius = (13 * scale)
		green = (mixed (color 0 200 0) 70 bgColor)
		drawCircle (newShapeMaker bm) cx cy radius green
	}
	icon = (connectButtonIcon this)
	drawBitmap bm icon (10 * scale) (10 * scale)
}

method updateIndicator MicroBlocksEditor forcefully {
	if (busy (smallRuntime)) { return } // do nothing during file transfer

	status = (updateConnection (smallRuntime))
	if (and (lastStatus == status) (forcefully != true)) { return } // no change
	isConnected = ('connected' == status)

	bm1 = (getField indicator 'offCostume')
	drawIndicator this bm1 (topBarBlue this) isConnected
	bm2 = (getField indicator 'onCostume')
	drawIndicator this bm2 (topBarBlueHighlight this) isConnected

	costumeChanged (morph indicator)
	lastStatus = status
}

// browser support

method checkForBrowserResize MicroBlocksEditor {
  browserSize = (browserSize)
  w = (first browserSize)
  h = (last browserSize)
  winSize = (windowSize)

  dx = (abs ((at winSize 1) - w))
  dy = (abs ((at winSize 2) - h))
  if (and (dx <= 1) (dy <= 1)) {
    // At the smallest browser zoom levels, sizes can differ by one pixel
    return // no change
  }

  openWindow w h true
  page = (global 'page')
  oldScale = (global 'scale')
  updateScale page
  scale = (global 'scale')
  pageM = (morph page)
  setExtent pageM (w * scale) (h * scale)
  for each (parts pageM) { pageResized (handler each) w h this }
  if (scale != oldScale) {
	for m (allMorphs pageM) { scaleChanged (handler m) }
  }
}

method putNextDroppedFileOnBoard MicroBlocksEditor {
  putNextDroppedFileOnBoard = true
}

method processBrowserDroppedFile MicroBlocksEditor {
  pair = (browserGetDroppedFile)
  if (isNil pair) { return }
  fName = (callWith 'string' (first pair))
  data = (last pair)
  if putNextDroppedFileOnBoard {
    putNextDroppedFileOnBoard = false // clear flag
	sendFileData (smallRuntime) fName data
  } else {
    processDroppedFile this fName data
  }
}

method processBrowserFileSave MicroBlocksEditor {
	lastSavedName = (browserLastSaveName)
	if (notNil lastSavedName) {
		if (endsWith lastSavedName '.hex') {
			startFirmwareCountdown (smallRuntime) lastSavedName
		} (endsWith lastSavedName '.ubp') {
			// Update the title
			fileName = (withoutExtension lastSavedName)
			updateTitle this
		}
		if ('_no_file_selected_' == lastSavedName) {
			startFirmwareCountdown (smallRuntime) lastSavedName
		}
	}
}

// dropped files

method processDroppedFiles MicroBlocksEditor {
  for evt (droppedFiles (global 'page')) {
	fName = (toUnixPath (at evt 'file'))
	data = (readFile fName true)
	if (notNil data) {
	  processDroppedFile this fName data
	}
  }
  for evt (droppedTexts (global 'page')) {
	text = (at evt 'file')
	processDroppedText this text
  }
}

method processDroppedFile MicroBlocksEditor fName data {
  lcFilename = (toLowerCase fName)
  if (endsWith lcFilename '.ubp') {
	if (not (canReplaceCurrentProject this)) { return }
	openProject this data fName
  } (endsWith lcFilename '.ubl') {
	importLibraryFromFile scripter fName data
  } (endsWith lcFilename '.csv') {
	if (isNil data) { return } // could not read file
	data = (joinStrings (splitWith (toString data) ',')) // remove commas
	clearLoggedData (smallRuntime)
	for entry (lines data) { addLoggedData (smallRuntime) entry }
  } (endsWith lcFilename '.png') {
    importFromPNG this data
  } (endsWith lcFilename '.gp') {
    // xxx for testing:
    eval (toString data) nil (topLevelModule)
  }	else {
	// load file into board, if possible
	if ('Browser' == (platform)) {
		sendFileData (smallRuntime) fName data
	} else {
		writeFileToBoard (smallRuntime) fName
	}
  }
}

method processDroppedText MicroBlocksEditor text {
  if (beginsWith text 'http') {
    text = (first (lines text))
    url = (substring text ((findFirst text ':') + 3))
    host = (substring url 1 ((findFirst url '/') - 1))
    path = (substring url (findFirst url '/'))
    fileName = (substring path ((findLast path '/') + 1) ((findLast path '.') - 1))

    if (or ((findSubstring 'scripts=' url) > 0) ((findSubstring 'project=' url) > 0)) {
      importFromURL this url
      return
    }

    if (endsWith url '.ubp') {
      if (not (canReplaceCurrentProject this)) { return }
      openProject this (httpBody (httpGet host path)) fileName
    } (endsWith url '.ubl') {
      importLibraryFromString scripter (httpBody (httpGet host path)) fileName fileName
      saveAllChunksAfterLoad (smallRuntime)
    } (and (or (notNil json) (endsWith url '.png')) ('Browser' == (platform))) {
      data = (httpBody (basicHTTPGetBinary host path))
      if ('' == data) { return }
      importFromPNG this data
    }
  } else {
	spec = (specForOp (authoringSpecs) 'comment')
	block = (blockForSpec spec)
	setContents (first (inputs block)) text
	// doesn't work because hand position isn't updated until the drop is done
	setLeft (morph block) (x (hand (global 'page')))
	setTop (morph block) (y (hand (global 'page')))
	addPart (morph (scriptEditor scripter)) (morph block)
  }
}

method importFromURL MicroBlocksEditor url {
  i = (findSubstring 'scripts=' url)
  if (notNil i) { // import scripts embedded in URL
    scriptString = (urlDecode (substring url (i + 8)))
    pasteScripts scripter scriptString
    return
  }
  i = (findSubstring 'project=' url)
  if (notNil i) { // open a complete project
    urlOrData = (substring url (i + 8))
    if (beginsWith urlOrData 'http') {
      // project link
      fileName = (substring urlOrData ((findLast urlOrData '/') + 1) ((findLast urlOrData '.') - 1))
      if (not (canReplaceCurrentProject this)) { return }
      openProject this (httpBody (httpGetInBrowser urlOrData)) fileName
   } else {
      // project embedded in URL
      projectString = (urlDecode (substring url (i + 8)))
      if (not (canReplaceCurrentProject this)) { return }
      projName = (extractProjectName this projectString)
      if (not (canReplaceCurrentProject this)) { return }
      openProject this projectString projName
    }
    return
  }
}

method extractProjectName MicroBlocksEditor projectString {
  for line (lines projectString) {
    if (beginsWith line 'projectName') {
      return (first (argList (first (parse line))))
    }
  }
  return '' // no name found
}

method importFromPNG MicroBlocksEditor pngData {
  scriptString = (getScriptText (new 'PNGReader') pngData)
  if (isNil scriptString) { return } // no script in this PNG file
  i = (find (letters scriptString) (newline))
  scriptString = (substring scriptString i)
  pasteScripts scripter scriptString
}

// handle drops

method wantsDropOf MicroBlocksEditor aHandler { return true }

method justReceivedDrop MicroBlocksEditor aHandler {
  if (or (isAnyClass aHandler 'ColorPicker' 'Monitor') (hasField aHandler 'window')) {
	addPart (morph (global 'page')) (morph aHandler)
  } else {
	animateBackToOldOwner (hand (global 'page')) (morph aHandler)
  }
}

// version check

method checkLatestVersion MicroBlocksEditor {
  latestVersion = (fetchLatestVersionNumber this) // fetch version, even in browser, to log useage
  if ('Browser' == (platform)) { return } // skip version check in browser/Chromebook
  currentVersion = (splitWith (ideVersionNumber (smallRuntime)) '.')

  // sanity checks -- both versions should be lists/arrays of strings representing integers
  // can get garbage if the HTTP request fails
  for n latestVersion { if (not (representsAnInteger n)) { return }}
  for n currentVersion { if (not (representsAnInteger n)) { return }}

  for i (count latestVersion) {
	latest = (toInteger (at latestVersion i))
	current = (toInteger (at currentVersion i))
	pilot = (current > latest)
	if pilot {
      // we're running a pilot release, lets check the latest one
      latestVersion = (fetchLatestPilotVersionNumber this)
      for n latestVersion { if (not (representsAnInteger n)) { return }} // sanity check
      latest = (toInteger (at latestVersion i))
	}
	if (latest > current) {
	  newerVersion = latestVersion
	} (current > latest) {
      // if this subpart of the current version number is > latest, don't check following parts
      // (e.g. 2.0.0 is later than 1.9.9)
      return
	}
  }
}

method fetchLatestVersionNumber MicroBlocksEditor {
  platform = (platform)
  if ('Browser' == platform) {
    if (browserIsChromeOS) {
      suffix = '?C='
    } else {
      suffix = '?B='
    }
  } ('Mac' == (platform)) {
    suffix = '?M='
  } ('Linux' == (platform)) {
    suffix = '?L='
  } ('Win' == (platform)) {
    suffix = '?W='
  } else {
    suffix = '?R='
  }
  url = (join '/downloads/latest/VERSION.txt' suffix (rand 100000 999999))
  versionText = (basicHTTPGet 'microblocks.fun' url)
  if (isNil versionText) { return (array 0 0 0) }
  return (splitWith (substring (first (lines versionText)) 1) '.')
}

method fetchLatestPilotVersionNumber MicroBlocksEditor {
  versionText = (basicHTTPGet 'microblocks.fun' '/downloads/pilot/VERSION.txt')
  if (isNil versionText) { return (array 0 0 0) }
  versionLine = (first (lines versionText))
  // take out "-pilot" first
  return (splitWith (substring versionLine 1 ((count versionLine) - 6)) '.')
}

method reportNewerVersion MicroBlocksEditor {
  versionString = (joinStrings newerVersion '.')
  newerVersion = nil // clear this to avoid repeated calls from step
  (inform (global 'page') (join
      'A new MicroBlocks version has been released (' versionString ').' (newline)
      (newline)
      'Get it now at http://microblocks.fun')
    'New version available')
}

// user preferences

method readUserPreferences MicroBlocksEditor {
  result = (dictionary)
  if ('Browser' == (platform)) {
    jsonString = (browserReadPrefs)
    waitMSecs 20 // timer for callback in ChromeOS
    jsonString = (browserReadPrefs) // will have result the second time
  } else {
    path = (join (gpFolder) '/preferences.json')
    jsonString = (readFile path)
  }
  if (notNil jsonString) {
	result = (jsonParse jsonString)
	if (not (isClass result 'Dictionary')) { result = (dictionary) }
  }
  return result
}

method isChineseWebapp MicroBlocksEditor {
	if ('Browser' != (platform)) { return false }
	url = (browserURL)
	return (or
		((containsSubString url 'microblocksfun.cn') > 0)
		((containsSubString url 'blocks.aimaker.space') > 0)
		(browserHasLanguage 'zh')
	)
}

method applyUserPreferences MicroBlocksEditor {
	prefs = (readUserPreferences this)
	if (notNil (at prefs 'locale')) {
		setLanguage this (at prefs 'locale')
	} (isChineseWebapp this) {
		setLanguage this 'ç®ä½ä¸­æ'
	}
	if (notNil (at prefs 'boardLibAutoLoadDisabled')) {
		boardLibAutoLoadDisabled = (at prefs 'boardLibAutoLoadDisabled')
	}
	if (notNil (at prefs 'autoDecompile')) {
		autoDecompile = (at prefs 'autoDecompile')
	}
	if (notNil (at prefs 'blockSizePercent')) {
		percent = (at prefs 'blockSizePercent')
		setGlobal 'blockScale' ((clamp percent 25 500) / 100)
	}
	if (notNil (at prefs 'devMode')) {
		setDevMode (global 'page') (at prefs 'devMode')
		developerModeChanged this
	}
	if (notNil (at prefs 'showImplementationBlocks')) {
		showHiddenBlocks = (at prefs 'showImplementationBlocks')
	}
}

method saveToUserPreferences MicroBlocksEditor key value {
	prefs = (readUserPreferences this)
	if (isNil value) {
		remove prefs key
	} else {
		atPut prefs key value
	}
    if ('Browser' == (platform)) {
		browserWritePrefs (jsonStringify prefs)
	} else {
		path = (join (gpFolder) '/preferences.json')
		writeFile path (jsonStringify prefs)
	}
}

method toggleBoardLibAutoLoad MicroBlocksEditor flag {
	boardLibAutoLoadDisabled = (not flag)
	saveToUserPreferences this 'boardLibAutoLoadDisabled' boardLibAutoLoadDisabled
}

method boardLibAutoLoadDisabled MicroBlocksEditor {
	return (boardLibAutoLoadDisabled == true)
}

method toggleAutoDecompile MicroBlocksEditor flag {
	autoDecompile = flag
	saveToUserPreferences this 'autoDecompile' autoDecompile
}

method autoDecompileEnabled MicroBlocksEditor {
	return (autoDecompile == true)
}

method toggleShowHiddenBlocks MicroBlocksEditor flag {
	showHiddenBlocks = flag
	saveToUserPreferences this 'showImplementationBlocks' showHiddenBlocks
	developerModeChanged this // updates the palette
}

method showHiddenBlocksEnabled MicroBlocksEditor {
	return (showHiddenBlocks == true)
}

// developer mode

method developerModeChanged MicroBlocksEditor {
  developerModeChanged scripter
  fixLayout this
}

// layout

method pageResized MicroBlocksEditor {
  scale = (global 'scale')
  page = (global 'page')
  fixLayout this
  if ('Win' == (platform)) {
	// workaround for a Windows graphics issue: when resizing a window it seems to clear
	// some or all textures. this forces them to be updated from the underlying bitmap.
	for m (allMorphs (morph page)) { costumeChanged m }
  }
}

// top bar drawing

method topBarBlue MicroBlocksEditor { return (colorHSV 180 0.045 1.0) }
method topBarBlueHighlight MicroBlocksEditor { return (colorHSV 180 0.17 1.0) }
method topBarHeight MicroBlocksEditor { return (46 * (global 'scale')) }

method drawOn MicroBlocksEditor aContext {
  scale = (global 'scale')
  x = (left morph)
  y = (top morph)
  w = (width morph)
  topBarH = (topBarHeight this)
  fillRect aContext (topBarBlue this) x y w topBarH
  grassColor = (color 137 169 31)
  grassH = (5 * scale)
  fillRect aContext grassColor x ((y + topBarH) - grassH) w grassH
}

// layout

method fixLayout MicroBlocksEditor fromScripter {
  setExtent morph (width (morph (global 'page'))) (height (morph (global 'page')))
  fixTopBarLayout this
  fixTipBarLayout this
  fixZoomButtonsLayout this
  if (true != fromScripter) { fixScripterLayout this }
}

method fixTopBarLayout MicroBlocksEditor {
  scale = (global 'scale')
  space = 0

  // Optimization: report one damage rectangle for the entire top bar
  reportDamage morph (rect (left morph) (top morph) (width morph) (topBarHeight this))

  centerY = (20 * scale)
  x = 0
  for item leftItems {
	if (isNumber item) {
	  x += item
	} else {
	  m = (morph item)
	  y = (centerY - ((height m) / 2))
	  setPosition m x y
	  x += ((width m) + space)
	}
  }
  x = (width morph)
  for item (reversed rightItems) {
	if (isNumber item) {
	  x += (0 - item)
	} else {
	  m = (morph item)
	  y = (centerY - ((height m) / 2))
	  setPosition m (x - (width m)) y
	  x = ((x - (width m)) - space)
	}
  }
  centerTitle this
}

method fixTipBarLayout MicroBlocksEditor {
	fixLayout tipBar
	setLeft (morph tipBar) 0
	setBottom (morph tipBar) (bottom morph)
}

method fixScripterLayout MicroBlocksEditor {
  scale = (global 'scale')
  if (isNil scripter) { return } // happens during initialization
  m = (morph scripter)
  setPosition m 0 (topBarHeight this)
  w = (width (morph (global 'page')))
  h = (max 1 (((height (morph (global 'page'))) - (top m)) - (height (morph tipBar))))
  setExtent m w h
  fixLayout scripter
}

method drawIcon MicroBlocksEditor {
	h = 200
	w = ((2 / 3) * h)
	r = (h / 28)

	bm = (newBitmap (w + 5) (h + 5)) // add a bit for line width
	pen = (newVectorPen bm)

	beginPath pen (0.632 * w) (0.012 * h)
	cubicCurveTo pen (0.562 * w) (0.013 * h) (0.342 * w) (0.046 * h) (0.342 * w) (0.165 * h)
	cubicCurveTo pen (0.342 * w) (0.241 * h) (0.356 * w) (0.337 * h) (0.392 * w) (0.401 * h)
	cubicCurveTo pen (0.316 * w) (0.405 * h) (0.299 * w) (0.410 * h) (0.240 * w) (0.417 * h)
	cubicCurveTo pen (0.282 * w) (0.365 * h) (0.298 * w) (0.313 * h) (0.298 * w) (0.251 * h)
	cubicCurveTo pen (0.298 * w) (0.029 * h) (0.390 * w) (0.013 * h) (0.344 * w) (0.013 * h)
	cubicCurveTo pen (0.298 * w) (0.013 * h) (0.035 * w) (0.087 * h) (0.054 * w) (0.251 * h)
	cubicCurveTo pen (0.081 * w) (0.323 * h) (0.104 * w) (0.426 * h) (0.138 * w) (0.474 * h)
	cubicCurveTo pen (0.077 * w) (0.550 * h) (0.030 * w) (0.620 * h) (0.030 * w) (0.697 * h)
	cubicCurveTo pen (0.030 * w) (0.864 * h) (0.241 * w) (1.000 * h) (0.503 * w) (1.000 * h)
	cubicCurveTo pen (0.791 * w) (1.000 * h) (1.000 * w) (0.864 * h) (1.000 * w) (0.697 * h)
	cubicCurveTo pen (1.000 * w) (0.643 * h) (0.965 * w) (0.395 * h) (0.517 * w) (0.395 * h)
	cubicCurveTo pen (0.554 * w) (0.331 * h) (0.569 * w) (0.238 * h) (0.569 * w) (0.165 * h)
	cubicCurveTo pen (0.569 * w) (0.042 * h) (0.695 * w) (0.012 * h) (0.628 * w) (0.012 * h)
	cubicCurveTo pen (0.630 * w) (0.012 * h) (0.630 * w) (0.012 * h) (0.632 * w) (0.012 * h)
	fill pen (gray 250)
	stroke pen (gray 0) 3
	return bm
}

// context menu

method rightClicked MicroBlocksEditor aHand {
  popUpAtHand (contextMenu this) (global 'page')
  return true
}

method contextMenu MicroBlocksEditor {
  menu = (menu 'MicroBlocks' this)
  addItem menu 'about...' (action 'showAboutBox' (smallRuntime))
  addLine menu
  addItem menu 'update firmware on board' (action 'installVM' (smallRuntime) false false) // do not wipe flash, do not download VM from server
  addLine menu

if (contains (commandLine) '--allowMorphMenu') { // xxx testing (used by John)
// addItem menu 'decompile all' (action 'decompileAll' (smallRuntime))
// addLine menu
// addItem menu 'dump persistent memory' (action 'sendMsg' (smallRuntime) 'systemResetMsg' 1 nil)
// addItem menu 'compact persistent memory' (action 'sendMsg' (smallRuntime) 'systemResetMsg' 2 nil)
// addLine menu
}

  if (not (devMode)) {
	addItem menu 'show advanced blocks' 'showAdvancedBlocks'
  } else {
	addItem menu 'firmware version' (action 'getVersion' (smallRuntime))
	addLine menu
// Commented out for now since all precompiled VM's are already included in IDE
//	addItem menu 'download and install latest VM' (action 'installVM' (smallRuntime) false true) // do not wipe flash, download latest VM from server
	addItem menu 'erase flash and update firmware on ESP board' (action 'installVM' (smallRuntime) true false) // wipe flash first, do not download VM from server
	addItem menu 'install ESP firmware from URL' (action 'installESPFirmwareFromURL' (smallRuntime)) // wipe flash first, do not download VM from server
	if ('Browser' != (platform)) {
	  addLine menu
	  if (not (isRunning httpServer)) {
		addItem menu 'start HTTP server' 'startHTTPServer'
	  } else {
		addItem menu 'stop HTTP server' 'stopHTTPServer'
	  }
	}
	addLine menu
	if (boardLibAutoLoadDisabled this) {
		addItem menu 'enable autoloading board libraries' (action 'toggleBoardLibAutoLoad' this true)
	} else {
		addItem menu 'disable autoloading board libraries' (action 'toggleBoardLibAutoLoad' this false)
	}

	if (autoDecompileEnabled this) {
		addItem menu 'disable PlugShare when project empty' (action 'toggleAutoDecompile' this false) 'when plugging a board, do not automatically read its contents into the IDE even if the current project is empty'
	} else {
		addItem menu 'enable PlugShare when project empty' (action 'toggleAutoDecompile' this true) 'when plugging a board, automatically read its contents into the IDE if the current project is empty'
	}

// xxx for testing blend in browser...
// addItem menu 'time redraw' (action 'timeRedraw' this)
// addLine menu
// addItem menu 'cursorTest' cursorTest
// addItem menu 'benchmark' (action 'runBenchmarks' (global 'page'))

	addLine menu
	addItem menu 'hide advanced blocks' 'hideAdvancedBlocks'
	if (showHiddenBlocksEnabled this) {
		addItem menu 'hide implementation blocks' (action 'toggleShowHiddenBlocks' this false) 'do not show blocks and variables that are internal to libraries (i.e. those whose name begins with underscore)'
	} else {
		addItem menu 'show implementation blocks' (action 'toggleShowHiddenBlocks' this true) 'show blocks and variables that are internal to libraries (i.e. those whose name begins with underscore)'
	}
  }
  return menu
}

method downloadTest MicroBlocksEditor {
  fileName = (trim (freshPrompt (global 'page') 'URL?' 'vm_esp32.bin'))
  t = (newTimer)
  data = (httpGetBinary 'microblocks.fun' (join '/downloads/pilot/vm/' fileName))
  print 'got' (byteCount data) 'bytes in' (msecs t) 'msecs'
}

method hasHelpEntryFor MicroBlocksEditor aBlock {
  return (notNil (helpEntry tipBar (primName (expression aBlock))))
}

method openHelp MicroBlocksEditor aBlock {
  entry = (helpEntry tipBar (primName (expression aBlock)))
  if (isNil entry) { return }
  helpPath = (at entry 2)
  if (beginsWith helpPath '/') {
    url = (join 'https://wiki.microblocks.fun' helpPath)
  } else {
    url = (join 'https://wiki.microblocks.fun/reference_manual/' helpPath)
  }
  openURL url
}

// Pretty Printer test

method ppTest MicroBlocksEditor {
	// Test the pretty printer by loading each example project and then generating its
	// code string. The result should match the original file.

	for fn (listEmbeddedFiles) {
		if (beginsWith fn 'Examples') {
			data1 = (readEmbeddedFile fn)
			proj = (loadFromString (newMicroBlocksProject) data1)
			data2 = (codeString proj)
			if (data2 != data1) {
				showMismatches this fn data1 data2
			}
		}
	}
}

method showMismatches MicroBlocksEditor fn s1 s2 {
	print 'MISMATCH!' (filePart fn)
	lines1 = (nonEmptyLines this s1)
	lines2 = (nonEmptyLines this s2)
	if ((count lines1) != (count lines2)) {
		print '  Line counts do not match' (count lines1) (count lines2)
	}
	mismatchCount = 0
	for i (min (count lines1) (count lines2)) {
		l1 = (at lines1 i)
		l2 = (at lines2 i)
		if (l1 != l2) {
			print '    A: ' l1; print '    B: ' l2
			mismatchCount += 1
		}
	}
	print '  Mismatched lines:' mismatchCount
}

method nonEmptyLines MicroBlocksEditor s {
	result = (list)
	for line (lines s) {
		if (line != '') { add result line }
	}
	return result
}

method cursorTest MicroBlocksEditor {
  menu = (menu 'Cursor Test' this)
  addItem menu 'default'		(action 'setCursor' 'default')
  addItem menu 'text'			(action 'setCursor' 'text')
  addItem menu 'wait'			(action 'setCursor' 'wait')
  addItem menu 'crosshair'		(action 'setCursor' 'crosshair')

  addItem menu 'nwse-resize'	(action 'setCursor' 'nwse-resize')
  addItem menu 'nesw-resize'	(action 'setCursor' 'nesw-resize')
  addItem menu 'ew-resize'		(action 'setCursor' 'ew-resize')
  addItem menu 'ns-resize'		(action 'setCursor' 'ns-resize')

  addItem menu 'move'			(action 'setCursor' 'move')
  addItem menu 'not-allowed'	(action 'setCursor' 'not-allowed')
  addItem menu 'pointer'		(action 'setCursor' 'pointer')

  popUpAtHand menu (global 'page')
}

method showGraph MicroBlocksEditor {
	graph = (findMorph 'MicroBlocksDataGraph')
	if (notNil graph) { destroy graph }
	page = (global 'page')
	graph = (newMicroBlocksDataGraph)
	setPosition (morph graph) (x (hand page)) (y (hand page))
	addPart page graph
}

method showAdvancedBlocks MicroBlocksEditor {
  setDevMode (global 'page') true
  saveToUserPreferences this 'devMode' true
  developerModeChanged this
}

method hideAdvancedBlocks MicroBlocksEditor {
  setDevMode (global 'page') false
  saveToUserPreferences this 'devMode' false
  developerModeChanged this
}

method startHTTPServer MicroBlocksEditor {
  if (start httpServer) {
	(inform (join 'MicroBlocks HTTP Server listening on port ' (port httpServer)) 'HTTP Server')
  } ('' == (port httpServer)) {
	return // user did not supply a port number
  } else {
	(inform (join
		'Failed to start HTTP server.' (newline)
		'Please make sure that no other service is running at port 6473.')
		'HTTP Server')
  }
}

method stopHTTPServer MicroBlocksEditor {
  stop httpServer
}

// Language Button

method languageMenu MicroBlocksEditor {
  menu = (menu 'Language' this)
  addItem menu 'English' (action 'setLanguage' this 'English')
  if ('Browser' == (platform)) {
	for fn (sorted (listFiles 'translations')) {
	  fn = (withoutExtension fn)
	  language = (withoutExtension fn)
	  addItem menu language (action 'setLanguage' this language)
	}
  } else {
	for fn (sorted (listEmbeddedFiles)) {
	  fn = (withoutExtension fn)
	  if (beginsWith fn 'translations/') {
		language = (withoutExtension (substring fn 14))
		addItem menu language (action 'setLanguage' this language)
	  }
	}
  }
  if (devMode) {
	addLine menu
	addItem menu 'Custom...' (action 'readCustomTranslationFile' this)
  }
  popUpAtHand menu (global 'page')
}

method setLanguage MicroBlocksEditor newLangOrCode {
  newLang = (languageNameForCode (authoringSpecs) newLangOrCode)
  saveToUserPreferences this 'locale' newLang
  setLanguage (authoringSpecs) newLang
  languageChanged this
}

method readCustomTranslationFile MicroBlocksEditor {
  pickFileToOpen (action 'readCustomTranslation' this) nil (array '.txt')
}

method readCustomTranslation MicroBlocksEditor fName {
  languageName = (withoutExtension (filePart fName))
  translationData = (readFile fName)
  if (notNil translationData) {
	installTranslation (authoringSpecs) translationData languageName
	languageChanged this
  }
}

method languageChanged MicroBlocksEditor {
  languageChanged scripter

  // update items in top-bar
  for item (join leftItems rightItems) {
	if (not (isNumber item)) { destroy (morph item) }
  }
  addTopBarParts this
  addZoomButtonHints this
  updateIndicator this true
  fixLayout this
}

// Iconic menus

method settingsMenu MicroBlocksEditor {
  popUpAtHand (contextMenu this) (global 'page')
}

method addIconButton MicroBlocksEditor icon selector hint width {
  scale = (global 'scale')
  w = (43 * scale)
  if (notNil width) { w = (width * scale) }
  h = (42 * scale)
  x = (half (w - (width icon)))
  y = (11 * scale)
  bm1 = (newBitmap w h (topBarBlue this))
  drawBitmap bm1 icon x y
  bm2 = (newBitmap w h (topBarBlueHighlight this))
  drawBitmap bm2 icon x y
  button = (newButton '' (action selector this))
  if (notNil hint) { setHint button (localized hint) }
  setCostumes button bm1 bm2
  addPart morph (morph button)
  return button
}

method projectMenu MicroBlocksEditor {
  menu = (menu 'File' this)
  addItem menu 'Save' 'saveProjectToFile'
  addLine menu
  addItem menu 'New' 'newProject'
  addItem menu 'Open' 'openProjectMenu'
  if ('connected' != (updateConnection (smallRuntime))) {
	addItem menu 'Open from board' 'openFromBoard'
  } else {
  	checkBoardType (smallRuntime)
  }
  addLine menu
  addItem menu 'Copy project URL to clipboard' 'copyProjectURLToClipboard'
  if (devMode) {
	if ((count (functions (main (project scripter)))) > 0) {
		addLine menu
		addItem menu 'export functions as library' (action 'exportAsLibrary' scripter fileName)
	}
	if (boardHasFileSystem (smallRuntime)) {
		addLine menu
		addItem menu 'put file on board' (action 'putFileOnBoard' (smallRuntime))
		addItem menu 'get file from board' (action 'getFileFromBoard' (smallRuntime))
	}
  }
  popUpAtHand menu (global 'page')
}

// Internal graphics performance tests

to timeRedraw { timeRedraw (first (allInstances 'MicroBlocksEditor')) }

method timeRedraw MicroBlocksEditor {
  page = (global 'page')
  scriptsM = (morph (scriptEditor scripter))
  count = 100
  t = (newTimer)
  repeat count {
    changed scriptsM
    fixDamages page true
  }
  msecs = (msecs t)
  print msecs 'msecs' ((1000 * count) / msecs) 'fps'
}

method redrawnMorphs MicroBlocksEditor {
  // Shows the number of each type of morph redrawn by timeRedraw.

  stats = (dictionary)
  scriptsM = (morph (scriptEditor scripter))
  for m (allMorphs scriptsM) {
    add stats (className (classOf (handler m)))
  }
  for p (reversed (sortedPairs stats)) {
    print p
  }
}

// Script image utility

method fixScriptsInFolderTree MicroBlocksEditor language countryCode rootPath {
  scriptEditor = (scriptEditor scripter)
  setBlockScalePercent this 150
  setExportScale scriptEditor 200
  setLanguage this language

  pattern = (join 'locales/' countryCode '/files/')
  for pngFilePath (allFiles rootPath '.png') {
    if (notNil (findSubstring pattern pngFilePath)) {
      fixPNGScriptImage this pngFilePath
    }
  }
}

method fixPNGScriptImage MicroBlocksEditor pngFile {
  scriptEditor = (scriptEditor scripter)

  // load scripts from file
  clearProject this
  importFromPNG this (readFile pngFile true)

  scriptCount = (count (parts (morph scriptEditor)))
  if (0 == scriptCount) { return }

  updateLibraryList scripter
  if (1 == scriptCount) {
    block = (handler (first (parts (morph scriptEditor))))
    exportAsImageScaled block nil false pngFile
  } else {
    saveScriptsImage scriptEditor pngFile true
  }
}

// UI image resources

method makeLogoPNG MicroBlocksEditor {
  // Used to generate images for the logo images in both normal and retina resolution.
  // Must be run on a computer with the necessary fonts.

  bm = (newBitmap 276 80 (gray 0 0))
  drawBitmap bm (bunnyIcon this 2) -6 4
  drawLogoText this bm 2
  writeFile 'logoAndTextRetina.png' (encodePNG bm)
  writeFile 'logoAndTextRetina.txt' (base64Encode (encodePNG bm))

  bm = (newBitmap 138 40 (gray 0 0))
  drawBitmap bm (bunnyIcon this 1) -3 2
  drawLogoText this bm 1
  writeFile 'logoAndText.png' (encodePNG bm)
  writeFile 'logoAndText.txt' (base64Encode (encodePNG bm))
}

method drawLogoText MicroBlocksEditor bm scale {
  // Used to create a logo images.
  // Must be run on a computer with the necessary fonts (e.g. MacOS).

  textColor = (gray 50)
  left = (31 * scale)
  top = (5 * scale)
  setFont 'Trebuchet MS' (18 * scale)
  drawString bm 'MicroBlocks' textColor left top
  setFont 'Futura Medium Italic' (8 * scale)
  top += (20 * scale)
  drawString bm 'Small, Fast, Human Friendly' textColor left top
}

method connectButtonIcon MicroBlocksEditor {
  data = '
iVBORw0KGgoAAAANSUhEUgAAABkAAAAWCAYAAAA1vze2AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAF
RgAABUYBwbT6GgAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAKZSURBVEiJrZPB
axNREMa/2U2wCzmIUFCraS499NLWLELD7koOgSIqVGitCKVSWkpBlOJND4LQgyDVmyYbQfAPsHioIiJb
26SXLrQgFMRDzKHtMTVoTLLZ8WC3bNc0yRq/25tv3vvNvHmP8B80NTU1KAiCDqCLiO4lk8nnbl9sFzAz
MzNCRIsAugBIAC7JspwzTXPTyaF2ANPT03eIaAGA4LGqAC6nUqn3/wRRVfU2EX3v7e2NA5ggIgwPD6Nc
LmNpacmdWmTmC7qub7QMGR0dFXd3d58y8y0AdjgcFkKhEMbHxxGNRpFKpbC1teXdtg0g1hIkFoudEATh
IxH1OzEiQnd3NwYGBlAsFrGzs1N3LzMbTQcfj8cHAWwS0Rmvt7e3h1KphHK5fBDr6+uDJEkoFApOMce9
AzskVVUnLcvK4M+rqVcl8vk8KpUKACCRSGB2dhaRSMSd8+TI61IUZYGI5hoV4UgQBPT09GBsbAy5XA7r
6+sAUCOi+8lk8lFdiKqq7wAMtQJwJEkSIpEIiAgAfjDzDV3X3wB1PqOmaTcB3PUDAADLsmDbNkKh0LZt
20PpdNpwvEOdyLIclCQpD+CkX4gjURQfLi8vP3DHDg2+o6NDbgcAgC3L+uUNBtwLIupsA2ABmMxkMq+a
Qb4xs+/TiagmiuJFwzA+1PO9/6STmW2fjAozJ44CAJ5OmPkaETX8oB4VAoHAecMwvjZKOoAoinIagOID
8KVUKp0zTfNns0QCAE3Tosy8COCs22Rmu05nNSJ6u7KycqXVagKapl1n5pcAju3HPtu2PS+K4qlqtfop
GAyOAOjfL2ijVqu9WFtba3g9f0GY+ZkL8JqZJ7LZbNGVY/o58CjIIhFdBfB4dXV1HoD/N9xEvwHaIuvR
gNAXcQAAAABJRU5ErkJggg=='
  dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAADIAAAAtCAYAAADsvzj/AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAK
jAAACowBvcbP2AAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAXXSURBVGiB1Vlt
bFNlFH7O224tUyndnDRsyrIfmwYJImOy9XZ2JnTOGBIhXQxmMTHrBoYEnf4wRA0SE2LUEAwktOyHJiZi
+DKAkGCQQXvBgA2KmulYQtgymSOzGxtb1497/LGPbKO3t58bPv/u+z7nvOe577nvPTkv4QGC0+nMNZvN
OwC8BmApM/uFEJ+63e7TWraU/fASw9atW83RaPQ4gOfnTClE9Lrb7f46nv0DIWTLli0liqKcBvCUCiVM
RPVut/ucmo8FF+JyudYS0UkASzWoQ0II6cCBA7/HmhSZDy1xuFyuOiI6B20RAGBSFOVkU1NTTO6CCXG5
XC4iOgXgkSTMSoQQpxobGx+aOzEvQqqqqp6UJKls8pGam5t3EpEHgH4mr6KiAjU1NVruKvLy8g45nU7d
zEG9GjtTsNlsdcx8GMB4XV2dffny5e8DeHUuz+FwYOPGjSAiDA4O4vr166o+mflls9n8CYB3p8ayuiM2
m83FzFPp82goFPo5Go3OEiGEwObNm7Fp0yYQEYLBIEKhUCLu33G5XG9OPejiMdMASZK0E8DnmPGyFEXR
j42NwWQygWjiwGxoaEBtbS0AIBAIYM+ePbh582ZiixC9uGbNGr/f77+R8eO3vr7eMDw8/CVipM8UTCYT
ioqKAAAlJSVobW1Ff38/9u3bh8HBwWSXHCGi5zIqpLKyssBgMJxn5pVa3MLCQhQWFgIAioqKMDAwgGAw
mOrSJzOWWlardV1OTs41Zi5OhD86OgoiQl5eHoaHhxGJRFS5U2kYB6aMCLHZbC4AxwEYkrG7d+8e9Ho9
Fi1apMoxGAxoaWmBxWJBZ2enGm0obSGSJH0GYDdSLHdGRkZgNBphMNz/DkwmE7Zv347y8nKUlZWht7cX
fX19sdwcSus/IknSMQCvpOMDAHp6elBaWgqj0Tg9tmzZMmzbtg0FBQUAgI6ODnR0dMQy7xJCfJDSjjid
ztz8/PxfcH/JnTKGhoZgNpshxMRp3dLSguLiic/N5/Ohra0N4XB4lg0zX2Hm9R6Ppz9pIQ6H47FAINAJ
oDT98GcFhbt3707vQHd3N1avXo0zZ87g6NGjYOa5Jt8R0YaDBw8OAknmtSRJqwBcApCXgdhjYvHixdM7
YTAYMD4+Hov2RSAQaD18+HB0aiBhIVartZ6ITmAe6jOLxYL8/PxYUwxgl8fj2Tl3IqHUstvtxcx8CUBu
WhEmCJWTLEhEjR6PZ38sm0SKRhGJRA4hyX9Euujt7cXY2NjU4wCA9W63+1s1vqYQm832BgBrZsJLHIqi
oKenB6FQ6BYzV3s8Hl88vma+M3Nr5sJLDpFIBF1dXUEAd7S4cXekurp6LdQ7G/OFciLapUWKK0Sn063L
XDwp429mbtMixRXCzOWZiycl/AGgyufz/apF1PrY5+W4VcE5o9Fo9fl83YmQtT72MY35rICIvhodHXX5
fL6wNnsCcYUQ0W8xapxs42Ov1/shJv7iCUNLiDyfQph5hyzLu1OxjSskGo0+S0SM7PeIGcDbsizvTdWB
aoB2u/3hSCTyD7JY6QIAEUUVRWmQZflYOn5UdyQcDj9NRFkVASAohKjxer1X03UUL7W6mVkhoqx0I4no
DoBVFy5cuJ0Jf6pBEpGTEujDpAJm/kun0z3h9XozIgKIsSMrVqzIXbJkyX4ATZlaZCaY+QdZlh2Z9jtL
SFVVVb5OpzsCoDbTC01iryzLb2XD8XTqTN5fnACQUH1FRFFmTrR50Q3gPZ/P903yISYGHTBxhwHgLIAi
FV6EiD4CcBtADoCf9Hp9IzNfxcS1Wcw2KTNfE0LsCAQCzX6/X7PwSwdUXV3tEEJ8D/UT7F8hhPPixYs/
qjmx2+3F4XB4JRE9DgDM3JeTk3Olvb09ZlswGyBJkq4BeEZl/kY0Gt1w+fLlP+croFQhoNJoI6Kzer2+
8v8gAgAEM5+PMb7XYrG81N7envSty0JBz8zNk4XhCwBuEdEur9d7ZKEDSxb/Afpz63umivdIAAAAAElF
TkSuQmCC'
  if (2 == (global 'scale')) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method startButtonIcon MicroBlocksEditor {
  data = '
iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAYAAADAQbwGAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAJ
egAACXoBD0XXIwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAFWSURBVDiNrdM9
axRRFMbx3x0GjaQ2pDCFRcxK2pAitpYi+QIpjQoWFoJYKbFML7EIhHwDYyobi7yInca4d0FBhC3WWKUJ
a0KYFJuVQTa7M84+3XnO4X+fw72XhgfqPoru+2FERSWYE8xiRdtP0ZMq4ERmPFePYVnbN9Gi99LywOBq
D/8aXhv3ScPdsgmv9OlPy7wRbYvmigG5VGDuFnZEb30xMQh4ucjJ57ojFUUvfO0dpGjCvEbxXGJP3e1h
ALuaErzTsO67sWEAIcgsOLGvbr5jRKfn4GFoaVigrrIUx1T+wweCe2o2EvypkghrEtNqNiDFyX/CPks8
MmU7byY6K5fRoeCxlpl/Yd2EZVbelHpoUvOige6l9FewJfPUTR8GjaY46tPfxzM1mwMPzQF/9/CbeKlm
VXBaFNYBBr9kf+sWlo145bp2GVA+4S5uYFVq3WSld+kMPTFR1LOrihUAAAAASUVORK5CYII='
  dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAACcAAAAsCAYAAADmZKH2AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAS
9QAAEvUBKRJxDwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAALKSURBVFiFzdjN
a1xVGIDx3z25UZoS8asqiuhC0klSBP+GFupCcOXSL4SgKFmEirgQdddSSqkipRRKLHbjSmihEQtudOdC
Jc2dmCAo+BXRQG0j6jjHxWTayaQx83Hv3DxwN+ec951n3veeM/dOAjKfY1jiHM6o+MMOILFkj5qVlrEr
mBUdNuGnssQgqNvbNnYbpiWWZU5Y9EAZYhBE920xN4Jpdd/KnLLsnkGK0ajcdh96C6b8Y1nVYVWjgxCD
ILGnw7WjotdEVVUv+sJwoWYabb23y5j7RSftNq/qqUKs1gmCO3uMHRN9KDPnsslcrdYJopE+cxwUfK3q
bN6bJkj6lmvkiZ5Wsygzk9f9mEflbhDdjmN2m5c52G+6QI5yNxjDnMx5Cx7qNUlRck2ekFiQecuSW7sN
DthVgFQrI3hTzZcu299NYKD7b9QjFcElmfdl7uokICAtWKqdZ7AkM7XdwoCh4n02cQdOyVyUeXirRWH9
KovHMa9qWpS0TyYya4rfFJ1wSeJZFT82B8pq6804IPpK1ZPNgbLb2s7doo9kToiGEpk6m/tdOtEHO6lq
GwliwL9le7QRcdxez6eol23Twq94wbjzNH4ddkrlPpF4rvUoSVErUQiu4nUV70nE1omUjQMDJbqIl0z4
7mbTZbV1RfSqCWf/b9Gg2xoxq+6QSb9vtzjFX8U7gQWJV1R82mlAwFqBQtbzv63usW7EaFTuz2KcwAV1
L5v0fS/BqWIq9w2mjfu4nyRBkqvcqmjGNfv6FYNUzEWuhjOGveGRDf+S9kUqsdbnMTxnyIwxWU5O10nx
W4+xizhk3IUcfTYQxK7b8AOm/GxfkWI02rrSYVtXRUeMeseDhR4/10k7qNyaxLv+dsSjVgch1SQV/LLF
4+Y1idM42vqMNUhS9U277IrESdFRlZ43Sy403royn2m8v55TN2vS1TKlmvwHLHW8gYqPdl8AAAAASUVO
RK5CYII='
  if (2 == (global 'scale')) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method stopButtonIcon MicroBlocksEditor {
  data = '
iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAI
+gAACPoBjcM6MwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAACFSURBVDiN7dU9
DkAwGIfx5zW7Re9lZpE4iY+NweBcnIK9pjZVEgnvxjO2yW/rv0KUBVmgBrL4LmoyUAnY8FAusAYobzDX
YCAPUQ8+wC5ReYmdUFHAjugMrQLm6mSGFUiVwC1Rgnw/+BVwVPRGzafXGyi0xsFhVmO+PAbvB/aAncAA
ffwF7ItnNpUpNqZKAAAAAElFTkSuQmCC'
  dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAR
8wAAEfMBmr+RUAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAIaSURBVFiF7dkx
TxRBGIfx39wqh1fZ2JBQWFDZ8gWUGDUIBDWCojHxgxkIMSGCgIKCBuMXsKUCtMBQ0ECFnHiuxR16HHvr
GY7bM+HpdubNzpPZyebd/wYN8pFz3TzD7YTpiwg1YzF2E2oXN3l6lR+NrFt700RionUmAmON1Dew6MwO
D3s5aKA2nVU68kxhuBlyVbyJudtDMa0oVbAi9wJDTVX7w1LEncvs1yuoK7hGHjMh+cw1k3d5hrv5ljSZ
SxrcohB40wI5uFFkYYtC0uSxHdzkQpFFXDt1taN8yDNQu5NHdnCVjiLTWi8Hffu8+kJn9eBvwVU6OplB
f8vVKgSul5irnH9UBGOiPJMxA1nJVXEzMPWJ8xBiog0m8SBjsVpmNxkJ64zjSdY2dZgI62zjUtYmddjO
xURZW6QQ5UK7CzoTPBFngiclyqnT0bQJUTvLobx7P7OWSKGUQylrixTOBE/KfyAYt7tgaHdBvM3aIoWl
tm35Y15+ZTRULqINnmMkY69D5ne538tBDgKlXR7jdcZisBwzeph8HUkWKmHRrIy+jQPvcwxVh0nHoo81
8oE53GqpHSt5Bmujj8R0a4vCXvlx97VEjZUCQ13s1U4ktltd7MX0BxZO381ynsEkOVKa1R6K+9zD/Kmp
lQPMutkgf+mmr/C9WH71zDbbLGYxZjgtXeUfQvTPjMc8aoZcYHqHsaaE6Idk9RviFzG4jSVrWs+wAAAA
AElFTkSuQmCC'
  if (2 == (global 'scale')) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method projectButtonIcon MicroBlocksEditor {
  data = '
iVBORw0KGgoAAAANSUhEUgAAABAAAAAWCAYAAADJqhx8AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAH
6QAAB+kBlHo8QAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAEbSURBVDiN7ZSx
aoNAAIb/hGsqlRZBChWbQicnB3c79AXyEKV5Axdx9w2cut3iEzi2QnFyL9TD1qWTgoNBQ0jQDoXSpOYS
2jXf+v//Bwd3NwAH3/fHs9ksopRebURLABEh5I5sG3ued2EYxkuWZac98RGA29Vq9TDsG1uWdS1J0pum
aX3jn9z8EjiOMy7LklVVdbJjDADHawLXdc/zPE8ZY1uPtsl30bZtOU3TD8bYCAAEQdhfQCkV67p+J4SM
VFWFKIqYTCYAgPl8zheEYSjIsvyq6/pZXyGKIr6gKIpYUZTLJEnWgqZpEAQB4jjmCgamaXbcxg5678FB
cBD8RbD4x34xBMB/LXyeh4SQ+67rnvD1Ue7LEsBj27bTTyA4XCa7dVryAAAAAElFTkSuQmCC'
  dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAACEAAAAsCAYAAADretGxAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAP
0gAAD9IB+4k7yQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAIrSURBVFiF7di9
i9oAGAbwJ7lrC6IHVuxdS40UgoJIXKQZjNCl0L+lmxQRyXCCkK2HSwYHb3IWHPQ6lvqBXHEpiF81LUlP
QTBwyE1K0inQw35EE7FDnjHJ++bH+yYQQsBiisWiy+fzfS4UChGTJUsAHQAXzWbzAwCQVgCiKLpZlv0a
jUbNAgDAA+A1gCuO43KWEKIouhOJxDgWiz3dtQeAc47j3hzvUlkqlTzxeHzEMMyZBYCRd1tPIpvN+rxe
7zebAADwcqtJpFKpx6qq3iyXy0c2AQDgxPQkBEHw393dTXu9np0AAICpSQiC4Jck6cdgMHhoNwAw8Xbk
crlnk8nkZl+AfyJ4ng8oivJ9OBw+2BcA+Ms6eJ4PzGYzaTQabVxDEMT+EZlMhppOp5PxePzb8xRF2YrY
WEc+n38xn8//CGBZFslk8t4xTdMsIe7dqFKpPHG5XF8YhtkAkCSJQCAAhmE21rFYLOxBVKvV00gkMqRp
2r1tk06nYx1Rq9XOQqHQkKbpk20bSJKEer1uCUGWy+Xn4XB4tAug3+8jnU5jtVpZQhyv1+uWLMseWZZN
Fei6DlVV0e120W63LT+UAEBwHKdb7mIxlr6s7IqDMOIgjDgIIw7CiIMw4iCMOAgjDsKIgzDy3yCWBzbc
kgCuD4y4JnVdvzikgCCI90eKoowpiiIAvDoA4LzRaFweAYAsyx+DwWAHwCkAPwDbf479kluCID5pmva2
1WpdAsBPdzu15+Xij+EAAAAASUVORK5CYII='
  if (2 == (global 'scale')) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method settingsButtonIcon MicroBlocksEditor {
  data = '
iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAH
OgAABzoBqsXEHQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAJ1SURBVDiNpZU/
aBRREMZ/c7tXbBoVooFAWiNaXmO4XYwhCfgnEMXTRuxTxiSIvZWK2qW2sAoSUUlhUA/yHmqRNqCtYDwU
tErA8/JZ5E7ebVYv4lftzJv53puZt98z9oE0TR8C19rmhnPuRK+cUq+AWq0WAVOB63i1Wh3ulReHRrVa
HS6VSvckLTrnngM0Go0qcCiXdwZ4D5Cm6Xkzm9nZ2bnuvX/fCbDOR5qmR4HXwGDb5SV9NbOzQDlkNbOW
pKeSDpjZWNvdMLOxtbW1ja4Tm9l9SYNBftXMKIKkCLiQWx8A7gDnIOixpMVCln9AyNG1ZZqmr4HRgpzP
kt4BmNnJ9unycM65rGN03QpJ33LBLUkLcRwPee+nvffT29vbQ2Z2A2jlYr+GhgGMjo4ebDabk2b2iKDv
kha893cLTkeWZQuSbgeupqSr5XL5Rb1e/25pmq4Cp4EoX34cx0P1ev1nEXGlUiknSfKRvW1pAa9KwHgB
KcDbP5ECrK+vN4E3BUsRMNHzz/sbJBXfR3aHt8reQQCMVCqVcoEf2G2FmY0ULLWA1ZJzbjKO435JV4Cw
9IG+vr7ZPxEnSTIHHAlcTeByHMf9zrnJrlKyLFuWNB3ubmY3t7a2HrR72hnaHHCL7tksO+cudowuEZKU
F5tI0u0kSeazLHvbjhkBDhcU0R8aoQidB54V1r1/THVU8fetMLOZ/yTt4ghFaBb4FMR54ImkHwUcLUmP
gZeBrwEs7CF2zn2QNGZmK+yWlDrnLkRRNJFnlTTvvb/knBsHpsxsRdKpjhZDTt2KUKvVos3NzS8Er4ik
Y+FrUYSef97S0lKL7qFu9CIF+AVCxv2ly3PtJwAAAABJRU5ErkJggg=='
  dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAYAAAAehFoBAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAO
egAADnoBz63/KAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAU+SURBVFiFxZld
iFRlGMf/z3tmRmiZAdOirHYEvSlv9KIVnPfAZNvqFOESCJJkGBhZGlokZBkUUUhgWWYFlSREgQUV1ZrZ
NrLvCHpRXbTd5IJOCRukwoyrzOzM++9ix9idOefMObOj/i/P8/U7H+/HeV5Bl5TNZhfWarVfAMxtMlmS
LxYKhde7UUd1IwkATE5OPoJWWABQIvI0AOlGna4BA+gPsN2SyWTu6kaRrgAPDAz0iMjyIB8RCbqh0Iq1
sYvrus9Za0upVOrA0NBQxcvp8uXLWQBz2uTqB7DXy5DL5eZcvHjxMQDJkZGRNwDQL0nQExat9T6Su0Xk
vXK5/KfWeoNXDmvtw21gAWDl4sWLW25Ka/1guVweJbmf5G6t9YdBXH4DQbTW+wA82WwgOayU2l6v18eV
UlsBbADQGwIYAP4h+QHJd0VkrlJqD8n7Pfw+NsZsAmDDAPvCToO2ImLR/pPy06SIKJJOgI8ndEuA67o7
AOwMqiYigtkNWCdE/LJ0Oj1RLBaPT7/YEmStLc0CpKuy1pabr7UAp1KpAwDGrglRsMYaLDPU8kmcOnWq
nk6nzwBYd02wfERy4/Dw8B/N132XS631YQCrriqVv34yxnguNL6jXCm13Vr7O8IPrgmShwHklVJ/A4C1
9nYAWRFZDaAnTBKS1nGc7X52X+BKpXI+Ho/bEMB1AHur1eprJ0+ePOdh39fX1zcvHo+/0NgEBU1lEBFL
cjwycDwe3xJkb6hEcl2hUBgKcmrcyDOZTOZHEfkcQCrAPQZgK4CXvIx+T08wtYIFyQJY3w52ugqFwpC1
di2m3kqQHvVj+3/QZbPZWL1eX06yH8AggKVtku4xxjwbFna6XNd9k+S2Nm6/AfhKRI46jnMin8/XAEAy
mUxOKfUEySyCX9V0TVSr1bTPN9tW2Wx2fq1WO42QAxFASUTy1tr3RWtdAZCIWPMLY8zaiDEzpLX+EsBD
EcOqCtFhQfJY1JhmiUi+g7BERxuYK/PsbGStPdtR7U6CSM76h1Ip1VGOToFv6ySuGzkUgGoHcdlOijXp
ng5iKorkoIh8AyD0PlhEVvf19c3roCCAqWkNwH0RQkoNxsFYY6Uairhw9CQSiZ0AOlo4arXaLrSZg0Xk
V5Jftywcfv5a69MI/rm0ANYYY76NAuu67iqS3yFgEyQixZGRkYXw+N33G3QUkU/a1FYAPs1kMrkIsA+Q
PBQECwAkD8CnN+E7taxYseJmx3HOkmy3Y6uLyDuVSuVVv6W6sRTvAvBUCNjJeDy+IJ/P/+tl94VxHGc+
yTDTnkNyWyKR2KS1/gHAMQB/NWx3AMjWarVVAG4IkQsAHGvtrQCiAZPcg2jzdA+m9gZR9wczJCKqXq+/
BeBeL7snkOu6g7h+/3MQkZWu667xtDVfyOVyc8rl8iiARVedLFhjyWRySXMDsuUJN7qI1xsWABaVSqWN
zRe9PonkNYAJJaVUC0vLFFMsFo/39vbeBOBuv0SNZmAdnffXJqfac4HxHxljdqJpPvYKoDFmC4D9PrDD
juMsFZEFJF8BcCYC6DiAl2Ox2AJr7RIR+T4A9nGEbLf+b2tqu44BeN4Yc6jJT7mue5Dk+jawExcuXLhx
dHR0xu5Qa90P4G0Ad7aDBYJfCY0xW0RkB8nNyWRyiQcsGok/awMLAD83wwKAMeZoMplcRnKziOzwa2Rf
UVeOogYGBnouXbp0DsHnHNuMMZ5nHFHUlVOkI0eOTJA8EeRD8mg3anXznC4IaLxQKLS0TjtR14BJHgRw
3sNkMXXc5XuUFUX/AfHiFId5ScXEAAAAAElFTkSuQmCC'
  if (2 == (global 'scale')) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method languageButtonIcon MicroBlocksEditor {
  data = '
iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAH
qAAAB6gBuRybzQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAANXSURBVDiNlZXd
axxlGMV/z8wkrMZNDRRlNbdqQQrFoDXZeWHRJmJiRXrhjSB6IxXphaAgSKshopGCF+K3f4DI3pS2KqZV
w84sKdFFxAYpih/UYnrlNonZfMzM8WJnZbMEis/NMGfeczhznvd9XmP38sIwPAocBfZJ6gMwsy3gkpm9
F0XRR0DWS7RewDl3TNIbwEAObZpZIskkBWbWn+NrwEtxHL+7w0n3SxiGn0t6G0jNbMPMPm21WsUsy85L
OtdsNotA1cw2cnfvOOfO7ipYLpe/Ah4GvgBqkn5PkuTpRqOx3VmztLS01Wq1npL0h5nNS5qTNBWG4dwO
wXK5PG1mD5jZYhAEbwFTZnZ8YWGh1RtJo9FYl3RC0uEgCGaB74Bx59xxAKtUKoUkSa7l4kHOy4DvJV0z
sxVgpKMnadDMbgYOdAyZWZplWdrX17cnSNN0BuiXNGVmC8ACsArUgEFgD1DIBbeBX4EVQJIGsiwr+75f
NrPTSZK8as653yTtjeO4WKlUgiRJViU9X6/XP+jK9xRAvV5/rKuBzwEnS6VSsVqtps65NUlXPUm3ARcB
Njc3bwUKZvZLb3a9lWXZz8ANy8vLt9C2exEYtjAMJemKmS0CReAQMA/83cW/P39e6MKGgApwPo/oIFDy
AF3Pzf+pANg2s8txHB8ZHR293ff9PyW9Xq/Xz3UWdWV4pIONjY1NeJ5XMbMnoyj6KwzDC8BeD7gC7AcY
Hh5eBtbN7I7rOTGzO4F/oii6mkP7gcvmnDsp6QUze2R9ff2bQqHwred5TUlf0850EHgoJ31JO69V4EFJ
xYGBgYNra2uHPM87Bcx2b2yjvVF92rleoj0AmsDdueCSme3JsqxoZnflnJT2QchKpdKgNz8/vyHpNaAP
+CFN08M5+UQcx/fGcTwuaVHSYhzH41EU3ed53jSA7/uTwI8595Vqtbrl5WHP5L94j+/7LwNngZmRkZEb
e7ObmJgYkDQt6XSapseAA5Lm4jh+E3rmoXPuM0mTwIqZ9Us602q1nigUClWAZrP5+NDQ0CfAJO1jWATO
xHH86H/N6nWQH6lZ4CZJnSmd5J8DoD/v8qqZvVir1T7c0f1ewbw859wzkp6VtK8zpSVtmdlPnue9X6vV
PmaXK+Bf79GQ6SIwG1kAAAAASUVORK5CYII='
  dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAP
UQAAD1EBcwOWNwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAf7SURBVFiFzVh9
rFRHFf+d2bvvLoSPpAVKkYpC2iJRAZG8vr1zl9UASkla20Aq2EZpaanRqH+ALabaNLFSS/1KNC2WSqpA
ra+GaFMw6Kabd+fuFpQGW6lIILUC9hX6oPCKb/ftvXP8Y+c+hmXfJ8/EX7K5cz7mzO/OnTl7ZggjxIIF
CyaNGTPmHgC3AJhDROOZWQAAEWlm7iaiQwB+H0XR1nK5fGYk49AwSY3NZDKPEtEqANcMayCiTmbe4TjO
Q8VisTKqBFeuXNnS2dn5LDOvAOAMh1gTRMz8/LRp0+5ub2/vvWKCUsq7AGwBMKZpAKJzzPwjZj5JRE8D
ADPfK4S4jpm/AWBCs37M3JNKpdZ2dHTsHGh8MQi5XQB+2UCuarUPxHF8g1LqEQA1S18LguDh3t7emQD2
WS9TtdpjtNY7fN9vHwlBx/f9vwL4nKV7D0A7ANfIrzLzp0ql0qn+gu/fv7+rVqstBXAQAJjZBfACgHOJ
DzOvkFIeRD9LpxlBIaV8jZk/niiIaDczSwC3G9UFZl4dhmF3f+QS7Nu373wcx6sA/MeobqtUKpKZ91pu
c82EDE5QSlkA8BFL9d0gCJYLITYCSBnCG8Mw/Mdg5BKUy+XDADYaMZXJZL4ZhuFniGhT4sPMc6SUfxyQ
oJTyAQB5q9N3lFLfzmazs5j5DqM+fubMmS1DJZfg7NmzTwH4lxFX53K564Mg+JYQ4hHLbXEul1vflKDv
+9cCeNSyHSei89lsdqEQ4mu4uEYeO3To0KDpoRGmzw+MmIrj+MvZbHah1vosgBOJn9b6saVLl05J5L40
4/v+fmZeOMg4MRFtZ+bjAE4DOM3MVSI6z8xLiWgDADDzZiLay8wTiMgFMNn8PsjMdxLRgNmDiMpBEGT7
CPq+P4eZD5ngIKKTAD4wlJkZRXQCmJpwyGQyNxYKhSMCALTWT1qOHUqp6Y7jXMfMdzKzsmw8CkTsGAER
3QVghlLqWgAlACAiVKvVp4D6unKIKJv0yGQy9wJAsVg8AWCHlDJJLXAcZ6bWOo6iaGoqlZrCzFMApAFk
AEgAK41rOwAFoAKgRkSn4jg+5ThOZ0tLS7pSqRwzfu8EQbDdin9PFEV/N6IEIBzzV5ZsgBOFQuFIwxvP
N893i8XiP037eOO0eJ53johWAgAzvxSG4bP9TaHv+13MfDURzbP1xWLxsJTy3wCmAUjncrnPCwB3WD4v
2h1aW1snAPiQEZsm0pGAmV83z5n5fH5cg2130tZarxLM/FHLfslbu647Axd3+uHRIgjgDfMUtVpthm3Q
Wm+zxHmCiCYZgZVS+xqcJyZtZu4aRYJ9xWsqlZpoG8rl8iu4uJEmOQBaDIHI87wv2M5ENI+5b9PNarQ3
oM1ue54X9eeotZ4lRD0VxnF8m+d5H25wiVDffC0kpRyN1PE/w4AZ/f8BDurfm5i5BmCNbRRCzGPm9QDA
zDsB7L48RB98IlpnfLcACPpzJKLlAFYZ381oyBBEtA1Ampm1Q0RVZs4QkaOU2mE7SinfArDekD0WBMEl
dhue5zkA1hmxHIZhv75Syr5yjpl3lUqlsmUWUspfGaJVobVOdid5nneTHUgIYVe+V/U34AjQF4uIztuG
fD6fxcXU1iWI6DXL+UsNBN8EoA1Bu4i9UswxT51Op9+yDVEU2cvsoGDm5y3Fctu5WCy+D+BNQ3buKBJM
jhNHzRg2liWNVCq1k1D/5lWY/2PXdW+0/4+llL+FOYvEcTzddd0urfXkKIqmCiGuBjAeAEw9uNa0txJR
cubo1lp3OY7TKYQ4rbWerLVOKusXlFJJgYF8Pj/bKhZqSqmMg/onDAEsAoBqtfoMAD+fz4+LougmZh5H
VF8SQogjURSNNe1LXjvxMe21ANYmshACWmtorUFEF6xu4z3PW5JOp8vFYvH9OI5/kRiYOQCgLytYDd4A
cAOu/BZhqIgAHAUwO+Hnuu7sQqFwpO+1pZSvAGgdKAozayHEHq3120TUiXrZXyGiXmb+JICvGNefEdFf
mLkF9VpxMjNPFUJM01p/drCSH0ColJKANUOu695arVZPwhwtUT9vPC2EKDHzLQDuIyKhtf5DGIY/bYzo
eR4nn5mZ/6yUuqwelFJ+nYhuNuKTzPyiKZbvB5AULVFPT0/fhUHfmxQKhXeEEA9a8SanUqlaEAQvaa0f
R/0zgIgeWLZsmYthwvTZYMQ4juMfhmG4x8gJOTDzhgMHDrx7GUEA6OjoeALAnxJZa/2wlHJTqVQ6xsy/
Nurp3d3d6zBMdHd33w9zECOi7eVy+ajneY8DeMhy2xOG4Y/tfpetBaXUkoYN86CUcm+1Wv0+gNjoNrW1
tc1u7NsffN+fA+B7Rowrlcpmz/MKyTHVkH5dKXVzY9+mizUMw3kwFz4GSzKZTEhEu4w8Vgix0xwJBsTi
xYsnmkJjLAAw8+9c1y0R0actt1eDIPhEs/797aZIKTUfwG8s3QRmXpFcoRHR/HQ6/XI2m53SPATQ2tp6
TU9Pz8sA5hpyvUR0O6w7Q631c0qpBTBrvBGDXmAuWrRoVRzHW2FmoAnOE9FPABxn5p8b3Tqt9Qwi+ioR
NZ1lIrrAzGuUUgPeDw71jtrJ5XLPaK1X48qTdw3AdqXUfehn1mwMtaKOOjo6vug4zngiesIk6eHibWbe
7DjOBKXU3UMhBwzzlt9GW1vbVel0eo3W+lYAHwMwDheTfAygG8DfmHlXOp3eViwW3xvJOP8F10V9BVup
s+gAAAAASUVORK5CYII='
  if (2 == (global 'scale')) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method graphIcon MicroBlocksEditor scale {
  data = 'iVBORw0KGgoAAAANSUhEUgAAABgAAAAWCAYAAADafVyIAAAABHNCSVQICAgIfAhkiAAAAA
lwSFlzAAAKkAAACpABL6VQZQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAMLSU
RBVEiJrZVPaBxVHMc/b/bNZHtYk01MnIZYUohFTVzbxNBbCwXxYObS4sGLWFvYgydbK43R5TUmYMHutR
baXkTIoYey7oZStM2hBD1EF3PomiZUs6FLsgfJkj+QmZ3nYXfCmiZ0W/Z7enx/v/f9Pt7vO/PE0NDQZS
HEZ4BJY+ECSVkVd4UQfzZSXWv9BnBOUjn5bCqVeqeRBo7jzAD9xosKKKVO7MK9PDo6+nYtJxzH0cDvoV
DolOd5++sRtyzL7Ovru10sFs/n8/lcwMdisYumaQ6VSqWT8/PzCaBfBkXP87qFEEfqMejo6DhiGEa0ub
n586WlpesAbW1tByzLcra2tv6em5srGUblcrYN0un0FDBVj4FSagogHA6/OTg4+MD3/RlgGvAtyzqZyW
SyjuMA8NwzUEq9DhwDsoD2fT8hhDgDHAWuKaWytf17GiilPhkfH99tJnFAABeAFPC+1vo7oNjU1PTVzu
a9DATwheu647VkMpncB3wEPFJK/QKMVksvAV8ODw//+5RQkKJyuXxGSvkaQGdn51u2bX8N6Hw+f7FYLD
4G6O7uPt7a2vrp6urqDwsLCz8B9Pb2XpBSRmdnZ0d839cAnuc9CoVCN9jrO4hGo+8BGsC27Y8DPhKJvA
u4hUJhKuBWVlZuLS8v3wjEd2I7RZOTk1kgOzY29qrnef3APWDRNM3TAwMDaK3/Ag4BP05MTNzcTawWQY
rkzoLneXFACiGuSimnXdf9QGt9mWqEDcO49izxWvzvipRSFnAWeGLbdmpkZKQghPgWOAicBh4mEokHL2
wghDgFvCKE+D4ej7sAkUgkCfxTrV+lOpt6sZ0irfX5WCx207KsA7lc7pv19fVS0NTV1XW4vb39w1wupz
Y3NzefJaq1/kMIcYXaf1FPT88+y7IOuq7789ra2t3aDYuLi7+Fw+EnGxsb9+s5tZSyUC6XK+uAbGlpmQ
EumaZ5J51O/7pzUyaTma5HPMBTKVJKrQDqeUTqgXAcZ4vKk/mwkcLVJ9OUQBI4p7UeaKQBlUf/yn/9gR
oIgZwg6gAAAABJRU5ErkJggg=='
  dataRetina = 'iVBORw0KGgoAAAANSUhEUgAAADAAAAAsCAYAAAAjFjtnAAAABHNCSVQICAgIfAhk
iAAAAAlwSFlzAAAVEgAAFRIB84QXFQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoA
AAW1SURBVGiB1ZlbbFRFGMd/s+esuLtt3W2k9QJViUobg9HUqC8aEjVKwmrjJfqgMV5Q9KEalVbTFj52
BR9UDA0mgFJjvNcHwSWYGA1eiCZqjAmhGFDAKlJTKk27rNXuOeNDz8J0u1d7k//Lnu8//zP7/zJzZr4z
R0Wj0TO11iuUUvcBczk10A90AS/YnvmW2XZUJuYCrQA+pdT9s2xmMrjfBs40iB+BL2bJTKm4Fqj3rufa
WY27EonEwzNsqCxEo9FXOJkAvln0MiWYjQSUiNRNVWfZU2jaISLXAQ8Cd5WgbQJu8/v9LW1tbUdyaWZj
BJYDd8RisUsKiUQkCLwE3D06OvqjiCzPpZswAk1NTeF0Oj0tS2swGKwEmgBfMpl8c+nSpW/k0w4ODt4U
DofP98KqgYGBG5uamt51HGecLtcUCiulmqfKtIlIJHIGYAEEg8HLKioqao4fPz6arQsEAnZVVdU5mXhk
ZGS0t7f3cqVUOFs7IYGtW7ceAs6fSuMA3d3dVk9Pz8/ACRP19fW7ROTObK2IJIBzvVAHg8Ebtm3b9jlA
NBodp52xZ6Cnp2cJcF4WfXssFltkEqtXr74RWGpQ76xcufLzfP3O5EOca4P0ua7blgk6OzvnaK07jfZh
27YL1mkzkoC37i8xqL+M6xMr0rFjx1qAizMNSql4e3v74UJ9z9QILMN7eD3cBaQzHlzX7RCROq11q6HZ
H4lEzNHIif+UgIi0iEhJ927atMkPPGBQO0XkQ+Adg7sDeA8IGdyjzc3Nfxfrv+wEROQsIO69ABVFX1/f
zcDZBrXR+41hjAJwtaF5X0Q+KaX/shNQSi0DTtNarxWRqmJ6rbX58PZXV1dvAxCRnxg/ChmkbNteUaqf
shIQEVtrvcwLa4BniugvBK43qC1Z0+JZYPzWCmva29t/KdVTWQkopaLAfIN6PB6PX1DglocA5V27lmVt
NhtFZB/wtkHtr66ufrEsT9FoVBvxq47jdFiWtT6XuKGhYXEwGKwxueHh4V/37dv3dbbW5/P5Fi1aFLVt
ew5AKpU6snfv3i+zdcFgsKKhoWEJoA4dOvTlwMBAzqoTwHGcxyzLijNWzY79T9EUPYRCocpAIFCTzVdW
Vs6PRCITTjNqamrmZ8wDHD169ECuflOpVHJoaKg3mUweLmQ+HybUQjt27OgDctUn6zm5GTmMrSBzABYs
WFAFXC8irqE3t//f6urqFnd1daXJgXg8fhGQTiQSB4sZzq6FSnqhEZEK4F6DSjB2APC0Fzcqpe4FXvMM
NTiOc42h3yIiOc0DdHR07C/FRy6UOoXuBs4w4pcDgcBa4MSQa62fyyyrjuMs5+TD6zB2CDUtKDWBR4zr
n0Tk09bW1mGl1CqDrwVa1q1bFwDuMfiEiPRO1mg+FJ1CsVjsGtd1L83ESqkNgAbQWm9hrMps9JqfHBoa
coCI0cWmqbM7EUVHwHXdR43wuNb69UwgIq5Sytw1TwdWGvFB4ONJuyyAggl4dc+tBvWWiAyamlWrVu0E
PsjTxWZzZZoOFEwgU/cYVL7p8BSQXTn+4/f7X5uEt5KQNwGv7nnIoL4Ske/zaA8A2bX71ra2tj+mwGNB
5E1AKXULMM+gXi7UUSAQiAN9xv0bC8inDBNqIcuy1jiO81l9fX1tKBQ6HSCdTju7d+8+7LquztMPALW1
tZXz5s2rHhkZGd2zZ8/vU23WsqzFjuO0YdRCuZbRwXA4/F4oFDqxuiSTyZ2O43xU7A/6+/t9tbW1T6RS
qW+01tNxTD+YTeQ6FxoUkQDGThoOhx/Yvn17SZtRY2Pjt36/f3dnZ+efk/OaG6XWQruAq4Arge3l7KSF
znCmAzkTEJFuoFtErgD+mUlD5aJgKSEi382Ukf+KU/4LTfYyeqp95MMGjnLyS2W92XgKoN8HbJltF5NA
l7Vw4cIfGKvvFzL+aO//jH5gg23bz/8LsSjXmhMY0ssAAAAASUVORK5CYII='
  if (2 == (global 'scale')) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method zoomOutIcon MicroBlocksEditor scale {
  dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAACXBIWXMAABx2AAAcdgH7OYqmAAAAGXRF
WHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAy5JREFUWIXN2EtoXVUUBuAvMU0Uan3Vtj5A
FFqtigNtpa0jpT4gOnCggtDSgkMfOFHEgUUQCk7EFkQdtBOtYBxWMSNBUetjKlofQSltBtKmRmxq08bB
ziXnrnvuPY97LvGHPdgc1r/+vdfae691hjSHy/EAxnEzrsMazOM4pvEtDuNz/Nug7564FRM4h4WS4zRe
x1WDFLYaB6QdKissjhm8jJGmxd2B3wqcz+EPKbxFi5jElU2JewSzOU7O4UPsxDXBZhi34Hl80UXkz9jQ
r7jNOJND/gHWV+DZLh2YPJG1d/JaHAuEZ7CjJt8I9uWInFQzJycD0d/YVlNcFs/miHypKsn2QHABTzQg
roU3A/+MCqEewpFA8EaD4kgh/S742FvW+O5geNpgLtj7g59TWFHG8NVg+NoAxLXwZfB173AJo4fDfKJp
VRl8FObjRQYjOG9pRcelnBwUNmrfwc+K7pu10ivQwk+Lhi1cJr0sdTGnPSJHpQ25aHEeX6QObNK+okPh
+23he9XxZ47P6cz32aIcjDs8X7SiBpCtE1cUhXg6zNeF+Um824eY2TAfCj5OFBFcrD0kR/sQUwbXB39f
FYV4DlOZ+XrcOBhtSC1DFj+UuQcPh3k/p7YI8c79uIzRQ9q3fQpjzepCarSyfc1ZXFrGcEwq3bMinx6A
wIngI15pPfFUMP5HKu2bws7APy+1CKUxgh8DyXmdOVMH90iHMcv9Th2izTp73wvY3Ye4x6XKPOb46qpE
V+DTQJQN9zMYrcB3NfZLC8xy/YXbq4rbKHVbRe/qFJ7DTV14hqUo7F0UkrfQjpQpKp3G8T5W5XzLVh0R
v+B3qTwblTrCDVJ1lIdjeFQq+0thCC8uiohhWJDCvU3nwakzPtH5xvfEGA5aOgR5oWz1JMN4DL/WEPY1
7qsijBSK2MFlT+ysVANGjOJBqRHvJnYe3+AV3FVVGGyRyptu4qrce2O4AVtxp1QZl3n3u+JJ+f9csuOF
fhz0gz2651trvGewzVJPzPQQtiD9hbpkucTB2zmiWjt6QqpylxUr8b1OcWelJP9fYK1OkbuWU1AeVuIt
qVPbs7xSlvAfCj2QzoDCDrQAAAAASUVORK5CYII='
  data = '
iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAA6QAAAOkAHc49yqAAAAGXRF
WHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAYFJREFUOI2l1L9LVWEcx/HXjaRMLRquJQi5
ZDlHe4M0REsNQqND/0AQ7bVas+Bi0BAKTtEWzYkRUaDiIoRDOfij8t5SvA3nq/fpeO85V/zA4ZznfD/f
9/P9nvM8D+W6iUksYwe/8AUvcK2D/EP14BX20YhrB/VkvBvg02WwPnyMpO94hMEkfhVPsR2et2XQuTB+
wKUC3zBWwvu8nWk0DN9QLeyjCf0pa3+4qLrxDmAHehY5E/lAJWaro/cYwOsB/FzJBar4gSWM4DymC0B/
8CAKqeFv/s+cinsjGV8pANaS50aS/x+wht84WwDKayiAi3niPt7jHO4eAzgW93etgvdjtmUMdAAbwHoU
c6OVoYL5gG6XQPsT78t2ptvY1NyvK7KWuhPPBTzEWngWZHv/iJ4ksA3Z1jsA17EYE+wm72e0WLNn8DqB
beJOtH8Pb2QnTSOJz+JWq6qq+JQkbOFxm8/Rj4ttYodaxZ7meTdTllCmKdlC3sNXWfsnUldAV3H5pLB/
foZsC5ZTyFQAAAAASUVORK5CYII='
  if (2 == (global 'scale')) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method restoreZoomIcon MicroBlocksEditor scale {
  dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAACXBIWXMAABx2AAAcdgH7OYqmAAAAGXRF
WHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAA0lJREFUWIXN2EmIXFUUBuCv2rY7QpRoYuIE
opDExAEcIhpdSYxCzMKFCgGDgsskIooiLnQZ0IWoILrRjQOYbRTbjRAhzrgSjUOjhKQXDh3b2Ind6XZx
q+hXp17Ve69eFe0PF+rUrfuf/95zh3OqYXBYhe3YgY24FGsxj2OYwhc4iEP4d4C+e2IzDmAOiyXbCTyP
1cMUtgZvSCtUVlhs03gGo4MWdx1+LnB+Cr9K4S2axAQuGJS4nZjJcTKH97AbF4cxI7gKj+GTLiJ/wIa6
4rZgNof8XayvwLNNOjB5IvteyUtwNBDO4sE++Ubxco7ICX3uyYlA9De29ikui305Ip+uSrItECzggQGI
a+GlwD+tQqgb+CwQvDhAcaSQfhl87C87+OYw8IThXLB3Bj9/4uwym/GeYL+C35uf12JvDVEnLa3URziM
W5v2KtxehuRr7TO7PtN3tc4NXqX9Fnw9HvpfKBI3ijOZAcekPTksgZtC/8dFIV4nvQItfN8c2MIUniia
ZQ/MBvuItCBnNe34InXgJu0zeqeGmLKYyvibGSn4cVzh+aFIakc2Tyw8xVPBvijYK3BtDTFz+CZjN4KP
40UEK7SH+EjoH/QhuSz0Hy4K8SlMZuz1uKJoVjWwPdjflrmoD2JPxt4pvZ2ki/ZQDUHTwY6PwvtlSO7W
vuyTGK8hqhs2aq9rTuPcMgPHpdQ9K3JPzxH94UDwUelKeyQM/kdK7QeF3YF/XioRSmMU3wWSMzr3TD+4
TTqMWe7X+yHaorP2XcDDNcTdL2XmcY+vqUp0Pj4MRNlw78VYBb4LpbRtIXD9hWuqitskVVtFl+4kHsWV
XXhGpCjsbwrJm2jHlmnELwJ24G2cl9OXzToifsQvUno2JlWEG6TsKA9Hca+U9pdCA081RcQwLErh3qrz
4PTTPtD5xvfEON60dAjyQtmqSUZwH37qQ9inuKOKMFIoYgWXPbEzUoIQMYa7pEK8m9h5fI5ncWNVYXCL
lN50E1fl3hvH5VIBdIOUGRclJj2xS/5/Ltn2ZB0HdfCc7vut1d5SfOKHhukewhalf6HOWS5x8FqOqNaK
Hpey3GXFSnylU9xpS1X+smOdTpEPLaegPKzEq/hDOjj/C/wH9uC4M441HhwAAAAASUVORK5CYII='
  data = '
iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAA6QAAAOkAHc49yqAAAAGXRF
WHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAZVJREFUOI2l079rlEEQxvFPgmLEH40mZ8BC
C6O9pLKKSECxCugfIGhhKUiakMJesRSsBAtJwEZiF8RSUUQUNaY5EAuxMDF6OWO8s9h54+a8e99ABpZ5
991nvjuzO0u1jeIOFtDAD7zBLRzfQvyG7cF9tNCO0UAzm/8O8I4q2D68jKAvuIbD2fox3MD30Dyugj4M
4TPUSnQjWAztzV6iMyH4hMHSOv5BV6TyR7qleTX8NJZwugT2B09xG1O40inoi92a2BsZtktGI+JOxPx1
Z4YHA/RBao8mTlVkSGqpXzjaCewP3w7fQr0E2Mq+21n8JuAqfmLA1ks+EvP3nRm28ARncR6PcKkkw/Xw
F8PPdxNNxG4LGC6BFTaMr5HMyW6CPjwP6EoFdCjT3uslGpf6rzinRVzA7kyzH5fxOTQvpLf/n01msG/S
0yvAq3iHj1jL/s9Ib3+T7cKDDLaEc1H+BOakGy0gy5jFWLesBvEqC1jG9R7HUcOBHmsbVpeuv+irmaqA
KrsrNfI63krlb8t2BrSOQ9uF/QUd5IF+Y39L9AAAAABJRU5ErkJggg=='
  if (2 == (global 'scale')) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method zoomInIcon MicroBlocksEditor scale {
  dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAACXBIWXMAABx2AAAcdgH7OYqmAAAAGXRF
WHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAA2pJREFUWIXN2EuIXEUUBuCvx86MQtREo/ER
8EUePoigiWgUFxKjMLpwEUXBaECXKm4UcWE2QsCNaEBUUDc+wOguiuNCQSE+wZVoog5qcGZhdOKImZjJ
jIvqJtV1b/e91dNh/KHgHm6dU/+tU3Uet2FwWIYtGMVanI+zMYvfMIkvsQef4N8Brt0Tl2E3jmK+5jiE
Z3DmiSS2Aq8KO1SXWDqm8CSagya3Hj9VLD6DXwT3Vn3EGM4YFLnbMV2yyFG8jW04N9EZwjo8ik+7kNyP
NQsltxGHS4y/hdUZdjYLF6aMZN87eR4OJAYP494+7TXxfAnJMX2eybHE0N/Y1Ce5GA+XkHwi18jmxMAc
7qrQ2SXc0incXTH3ucT+lAxXN/B5YuDZGnqvRPPvq5jbxFfJGjvrErwmUTykXoDNIQg3J+v8iSVDNRRv
S+RdOFhDLxcfYm8kL8MN/RDcPTBKRbyTyKNVBJu4MpIn8M1AKXXivUTeUBVvVgpZoI3vhfPRxulCZinD
JdHzdThWMmdGp0f2tead1JLTjFTABp0H983k/eWKMSxn/F6y5mT0frqOi2PMVn3RABDXiUuqXDyZyOck
8h94uYvujULhCh8LeTbFdCI3kjUmKvg5WadL9lUpRMiNg7AqWW9vlYtnMB7Jq3FRBslcbEnkb+vEwT2J
3O3WDgJpzE3DTilu1bnt4xipoZfr4rU6+5ojOLXODn6EXyP5QjxYQy8XT+uMGu8qXqKueEDnLv4jlPa9
kLOD2xL7s0KLUBtNfJcYOaZ4ZmKsEpqr9VjeY971wmWMbb+UQ66NjYq97xy292OshTuFyjw94ytyDS3H
B4mh2N0PYTjD3llC2TaX2PoLV+SSu1TIAlV5dRyP4OIudoYEL+xsESn70MKRaVSQG8UbOK3kXVx1pPgB
PwtN+7DQEa4RqqMyHMAdQtlfCw083iKRumFecPcmxYvTz3hfMcf3xAhec/wSlLmy3ZMMYSt+7IPYZ7gp
hxjBFWkHF9/YaaEGTDGMW4RGvBvZWXyBp3B1LjG4VihvupGrinsxRnCBUElfJVTGdbJWV9yj/J9LPB5b
yAILwQ7dz1t7vK76xp8wTPUgNi/8hTplscjBiyWk2js6IeTURcVSfK1I7ohwyP8XWKlI8v7FJFSGpXhB
6NR2LC6V4/gPU86YtMg9uoAAAAAASUVORK5CYII='
  data = '
iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAA6QAAAOkAHc49yqAAAAGXRF
WHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAaJJREFUOI2l1L1rVEEUBfDfihq/g8JGA4I2
Rq3FXkQsxEYLwT9AC0tB0lnYK5aCjYKFRBALsRPbKIqIQoxpAmKhFolRsxsTdi3mbjI+57mRXHgMM+fc
c++Zj0f/OIpbmMQ8fuAtbuDgKvKXYyvuoYNufPNoZ/PFEF7fT2w7XkXSZ1zG3gw/gGuYC86TfqIPg/gc
u//BG8FUcK/XkU4E4SOaFWwcYwXR75L9kXUFwUsxXsXXCjaAjZW1D7gpWb5YFWtEtTa2FYq9xqPC+iHJ
1ZtGBWjiC97jMHbgToYfl056POYLOB+NtPCrejK9Lehm830Z3rPbW2tlWDfL/0OwhZ/YVLBWZ3l/CE5U
FTt4hi04XUisi3MxPi2BZ6PaJIZX0eGwdBs6OFISbOBFiM5VRHdhMJsPZdy7de2fxIyV9zoVljZnnEFc
wKfgvJTe/l8xitkgzUhPryfcxkQUWMzWxxTu7ADuZ2KzOBX2z+CxdP+6Gf4Ax0pdNaXN7iV8w5Wa7RjC
zhpsOaaxZOV/V338/x23pYu8hHeS/TXFhhCdxp61iv0GkDZz2QEPwisAAAAASUVORK5CYII='
  if (2 == (global 'scale')) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method bunnyIcon MicroBlocksEditor scale {
  dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAA
CxMBAJqcGAAAAVlpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRv
YmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRm
PSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpE
ZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFk
b2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVu
dGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4K
TMInWQAAEIhJREFUeAHdXAeQVFUW/ROAUTCBZJC4rDiyarlYiogwAmKJirqKpEUoQDFgQLQMqJhRCiOW
CpIkLCoYMayCJJUsLCAgMENmyEEEptPbc+68++tPT7dMT890z/iqfr//X77n33fffffd346ToPD000+n
oqv0k3V3yy23pEUrZ4xJOVn9ks5PSIdt27ZNnzNnToCDB5EZL7zwQrP09PS8Rx55ZL0SRGA++ugjPgY1
7f3336+zefPm2qFQqGG1atVWPvjggxsJEoLRMuU6tlxDznGmT59eu3fv3sNxm40rdMUVV5ghQ4Z0ZB4A
zGDM8Nprr/29R48ew+rVq7cEj7/jMqeccopp06ZN4JlnnmnJMpbLeFt+A8Bxp9Pjjz8+AJQcwGUAgAEn
kAPM888/304pfO+99zI7dOgwBc/kIPPwww+bGTNmmNWrV5vHHntM0kaNGvXXAEjBwXSofNNNN80gwQ89
9JDZunVrHtLyBgwYYKpUqfKdggMwBuM+UL16dTN58mSzc+dOH8r5cQUDgUBely5dTIsWLSbb8pRR5TdQ
3nD0a9asqdqpU6fVuDVffvmlD3IkCILNqlWrKItMnz59urHc7bffPo7PTz75pNm/fz8BDLFcMCjFQ199
9VWI+S+99FIrli/X08vKHGfTpk1nXHnllWtJGKYIiTYASOgeP348p9dePKRDJo1gmSlTppBjBBECY8Fh
7O/Xr59p0qTJApTTkJCFRTsrsRgEugO/9dZb56BhAy4ScDBNCA6D76677iJAo19//XXKH/PBBx9wKnm5
xgVoy5YtPpbp27fvEMQU5q5c43N5CzL4O++8cygGbmbPnu2CoxyRm5sr0wucM6hx48azevXqRTDIPS4o
nvvQ3LlzZXq9+eab/yQY5XZ66cDfeuutTNARHDlypNDJacXLAhRasmQJuccHeTMScWD+/PksF/JwGJ/d
6fj222/LdPz++++roTx1KJdL+Vyegqws7du3n1yjRg0K2wJcYQEKglASvAmATj7nnHPMgQMHZO5Z+eSC
Y5/9UChZfr4FIingiBIXz5uwgjk4duzYxgDgZnCPU7Vq1XQQ6aSm5jcPzVe6gPBm7Pvpp59qYno5Z511
lqRrvjzgR58PHTrEpM38QYh7rPnNxPYbd6e6cn3yySed0XWldu3aUc4UeNuWYINtg9OsWbN9O3bsMKed
dpqMFGwTccQE+PffqUg7kQtErFXyiSWxKggBX3zxRYeBAwc6tWvXllEqF3iGTNniYE+1E2kVLTBRiWf9
CG14mkvMbbwcRE4JYnWqjDgT+ysSlUoglDjlEMgh58iRIxS0O1hH86ORyXqsk+wQF0AQtlJ/xIgRjUBI
A2wVSE+B6aUEUlADSGfhwoVHLrjgAgpnzYoY+/1+Z+/evcyL2F7ESqWQGBdA1jzh/Pbbb2wn5eyzz446
RBJMmXLqqacGVq5cue3w4cMsS9sFuapQPSz9zq5du5xrr71WzCSFCiQoIS6APvzwQxnmDTfcUAs3KdiA
UrGL+MZJ8L59+5z69esTjeCePXv+dAodP37c+fnnn9k+pyRDxHbzs0rvNy6AlIN+/fXX/Ryiz+dje4XZ
gYngEnJR5cqVHWxizcaNGx2CEB6UmwgoA/SqXMbYZjBKeCgRgNatW5eHkYfstIlIBAkn0QDI1KxZM2fe
vHnOH3/8IWUVFG9FCza5TJQnb14i7+MCCDqQcAvsNVxuQtCMo46dKxvzzz333GDdunU3sKCCEKGSgYDm
2PwQ/DnMp60oQrlST4oLoKeeekoB2o6R5ublkZEKTjHljqNHj8qqdOzYsVxwmsgVbEnYf0TCYTRjW37o
VTIPMzMzI5ZjodIMcQGEFYiDTsHbpcqbbbcShlsMBUYHD/kjQrZOnTp7W7duLUTDwhhN8BqrRR+AYe0g
29CXoe0lKo4LIDtIaaNixYr7YP+hzIj0pg3kjWjtiHd269ZtG+put3strnwSCKrdv4W4LUFYA837COJU
+zKYltBQEgAJF2BlWorVLOLKRIoswUFsZGUeImnF+vXrmVWI48BtBqYRB5bEXSyAUBLjzG8pxt+4O9bl
F0riChKVnZ3NNsEM+YxktxSh7dspppyt9913n9xcc80123744QeuZC7HaR3IqFTmwVC/mJUgf9hmtOnI
IqUWSgIgmSJdu3Zdh1EeBae4bZJgAsRpx+kH7llu5ZUDQOdREdy9e7cQruCgDQPNPI0qQ/PmzeeSctQV
0ytu0/FC0tWCwLzyELxvdhWNXAhiCCMwDFjefRUqVDAQzjzekQAOqYcb/6xZs1gkxLK2fGjcuHGcdsdg
r+7y6quvNpw4cWINlHGBt02kqyXTPpfpSAQwTjJGd+zY0WAppyHeQDFkZH755RexLd977739cf0bJ6Wj
wE3TQVHeE088wSJQk/LNs3zAGZqURz6nH2UWFaz/tWzZcvzgwYN7ffbZZzXxrCGtzHMU2Z6jhTG+ByJO
EUFGAYKtmoRSmWRsrrrqKoPTVp6YGhrmLUJqizbYpJpFixaZZcuWhRh//PHHhpyJQ0ipjzYOY/83esKE
Cf/AvQQdgz6XqVjf4NSpU+tjYMexRyPNPBVlbDCdzBtvvCFEb9u2LQDBrCenAo4Usj/kJE/gAy/O1cCJ
Eyd82NYExowZY2CZFLBwjj8KaWKevPjiiyuUKWA8g6EcEll0/vnnz+bZFwiVaRaBYJd+5qmcchNxo+kq
lxiHtROkXHvnnXcEJNiXcoYPHy5HQxiHcLNnbGXjVt9ez549B2JEPIcXgJS4cGLDCPbiE/XeC5wtFILu
lXf55ZcTqCA4+V8WjbIHkk4zyIW6GOSxd999lzSApgJTJirxsWYo4KwHU67/7rvvFm56+eWXb7Ygla3p
pkLyueee64oBGjgdyBpPQkozqJyD9u3Hqa6AhGPt1gRJx2QBS14EAET+IE6DSXUDTjeISSQZxPQSDwoS
Nrh+gGJgUsldunSp2H+Vs5OHTn7Pws54gyJ/VqxY4cqfEkcjSoMKElQM6k3mxhtvHGtBSa4/Ecar3EOQ
NkKRIwmyvpeW/ImCka6IIagbonM9++yzWQQpqVNNOx80aFAfjMUkg3sUMH0h0OR9VEYvuuiieQQIgS9R
XqQ8JfDH7RSmiWVW/0kK9yhIdlEIff3118JF0I86EA/IosQv/bpZtKzMbUNCVi4FI1KsXERtvVWrViYr
K2uqZZikyCLp9Oqrr54CRZFmUnF70UFGIiARaZaLgrAGcNk/tHjxYp7bkYvCLQIWu1KItLNvvvmmKprf
Q2cnhGCywZFBWN0LZ288XDO33XZbd0Kg8pL3RQ3FRhSe81IXZ+30Pq1+6aWXcs6nYoBF7bvUylkrppzi
Qgw4sAi0ZWcYM6OYQjwASUfovDUUM6dhw4ZiWdTBxTSKEi7MMfBF4SAh9bLLLnNycnI64JkeKFxA3IWl
KN0WGyA0LoDgqOdvMJI5Z555ZkwdF2Vw8ZSxnJwC6wKbqT1s2DAxsiGOaZzFAsi+Be5C06C5Nq9VqxZt
zykcVGlyENuHjIsJN5ziskIlnOI2YUXYt0sfIILBzmAYq4KoaoMGDfgoAPEm1qCEM44WFHz1e/yzsp42
UuALIIjCNymT6TjSLn2AdADolBSZ008/XZNijr2EE/dIhGsZHjTa8zXh1EhldQDKyXDJcfDplQO7uHiM
xiqoizXFdBAa62D0uaixEk7XvA0bNoi/UDhInFJMo29R9+7dnUaNGjlwGC1qF3JSSxFgDw6KXE8LxgVQ
pUqVyK6p2Ptoe0WOveDcc8899H51YGyLWp/+RNg+SD7s2+JrFA6mt7JyF2SPw0PL6667Lvr89VYsiXt0
LvMYMT+Ey4EVD7cmEIuSqIY0fP0j0xTtcHNp4FTFtlwbtLYJLd08+uijBgeO5scffyxQRh7CfrR9LCJ+
to3NdG/SHquyWCwOwpsjUXQoOIEBr6EvIUJUf0Nmhge+fQbqUPgWg0qdg0NCJyMjQ1Yq0OvKI04zyhLs
+UQGYY8ldbUNeYj8w+2PbIfQPk9+Y/YzKhZAdixSF299Pb3FIECLzMIknsQxpgDlFKMjAw4epWmuVLxY
hpeuXGlpaeLCx3reEP7szVu7di3fxGGstFuYHqufUbFNAGBVUd3hG70IH6c4OO9KgbIoRJ/szSo43hin
rW5dOKXTCUK4icSTQ/G5poOja+EuBYwEMz+8P6bZMsHly5enI38xPtGir2Mq9pCxKVLspDhBN6ujR4+m
hnoIXyhjXDTqFd1Iz7IqYxjrPT6lIosUuKDgsX21Gha6lwT7o2OAGiLyB/5I8r2ZHk0Vh97i1pH5fckl
l0yj7YVGc45RCfUOWtPgiicf9WJVkmymK0HeuvClFqFNoL799lu3rJZRGzTc/uQDYFgypQzbsu2FPv30
U4Kch5PYpiRQ7Ve8T0jQDl955ZX26NDgax+xJnoJllHjh0AoSCSY5aG0abbkKXF0oGL4/PPPpRx9iBgI
irdtHE7SY8RAeNNhQspoPh0oYKfi5+QzLRjxyNv48czKylrYuXNngzd6Ui4iJdjkihMDD/xwti7Ehf/g
Y2Bz4YUXFgCFZaA0GnxGLuDBHuVW4wtQzpo5c6bYgqCCdCJ1kJnFlrdxoaMdYyAd0ZDB/oxcVOgrQqXC
O6XIKRDIBmfrhp+Kc0rwUyk4T0lxKI4GH+lx6tLHyMAyaLAb59bGgGsFKBZU7lTuOXjwYB71JdT9zhKX
r1PERWl8lUUWwXL3H4KUnZ3tfq+qwITHSgzTOT0WLFhgIPgN3H4NlnuDz8UlxmoknNa0aVPhGPyDg4FX
mtuctqPTFxlBTjmMIwD9qgXJUlHA+6QEXdGgc1Q777zzdnDuQxjLVFOWdyny3Hi5SZP79+9v8J8ePG+X
b+nhBmzIadOmTTPcLmggMF5w9B4cLO56+FJ6AMFQDk8KMN5OMUXkdBV/H0E1V6YM/HlEaP8ZSCSYQKlg
xqGf4T8tMI1OU/QDwmmJtMd0AsE8XlpXwQEXyqkqwNGTjOQKZi9A9l5AAgd0J0hwt+PeyuUkJUooC/tR
IuFVJlOJ9Xlh2hq41BjoMmbSpEkFamkdJIawPzvB8vA8+w7PInOUs5FepoLII/xxST+MysBEof/FIcQp
BxSglBRajqBAJhfNgnMndSXsxsOLChd5wAli+olCeP31189DYek/6XLnJK9EQWqHcnsIFAjm/3fIlCPF
JDAcLAWpECJIYJ7Wsfn0vfbRF4DtQ12YiHTpF9+xSXySMSY3W9V6DLY63ux/ScQdd9xBx0yyhKgCllCX
cAJAecWLMokX78OAE/c7/AcI91QE5/DQoUN7KrVlnXN0nBIrSHy4//77+yLahMvgnn9dEYR9mFxFGaWA
UfKGX9zcBaAK+OBu56fnGnUctgO5NAnLfj3cM5R9d+D8cRb8tW9UhCYIzcC/Tg2EyWElSgmRDzzwgOE/
wsBaaLDzNgDBwPTBv9Ex/OsKLu+wE4nCaOvsx3chYyCwW2pP3hehaeUuDtdH8KV0G3y+MAyEcPptwaVT
RoDDs8b81GoZ/rBgAr7z6AnN2/vlcKlzjbxZDCAhARyUAkLTsEnlPskNSK/84osvNoC+k4FVjFMsBfKH
9p8UKIe74euzwy2cf5MGzuSxE4+7/3qBAFiO4gayqMpcGuskWrf5PwAwdFuBpcnnAAAAAElFTkSuQmCC
'
  data = '
iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAA
CxMBAJqcGAAAAVlpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRv
YmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRm
PSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpE
ZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFk
b2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVu
dGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4K
TMInWQAABmlJREFUWAmtWFtolEcUnt1cLGmK0kvWSmIjiNi8KJgGDWq0okUhitJCoC1IQNMmUCtYii2I
D4U8SPHBkrRaioRCJdoGETSKxJpUqYlpNSohMSqJuWiqMYm57m36fZM565+su9nVHJidmTNnzvnmzJyZ
869S8VGiQzxt7969b6DvcvBS0X734MGDcyzPOeYQm5mmgHk7PT3956KiIr1y5cofreoVqH8tLS1tR9FZ
WVnfW77MmRkEDi2i+P0dO3YMPH78WFdXV2uMf4DyVXl5ue7t7dWkEydOkJ9n5ybYekYrAfMetkj7/X5j
eN++fQ2w8u358+dNHz+j4+PjevPmzX/NqPUpyuQMJG/durV1eHiYxkfpIcj9uX///k6Lhii9HR0d5JdS
x7Jly5JYzzSJd76or6+n7XH+tLa20nBTbW2t6ft8viDYvmvXrpH/iQUhc+PC5I4mDSMBjn8EWrJkCZvm
TAwMDATRHkxNTXWeEZfX66XMMH9elKIBcrtcLq7Yk5OTk5WcnKwA0GwhzooffG7XpPmBgMHvBBk3rkkK
nbNxPqQ7e+7cua+yEwwGDSCcJXYHx8bG6Ckh19OnT9keE8aL1LEACjB6nMoBjPNGsHXGJdaT7sHBQYp1
W9lJcyxv2ioiIMfMof7+fuMSt9ttjAAg57XBIyOUE/6jR48o10seaMYBicL/uru7e2gBnjBbNDQ0NI5u
E/jGJcJ/+PBhH/j9lAXJ/IlejL/RPKQRXDygwStXrrQCBFUaQPfv3+c5udHe3t5BJijIA41+M9pGEPcQ
w/6lDjgVTyW5S75paWlBUOlRhLbeuXNnjRX8CV4hf+TOnTv0SAVKCorzUiSoaAvH8DMSg884z2/9fevW
LbVo0aKke/fuqcOHD3sKCgp+x1atwPlSaWlpr3DaoUOHClDlNzc3d5WVldWh/QsKnxgSgZkgML0X+cHK
5el4De+YeSYAwE9vMfIQbfQOKlOzbQjbp3t6evSRI0foNYJKtvZffgvXrFkjXizr6uqiQR+KeSpsTV4I
nOWZt43ttrY2vWrVqn+gR3KkmLcvqhPXrVtX8+TJE9rGg+83AKZ6hoPksdBLqAl8rLOzU2dmZtY6DIjn
HazYmuKdD0+fPk17fmuE7WmJeGy6Mnb58mVu39fWrOiNDYVIwaJZyaZNmy7Z1MM3sehpsYQErHyAjD17
9vCeesvqj2/r7B3EuXnHjh2jvkA83uEEIW4fyHv9+nV66UsqdZxNdmMiiYgf7GH2WsViJ+baesnHyNy2
bZu5wzCZ3g87S5HcRkFzZxQWFubgnuEKcO2EzWdKYgoFhACAmYF0pXYzhVm+fDkTqzehi94KUxgJkCiZ
PX/+/PTERHMGw2QJhiBZ2CaxxmNriijhOAAa4/hieR38d+xYzIBEMBFZYegZoGIhAcMskfmRNWpqpLLq
3LlzIuqsg3PmmOuIoEjPFE70I74xE8vFtsFY6LoXL3CutCsrK9Xq1avNFtEzpJs3byryhQQ8+q7R0VGy
TdqCWuyQF5VCyPEd1ogkHjrNHcR6Et29e1cjGwhdiDzAvHueEwAm1PDeMWfKsNbDjkE0VBJl5ch7CGJS
lPHVdxI/gfg1W1JSom0GEBq2sj4C3b59e73DaGjhwouIEPeQyFTW1dWxbWQlem7fvq1qakwEG7mMjAy1
ceNGtXjxYr7+hseUtqqqSkkuhUdZHT16tIqD9h6KecuMQvyYFWRnZ9f09fVxxZO81NTUpI8fP64bGxs1
En599epVferUKQ0gGmDNZzVffZCfW7hr165pb2rZFgEwtea4xpb9O2vWrM/Wrl2bgGiC7gDOr1t5PB61
cOFC9eDBA1VRUaHoETyk6uzZsyo3N1fl5eUpRCm9EDh58mTC7t27S9C+hMJ7JBQsaIdoOkBUxsk9Fy9e
7FiwYMGWpUuXEowPoBKwcpWUlKTmzZunkDEaMOzjrlHr16/nFUCjQTysSRs2bOA/Jd+hcOufCwb8mEmA
f37gwAE9MjJitgE/DD9GTxBeZO4TRFizT76XEQfPcFHlDkthB9kxFldTQOVitY1nzpzRyB5hN5wASjc0
NOji4mJ+rXzqsBIxiEQmXrTcPn5Gk7bgj6mP8/Pzs/G8eFJSUhSAuPkphD8hbly4cOEPyPyGws9ZAqGn
WKJSvICojJ5yngEm+B4U6mJhJA2gCDkXIbyI9f8PmQ4SvBAaOwAAAABJRU5ErkJggg=='
  if (2 == scale) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method logoAndText MicroBlocksEditor {
  dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAARQAAABQCAYAAADYzoq3AAAkWklEQVR4nO1dCZgURZYuupub5r6ao5uW
q21AbkfEg11Qx13dQWedUUfGYxQ8FlfB5VCXwXUVV2aQVQeFUQ4FPEEEdkQQ1MEbuRQQQRBRTkXkprqB
3PcH8ep7HZ1ZmVWdXdVI/N+XFF0VmRnnH++9ePEiErGwsLCwsLCwsLCwsLCwsLCwSDkqEegjM0DSjIDp
LCwsTkcQl8QIoiqhSZMmnRo2bNjOSJahrxjq1KmT07Rp027t27e/skGDBq1TkVcLC4sKCi2V4IrUrVu3
abdu3R6h/26i6/j555/v5OXlXYTfMjIyqvI9jRo1atepU6fRjRs3/oT+3E+XU716dYfSFzdr1qyHTpYR
sbCwOH1AJBGTSrp27XoLfeyhyxk/frwzZMgQB//Pz8/vw2lycnIKO3bsOIP+ewy/DRs2zJk9e7azZs0a
Z8SIEeq73NxcSygWFqcbmExqEH7xi1/Mov8699xzj7Nx48ajwMCBA51q1aot5PQ9e/YcQh/FJJ04M2bM
cLZs2RItIhwjHDp06Gj//v2dli1bTufHp6FIFhYW6QDbS2rXrl2vd+/en9N/nddeey1aXFx8zCGsXLmy
OHJSOrka6SjNZPw9atQoZ/v27UePE5AOH/j//Pnzj0dOSie99CssoVhYnA7QNpNIrVq1avfo0WMd/ddZ
sWLFURDEiRMnHEgcU6dOhbqzO5PQvXv3sUjz3HPPRfGbIBL81yFhpujmm292mjVrtjStBbOwsEgf+vTp
8zZ9QBpRZKK5wokSbr/9dhDKpDZt2vRBmilTphRJqUR+kooURZqOHTveg+fK1SILC4ufN9Rg79at2/30
4SxYsCBGJkwQ3333nVJ3CgoKBufk5Lw1YMAA58iRI1FJIlLdefvtt5W607Jly+76HVbdsbA4DaAGetOm
TQvp49i4ceOUegM1BxcTxLJlyyCdRC+66KI/02fx0qVL1fcswTBYPZowYYJSj7Kzs+uns3AWFhaphSKU
Dh06TG/cuLGzY8eOElIHPkEQb731Fgjiq7PPPnt6bm6us3v37mImEEkmuLDK8/DDDyP939NbNAsLi5SB
DbENGzbMp48j06dPV1KHVGFY4pg4cSIIYl2DBg0W3XfffU4xwTHA5AJCgS8KpX9Ov8qqOxYWpwGU7SQ/
P38wfcCHpMi0iQAgj5EjRzotWrSAxLHwkUceUd9J6UQSClZ4brvtNhDKNP0eSygWFqcBeKDPBQFEo9Ei
U41hiWP48OFO27ZtX6S0s8eMGaO+8yIUPEevCKWbUDKqVavWAVciN1WuXLkl7snMzKwbIHlWrVq1Lkj0
HaciqF6awd+RyvsPtWvXvqxu3bq/qV+//nUktd5E1x/ou39CPWRkZNQK+sxmzZqN6dKlyyG+qlatWlCe
ZQgb7du3/4jz3qFDh03pzk/aUb169Rr0sWnmzJlKtTHVHeDIkSNK4sjLy4NB9hVIKPEIBRLKoEGD0k4o
1LkLu3Xr5uCicnYLel9hYeGXuKdp06b/GS8daYzVqBNt5nc0b958bNlzXXFBEurjXFa/iyafxUQ8fRJ9
JrVT5xQUJTSceeaZaznvZ5111vfpzk86oQY5zSyYWY8tWrTI1X4CHDhwIHrFFVeAIP6Ym5v7gp+EQumL
rrzyyrTbUOrVq3ctNzbNhA8FuYdmyPZ8zxlnnPG6z/OvkYMBsxTNzjXDyX3FQyKEwhep069G9CbTIM+0
hHLqQg1yElM70cfxlStXehLKjz/+GO3Xr5+TlZV1H6V9dMSIEcrRzVSP+P979+4t6tWrFyp4snxXqkES
w6Pc2CR1rA9yT+PGjYfyPR07dtwWLy3V3S/lYOjUqdNuklqqhJP7igcvQunatWsRXcVepJKTk/NA0Gda
QjlFQR1fDXIaaAhD4Kxfvz7mPm8SxO7du6M0+zqkL99LacfcdNNNzuHDhz0JZfv27UV4Zrt27R7Ur0uL
l2ybNm0Wys5KKlBHv3tIVH9H3kMkmhMneQZJMXNpMJ3o3LnzvoYNG94aYvYrHMzBT9LtzfR1lv65EtVV
U0htcpBpwjlRpUqVVkGeaQnl1IUiFJqRYVtw1q5d6ymh7Nq1K9qhQwfYFO6lAffwBRdc4OzZs6cUofC9
W7duVYRSUFBwB96RLrd7SAzGTDk6XvrMzMz61PmPyXtgfPR7D4y4iRgiT1WYgx8GWbd0qEeS7r6RaevW
rfuvQZ5pCeXUhSKUWrVqKRvKBx984EkoO3fujLZv3x5u9COJUBAfBaTh6nYPbN68WcVAadas2S/xjnQQ
CiQLU/Smxv883j3S5hKUhE4nBCUUAGqOTEt94eEgz7SEcoqCndpI6sAyXdH8+fM9CYVUmCjinVCFDcvN
ze1D6UEaxW6Eggd8+umnyk2fBmh7/bqU21BIsrjUTZ+H0dXrnlatWr1gpm/duvV8Mx1UJywVmxdJKi2C
5I2kmTo1a9Y8l1SGW5o3bz6OBt9/0wz+a1IL8r3uoWfnynexrQYrTVTPV9Mz/osI/y/UnvfTQB+Ad7g9
h9JXx9Iv1DMMZkp/X506dS7XKomn8RRIhFDo+XfItLg3yDODEkpZyuGFZNolKKFAHZTth7y7paO+dSbV
6w26PZ9s0qTJcOSBpL6GyZQp5aAKhKi+ddasWaWWjfn/GzZsUDuH8/Pzf0+N1hb/X758+XGTgJhQ5s6d
C0I5SBWRi3cweaUS1BAj3QiFvr/X45bKnTt3/slMT2rTTjMhqXLL3Z5Ns/D/xMsTBgtJep94GS9xkWr5
Namh94Ao5L1uA4/a4lfoxOYzunTpcoQ6YAN5PwgIg8RU6Yx3b6L+0CvigUQIhdI+Ydhb/hDkmX6EEkY5
TJSlXYIQCoiqsLDwC/m8Nm3aLJJpQIRYEYO9ye39MHrTPW/SmLoyaLnSiXceffTRmDs9SyZMFuvWrVM2
ESrwpdSJMAs7r7/+eimJhvf9IHIbpdlKTJydrgJRXl9yaxgigxVu6Smv/+jVmUzJIwlCqQzVCash8Tqt
vEhamiEfYA48qBD0vONu95IUOVneS531DBowy4K8Fx1X+9+UkiqDEgpJge2InA+IgfYDzdCN3NImQihh
lSPMdglAKBkk5f5NPgMrjtJp0o1w4rx/uss7KgxUZVNjv3r99dcrBzaTUMAYq1atUnFkaZbhxt46bdo0
RUBMKHIfz0MPPYT0b+i0KZdOAHZOc7vQMc301LEf80pPkkB/mbZdu3bvu82QXoRC5DbL7bkdO3b8FjMV
dcp18nkgCpphzzPy97hX/iBFYYZlgqFB2ZXvg7GYft9u3kP1sxGk27Zt23dp8O83fycV999d6iguoWCQ
kApyG5XrO1kWeNR6tVNQQgmzHGG2ix+hkDT1J/lsSrOHCLdNvDS4IGVSP1tK5dsgpZZ4dVkRoIylVHkj
evbsCX8TV0KZM2cOCKKYCIXdoufee++9ijw4Pd9z8ODBKOLIUkNOlu9IJeBcJmdviKuysUh0/Q/zHkrz
lehQ38hGhC7t9h7owX6EAr3e7CzU+ZdgZUimgygNewAGjZsB041Q0NmpngdzGujppkgMhz6jox6iPP2L
UV+14MRndPzv6fva8fKATk/53YX6chvMUCHNd/mVy4tQwixHmO0Sj1CIcK832quIJOELzWcQcXwg08F/
CjYi/h3qEJXrNSpz1K0sFQa8+kIFwGoMQj4ek2oMSAJSyJNPPglC2aTtLZj9/wLHNTi8cTq+Z8eOHcXU
WBDNbtXvqJzqckF/lg0EQqCGX8N/02z+sUwPQ5hMT6LyKOjh/DcR7gK39/gRCpW9Bj1ni0zTsmXLpyLx
SRb15atu4PLze6GOmIdBL+9x69AaGZiVjfKUGECJespi5nWTBuM9041Qwi5HmO3iRSjog5Tno/Id2PPk
9mBILTIdldf1HCuv7ysM2FjapEmTVvSxX9pFzH081ICv8H15eXm/jZx0hisSkoy69/3332f16EzjdZkg
sFQYaCF2ywaCmIjVD/mdnImo/MPkbyAYKQ57Gdv8CAXSg/wds3my/irmwKOO/FnEZ/XMnNVh1IuX3vT8
hegfLw9BLkh6ekC75jUIoYRdjjDbxY1QYHOjZ+4wpQ6vZxQUFKySaSl/dyaTl4qGzxAUiQ2zLHHAB4Uq
CINlCCekAducPooWL14cIyAmlClTpjjEGYeoYn5Vr169vOzs7EYuJIKZoNyWkmm2eVo2EHaw0tXWaLS7
OD10VTFQ1+A7SCnGrJFnvsePUHJzc/9qvNNTn/eDOfCwRcDvHqwayHuwG9jnlkqG/eOEXNUw84CVNBhg
UTdYSqe2vhhLrqYIj4tE9tlByuVGKGGXI8x2MQkFqopptNd7wjz7O9XB/xokXIxJLpIm+2NZocQ86gST
Lr74Ymffvn1K6uDQjlgepp9hh7iZKmoAkcuTJK1gw9fR+++/X5GItKEMHTpUpdfX0cjJQ8JWU6eYQpV/
HalDjcW7M8pDYsGWcm4cEjsPcxllQ4NEVOEzMxtIwxsRyR/xPZZkDSnn1+Z7/AiF3vGeIfn4uv57wRx4
NKj+2e8eOPLJexB+wO8eGDeNPMckzUSWjWHfMFeh3PIchFDCLkeY7WIQyg9uq4vwyYn3DPiYmGoPLqz8
YHsDDZGq8e6vUGA7ClXEtfSBJeJiSSjafqI8X3H17dvXQcQ2GGURiNo0yu7YscP5+OOPnWXLlh3H56uv
vupA8tG7j3H91Llz50nUkTqZeQgJGTDYcaNgmZF/kKoNZi1408IJzK3jYdY1yGKM+SI/QjE7CXT3ZAvl
MvC6BKiHI6K8WPr3lQpN5z659SARQgGoPh6R6bE6FqBcJqGEXo4w28Xct+R2gWj8HNMQXsNUk/iCyoZ+
GjkVJBaWELR/yeFXXnlF+ZIwoRBpOI8//rgiia+//rp479696mTAEg4ohmetVpmO6yDWx6BG7d+/P7pm
zZriZ555Bh1LkUuPHj2epEHJumuWZyYTANQb2Rgk3j7Lv4Ek5OoNZg4i0pf5b1Z3GNQR9vJvpiMSEI9Q
SCfPNjrV3rKUKxkHMOlfgUEZ5D2mOkD94vdeefAjFMrjWTI9TSQHEy1X2OUIu12CEAquvLy85/yeRZJX
c/iZePkXwZ+lLOSXclBhFiPSmlvkNpNA5MqO2/fyks8BwcAu8/TTTytSITVkc/PmzfmojTJLKnBDl41g
6sdSv4foi13C/DerOwwpNlPH+9F8l5+EIpdSTT0+USTjoo48i/dDFfUlbWw1kO+RQZISJRSI6uagIKlQ
qryByhV2OcJsFzdCgQ8U1CjTizk7O7tfkGdCStbEUsprlso1L9m8phKqgWgAYRnS2bRpU2z1xiQIqd4k
AvkcJqhVq1Yd7d27t1KpqBHYRlEmUjHFbIQrlL+DYLxmEUR4k2nNzm4u2/kRiunOXZYwkckQiulVihnQ
7x4i+NXGPTEv4UQJBd6xZh2be6mClCvscoTZLiahwN2A82f6ocDXSfqX+AF9V7ov8FWzZs3zk81vSsBq
T926dWHsOoQI92xsLQ9IYtmzZ0/RHXfcoaQV0hXZKStp9Qc+I7LyzT0tMOi5iZSmugPAb0CmIennt/J3
P0KBmGtIS4MjSSIZQjHtCH5OZrApwXmK02uDdkxvT5RQ4Csi02t1pUTbupSrq/mcsMsRZrtIQsF7zNVA
OMsZfaSULS4e4KSJQF/yGX6hSdMONopSxuHW68ybN69UsKXyANtpDh8+XHTrrbcqUsnPz+8t85Qo4IbO
Fe8VcY0a+W2TUEx1ByDC6C7TmL4EfoQCj1z5uzbOBQl8XQrJEAo2Qsp7vBz0GHAAlOlplv80Xh58CKUS
iedvyPQkGXxoJpJR9TRZ9DfThF2OMNvFz/Uey+rSwQ1LwiQRdXJ7lhdAQjK/5l6tCgliQkSI3wAnNulS
X95gUoHbf58+fdBZdlCnUlJFokvKcD2XFQ8jlls6eJiahGKqO/r91WRoQ8w28nc/QoGbtLn/BA5z8dyn
sbU9yD6aIISCQEfSsAydnPT4i9zS4nnSVoHLXCoPSihwEjOJQtfPI2Za+APJNG5xfMMuR5jtEmS3senT
pIk1tlIFWxNJTdO82hQ+PGWRclINJYIWFhYq+8myZctcz+ZJBamsWbMGfivoMLwyk5DzG3WyS/w6MIAl
PEkU6BRez5Qu+9ibEhGic5C9PPDSNQcWlgERzEm7pYPLs9FhqVO/ogdMkbmnJNm4IYinIe/Ds2lg/BsG
aeTky2tiwEnjNK4gS7w0U06Cvw52akOywHMpzXg3nwp4g7qtUMAZzkxLg+t5LKNK/4swyxFmuwQhFKxU
mbuJpW8K5wVECXWsZs2avVF27OGB17cZr5fSXxWk7dMGmtlBKhuHDh1aKoRBqsCetjNmzFA+L9SIypia
iOpjdjp0Dq+0cN/mdPGismG7unwmRFj+LQihAOaGNXlB13ez5mNgymeUIRBRNa+d15il3YJLQ0Snsp1j
PisZ13s90H702tMDacbcV+M2cMIsR5jtEjTAEohJPg/Ex8ZbkqT/z3yPV1wUkB6RaL0gbZ9y8GClSrkh
kibphMEE9tNPP0XhPIcl20TLYxrv4nlANmjQ4EaRztPKb+7zkSQVlFAImYgolkjcDXQy+YCyhEpEvA2e
Zf0uxOrwcppLlFAwyOEP4hfJDku6boZycyYOqxwCZW6XREJAUl08I5+ltyNkwD8nyLs1QbpGeqtQoI7y
KfxPioqK0iKdMFhKmT9/vpJSSIpQ6/bUkQJJKYbLPaLMea4WwQiHNPHUHcAUyaEP828Qy+VvXmEORPou
MCi6qQQ6z4cgEbl1GjNmhnQlDwoSnwdh+4G5CxazIZY0EXIw3rlCbnE75AU7B5ZrYY+AuimlOT/AUGlK
DF6ifVnLYaIs7SI39kFSivceqGdm4HQ8E+E90Xe8PGU1MT/jdXJARYGyT2jVwlmyZElKVnbiQZzrEz33
3HOxbj9T5jVsYFcqNejZ5fFsP2DWxiY32B6wmpTimKFZkN4QiR4Bg2ArSOG74wIqEPIGV3lzyd8FoZcj
ze0C80MTqGkgU9gE4bdTFse7VEINUmLlGd27d3c9FiMd4DCSzz//PJaR99avX78J8pmOuLQWFhYBwIOT
dFcYd3ZNmDBBDeJ0kwkTCrB+/fpiyhtWEq7ReU7L2T4WFhY+4MHZrl07bCd3Pvnkk1JHYqQLIpRk0VVX
XYVATRN1ti2hWFhUUDChjCkoKFBBlORgTjeQD0hM48aNg9qzmXTKU2eHpYXFaQil8uTk5Lx65513uu4u
Tid4tWfhwoUglCP16tVTBy1ZO4qFRQUF3ADpYy2HfSxvMvEKdxCPUD777DO1fNyqVSve9p3yEwgtLCzi
Q83y1atXx76FHTiUyzwxMBmiiEdI5m9+5MV52bhxozpgrLCwUO2hsIZZC4uKB0UoVatWxZr99nnz5iVN
KEGIQviWIOJbIFIR4SSLsrKy4Ew2WufdEoqFRQVDCULBIenJEAoP+n379uHs49gGPyPKm/r8/vvvnUsv
vVSFJ5g9e3ZgQtm1a1dRixYtcB97pyZEKHB0glt9IkFtygpEhMM+DY5MBtd9/A3vzlTlweL0APW1v8s9
Qenqa4pQaKBB5dn58ssvJ0wokkwGDBigiOLZZ5/1JJQPP/yQA1Q7CFGgoyN4kgrf9+233yqVp23bthxQ
JhChYM9Hq1atZkrXZfr7Rez6LI8KlYD7uQykjB252o08oUOusdcI0fjNi+rinfLIdyKAmzry4nbYFjo0
6jsVdV1eSLbuq1Spko8T/mrWrHluKvKJvUMyJGayfS0UkISCreGb+ZD0RIyyPOA///zzGFFQwXAoWAmi
4M8DBw44I0eOxJZtBweBxSMT+fy1a9cqQikoKFABhoPaUOQmLGwS4+hd2BZffjV6Ms4G3tOhQ4fN/B1H
kKtRo0aPRJ6Vk5PzAJMhIp3xFVYZsOUAm9P8Th90A+oUeTP36mAXrN7TsjuMPKYLydZ9vXr1fof7sOep
vPMIqRvvkoeYJdvXQskP/qldu/a8u+++O+GASpwOkQ6eeOIJHOPovPPOOzEykLFnmRygEh08eDAwYWGV
B0dxUDbxfN5vE2SVJ3aMhj56AOTZFhu3srOz+5ZTfSpgXwneK2cyHLiN78zgzH5AVC5dhhvCzicAsRjP
TyZYD9evGd8EG/zwPTbuhZfT1CPZuscgp3q9Pci5QWUFyBx5lPFeku1rYYAd2/6EfTy7du0K7NhmSh/A
4cOHAxGF2zvc3smEMn36dLWfp06dOoH386Axeat3ROw2TmT3abLApjItCcWOTMDW9KBHP0jQbPMWnhU0
UnqioFn4QTwfQYoSuQ8b9vTO4lKnAFD5L9Xb8l8LL6epR3nXfRhA3pBHhOzg75Lta2UGqw4kmmN7OE4H
TCgOihup8P/nzp3rjB8/3sExGU899ZQzatQoZ+nSpTGi8CMT/g5S05AhQ0AofI5tYKc2nFWrRb+e5VB9
nuDQkhzGgAcfqQgbEn0W7kk2TEEQ8CzsFsM1HhBEGvfps5VLgMo/EL/haM3wcpp6lFPdh+qUyQHUOQZP
WfpamcEzPbEcRKO9MKgmapiVvifyaI0lS5bE7Cp8rV27thSheL3LNMiS+HyPznbgSPiIz8m6PEIUmr/D
YIujSBF9C8cUIGIYQhlgQCC+BcL1mUGrcYAYZl7orDgaExZ1xPyAesMdD4eC4714Dv7mwYcZL9E24tPy
EOgZtg6+YPgLmh+khT0JoSsR7Yx0fLXRknT8sQjMrInhc8QPCZovRJzHfTC+UrkWyovesRG/NW7cmNtM
Bb1CnnilDYGh8DdHyYM6ir9RNhzjiTaDGI8YITijmsq3FcdoQPqR+YC9Am2IoOQIxgV1Fs/BwW3i3Wjn
99EuyBuOz8DRnmWpe5Hf1+hzMeofkQLdyoqwA1TX46h/fQ2JGcGyTaknSB7pnW0QYwZ1ASKn941gOw+H
kjT7Gs4lQl4M9SsT50Tje0SQC9LeiSBDv/hFxB5BkGg/qQE2EEgNX331Vex7SQycbvXq1cpIS4933nzz
zRK/6X066v/RaNQZNmyYs2rVqhiZsLozZ84cdTYyieStZX4DFSwjI1sep4FBFRGEhOMO+DdqpG/YAAdL
PmLIcvQwHpgIYM1RtXAvBqgMgMOBb3A4E/4GOeFvPh850Sjl0IG9ghhhiTBofviQcerIKzFItG0jE51S
pvc6yNwNUJF0fRUhD/ISgZF+o5NX0gbNQ3w/SA1pmMSoji7n+0BSHGAa7YH/c3hIOfOCsERQo10y2ps8
ela2MyYOpEMQJpBVsnUv88sBnviYUPwtyloJA5cDT3FsYuRBSs5+eQSB8cFkWFzgw8P43ciPrscSfQ0n
ZuJvfei6Ag6y15PIukhIJ3VKqAFKAw+GSgx8zx3HUgIBQSA9G2ElseDSIWmV6oN0hw4dUn+DROSzt27d
6px33nnOgw8+GLPB8O84sP2SSy5BBc/nxkmifJXQ+bmj85GkssPoCFyVOFIWzwwcSpKPr6QBNxd/Y4Di
fgQB4lizIKGIbhzMmJqIVAR9nPeiVaDRiWScj+/AwEcnlhfyGzQ/3OmQBjMVxyLVB8QXoTMjoE+8aO8m
IGLrjjrS/I0HEMdxxbM1GXzBaTC7ainmP/A3Zlhd1jUcFFqTy0HkGcvPPOgw8yPv3KZ6hSoLB7BBUuA6
ke2MwcmHtHMIy3grW351z/kFOSOQNI5b1e9rKsvKJ1hCAuRg21Tmu6WNKUgekVbfM1dLG1kyij6HAjX7
GtpAkIeyIXKkf1PaCx3du3f/8LLLLlMhA/ykFGDTpk3q0HQc0LV+/fpSaQE4zFFHKEVQP/zwgzNp0iRF
NgsWLCjxfJZciIxULBQaoJcgf2Vxuee4r9QJD9CfWVhS0x1iBaeB2IxG5YGF5UFZ8XyEA3ce/dxztIQT
W7ZjaYcjh0G10ER1UyJ5ptnmCt2J5rj9HjQ/fC4O8iVFbe7IWP5NJF8Ak61bAHCI9jyT6zz11GI428Ei
JJlM0PerQ9P4uA0mKCYU5F3fomZ+PheZjZFm3mkgPobv6Xl/1u/uoSWWjzgNk2G81Ru/uuf8ghzk91iG
12VdIMuJs6GgkuGCyqMlka+C5pFVUxl+Ev0UEwe+5/OE3PoaS6LIG5OQ35lGZQIPVCoszjhxXnzxxWJ9
wLkrSUgVB5II3PapoZ2BAwc6UFG2bdumnN2AadOmOf369VM+KKROIeaK88ADD2CQOmPHjlXEIqUffu7O
nTuPwl+FKmxhMmVCxZsrOtA9mc1x1IKWWJ7RdYCzd07IeKB8pjGWgXm9X1vPY8TGR3bgfGT9VSaL6ZyG
D2I3BnOOXxn4uFQ342YC+VGqH+wSLLnwLCgGeok6DpI36Pu4FyEXjZ8ytdoYc+qDg5Wu60mciEmO7u+F
v+FwqOtITR4460eWnaUcnmn5eE9IZPLl7HvEZ+eIduYjWWJkyO9yQ7y6d8svAyEb9ftU/B6WLLTatlle
UEED5jFLq0AlHAVhU9GT5H7+zq2vsdQClRYTKvpAWY5dDQrV+L169cLyk/PFF18cZRXFC1LqgLry3nvv
OaNHj4a45Vx44YXODTfcoD6pQytJhjqukkhmzZqFJepSz2HpB4ZhqECUtpie1VHmLwjA6mgANDp/J0//
g7hMM8sQ/J+Pc4SOas4SpqTBq0YIWK2TZPHhS9yxcV6LlnxW8XM4aDY7gOFMWujBbLT1AmZZPQsOdfs9
SH50npQezjYHkAv+Fh35r5w2aN6YnM3zaRCLVc++W/g72BYM8q7O6grHi8WhV7qOCvA3otDLspszPx9v
ClsCDzKQDtuReNXKbGcA2yLku5KpezO/DK5j5F8/Z6wmptixG8inPE4kSB75bGN5/CpJMQ+xmijyVaKv
AVBxpY0GUpNXuUMDr/hQhuvTzPwdbBd79+4t8iMVt3AEt9xyizN8+HBn//79arn4xhtvVJLMSy+95Fx+
+eUliESSCf9/5syZiFSPwX2LzltCqg6s8GBiLWp+h0pmgx0ff4AG1iKlso+wCC1WBzArHJOSBncOSAUw
vGKW4UZixzAczsS6Lt/HOitb/WFj0Ea5uJ6MfFQEgi+7/R4kP/jEzIZVBpygqNUB5cEpOvL9/MyAecvS
buhQSUu0DZcf+0v4Ozi6QfoDiWDm5sEiyVvUkXKSE+7jquzmzK8Pzdqg23grfH7Y0U5LoepsZLOdAfQJ
2R7J1L3Zpgy2ffBpirrsRbhA9vD7AdmCtPl4jyB5BLHpto5iomQJSffpv/nli9V3EC4Or/cqd6igTCgj
HlUmxFClwhw8eLDYj1SYENgQ+8ILLzj9+/dX3yHOCnUg591331XPw/fSg9YkkyVLlqhTA0my4Uj3Sa3b
Y0aD2C/PWsHxDOw9yCsfvA8FUo0ebGPxN8+0LJbq+qmBpWgmJ9hcYIPB/9l4BpuAngV4CVaJq+yGjmVN
UyrwAg88r4j8QfIDchUrCyfwTBgO8RtIRnfkAYnkDbYRPZC/MX/j8oPg5PfID+vy6NQYEGKWLlFHAJMf
l53JD+cbcxqoonKlSm+SKyH5mO0cOamSHffbFuBT96Xyy2AJEZIefwdSksdmgPjgScu/B8xjFiYH3j4C
MmcpCcvqfvliQzkbwVMJRSrUUPBVcAYPHgxJIyapBNl7s3z58hL+J1dffbVz3XXXOddcc40Dr1e3e2Cz
ITKBPcAhtSum05c1OhvsKPoYBL+jGBJ6phb1E84bbA+QesI8liFIfjB4/VzByyNvJrShNtSlSqgQKZt1
k0cm1GptuyhL+I3K1JZ5bse5egGEptXQTenarKnsFd27d/8DfTjXXnuts2XLlqgkgXgrQDDAQkpZvHix
8lXhXcUmkYj9PcdmzJihHNh69+79ro4iF8vHzwVszU/UzT0VqMh5s0geWGzgVTfzsPhUgw8A60MfuyIn
l3ejfKqgJAU313s3SD8Vlko2b94cxVnKeH7fvn2nMZlQRfysyIShl/0qZICoipw3i+TAxu1kjvQtDyjR
lHTrhueccw58CJxBgwY5H330URShDo4La6zwblWqES7YVHCZqhIkEkTYnzx5stpFTNdPpI//Trz3Z0km
FhapBNRL2JRgO4Pan+78MGL6bmFh4Y30AWcc56677nIWLVp0bNu2bVFEy2eCcQMIBL/jAPTVq1cXTZw4
UcVEiZy0lzxfv3795voVGTaivYVFOMByMXyNsNKU7ryYiEkMCMhErHdr69at4WehSAGxVKZOneq88cYb
zooVK5x169Y5X375pQq8hB3GWC5+7LHHlIObvucH0uv+SuqUXJoMfU+BhYVFBYbpD0KEcD4Rw+jIydAC
W+hiFca84Mn3aUFBwdT27dv/jlQoueJipRILi9MZbo5mONWvUaNGZxJZdKX/dqarCxx36LuuDRo0cFuu
zIhYW4mFhQVDEwuuoBIGpJFMK5FYWFhYWFhYWFhYWFhYWFhYWFhY/Bzx/65Mtr+WQfECAAAAAElFTkSu
QmCC'
  data = '
iVBORw0KGgoAAAANSUhEUgAAAIoAAAAoCAYAAAAhU2KBAAAPAUlEQVR4nO2bCXBWVxXHv0DYAySEfSdA
yr5Zx1jaihapGinYyqBWpEpr68QtgFSqCIiWYRFQRpayDIrSIqQQcdgkdGjLGpBFaiUC1jaAUHbCEkh4
nt/znvTy8r7kfV9SaMt3Zt6875539/u/55x77vlCoRjFKEYxup1U1frdqGbNmg083+vI00n49W9jn2L0
ASMFSdOkpKQFTz/9tNO+ffu5hpcmz9IxY8a8NXnyZKdJkybTPWVidJeQLvinhw8ffv7MmTPO+vXrHUkP
kGf03LlznVOnTjnQypUr4T9o8le5I72N0R0hBcm9Y8eOdYqKilxAjBgxYpfwntu0aZObviJUWFjo9O3b
97U72dkY3Vmq1r9//0OXL192AYFEEd4rI0eOfAeQ3BASkBS+/fbb8J83ZeLvYH9jdJtJpcn3du3a5VwT
Ahh5eXkAYr9IEzctGCm+LrRv3z74j3vKxuhuoX79+r2KWkFyAIwdO3YUCfs1Ac8NBQrfAJPwB5titw0o
cXFxNW5XWxZVEUqIj49vXK1atebh+iDfWiQnJz9Vp06dvu9HJ+SE2Zn65d39/ag/CMWZd+MJEyacNirG
NVA2b958Tfgv5ubmFttA2b59O0B5zJSLCiitW7de2LZt22WlOhMXV71nz54X6tatO8DmN23adHzv3r1v
JCYmDommvWjpnnvu2dmnTx9HH+nDzS5duvxLFm2Ena9evXqf53urVq3mhqurItSwYcMM6peT5pj3o/5y
SRZGgdJx0aJFVwGEaBcXGGvWrAEo87ds2VIiUcTILdq4cSNASTflogJKp06d9gggLknzNW2+AORhJkSA
8ROb36JFixnwZYG+FU170ZICJSUlZZWAYJ6kdwhYrsNr0KDBNzTfRx4oofckSsqcOXOueIByXfgzs7Oz
1UYpso7GvU25aI7G1Xr16nWNgdevX3+w/UEmeo4ujLeQiP9GUbRVIVKg1KpVq4fyGjduPBpehw4dNijv
bgJK44kTJ75rq56srCxslAyRNGcNgFzJMmvWrEvCb+EpH5jQsyrKRf380f7WrVu3d+DzVp4syKbOnTsf
4Kldu/Yn7L4zgR07dtzSo0ePd6XMMQHYn0UqPcRHsRfuowzSqVGjRj8UKbYfKSYLncl3bI+WLVvOljz/
QN0JKHbJt1H2mPyAIm1+B56ozwXKCweUIG0EGYsfUES6Psn42rVrt4J01apVGzZr1uwXMs693bt3PyX8
LK+KrAyKGzZs2AEDiOu8BSCXhf/AuHHj3jISpZB3Zmbmf0L/d+NHRYhsBYpM3kU1EGUx+tj2gEiQpvBl
8jZLvvPwZOI+q/1t3779OlPHJfKgzrAh1PbRxZOJPyv8otTU1Nf4Xb169fbSZm0Wj+/YHLIo2SwQ6TZt
2vxO+6pAQSXWqFGjoyzYt7t27fpv+m2Dxw8oQdsIMhYvUDCaRSoXAj4MXXhS5xLyCEhOmjm7RJvRrpMf
VTGTsvLSpUslx2MByBlhJw4ZMuRV0leFcMQNGDBgvVU2PhSh+lF7QyTFRqN+BsGX3TDB8P/KWyb/i1oG
49cGCrvJLECenDhaaT5ZvF6ys5L5rYvHk5SU9DV7rCJlfgpfJjQHA9odSHx8M9nJ+fBFct1r5uQWY1Yf
WbhnQpZU8ANK0DaCjMUGCqcvAcMJAVKxtKu2YkiAUUAeAU4X01ZTaePjkaxNeaQG6dhDhw65zjaESnp6
eo7hzzt58qRzWejIkSPYJ+yGWqFbnW0sQCA1BNrNRKWxa2QnLIWPyGTHy+C/wHeAo2W8QMGoNBM3Nlw7
unjssJDH6EYNGYN0uM2XNicaY/pnph0XKKI+ZmKbCMh/JRLlLXgi2pd727KBEkEb5Y5FgSJlxln5f+wZ
017T119Lslq4uipCJXc8L7/8sutHATCSPti3b9+VgwYNOka6WAigzJw5s3DKlClnhw4d+nfJM0eee626
ypUugEGe0/yWQW9HfCLWjUhegs+C3yKO/6JlvEBRVVSWX0EXT+r8vedTnIjty3yzdzAkkucr2g/Tv1I2
itgd9bS89LuD3ZYFlMBtBBmLAgV145FqJSTq6AGVKth4AtBh4eqrKCVkZGS47vrTp0+7YMEsuXnzpgsS
3jYJyzlx4oSzYMECQLUo9B6Kw4JFJq21EcevkMaw1BOEUUMD4YsU+C+PlvMApSo+FURvqIzjeRknERax
EGkW8khBJt8Y2a5t4AcUiO/wxUj+QZi2grYRaCwKFLOB1krdV2WznZNN1cTOJ/ZXCvYP7RqD+4VwdUZF
okO1k789duyYa9ACDn0rOBQ0kN798Pvw4cM4o/ZIxzVGxVcNCRAescQjwGmpg7INW7VfdDd6JYro80Nm
F3YON6ayjqwYl6b+ljZfFu9Fo/YmkQ4HFE4n8Js3bz7Zbkv6OT/SNoKMRYECSCQZj9ryOzUqJSQkfAow
MbfYReHqjZqk4pxz58656gfDFWB4JYkCxoCGm+ZiDN38/Hx06Jay6sfDahxnTypPTiNb7V0MiS0wzUiY
L5H2AgXnl7ETskKWrSTGX5KCqyygaH2yWD9XHkdZpJjHFioFFIxMBXdiYuKj8DBMSXPKibSNIGPxnnrY
UAowqac/PAFaN6m/rpbn5OQ9FFSUVJo8tnbtWgVJcSl0hCEAA6gAy7Zt21BDYzz1lhCONGPIlvhDEN/2
pEPoV7Njf0naCxR8Btg58GRC9rGz8Vdw/FS/QllAERHdRnbcFbUV8LWo8YnfRvMpUOCxe1GZqAqzu9eF
3lOzcZxE4FMGlRC0jSBj8fOj4GPR0xLA4fiP4S5lZ3FAAMz4U7CpIsRD2ZSWlvY6IQaoGz8pEgAsrqNO
7ByO1Q11Au02EMcMQDpf4ofhQs2482srjx1siVqA8oIBykOaRxairUz4el04c8I5ru5/vQ7A2+s3XtpQ
f4UxFK9IO4vZ9ZoHY9s+FmN4UgZwey8IOarKt7/ZR9QgbQQZizr5OHnZ5QCvAdBzqHOZ3zfV6MXNwGYp
f+WDke6IB1966SV3sSORJjahhrBZ9u/fj1RxjTzL9imT2H3RDoAFE0qVnemN7Q1ELJo5vVTKTbip65Y4
naBtVHQsEDaJF4iVQQqU2RixxjiNBieuVEEacVK6//77c8psNUYfTho4cOBOwlDCqR0/oxZA2aCy1c/4
8ePxkySb6iO+D4rRB5PqjRo16hgLzEJ7AWGn9Xc4G0bA5iJn2bJlqJ8+pv5Y8PWHnHSnN5gwYcIpBYof
SFAnBQUFJZIE2rt3r7Nhw4ZSQKEOTk9Sb39Tfyxc8iNC9UePHn3CT6IoKJYuXepa4raqgTdixAiv6nGd
cVlZWQDlPlN/KYlijmwRB2bLKaJ3cnLyN/VdwXHfNSRH7ucxcOW09n29doiKBg8evBsbBR+Kn1o5evSo
s3PnzhJbRX0nXsNXJdL06dMLpFr1SN5ioxAzwcUajic5RnaNpJ/4E3DG6dsvD8dU7jwIB0hJSVldXp2c
MKTM58J955iqrnL8Ot7ou8om4lDwydD/pKSkofY37q3wu0RYZRXmgzd+HO7VoumX7vY5x48fL3XqMaEp
JcRfNfj3YEZGhsONsk3kxRgGK+np6TvDtBePaxmvo3FZRyRVbJDw9ssDH6dT0DoBVrt27Vb6feO4io9H
07jfZfEe98tbWUQwUhnu/IhvhfHuCuiO8Bs/ULRB6gqUfsuXL3clin2aeeONN5ycnJxbALF69Wpn9uzZ
JekLFy443DqfPXvWjWWhjNTnXoH7+VFkEX+DY0qQ3Yk01+apqanb8EriQJJBHeUGGVc5ntAuXbr8kzyk
8VSahV1hx2LYJCCajlcT55OI2u9yv8QVPHXAkyzxeIhpD4cYTkB2nJ9zCp8GTjDK8eAwI2gIhxuXeywo
rnfCNFkMxoXHlhgUHurwa9+M+XVAISrhlv9wc+dFn8gr7XeWeg/jrscVL2VeJQ8qRMoeZByUJ41HmLkT
IH+VdcUBh+Tm3oy+sDmJnMO7raEdeHrV+x2YpBM5LLZXqhw4cMBZsWKFs2fPHoDg7N69m3ha5+LFi0Tq
uzG03CIryETihPXMKvHXAwJ4Qv+XMNe4OMP9bDyZu1kMwEA0nLk4LMKDK5ORy52Gvv3qRjogsrn3IGCI
iSYvE426Q1ebSP+H6R8TasIjS4GafwPY4Q6Upx+EQSJZqFPa+xN3PSwuYp1dS8ARoCJ43Nu+GfNV6mHh
bW8zatD0sS6PqfdNbDqCkLiMRPXQBnPIPRnXHfQHlchv4mS4/yEv7ePVlmcRdh35mRNUm6R7Muf0IyhG
VKp0HzduXLE5vdywD0CcenJzc51JkyY58+fPd6ZOneo8++yzzsGDB9XoLQZgq1atQpo8oeP2AwhxF7pY
7Eizy+KMiK9CGk8tgCE8ktAEJpZvSArK6pvF8noxTble/JZJqSV5z/Amko5dBz8hIeEz7C4kBgvNInKt
4I3yJ/RRrwAQ2aYfhC6uITBcAPYjkWBTExMTHxNp+AfGRhvURR/92sddb8aMNN1lA17A8DHtI6T1mt9f
RhLQBguMVCMIik1FmIaM6UEuW7knIliK+zHKUYaAJy5Y9bYZqUsddnBYUNJFfWLJkiUKjkLAYgNm8eLF
ONOcKVOmOAsXLnRVFKDCNtm6dSsg0XsVX0nCwOkgDyKPwXHHQdgeYpM8iF55xQMCeIhz3mbyT+ubkEBE
t1fn8g0xq2naUfENKAAfot+ouCZGrfUgYozwRbsuTgsaScZpAanBbyQdRi4Lzq5HItGOqkU2AHc8fu3r
mPmm0sOan0f1IhDSes3vkRwE+I3UwDBF3SG9dHMBHO6DkEBID76zIZE0pi73r8AY70h0+34tElLJ8sy0
adMIiSwBQZE59+bn5xfn5eUVFxQUFBl3fSEnoOzsbBsk5bZjXwqWRRpr6keEJ4azU8qrx4CrqpWuxU6O
xNCLMG/YcURLxsVQptebcfnxsVns/yVF1b55fzItLW33unXrnPPnz5c6LkNXr1511dHw4cOPS/6v2/2r
SAcCd7SSr88r/Tr+A0qoINRzqBLWybYtHhF9tlwM1CMzZswomDdvXsGsWbOuZGZm5ouIJx7jKXn0pjJ2
p/MhIFFViba6qyh5vamI2dbyEA7QVh7v7ou56WMUoxjFKEZh6H9xNMaNxSmFgQAAAABJRU5ErkJggg=='
  if (2 == (global 'scale')) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method trashcanIcon MicroBlocksEditor {
	dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAAIwAAACMCAYAAACuwEE+AAAACXBIWXMAABDYAAAQ2AEmEfhPAAAAGXRF
WHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAFVhJREFUeJztnXtw3Fd1xz/np11Jq4et10bS
Lk4i2Ymr2FacB8GQpOOGBkqmKWUgvBo6pNNACEkABxgY6NAy0AkEAiSEhJq2U2JCoXTyaBsnhHg6qV2c
BDcBY0+I48SJLa2NJMuOredae/rH7sorWft77O+5ij8zO7a0v9+9d3/67r3nnnvuucLrBFVdAvQBvcDZ
hVcX0F7yigF1QEPhtnFgCjgBjBRew8BBYF/h9TKwW0SOBfE5wkbCboAfqGoT8CbgUuBCoJ+8QPz6vEpe
ODuBHcA24GkROe5TfaGxKASjqjFgHfAO4O3AWqAm1Eble6VngZ8Dm4HtIjITbpPcU7WCUdVa4ErgvcDV
QGu4LbJkFHgY+CnwuIhkQ25PRVSdYFT1QuB64H1EXyTlOAz8BNgoIs+G3RgnVIVgVLUeuBa4Abgo5OZ4
za+Ae4FNIjIVdmOsiLRgVLUD+BjwcaAz5OYAkMvlGBoa4vDhwwAkEgnS6TTxeNxt0QeB7wL3isiI28L8
IpKCUdVm4Ebg88DSsNoxMjLC4OAgg4ODDAwMMDg4SCaT4cSJE3Oua25uZv369VxxxRU0NDSUKc02x4G7
ga+JyKjbwrwmUoJR1QSwAfg00BJUvePj47NiKP67f/9+jh93NitetmwZGzZs8EI0kDeSvw58W0QmvSjQ
CyIjGFW9GvgO0ONXHRMTE3N6jEwmw4EDBxwLw4wVK1Zw6623YhiGV0XuB74I3Cci6lWhlRK6YFR1BbAR
WO9Vmdlsdra3KB1OinaH39x8882sXr3a62J/AXxURF7yumAnxMKquOBsuxX4EpCotJzh4WFeeeWVOT3G
8PAwuVzOs7Y6Zdu2bX4I5o+Bnar6JeBbYTkBQxGMqp4N3AdcVuH9bN++na1bt7J3715UQ++p57Bz505y
uZyXw1KRBuB24BpV/QsRedHrCqwIXDCq+mHgTqC5kvtzuRybNm1i27ZtnrbLS7LZLENDQ3R2+uYJuATY
oao3ich9flWyEJ5/BcqhqvWquhH4ZyoUC8D9998fabEUGRgY8LuKJcAPVfWHhdllIATSw6jqMuBn5L8Z
FfP73/+erVu3etMomyQSCVKpFKlUinQ6Pfvvxo0bef7558veNzg4yIUXXhhEEz8ErFbVd4vIy35X5rtg
VPVN5BfdznBb1pYtW3yzV+LxOKlUiu7ubtLpNOl0mu7ubtra2ha8PpVKmQomgB6mlAuAZ1T1nSLia/fr
q2BU9V3AJk4GJLkik8m4LsMwDNra2mbFkUqlOPPMM+nq6nJkpKZSKdP3vWirQ9qBX6jqh0XkJ35V4ptg
VPVG4C48tJPmu+TNEBHa29tnh5Bij9HV1UUs5v5jp9Np0/cPHTrEiRMnPKnLAfXA/araIiLf96MCXz6N
qn4G+BoBOwbPPfdc1q1bNyuOuro63+pKpVKISNkhMpfLcfDgQd7whjc4KndkZIRMJsPAwACHDh1ienqa
ZDLJunXr7M66DOAeVW0WkW84qtwGngtGVf8G+LLX5QKcccYZvPhieddDMpnk0ksv9aPqU6ivr6e1tdXU
ezwwMFBWMMeOHZv1QJd6oycnF142evTRR7n66qu56qqr7DRPgNtVtU5EvmrnBrt4KhhV/SQ+iQWs7YaA
DU1SqZSpYDKZzILrVwMDAxw75ixmPJfL8dBDD9Hc3Mzll19u97avqGpWRL7uqDITPBNMwWa5w6vyFsLK
bshkMqgqIsGMhOl0mt/+9rdl33/iiSfYvHmzp3U++OCDvPnNb3ZiG92mqke9smk8MUhV9d3kDVxf/1JW
PczU1BQjI/7GHuVyOTKZDDt27ODQoUOm105PT3te//Hjx3npJUfrjwJ8rzBjdY3rHkZV3wj8kAC8xi0t
LTQ2NjI2Nlb2moGBATo6Ojyp78iRI3NiZAYHB3n11VfJZsON396/fz/nnnuuk1sM4EeqeoWIbHdTtyvB
FBYR/wuP/Cx2SKVS7Nmzp+z7g4ODnH/++Y7KPHr06BzDs2hrTE1FM8R2z549vPWtb3V6WwJ4UFUvEZFX
K627YsEUArN/BiQrLaMS0um0qWDMDN9iZN18cZj1WFHkhRdeqPTWTvKiuVREJiopwE0PczchRPBb2TGD
g4NMT0/PzkaK/w4ODjI6GrkQ2YqYnJx0Y9xfQD6y8SOV3FyRYFT1OuCvKrnXLXYEc8stt0QuRsZLZmZm
OHz4MO3t7ZUWcb2qPikim5ze6NhQVdVe4NtO73ODqjI0NMRzzz3Hrl27LK9dzGIp4oHP6Z5CeKwjHPUw
hbDKH5GPxfCF0dHR2VDL0mHFjylqNWIYBh0dHczMuI7QbAL+RVX/0Em4p9Mh6Vbym95dMzY2dsqsZGBg
gPHxcS+KXxQYhkFDQwPt7e309fWxZs0ali1b5uUa2VuATwLftHuDbatJVc8Bfo2LgO29e/eyZcsW9uzZ
w9GjRystZtEhIrNrU6lUit7eXvr7+0kmA5mAjgP9IrLXzsW2BKOqAjwB/FGlrXrsscd44IEHXhf2hRl1
dXUsXbqUrq4uenp6WLVqFWeddVbYzXpcRN5m50K7Q9J7cSGWXbt2ve7EEo/HaW5uprOzk7POOouVK1fS
19cX2DqXQ65U1XeJyANWF1oKphBgfJub1jzyyCOLViw1NTU0NTWRTCZZtmwZK1euZNWqVdTW1obdNKd8
Q1U3W23LtdPDbCCf7qsicrmc08WySCIiNDQ00NraSjqdpre3l4svvpimpqawm+YVvcAt5Pdzl8VUMKra
Qn5mVDG5XC7UXYiVUF9fT0tLC11dXfT19bF27VpaWgLLDRAmn1fVjWZZI6x6mM/gMstTLBajubnZccCQ
34gItbW1s8Lo6enhggsuoKurK+ymhUkL8Angb8tdUFYwhWQ+N3vRilQqxe9+9zsviqqIomiTySTnnHMO
fX19LF++3I+trIuBT6nqd8r1MmY9zI242KFYipNofzeUzkzOPPNM+vr6WLly5WlhOGMJ+axff7/QmwsK
RlXrCjd5wsqVK9m715ZfyBaGYdDY2EhbWxs9PT2sWLGC1atXk0gEtmN0sXOLqt6x0IypXA9zLfks2Z6w
evVqHnnkEcf3FT2gyWSSdDrNihUr6O/vZ8kS35ayTpOnE/gA+X3wcygnmBu9rN1qD4+IzHpA0+k0y5cv
Z82aNX5mPziNNTdgRzCqej75dOuekUgkaG1t5bXXXqOjo4OWlhaam5vp7u6mr6+Pnp6eqHpAX89coqpr
ReS50l+e8ldS1XvIq8tTHn/8cXbv3r1oPb5B0dLSwjXXXENjY2MQ1X1XRObMlOf0MKoaJ79u5DkPP/zw
6ZgWj1i+fLmTzWxueL+qfkpEZqe58+ebbwcWzm/hktOGqncE+Cw7gCtKfzFfMNf4VbPVrsXT2CfgZzln
xJkVTCH88mq/arUK3j6NPerq6twEf1fCn6vq7FFCpT3MOnw8HeR0D+MN6XQ66BllO3Bx8YdSwbzDz1pP
C8YbQnqOs9oonSW93c8ai5mfKl1Xqquro76+npmZGU9TvYsILS0tc7Ih5HI5jhw54kVk/iyxWIwlS5Yw
OTnJ5ORkxSEfIQ3tf0JhBTsGs2ckOtuQ7BDDMOjs7LS9n0ZE6O/vp729nUQiMWcB8emnn7bMnGCXtWvX
Lpj0Z2hoiO3bXe1bn8UwDC6//PLZYCtVZWpqivHxcXbt2sWRI0dslxVSD3ORqjaJyPHiX2EdAWTUdPJh
iyvOjY2Np6w29/b2etIewzDKtimZTHq2mJlMJudE5hXXyNra2ujr63NUVkg9TIyCHVP8S7wliFqdCKa+
vr7se0uXenOEUl1dnakB6ZVgzNrrpI4lS5bQ3OxJxEklXAonBRPIpnongjHLwRKPxz3JTmk12/BqGcNM
FE5yzYQ8cbgITgqmP4ganXSn5ZIDFjHrgaKGmWAmJuxn3QhZMGsAjMKJ8YHspGpra7N9WpnVg/To1LNA
MGtrFQmmV1WbDKCPgPLpigjd3d22rp2YmDAdEqopus6sN6wiwRjAHxjk96MEht0Praqmw1K1CKauro6a
mpqy79sVjIhEYUfD2QYuNqlVghM7xuxhVosNY9VOu4JJJpO+Zja3SY9BQPZLESfdqtnDrJYexqqddgUT
kaWVHgOwZ1R4hJMPvhiGJLN25nI520FlERFMl0E+SCYwGhsbbW87tephqiEO2GpKbdfXExHBdAQuGLD/
4c2yURmGURUZErzywUQknqjDIMAT6IvY/fBWD7QahiUvBBOLxTjjDNcH2nlBqwEEbnrb7WGsvL2vF8F0
d3dHZbtvnQEE3q/bFcz09LRp/EzUBWMYhulU2OoLUSQi9guEJRgn35hqnilZrYZX2ZQaCoIJnHg8bjtD
ZDULxmq9qwoFgwGEsrvM7kOoZufdInPaAUxFXjBmU+tqFoyVfVakoaEhSunSpgwglEOBvJha19bWRmX2
sCBerFJHqHeBgmDKn3LpI15MrUUk0r2MWduqcIYEMGIA/h6SWIZkMmnLU1vNzjsvfDBRFMxwGDUbhmEr
mKqaA6kWoWCGDeBgWLXbeRgzMzOmK7pRjYuJxWLE4/Gy79s5tcVJhGJAHDKAV8Kq3QvDN6o9jFW77Ngw
ra2tUYtdftkA9oVVuxeGb7UKxs6QFJEV6lJeNoDQDgLwwnkXsW/gLGaCsYpXLhIx+wUKgtkNhJJ4bunS
pbZ28i22IWlqaspW4FTEBJMDnjdE5BjwclitsDtTKkdNTY2pcRkWi3CGtFdExopu0p1htcLOQ6lGX4xb
wRiGEYVtJaXshJNbZXeE1YrXo2DsTKk7Ozs92T/uIf8HJwWzLaxW2BGMVQKeqAmmmM6jHFVq8G6Fk4J5
CgjmyJF5FNPKWzE1VX6NNGqCqaurM10UtTMkRUwwWeAZKAhGRMaA58zu8ItiYh0rqinMwQsfTMQEs0NE
xmFuUsTHQmqMazsmassDXmyPjZhgHi3+p1Qwm0NoCOBeMNXUw1itjUEouXitmNVGqWCeAsoeDukndlzg
VssDUdoF6XaGZNeuC4hh4FfFH2YFUziA4KEwWuS2h7GalQSN28CpiK0hPSAis1PU+ab8vwXcGOBkDl8z
qskX49ZpFzH75aelP8wXzOOEEIFXU1NjuRXU6kFXSw9TZYIZAv679BdzBCMiWeYpKiisHlI2m62KXZBW
SQKqTDA/Lj0rCU7tYQDuDagxc1gsMyUrA9xKMCHn4p3PP83/xSmCEZHfEMLaklvBRCUuxq3TLkIG71Mi
8uv5vyznv/6ez405hcXivLMKnLISTISGowVHmnKC+RGQ8a8tp9LW1ubKQxqlIakc2WzW8hSTiAhmELh/
oTcWFIyITBFwLyMilt2x1S7IKIQDuHXaRUQwd4rIgu5os32m9wCv+dOehbF6WFbdeQTSkrraHhuRbSVH
ge+Xe7OsYERkBPiOHy0qh1vBRGFYcuOD6ejoiILo7xCRsgc4We1k/yYB7r22Ekw1pDBzc65ABIajEeDb
ZheYCkZEjgK3e9kiM6xsmFwuZyqasKfWtbW1pmnirQQfAcHcJiKmZoidXBl3AC960x5zmpqaLA/xjvLU
usp9MHuBu6wushRMwVr+nBctsoMbOybsIcmtYELuYTYUZsem2MrGIyL/DvzCdZNs4MaOCVswZj2c1XAa
i8Xo7Oz0o1l22CwiD9u50En6puuBscraYx83PUxDQ0OogUdu4mBCzMU7Dtxk92LbLRSRfcDfVdAgR7gR
TNjp5N3MkEK0X74gIrb31zuV9LeA/3V4jyNSqZTpN83KWxqm4evGBxOS/fI/2DB0S3EkmEJsxLX46AGO
x+N0dJQ/LyPKvhg3Xt4QBHMU+EsRmXFyk+NBU0RexsGYVwlmD296ejqSuyCt4oojKJgbCmaGIyqyskTk
PuAHldxrB7OHZxUiEJZg6uvrKw6cSiQSQefi/Z6I/GslN7oxy2+isH3Sa6rRF+MmNCOdTgc5u3sK2FDp
zRULpuDkeQ9wqNIyylGNgnHjtAtwOMoA77HjoCuHq4m/iLwK/Cke+2eSyaRpkqAoCsZsSm0VwB6QYCaA
d4nIATeFuPYUicivgPcDjqxtM6xy+JrNlJxko7JKG+ZkmDCr12pmF4APJgd8UESecluQJ65FEflP4ON4
mCvP7CG+9lr5Wb3dU1oh/803wyzFiJNrjx07Znqvz4JR4CMi8qAXhXnmixaR7wOf9Ko8s256dHSUI0fm
xvgUZ0+7d++2XceJEyfIZBYOXR4dHWVszP5Iu3//foaHh08ZelSVffv2lb2vtbWVxsZG2/VUwGdF5B+9
KszTIFgRuVNVm4GvuC3Lalzfvn077e3tTE1NMTk5yeTkpO0jfUt59tlnOXDgwBzvsqoyPOwso342m+WX
v/wlkB+eEokEiUSCiYkJ0x7RZ/vlCyLyDS8L9DxqWkS+qqpHyLucK54r2tkJefCg+6z3MzMznpRTSjab
JZvNmgqliE+CUeDTInKH1wX7sjwqIncDH8OFIdzS0uJ3Vx0JfLBfZoDr/RAL+CQYmLVp3k1++bwiIrQL
0Dc87mHGyE+dPbNZ5uNrAIaIPASsp0LnXgRiXH3F41y8B4H1IvIfXhW4EL5H7IjIM8DFwHan9y52wXR2
dnqVxXwHsK7gE/OVQEK8Ct7F9cCdTu4777zzopS6y3POO+88L4r5B+AtIhLIMUaBxQSKyJSIfAL4EDbj
aTo6Oli1apW/DQuJeDzOZZdd5qaIo8AHROSj5ba1+kHgQaQisgnoJx/tZcl111236IzfWCzGtdde6+Zz
bQcuqjREwQ2h9feqWkPeM/xlwHQH2szMDE8++SQvvPACIyOhnGnqCfX19aTTadavX1/pDoEx4IvAXU4j
5bwidANBVXvJ5yK5Muy2RJzNwI2VRMl5SeinhIvISyLyNuDPyO++O81cXgTeKyJXhS0WiEAPU4qq1pEf
pj4LWB9AsLgZAW7DJFdLGERKMEVUtYl8uMTngECDXSPAceBu8hvjy6bdCItICqaIqraSX5O6CQg9047P
ZMj7qe6NolCKRFowRQpD1QeBG4BLQm6O1zxF3ui/P0pDTzmqQjClqGo/8NfAB4DyO96izRDwY+AHIhLa
eZuVUHWCKaKqMeAK4H3AO4FInRezAMPkD//4CbAlLD+KW6pWMKUUnIBvBN4BvI38YmfYKTWz5I+N+Tl5
H8ozpaeCVCuLQjDzUdUG8rbOZcAFwPlAD/75nXLAS8BvyJ++upW8QCqOBYoqi1IwC6GqjUAfeeH0AGeT
n3m1F14dQLzwaircdpx8T5ElP6SMFF4Z8ofD7yMvlOcL52Yuev4ffUqHj9IIyMkAAAAASUVORK5CYII=
'
	data = '
iVBORw0KGgoAAAANSUhEUgAAAEYAAABGCAYAAABxLuKEAAAACXBIWXMAAAhsAAAIbAFh5+LxAAAAGXRF
WHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAACyFJREFUeJzNnF1sHFcVx393Zr1e2+uv2mS9
O846cRLHjUNJDQ+oDSVFImlpq6aIiic+JAqi4jO0Erwg8QQIikiREBJCQPJAS2ijShTSVKIfNBIPbVWS
pnGcpDSQ7K4dp8k6jb+y3j08zHqzM7MfM7OzTv5S5MzMPefe/d8759x77rmjWCWIiAK2Ah8DRoDNwEYg
CvQU/wJcBbLFv2eASeAU8AZwXCklq9Fe1UzlItIDfA7YCewAPtSgyhngFeAw8KxSKtugvtWDiCgR+YyI
HBCRBWkeFkTkz8W6Au/gwBSKiAbcB/wIGPejI5fLMTU1RTqdJpVKMTs7S3d3N9u3b2fNmjW1RN8Bfgb8
SSm17KduOwIhRkTuBfZi2o66KBQKXLhwoUTAyt+ZmRkKhYKjfCQSYc+ePaxbt66e6kngu0qpFzz+BAca
IkZEEsBPgS9UK3Pp0iXLj0+n02QyGZaXvXXs6Ogoe/bscVv8eeCbSqn/eqqkDCG/giLyEPB7TI/iQCaT
Yd++fbz33nt+q7BgcnKSpaUlWltb3RS/H7hLRL6mlPqzn/o0rwIi0ioiTwIHqUJKLpdj7969vkjp6Ohg
ZGSEHTt20N7eXl4vU1NTXlR1AU+LyH4RafPaDk8jpuh+/wpsr1Xu2LFjZLO1PWlrayvxeBzDMEgkEhiG
QTwep6fnOtdTU1OcPHmydJ1KpRgaGvLSZDBf800icr9S6n23Qq6JEZEB4AXgI/XKLi4uWq7b29sZGxuz
kNDX14dStU1cIpGwEJNOp6uWzWazTE1NoWkaw8PDhEKWn/Zx4FURuUcpdb5e+8ElMUUjewRY76b8Lbfc
Yrnu7OzkkUcecSNqQSKRsFyn02nm5+dJpVJkMhnOnz9PJpMhlUoxNzdXKheLxXj88cfp6uoqFx/DJOcT
SqnqDBdRlxgR6Qb+hktSwPmDZmZmyOVytLS0uFXB0tKSY0RNTEy48kzT09O89NJL7N692/5oGDgsIncp
pS7X0lGTGBGJYJKyrW5rytDd3U00GuXq1auAOW/JZDIkk0lH2eXlZaanpy3uPJ1Oc/HiRUSsy6JKc5xq
mJycrPZoK/CciOxUSi1VK1RvxPwSuNN1a8qQSCQ4depU6TqVShGJREqvwQoJ09PT5PN5P1XUxNmzZ2s9
vgv4OfDtagWqEiMiDwNf99Ooy5cv09Zm9ZD79+/31OONolAokM1mLV7Ohm+JyL+UUk9VeliRGBFJAr+r
V/nc3JzFAK6Mhvn5+YoNXQ2Ew2Hi8Tjj4+N2z1QJvxGR1yp5qor+UkQOAg9V03bkyBEOHTrExYsXPTU6
SOi6TjQapb+/n2QyycjICFu3biUcDntV9YxS6mH7TQcxIrILc75SEadPn+aJJ57wWrlvaJpGe3s7fX19
DA4OsnHjRrZt22aZFQeA+5RSfy+/YRlrIqIDv6ql4fTp00E2yIJIJEJPTw8DAwMMDw+zbds2YrFY0+or
wy9E5LBSquQF7C/h56kTOgiip1pbW+nq6iIWizE0NMTtt9/O2rVrG9bbAEYxI42lBWeJmGIU7Af1NHR0
dLiuLRwO09XVRTweZ/369dx6660MDw97a/Lq4Yci8helVAGsI+Ze4MP1pLds2eK4p+s6nZ2dJUM4NjbG
6OioG69wM2EMMzb9AliJ+bIb6Y6ODu644w5CoRAdHR3EYjGHJ1haWuLo0aMBtdcf4vG4Y2niAl+inJji
euh+t9Kvv/46hUIBTfMczlkV5PN5brvtNh599FGvortFpEcplV0ZMQ8DroM5/f39ZDKZpkzlg0AoFPIz
WgAimPO3P6x0+S4v0slksm4s5UbDJzFg2hlCRW/0SS+Sg4ODvPXWW1y7ds1yPxqNEovFaGtr49KlSzUD
SyvYsGFDydOdPXuWK1eu1JUZHR1FKcXCwgLnz593BNaXl5cxDMPDL7LgUyKiQpieyNMOoWEY5HI5x/2R
kZFSg+LxeF1idF1ndHS0ZKsKhQLHjx+vKdPV1cWmTZtK1/l8nnPnzjn01tmHqoU1wJgGfNSrpGEYjliJ
HZFIpK671jTNYsB1Xa9bdzQatVxXakd/f3+jU4VxDXNz3RN6enqIRCKO+wsLC5Zre+ghCNh12usEKgbE
PGKzL2IABgYGHPduBmJaWloYHBxstJrNGmYc1DPWrVvnGPo3ghj7jkShUGjE8K5ggwZ0+5E0DMMxwVtt
YhYXFx0BsHw+HwQx3RrQ6UfSMAyHm1xtYirZl3A4TG9vb6PVdGpcz2TyhEq9ksvlLGQFTYymaZYtmErE
DAwMBDH57PS92IlEInR2Ogdb+TsfNDFtbW2WH20nRtM0N6kirqBh5rr5QiXrXx4Ir+TSG4E9SGY3vLqu
B2FfAD7QgA/8SieTScdEqrwXNU0LlJx6rrrBpUA5PtCAWb/SlRrRTANcjxgRaWTxWI5ZDfiPX+lEIuHw
TPbhHSQx9tFn37+KRqOeQq818K6GmbfmCwMDA3Unec16lfL5vGMhG9BrBDDZEDGhUMiR8tHMV6nc+C4u
LloWkLqu+0kqqoZJDTPj2jfsQauFhQVLg5v1Ktk7QCkV5Ih5UwOOAxf8ahgcHLR4pkKhYAlgBUVMOBy2
vLZ2YvL5fFCG9wJwQivm5r/qV4thGI71SnmjgyLGTbghHo8HUdU/lFKyMvM97FeLYRiOoHh5o8PhcCC7
CXZi7B6pt7fXU8ZWDbwI19NZnwGcXeACfX19jgaVE6OUCmTU1Ao3KKWC2uJdBJ6DIjFKqVnMbGrPUEo5
glbN8Ey1XqVQKBRE1A7guZUTLeVj/I9+tQ0NDdVc3DWbGBEJyiPtW/lPOTGHgLf9aDMMw+KZmk1MLpez
2LWA1khHKbO1JWKK3uknfjTag1bNJsauX9d1+vv7G63ix+Wn5+zu4gA+ZsL27ZRr165ZerTRZYGmaZbD
FXZiYrFYo55vAtMBXa+z/KKYUVQ1xbMaotGo40BEkAGr1tZWiw0rd9WapgWxFHhsJS+mpNdeQin1IvCs
V832d7y8VxvNwqoVoNJ1vdHtkgNKqUP2m9XG3x48xmmGhoaqGmBd1/1kU5ZQyyM1uCuQBb5X6UFFYpRS
5wBPpyIMw7AM9yDjMrWIaWAfSYCvKKVSlR5WtVhKqWeAX7utpZmeqVaAKhKJ2E+ZuMWTSqmD1R7WM+WP
Af90U4t9ZRtkwKqcVBFhaen62QifK+pXgO/XKlCTmOLpjAeAf9erqaWlxZK3v3LypEyXQ6ZQKFjcfLUM
rXLZubm5koyu6362S94GHlJKXatVqG6uhFLqiojcB7xGnX3utWvXks1mERHm5+c5c+YMoVCIhYWFirky
+XyeU6dOlfan7HkuKzh58iTZbJa2tjZmZmZK9zVN8zpi3gV2uTnh7yqJRCmVFpE7MZcNVc8uJZNJTpw4
UbI1ExMTdXWXH92phtnZWWZnnU4yl8t5MbzHgXuVUhk3hV1PF5VSU8Dd1LA5bhKKgoRSyu2IeRXY7vY8
JHg8Xlwcgjsxzxs4GEgmk6uaydnb2+vGqP8W2FkMrbiG53ysokH+joi8jHkgvZRa0N/fz/j4OEePHkXX
9aZldooIuVyOBx98sFaxK8BXlVIH/NQR+CcMRISJiQnef9/1EWfPWNm8r2Ffnge+oZT6X9Ma4QYisktE
JgL6/EkjOCEin76hZNghIpqIPCAib9wAQo6JyBfFPG91c0LMD+vcIyJPi8h8E8mYF5GninXdvB/WqQQx
D298FtOT3Q00elxtGngZMwR5UClVP43cJ1btQECxV7dgfrxrM+ZJug2YX+2o9PGuWcxMjMnivzeVUu+s
Vnv/D5+W/VhX9GaCAAAAAElFTkSuQmCC'

  if (2 == scale) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method hideDefinitionIcon MicroBlocksEditor {
	dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAAIwAAACMCAYAAACuwEE+AAAACXBIWXMAABDYAAAQ2AEmEfhPAAAA
GXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAFr5JREFUeJztnXt0VNW9xz+/kSQQ
MuEVkgYSTRBCstBA8AGKFTSEVsRS0BXhUm8rVPuwakXEF7239VYq5VLfrd6K1auAcrt8NPgooIJe
F4+AIFEgiAkSEohMgEDeCbPvH2cmN+Q1Z86cxwTms9asRZIzv/1L+M7e++zzewjnCEqpeCALGAak
+V7fAQa1efUCYoBY39vqgEagBajyvTzAEeCA71UK7BaRU3b8Hk4jTjtgBUqpOGAcMAEYC2SjCcSq
31ehCacI2A58CmwVkRqLxnOMs0IwSqlewHjgOuB7wBjgPEed0malHcBa4D1gs4icdtal0OmxglFK
RQN5QD5wAzDAWY8Cchz4B7AaWCcizQ77Y4geJxil1FjgNuBmwl8kXXEMeB34q4jscNqZYOgRglFK
9QZ+BPwcuMRhd8xmG/Ac8KqINDrtTCDCWjBKqQTgF8AdQJLD7ljNEeAZ4DkRqXLama4IS8EopdzA
L4EHgX4Ou2M3NcCzwBIROe60M+0JK8EopfoA84EFQH+H3XGa48AfgSdEpMFpZ/yEjWCUUjcATwLp
TvsSZpQBi4BXREQ57YzjglFKDQf+Ckxy2JVwZz3wMxEpcdIJl1MDK6V6KaXuB3YREYseJgNFSqkF
SinHDiUdmWGUUmnAK8BVTox/FrAVmCMi++0e2PYZRin1E7RZJSIW41wObFdK3WL3wLbNML7Dt6eB
n9o15jnCK2h7m3o7BrNFMEqpVODvaJ+MCOazA7hRREqtHsjyJam8vHx2fX39DiJisZIcoFApNcHq
gSwVTHl5+cLDhw+v2LNnz6D6eltmzHOZQcB6pdTNVg5i2ZJUXl7+VEVFxZ2nT2shIFFRUWRlZdGn
Tx+rhoyg4QV+KSLPW2HcEsEcOHBgZWVl5WylzjyYjIjGNhSwUET+02zDpgumpKRkzbfffnt9Vz+P
jo4mKyuL3r17mz10hI4sEpFHzTRo6h7mm2+++e/uxALQ1NTE7t27iexpbOH3SqmFZho0TTDl5eVP
HTlyRNdBUnNzM3v27ImIxh4eU0r9zCxjpixJFRUVDxw6dOgPXq83qPdF9jS24QVuEpE3QzUUsmDK
y8tvPnz48KqWlhZDtiKisY164FoR2RyKkZCWJKVU2oABA/7scrkMCy+yPNlGH+AtpdT5oRgxLBjf
s6G/9+nTZ2BWVhbR0dGGnYiIxjaS0ERjeDoPZYZ5Fl8Ef+/evYmIpseQgxbZaAhDS4lS6lbgxfbf
b2hoYM+ePTQ1NRn1J7KnsY9bROTVYN8UtGCUUsPQno7Gd/bziGh6DDVATrBBWEEtSb4c5hV0IRaI
LE89iDjg5WDDPYPdw9yLlvTeLRHR9BiuBH4dzBt0L0lKqRHA52i3Z7qILE89gjogW0S+1nOxrhlG
KSXA8wQhFojMND2EWOAvei/WuyTlA9cY8SYimh5BnlJqhp4LAy5JvkOe3WgVnAwTWZ7CnhJgVKC0
XD0zzHxCFAtEZpoewDDgrkAXdTvDKKX6oynPtMI9kZkmrDkBDOuuakSgGeY+TK7yFJlpwpr+wN3d
XdDlDOMr5lMCuE12Cgifmeb06dPU1NRQU1NDY2MjjY1nFoHq3bs30dHRxMXF4Xa7cbkcS0e3i5NA
WlezTHeC+Tfgd1Z5BfaKxuPxUFZWRnl5OUeOHMHj8eDxeDh1Krjyum63m8GDB5OQkEBSUhIpKSmk
pKSQkJBg+HcIQx4WkcWd/aBTwSilYtCKFn/HQqcA60Tj8XjYs2cP+/fvZ+/evZw4ccIMd7vE7XaT
np7O8OHDyczM5Pzzz0fE8WoqRqlEm2U63DF1JZh5wAtWe+XHLNF4vV6KiopsEUgg+vfvT2ZmJtnZ
2WRnZxMVFeWoPwaYKyJ/a//NrgSzHa2Ctm2YIZr6+nree+89x8XSnqioKLKzsxk/fjyjRo3ivPOc
rjmti60iMq79NzsIRik1Gthpi0vtOJtF4ycuLo5LL72USZMmkZyc7LQ7gcgRkTO00Jlg/oJWD9cR
7BRNVFQU6enppKWlkZSURGJiIjExMcTGar0p6urqaGho4OjRo1RWVnLgwAFKSkpoaWkx7FtbLrzw
QnJzc8nJyQnXu69nROTOtt84QzBKqSi0erED7fSqPVaKJiYmhpycHMaNG8eIESOC3ls0Nzezb98+
tmzZws6dOzvchhshMTGRa665hgkTJhATExOyPRPxAMki0voJaS+YaUCB3V51Rm1tLV988UVINtqK
Jj4+nry8PK6++mrT0nQbGhrYuHEj69ev5+TJkyHbi4uLY8qUKVx77bXhtEn+nois9X/RXjAvA/9q
u0ttaGlpYdOmTaxZswav18vUqVNblwgjNDQ0UFdXx+TJky37T2hqauL999/nn//8pynLldvtJi8v
L1yEs1xEWquGtQrGF375LQ41fFBKUVhYyJtvvsmxY8davx8fHx+yaOx69lRZWcmLL77IgQMHTLE3
aNAgZsyYwaWXXurkmU4VkORv3dNWMFcBnzjhUVlZGa+//jpfffVVpz/vSaJpaWnhjTfe4IMPPjDN
5ogRI5g1axYpKSmm2QyS8SKyBc4UzKPAQ3Z6UVtby5o1a9iwYQOB8rJ7kmgANmzYwGuvvUb7GjlG
ERHGjRvHTTfdhNttyeO97vidiPwWzhTMNmxsLbN9+3ZWrlxJTY3+Lnc9TTSFhYUsX77cNNEAxMbG
MnPmTL773e+aZlMHW0RkPPgE4+uReBytSaalnDx5kpUrV7Jjh7G+Uj1NNB9//DErVqww3e7FF1/M
nDlzGDDAli1nCzBARGr8gpkMrLN61E2bNrF69Wrq6upCsmO2aKqrqykuLqasrIxjx45RW1sLaJ/m
hIQEhg4dSmZmJv36GevEs3r1alP3NH5iY2PJz8/niiuuMN12J1wjIhv8grE0lKG+vp4VK1ZQWFho
mk0zRAPa0rhr166Ay4aIMGLECCZOnMgll1wS1F1LS0sLS5cuNe3uqT05OTnccsst9O3b1xL7PhaJ
yKN+wbwN/MCKUUpKSli+fDkej8d022aIxsizpyFDhjB79mwyMjJ0v6eyspJHHnnEtMcK7RkwYADz
5s1jxIgRltgH3hSRmX7BlGJCoHdbvF4vBQUFvP/++wHvgEJh+vTpJCcn2/7AUkTIy8tjxowZup8D
vf3227z77rtG3QyIy+Vi6tSpXH/99VY8m9ovIiPE1zH+BCZW1KytreWFF15g9+7dZpnslPj4eBYv
Xszp06cde8qdnZ3N7bffrutEtqmpiYceeijoKL9gycjI4LbbbiM+vssUeCN4gX4uIAsTxXLw4EEe
ffRRy8UCtB73mxFY3qdPH6677jr69w+uc+CuXbt4/vnndc2i0dHR5ObmGnVRN/v27WPx4sWUlpra
esAFZLrQ8lFMYdOmTSxZsoSqKuubosbExDBx4sTWr50UTVFREW++qa/e4KRJk0LyUS/Hjx9n2bJl
bN4cUkm79qS5MGHvopSioKCAl19+2bJNXXvGjBnT4amzk6JZt24d+/bt02V/9OjRRt0LiubmZl56
6SUKCgrMOjxMdwEXhGLB6/WyYsUK1qxZY+qJZiDGjesQPQg4JxqlFKtWrdL1N+jKdytQSrFmzRqz
PszpLsBwnGBDQwPPPPMMn3xi7zPLXr16dXtL6xdNKBgRTUVFBdu3bw94XUZGBr16WX6ofgabNm3i
6aefDvXQ9DsuwFBCzYkTJ1i6dClffvllKA4YYtiwYQHvSnr37s327dtD+gMZEY2eD09MTAzp6fZ3
W967dy9Lly4NZY+ZYEgwFRUVLF68mEOHDhkdOCTS0tICXlNdXc2uXbt49913bRVNcXGxrtvmCy4I
aSdgmIqKCpYsWcLhw4eNvD3BRZAd6MvKyvjTn/5EdXW1kQFNITExMeA1+/btQynFyZMnbRWNUori
4uKA1yUlJRn2J1Sqq6tZtmyZkQ/8ABegO+r44MGDPP7445YfPAVi8ODBAa8pKytr/bfdomk7dlfo
+R2s5NSpUyxbtizY51sxLkDX7URpaSmPP/5465NcJ9ETlnD06NEzvrZTNHqem4X60NQM6urqePLJ
J4MRjT7BlJeXm7HDNg09Uf8NDR0LKdklGj1lSMKlwVhdXR1PPPEEBw8e1HN5TFhmT1mJ3ctTTyCY
UA0XEPCJ3dChQ7nrrrvCYhoFdCWPdbdsWS0aPUtmZzOgE8TGxnL33Xdz/vm6mpw06hIMaLey8+fP
Jy4uLiQHzUDPf3Sgei1WikbPhjYclne/WPQcU/hodAG6cz1TU1NZsGCB4VBFs2i/oe2M1NTUgNdY
JRo96SB6fgcrcbvd3HvvvcGIBXyCORbwsjYkJydzzz33OLp+V1ZWBrxm5MiRutZms0UjIowcOTLg
e/T8DlbRv39/7r33XiN5TlUutMy2oEhOTubBBx/U9Sm2gm+++SbgNfHx8brDFc0UTU5Ojq68Iavi
ewMxZMgQ7r//fqOlRqpcaBn6QdO/f3/uu+8+LrroIiNvD4mSkhKam5sDXtc2XiYQZolmzJgxAW+r
GxsbHRFMVlYWCxcuZOBAw8U5PC608h6GiImJ4Y477uDqq682asIQLS0tumJPxo4dy5AhQ3TbNUM0
QMCSsMXFxbbFDfm58sorufPOO0PNxap0AYHn925wuVzMmTOH/Px8WxPGt2zZEvAal8vF7Nmzg/LL
DNEEqiO8detWw7aDRUSYNm0aP/7xj80olVbqQquWGTK5ubnceuuttpWn2LFjh64T1YyMDPLy8oKy
baVo6uvr+fzzzw3bDYaoqCjmzZvHDTfcYJbJUhda8WZTGDduHPfff78tNWubmprYuHGjrmtnzJhB
Tk5OUPatEs2GDRtCym7Qy8CBA1mwYAGXXXaZmWZLXWidSkyLrUxNTeWhhx5i1KhRZpnskvXr1+v6
47tcLubNm0d2dnZQ9s0WTWNjoyUps+256KKLWLRoUbBnLIHwAnv9iWxfY2L2gM8m77zzDu+8846l
iWxTp05l+vTpuq71er289dZbrF27Nqj4Y7NyuSsqKigosK4inMvlYtq0aUydOtWK/eRXIpLhf/hY
ZLZ1/2Zr4cKFli5Ra9eu1X0I5nK5mDlzJvPnz7f97qm5uRm3223ZgefAgQOZP38+119/vVU3H0Xw
/+U+fgM8YsUooD1oe/XVV01Nxm9LWloa9913X1CB1UopPvvsMz7++GOKi4t1JeOPHj2aSy65JKTs
CCvqCDuRjH8tYPniunnzZlavXm1JEFZubi75+fmG3nvq1KnWch9VVVWtRY7i4uIYNGgQqampjBw5
ErfbHVbFp/v27Ut+fj7jxwds9GsGk0Rko18wfdHyq20pKLRq1So+++wz023n5+fbkooaDqLJzs5m
zpw5dj3Tawb6i0hd25JlhcCldowOsG3bNl577TVT44NFhLlz53L55ZebZrMrnBJNfHw8s2fPZuxY
W1tBbBaRK+DMGne/Bx6204u6ujoKCgp0FUXUi4hw0003MXnyZFPsdYedonG5XEyYMIEf/vCHTsQk
/VZEfgdnCmYC8L92ewJw5MgRVq9ebWpSXG5uLjNnzrQ8w9AO0WRkZDBr1iyGDh1qeIwQGSciWyGM
CjuDtky98cYbplV/SEtLY+7cuZbnAFklmoSEBG688Ua7l5/2eNAKO3uhY+n4vwE/ccCpVk6fPk1h
YSEFBQWmlDnr1asXU6ZM4fvf/75ljR8aGxtZt24dffv2NaV8mr+61cSJE23Pwe6Ev4rI7f4v2gtm
KvCO7S51QtueA2acWbjdbnJzc5k0aZJp5Vbr6+v56KOP+OCDD6ipqTHlRFgpxahRo5wo3twVeSKy
3v9FZ+1vDgOD7PaqK5qamvj000/56KOPTAlrjI6OZsyYMVx++eWMHDky6LIgjY2NFBcXs3XrVnbu
3NkhkKun1REOwFFgSJftbwCUUn8GfmGnV3pQSrF3714+/PBDioqKTKlF06tXL9LT07ngggtISkoi
ISGBvn37tv5H1dfXU1tbi8fjaW2wVVpayunTp7u1exaJ5ikROaOPdWeCyQbsCdgwyOHDh9m4cSPb
tm1zPM+7K84S0YwRkTO00FWTUFv7DhjF6/VSUlLC5s2bKSwsDJvkMD89XDSt/QXa0pVg5gLLLXfJ
RJqbmykqKmLXrl3s3buX48c7bexuGwMHDiQzM5OLL7641T+jOCSaW0Xkpfbf7K7ReSkhlDNzGo/H
w/79+9m/fz9ffPGF5QJyu91kZGRw4YUXMnz48DMKBlnVzN1CKoB0EengcJeBE0qpRcB/WOmVnVRV
VXHo0CHKy8s5cuQIHo+Ho0ePBt2rsV+/fiQkJDB48GCSkpJISUkhJSUlYOpGDxPNAyKypLMfdCeY
QWjxvqaWkw43vF4vNTU11NTU0Nzc3CFIKjY2lqioKOLi4oiLiwupJHsPEU01kCYinR5+dRuapZR6
BPiNFV6dq/QA0fy7iHQZTBdIMP3QZhlH+1ifbYSxaKqAYSLS5Trd7fwqItXAUjM9imBO8elAyXIG
eaw7sYCOphRKqWjgS2C4WV5F0AizmeZrYJSIdFv+JeAOzndr9UCo3kToSJjNNPMDiQWCaHujlFoH
WB/Gdg4SBjPNeyIyVc+FwQgmDfgCsDSX4VzFQdHUAReLiK6Uad2HCiJyAAsbiZ7rOLg8PaxXLBBk
JzZfGOdG4Mpg3hdBPzbPNJ+gtRfuPl6jDUHnVCql0oGdnOUnwE5ik2iq0cIXDgRjN+hzbhEpBX4V
7Psi6Mem5ennwYoFDAgGQEReAV4w8t4I+rBYNH8WkdeM2DSc5u8LgfgEMLViTYQzsWB52gJM1HPm
0hkh1YVQSp0PbAWca/5zDmCWaDIzM4/GxsaOFRHDndFCak4hIgeBaYDzPXHOYsxYnrxerzp27Nj8
UMQCIQoGQES2AbMA3bdmEYInFNG4XC6Sk5MfTk1NfTVUP0xpfyMia4A7MLFWXoSOGBGNiJCcnPxk
SkrKH8zwwdTaVkqpu4AnzbQZoSPB7GmSkpJeT09Pn2XW2KY22BKRp4BFZtqM0BG9M01iYuI/zBQL
mDzD+FFK3QE8bZX9CBpdzTQiQmJioqkzix9LWviJyLNo6baRjbCFdDbTuFwuhgwZ8qQVYgGLZwCl
1HRgJRAevf/OUvwzjdfrVUlJSQ+kpqb+0aqxLF8ylFKXAQVEDvcspb6+3nPs2LE7UlJSVls5ji17
DKVUCvA/gC31Qc9BtgM3ikhInWn0YEsbYt/p4iTgKTvGO8f4L+BKO8QCDtzFKKV+BDxLJJ4mVKrR
QhQMPXU2iiO3vUqpC4BXgO86Mf5ZwGbgRyLytd0D27Iktcc3fV4DLEALQo6gj1rgHuAqJ8QCYXCw
ppQaBjwHBNc27dzjPeCXRqLkzMSRGaYtIlIiIlOAH6Bl30U4k/1AvohMdVosEAYzTFt8UXy/BhYS
KQBQBTyGVpjQ+p5/OgkrwfhRSsWhhUs8ANjSriOMqEG7i3ysqxotThKWgvGjlBqA9kzqV/Tg8mk6
OYx2TvVcOArFT1gLxo9vqfoX4OeA9b1t7GUL2qZ/ZTgtPV3RIwTTFl8d4Z8CswHr+x1bw1FgFfCC
iJjeb9NKepxg/PjSdq8FbgamE0bl7rvAA7wNvA58GEx6ajjRYwXTFqXUeWj5UdcBU9A6yzndBqQZ
2AasRTtDKfS3kOnJnBWCaY9SKhZtr3MVkAOMBtKx7tzJi1YLcBfwGVqjskIROetOsc9KwXSGrxFq
Fppw0oE0tDuvQb5XAhDle/l75NWgzRTNaEtKle91GK3w9QE0oewVkXMiN+v/AAaMZBHUqrZtAAAA
AElFTkSuQmCC'

	data = '
iVBORw0KGgoAAAANSUhEUgAAAEYAAABGCAYAAABxLuKEAAAACXBIWXMAAAhrAAAIawEzo0SOAAAA
GXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAACytJREFUeJzdnF1sFNcVx393bVjb
WWPH608w4DjGGwgGqlRWaE0CWJAYMLSENMVJWqXkJUGgKJWiPPoxSh9oIoFUtWkRD04KhBQRPgoh
FFkogB0pEH+tU0rABn/gBbwLu9jYe/owXuP17szO7tpeyF+yrJ05c+fMf+6Ze8/HvYopgogoYCHw
c6AUcAAlgA3IHPkPcAe4PfL/v4ATaAcagSallEyFvmoyGxeRTGATsBpYDuTE2eQN4D/Av4HPlVK3
42xv6iAiSkTWiMheEfHJ5MEnIv8cudekvuC4ICIWEakWkW8nkQw9NInI70QkOdE8BEFEqkTEmQBC
xqNNRF5MNB+IyEwR2ZNgMsLhkIjMTRQpvxaRWwkmwAj9IvLKVBJiFZGPEvzQ0WCPiKRG+5xRfc2v
X78+x+fznSkqKiq0WCzR3iuROAusU0q5zF5gmpiOjo6ymzdvnvP5fKnp6ek4HA6SkpJi0jJBaAZe
VEp1mhE2RUxnZ+eSGzdunB8YGJgWODZjxgwcDgePWM/5H7BMKXU9kmBEYjo7OwtdLle7z+cLsdNH
tOc0Ac8ppW4ZCRm+bhFJGRgYOBuOFACPx0N7ezt+vz8OPaccC4F/iYjVSCiSHewoKiqalZGRoSvg
drtpa2tjeHg4Bh0ThueAPxkJ6JqSiLwM7AXw+/20t7fT39+v29AjalY1SqlPw50IS4yIzAG+B2YE
jv1EyekHFoYbqfRM6c+MIQXAYrFQWlqKkVl5PB6cTuejZFYZwI5wJ0J6jIi8ABzTa+kn2nPWKqWO
jD0QRIyIJAEtaBE2XfwEyWlDM6nRrj7elF4hAikwsWYlIni9XlwuFy6XC6/Xi8iURC/H4im0SOMo
RnuMaFGwC0CZ2dai7Tm9vb04nU6uXr1Kd3c3XV1deDwe3esKCgrIz89n7ty5OBwOcnLijYwaohlY
pJTyQzAxa4DD0bZmhhyfz8eJEyfo6+uLQd8HyMrKYtGiRZSXl1NcXIxSEx7RrFJKHYNgYvYCL8fS
mhlyuru7OX78OENDQ0HHCwoKyM7OZsYMbRB0u9309fXR1dVleE+73c6yZctYtmwZNpvNUDYKfKaU
2gwjxIhIBtAFRB23CMDv99Pc3IzX69WVCZCTmZlJZWUlixcvxm63h5V1uVxcuHCBkydPGva0adOm
sXTpUqqqqsjKyopV/QDuAQVKqdsBYt4E/hprax6Ph0OHDnH27FlWrFjBzJkzdWWHh4d55plnsFoN
XZVRDA0Ncfr0aQ4ePMjAwICuXHJyMhUVFVRXV8fbg/6glPpHgJh9jPsqm4GIcO7cOfbt28edO3cA
SEpKYtWqVYbkxDKUX7t2jV27dkX8TqWlpbFu3TpWrlwZ6zfoM6XUZjUyGvUQZTKsp6eHuro62tra
Qs5NFjlut5sPPvgAlytyIK6kpIRXX33VUAcd9AL5SkQWoQ3TpuD3+zl8+DBHjx41nKOYISctLY3e
3l5aW1tHH9ZutzN//nzKy8tJT08Puaazs5MPP/zQ0KzG6lBVVcXatWujDaiVKRF5A/i7GWmPx8Mn
n3xCa2urqdaTkpJ47bXXDHuF3miVkpLChg0bWLlyZcg1X331Ffv27TOlA0BpaSlbtmwhMzPT7CW/
T6qtrf0tUBFJ0ul0smPHDq5du2ZaIbvdTk1NDT6fT/cN22w28vLyuHz5clDAa2hoiObmZjweD2Vl
wXPOOXPmcP78ecMRcCxcLhfnzp1j1qxZ5ObmmrmkNam2tnYr2pRYF8eOHWP37t2muu9YVFdXU1JS
QlZWFnfv3o2aHIArV65gs9l44oknRo8FzKK5udm0LoODg5w/f55p06ZRUlISSbzXAhTrnfX7/dTV
1fHFF19E7b8opVi8eDHwwLcyGkbz8/NZvXo1ycmh6eeDBw+OjnoBLFmyJCp9QBtFDxw4wJ49eyL5
cE9a0GISIRgcHGTnzp2cPn06agVAe9CxkzeLxUJ3dzfXr+sH6PXI8fl8NDQ0BB2z2+3k5+fHpNuZ
M2fYtWsXg4ODeiIZFiDk0x8gpampKaYbA2FntC0tLZw4cSImclpaWkzdwyyampr4+OOP9cw73cKD
SibgASnh5ifRINwIcPPmTYaHh2MiJ9zcJYpRJix++OEHPXLSJy1bFu6bFJiJxkLOJHjShu1a0Grd
RjF9+nS2bt3KU08ZDlQREc7THuvkRUtOOAfRyJs3g3nz5rFt27ZwfpvHAoREigLkLFy4MOabhuv6
8+fPD/odDTkLFiwIORdPfKesrIzt27frObMeC1oKIQQBcpYvXx7Tjbu6ukLIKS8vJyUlJeiYWXKy
s7ODhti+vj66u7tj0q2iooK3336b6dOn64n0W9AS3WFhsVjYvHkzL730Ukw2fuFCsAuWnp7O+vXr
Q+TMkOP1eoNiyN99913U+lgsFjZt2sTrr78eyXe6ZEGrozXE6tWreffddw2D3+Fw8uTJEB+osrKS
559/PkTWDDmBAPvAwABff/11VLqkp6ezbds2Vq1aZUbcmVRbWzsb2BBJ0m638+yzz9LR0WHatr1e
LzabjeLi4Ml1WVkZNpuNS5cuBREnIly+fJnc3NywnjVo04nOzk4aGxtNFxOUlpbyzjvvMHv2bFPy
wN+UiJQBF81e4ff7OXLkCEePHg3pDeFgtVp57733KCwsDDl3584dGhoaaGlpGSU7OzubBQsWkJub
G+IGjIWeVz4WycnJVFVVsWbNmmjDDgsDgapuwJTbGUBvby91dXWmQhB2u533339/NOBtBvEE2EEb
imtqamIPVEHsGYJAaHP//v26+aEAHn/8cd566y3mzjVfZRoLOWlpaWzcuJGKiopYJ4WfKqVqAsRs
Af4WSyugmcSXX35JfX29Yde2Wq2sX7+e5cuXh/Wiw2FwcJDGxsaIwa5Tp06xdOlS1q1bx2OPPRb1
M4zBG0qp3ROWPgG4desWR44c4ZtvvuH+/fu6cna7ncrKSpYsWaLrCPb19Y2mT27fvh0xTJqamsrT
Tz8db648OH0C8SXcxuPu3bvU19dTX18fcQTLy8sjJyeHjIwMRAS3282NGzfo6ekJkpusAPs4BCfc
IPYUrRECw29DQwMXL16MO0Wbl5dHZWVlyOx5LOIkJ2yKNuqkfrTo6+vD6XRy5cqV0aS+2+0OK5uR
kUFBQQF5eXkUFRXhcDiw2+2TWYJyAfhZYKHY+PqYzUBdNK1NBLxeL/fu3QO07EBaWpqh/CSR84pS
am/gR7jCoWa0ZXkPNSaYnFa0wqHRqXTQdHCkomh7HPpOGSa4JvCPY0mBMMWJSqnjwOexKDvVmCBy
9iqljo4/qFfOOhutnDU6dzpBiMOsbqOZUEgWMaxnpZTqAN6MU98pQ4w9R4At4UgBg5J5pdR+YGcc
+k4pYiDnI6XUAT1ZQy9rZCHCcbTa+0cCfr8fp9OpOz8CyMnJuVpcXDxPKaWbcTMMUiilBoBqIPo4
YoJgsVhwOBy6PSc1NfVeamrqc0akQOTVJyil3MBaDGLDDxsCZjU+/mO1Wu9nZWWVz5w580rENszc
aGRF2C95hHtOSkrKvaysrKWzZ8/+3sz1UUVyRNur4SCP2Dfnxx9/7LBarb8oLCw0tR4yJsiD5cX+
yVoPPMH4i4joJpAmg6BficjNBD+0EfpF5DdTRsg4ch7mLQzmJISUcQS9ICKtCSZDRKRFRExl1KYM
8mCblMYEEHJRtG1SHt7FUaJtrPOiiHwmIt5JJMMrIp+O3GvCi2cmeyumDGAj2lZMK4C8OJvsAU6h
bcV0YGTyOSmYsi2MRt7qArTNuxxoK+meRFuUGm7zrn602bZz5O9bpZT5+tU48X90nMccQUXLVwAA
AABJRU5ErkJggg=='

  if (2 == scale) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method hideAndDeleteIcon MicroBlocksEditor {
	dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAAIwAAAFKCAYAAADPBrcjAAAACXBIWXMAABDYAAAQ2AEmEfhPAAAA
GXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAIABJREFUeJztnXl8lOW597/XTEJC
EjCQBCYLEmQJYbMuLIoVtcpirZ6eeqQute2pni4e20oPamv7tqen51istVZr1S5vF5dK1Sp9i+IG
R45yQMW2oCaAQFgSliTsZM9c7x8zE0PIzDwzzzrx+X4+8+HDzPPc9zXP/HLd23Vft/AhQVWHAtXA
aUBl9BUCinq9soAcIC96WwvQDnQBzdFXE7AXqIu+tgPvichRJ76H24jbBtiBqhYAM4DZwJnANGAM
9n1fJSKcDcDbwGvAGyJy3Kb6XGNACEZVg8AsYAEwD/gIEW/hJl1ExPMi8DywTkS63TXJPBkrGFXN
Bi4GFgKXA8PctSgpB4BlwB+BV0Sk02V70iLjBKOqHwFuBD4NDHfZnHRpBp4Afikif3fbmFTICMGo
ag5wDfBlYLrL5ljNG8CDwB9EpN1tY5LhacGo6nDgS8DNREY0rqOqNDY20tzcTDAYJCcnh/LycrKy
THeZ9gD3Aw+JyEHzltqDJwWjqkOArwC3A4Vu2XHw4EEaGhqor6+noaGh59XZeWL3Y+jQoVx44YVc
dNFF5Obmmq32GPAA8EMROWS2MKvxlGBUNRf4OnArDnZiW1paaGhoYM+ePT3/7t69m6NHU5taqays
5JZbbrFCNBDpJP8QuM9LTZVnBKOqnwDuJTKxZgvt7e3s2bOnx2PE/j18+LBldYwfP55FixYRCASs
KnIX8G0R+b1VBZrBdcGo6mnAL4CPWVVmV1cXe/fuPUkczc3NqKpV1cTlq1/9KpMnT7a62BeAL4lI
ndUFp4Jrk1vRybavA9/ng6n4lDl48CB1dXU94qivr2f//v10d7s3R/baa6/ZIZh5wDuq+m3gfrcm
AV0RjKqOBn4PnJ/m/bz11lu89tprbNq0yRGvkQobN24kHA5b2SzFyAd+AixU1etEZKvVFSTDccGo
6meAnwFD07yfxx9/nNWrV1trmIV0dnbS2NjIyJEj7apiFrBeVb8sIn+wq5L+sPxPIB6qmqOqDxPx
LGmJBeCJJ57wtFhiNDQ02F3FKcDjqvqwqg6yu7IYjngYVS0HniLyl5E2TU1NjoslJyeH0tJSysvL
KSsro7y8nNLSUn7zm99QW1sb9776+nrOOOMMJ0z8F+AsVf2UiOywuzLbBaOqpwPLgXKzZa1cuZJw
OGzeqH4IBoOEQqEeUcT+LSoqQuTkwWRpaWlCwTjgYXpzFvC/qvoJEVlvZ0W2CkZV5xNZnR1iRXn1
9fVWFMMpp5xCWVkZpaWljB49mtLSUsrKysjOzjZcRllZWcLPHRYMQCnwqqpeLSL/z65KbBOMqt4A
PAQErSqzq6srpesLCwtP8hilpaUMGmS+yS8vT+ww9+3bR1dXlxVrTKmQDzyjqjeKyG/sqMCWb6Oq
XyYyErK0U51s+Dx27FhmzZrV0+fIy0t7eicpZWVliEhcm8LhMHv37qWioiKlco8cOdIz0bh//35a
W1sJhUJMnz6dkpISI0UEgV+r6ikicm9KlRvAcsGo6q3AEqvLBRg5ciRbt8afegiFQpx/flpTOykz
ePBgCgsLOXgw/sJyQ0NDXMG0trb2LGb2no0+duxYv9cvX76cK664grlz5xoxT4CfqGq2iPzIyA1G
sVQwqvqv2CQWiHQ0E+F0v6G8vDypYDo7O3sWNXuL48CBAynV1dXVxdNPP01BQQHnnnuu0dvuUtVu
EbknpcoSYJlgVPULwH1WldcfyfoNDQ0NqGq/oxo7KCsr45133on7+cqVK3nhhRcsHdk988wzzJgx
I5W+0d2qekBEfmtF/Zb0MVT1UiIdXFt/qWQjk/b2dpqbm+00AVWlqamJDRs2JK2rvb3d8mmAI0eO
sH379lRuEeBXqnq5FfWb9jCqeiaw1IqykjFs2DDy8/M5fjz+7o2GhgaKi4stqa9vnMyOHTuor6+n
ra3NkvLTZdeuXYwfPz6VW4LAo6p6voj8zUzdpn5kVa0A/gIUmCknFUpLS3n//ffjft7Q0MC0adNS
KrOlpeWEUIiGhgZ2796dUJhusmXLFi666KJUbxsC/EVVZ4hI2p29tAUT3ebxBJEJI8coKytLKph4
dHZ2nhBqGRNIoo6rF9m0aVO6t5YDT6vqHBHpSKcAMx7mfiI7Cx0lWce3vr6ecDjMvn37TvAY9fX1
NDU12ba04CRtbW1mOvezgLuBr6Zzc1qCUdWrgS+mc69ZknV86+vrufnmm1OeFc4kuru7OXDgAEVF
RekWcbOq/o+IPJnqjSmPkqL9lgdSvc8sR44coaamhi1btiS8TlUHtFhiWDDn9AtVPTXVm1LyMNGw
ysewMaI/NjLpOwPq1Q6oGxQWFtLebnojQSHwO1X9mIgYbqdTagRV9etEQgRNM1A6oHYiIuTk5FBY
WEhVVRVnnHEG5eXlDB2advxZf9wsIj8zbJPRC6NxuO9gYgi9a9cuVq1axZYtW2hsbPRcLK5biAhZ
WVkUFhYSCoUYM2YM1dXVjBkzxolZ66PAZBHZZeTiVATzPDA/Xav++7//m6VLlw6IUYoZgsEgQ4YM
IRQKceqppzJx4kSqq6vtCBhPhb+IyCeMXGioD6Oq/4AJsWzatIknnnjiQ+VRAoEA+fn5FBUVUVlZ
yfjx45kyZYpVuyKt5jJV/biILE92YVLBRAOM7zJjzfLlywesWESE3NxcSkpKKC8vZ9y4cZx++ukM
GWJJkKGT3KuqLyfblmvEw3wVSGnhojfhcDjhzGym0LsDWl5ezmmnnca0adMYMWKE26ZZxTgi6VQS
Bl0lFEw0V9ytZqzo7u52dRdiqsQ6oMOGDSMUClFZWelkB9Rt7lDVXydK8JjMwywCDMUFxiM7O5uC
goK4kWRu0rsDOnr0aKqqqrzQAXWTYuBfgTvjXRBXMKpaCNxihRVlZWVs3rzZiqLSQkQYMmQIRUVF
jBo1irFjxzJt2jRbY34zmH9T1QdE5Eh/HybyMF/ComQ+Tg2lA4EAeXl5FBcXU15ezoQJE5gyZQoF
BY5FXwwEhhPZHHd3fx/2K5ho6MJNVlkwduxYSzu+fTugY8eOZerUqQOpA+o2X1fVn/aX6TOeh/k0
kNr+iARMnTqVF154IeX7+uuATpo0icrKyg9DB9RNyoGriKwbnkA8wXzF0tqTxLCA3wH1IF/CiGBU
dQomN833JS8vj8LCQg4dOsTQoUMpLCwkPz+fUCjUMwOak5NjZZU+5jlPVSeJyHu93zzJr6vqT0kz
GisRr7zyCtu2bRuwM75OUVhYyOWXX+7UEsPdIrK49xsneBhVzSLSf7GcZcuWWRHD4UNkmuK8885z
oqrrVPX23unR+nYQLgJsGWr4Q1vryM/Pd6qqEPDR3m/0Fcw/2VVzslhcH+MYGURYyFW9/9MjGFUN
AFfYVasvGGsYNGiQ0SwOVvFJVe3p6/b2MNMxuW6UCIf/KgYssTQjDhICenKv9RbMAjtr9QVjDS49
xx5t9BaMocQj6RIKhQgG009GFVsnsmM4mZeXd9LLagKBAAUFBaYzUrnUtPdEW2YBqOpgIon1bCMr
K4sRI0awZ88eQ9eLCBMnTmT48OHk5eWRk5ODiBAOh1m3bh1NTU2W2DVlyhTGjBlz0vt79uzhrbfe
sqQOEWH27NkUFkbWcjs7O2lra+P48ePU1NSkFPrhkoeZrqq5ItIW8zAzAdtzvabyZUtKShg3bhzD
hw8nNze3p90OBAKMGzfOEnsCgQCjR4/u97PS0lIGDx5sST0jRozoEQtEYoRiyyCppph3STA5wNnw
QZNkOKWRGVL5sonmGno/fDMMGjQo4VqVVc1fon1EqcypFBQUWL0nKRVmwweCsbU5ipGKYPoeYtWb
7OxsU/2hGE4tbCbqEyX6nn1xeeBwFnwgmNQSqqRJKl+4tbU14edWNRdOkMhTJfuevXFZMNMAAqqa
j42HWvWmqKjI8Kr0QBJMIltTEYzLk5/jVHVwAKjGoUMqRCRpJswYydKCeXRDWL8kapJSSX/msocJ
AhMDOORdYhj90uFwOOHDzJQA7kGDBiXsbxn1MCLitocBGBMAKp2s0ap+TKY0ScnsNCqYoqIiL3jV
Sl8wNpPsRzYqGA94F4h6GEeTGlolGA/8tRkikbCTNbu98chaXGmAyG43xxgyZIjhjeqJHubgwYMz
YudAIsFkUIc3RrHjggHjXz6RhwkGg5YcY2M3iTrnGTQHE6M4gEW7G1PB6JdvaWlJ+Hkm9GOsmLQL
BoNe2aQ3PAA4/tSt8DCQGYKxYtIuFAo5fVBXPHIDOLBK3RejPf7Ozs6E+7K93vGNJRuKh1HBeKQ5
AhjkmmCMdFhVNaOH1rEYnnhk2JAaICeAzUfW9FtrTo7hLNaZLBirJu085GEkAKR1SIFZrOjHeF0w
yZYvMmwOBqDDF4yNJLKvq6vLUCxMbm4uw4cPt9IsM7QHAFf2rxoVTKK/wtzcXE9nd7Ciw+vCtpJE
tAcAV3K1G+3IJXuwXs76YMWQ2kPNEcCBAGDvIYlxMDq3kOzBejnMwYpZXo8JpjkAWLNfI0UCgQCh
UCjpdZk82zsAPUxTANjnVu1GHkZ3dzcdHfH75V4VTDAYJDs7O+7nRgVjNELRIfYHgB1u1W60H5Os
4+tFrJiDOeWUU7yWgn57AKhzq/aBPLS2QjAemuGNURcAUjo120oGsmCSeT4jk3Ye679A1MO8l/Qy
mxg2bJihUU4mCibZTgEjya49JhgFagIichDY7YYFRredJBJMdna2V5b+T2AAjpB2iMiR2DTpBres
MPJQMjEuxqxgRMTQtIODbIQPNrD91S0rjHTsMlEwZpcFSkpKvDaL/Tf4QDBr3LLCiIeJnQQfD68J
RkRM73b0WHME8BqcKBhXTu808mBUNWGOX68JJlkaESMexmOC6QbWQVQwInIIl0ZL+fn5hvK9JFoi
8JpgktmTbLkDPCeYjSJyGE7chP+iS8aY7vhmmmAycNKu5yia3oJZ4YIhgPmOr9cEk6jDGw6HkwZO
xfIBeogebfQWzGrguPO2GO/4xsNr60nJhtTJDugoLS31UmDYEeD12H96rIqeV/y8GxYZ8TCJ2v1A
IOAp0Zidg/FY/2V575PZ+sr4jw4bA0QEk+wvKtmD9gVjG0t7/6fvr7QccPy84Ozs7KT58zNp8m4A
CeYovTq80EcwItICPOukRTGSPaTOzk66urrifu4VwQQCgYQztBk2QnpaRE7oPPbXDvzKIWNOwMhD
yoTJu2S7HZPN8saOO/QIJ2nhJMGIyKtAjSPm9GKgzMUkC9dI5mHKy8u9sq1kE/0sGcXraTruZQaK
YMzO8nqo//KQiJw0/o8nmF8Ch+2150RKSkoSBk1DZiwPJLKjo6OD7u7uuJ+DZ/ovR4D/298H/QpG
RI7isJcJBAJJg6kStf/J0ps6hdmwBo94mJ+LyJH+Pkg0+fFTHN53nexhJXrgyXKxOIXZnHYe8DBt
wP3xPowrGBHZhcNeJtnDyoS5GDNzMEZjnG3mYRFpiPdhsgWLHwDGM/eZJJmHaWlp8XwglRnBeKA5
agPuSnRBQsGIyB7gQSstSkSyBxYOhz29CzIrKythxz0DRkj3JfIuYOxQiv/Aof3XhYWFSQ+c8vKq
dTLBJuvDuNx/2Q/8V7KLkgomGo33XSssMoKZfozbHsZs4JTLHuaOWFRdIowGXfwC+Ls5e4xhZqTk
docxkWBUNaGHMZrNwibWA78xcqEhwYhIF3AjkWBgWzEjGC97mPb29oQd9pEjRyaduLSJLuCLImLo
tzUc1iUibwL3pWuVUcwIJlmKDbvJ0BHST0RkvdGLU40D/A6wJcV7UiJZTjcvz8WYEYxLHd5NwPdS
uSElwYjIceBqbJwBHjx4MMOGDYv7eaYKxoND6k7g+mgMlGFSjjSOuq/vp3pfKiR6eO3t7QkzH7gl
mGRLEx4cUt8hIm+kelO6oel3YmPAeKKH59VdkDk5OWnvdhw0aFDSEFWLeQm4J50b0xKMiISB64Bt
6dyfDCNLBPFwSzBmjupzOBfvDuBqo6OivqS9+UVEDgBXYcNak5mRkluzvWYCpxzsv7QA/yAiaafa
NbVbKtqf+QwWb+QPhUJpH93rlodJVG93d3fC3Y4O9V/CwHUi8jczhZjeXiciTwO3mS2nN8m2iibq
QLqVUyVRvck6vA55mEUi8ozZQizZjykidwP3WlFWjEQP8dix+FunEm1F6UuyPc5GDo8wUm8ie8ER
wfxYRH5qRUFWbuBdBDxsVWGJHuKBAwfi9gm2bTPeD+/s7OTAgQP9ftbS0sLx48a3mtfX18f1JLt3
x08hWFBQwNChQw3Xkwa/ARZbVZhl2QRFRFX1K0ABcK3Z8hIJJhwOs27dOkpLS+no6KC1tbXnlYqH
AVi/fv1JWztUlX379iXdNN+blpYWXn75ZXJzcxk8eHDPq7W1lYaG+CEmNnuXR4Eb+ov+TxdL00+K
SFhVP0skcusLZspK9iCPHTvGli3mVyna2trYunWr6XLggyMHPXK88CPAP0enQCzD8pwS0fH9jZjs
0xQVFbkeEOUENo2Qfg58LhplYCm2JCERERWRW4Cvk+aQ24NpR23BYg+jwL+LyE1We5YYtmatifbM
FxJpolLGAzGutiIiVnqYdiLzLN+zqsD+sD3NkYg8BVwM7En13oEuGAub3XrgQhF53IrCEuFIXiwR
eR04HViVyn0TJkywxyCPMH78eCuK+R9guoj8rxWFJcOxRGoi0gjMA+7GYL9m1KhRjBo1yla73EJE
mD17tpkiwsAPgYui24EcwdHMeyLSKSKLgUuIuNGk3HDDDa4Hd9vB/PnzzXiYvcClIvJNO0ZCiXAt
EYmqFhEZel+X7NrDhw/z5z//mc2bN9PY2JjShJqXyMvLo6KigosvvpjTTz893WJ+D9wSjRZwHNcz
16jqfOAhYLTbtnic7cCXRMS1BNzgcJPUHyKyAphMZIelY/u4M4gWIoHaU9wWC3jAw/RGVUcT6cgt
xGO2uUAYeAK4PZpJwxN48kdR1clEtudeiUdttJmXgdtE5G23DemLp38MVT2bSHDWJwH300vZSzfw
NLDEi0KJ4WnBxFDV04BbgOsBW4NHXOAwkZHPvSJiS1C9lWSEYGKoaj6RwPMbgHNdNscsrxPJ8PXH
VDeTuUlGCaY30Q7yPwD/BJiaMnWQ94AngcdFZLPbxqRDxgqmN9Ema0H0dSHglanh48BKIucNPS8i
rh0qbxUDQjC9UdVBwFlEmqzzgDOBUx2qfgfwNpEDNdcA63sfHTMQGHCC6Q9VLQSmApOA04BKYAxQ
ChQBRjcztRJJ37aXyMxr7PUuvc5FHMh8KASTDFXNIyKcbCCHD5q0FiKBSZ1AcyZ1Tn18fHx8fHx8
fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8
fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8MhX/gC1AVQuIHLAVJHI6W270
ozYip7B1Ezlg65g7FnqHD4VgVHU4cDqRI/zGEDnCrxIIAcVETmEzQhvQTOQIv7roaxuR02I3iMgB
66z2JgNOMKqaC5xN5JDQ2UQOCa1wqPrdwHoiZ1KvAd4SkXaH6naEASEYVZ3AB8cQz+GDJsVtWoFX
geeJHEO8xWV7TJOxglHVSuAKMvOg8ydEpNZtY9IhowQT7Zx+GrgRmOGyOWZZC/wKWJpJnemMEIyq
jgNuAT4DDHHZHKs5AjwC3Csi77ttTDI8LRhVnQXcSqTpCbhsjt2EgWeAu0TkDbeNiYcnBaOqU4Hv
AFfiURtt5mXgmyLyltuG9MVTP4aqngYsAT6Fx2xzASXSQb5NROpctqUHT/woqjoE+BaRforRSbQP
C23Aj4E7ReS428a4LhhVvRR4EDjVbVs8TgNwk4g866YRrnUkVbVEVf8ALMcXixHKgGdU9VFVLXLL
CFc8jKpeDPyOyEPwSZ19wD+LyHNOV+yoh1HVHFW9F3gRXyxmGAn8RVV/rKqDnKzYMQ+jquXAU8As
p+r8kPAW8CkR2elEZY54GFU9n8gqri8W6zkbWKeq5zlRme2C2blz5z2HDx9+hYgb9bGHEPCKql5n
d0W2Nkk7dux4Yu/evQtFhAkTJnDKKafYWZ1PZLLv+yLyPbsqsEUwqip1dXWr9u3bNyf2XiAQ8EXj
HA8RmbMJW12w5YJR1axt27a92djY+JG+n/micZTHgM+JSJeVhVoqGFUNbtmypebAgQPj410TCASo
qqpi6NChVlbt0z+PA9eLSLdVBVrW6VVV2bp165uJxAIQDofZtGkThw8ftqpqn/hcA/xaVS1zDJYJ
ZseOHauamprOMHJtOBxm8+bNHDlyxKrqfeLzWeAeqwqzRDA7d+58fO/evXOSX/kBMU/ji8YRvq6q
i6woyLRgdu3a9b09e/Zcnc69vmgc5Ueq+o9mCzHVtqnq9O7u7tU1NTW5x4+nH6rhd4QdoxU4T0Te
TreAtAUTXWJ/C6js7u6mpqYGXzQZwU7gLBFpSufmtJokVQ0CS4lsNyUYDFJdXU1+fn46xQF+8+Qg
pwKPqmpav326fZhvAx/r/YYvmoxiHnBbOjem3CSp6tlE9g1n9/d5V1cXtbW1fvPkfbqI9GfWpXJT
SoKJ7jz8GzA2oSW+aDKFLcAZqQSXp9ok/SdJxAKQlZXFxIkT/ebJ+4wH/j2VGwx7GFWdQaQpChq9
x/c0GUGYSNP0v0YuNiQYVc0C/gpMSdUaXzQZwd+As40sUhptkr5CGmIBv3nKED5CJCNGUpJ6GFUd
RqRzZGovjO9pPM8BYHyytGtGPMx3MSkW8D1NBjCcyHblhCT0MKpaBrxPJLOkJfiextO0EfEyu+Nd
kMzDfBcLxQIRT1NVVUVeXl7aZfiexjZygdsTXRDXw6jqaCJ9l35ndM3S2dlJbW0tLS0taZdh1tO0
tLRw+PBhjh07xrFjx2htbaW7u5twONxTfjAYZPDgwRQUFFBQUEBhYSGDB1v6N+Q12oFx8bxMIsH8
BPi6XVaBc6I5fvw4O3fuZNeuXezatYv9+/fT2NiYdrOYn59PSUkJI0eOpKKiglGjRjF69GhTXtNj
/EhEbu3vg34Fo6pDiSyD2x7eb4do2tvb2bZtGzU1NdTW1rJz505U1SqT+0VECIVCjBs3jurqaqqr
qzNZQEeAU0XkpMDreIL5BnC33VbFsEI0IsKRI0dYv349dXV1Pc2KWwQCAcaMGcPUqVOZMWMGRUWu
ZehIl0Ui8pO+b54kmGiEeS0wwQmrYlghmq6uLl566SX27NljoWXWUFpayjnnnMOsWbMyZV/WJqBa
RE5wzf0J5kJgpVNW9cYq0bz44ovs3bvXQsusIxAIUF1dzQUXXMDUqVMRcT0JWCI+KiKv9X6jP8E8
RmQ/iytYIZrOzk5eeumlpKIpLi6mqqqKyspKRowYwYgRI8jNze3pe7S0tNDW1sb+/fvZv38/dXV1
bNq0iaamtKIb+63//PPP56Mf/ahX+zu/E5HP9X7jBMGoah6wH0h/OtYC7BRNcXExs2bNYubMmYwY
MSKtsvfv38+6detYu3atJeLJzc3l3HPPZe7cuQwbNsx0eRZyFBgpIq2xN/oKZiHwhNNW9cfBgwd5
7733yMrKSruM3qKpqKjgkksuYcaMGQQC1uzfU1U2btzI8uXLqaurM11eVlYW55xzDpdddhmFhYXm
DbSGT4nIn2L/6SuYpwHTe1fMcOzYMV588UVWrlxJMBhkwYIFpv7qurq6UFVmz55tW39BVVm3bh1P
PfUUR48eNV1eTDiXX365F5Y/lorIp2P/6XmC0XOGmnCpOYp5gxUrVtDe/sERQ7m5uaZF49Ta0/Hj
x3nkkUf461//akl5OTk5LFiwgEsuucSUpzXJUaBYRDrgRMHMBV5ww6INGzawdOnSuP2BTBKNqrJy
5Uqeeuopy+aCSkpK+OQnP8lZZ51lSXlpcJGIrIITBXMPkUzcjrF3716WLl3Ke++9l/TaTBINRP4I
fvnLX9LR0WFZmVOmTOGqq65i5EjHs7/dJSK3wYmCeQeY7ETt4XCYl156iT//+c90dRnPd5Npotm8
eTP33XcfnZ2dlpUZDAa5+OKLueKKKwgGDYdXm+XvIvIRiAomGlXXhANJEhsaGvjtb3/Ljh070ro/
00SzYcMGHnzwQcuXKioqKvjsZz/Lqac6kkQ9DAwXkcMxwXwc+IutNYbDPPfcczz33HN0d5tLiGSl
aIYMGUJdXR21tbXs3r2bpqamnvmfvLw8iouLqaioYOLEiVRWVqY10lqxYgXPPPNM2rbGIysriwUL
FnDppZdaNlWQgAUisiImmP/EQHheujQ3N/PrX/+arVu3WlamFaJRVdasWcOmTZsMXV9cXMycOXOY
M2cOOTnGD11RVe6//37efffddE1NSGVlJV/4whfSnog0yH+IyP+JCeZ5YL4dtaxfv55HH33U1Kxt
PHJzc7n00ktNTXIZXUbozZAhQ7jyyiuZNct4nupDhw7x3e9+l7a2tnTMTEpubi7XXHMNM2fOtKV8
YLmIXBYTTD0W5/5vb2/n8ccfZ+3atVYWexILFy6kuLiY1tbW5BfHIR3RAJx99tlcf/31hr3Nyy+/
zJNPPpmOiYY599xzufrqqxk0yPIjCHaKyOhA9NR4S8Wyf/9+lixZYrtYioqKmDNnDtXV1abCJrOz
s7nkkksIhUIp3ffWW29xzz33GI7cu/DCC22Pi1mzZg1LliyhsbHR6qJHqWphAJhkZakbN27kzjvv
pL6+3spi+2XevHkEg0Gys7NdE01dXR0/+9nPDM23BINB5s6dm66Jhtm9ezc/+MEPLJtxjiLAxAAw
xqoSn3vuOR544AFb+it9ycvL49xzz+35v5ui2bZtG4899piha2fPnu1IKENbWxsPP/wwzz//vJXF
VgaIZpEyQzgc5rHHHmPZsmW2x87GOPvss8mM7bu8AAANfElEQVTOPnFDg5WiSXXEsXbtWkN/0dnZ
2Zx55pnpmpcSqsqzzz7L7373O9NTGVHGBIDRZkpob2/ngQceYPXq1VYYZJgZM2b0+75Vopk3b17K
onnyyScNzVxPnz49XdPSYs2aNdx///2mBgZRKgOYOJbm0KFD/OhHP+Kdd94xa0hK5OTkMGZM/JY0
Jhoz3i4d0TQ3N7NuXfKETuPGjbNjFJOQmpoa7rrrLg4cSLh1OhkjA0BxOnc2NDSwZMkSdu3aZcaA
tBg3blzS5f7s7Gxef/11Dh48mHY96YjmtddeS3pNVlYWY8cmzctkORb8ZsVpCeb9999nyZIlZtWa
NqNGjUp6TXNzM5s3b2bFihWOimb79u2G6jPyHezg0KFD3H333enOuhcHSHGz2pYtW7j//vttm7E0
gpHl/c2bNwPQ2trKihUrOHToUNr1ZWdnM3fuXEOiUVVDSw2pjsSspK2tjXvvvZfa2tpUby0MkMJJ
9O+++y4//elPXRULRNZ0ktF7Hqi1tZXnn3/elGgGDRpkWDRG5qCMfAc76ejo4IEHHjAUi9SLnABg
qPf1zjvv8OCDD1oa25EuRkZAfaP3rBRNSUlJSnX3hxc29Hd0dPDzn/88lUVRY4LZsmULDz30kCfE
Ahhau+nPC1olmnnz5iUUjZHha25ubto2WElnZycPPvggW7ZsMXL5oACRgyUTUlxc7IXo9R6MDJfj
xYc4IRojkXBu7/3uTX5+vtEwEQ0ASRdBhg0bxte+9jXP7JUx0odK5PLtFo2R5sbtfmCMYcOGsWjR
IqN9qnZDgoHIyOTWW291vbMGGFqrStbPsFM0yeoGY9/BboYPH86iRYtSCSpvDxA5Q8cQRUVFfOMb
3zD0QOxk//79Sa8xEutql2hGj06+2mLkO9hJ7LdMcfmjLUAk3aZhhg8fzje+8Q1X5xH27duX9Jqq
qipDca5WiyYYDDJhQvJMKW5mlwiFQixevDid1qI5ADSnetewYcO47bbbDD0YO9i+fXvSa/Lz85k0
yVioj5WimTFjhqHwBSPfwQ7Gjh3L4sWL042Fbg4Q2V6SMnl5eXzta1+zM4Y0Ljt27DDUabzgggsM
l2mVaKqrqzl27FjSunbu3Jl2Pely1llnccstt1BQUJBuEU0BIO10TVlZWXz+85/nsssuS7eItOju
7jY0rT1lyhQqKysNl2uFaABqa2sTiqampsbxYfVFF13EjTfeeFIMUYrsDQDp7SiLIiJ84hOf4Prr
r3dyJ56hMAIR4Zprrklpz44VookJOp5ojNhuFYFAgGuvvZaFCxdakb1iewCoM29WJPTwpptuciyT
0oYNG5K6foiMWC6//PKUyrZTNEePHnUsfigvL4+bb76Z888/36oitweAbVaVNnnyZL7zne8YGlaa
pauri5UrjaXimz9/PrNnz06pfLtEs3LlypT2k6dLRUUFd9xxh+GOv0G2B4D3iOydtYThw4ezePHi
EwK07WLVqlWG1m1EhOuuuy5lm6wWTUtLC6tWrUq7LKPMnDmT2267zepJ1i6gNraRbTOR49ws5dVX
X+XJJ5+0ddHyYx/7GFdddZWha1WVl156iWeffTaloOjBgwezYMECU0sjwWCQXbt2sWLFirTLSEZ2
djZXXXWVlU1Qb2pEZFKsN7jBjhrmzJnDHXfcQUVFhR3FAxEvYzTkUESYO3cu3/rWt1KaQ2ptbeWF
F14wdRhGd3c3xcXFti2tlJaWcvvtt9slFoCN8EG6j9uBO+2qqbOzkz/96U+sWrXKlm0oZWVlfPOb
30w5sHrz5s28+uqr/P3vf0/qBbOzs5k+fTqTJ082tWWjvb2dF1980dKdibNmzeLaa6+1O7D8VhH5
UUww5wOv2lkbRIKwHn30UVMxtvE455xz+NznPpfWvZ2dnWzdupVdu3b1m+5j1KhRjB07luzsbDo6
OqipqTG12myVaIYNG8Z1113HlClpna6YKrNFZE1MMIOBQxiMvjNDW1sby5Yts8XbXH755Xz84x+3
tMz+cFs0IsLMmTNZuHChU9MY7cApItLeO2XZ64D9Q5sotbW1PPLII5Zl1Y5x9dVXp7QkkC5uiaak
pITPfOYzVFVVpV1vGqwWkTlwYo677wLfc9KKzs5OVq5cyfLly09ItWqWefPm8Y//aH+6YSdFE9vu
Mn/+fLPT++lwh4j8F5womBmAc3PWvTh48CDPPvuspelBZs2axTXXXJNSpqh0cEI006ZN49Of/rSb
R+icKSJ/hRMFEwD2Aq5FR9XU1PDUU0+xe3fcMypTIhQK8fnPfz6lBch0sEs0o0aN4sorr2TixIlW
mJkue4Dy2DE4fVPHPwz8ixtW9bKBjRs3smzZMkuEIyKcf/75XHHFFaaOQE7EsWPHWL58OUVFRQwZ
MiTtcmKiycrKYv78+cycOdMLx+M8ICL/GvtPX8FcDLzkuEn9oKq8/fbbLFu2zFCEXTJycnKYM2cO
F198sWUHXB06dIiXX36Z1atX097eTn5+Ppdeeqkp0agqkydPNlWGxcwRkZ7UHH0FEwTqMZHRwWrC
4TBvvvkmK1eutOTEkEAgwKRJk5gxYwaTJk1K+Yc5evQo7777Lm+88Ua/cS1WiCYYDFJdXW2bR0yB
PcAoEemZqezvgK17ga85aZVRduzYwcqVK3nzzTctSZAjIpSVlVFZWcnIkSMpLi4mLy+vZ5tIa2sr
LS0tNDU1sXfvXurq6tizZ0/S+aMBJJqTTpftTzDVRFawPcvBgwdZvXo1b7zxhuXzOFYxQEQzSURq
er8R71TZNcA5jphkkoaGBtauXcvatWs5fPikU3NdJcNF8z8ictJKZjzBXAs8artJFhIOh9m8eTMb
NmygtraWhoYGx/Lt9UVEKC8vp6qqiqlTp9LR0WFqyO2SaK4RkT/0fTOeYLKB9wFHTj6wg6NHj7Jp
06aelxUjrUSMHDmSqqoqJk6cyIQJE07wKlbM02RlZTFx4kSnRLMLGCsiJy3hxx3kq+pi4C47rXKS
1tZWdu/eze7du9m3bx+NjY00NjZy6NAhw8sSOTk5FBYWUlJSQklJCaFQiPLycioqKpLup84w0dwi
Ivf290EiwZwCbAc8dcypHXR2dnLs2DHa29tPEk9OTg45OTkUFBSYXsPp6OjgvffeM7Vu5oBomoDT
RKTfwysTTiOq6h3AD+yw6sNKBojmNhGJ27IkE0wBsBWw9VyVDxseFk0jEe8Sd/9Owh1e0Rt/aKVF
PpEttZMmTTK1kt7V1UVtba3hgzEM8h+JxAJJPAz0jJg2Ao5G7HwY8JinqQFO729k1Juke0ijBfyb
WWt8TsZjnmZRMrGAwUNBReQvwHKzFvmcjEdE86yIGNowZTjYQlVPBd4BPLPuPpCwonnKzs5m4sSJ
qQaGHwEmi4ih4CPDaQ1EZCfw7VQs8TGOFZ6ms7OT2traVPPn3W5ULJCCh4GeMM5XgAtSuc/HOA57
mleAuSJieG99yvF/qlpOZGvt8FTv9TGGQ6I5CHwk2nIYJuXTsUWkHvhSqvf5GMeh5ukLqYoF0hAM
gIg8CfwsnXt9jGGzaO4RkWfSKTPtkPTohN4rwEfTLcMnOTY0T2uAC4zMufSHqT0MqloGvAGUmynH
JzFWiaaqqmpvfn7+GSKSdpLgtJqkGCLSAMwHvBUbOcCIpXM10zypqh44cODLZsQCJgUDICLvAFcT
SWnlYxM5OTlpiyYYDFJWVrbo1FNPfdasHaYFAyAizwNfwMJceT4nk45oRITS0tKflJWV9RtBlyqW
CAZARH4P3GxVeT79k6poQqHQryoqKhZZVb9lggEQkZ8Di60s0+dkcnJymDhxYsIUZSLCyJEj/zh6
9Ogbrazblp3eqvol4AEsFqTPibS3t1NTU3PS6ElECIVCvxs9evTnrK7Tlh9URB4CbgDM72f1iUt/
zVMgEKCsrOxuO8QCNnmYGKo6F3gS8M6BkQOQmKfp7u7WUCi0uKKi4sd21WV78hFVnUok+Mqdo+A/
JLS2tu5vbm7+8qhRo/5kZz2OZKuJzgg/iYNJFz9kvA78k4ikfZSRURzplEZnhOcAS5yo70PGL4CL
nBALOORheqOqC4GHAG+caZy5HAC+KCJPOVmpKwnUVHUU8AgRr+OTOquA61MJrbQKV+ZJRGQXcBHw
RaDfPbw+/dIC3A5c4oZYwCUP0xtVrQQeJLLq7ROfvwA3pRMlZyWuz8SKSJ2ILAAuweOp0lxiC3CV
iHzCbbGABzxMb1R1EPBVIm7XtbTXHqEJ+C8ieXI73DYmhqcEEyOaNeIm4DY+BPlp+nAU+Dlwp4h4
LjDNk4KJoaqFRDrGXwXKXDbHbuqB+4CHvSiUGJ4WTIxoU3U18GVgpsvmWM1aIp3+J7zU9MQjIwTT
m+ja1A1EBOTaQRom2Q/8AfhVNMQ1Y8g4wcRQ1SzgQmAhcAVgz+mb1tEILAOWAqt6p2PPJDJWML2J
7vmeDiwA5gJnA46fQtWHTuBN4EXgeeCtVPYwe5UBIZi+qGoeEQGdB5wJTANOw755pzCwDfg78Dbw
GvCmiCQ/hT3DGJCC6Q9VzQeqgTHRVyVQSmS+p4hIk5YdfRVEbztGxFN0EpkXaY6+9hBJSVtHRCg1
IpJSjo1M5f8DJH/nomvuU2YAAAAASUVORK5CYII='

	data = '
iVBORw0KGgoAAAANSUhEUgAAAEYAAAClCAYAAADh/ouoAAAACXBIWXMAAAhvAAAIbwHMXsOcAAAA
GXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAFqZJREFUeJztnXtwVFWexz/npmO6
O+QNIUmTBMIjIQgoOiylgoALyKKoODuOi+vOzK7U4kwtzrizzh9btfzhVLHlrituObUzU6OrzjCO
O8r6BnXAYbTKB2QQ0BBe2QTyICQmEJLOs3/7x+1u+3H79r23OwlO5VtFhXvvub9z7rfP83d+5/dT
jBNERAFXA9cD84BqYA4wBcgP/gW4DPQE/54CGoATwEHgmFJKxqO8aiyFi0g+cDewDlgJTEtRZAfw
HrAXeEkpdTFFeeMHEVEisl5EfiMifhk7+EXkhWBeaf+B0yZQRDRgA/AvwHVOZIyMjNDW1kZrayst
LS309vaSk5PD8uXLmTbNtLIdAx4DdimlRpzkHYu0ECMitwI70fuOpAgEAly4cIGWlhZaW1vDRHR0
dBAIBOLSu91ufvCDH1BZWZlM9HHgIaXUXrvfEIuUiBGRMmAH8NeJ0nR3d9PS0hJFQltbG8PDw7by
qqmp4fvf/77V5K8D31VKNdvKJAIupy+KyJ3A00CB0fPz58/z7LPPcvr0aadZRKGhoYGhoSGuuuoq
K8lvA1aIyBal1G+c5KfZfUFEskRkJ7CbBKQMDw/z+OOPOyLF6/Uye/ZsVqxYgdfrjcyXtrY2O6Jy
gRdE5KcikmW3HLZqTHD4fRVYbpbu6NGj9PT0mMrKzMyktLSUsrIyfD4fPp+PsrIyCgq+5Lqjo4Pj
x4+Hr1taWqz0M7HYAlSLyB12hnfLxIhICfAWcE2ytH6/P+ra7XazYMGC8Mf7fD6mTp2KpplX2NLS
0ihiWltbE6bt7e2lvb0dEWH27NlkZGREPr4ZeF9EblVKtSQrP1gkRkRKgT8As62kLywsjLrOy8tj
y5YtVl6NQllZWdR1a2srfr8/aiRra2sLD+0hlJaW8vDDD5OTkxP5+tXAeyKyXCnVnizvpMSISC7w
BhZJgfgPunDhAsPDw2RmZloVYZi+vr6ehx56KOm7bW1t7Nu3jzvuuCP20RzgbRG5WSnVbSbDlJhg
p/UacG3S0kQgLy+P7Oxs+vr6AH3e0t7eTnl5eVzaQCBAR0dHuAaE/l64cCFuTmM0x0mEhoaGRI8W
Ai+LyDql1FCiRMlqzL8DKyyXJgI+n48TJ06Er1taWvB6vVHNIDSnGRlJy2Q1Co2NjWaPVwL/CiSc
GCUkRkRuBx50Uqje3l48Hk/Uveeff35MCEiEQCBAT08P+fn5iZJsE5EDSqndRg8NiRGRGcBzJJkZ
G3WE586d4/Lly3Fpx4uUzMxMiouLWbJkSezIFAsF/EJEPlJKxQ13iWrMf6DrSAzx4Ycf8uabb3L+
/HlbhU4nNE3D6/VSVFREeXk5c+bM4ZprromrqUlQgN5d3Bv7IK5GiMga4O1Ekk6fPs1jjz2GyLjo
i1BK4Xa7KSwspKysjJqaGhYuXEheXl46s1mvlNoTeSOqxohIBvCkmYSGhoYxI8XtdpOXl0dpaSkz
Z87k2muvpaSkZEzyisG/icjbSqnwsBfblL4O1JhJiFy/OIFSCpfLRW5uLsXFxcyZM4f58+dTVVWF
UmOqUDTDAmAT8NvQjTAxQS3YPyWTYIeYzMxMcnJymD59OhUVFcyfP5/q6uqkS4EJwj+LyEshnXJk
jVkHLEn2dm1tbdw9TdPIzs6msLCQWbNmMWfOHK6++mq7HeFEYzEQ7l8jifmWlbenTJnCsmXL0DQN
t9tNWVmZYS36/PPP01BW55gxYwbTp0+3+9r9RBITXA/dbvXtQ4cO2ZqejzdEhEWLFrF161a7r24S
kTyl1MVQjbkbsNx5FBUV0d6edIE6YXC5XJSWljp51QPcATwX6gXX2Xm7srJyIkcQS/D5fE5fXQvg
Co5GK+1m6nK54hTaXq+X4uJiPB4PPT09llSRs2bNCutNGhsbo/QqiTBvnr4Z4ff7DRehIyMjcaoP
G1gtIsqFPobb6qV8Ph+jo6Nx92tqasK/VKjQZtA0jdra2vDwPTo6ymeffWb6Tk5ODtXV1eFrEeHc
uXNxch10vCGUAjUaDjbHfD6fYecb2bw8Hg8ul7lWIyMjI2pOkyw9EKuVM0RRUZElWSa4TkPfXLeF
goIC3G533P3+/v6oa6M0qSJ2bhSrX1ZKUVFRkWo21Y6IAQyramwhU10+GCGW7Ng8XS6XoabQJqo1
bOhyIzFz5sw4fcfAwEDU9VjMfCNlikhcnqOjo6mMSCHM0TDRu5jB5/PFrXmMtk3SjUhiBgcHDfXC
aSAmX+NLgx1bKCsrixsmY4kZixoT2TxjawvoC9fY7RsHyNGA5N28AYx+laGhoahhPN3EZGRkRG2p
xP4QACUlJemYfOY4Xv97vV6mTImvbJEjU7qJcbvdUR9tNCI52MI1gtKAPqdvz5gxI+5eZPX2eDxp
XTokG6pdLpdhmRygVwOSz8EToKKiIm5kiiyspmlWzTYsIRkxo6OjqSwFItGrAY4N/MrKypKOTOls
TsmICQQC6SLmogaYbtmZwefzxS0kJ5IYr9draclgAWc0dDtaRygtLY3rQ8aLmEAgwNBQ9NZzGuYv
ITSkRIzL5YqbM4wlMZETRr/fH7WN43K50jUiQZCYulQkxC7YBgYGogqcTmIiJ3dGQ3Uaa8wfNeBT
oMuphPLy8qhJ1+joaFS/ky5irrrqqqgRMJaYkZGRdBHTBRzVgrtvB5xKKSsri1uvRE7y0rVeStbx
AunatdynlAqExtp3nEox0uZFFjorKystG2yxxMSuk/Lz88nKsm2caYR34Utz1heBhNZFZpg2bVqc
SVgkMUqptDSnZDUmDToY0Dl4CYLEKKW60C0ybUMpRXFxcdS92F8zHc0pVkZkc3W5XOnQ2gG8HuQi
ygD6WafSYrdTxmLIjtUGxpKfphnvc6H/RBLzKvqBKdsIbaeEMBbERMoYHh6O0gWlaUQ6hX4GAYgg
Rik1im6wZxs+ny+qoGNNTKx8TdPimrMDPBrkQJcZ8/B5oMmuRJ/PFzWpGxgYiBrCUyVGKRU14sQS
U1xcnOrIdwbYFXkjSppSahj4R7tSc3NzTYfTVIkxU1ClSTn1cPDbw4ijWSn1W+BNu5JjO7/IwqeD
mESy06Cc2quU+t/Ym4nq3zagP8EzQ1RWViacsrtcLlvm8rEwm8OkuCvQB3zX6IEhMUqpU8A/2Mkh
VmmVzg7YbKhOUWv3PaWU4aGqhD2WUuoX6J2xJcQqrdJJjFmNycrKMrP+NsOvlVL/nehhsq78QeCw
lVx8Pt+YTfIi+5jY3UcjZZkF1AEPmCUwJUYpdRndkCbpxC8rK4vc3NzwdewGv9FwavV0SWTfFTkV
0DSNmTNnJitaLM4AG5RSprsjSW0llFIXRGQD8D5J7GjKy8u5eFHXrV++fJmzZ8/icrnCZw5iMTo6
SmNjY3h/KtEJtlOnTtHX14fH44ky08/IyLDbv7QDa9NykAv0zlhEbkB3HTAnUbry8nKOHz8engUf
Ppy8FR47dixpms7OTjo7O+Pu21wKNAK3JupsY2F5uqiUOoN+SDTh16ZRtWgJImK1xhwDliulLK8F
bc2jg1XwZuB/jJ5XVFSM65mkvLw8KzY4LwA3WD0kGoJteyyl1CXgGyJyP/Bf6CaggG5MNG/ePM6c
OTPmZvEjIyOsXbvWLMkg8IhSaqcT+am6MLgaeIqI44EjIyMcPHiQ9vb2MTOSzszMZO7cudTUJDwP
8nvgQaXUxJmni+4W5X4RaU+nDxSHaBOR+2QM3KY4huiuDbaIyNkJIKRdRB4RkfQb/aULQYK+LSK/
F5HAGJIREJH3gnmlZXsgEmPtimkm8FfoJvnLgFRtQgaBD9HnU7uUUraValYxbm0xWM1vQj8TVY1+
kq4K3TgylrAhdAdeZ4B69CXJIeADpZQtdYhTXBGdlIhcRYRXM7MT9JOYxCQmMYlJTGISk5jEJCYx
iUlMYhKTmMQkJjGJSUxiEpOYEFwp+0pZQHbwsk8pNTiR5YHx3YnMRrfIityJnIXuOjbWTmcE6EY3
DzuOftL3EPB+MqPCdGGs966rgM3olp9/Bjg3D9cxDHyEvnf9K6WU48P0446gtcN3ROQP42DtcCCY
V9qtHdIGEckWkW0yMfYx50Vku+iuMa8MiG5R9e1g4SYa7SLyNzLRFlUiskhE3p9QKoxxQHT7wAkh
ZYuIDEwwAWYYEJFt40lInoi8NMEfbQcvioO+x1ZbPHv27KL+/v79VVVVhSm6bBxvfIZuLn8uacog
LFspNzc3r+js7DzY3d1dGHle4CuCBcAfRMRSjDmwWGPOnTu3qqOj492hoaEwkdnZ2cyfPz9ZtIgr
DeeBm4In+EyRlJizZ88u7OzsPDQ4OBg3a83OzqampiZVT6jjjTPAjcmO5pg2JRHJGRkZedeIFIC+
vj6OHz9u6Nv3CkYV8KaImHqMTNbH/KSysrK4qKgoYYK+vj7q6+u/an3OtcDPzRIkJEZEHgDuU0ox
e/ZskpHzFeyQvyki30n00LCPCfbeh4k4ciMinD59mq6uxF6bvoJ9Tj+w2KgzTlRjniCCFNBdBfwJ
1hwv+rGiOMQRIyLfANYbJf4TJWetiGyKvRnVlEQ3XT8JmLrv+RNsVv8HzIt0fBFLzN+RpLeOSJsy
OYFAgP7+fgYGBsLntL1eL263G6/XO95Rdb4deXI/TIzoQafqgblWJYkIJ0+epLs7ccjFEDmaptHU
1ERDQwPNzc20tbXR0dGRsMm5XC6mT59OSUkJlZWVVFdXU1FRMZZknQJqQs51IonZRNCjlx1YIcfv
9/PGG29w6dIlB+X9Eh6Ph4ULF/K1r32N2trasWimd4VcpkQS8wqw0Yk0K+R0dXWxZ88eBge/3BnR
NI2qqiqKiorCMdkuXrxIZ2cnjY2NpodNs7OzufHGG1m5cqXpYGATu5VSmyBIjIgUAa2kcAJNRDhy
5Iihg/MQurq6eOutt5g+fTpr1qxh4cKFCc9N9/X1cfToUd555524EB6R0DSNJUuWsGHDhnR4NhsC
fEqpzhAxW4GfOJXW1dXF7t27qaurY+XKlUldIy1ZssSyox0R4aOPPuLFF18Mh3A1glKKpUuXcued
d6bqZf7vlVI/DRGzG7jTroRAIMD+/ft55ZVXwk1E0zRWrVplSo6Tobyzs5OnnnrKNLQz6M5K165d
y/r16532Qb9VSv2lEhEN6ABsNdTm5mZ++ctf0tQUf15zrMjp7+9nx44dlgJ3zpgxg82bN1NVVWVZ
fhBdQLESkSXo25+WMDIywssvv8y+fftM40VaIScrK4tz587x+eef88UXXwB6rOza2lpuuOEGwyZx
/vx5duzYEeefxghKKVavXs2mTZvs1p5rM7Zv3/4XWByNurq6eOqpp6irS+4bWURoampi0aJFCT0C
jY6O4vf7qauro6+vj4GBAbq7uzlx4gQHDhxARJg7d27U+1OmTMHj8XD06FFLX9jY2MixY8eoqakh
Ozs7+Qs6PrIcLefw4cM8+uijnDlzxqpwiouLWbp0KQUFBQnTTJ06lVtvvTXOTf/w8DCvvvoqzzzz
TFzNXL58ua3AUs3Nzfz4xz/m4MGDVl+pzti+ffv3MCFHRNi9ezcvvPBCnEf5ZNi4cSOzZs2isLAw
PPU3gtfrpaSkxHDu0tLSQlZWFrNnfxnURymFUsqSU54QRkZGqKurY3R0lOrq6mR+rS5o6KYYCYU9
/fTT7N2713IBQlBKsXjx4vD/586daxgSJITi4mLWrVtnOIy//vrrcbPmxYsXO4qS8dZbb/Gzn/0s
2Y9cpQGGYYD9fj9PPPEEH3/8se3MQfeLF+mGTSlFa2srzc3NCd9JRM7g4GBcOQoKCpyGPKSuro6d
O3eaTUbzDKPl+P1+nnzySU6ePOkoY8BwRKmvr2f//v2OyKmvr7eUh1WcPHmSxx9/PNHolqPxpYkX
oLtT27lzp61O1ghG8ai7u7sZHR11RE5oOI+EQ8eAYTQ1NfHkk08a1Zz4MEKhkMupwmiOExn20C45
VvzoOYHX6zXaNJS4aDkul4stW7aEO06nCPnDi0Rk1bdLjtEK2igPO1iwYAFbt2416vB7NeBy7N0Q
OUuWJI3ynBAXLlwwLEgk7JAT+26iPKziuuuu48EHH0y0mL2koftpiUOInNtuu81RxufPn6ejoyPq
3tKlS+Nmn1bJKSwsjNrx7OjoiJNvFatXr+aBBx4wWyZc1ICEngSVUtx+++3ce++9jlSKn376adS1
1+vlrrvuiktnhZz+/n4aGhrC5FjxyhiLjIwMNm/ezD333JNsDnTKUrSclStX8sgjj9jWlP3ud7+L
m0gtX77c0H+dFXJ6e3tpaGhgYGCAffv22SpLQUEBDz/8MCtWrEieGBoytm/fPgMLupj8/HyWLVtG
S0uL5So8MDCAx+OJms6DHn6+qKiI06dPR8VICi08CwsLDYd70CMLtrS0UFdXZ3lUqqmpYdu2bXYm
hD9XIrIA3RelJYgIb7/9Nq+99pqltVNmZiY//OEPDdUPfr+fQ4cOUV9fH6V2mD9/PlOnTjUddTo6
Oti7d69pGTIzM9m4cSNr1qyxu3yYr0Q3/WwFbIWa6ezsZNeuXUnDMINe2370ox+ZrrJjYUXBbkZO
dXU1mzdvdhLeuU0pVRZSbb4A3GNXAsCRI0fYtWuX6QeATs7WrVttOSZ2Qk5ubi533303y5Yts5xP
DH6llLovRMy3gGecSurv72fPnj289957UdsjscjMzGTDhg3ccsstlsMkDg4O8sknn5gqzzs6Oti/
fz/Lly9n/fr1qQahuV8p9XyImFygDX333zEuXbrE3r17ef/99023UfLz81m1ahXXXHNNwmBRbW1t
fPrpp+zfv5/e3l5Wr15tGirI6/VSW1ubqk1gP1CilOqN3HD7NfDNVKSGMDAwwAcffMCBAwdobzf3
Ql1UVERRUVG4/+nu7qarqytuTzwjIyMpOaGw8imQ8yul1H0QvRO5DtjjVGIinD17lo8//pgjR44k
JSkZfD4fN998s2lTSZGctUqpdyDe2uEQ+kGrMUFPT0/Upn57ezsXL16M29h3uVzk5eVRUlJCaWkp
FRUV1NTUkJeXZ6lDdkjOYWCJUkognphvAL+xIy0dGB4eDvdJbrc76S7lGJFzt1Lq5dBFLDEacBSo
tSptopBmco6h2+KFp9KxYYQC6AFhrniEFOxmWrzQ2sqCHfK2SFLAOIzQu0xAc3ICpRTz5s1LlZxd
Sqm4FWkic9Yy9OplfQ4/gRARTpw4QU+PoWoJSNisvgCuVkq1xaZPFEaoFbgfSLw5fQXBYc0R4G+N
SAHzMEKvA/+ZQnnHFQ7IedwoEldYnllmQfPWvcBKZ8UdfwQCAU6cOGGqspg2bVpTVVXV3Ni4bZFI
FkZoCLiDFEM/jyc0TTOtOR6Px5+VlXWTGSlg4YRbMKTHBnRzz68ENE1j7ty5cVpAt9s9lJ+ff/2M
GTOSHgG0pOEOHnq6Cfijo5JOAGJrjsfj8RcVFV1fWVlpKeyHLX1f8PDTy8Aa2yWdIAQCAZqampoy
MzNvLC8vtxUxxxZExCUiO2Rs/TakCwER2Sn6IDI+EJGNItI1sd9tih4R+fq4ERJDTqmIPDfBBBjh
NRFJS2TwVAn6cxH5fILJEBE5JiK3TDQfURARTURuF5FPJoCQI6LHeLpyD4GL7jZlnYj8WkT6x5CM
fhHZFcwr7W5RxtoVUy6wCT2M0CqSxJm0gHZgP/oyZXdw8jkmGE/nXQpdM3g9uvnsPGA2kIseSigc
LQfdNOUi+qn6huC/Q0qp5NueacL/A/Ao3MoZ5Z/QAAAAAElFTkSuQmCC'

  if (2 == scale) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Copyright 2022 John Maloney, Bernat Romagosa, and Jens MÃ¶nig

// MicroBlocksExchange.gp - A textual representation for exchanging scripts between projects.
// John Maloney, February, 2022

defineClass MicroBlocksExchange mbProject functionsUsed libsUsed

to newMicroBlocksExchange aProject {
	return (new 'MicroBlocksExchange')
}

// Script export

method exportScripts MicroBlocksExchange aMicroBlocksScripter blockList {
	// Return a string representation for the given scripts (a list of Block morphs).

	mbProject = (project aMicroBlocksScripter)
	result = (list)

	analyzeCalls this blockList
	add result (libraryDepencies this)
	add result (newline)
	addAll result (functionDefinitions this)

	scale = (blockScale)
	for m blockList {
		if (isClass (handler m) 'Block') {
			expr = (expression (handler m))
			if ('to' == (primName expr)) {
				// save block definition in scripting area as 'to' command with a nil body
				// all function definitions are saved separately as a top-level 'to' commands
				callArgs = (join (list 'to') (argList expr))
				atPut callArgs (count callArgs) nil // replace the body with nil
				expr = (callWith 'newCommand' (toArray callArgs))
			}
			x = (round ((left m) / scale))
			y = (round ((top m)/ scale))
			add result (scriptText this expr x y)
		}
	}
	return (joinStrings result)
}

method libraryDepencies MicroBlocksExchange {
	// Return a string listing the library dependencies, if any.

	if (isEmpty libsUsed) { return '' }
	result = (list 'depends')
	for lib libsUsed {
		add result (join ' ''' lib '''')
	}
	add result (newline)
	return (joinStrings result)
}

method functionDefinitions MicroBlocksExchange {
	// Return a list containing the specs and definitions of functions used, if any'

	result = (list)
	for funcName functionsUsed {
		spec = (at (blockSpecs mbProject) funcName)
		if (notNil spec) {
			add result (join (specDefinitionString spec) (newline))
		}
		func = (functionNamed mbProject funcName)
		add result (prettyPrintFunction (new 'PrettyPrinter') func)
		add result (newline)
	}
	return result
}

method scriptText MicroBlocksExchange cmdOrReporter x y useSemicolons {
	if (isNil x) { x = 10 }
	if (isNil y) { y = 10 }
	if (isNil useSemicolons) { useSemicolons = false }

	pp = (new 'PrettyPrinter')
	if useSemicolons { useSemicolons pp }
	result = (list)
	add result (join 'script ' x ' ' y ' ')
	if (isClass cmdOrReporter 'Reporter') {
		if ('v' == (primName cmdOrReporter)) {
			varName = (first (argList cmdOrReporter))
			if (varMustBeQuoted varName) {
				varName = (printString varName) // enclose varName in quotes
			}
			add result (join '(v ' varName ')')
		} else {
			add result (join '(' (prettyPrint pp cmdOrReporter) ')')
		}
		if (not useSemicolons) { add result (newline) }
	} else {
		add result '{'
		if (not useSemicolons) { add result (newline) }
		add result (prettyPrintList pp cmdOrReporter)
		add result '}'
		if (not useSemicolons) { add result (newline) }
	}
	if (not useSemicolons) { add result (newline) }
	return (joinStrings result)
}

// Script analysis to collect function calls and library references

method analyzeCalls MicroBlocksExchange blockList {
	// Collect all the user-defined functions (i.e. blocks defined in the main project)
	// and libraries used by the given list of blocks.

	functionsUsed = (dictionary)
	libsUsed = (dictionary)
	for m blockList {
		if (isClass (handler m) 'Block') {
			analyzeCallsInExpression this (expression (handler m))
		}
	}
	functionsUsed = (sorted (keys functionsUsed))
	libsUsed = (sorted (keys libsUsed))
}

method analyzeCallsInExpression MicroBlocksExchange cmdOrReporter {
	// Collect all function calls and library references by the given command or reporter.

	main = (main mbProject)
	todo = (list cmdOrReporter)
	while (notEmpty todo) {
		cmd = (removeFirst todo)
		for cmdOrReporter (allBlocks cmd) {
			op = (primName cmdOrReporter)
			if (isFunctionCall this op) {
				if (libraryDefines this main op) {
					if (not (contains functionsUsed op)) {
						add functionsUsed op
						func = (functionNamed main op)
						if (notNil func) {
							add todo (cmdList func)
						}
					}
				} else {
					for lib (values (libraries mbProject)) {
						if (libraryDefines this lib op) {
							add libsUsed (moduleName lib)
						}
					}
				}
			} ('to' == op) {
				add functionsUsed (first (argList cmdOrReporter))
			}
		}
	}
}

method isFunctionCall MicroBlocksExchange funcName {
	return (or
		(notNil (functionNamed mbProject funcName)) // function call
		(and (beginsWith funcName '[') (endsWith funcName ']'))) // primitive call
}

method isUserDefined MicroBlocksExchange funcName {
	return (notNil (functionNamed (main mbProject) funcName))
}

method libraryDefines MicroBlocksExchange lib funcName {
	if (notNil (functionNamed lib funcName)) { return true } // lib defines function
	if (contains (blockSpecs lib) funcName) {
		// lib has spec (funcName is a primitive call)
		return true
	}
	return false
}

// Script import

method importScripts MicroBlocksExchange aMicroBlocksScripter scriptString dstX dstY {
	mbProject = (project aMicroBlocksScripter)
	scriptCmds = (parse scriptString)
	if (isNil scriptCmds) { return }

	// add block specs
	loadSpecs mbProject scriptCmds

	// add libraries and function definitions
	for entry scriptCmds {
		if ('depends' == (primName entry)) {
			for libName (argList entry) {
				installLibraryNamed aMicroBlocksScripter libName
			}
		} ('to' == (primName entry)) {
			args = (argList entry)
			funcName = (first args)
			parameterNames = (copyFromTo args 2 ((count args) - 1))
			body = (last args)
			addGlobalsFor this body parameterNames
			defineFunctionInModule (main mbProject) funcName parameterNames body
		}
	}

	// find the origin of scripts to be pasted
	scriptsX = 10000
	scriptsY = 10000
	for entry scriptCmds {
		args = (argList entry)
		if (and ('script' == (primName entry)) (3 == (count args))) {
			scriptsX = (min scriptsX (at args 1))
			scriptsY = (min scriptsY (at args 2))
		}
	}

	// add scripts to the scripts pane
	scriptsPane = (scriptEditor aMicroBlocksScripter)
	for entry scriptCmds {
		args = (argList entry)
		if (and ('script' == (primName entry)) (3 == (count args)) (notNil (last args))) {
			script = (last args)
			addGlobalsFor this script
			if ('to' == (primName script)) {
				funcName = (first (argList script))
				f = (functionNamed mbProject funcName)
				block = (scriptForFunction f)
			} else {
				block = (toBlock script)
			}
			fixBlockColor block
			blockX = (round (dstX + ((blockScale) * ((at args 1) - scriptsX))))
			blockY = (round (dstY + ((blockScale) * ((at args 2) - scriptsY))))
			fastMoveBy (morph block) blockX blockY
			addPart (morph scriptsPane) (morph block)
		}
	}
	saveAllChunksAfterLoad (smallRuntime)
}

method addGlobalsFor MicroBlocksExchange script parameterNames {
	globalVars = (toList (allVariableNames mbProject))
	varRefs = (list)
	localVars = (list)
	if (notNil parameterNames) { addAll localVars parameterNames }
	for b (allBlocks script) {
		args = (argList b)
		if (notEmpty args) {
			varName = (first args)
			if (isOneOf (primName b) 'v' '=' '+=') { add varRefs varName }
			if (isOneOf (primName b) 'local' 'for') { add localVars varName }
		}
	}
	varsChanged = false
	for v varRefs {
		if (and (not (contains globalVars v)) (not (contains localVars v))) {
			// add new global variable
			addVariable (main mbProject) v
			varsChanged = true
		}
	}
	if varsChanged { variablesChanged (smallRuntime) }
}
// MicroBlocksFilePicker.gp
// Dialog box for specifying files for opening or saving in MicroBlocks.
// Note: Replaces the GP FilePicker in the MicroBlocks IDE.

defineClass MicroBlocksFilePicker morph window folderReadout listPane parentButton newFolderButton nameLabel nameField cancelButton okayButton topDir currentDir useEmbeddedFS action forSaving extensions isDone answer onFileSelect onFolderSelect cloudAction

to pickFileToOpen anAction defaultPath extensionList {
  // Pick an existing file to open starting at defaultPath, if provided. If anAction is not
  // nil, invoke it on the full path of the choosen file. If it is nil, wait synchronously
  // until a file is chosen and return its full path, or the empty string if no file is chosen.

  return (pickFile anAction defaultPath extensionList false)
}

to fileToWrite defaultPath extensionList {
  // Ask the user to enter a file name and location for writing. If provided, defaultPath is
  // offered as a starting point. Wait synchronously until a file is specified and return its
  // full path, or the empty string if the user cancels the operation.

  if (and (notNil defaultPath) (endsWith defaultPath 'png') ) {
	lastScriptPicFolder = (lastScriptPicFolder (findProjectEditor))
    if (notNil lastScriptPicFolder) {
      defaultPath = (join lastScriptPicFolder (filePart defaultPath))
    }
  }

  if (and (isClass extensionList 'String') (notNil defaultPath) ((count defaultPath) > 0)) {
	// there is a single extension and the default path is not nil or empty
	extension = extensionList
	if (not (endsWith defaultPath extension)) {
	  // append the extension to the default path
	  defaultPath = (join defaultPath extension)
	}
  }
  fileName = (pickFile nil defaultPath extensionList true)
  if (endsWith fileName 'png') {
	 setLastScriptPicFolder (findProjectEditor) (directoryPart fileName)
  }
  return fileName
}

to pickFile anAction defaultPath extensionList saveFlag {
  if (isNil saveFlag) { saveFlag = false }
  page = (global 'page')
  if (and (notNil defaultPath) (beginsWith defaultPath '//')) {
	defaultPath = ''
  }
  picker = (initialize (new 'MicroBlocksFilePicker') anAction defaultPath extensionList saveFlag)
  pickerM = (morph picker)
  setPosition pickerM (half ((width page) - (width pickerM))) (40 * (global 'scale'))
  addPart page picker

  if (and saveFlag (isNil anAction)) {
	// modal version -- waits until done and returns result or nil
	setField (hand page) 'lastTouchTime' nil
	while (not (isDone picker)) { doOneCycle page }
	destroy pickerM
	return (answer picker)
  }
}

// function to return the user's MicroBlocks folder

to microblocksFolder {
  if ('iOS' == (platform)) { return '.' }
  path = (userHomePath)

  // Look for <home>/Documents
  if (contains (listDirectories path) 'Documents') {
	path = (join path '/Documents')
  }
  if (not (contains (listDirectories path) 'MicroBlocks')) {
	// create the MicroBlocks folder if it does not already exist
	makeDirectory (join path '/MicroBlocks')
  }
  if (contains (listDirectories path) 'MicroBlocks') {
	path = (join path '/MicroBlocks')
  }
  return path
}

// support for synchronous ("modal") calls

method destroyedMorph MicroBlocksFilePicker { isDone = true }
method isDone MicroBlocksFilePicker { return isDone }
method answer MicroBlocksFilePicker { return answer }

// initialization

method window MicroBlocksFilePicker { return window }

method initialize MicroBlocksFilePicker anAction defaultPath extensionList saveFlag {
  if (isNil defaultPath) { defaultPath = (microblocksFolder) }
  if (isNil saveFlag) { saveFlag = false }
  if (isClass extensionList 'String') { extensionList = (list extensionList) }
  scale = (global 'scale')
  useEmbeddedFS = false

  forSaving = saveFlag
  if forSaving {
	title = 'File Save'
  } else {
	title = 'File Open'
  }
  window = (window title)
  morph = (morph window)
  setHandler morph this
  setClipping morph true
  clr = (gray 250)

  action = anAction
  extensions = extensionList
  topDir = ''
  isDone = false
  answer = ''

  lbox = (listBox (array) nil (action 'fileOrFolderSelected' this) clr)
  onDoubleClick lbox (action 'fileOrFolderDoubleClicked' this)
  setFont lbox 'Arial' 16
  if ('Linux' == (platform)) { setFont lbox 'Arial' 12 }
  listPane = (scrollFrame lbox clr)
  addPart morph (morph listPane)
  setGrabRule (morph listPane) 'ignore'

  addShortcutButtons this
  addFolderReadoutAndParentButton this
  if forSaving { addFileNameField this (filePart defaultPath) }
  okayLabel = 'Open'
  if forSaving { okayLabel = 'Save' }
  okayButton = (textButton this 0 0 okayLabel 'okay' true) // default
  cancelButton = (textButton this 0 0 'Cancel' (action 'destroy' morph))

  setMinExtent morph (520 * scale) (420 * scale)
  setExtent morph (520 * scale) (420 * scale)

  if forSaving {
	defaultPath = (directoryPart defaultPath)
	if (isEmpty defaultPath) { defaultPath = (microblocksFolder) }
	if ('Browser' == (platform)) { defaultPath = 'Downloads' }
  }
  if (and ((count defaultPath) > 1) (endsWith defaultPath '/')) {
	defaultPath = (substring defaultPath 1 ((count defaultPath) - 1))
  }
  if (isOneOf defaultPath 'Examples' 'Libraries') {
	useEmbeddedFS = true
	if ('Browser' == (platform)) { useEmbeddedFS = false }
  }
  isTopLevel = (isNil (findFirst defaultPath '/')) // root folder
  showFolder this defaultPath isTopLevel
  return this
}

method addFolderReadoutAndParentButton MicroBlocksFilePicker {
  scale = (global 'scale')
  x = (110 * scale)
  y = (32 * scale)
  fontName = 'Arial Bold'
  fontSize = (16 * scale)
  if ('Linux' == (platform)) { fontSize = (12 * scale) }
  if ('Browser' == (platform)) {
	fontName = 'Arial'
	fontSize = (16 * scale)
  }

  folderReadout = (newText 'Folder Readout')
  setFont folderReadout fontName fontSize
  setGrabRule (morph folderReadout) 'ignore'
  setPosition (morph folderReadout) x y
  addPart morph (morph folderReadout)

  parentButton = (textButton this 0 0 '<' 'parentFolder')
  parentButtonM = (morph parentButton)
  setTop parentButtonM (y + (3 * scale))
  setLeft parentButtonM (x - ((width parentButtonM) + (13 * scale)))
  addPart morph parentButtonM
}

method addFileNameField MicroBlocksFilePicker defaultName {
  scale = (global 'scale')
  x = (110 * scale)
  y = (32 * scale)
  fontName = 'Arial Bold'
  fontSize = (15 * scale)
  if ('Linux' == (platform)) { fontSize = (12 * scale) }
  if ('Browser' == (platform)) {
	fontName = 'Arial'
	fontSize = (15 * scale)
  }

  // name label
  nameLabel = (newText (localized 'File name:'))
  setFont nameLabel (join fontName ' Bold') fontSize
  setGrabRule (morph nameLabel) 'ignore'
  addPart morph (morph nameLabel)

  // name field
  border = (2 * scale)
  nameField = (newText defaultName)
  setFont nameField fontName fontSize
  setBorders nameField border border true
  setEditRule nameField 'line'
  setGrabRule (morph nameField) 'ignore'
  nameField = (scrollFrame nameField (gray 250) true)
  setExtent (morph nameField) (213 * scale) (18 * scale)
  addPart morph (morph nameField)
}

method addShortcutButtons MicroBlocksFilePicker {
  scale = (global 'scale')
  hidden = (array 'Cloud') // this can be used to hide selected shortcuts

  showMicroBlocks = (and
	(not (contains hidden 'MicroBlocks'))
	('Browser' != (platform)))
  showExamples = (and
	(not (contains hidden 'Examples'))
	(not forSaving)
	(isClass extensions 'Array')
	(contains extensions '.gpp'))
  showLibraries = (and
	(not (contains hidden 'Libraries'))
	(not forSaving)
	(isClass extensions 'Array')
	(contains extensions '.ubl'))
  showDesktop = (not (contains hidden 'Desktop'))
  showDownloads = (and
	(not (contains hidden 'Downloads'))
	('Linux' != (platform)))
  showComputer = (not (contains hidden 'Computer'))

  buttonX = ((left morph) + (17 * scale))
  buttonY = ((top morph) + (55 * scale))
  dy = (65 * scale)
  if showExamples {
	addIconButton this buttonX buttonY 'examplesIcon' (action 'setExamples' this)
	buttonY += dy
  }
  if showLibraries {
	addIconButton this buttonX buttonY 'libsIcon' (action 'setLibraries' this) 'Libraries'
	buttonY += dy
  }
  if showMicroBlocks {
	addIconButton this buttonX buttonY 'microblocksFolderIcon' (action 'setMicroBlocksFolder' this) (filePart (microblocksFolder))
	buttonY += dy
  }
  if (not (isOneOf (platform) 'Browser' 'iOS')) {
	if showDesktop {
	  addIconButton this buttonX buttonY 'desktopIcon' (action 'setDesktop' this)
	  buttonY += dy
	}
	if showDownloads {
	  addIconButton this buttonX buttonY 'downloadsIcon' (action 'setDownloads' this)
	  buttonY += dy
	}
	if showComputer {
	  addIconButton this buttonX buttonY 'computerIcon' (action 'setComputer' this)
	  buttonY += dy
	}
  }
  if (and showComputer ('Browser' == (platform))) {
	addIconButton this buttonX buttonY 'computerIcon' (action 'setComputer' this)
	buttonY += dy
  }
  if (and showLibraries (not (contains hidden 'Cloud'))) {
	addIconButton this buttonX buttonY 'cloudIcon' (action 'cloudAction' this) 'Cloud'
	buttonY += dy
  }
  if (and (devMode) showLibraries) {
	addIconButton this buttonX buttonY 'newLibraryIcon' (action 'newLibrary' this) 'New'
	buttonY += dy
  }

  newFolderButton = (textButton this (buttonX + (2 * scale)) buttonY 'New Folder' 'newFolder')
}

method addIconButton MicroBlocksFilePicker x y iconName anAction label {
  if (isNil label) {
	s = iconName
	if (endsWith s 'Icon') { s = (substring s 1 ((count s) - 4)) }
	s = (join (toUpperCase (substring s 1 1)) (substring s 2))
	label = s
  }
  isChinese = ('ç®ä½ä¸­æ' == (language (authoringSpecs)))
  scale = (global 'scale')
  iconBM = (call iconName (new 'MicroBlocksFilePickerIcons'))
//  iconBM = (scaledIcon this iconName) // don't activate this until warpBitmap works in browsers
  bm = (newBitmap (70 * scale) (50 * scale))
  drawBitmap bm iconBM (half ((width bm) - (width iconBM))) 0
  if (1 == scale) {
	setFont 'Arial Bold' (9 * scale)
  } else {
	setFont 'Arial Bold' (12 * scale)
  }
  if ('Browser' == (platform)) {
	setFont 'Helvetica' (13 * scale)
  }
  if (and isChinese ('Win' == (platform))) {
	setFont 'Arial Bold' (12 * scale)
  }
  labelX = (half ((width bm) - (stringWidth (localized label))))
  labelY = ((height bm) - (fontHeight))
  drawString bm (localized label) (gray 0) labelX labelY

  button = (newButton '' anAction)
  setLabel button bm (gray 225) (gray 245)
  setPosition (morph button) x y
  addPart morph (morph button)
  return button
}

method scaledIcon MicroBlocksFilePicker iconName {
	// This works on SDL 2.0.10 but warpBitmap has not yet been implemented for browsers.
	scaleFactor = (0.8 * (global 'scale'))
	iconBM = (call iconName (new 'MicroBlocksFilePickerIcons'))
	resultBM = (newBitmap (scaleFactor * (width iconBM)) (scaleFactor * (height iconBM)))
	// warpBitmap args: dstBM srcBM xScale yScale rotation
	warpBitmap resultBM iconBM 0 0 scaleFactor scaleFactor
	return resultBM
}

method textButton MicroBlocksFilePicker x y label selectorOrAction makeDefault {
  if (isClass selectorOrAction 'String') {
	selectorOrAction = (action selectorOrAction this)
  }
  result = (pushButton label (gray 130) selectorOrAction nil nil makeDefault)
  setPosition (morph result) x y
  addPart morph (morph result)
  return result
}

// actions

method onSelectCloud MicroBlocksFilePicker anAction {
	cloudAction = anAction
}

method cloudAction MicroBlocksFilePicker {
	call cloudAction
}

method onFileSelect MicroBlocksFilePicker anAction {
	onFileSelect = anAction
}

method onFolderSelect MicroBlocksFilePicker anAction {
	onFolderSelect = anAction
}

method setComputer MicroBlocksFilePicker {
  if ('Browser' == (platform)) {
	isDone = true
	removeFromOwner morph
	repeat 10 { // hack: need several cycles to remove MicroBlocksFilePicker when file is double-clicked
		doOneCycle (global 'page')
		waitMSecs 10 // refresh screen
	}
	ext = ''
	if (notNil extensions) { ext = (first extensions) }
	if (beginsWith ext '.') { ext = (substring ext 2) }
	browserReadFile ext
	return
  }
  useEmbeddedFS = false
  showFolder this '/' true
}

method setDesktop MicroBlocksFilePicker {
  useEmbeddedFS = false
  showFolder this (join (userHomePath) '/Desktop') true
}

method setDownloads MicroBlocksFilePicker {
  useEmbeddedFS = false
  showFolder this (join (userHomePath) '/Downloads') true
}

method setExamples MicroBlocksFilePicker {
  useEmbeddedFS = true
  if ('Browser' == (platform)) { useEmbeddedFS = false }
  showFolder this 'Examples' true
}

method setLibraries MicroBlocksFilePicker {
  useEmbeddedFS = true
  if ('Browser' == (platform)) { useEmbeddedFS = false }
  showFolder this 'Libraries' true
}

method setMicroBlocksFolder MicroBlocksFilePicker {
  useEmbeddedFS = false
  showFolder this (microblocksFolder) true
}

method newLibrary MicroBlocksFilePicker {
  scripter = (scripter (findProjectEditor))

  libName = (freshPrompt (global 'page') 'New library name?' '')

  if (libName != '') {
	  lib = (newMicroBlocksModule libName)

	  addLibrary (project scripter) lib
	  updateLibraryList scripter
	  updateBlocks scripter
	  selectLibrary scripter lib

	  showLibraryInfo lib true

	  removeFromOwner morph
	  isDone = true
  }
}

method parentFolder MicroBlocksFilePicker {
  i = (lastIndexOf (letters currentDir) '/')
  if (isNil i) { return }
  newPath = (substring currentDir 1 (i - 1))
  showFolder this newPath false
}

method showFolder MicroBlocksFilePicker path isTop {
  currentDir = path
  if isTop { topDir = path }
  setText folderReadout (localized (filePart path))
  updateParentAndNewFolderButtons this
  setCollection (contents listPane) (folderContents this)
  changeScrollOffset listPane -100000 -100000 // scroll to top-left
  if (notNil onFolderSelect) {
	call onFolderSelect (join path)
  }
}

method folderContents MicroBlocksFilePicker {
  result = (list)
  if useEmbeddedFS {
	dirsAndFiles = (embeddedFilesAndDirs this (join currentDir '/'))
	dirList = (at dirsAndFiles 1)
	fileList = (at dirsAndFiles 2)
  } else {
	dirList = (listDirectories currentDir)
	fileList = (listFiles currentDir)
  }
  for dir (sorted dirList 'caseInsensitiveSort') {
	if (not (beginsWith dir '.')) {
	  add result (array (join '[ ] ' (localized dir)) (join '[ ] ' dir))
	}
  }
  for fn (sorted fileList 'caseInsensitiveSort') {
	if (not (beginsWith fn '.')) {
	  if (or (isNil extensions) (hasExtension fn extensions)) {
		add result (array (localized (withoutExtension fn)) fn)
	  }
	}
  }
  return result
}

method embeddedFilesAndDirs MicroBlocksFilePicker prefix {
  dirsSeen = (dictionary)
  dirList = (list)
  fileList = (list)
  offset = ((count prefix) + 1)
  for fn (listEmbeddedFiles) {
	if (beginsWith fn prefix) {
	  fn = (substring fn offset)
	  i = (findFirst fn '/')
	  if (isNil i) {
		add fileList fn
	  } else {
		dirName = (substring fn 1 (i - 1))
		if (not (contains dirsSeen dirName)) {
		  add dirList dirName
		  add dirsSeen dirName
		}
	  }
	}
  }
  return (list dirList fileList)
}

method newFolder MicroBlocksFilePicker {
  newFolderName = (prompt (global 'page') 'Folder name?')
  if ('' == newFolderName) { return }
  for ch (letters newFolderName) {
    if (notNil (findFirst './\:' ch)) {
      inform 'Folder name cannot contain: .  /  \  or  :'
      return
    }
  }
  newPath = (join currentDir '/' newFolderName)
  makeDirectory newPath
  useEmbeddedFS = false
  showFolder this newPath false
}

method okay MicroBlocksFilePicker {
	answer = ''
	if forSaving {
		answer = (join currentDir '/' (text (contents nameField)))
	} else {
		sel = (selection (contents listPane))
			if (isClass sel 'Array') { sel = (at sel 2) }
			if (notNil sel) {
				if (beginsWith sel '[ ] ') {
					// jump inside folder
					select (contents listPane) sel
					return
				} else {
					answer = (join currentDir '/' sel)
				}
			}
		if (and useEmbeddedFS ('' != answer)) { answer = (join '//' answer) }
		if (and (notNil action) ('' != answer)) {
			removeFromOwner morph
			call action answer
		}
	}
	removeFromOwner morph
	isDone = true
}

method fileOrFolderSelected MicroBlocksFilePicker {
	sel = (selection (contents listPane))
	if (isClass sel 'Array') { sel = (at sel 2) }
	if (beginsWith sel '[ ] ') {
		sel = (substring sel 5)
		if (endsWith sel ':') {
			showFolder this sel true
		} ('/' == currentDir) {
			showFolder this (join currentDir sel) false
		} else {
			showFolder this (join currentDir '/' sel) false
		}
	} else {
		// fill the file name input field with the name of the selected file
		if (notNil nameField) {
			setText (contents nameField) sel
		}
		if (notNil onFileSelect) {
			path = (join currentDir '/' sel)
			if useEmbeddedFS {
				path = (join '//' path)
			}
			call onFileSelect path
		}
	}
}

method fileOrFolderDoubleClicked MicroBlocksFilePicker {
  sel = (selection (contents listPane))
  if (isClass sel 'Array') { sel = (at sel 2) }
  if (beginsWith sel '[ ] ') {
	sel = (substring sel 5)
	if (or (endsWith sel ':')) {
	  showFolder this sel true
	} else {
	  showFolder this (join currentDir '/' sel) false
	}
  } else { // file selected
	if (not forSaving) {
	  answer = (join currentDir '/' sel)
	  if useEmbeddedFS { answer = (join '//' answer) }
	  if (notNil action) { call action answer }
	  removeFromOwner morph
	}
  }
}

method updateParentAndNewFolderButtons MicroBlocksFilePicker {
  // parent button
  if (and (beginsWith currentDir topDir) ((count currentDir) > (count topDir))) {
	show (morph parentButton)
  } else {
	hide (morph parentButton)
  }

  // new folder button
  if (notNil newFolderButton) {
	if (and forSaving
			('Browser' != (platform))
			(not (contains (splitWith currentDir '/') 'runtime'))
			(currentDir != '/')
	) {
	  show (morph newFolderButton)
	} else {
	  hide (morph newFolderButton)
	}
  }
}

// Layout

method redraw MicroBlocksFilePicker {
  scale = (global 'scale')
  fixLayout window
  redraw window
  topInset = (24 * scale)
  inset = (6 * scale)
  bm = (costumeData morph)
  fillRect bm (gray 230) inset topInset ((width bm) - (inset + inset)) ((height bm) - (topInset + inset))
  costumeChanged morph
  fixLayout this
}

method fixLayout MicroBlocksFilePicker {
  scale = (global 'scale')

  // file list
  topInset = (55 * scale)
  bottomInset = (40 * scale)
  leftInset = (110 * scale)
  if (notNil nameLabel) {
    leftInset = (max leftInset ((width (morph nameLabel)) + (23 * scale)))
  }
  rightInset = (20 * scale)
  setPosition (morph listPane) ((left morph) + leftInset) ((top morph) + topInset)
  setExtent (morph listPane) ((width morph) - (leftInset + rightInset)) ((height morph) - (topInset + bottomInset))
  updateSliders listPane

  // parentButton and folder readout
  parentButtonM = (morph parentButton)
  setLeft (morph folderReadout) (left (morph listPane))
  setLeft parentButtonM ((left (morph listPane)) - ((width parentButtonM) + (13 * scale)))

  // nameLabel and nameField
  if (notNil nameLabel) {
	x = ((left morph) + leftInset)
	y = ((bottom morph) - (32 * scale))
	setPosition (morph nameField) x y

	x += (- ((width (morph nameLabel)) + (8 * scale)))
	y = (y - (1 * scale))
	setPosition (morph nameLabel) x y
  }

  // okay and cancel buttons
  space = (10 * scale)
  y = ((bottom morph) - (28 * scale))
  x = ((right morph) - ((width (morph okayButton)) + (25 * scale)))
  setPosition (morph okayButton) x y
  x = (x - ((width (morph cancelButton)) + space))
  setPosition (morph cancelButton) x y
}

method listPane MicroBlocksFilePicker { return listPane }

defineClass MicroBlocksFilePickerIcons

method computerIcon MicroBlocksFilePickerIcons {
  data = '
iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAO
xAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAANtSURBVFiF5ZZb
aBxlFMd/c/m+3Z2dJLVoG1MDBaUo8UVBTVNbW4pIRLyXSqBioC9SiVWUesPijVIKKlYKeak1SiFSbdGi
wUJMi9HWVsVgSYu+tCQmIZXs7GYvs3NZH8KumWYvNuxuH/zDPMz/fDPnd5jznW/g/y4FiBhG+NWQFOtz
OV/8G1C9bDY7nEzbbwHxmgE0NZifd7S3dT7ZdV9E19RCwPN8Dh05njk2eOaklUhuqBmA0DV79Oc+2WAa
C4Ku57Gy7QnHcdwewK9SzgTwK3AO5j5BbuKPL1BVpejq3v1fuaPnL3hVSk4sPps9dXpUdT1vMB5PbqoI
UAvZtsPT299Nn/hx5JOrAgDw1+TfrLl3W0ytvLQ2al62lFTKXqIDHDg4wNGBk4yNT9cl+YqW63iwsx0A
XUrJkaOn2Pna87S2ttQF4OLFcd58532kFCiRSDj325kBWq5fXpfkeY2NT3LbnZ1z2zB+6SyqWt928H2f
xmvbuGpNmJdeKnB25DhD3/aRTiUKXtM1y+h8+BluaL25tgC+7/P14Q/ZsnUXS5Y2F/w/z5/m2Je9dG97
DwDPdXGcTNkEQoTR9JJ1FgewM0lQoHnFTQG/deWtDA58BMD33/Xzw1A/qlb65QCe57JuYxer1z3+3wEA
fM9l9+uPBLwcIITEcWyGh/rp2XGAiNFYFiA1a7F3Tzd3dDyErosF8ZIAqqbx7EufBrx47BIH979C1k4j
ZKhicgDDbELVNJxs5soAQEHKcMARMlQx4ZWqJIDnOrz98v0L/Gi0ctVVAdB0wY43Dgc8KzZNX+8L9QEA
UBSl7H01tKhJKEMRnKxNOlX5XzU5GyPneYjL+imv8pu4hIQIsWb9Zj7Y/RTavDng+S5KjsBsyM+BYjug
JICQYXKeR2rWwjCbCr41M0U4YgJw94bNtK99FNexC/Hhoc9QFIWOezbNg13EJNR1wdqNXezd0x2oUFEU
HnhsOwAf977I9NSFwHOu66AAv/z0TcBf3nIjW7buKgpQ9ji+fNbLUARV1QBwHBvPdUpWNl+aLhAiOEPy
x3HZHtB0HU03i8aECC146WKkSikzlpWovLLKsqwEISnTWkND9JaR38+tWn3X7XpjY/Fqq62x8Ul6ntuZ
npiYOgRgmKaxLxo1Zpg78Gp+RaPGjGka+wDjH/YDRFusMm44AAAAAElFTkSuQmCC'
  dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAd
eQAAHXkBKkJFPwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAZgSURBVHic7Zt7
bBRFHMc/+7iWa3vt9SEFgRILAlFQBAzYNrQUEMNDwEBRNCYY64Mi8ZmY8IcGE/9RE6IRApqIii8gSnkp
JFBauRYoIsUKAimhPGyK7bW9HvRxu3v+cb3zpKXX3d6j0H6STeZ25zfzm29mdn4zOwcDDDBAf0bwS5uA
ucCDQEwAuzagCtgJNIbGtfAyATgBuHVeNcDCCPgbNAQgBfgDGJKQEMfM7EnExgzq1khRVEqPVlJ9uRZA
BaYDpaF2NhQIwCYg/97Rw/lxy3sMvsvaI8O2NhcFb6xj18+lAH8C40PnZugQ8HTjIVs+W8Ps3Cm6jOvt
DiZMW4GqagCjgAvBdzG0yEAqwKj0YbqNk5PiSbRaqKtvAijB83Lsa2hAHXAc+Ak46P9QpmMmEIROhj1i
8fwsPvtyD4B+BcPHaGAasAooA1YAZ8HTeDfAkYPruWfkUN0lu91uyo6dRlGUoHkbbGpq7fxaeorCPTba
210ATcBsoLzXAtxOVF+uJX/VB1RUVgFcBe4TI+xTWBk5IpWtX73L3UNTwDNkV/crAQCsCXG8unKJ9+eS
ficAwMOTxnqTo/ulAGZztDcZ2y8F8Ef2/3Hi5DkK99o4e/4ydrsjUj6FhKSkeMaNSWPh3Eys1rj/PXMD
7tzsh/SuBG/ba2b2JF/aFwcASJLEgnmzyJk+leTkRAM6913q6xsoKj7C7r0HUFXVd98ngMUSx/bvNpCZ
oW9BdLtx2FbOkqdexum8DoAEvAuw9p3XWfLE3Ai6Fh7S0oYRFWXiQJENAN8skJuTETGnws2s3Cxf2ifA
oOjoLjPfifi3td/HAQMCRNqBSCMHztKZy9VnsBV9R23NRVyu1i7zxMZaSbtnPDmPPktsXM82WiOBbgHO
/1XOtq/Xomlqt/laW5zU112h6txx8ld/ijnGYtjJUKJbgH0716NpKuPuz2Rq1iJkU9ezh7PZzv5dG2mw
13C46Htmz8vvtbOhQJcAzmY7jQ21CILI40tfIyq6+y9orS1OCrd+yJXq052eKUo79rqr/wtLjSBJMskp
w5FkQ6NZnwAtN5wdlUoBGw/4un1LS7PvnqK4OLT/S8pLC3vdeC+ybCIjO4+s3CcRRUmfrdFKA70DANxu
rdO9ol++4KhtBwBR0WbdDt+Mqiq42lspOfANoiSTNWOZLntDAqiayvtrFui2a29vpbxsFwCLlr3F+Ikz
jFTfiWO2HezfvYnS4m1k5ixFEHo+u4c1Dqi7dglNUzHHWILWeIDJ0xYgiiLtbTdotNfqsjXUA0RBpODt
zQHzXayqYOe2j3y/VcUFgCSZjFR7SyRJQhQlNE1D6aijpxgSQBAE4hNSAuaLiY03UnxYGQiFDVm5PTFB
IFpvNAfME2mMzQKqwrr3nwm2LxFhYAgYMZJkmTff2R4wX9X539j21VojVYQNw5GgLAeeyqReRnnhoN8P
gQEBwlmZd+/ApQT3LJWqKGiaZ+FlMkXpsg2rACmpI5BkmbaW65TbCn1O9wZVUbAd+t63xkhITNVlb/gl
aASTHE1mdh4lB75l3+6N7Nu9MajlT5/5NILO425hFQAgK3c5khxFWcl2WlucQSkzJi6B6bnLmTxtvm5b
XQJ4x5emaaiKEnAbSlHaO+z+O3ssiiKZOXlk5uThaKpDVbtevV13NrB5w5sAvPjaBmS567EtyyYs8YEX
ZrdClwAJiakMMsfR2uLEVvwDGdl5t4wHrjsbOWYrBGDIsFFd5uluRelfrjVpCCY5NJ/ufJ/HTx3fR3p6
WkAD7+5LT5HlKJ5/5WNSBnvKLtz6IZUni3C73QEs9SEIIlMemc+cBS8FzHvhwiUemDLH45/eih7OWIgo
SpQc/JYbzqZuHBJIHZrOY4sKfI0HaGq8FvTGg2f/0dH0j2473T3An2ZHvW+c30yMOZ5oc2yn+6qi4HD0
zFGXqw1RFHu8g5RgTUUUA8/sveoB/ljik3XbSLJMYlLfOZI7EApH2oFIIwIKgKL23ePuwcavrYoIXAI4
WdH5+92dyonfK73JagkYAWScrDjN4oVzsFjibm15B/B3TS3PvfAWDocT4HMBSAIqgOEpKUmsLljBjOxH
sFr7/p6+HhoamigqLuOT9Zupq7ODp+dP9D4fC5yhDxxjDdN1Bhhzs0hmoADPv78a+oCTwb4agGJgZUdb
AfgXKCaphJhXjRgAAAAASUVORK5CYII='
  if (2 == (global 'scale')) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method libsIcon MicroBlocksFilePickerIcons {
  data = '
iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAO
nAAADpwBB5RT3QAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAToSURBVFiFvZdb
TBRXHMZ/s8zOzuyyRQSBZUG5o9LW+61oi7Va0mjS1KqNTUvbpOk1qTW2sUk1sTZNa1vBNhp9wJBaU632
obdoLBJERYgVraKGi0hYQLm4uAsLuzDL9KHVBndZGIn9JvMy8/3P95tzzpwzIxBcYYosfyoIwhuqX1Uk
SbotimFNAwP+eo/H028Nt+R6fb4okyR1aQilHo+nGDgNXAW0YdoMKiHYRVmWt6SnJW3YuWOr2W6Pw9Hc
isPRyqXqGr7dVcTOHVtZtHAujY0OzlSep7jklHau6hKqqvolyejo7vaUA/uAUsA3EoAiSdJGsyw9iaBJ
AP5Bpv+4f5e0aOHcIeb8bwqpvlxD4Z5tAQ1pmkZNbQPlFecoK6vkZPlZrbPTOWgNN1f3ePqOqapaBpQD
ziEA4RblYNaUpBWvvJiriKKIpsG7Gwq48tdx4mInDAlZvfZtcp/O4bW81aH79V/dbOugorKKU+Vn1dLS
ir66a41mi0Upcbt7XgZuAghGMcxbWbrbZLdFA9DW3sWcnDfpbL2AIPw3QpqmMSn9MY79/j2TM1NHBXCv
XK5uNm/52n/w8K+NPT296YBmGFD9pnCLctfkaGlnYoJtSDhATW0DmqaRmZFyX+EAERFWtn+5KUxASFUU
0x+AyXCvqbmlg8SJ8QHFZyqrWDBvZgCYXt2pn5oxKTvcrOQHADQ1t5M0MSEQoOIcC+bPGlM4QPXlWmRZ
Iv+Ld+RBtBcCe6C1g8REexCAKhbMmzFmgIrKKubNmUpcbBS9vd5IAdA2b8zjaPGftLU7cbs9yLKMLJvu
FvkHB7l1q4sJ0ePHPAQudzdRkVbWrlrCls+LEIxGUctIT+bjj94jwR43xucbnZpbbrL1swLq6hoRZNmk
nSw5zJTJaf9L+B1duVrH40tWIXq9PuJtsUFNLc01tLU23FeAxTKOlMyZGEVT0Pv2+Di8Xh9iqEYa6y9S
dnwfKWkzsD4UrQvAdbuDspL9vPpWPqJoHNYXEiA7ZxU9PU4iIiYwf9FzugAAinat50ZzLYlJWcN6Al7D
e6XIFvr7vbrDAWSzFZ+vN6QnZA/09bppqD/PtFlL8fb16Arvdjtpa20gKjpwURs1wPEje+lsd1B8pJDi
I4W6ABQlnOzFa4iMsoX0hRyC5SvX8eisp/D1eRj0+xF0HN4+DyVH9/Lb4QI0bfiPpJA9ALD0mdfp9/Yy
bryNhYvXjGQfIlXt57s9H3D92gVS0oIv4yNOQkEQsNnT6XZ36goHEEWJmNhk3K6OYT0jAgC4Xe0oSrhu
AACXqx1FsQ57f8QhOFnyA+UnfiImLokWR42u8J7uLkyyhdSM2foBWhw1HPtlN6raT2SUjYF+L65RrgcG
g0hsfDI5y/Kw2dMwGML0A8TEJZGYnEXT9WqWP//+qILvyD+ocrrkANfrL2BPzAzpHRbAaDQxN/tZrlws
w2bXv1NOm72M6vMlI/pCTkK/OoAhbMRpErzWP7raYR1dzhv8fOgrRFGi/MQhfeGqysWqYhbn5t0/gMEQ
RnLqdPx+Vfc+ECaKrFi5jokpj4wMIEnGXmfXbXNExNB3NWJcDE8sfUlXsB45nV2YJKlXsFotRQ9nZa7e
vm2TkpgQ+D/wINTkaGX9h5/0XaquPQCgKIqyw2xWnPzza/3AT7NZcSqKUgAofwNEK90nvFaEEAAAAABJ
RU5ErkJggg=='
  dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAd
dwAAHXcBjssJwQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAnESURBVHic5Zt7
cFTVHcc/e3ezz7zfPLIJpLwRIUASwhiwRKAqRaS1o2grVluVStWO04fTqZ1pmbEzDuOo1ToyqGitVqtl
VBAjCUiS3RB2E5JAAgh5LXknkJAH2cftH5tdQx7s7r3rJtrPzJ3dmz3ne3/nm3PPPfd3z1UQOErgZ8BP
gaWAAegA6oG64c/6Eft1gBrYCdwJzAdcwBmgFDgGFAHnJMQScpKAYkAMcHP6UaYZeB94HFgJqELRIEUA
ZQXgKLDaYNCzc8f9bNywlpioKFpa26lvsFHfYKOx0UZD40XqG200NbUwNDQEwKy0FJ58/CFysjNwOl1U
VddSYrZQYrJw6vRZXC7X6OMNApVAIZAPlAC9chs8mkAM2Aq8r9fr+OLgP7lh8XyfFXY9+yK7nn2J9PRU
jnz+HtHRkeOW6+npxVRqxVxaTlFJGRZLJf0Dg6OLiUA38CXw7vBnUwDxj8vIbiYAucASQDdO2a0A996z
xa/GA3xy4DAAO3dsn7DxAJGREazPy2V9Xi4AdrsDa0U15lIrxSVlmErLaW/vVACxwObhDdzjjGcMOQZU
4x5f/MbTA9KBvcBNviq8/MJfuW/bnT6Fe3uvMHN2Nk6nk4rjB0lPTw0krjE0t7RhMlsoNlkwmS2UV5xC
FMUxhwXMfG1IETBwPV0FEIX7XEvR6zTkZC1Gr9eMKfj54TIGBof45KO9rMnN9hnwFwVFbN76IAkJcZyv
+RKFIpCzzTcdHV2UmK2UmE5gMluwVlRjtztGFxsEDgC7gLLxdFTAX4CUNGMy/37zGYwpSWMK2e0OjAvv
AsBonOFXgCazBYBVWcuC3niA+PhYNt22jk23rQNgYHAQi6WKopIyzKVWSsxWenp6tcAW4IfAH4C/jdZR
DRfgz09vH7fxALbmDlwuEaVSyYzpyX4FWGxyG5CdlRFw46Sg02pZnbOC1TkrAHC5XJRZKnlu96t8cuCw
EngWaANeH1lPAKYBzJuTMqF4k60dgOSkBNTqMJ/BOBxOysoqgNAZMBpBEMhccSPvvv0SO3ds9/z5eUB/
TbnhDUEQJhRraGwFIDXVv+5fUXmKvv4B9DotS5csDDj4YPPMH59gWnIiQCTugdHo+W3iVo+gcbgHGFP8
PP9NVgCWL1/iV4/5plGrw8hYttizuxQ4ASwGPw3wnAKpfg6AJd4BcHK6/3i0tLjbMC0pDiAe2A8Y/OwB
bQCkpEz362DeK0D21DCgf2CQyuoaAF55/kmSEmMAZgG/CsgAox8GnD/fQEtrO4IgkLVyqdSYg0pZWQVD
Q3aio8LJXL6AXz/yI89Pd/k0wOF00tLSBUCqH2NAsekEAIsWziUyMkJy0MHEc0leuXw+gqBgVaZ3YJ7r
04Dm5k4cTicKhYIZM33PAaZa94evY8pcvgAAg8F7qxPu0wBP909KjEerGTtFHo3H7akyALpcLkqH5yRZ
KxaM+f2apMPp2nr2f1rM6dp6+vrdt6Otbe7uPzAwyKYtD1z3YHa7gzNnzwPw6p53ePOtD+S3QCZXrvTT
09OLIAgcPmIhKtKATnftP1IExFs3ZIsKhSLQTM+3blMoFOLtG1d9vT/8BQCFQsG6m1ezdk32lBnAgsXl
y70cOWrii4Kia26jvQbo9Tre2fcC625ePVkxhoT8w8e4577HvBknJfAMuOfLd/9k83WqfjeYPcuIKiyM
gsJiYMRU2JOO+n9g4/o13u9eA7Ra35e47woj2yo5997WcoGj+W9z9Wp/UILyF5VKTWJyGktXbCAmbpp8
PakVa0+ZqKkulh2AFM7WlFJa9F/uuOsp5i3OkaUl2YBVuVsJj4il8NAb9F25xMIbclmWuVFWMP7gcAxx
5pQJ6/GD7P9gNw8b5xERGSdZT7IBKpWaZSs3EBObzFuv/Z6O9gZmfS80d39z5mcy0N9DTXUx52rLWLZy
g2Qtv26Hr0dK6iIAujouypUKCOMsd4ano7Velo5sAwSlW8LlGpOT/0YRBHfndYkBPQgaqyM3EM+sUnGd
pOo3gTjccIVC3nFlR91sOwtAdIz8S1IgXGw6A0BcvH95yomQPAiKootztSc49PErAKSkLqC7q1lWMP5g
H7pKTXUxVeWFqFRqZs+Vl3eQbID52Ifkf7rHu19edojyskOyggkEQVByy+0PERMrr+dJNmBGynymz5zL
QH8voigiik5ZgfiLKkxNfKKRJRl5zF3g+yGtL7y3w5WWQ8xKm/jx2EQ0Ndaw7x9P4XSGxoCRqDV6Fi25
ibxbH0SjNfhd70JdIzdkrAeCsA5Hq9Gj1UXQd+USABqdAb1u4sUQwcLlctBzuQPr8c9ovvgV2x/ZjVKp
DFhHtgHxiUZ2/m4fR/P3UVT4HhERcTz8xCtyZf3iUncr/9r7J1ps5yg/fpDl2bcFrBGUi7dSqWTNLfeh
D4+io62B/iuXgyHrk+iYJG7KuxuA+guVkjSCNnsRBCXh4bEA9PVdCpasT6KiEgDo7emUVD+007cpSFAN
sNvdicawsNBll64OuddAaTR6HyXHJ2gG1J8/yaWuFjRaA1ExicGSvS6iKHLyRD4AydPTJWnIvgpcHewj
/9M9VFkLEEWRyKg4Cj57Q66sT1wuJ4111dgaa9HoDGRk3SpJR7YBdV+dxHr8oHe/vbWB9tYGubJ+ExkV
z+Yf/4bIqHhJ9SUZ0Np8nqryQq4O9iGKImnpNzI0NGZpa1BRCkpUYWoiIuOIS5iJUhlGQpIRY9piwtRa
ybqSDCg89CZna0olH1QuM1LmsXXb05L/6yORZMD3Nz6AWq2j+uQRAFau3kxCotFHLXk4HXYGBnqpKi/A
1ljL/vefY9sDu2QvwpRkQEKSkS13/5aIqDhMX/4Hl8NBRuYPZAXiL1k5d/Dy7l9Sd66Czo5G4hPkGS/r
Mjh/kTsn39ZaJyuIQNDoDKSlLwGgtfmCbD1ZBghK9xpAlyO0CVGVSg2AY/hlDDl8O6fCnsf7QViDLcuA
7k73s4DwaOlPZqTQ2WkD3HeDcpE8EbI11VLw2esAzJ4TmgVRQ0ODnDB9TGNdNRqdgWkz5sjWlGTA5x+/
irnoI+/+gQ9f5MCHL8oOxl8UCgUbNz2CWjPemz2BIckAjdaAUqkMeR5QrdaSND2dtXn3kpp+Y1A0JRmQ
m7eN3LxtQQlgshEABzApWd3JYkRbHQLQAFBecWrSAgo1FmuV52u9EkgBcqzl1WzZvIGIiPDJiywE2C62
8PNfPMXlnl6A1zwvI1YAM+PjY3ns0ftZuyab2JjoSQ002HR1X6KgsIQX/v46nZ3d4O753hUd84DTTIGl
rCHaTgNzR5ukA3bgfkG6ewoEGeytCzgCPMqIV4P/B7Gu5sILeBMvAAAAAElFTkSuQmCC'
  if (2 == (global 'scale')) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method desktopIcon MicroBlocksFilePickerIcons {
  data = '
iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAO
xAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAGpSURBVFiF7dM/
SBthHMbxby6XN+a9SyxibZsiOBVKJh1a/yx1KJKlW6E4dC+C2K4tCJau4iR0EbHQyYqgQ0AQFIqKSqm0
xOJUSUxEi96lMV6Su3MQ26EFF3MZvAfe6ffC84H398J1TwCISNnwOixCj1zXCf0dKHa5XP5cLFlvAbNm
gMao/qm7M5F83t8XUYPKn4FtO0zPLp0uLG6sGoVib80AITVopTenRFSX/wyrtk1b4lmlUqkOAs4VdRaA
L8A2nD+Bm9uZQVEC/739fmKumv7x076ico7N3+W19bRSte1F0yw+vRRQi1hWhRdDo6Xlla0PdQEA7OV/
0fN44Fi5/GptcruliZMT64YKMPkxxXxqlUz2wJPyu/GbPEl2AqAKIZidX2P4zStaW+OeAHZ3s4y8G0OI
EIFIpMH9upEifueWJ+UXyWTztD9Inn9D8/A7iuLtOjiOQ6w5Qd2W8CI+wAf4AB/gA3yAD6g/QAhxahgF
z4sNo0BYiFIwGtXub33bvtf1sEONxXRPyjPZPIMvh0u53P40gNR1Oa5p8ghwvTiaJo90XY4D8gxLrakS
AQRhKAAAAABJRU5ErkJggg=='
  dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAd
eQAAHXkBKkJFPwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAMwSURBVHic7Ztd
SFNhGMd/c5Zfm85pqflFaRqRVFJkaml+ENgXhjddGhikIiF01UVSl110ERhkFxVCEFEIKd2UWC0tw7RM
qTAoKRF0Q7ELdXNdzI317WrbM937gxees7Pn8Hv/nJ33HDgDhUIRzGjc6lVABbAViPxL3ywwArQBU75R
8y85QB9g93CMAYcFfL2GBogHXgOJMTE6SotyiYoM/2OT1WrD9GyQT6PjADZgD9Dta1lfoAGuADUbM1O4
03qetWsMS2qcnZ2ntvEi9+53A7wBtvhO03docJzGia0tZygv2eFR86R5mpy8amy2BYAM4IP3FX1LKJAA
kLEh2ePmOGM0sQY9E5NTAI9wXBwDjQVgAngB3AUeuu8MZXEl0Gh+alwSlQcLabneDuB5gv4jE8gD6nFc
q6qBt+CYvB2g52Ez69OTPD6y3W6n+/kQVqvVa7beZmzczOOnr2hrNzE3Nw+Opbsc6P3vAJYTH0fHqam/
wMDgCMBnYHOIsJNfSU9N4NaNJtYlxYPjJ9sQVAEAGGJ0nKqtcm5WBV0AADtzs51lZlAGEBER5iyjgjIA
d0LdN/r639HWYeLt+1HM5mkpJ59gNEazKSuNIxUFGAy67/bZAXtJ0XZPnwSX7SgtynXVrvsAAK1Wy6ED
ZRTv3UVcXOw/5By4TE5a6Ozq4V7HA2w2m+tzVwB6vY7bNy9TkO/ZA9Fy44mpl6pjJ5mZ+QqAFmgCOHe2
kaqjFYJq/iEtLZnVq1fxoNMEgGsVKCnOF5PyN2Ulha7aFUB4WNgvv7wScZ9r0N8HqACkBaRRAUgLSKMC
kBaQRgUgLSCNCkBaQBoVgLSANCoAaQFpVADSAtKoAKQFpFEBSAtIowKQFpBGBSAtII0KQFpAGhWAtIA0
KgBpAWlUANIC0oQAVgCrLXBfd/c2bnO1hgCfAPoHhsSE/E3fy0Fn+VELpAL5/QNDVB7Zj16v+33nCuDL
2DjHT5xmenoG4KoGMAIDQEp8vJGGumr2Fe3GYIgWFfU2FssUnV3dXGq+xsSEGRxn/jbn/mxgmAB4jdVP
YxjI+jGkCKAOx7+/LAEg6e1hAbqA2sW5AvANHNVzCuI7b40AAAAASUVORK5CYII='
  if (2 == (global 'scale')) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method downloadsIcon MicroBlocksFilePickerIcons {
	// TODO
	return (desktopIcon this)
}

method examplesIcon MicroBlocksFilePickerIcons {
  data = '
iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAO
xAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAS/SURBVFiFtZd7
bFNVHMc/vW1v29vbFvbQoa4o726y8ZhsjI2XTIliYkAhAYn+IfvHR8Q/1GDEkKD4CELQTIPGICFqFEwI
MahhPDa6joVtYcAezDG2dg9GtnVt161svdc/kEXoxnZx+yb3n3N+v+/vc86595xzdQwvvc1m/URR1FcH
BgbMZpPJbxQNvsFBpT4YDEVk2bq6r68/3mw2dQuCrrinJ/gH4AZqAXUEz2GlG65RlqWd8+elvlWw7yNr
UlIiPl8bzd5WLl6q4/Pd3/DD91+QvTiDpiYfJaXlFJ5yqx5PhRoMhRSzyeQLBENuRVEOAmeAyGgAkiSZ
t5lE43JVVYwAqirMO37soJg2d84dwV8WHKChoYm9uz8c1qytvQNPaTnFZ8s4edqjer2tg1ZZqgmH+/+K
RCJn/p2l7jsAHDb5t+zMlNWbNz5tMRr0qKrK5vxdeK+eQ7KY7yiw8eU3ef65p1j/wpp7DWpIvb1hys5f
wF1yXjl5uiRYdbHGbDaJbn9PcBPQDqAzGvSRuspDolW6Vazjhp+Va96m8UpJjOG02TmcKfyV5EemjAng
bvVHIuze+230q4ID3mCwdxqgCgOD0aHiAF5fB87kh2KSGxqaEEXjfRcHMJtMvP/u63pJsky1Ws0nAJNw
d5CvtQOnMxbAc66CxVkL77v4f6UDXWZGSrbNJu2LAWj2deB0JscClJaTPQ4Ajde8KIrCnl2vmaPR6Pph
ZqCTqckPxySWlFaQlTn/fwOUnqtk8aJUkh6MIxyOTNIB6q4d+Rw7XkpL6w0CgV4sFgsmkziUpCgKnV1+
EuIno9MNu3WMWYFgiMSESbyyKY/3tu/HYDKJHP29jA+2bcXpjB35RKi5uYUdO/cgiiI6i9msVlX8yZSk
BzQbhUM9AEiyQ3Nua9t10jNWowPUUFfNmBNvRsK4T//ChfITKMogAHrBSHrGKrKXvYhoksbsJce5tAEE
A50c+m4byU4XS1ZsYHL8rT2hu7ONs6d+pqW5jpe2fIxsixt/AFVVObj/HabPyiBnxYZhY4oLf6KxoZLN
Wz4d08sqx7mI+QxHUuPfldy82ceS5etHjMlZuYH+vl6uNVwYq+3YAa7WV5Ayd9k9R6bTCaSkLaXhSvn4
A/SG/Ngd8aPG2R0JhHv94w9gs8fj77o+apy/ux2bfXRQzQAzZmVQfbEIVR35xqWqKtVVxcyY/cT4Azin
zUWvN9xzfetryxBFE8mPpo4/AEBW7jo8RYdH7PcUHSYrd50WS20AKWm5BHpu4PPWxvS1+OoIBbqY83jO
xAEIgp60Bauor/bE9F25XEJ6Rh6CoMlSGwDA5LgkmhovoSjRoTZFidJ8rRq7PUGrHQatCYIg0NJcx2fb
1zIp4fZZ0I4SHSB94aqJB9DrRZIfS8WVuoQWby2osHDRM9RcdmOx2DUDaF6Cma5MHI5EytxHyXs2n7w1
+ZS5j+JwJDLTlakZQPN94LZKi49QVPgjAEuf3ERW7lrNHnKcC50oin2NdWfNDodNs8Hg4AAABoNRc67f
H2C6K7dPb7NZXVWXamZlZS4w2O2yJhNB0CMIes3FfS3tvLF1e19b6/UjAJIsy19brVI3t36tJ/yxWqVu
WZYKAOkfzVHeLEHJtboAAAAASUVORK5CYII='
  dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAd
dwAAHXcBjssJwQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAqPSURBVHic3Zt7
UFTXHcc/d1kWdpfHuq6IUfBV34r4AhQUjKkSjQ+wSRPbNEmbNmNsNM1MppN2OpNO28ykM500k8YkTt5N
m0lqM5poIMa3wi4IC1seokQCrAjyUlhhgd292z+WRR6Luwt7N7bfmTvscn/3d7/nu+f+zjm/87sC/iME
eAz4CZAIqIFWoA6o7f9bN+h7LaAA9gLZwHxABC4DhcB5IA/4Zgxcgo7JQD7g9PNw+GDTCBwEngVWAfJg
NEjww1YGnAVS1WoVe/c8TuamDCZER9N0vYW6+gbq6hswmxuoN1+jztzA1atN9PX1ATBzRhzPPftz1qQs
x+EQKa+4hL7AiN5gpPJiNaIoDr9fD1AGnAaOA3rAMt4GD4c/AuwEDqpUSk7k/pMli+d7veCll//GSy+/
zuzZ0znz9adoNFEe7To7LRgKSygoLCVPX4TRWEa3tWe4mRO4AZwDPun/e9UP/h4xuJvJgHVAAqD0YLsT
4Me7snxqPMDRnJMA7N3zxKiNB4iKimTjfevYeN86AGw2OyWmCgoKS8jXF2EoLKWlpU0AtMD2/gNcccYd
Q84DFbjii89w94DZwHvAWm8XvPHan3j0R9leHVsst5g2KwWHw4HpQi6zZ0/3h9cINDY1Yygwkm8wYigw
UmqqxOl0jrgtUMBtQfIA6538CkA0rmctTqUMY03yYlSqsBGGX58swtrTx9FD75G+LsUr4ROn8ti+80km
TZpITdU5BMGfp807Wlvb0ReUoDcUYygwUmKqwGazDzfrAXKAl4AiT37kwB+BuBnxsfzrwxeJj5s8wshm
sxO/8CEA4uOn+kTQUGAEYHXysoA3HkCn07J1ywa2btkAgLWnB6OxnDx9EQWFJegLSujstIQDWcA24DfA
n4f7kfcb8PvfPuGx8QANja2IopOQkBCm3hPrE8F8g0uAlOTlfjduLFCGh5O6ZiWpa1YCIIoiRcYy/vLK
AY7mnAwBXgaagfcHXycDpgDMmxM3qvOrDS0AxE6ehEIR6pWM3e6gqMgEBE+A4ZDJZCStXMon/3idvXue
cP/7VUA1xK7/QCaTjeqs3nwdgOnTfev+prJKurqtqJThJCYs9Jt8oPHi737FlNgYgChcgTHefW70Vg+C
ub8HxMf5+PwbSgBYsSLBpx4jNRSKUJYvW+z+mggUA4vBRwHcj8B0HwOgfiAAfjfd3xOamlxtmDJ5IoAO
+BxQ+9gDmgGIi7vHp5sNjAApd4cA3dYeyiqqAHjz1eeYHDMBYCbwS78EiPdBgJqaepqutyCTyUhelThW
zgFFUZGJvj4bmugIklYsYN/uH7hPPeRVALvDQVNTOwDTfYgB+YZiABYtnEtUVOSYSQcS7iF51Yr5yGQC
q5MGAvNcrwI0NrZhdzgQBIGp07zPAe627g+3OSWtWACAWj2w1InwKoC7+0+O0REeNnKKPBxute+WACiK
IoX9c5LklQtGnB+SdLh4qY7Pv8zn4qU6urpdy9Hrza7ub7X2sDXrp3e8mc1m53J1DQAH3vmYDz/69/hb
ME7cutVNZ6cFmUzGyTNGoqPUKJVDf0gn4Ny8KcUpCIK/mZ7/uUMQBOcDmatvf+//AIAgCGxYn0pGespd
E8AChY4OC2fOGjhxKm/IMnpAAJVKycd/f40N61O/K45BwfGT59n16DMDGacQ4EVwzZcf+eH2O1z6/4FZ
M+ORh4Zy6nQ+MGgq7E5HBQN2ex9tLWbqa8qorymjrcWM3d4XtPtnbkwf+DwwCoSHex/ixgNRdFD5n7NU
mM5Q+40Jm713yPlQeRgzvreURUszWLR0HYLg0yR1TBjc1qDk3uuumMj94k1artfdvrE8FJU6GoCurpvY
7L1UVxVSXVVI/plPydy6m/hZSyTnJrkAhecPcTznbURRRBGmZEXyFhYsSWPK1DkDqTKn08m1hstUleVR
XHCU5qZaPnrnBe7b/CRJqTsk5SepAIZzn3H8y7cBWLhkHZnbdqOKiB5h55pmz2PqtHmkrM0m5/B+qsrP
c+zIAZxOJ8lpWZJxlOxBu1JdzMnc9wBIzXiIrEd+7bHxw6GO0LBz1wukZjwIwImcd6n5pkQqmtII4LDb
yT28H1F0sDhxPRkbH/MrMywIAhkbH2fR0nRE0UHu4f04HA4pqEojQGnxV9xoa0SpiuL+bU+PKS0uCAL3
b9+DUhVJe2sDpuJjEjCVSIDy0tMAJKftIEypHrOfcGUESWtcQbDcdDoAzEYi4AJ0d3XSUO9KPy1c4nWn
zSsWLnX5uFpbibU74JvDgRegvf0aouhAHaFBq/MtiXonTNRNQxURjSg6aG+7FgCGQxFwAbo6XPmDiCht
wHxGRk4EwNLZFjCfbgQ+Bsj6JzcjCx7GDFF0jQB32rwZKwLuMVoTA0DHzRZP29d+w+kU6bjpSstFR8eM
299wBFwArW4qcrmC3p4uGhuqx+2vwXyJvl4rofIwtDHjjynDEXABFIpwZsxOAKCqPG/c/i6WnQdg5pxE
QuWBX7FKMg9YnLgegJILudj6RtT6+Izeni5KLnw1xGegIYkACxPSidbEYO22YLyQO2Y/RYYv6evtRqON
Zf7itAAyvA1JBJDJZCSluWZwBec+w2EfUbriFXa7jaL8zwFIScuWZAQACVeDy1dlEq6MoLOjlcqys35f
X156CoulDZU6iqUrvy8BQxckEyBUEc6K5M0A6M8e9GtIdDpF9GddmyorV28jNFS6dJ10iTcgKXUHofIw
mptquXLZY5GWR1yqNNDWYkahCGdlygMSMpRYAHWEhoTlriou/bnPfL7OcM716ycmZaJSj15gGQhIKgBA
8tpsBEFG3RUTls5Wr/YdN5u5WnfRVV8gcT4QgiCAVncPGq2r/K6l2ezVvrW5HgCNdsrAtFpKSC4AgCLM
tR9v6Wz3amvvry5XKMIl5eRGUARwL2dP5byL1do5qp3V2sm5Ux8DEBbmqV478AjKxsgti+uXv3XrBq/8
YRdTps1l1pxlxEyZCU4nzU3fUlNdwrWG6oFldG/v2KfQ/iAoAgyeA4hOkQZzFQ3mKo+27u1qdw5AagTl
EQiVKwDYnLWXZasyiYzWIQuRgyCAICALkRMVrWNZUiabs/YOuUZqBKUHaCbGctVcRbHhCJnbdrMle69H
O3NtBTmH9wOgnRT4tb8nBKUHpN37MGFKNdcba/jgref5+siBETbHjh7gg7eep7npW8KUatLufTgY1IIj
gG5SPE/te4NFCa59+Qv6Lyg8fwi73YbdbqMg7xAX8lwrv0UJ6Ty17w0m6qYFg9rtEpky4zFmzhi9ZD5Q
OHLwr5T27/K4l7juN8aWrdrElux9knP4ttbMkuUbgSDFgMHYsnMfusnx6M8epOvWTcC1ZliT/qDkW+Ge
IAfsgFyqzcfhEASBlLXZJKftoONGf7Z3QoykFSHDMaitdhlQD1BqqgwaAQBBkKHRxqLRxga18QDGknL3
x7oQIA5YU1JaQdb2TURGRgSVTLDRcK2Jn/3ieTo6LQBvu19GNAHTdDotzzz9OBnpKWgnaL5TooFG+42b
nDqt57X979PWdgNcPX+gnn8ecJG7oJQ1SMdFYO5wkZTAHlwvSN+4C0gG+mgHzgBPM+jV4P8CMZNSfiX/
tJIAAAAASUVORK5CYII='
  if (2 == (global 'scale')) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method microblocksFolderIcon MicroBlocksFilePickerIcons {
  data = '
iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAO
xAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAATzSURBVFiF7ZVp
UJR1HMc/z+6yz+6zF4cJBMi1qKCZY2jkoEaOEZPUlJpmM9aMY3lMGjKMTo40luabNB0dKdNCO7RBlDCm
GFPHMR08aShEUpM0jgWVZTn2fHZ74Swpl+DBq74zz4v/7/h+v//zgQeDJIqq7CCTsUqnk6yBJtOOB+Qb
EFJ1ktT4YsZzbUX7vvANGRJsVyqV8xUKxeKgoMCikJDA6uDgwAqTSb+oLxIVIEmSZpWoDnjW5/Oq/AkB
hexyuU60250fAbYufWkGnXRwd/4m3bSpk9iy7SvZarU1azTi+imTU6RXX07XxcfHsDznQ9dfV68/0ZcB
wWTQ75+YMipj3tx0jUqp6EzIspd9Rccch46cLWtpbU+7oydQkrQ1hXs/M01KnYDd4SDGPNHRYXeI+Ts2
MOOVDAGgoLDEt3T5BzWtre1JgKNXAwEqpbO6/Bu1TtJ0S3pkmZhRc9xut2cp4AUQRXHG7JnT07ZtWRsA
sOf7YhYsWkFG+rPOgj15IoDX6yUhaYrT0nhjM3ClC20r8BtQBaBye+QexQFUSiW5K94ULlys2eSPHTp6
Xv3OgjcE//jbvQcQBIHZszJFf6zsVDmCgPr1mVOXdeW02tpcZWcuKGTZe8Rma58lAD7LlQO9rdBdqLfc
ZNpLOVz98yQAHXYH8SNTCVApOVy6lwRzLAA5K9dh0nvJWjKrRx6n083i5Rvtx05UfK3osaIXXK2pJ8Ec
0zn+5fCvmOMicLk9xMdFA7eXv6i4lMyMib3yiGIA63IXaGVZfk3Va1UPsDQ283h4aOe4YN9BRpgjCQjQ
oFDcnsup0+UEBxkwx0X0yRUWGkxHhzNQAHzr17zNwZ/KqK1r6rPJ4XDhkb0YDXq8Xi83b1nR6zS4XB5M
JiMAttY2lAoBrVbslScy4jEyM1JYmbsdlSiq+aHkNKvfz2LYsL5dPyxcu1bLmrWfolarEbQaja/ifCnh
YUMHRdyPunoLTya/gAD42m5VDaq4H/rgRAZ0Cx4FHpqBJsvfHPpxOw11XR++h2SgxdrIrs9zKPxuPbLH
0y1fUriZUyeKKC7Y+GgMXKw8yfWaSqp+P05DQ/dZRsYkARAVnTQgA/0+hLaWGxQXbMBgDGH6jCyUSmW3
GntHK1rJ0G9xfXDi/d+Cy9VnsbX893AljByPwThkQBz64ETu+RT7fF4EQdEtduTnL2lqvIZSoUKW3YQv
2dzNQE+9XdFntvZ6NTu3LsPabLkrLggK3lr4CWHhZrxeD6lpcwiPMN9VY73VwM6ty6i9Xn3/BiKiRjA2
+Xny87I5d6oEWZY7c2pRYva81SiUKiZNndsZl2WZc2Ul5OdlMzY5nYioEX0auOcWJD+TSVTMKI6W7qLs
+H5GjZmCOXECoaExeH0+tBoDssdNneUSl6tOU1lxjJAhkcydv5ahYbH3oh/YIayvvUx15QnKT5fidNvB
B7LHRYBai1YyMnzkeMY8Na3bdvSGfh3COxEeYSY8wozT5cBoDGFYzGgO7t/MwvfyyM/LJmnM5H6L+zEg
A35Ex47maOluLlWfweN28vGqTAAknXHAXPdlIM48jibLNULDY4mKTkIrDVzYj/9/xwq1Wu1oaWkddGGr
1YYoqu1Kg0GXWPFH1fCUp8epjEb9oIj/U9vAu1m59vo6SyGApNfr83Q6qRnwDcan00nNer20DZD+BcCd
6BrJe+ugAAAAAElFTkSuQmCC'
  dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAd
dwAAHXcBjssJwQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAApjSURBVHic7Zt5
UFRHHsc/czEwwyGHQUBAbhFFDQp4RAkqRvGOS9bd7K6blKkk5jDZuFWpraTiZrOpbBI3G42blNlkc7tK
RaKJ4MElQfDgUhQJcQWMJoRLBIYZBubtHw8GpmbA4ZhBs/lWddXr1/3r/v5+r/v1ry+4NeAPPAmkAzVA
M1AITBlLUvZAFLAH6AYEC+EBWxOQ27qCAaAE/gpsAaQAM2dEsWrFEvK+PkVWzgkALVDUk98VmAfMBnwA
T6ANuAYcBXLtyn6ECAWK6fnKSYsXCNlH/yO0NVUIJ3L3C3K5rPfrP4So8KeADsstpDesHC6Z/i1ACiwA
ogGnm8jpgUvAEaBjCPVNATKBCa6uLuz4+zbuXbvMmPj0H1+kq6ubnjzhwNuABGCC93jmxMcQ4O+Lp6c7
1dVXeO+Dvf3LPTgEHmYIBY4zuJUthf8Cd1tZhzdQDQhhoUFCeclRoa2pwhjSUnf3L/e73ufVK5OEY+mf
mORt+uGsEBc7szdvBaAeruJywA3IAvxVTkrmxk1FpVIOKqTXd3OmpJL6hutBwGEgFigdREQCvA8E+k/0
If3gB0zwHm+S4eVX3uof9VOrVex68y8mLaQXr7+xm5OnSkD8D6QA7YOrOTixncDmSQET2PfhCwT4e1sl
2NbewUOPv0ZmbjHAGcT+OhDuBz5SyOVkHdnDzBlRJollZyuYl7DOGJdKpaSl7iYxYa5ZQdU13xETl4yu
sxNgE/CuVYQHgBRYA7DtT7+3WnkAZ7UT21/ejFQqAZiFOJZbghzYBrDliQfNlAd4/8N9JvGNv1lvUXmA
7W/s7lW+APiX1YQHgARxDJYWZu0iKNBnyAVExW6kobEFxL6osZBlHBDi5uZCRVkmrq4uJomaDi2hkQu4
caPV+K7k1CHCQoPMCmpsbCY8KqHXAFXADStpNiIOqfuB0/0T5PSMw1Kp1MqyTJGUOItP92UCRA6WL2X9
CjPlATKz8k2UDwsNsqg8wJfpWb3KA4QNlSrwLOLItQmohVFwhF576VGSFs1Gr+82SzMYBJ56dicajZa1
q5ZalE/PyDaJz4m7c8C60r44DMDypHjWrrzLao51PzbxdcE5jmadodtgSEJsDXcD5SM2gEwmZdmSOItp
F7+pRaPR4qhUEhs7wyzdYDBw+KipE2cpH0Braxu5eYUAbNm8nulTQ4bEc9PGFVRW1bLp8deprKr1Ag4A
04bX7q3EpcvXAAgODsBRaT60FpeWU/djAzJZH4242ZYNkJmdT2enHh9vT6KjgofFJyIsgM8/+TPed7gD
BAGP2cUAoSGBFtMzDucA4OvjBYCDg2LA/n+op6ssSZyFRCIZNicvTzeefGR9bzTFpga4XC0aICTYsgG+
SheVCp4kjj7BQQHI5TKzfJ2detJ7jJW0aDB3wzrMiTXOssNtaoD6husA+PqY+xc1tVc5V34RiURC8CRf
ACLCLffrjCO5NDe3MG6cMwnzp4+Yl1ptnOo429QALTdED9XNzdUs7ZPP0gCYOT0MXaceGLir7Nn7BQBr
kuejUIzuDF6COKHgVM7baDRaDhw6QUVlDe0a7YgLP1NSiUajZdrUyXh5uhvfC0BhYTFanY7wkIk0NLXQ
1NxKeFgQfr4TTMrQ67s4UViEwWBgRnQori7Dm/eoVY5ERgSyOnkeTk5KYhMeNuEjLE+KEyQSyVBng7dd
kEgkQvI9c/riPQ8ASCQSFifOZ+GCOIte2+2MlpZWco8XkpmdjyAYVe7rAiqVE3s+3jngJOSngszsfDbc
/xiaDrGLy4AXALY9/zS/TFk1htTsg+CgABQOit51R4yjwJJF1vvWtzuWLllofDYawNFx8FWgnxL662pT
P+B2wM8GGGsCY41b1gDtbddpvdFo83rGamtsQHR3dZG291UqzuUBEDZ5Nus2PIvCwdEm9dmkBQiCQHlp
Nqkfv8Sh/TtobvzeatnTBQeMygNUXTxNfs7eQSRGBpu0gJNf7+fYob7l+gvn8nj4qbdxdvG4qey1K99Y
eFc5qvz6wyYtoOjkVyZxbUcb588et0rW29d8TcDSu9GCTQwgkZgXa+0iVuz8VYRN7lv1CQyO5q7EDaPE
zBw26QJx89eQnta316d2HkfU9ASrZBVyJff9bhvNTd8jGATcPX1GtAZ4M9jEADFxybi4elJ5vgCV2o3Y
eatQO48bUhnuHkPfpRoObDYMhkfGEx4Zb6viRw129QMMBgMHU7fT8GMtAJ06LQaDuKPU3a1Hr+9kxqwk
Fi2z+dEgI+xqAK2mlfNlORgMhgHzfH+1yo6MRmEU0GmtP5ugcnZj9X1bkcks212uUHLP6kdsUvdAGJEB
rlSf582/baT0zBGrZaKiF5Ly2+cturZLVmzCa3yAVeWcLc7kzVc2Uv1tmdV1W8KIDHCm8Et0He189fk/
yD78/qBNuz9CwmfxqwdeQunYt8Q9OWouMbHLbyrb3d1NZvp7HEzdjk7bTsmZjGHzhxEaYHXKM8TEJSMI
Avk5+/jwna3U19VaJesfGMmKdU+KEYmU5HVP3FSmvq6Gj97ZSsHxVARBICY+mdUpz4xEhZH9BKVSGcvW
bMbPP4KMA7v4rraCd3dsJiZ+JXMXrr+p7+/sIm6WODqqcVKZ7x71oq21ifzcfRQVHMRgMKBwcGT5mseY
NjNxJPSBURoFomMWMzFwCocP/JNLVUWcyk+j+OQhps1MZHrMYvwCIi16c/ou8bSHo5P5bo8gCFytraCs
6BjnSjLp6urZPouYzdKVD+PuOTqO0qgNgx5evmx44EUqLxSQl/UZP1z9lpLTGZSczsBt3Hgmhc4gMCga
rzsC8Brvh4NShb5TXJuXyx3QadtpbLhKfV0NtZfLqb5USsv1emP5Pn6h3LXo14RHWj6MMVwYN0bOFR8h
aNJAB72GjktVRZSdPkpVxUn0XTqzdJlMhlSuQK/TYrI91Q8KuZKwKXFMn7WEkLCYUeN2ufoK0+5MAmzo
CIWExRASFkOnTsPlb8vIyxZbhVQmw9DdTXdPgD7llU5qFDIFmo5WIqbMYeW9W3BQqmxFEbCDJ+igVBER
NQcksO+jF1Gr3dn0xE50unaKT2ZQcHwf/pOi+MX9z6FSu/Jl6huUFh3Bw9PX5sqDHV3hgElTkUiktN5o
QKdrx93DB7Wz+OeXy+XodO3odO10aMUjczK5wi687GYAJ5ULXnf4U19Xw9miY6idx3HxXD4AV6ov8Nar
D5rkl8l+YgYACAiaSn1dDXlZn5m8l8kUSJAaf5ZyuQI//wi7cLKrASKi5lJyKgO5wgGfieH4TQzH1z+C
sIhYZPKxWaG3a63BoTP5w3N7cFA6WVw3HAvY3ez9J0C3Am6NzzCG+NkAY01grCEFugCjW/r/gH66dknp
uThQWnZhzAjZG8Ul5b2PNTLEuz5zS0rPs3b1UlxcnMeOmR1w9doPPPjQVlrEWyrvSgAPoAyY6OXlweOP
biRhYTwe7kPbybnV0dR8neycAnbs+jeNjc0gtnzj5YQIxEtPY36U1U6hAvFmqgmcgM2IN0ibbwGSox2a
EC9ZP0q/q8H/Awj8JV/kA4nHAAAAAElFTkSuQmCC'
  if (2 == (global 'scale')) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method homeIcon MicroBlocksFilePickerIcons {
	// TODO
	return (desktopIcon this)
}

method cloudIcon MicroBlocksFilePickerIcons {
  data = '
iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAO
xAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAOYSURBVFiF5ZZd
TFt1GMZ/PS0Helo6vloKCwy2bGYBMhiZY2qMuCyKF5sxc2HLYuRiF5vJoviVOJOp08R4gXrhxJiI2xKj
c1MSG0Ky2EwNFhRGAAljDhWktNRBW1oobTnneLEwXaB0K7Re+CTn6nmT5/c/73ve84f/uzSAXpIyTqSL
aQ+pqpL2jyHIkUikYzYUPgXMJA1gXabx4n01ZXVPHXpEr9MKtwxZVrjQ+t38JXt3pz8wW5s0gDSdNjzU
c1bMNEpLzAVZpqSsPhqNLhwHlDXKDAC9wFW42QLV9etXCIJm2eqPPvlmYWh4VF6jcHwzwUjXz0PCgizb
Z2Zmn4wLkAyFw1GOPtsU+t7Rf+4/AQCYcE9x/55nfEL80uTIaslhbi6cpQP49LN2bO2djDv/Skn4+kIz
e+tqANCJokirrYuTrzZSVFSYEoCxMSdvvPUeopiGRq/PUPu62yksyE9J+KLGnW6q7q27+RnO3BhEEFI7
DoqiYMorQ3cnxd4pF309l/C4f0cjCJgtG9hWvYfs3IJVg8Q9dsflL2lpbkSWF6jc8SgVVbtRFJmW5kY6
Lp9HVVUAZoM+XM7rBIPeuwJYsQXdDhtXfmrjYMMpMk25t3nBwDSfn3mNDaUVuF2/MTkxQnaOFZ/XQ56l
iLp9x7BYS2MGL7YgJkBoLsCHTUdoOPpuzFftm3ZzpvlFHthdT9WOOgRBQFFkBnrt2NtbONTwJvmFGxMD
GOi1MzzoYP/hEzFPsZIGeu30OGw8faxpRYCYM+CddmGxliQUDlBeWYvP58HvW3m5xR5CFSKRUMIAGo2G
9cX30PrFOzj/HL47gD+u93Glq40tW2sSBgB44uArVO98jPNnX2d0pO/OABRFxvb1+zxe/xLFpeWrAtBq
tZRX1rL3wPO0tX6Aoiy90ywBcE+MkJ4uUbJp26rC/61Nm6sRtAI3PGPxAYIBL+uyzGsWvqis7PxlB3IJ
QE5uAZ7JUVR1ra6AoKoKHvcoObnW+AB5lmKMxmx6OtvWDKDbYcOUZSbXXLTEW/ZntO/AC5z7+GWmpyao
qHqYDL0hoeD50Cz9vd9ybfBHDh95e9mamJtwLujH8cNFRq71EI3MJwQgpuvZuHk7ux7cj2Qw3ebFXcXJ
1q1VLIrivN8fSGk4gN8fIF0UQ9rMTMPW/l+ubtm1c7vOZDKmJHzc6eb4cydDLtfkBQDJaJROGwySF1BT
8RgMktdolE4D0t+OiolPtJLckwAAAABJRU5ErkJggg=='
  dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAd
eQAAHXkBKkJFPwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAgWSURBVHic7Zt7
UFTXHcc/yy6PhV1Y2JWXvGR5iNHEt4ACChofadQYZlrzmIitnVGTNHWmnWb8I9Z0Op3ptM4kNWlNUzFj
HtY0CVMVcQL4YIMRH4CIokEFxBVldwFBXvvoHytbGmm9d19g8TNzZ87de37n9zvfPfecs+echcc85jHj
GcmwtC+wAngKCHyIXT/QCBQBnZ4JzbtMA84CNpGXHlg5CvG6DQmgAc4DkSEhCvJyZhIUGPA/jcxmC7pv
62huaQOwAFlApaeD9QQSYBewITkphi/2vk34BJUgw/7+QTZt2cGBw5UAF4CpngvTc0iwN+PIvR9sZUnu
bFHGBmMX09ILsFisAFrgqvtD9CwyIAJAmzhRtLE6LJhQlZJ2QyfAceyd41jDCrQDp4EvgbLhD2XcHwkk
kgcMBfHcDxbwwZ6DAOIV9B5JQDrwKva+qgBoAHvlbQAny95jUnyU6JJtNhuVp+oxm81ui9bd6NuMnPim
lqKDOgYGBsE+dC8BqlwW4FGiqaWNDa/+npq6RoBWYIrPKMfkVeJjI/j7R9uIjtKA/ZV9fVwJAKAKUfDG
pvyh2/xxJwDAnJmpQ8mkcSmAXO4/lAwalwIMRzb85mz1ZYoO6Wi40oLR2DVaMXmEsLBgJqfEsWrFfFQq
xX88swG23JwZYn8JPrJXXs5MR9oxDwCQSqU8+8xiFmbPQ60OdULnsYvBYKL82EkOHCrFYrE4PncIoFQq
+PzT95mfKe4H0aNGha6K/LUb6e7uAUAKbAPY/tYW8tesGMXQvENc3ET8/HwpLdcB4BgFchdmjlpQ3mZx
7gJH2iFAgL//iJn/Hxle18fzAHcXaLFYaLpWS3tbE3e7jFgsZuSBSiKiEolPmIq/PMjdLl3CbQLc7TJQ
UfYZdbVH6e/tGdmZzJeUtAyy8tYyISLeXa5dwi0CVOmKKCspZHDQviIWIFcQG5+GQqlGKvOlp7uD1uaL
dHW2U3/+OBfrKsjIfp6cxS8jlbm9EYrCJe82m5Xir3Zy9lQxAJHRWnKWvExi8iykUun38tq40VRPRdln
NF45wzfH9tOmv0b+S1vx9f13p2Rsb6W56QJ3OwzYsBEcomFibKrHWoxjIlR7uoTExDhRxkeP7KGifB8S
iYSsvBfIyl2LRPLwfrX2zNcc+updzOZBUqdm8vzaN7l0QceJ0k+509Y0ok2YJpr5C3/ItBm5+PhIR8wj
lKtXm3ly9lLABQG+a6hi355t2Gw2lq/azKz0Z0QF0XjlDPsK38JqtRKqjsJk0APg4yMlKjqJUE0UIKHD
dIubLQ1YrVYAYhOeIP/FrQQphO1fjMRwAZx6BaxWC6XFH2Kz2ZgxZ6noygNok2eRs+QVykt2YzLokcl8
mZO5ivSsNQ9Urq+3m1O6Ik6e+Act1y+w+/0tFGz8o0siDOHUPODKpVPcaWvGzz+QRU+vc9p5etYaomNS
UCrVvLThd+QtXz9ipQLkCrIXv8i6jX8gOERDh/EW+/f+BqvVMkKp4nBKgMv1JwGYNn0RgYoQp51LpVIK
Nu3gtV8VEhOX9tD84ZGT+NG6X+PnF8CNpnpqz5U67XsIpwS43lgNQHLaPJcDkEgkojq18MhJpGfbFzV1
5ftc9i9aAJvNyt0uAwBqzehsBs3NXIlUKsVk0HP71jWXyhItQF9vj6NHDgwMdsm5swTIFUTHTgagteWy
S2WJFiBAHoRM5gtAd4/JJeeuoAqNAOBE6cdUHv+cQbNz+7KiBTC2tyK5/852mm475dQdJKfNRSqT0dXZ
Tmnx39i1YxO3Wr8TXY4oAVpbGvhw588ZHOgjSKFCEy5u5uhOpkzL5o03P2bZyo0oFKGYjHr27PolLU0X
RZUjWIDee1188clvGei/x8TYVH7y2jsEh2hEB+5O5IFKZmc8y4af7SQmfgqDA33s37udnu4OwWUIFqC8
ZA+dHXdQhUawtuBtlMGjW/nhBClUvFCwHbUmhnvdnZQfLhRsK0iA/t4e6qrLAVi+ejMBcsVDLLyPn38g
y1dvBuB8TZngViBIgIb6SgYG+lBrYkhMnuV8lB4mQfsUmvA4LGYzjQ2nBdkIEsBoaAUgbtITSJw9S+Ml
ErRPAqC/KWxEECRAx/3hLjgk3MmwvIdCqQbgXrewA6yCBPDzsx+cNJv7nAzLe/T32dcjhfZTggQIVtm/
+Ta9a/Nub3D71nUAglUTBOUXJIA2xd7xXW+sETXGepue7g6artYAoE2eKchGkACR0VrCIxMwmwc5euQj
5yP0MOUlhZjNg4RHTiIiWivIRpAAEomE3GUFAJyrOsyZU4ecj9JDnDl5kOrTRwDIW7Fe8GgleCaYlDqH
9Kw1ABR/+SdKDvzlv26AeJP+3h5K/vlniot2ApCRnY9WxFxF1KJo7rICLFYLVboiqnRF1J79mpTJ84iO
SSFIqUKCd+YINmz03O3g5o3LXL70reOLmLtgNYuWviKqLKeWxS/VVVB6eLdjKXu0CVVHsXjZj0mdKmyL
3+Vl8clTF5CclsH1xnNcuVRFh1Hv9dEhSKEiVB1N0uQ5JCROf2AnSihOb41JpVK0KbPRpjzaR2rG/fkA
H8AMYLaM3ePu7mZYXc0+QDNAdU39qAXkbc6eqxtKNkmBWCCzuqae51YtRakce4sd7uSmvo31P/0FXV3d
AH+VAGFADRCj0YTx+uYCFuVkoFKNzpq/pzCZOik/Vsm77xXS3m4Ee8ufPvQ8FbjIGDjG6qXrIpDyfZHk
wGbs//4yjYEg3X2ZgGPApvt1BeBfy0VRnxa1jVQAAAAASUVORK5CYII='
  if (2 == (global 'scale')) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method newLibraryIcon MicroBlocksFilePickerIcons {
  data = '
iVBORw0KGgoAAAANSUhEUgAAACMAAAAjCAYAAAAe2bNZAAAACXBIWXMAABAnAAAQJwFR8a7xAAAAGXRF
WHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAABARJREFUWIXtln1M1HUcx1+/33G/23HccccB
hxhNRQWEIsAHkIcawpKHHMLWTMyNJms92dbc2lrTVZabNKgtWy6NRsBWUDFK0B0+jFQEhbDSMhggIHIc
wREQcncd/dFqIx68g2Ot5fvv9/v7ee37+T584J7u6T8sYYG5VGAb0Ouk3wzUAP3uhslUKKRqL5UnGenJ
VmcCHZ3d9qbLV7FabQ8Dze6CyZEkeUVm+hbh2vU2mi997XSw8N1jjoLCo42jo2Ob5/KILoDskuTyinfe
PiDsydvhQuxPpSQniHa7bd18HmdhdiokqaSkuEjYvSvHZRAAURSYmpq/Ex5OrPOoJMlLS4qLhIy0ZAAc
jilkMpHqykLM/V2zhmQeEnEJ2YREzNkVl2HCFArFicLDr/4NAnDSeBZJtPB9yxlSMvag0ehnBEcsAxhr
j7kPRq32anA4HLK6Mxcw1tWDINBvMtPR0U1Z8VsErwrCP2DlrNmB/i4u1lc6DXJXmMnJSXn+U09gMPjR
2d7K0GAv8evXUHDwaaJikmhpquWH1nOzZsfHLKjVM3dswTCiKNqfzM0mIjyEyYlxvr1ykvYbV/jpu9ME
BCynvq6MlasfQj1Lm9QaPbGJrh12Zw4wAAqlitjEHDRaP2qrjlB2/BVkMg+StuSi0y9zqeiiYQD6ettQ
KjXk7z2CxtsX0+0OLMMmLMOmaT6tzrAgQKdhmhtP8E1dOYIoQ+tj4IGoZM6e+hiVSodckqZ5h4ZuszPv
IMuDQpYGZqCvk+hN6awIjuRyw1d0treyak00W7c9g9JTM81bUfoG/X3tSweDKGCzTeIfsILtO15GFEXs
dit2m5U7E2PTrL/b7YiizCUQl2DCIhKoLHuThvpKojemkb79BY6/9yJm080ZXq3OQFrWc0sHsyI4kn37
P6PxQhVN57/k8/JDjAybyHu2yOV2LBrmL4VFJCCXKwAIXhuDYdnsL/CSwvxi7uFU9QdMTIwSGZPK+rjH
qPq0YN6ZRuWlIzUzH73vfe6FaWmsxdNLi843EGPNh5wzfsLknd/IyNmLt7f/rJmrzUZaGmtJzch3L4zd
ZsVHH8jmRx4nNjEbAEEQ0eoMc2Z6uq4xPjrsbAnnYby89dy43sDY6BCrQzewNiyWpvNVDJp75sz03Woj
ZF2c+2E2xWehUCj5+cdGmi/VoNb4crG+cs6PEuDBqGSiNmx1P4ykULIxPguN1o/TNR/xRfkh5JKCpJRc
dD7/wkcJEBoeT2h4vFuK/1PzDuSSJA129/S5pdDN7ltIkmSezzPvtC6K4vM+PtrDr+1/SXl/UOCiQA68
XjgxPDyyz+FwvL8gGACZTLZbrfLMnxKY+w7fRcIUJsuvo0eB0oWu8f/WH7ozRDZHhK3AAAAAAElFTkSu
QmCC'
  dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAAEYAAABGCAYAAABxLuKEAAAACXBIWXMAACBPAAAgTwGUeoKrAAAAGXRF
WHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAB5VJREFUeJztm3tQVNcdxz/7ZnnKsiQR5BUQ
8E2DIHRxGpqIM9YncWItNkkfSaetzcTO9DE600mnqWmn04yjZVKShvThq63PQEwNtlYJIQqiiEp9hAjy
Mi5WFlAeu3v7x7qruPLYu/de6bifmZ3Zezj39/3tl91zzu/ceyFAgAABAgQIECBAgAAPMSoFtbRAnUql
ShMEoR9wSBy/H7gA7ARKgUGJ48uCEbgICAq9aoHJ/iSsxDcmEqgH4twNuTlPsP4nayUV6e8f4GjlMd4u
3UF//wC4zMkF7GLiyW1MPK4Eo/U6HbNnTaO27jRLFz/N9j9vkUXweG09i5Y8T//AAMALwJ/ExFFLmdQ9
JAIngeiQkGD+ur2YggXzZZRzkT13Dl9fU+g+XC42jlzGpAGnAJPZbOJg+V9Y8JT8prh5ImOm+22C2Bha
aVIZRjpQDUQ8Eh1F2d5SZkxPlUFmZHQ6z8fSiY0htTHTgU+AsNiYxyjfV8rUlCSJJZRBSmPigaNAWHxc
DO/v/yNJiXFjnTNhkcoYM1AFRJnNJvbv/sOYpnS2f0pjQyWCIPgsptXpSU6dS2xcmrhsx6MhQYwQXKZM
CQ8P473d74z48xkcHHKJanV8WF5Cy2dnRItW/nMHzxStJ33GF0XHGA0pjCkDUg0GA3/bVszsWekjdjxe
Ww+ArauRzjYjAJNjU5hk8m2ReuN6Bx1tl6ipLpuwxmwB8gFKijeSZ8kaseP2nfs5WnkMgFjzIIODrrWl
JX8V6TMsPomerT/C3p2/ps/2X5Fpj40/xqy9/SLPkkVUVCSHj1R7dbp2rYsPDv6bXXsOAFDw5Uy+9Z0i
AIJDwkmbnutHCvLhjzEb3G8+qqrho6qaMU9Yuvhp3nnrNxiDgvyQVQZ/jOkGHgsONqLX31lHCU4nAwM3
ATAEhRBliiA97XHWrC5k6ZKFwwLYuq04HEM+C/fYugBQazTisx8Df4wZAtj8xqt89dmlnka7fZBNG9fQ
f6v3rq5XaKz5PXm5szCZYwCoKH+LY1X7/JBH1ula8lpJq9WzfNWPCA0zDWsfGhrAeu2K57izo0m0hkql
IiF5Dk8WPCc6xljIUSuRkpbFK+u3er41JZu+R4/NSmvzORx218ZaX+8NAPIXvkDmvEU+xVdrtOj18o5T
shjjJsgYCoBa7ZqaPz7yd68+ep3B028iIasxbr6QvYjTdRUIzuHLf2NwGMlpc5VIwWcUMSYvfxV5+auU
kJIMWYxx2O3U11VwtaMJwekEIDJqMjnzC1GpXON9e+sFTtcdwukY38UCQ1AIqdNziUuYJkfKXshizJ6d
r3P+rPcqOC5xBlPiXR+s4v23uXL5rE9xP6ncw8o1GxRZLUtujK3b6jFlTuYCNBotp+sOYbcPsWvrL9Hp
DAD02KwAxCfNxBw99r7N552XaW1p5ER1+f+nMTf7ugHXWmPJynUAXG6q57q1nd6e6179sy3Lx1Uhnz5x
iNaWRvpux5cbRQbf1d/4BZ1tl7za9QYjj0/NVCIFn1HEmEjTZCJ93HN50EhujEZzJ2SXtRW12lXoBQWF
YgwO8/xNEJzYuq04neOblWy3C0eNjIXj3UhuTGRUDMbgcG7dtPHmb1+6I6TV8eLLvyPq9kB7sKyE2uoy
n+PHJkyXLNfRkKGI1FG4+qdMinx0WLvdPkSXtd1zfO1qs09x1Wo1U9Oz+dJTRZLkORayjDFJKRms/fG7
DPT3IQiCp4hsunjCMzO591TGW0RqdXq0Wr0c6d5fT87ghqAQwPXfBqitLvfq81AXkdmWZZw5ddirXWcw
kpKerUQKPqOIMfPyVjAvb4USUpIhizF2+yAnj/8D69UWBFxbDWERZixPPuuZvlubz9Fw8jCC4BSloVKp
iX40gYyshWi1oq/dj4gsxuza+hqXztd6tScmZ3iq40MflNLafM5vrU8v1LDq+Z/7HedeZCki3aZkZBag
1mg8ReTubeKLyHtxOhycOvEhF/9Tg63bSniEWboPgcxF5OKVrwDQ3NRAl7X1vkVkzvxCUqfliNKqr6tA
EARu9nVPfGPuR9G3N9LW0ujVbjSGk5A8W4kUfEYRY8IjzITPUu5WMymQoYi8M0O0tZ5HrXLNQmHhpmHX
mpxOB9bPr+BwiLrbFKdwp/i8W1MqJDfGFBVDSOgk+npv8G7xOk+7RqPhxZeLMT8SD8DB/W9y4vgBv/VC
QidhMsf6HedeJC8iNVotz3xtvaeKduNwOLje1eE5tlpb/dYyR8ezsmiDLFsRsowx8Ukz+e4PSzzHm3/1
HLbu+xeRBV95iew80bfjyoYig6/7ksn9ikiVWs57sMWjiDE5eStoOOW9/A8yhjL1YS4isyzLyLIsU0JK
Mibm93gC4I8xfQC9vX0SpSIdPT2enHpH6zca/hhzBqD8wL/8CCEP75VXuN82iI3hzwLACnyz6bMWlSAI
WHLnerYwHxQOh4PXXt/Cth37wPWk2/eBNjGx/H2QazPwA4DEhCnkWbLQ66Rfno+HgcFBqj6u5XKzZ+G4
CVg3yimyogZexfWgplLPO471ugX8DD8nFqke/YsFVgCpgEGimL4yAJwH9gLtY/QNECBAgAfK/wB5A4H5
TI/+pAAAAABJRU5ErkJggg=
='
  if (2 == (global 'scale')) { data = dataRetina }
  return (readFrom (new 'PNGReader') (base64Decode data))
}
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Copyright 2019 John Maloney, Bernat Romagosa, and Jens MÃ¶nig

// MicroBlocksFinder.gp - Finds and helps graphically locate users of a
// particular block in a project, be it functions that call it or scripts that
// include it.

// Bernat Romagosa, July, 2022

to findBlockUsers aProject aBlock {
	finder = (initialize (new 'BlockFinder') aProject aBlock)
	find finder 'users'
	showResults finder 'users'
}

to findVarAccessors aProject aBlock {
	finder = (initialize (new 'BlockFinder') aProject aBlock)
	find finder 'accessors'
	showResults finder 'accessors'
}

to findVarModifiers aProject aBlock {
	finder = (initialize (new 'BlockFinder') aProject aBlock)
	find finder 'modifiers'
	showResults finder 'modifiers'
}

defineClass BlockFinder morph window frame project block functions scripts noEntriesTexts

method initialize BlockFinder aProject aBlock {
	project = aProject
	block = aBlock
	functions = (list)
	scripts = (list)

	noEntriesTexts = (dictionary)
	atPut noEntriesTexts 'users' 'This block is not being used in this project'
	atPut noEntriesTexts 'accessors' 'This variable is not being read anywhere in this project'
	atPut noEntriesTexts 'modifiers' 'This variable is not being modified anywhere in this project'

	return this
}

method functions BlockFinder { return functions }
method scripts BlockFinder { return scripts }

method varName BlockFinder { return (first (argList (expression block))) }

method allEntries BlockFinder {
	return (join functions scripts)
}

method find BlockFinder purpose {
	// look in block definitions
	for function (allFunctions project) {
		if (usedInFunction this function purpose) { add functions function }
	}
	// look in scripts
	for script (parts (morph (scriptEditor (scripter (smallRuntime))))) {
		// script is a 3 item array where the first two are its coordinates
		if (isClass (handler script) 'Block') {
			instance = (findInScript this script purpose)
			if (notNil instance) {
				add scripts (array script instance)
			}
		}
	}
}

method usedInFunction BlockFinder function purpose {
	if (purpose == 'users') {
		return (contains (allCalls function) (primName (expression block)))
	} (purpose == 'accessors') {
		for expression (allBlocks (cmdList function)) {
			if (and
				((primName expression) == 'v')
				((varName this) == (first (argList expression)))
			) {
				return true
			}
		}
		return false
	} (purpose == 'modifiers') {
		for expression (allBlocks (cmdList function)) {
			if (and
				(contains (array '=' '+=') (primName expression))
				((varName this) == (first (argList expression)))
			) {
				return true
			}
			
		}
		return false
	}
}

method findInScript BlockFinder script purpose {
	for child (allMorphs script) {
		if (isClass (handler child) 'Block') {
			if (or 
				(and (purpose == 'users')
					((primName (expression (handler child))) == (primName (expression block)))
				)
				(and (purpose == 'accessors')
					((primName (expression (handler child))) == 'v')
					((first (argList (expression (handler child)))) == (varName this))
				)
				(and (purpose == 'modifiers')
					(contains (array '=' '+=') (primName (expression (handler child))))
					((first (argList (expression (handler child)))) == (varName this))
				)
			) {
				return child
			}
		}
	}
	return nil
}

method menuTitleFor BlockFinder purpose {
	if (purpose == 'users') {
		return (join (localized 'Users of ') (primName (expression block)))
	} (purpose == 'accessors') {
		return (join (localized 'Accessors of ') (varName this))
	} (purpose == 'modifiers') {
		return (join (localized 'Modifiers of ') (varName this))
	}
}

method showResults BlockFinder purpose {
	page = (global 'page')
	count = ((count functions) + (count scripts))
	if (count == 0) {
		inform page (at noEntriesTexts purpose)
		return
	}

	menu = (menu (menuTitleFor this purpose) this)
	for entry functions {
		b = (blockForFunction entry)
		fixLayout b
		addItem menu (fullCostume (morph b)) (action 'jumpTo' this entry purpose)
	}
	if (notNil functions) { addLine menu }
	for entry scripts {
		// entries are 2-item arrays with topBlock and actual found block
		addItem menu (fullCostume (at entry 1) 600 200) (action 'jumpTo' this (at entry 2))
	}
	popUp menu page
}

method jumpTo BlockFinder entry purpose {
	scripter = (scripter (findProjectEditor))
	if (isClass entry 'Function') {
		showDefinition scripter (functionName entry)
		m = (findDefinitionOf scripter (functionName entry))
		entry = (findInScript this m purpose)
	}
	scrollIntoView (scriptsFrame scripter) (fullBounds entry) true
	repeat 6 { flash (handler entry) }
}
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Copyright 2019 John Maloney, Bernat Romagosa, and Jens MÃ¶nig

// MicroBlocksFlasher.gp - An interface to internal ESPTool to flash Espressif boards
// Bernat Romagosa, September 2019

defineClass MicroBlocksFlasher spinner boardName portName eraseFlag downloadFlag espTool socket fetchID downloadProgress

to newFlasher board serialPortName eraseFlashFlag downloadLatestFlag {
	return (initialize (new 'MicroBlocksFlasher') board serialPortName eraseFlashFlag downloadLatestFlag)
}

method initialize MicroBlocksFlasher board serialPortName eraseFlashFlag downloadLatestFlag {
	boardName = board
	portName = serialPortName
	eraseFlag = eraseFlashFlag
	downloadFlag = downloadLatestFlag
	spinner = (newSpinner (action 'espToolStatus' this) (action 'espToolDone' this))
	return this
}

method spinner MicroBlocksFlasher { return spinner }

method espToolStatus MicroBlocksFlasher {
	if (notNil espTool) { return (status espTool) }
}

method espToolDone MicroBlocksFlasher {
	return (or (isNil (task spinner)) (isTerminated (task spinner)))
}

method destroy MicroBlocksFlasher {
	destroy spinner
	enableAutoConnect (smallRuntime) (success espTool)
}

method startFlasher MicroBlocksFlasher serialPortID {
	espTool = (newESPTool)
	if (notNil serialPortID) {
		setPort espTool serialPortID
		ok = true
	} else {
		ok = (openPort espTool portName boardName)
	}
	if (not ok) {
		destroy this
		inform 'Could not open serial port'
		return
	}
	setTask spinner (launch
		(global 'page')
		(action 'installFirmware' espTool boardName eraseFlag downloadFlag))
}

// Downloading from URL

method installFromURL MicroBlocksFlasher serialPortID url {
	if ('Browser' == (platform)) {
		data = (downloadURLInBrowser this url)
	} else {
		data = (downloadURL this url)
	}
	if ((byteCount data) == 0) { return }

    if (and ('Browser' == (platform)) (isNil serialPortID)) {
        // must request a user gesture to open port in browser after long download
        ok = (confirm (global 'page') nil (join (localized 'Open port?')))
        if (not ok) { return }

		timeout = 20000 // ten seconds
        openSerialPort 'webserial' 115200
		start = (msecsSinceStart)
		while (and (not (isOpenSerialPort 1)) (((msecsSinceStart) - start) < timeout)) {
			// do UI cycles until serial port is opened or timeout
			doOneCycle (global 'page')
			waitMSecs 10 // refresh screen
		}

        if (isOpenSerialPort 1) { serialPortID = 1 }
    }

	espTool = (newESPTool)
	if (notNil serialPortID) {
		setPort espTool serialPortID
		ok = true
	} else {
		ok = (openPort espTool portName boardName)
	}
	if (not ok) {
		destroy this
		inform 'Could not open serial port'
		return
	}

	if (notNil (findSubstring 'databot2.0_' url)) { setAllInOneBinary espTool true }

    // install the downloaded firmware
	spinner = (newSpinner (action 'espToolStatus' this) (action 'espToolDone' this))
	setTask spinner (launch
		(global 'page')
		(action 'installFirmware' espTool url false false data))
	addPart (global 'page') spinner
}

// Support for downloading files from URLs

method downloadProgress MicroBlocksFlasher actionLabel {
	percent = 0
	if ('Browser' == (platform)) {
	    bytesExpected = (fetchBytesExpected fetchID)
	    if (bytesExpected > 0) {
	        percent = (round ((100 * (fetchBytesReceived fetchID)) / bytesExpected))
	    }
	} else {
		percent = downloadProgress
	}
	return (join (localized 'Downloading...') ' ' percent  '%')
}

method abortDownload MicroBlocksFlasher {
	if (notNil socket) {
		closeSocket socket
		socket = nil
	}
	downloadProgress = nil
}

method downloadCompleted MicroBlocksFlasher {
	return (isNil downloadProgress)
}

method downloadURLInBrowser MicroBlocksFlasher url {
    if (beginsWith url 'http:') {
        url = (join 'https:' (substring url 6))
    }

	fetchID = (startFetch url)
	if (isNil fetchID) { return }

	downloadProgress = 0
	spinner = (newSpinner (action 'downloadProgress' this) (action 'downloadCompleted' this))
	setStopAction spinner (action 'abortDownload' this)
	addPart (global 'page') spinner

	result = nil
	while (and (notNil fetchID) (isNil result)) {
		doOneCycle (global 'page')
		waitMSecs 10
		result = (fetchResult fetchID)
	}
	if (or (isNil result) (false == result)) {
		result = (newBinaryData)
	}

	removeFromOwner (morph spinner)
	return result
}

method downloadURL MicroBlocksFlasher url {
	// Return the binary data for the given URL or an empty binary data if the download fails.

	i = (findSubstring '://' url)
	if (isNil i) { return (newBinaryData) }
	host = (substring url (i + 3))
	i = (findSubstring '/' host)
	path = (substring host i)
	host = (substring host 1 (i - 1))

	downloadProgress = 0
	spinner = (newSpinner (action 'downloadProgress' this 'downloaded') (action 'downloadCompleted' this))
	setStopAction spinner (action 'abortDownload' this)
	addPart (global 'page') spinner

	socket = (openClientSocket host 80)
	if (isNil socket) { return (newBinaryData) }

	nl = (string 13 10)
	request = (join
		'GET ' path ' HTTP/1.1' nl
		'Host: ' host nl
		'Accept:' 'application/octet-stream' nl nl)
	writeSocket socket request

	data = (newBinaryData)
	headers = ''
	bytesNeeded = -1
	while (or (bytesNeeded < 0) ((byteCount data) < bytesNeeded)) {
		chunk = (readSocket socket true)
		if ((byteCount chunk) > 0) {
			data = (join data chunk)
			if (headers == '') {
				headerEnd = (endOfHeaders this data)
				if (headerEnd > 0) {
					headers = (join '' (copyFromTo data 1 headerEnd))
					data = (copyFromTo data (headerEnd + 1))
					bytesNeeded = (toNumber (contentLength this headers))
				}
			}
			downloadProgress = (floor ((100 * (byteCount data)) / bytesNeeded))
		} else {
			waitMSecs 1
		}
		doOneCycle (global 'page')
	}
	closeSocket socket
	downloadProgress = nil
	return data
}

method endOfHeaders MicroBlocksFlasher data {
	for i (byteCount data) {
		// find the end of the header (byte sequence 13 10 13 10)
		if (and
			(13 == (byteAt data i))
			(10 == (byteAt data (i + 1)))
			(13 == (byteAt data (i + 2)))
			(10 == (byteAt data (i + 3)))
		) {
			// return the byte index of the end of the headers
			return (i + 3)
		}
	}
	return 0 // end of headers not found
}

method contentLength MicroBlocksFlasher httpHeaders {
	for s (lines httpHeaders) {
		if (beginsWith s 'Content-Length:') {
			return (toNumber (substring s 16))
		}
	}
	return 0 // no Content-Length: header
}
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Copyright 2019 John Maloney, Bernat Romagosa, and Jens MÃ¶nig

// MicroBlocksHTTPServer.gp - An HTTP server that allows a Snap! or other tools to
//interact with a MicroBlocks board tethered via a USB cable to the MicroBlocks IDE.
//
// John Maloney and Bernat Romagosa, May, 2019

defineClass MicroBlocksHTTPServer port serverSocket vars workers

to newMicroBlocksHTTPServer {
	result = (initialize (new 'MicroBlocksHTTPServer'))
	return result
}

method port MicroBlocksHTTPServer { return port }

method initialize MicroBlocksHTTPServer {
	serverSocket = nil
	vars = (dictionary)
	workers = (list)
	return this
}

method start MicroBlocksHTTPServer {
	stop this
	port = (freshPrompt (global 'page') 'Server port?' '6473')
	if ('' == port) { return false }
	port = (toInteger port)
	serverSocket = (openServerSocket port)
	if (notNil serverSocket) {
		print 'MicroBlocks HTTP Server listening on port' port
	} else {
		print 'Could not create HTTP Server socket'
	}
	return (isRunning this)
}

method stop MicroBlocksHTTPServer {
	if (notNil serverSocket) { closeSocket serverSocket }
	serverSocket = nil
	for c workers { closeConnection c }
	workers = (list)
}

method isRunning MicroBlocksHTTPServer {
	return (notNil serverSocket)
}

method step MicroBlocksHTTPServer {
	if (isNil serverSocket) { return }

	// accept a new connection if there is one
	clientSock = (acceptConnection serverSocket)
	if (notNil clientSock) {
		add workers (newMicroBlocksHTTPWorker this clientSock)
	}

	// process requests
	connectionWasClosed = false
	for c workers {
		stepWorker c
		if (not (isOpen c)) { connectionWasClosed = true }
	}
	if connectionWasClosed {
		workers = (filter 'isOpen' workers)
	}
}

method run MicroBlocksHTTPServer {
	start this
	while true {
		step this
		waitMSecs 1 // chill for a bit to avoid burning CPU time
	}
}

// Broadcasts

method broadcastReceived MicroBlocksHTTPServer msg {
	// Called by the the runtime system when a broadcast is received from the board.
	// Add the broadcast to the queue for each worker.

	for w workers { broadcastReceived w msg }
}

// Variables

method clearVars MicroBlocksHTTPServer {
	vars = (dictionary)
}

method variableIndex MicroBlocksHTTPServer varName {
	// Return the id of the given variable or nil if the variable is not defined.

	varNames = (allVariableNames (project (scripter (smallRuntime))))
	return (indexOf varNames varName)
}

method requestVarFromBoard MicroBlocksHTTPServer varName {
	// Request the given variable from the board and return its last known value.
	// Details: Request the variable, wait a few milliseconds for the board to
	// respond, then return the last known value of the variable. This design ensures
	// that the HTTP request completes quickly, but if the board is slow to respond,
	// the variable value could be out of date. However, if the client is continuously
	// requesting the value of a variable (e.g. for a variable watcher) then it will
	// typically lag by at most one request.

	id = (variableIndex this varName)
	if (isNil id) { return 0 }
	getVar (smallRuntime) (id - 1) // VM uses zero-based index

	// wait a bit to allow the board to respond
	waitMSecs 3
	processMessages (smallRuntime)

	if (not (contains vars varName)) { atPut vars varName 0 }
	return (at vars varName)
}

method varValueReceived MicroBlocksHTTPServer varID value {
	varNames = (allVariableNames (project (scripter (smallRuntime))))
	if (varID < (count varNames)) {
		varName = (at varNames (varID + 1))
		atPut vars varName value
	}
}

defineClass MicroBlocksHTTPWorker server sock inBuf outBuf broadcastsFromBoard varNames

to newMicroBlocksHTTPWorker aMicroBlocksHTTPServer aSocket {
	return (initialize (new 'MicroBlocksHTTPWorker') aMicroBlocksHTTPServer aSocket)
}

method initialize MicroBlocksHTTPWorker aMicroBlocksHTTPServer aSocket {
	server = aMicroBlocksHTTPServer
	sock = aSocket
	inBuf = (newBinaryData 0)
	outBuf = (newBinaryData 0)
	broadcastsFromBoard = (list)
	return this
}

method closeConnection MicroBlocksHTTPWorker {
	if (notNil sock) { closeSocket sock }
	sock = nil
}

method isOpen MicroBlocksHTTPWorker {
	return (notNil sock)
}

method stepWorker MicroBlocksHTTPWorker {
	// This is where data is actually received and transmited.

	// receive data
	if (isNil sock) { return }
	data = (readSocket sock true)
	if ((byteCount data) > 0) {
		inBuf = (join inBuf data)
	}

	processNext this // process a request

	// do a socket write operation even if outBuf is empty
	// a result of -1 indicates that the client has closed the socket
	n = (writeSocket sock outBuf)
	if (n < 0) { // connection was closed by other end
		closeConnection this
	} (n > 0) {
		outBuf = (copyFromTo outBuf (n + 1))
	}
}

method processNext MicroBlocksHTTPWorker {
	// Process the next request in inBuf. Do nothing if the request is not complete.

	headers = (extractHeaders this)
	if (isNil headers) { return } // incomplete headers
	contentLength = (contentLength this headers)
	requestEnd = (+ (count headers) 4 contentLength)
	if ((byteCount inBuf) < requestEnd) { return } // incomplete body

	body = (copyFromTo inBuf ((count headers) + 5) requestEnd)
	inBuf = (copyFromTo inBuf (requestEnd + 1))
	handleRequest this headers body
}

method extractHeaders MicroBlocksHTTPWorker {
	// Extract the header fields from inBuf. Return nil if a complete set of header has not been received.

	bufLen = (byteCount inBuf)
	if (bufLen <= 4) { return nil }
	for i (bufLen - 3) {
		if (and (13 == (byteAt inBuf i))
				(10 == (byteAt inBuf (i + 1)))
				(13 == (byteAt inBuf (i + 2)))
				(10 == (byteAt inBuf (i + 3)))) {
			return (toString (copyFromTo inBuf 1 (i - 1)))
		}
	}
	return nil // did not find end of headers; incomplete request
}

method contentLength MicroBlocksHTTPWorker headers {
	// Return the value of the Content-Length: header or zero if there isn't one.

	s = (getHeader this headers 'Content-Length:')
	if (and (notNil s) (representsAnInteger s)) { return (toNumber s) }
	return 0
}

method getHeader MicroBlocksHTTPWorker headers headerName {
	// Return the (string) value of the header line with the given name or nil if there isn't one'

	headerName = (toLowerCase headerName)
	for line (lines (toLowerCase headers)) {
		if (beginsWith line headerName) {
			i = ((count headerName) + 1)
			while (and (i < (count line)) ((at line i) <= ' ')) { i += 1 }
			return (substring line i)
		}
	}
	return nil
}

method handleRequest MicroBlocksHTTPWorker header body {
	method = (at (words (first (lines header))) 1)
	path = (at (words (first (lines header))) 2)
	if ('GET' == method) {
		if ('/' == path) {
			responseBody = (helpString this)
		} (not (serialPortOpen (smallRuntime))) {
			responseBody = 'Board not connected'
		} (beginsWith path '/getBroadcasts') {
			responseBody = (getBroadcasts this path)
		} (beginsWith path '/broadcast') {
			responseBody = (sendBroadcast this path)
		} (beginsWith path '/getVar') {
			responseBody = (getVar this path)
		} (beginsWith path '/setVar') {
			responseBody = (setVar this path)
		} ('/varNames' == path) {
			responseBody = (fetchVarNamesFromBoard this)
		} ('/board' == path) {
			boardType = (checkBoardType (smallRuntime))
			if (or (isNil boardType) ('' == boardType)) { boardType = 'none' }
			responseBody = boardType
		} else {
			responseBody = 'Unrecognized request'
		}
	} else {
		responseBody = 'Unhandled method'
	}

	responseHeaders = (list)
	add responseHeaders 'HTTP/1.1 200 OK'
	add responseHeaders 'Access-Control-Allow-Origin: *'
	add responseHeaders 'Access-Control-Allow-Methods: PUT, GET, OPTIONS, POST'
	add responseHeaders (join 'Content-Length: ' (count responseBody))
	add responseHeaders ''
	add responseHeaders (toString responseBody)
	outBuf = (join outBuf (joinStrings responseHeaders (string 13 10)))
}

method helpString MicroBlocksHTTPWorker {
	result = (list)
	add result 'MicroBlocks HTTP Server'
	add result ''
	add result '/ - this help text'
	add result '/getVar/URL_encoded_var_name - get variable value'
	add result '/setVar/URL_encoded_var_name/value - set variable value'
	add result '  (value is: true, false, an integer, or a URL-encoded string (up to 800 bytes))'
	add result '  (double-quote strings that would otherwise be treated as a boolean or integer such as "true", "false", or "12345")'
	add result '/broadcast/URL_encoded_message - broadcast message to board'
	add result '/getBroadcasts - get broadcasts from board, (URL-encoded strings, one per line)'
	add result '/varNames - get all variable names, one per line'
	add result '/board - get the board type; return "none" if no board is connected'
	add result ''
	add result 'Lists and byte arrays are not supported, although getVar reports them as they would be shown by the "say" block'
	return (joinStrings result (newline))
}

// Broadcasts

method broadcastReceived MicroBlocksHTTPWorker msg {
	// Add the given message to the list of received broadcasts.

	add broadcastsFromBoard msg
}

method getBroadcasts MicroBlocksHTTPWorker path {
	// Handle URL of form: /getBroadcasts
	// Return a list of URL-encoded broacast strings received from the board, one per line.

	result = (joinStrings broadcastsFromBoard (newline))
	broadcastsFromBoard = (list) // clear list
	return result
}

method sendBroadcast MicroBlocksHTTPWorker path {
	// Handle URL of form: /broadcast/<URL_encoded broadcast string>
	// Send the given broadcast to the board.

	msg = (urlDecode (substring path 12))
	sendBroadcastToBoard (smallRuntime) msg
}

// Variables

method getVar MicroBlocksHTTPWorker path {
	// Handle URL of form: /getVar/<URL_encoded var name>
	// Return the value of the given variable.

	varName = (urlDecode (substring path 9))
	if (endsWith varName '/') { varName = (substring varName 1 ((count varName) - 1)) }
	if ('' == varName) { return 'error: missing var name' }
	value = (requestVarFromBoard server varName)
	return (jsonStringify value)
}

method setVar MicroBlocksHTTPWorker path {
	// Handle URL of form: /setVar/<URL_encoded var name>/<value> where value is:
	//	true, false, <integer value>, <url-encoded string (up to 800 bytes)>
	// Set the given variable to the given value.
	// A string can be enclosed in optional double-quotes to pass strings that
	// would otherwise be interpreted as booleans or integers.

	i = (indexOf (letters path) '/' 8)
	if (isNil i) { return 'error: unexpected URL format' }
	varName = (urlDecode (substring path 9 (i - 1)))
	valueString = (substring path (i + 1))
	if (representsAnInteger valueString) {
		value = (toInteger valueString)
	} ('true' == valueString) {
		value = true
	} ('false' == valueString) {
		value = false
	} else {
		value = (urlDecode valueString)
		if (and ((count value) >= 2) (beginsWith value '"') (endsWith value '"')) {
			// string enclosed in double quotes: remove quotes
			value = (substring value 2 ((count value) - 1))
		}
	}
	id = (variableIndex server varName)
	if (notNil id) { setVar (smallRuntime) (id - 1) value } // VM uses zero-based index
	return valueString
}

// fetching variable names

method fetchVarNamesFromBoard MicroBlocksHTTPWorker {
	varNames = (dictionary)
	readVarsFromBoard (smallRuntime) this
	return (joinStrings (sorted (keys varNames)) (newline))
}

method addVar MicroBlocksHTTPWorker varID varName {
	// Called by MicroBlocksRuntime when variable name message received.

	add varNames varName
}
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Copyright 2019 John Maloney, Bernat Romagosa, and Jens MÃ¶nig

// MicroBlocksHelp.gp - Help string table.
// John Maloney, November 2021

defineClass MicroBlocksHelp opDict

method initialize MicroBlocksHelp {
	// an entry is: op name, Wiki path, description

	opEntries = (array
		// OUTPUT
		(array 'setUserLED' 'output#set-user-led' 'Turn the user LED on or off.')
		(array 'sayIt' 'output#say' 'Display a bubble showing the value.')
		(array 'printIt' 'output#graph' 'Graph the value.')

		// INPUT
		(array 'buttonA' 'input#button-a' 'Report the state of button A ( (-o) or (o-) ).')
		(array 'buttonB' 'input#button-b' 'Report the state of button B ( (-o) or (o-) ).')
		(array 'timer' 'input#timer' 'Report the milliseconds since the timer was last reset.')
		(array 'resetTimer' 'input#reset-timer' 'Reset the timer.')
		(array 'millisOp' 'input#milliseconds' 'Report the milliseconds since power up.')
		(array 'microsOp' 'input#microseconds' 'Report the microseconds since power up.')
		(array 'boardType' 'input#board-type' 'Report the board type.')

		// PINS
		(array 'digitalReadOp' 'pins#read-digital' 'Report the electrical logic level on a digital pin ( (-o) or (o-) ).')
		(array 'analogReadOp' 'pins#read-analog' 'Report a number proportional to the voltage on an analog pin (0 = ground, 1023 = supply voltage).')
		(array 'digitalWriteOp' 'pins#set-digital' 'Turn a pin on or off ( (-o) or (o-) ).')
		(array 'analogWriteOp' 'pins#set-pin' 'Pulse width modulate (PWM) a pin with the given duty cycle (0 - 1023).')
		(array 'analogPins' 'pins#analog-pins' 'Report number of analog pins on this device.')
		(array 'digitalPins' 'pins#digital-pins' 'Report number of digital pins on this device.')

		// COMM
		(array 'i2cGet' 'comm#i2c-get-device' 'Report the value of a register (0-255) of an I2C device (0-127).')
		(array 'i2cSet' 'comm#i2c-set-device' 'Set an I2C device and register to given value (0-255).')
		(array '[sensors:i2cRead]' 'comm#i2c-device-read' 'Receive multiple bytes from an I2C device.')
		(array '[sensors:i2cWrite]' 'comm#i2c-device-write' 'Send multiple bytes to an I2C device.')
		(array 'spiSend' 'comm#spi-send' 'Send a byte (0-255) to an SPI device.')
		(array 'spiRecv' 'comm#spi-receive' 'Read a byte from an SPI device while sending a zero byte. Report the byte received.')
		(array '[sensors:spiSetup]' 'comm#xxx' 'Set the SPI clock speed, mode, channel (Raspberry Pi only), and bit order.')
		(array '[sensors:spiExchange]' 'comm#xxx' 'Send a byte array via SPI, replacing its contents with the bytes received.')
		(array '[serial:open]' 'comm#serial-open' 'Open the serial port at the given baud rate.')
		(array '[serial:close]' 'comm#serial-close' 'Close the serial port.')
		(array '[serial:read]' 'comm#serial-read' 'Report data received from the serial port (a byte array).')
		(array '[serial:write]' 'comm#serial-write' 'Send a byte array to the serial port.')

		// CONTROL
		(array 'whenStarted' 'control#when-started' 'Run when the board powers up or when the IDE start button is clicked.')
		(array 'whenButtonPressed' 'control#when-button-pressed' 'Run when buttons A, B, or A+B are pressed.')
		(array 'forever' 'control#forever' 'Repeat the enclosed blocks indefinitely.')
		(array 'repeat' 'control#repeat' 'Repeat the enclosed blocks the given number of times.')
		(array 'waitMillis' 'control#wait-millisecs' 'Wait the given number of milliseconds.')
		(array 'if' 'control#if' 'Run the first set of blocks whose test condition is (-o) .')
		(array 'whenCondition' 'control#when' 'Run when the condition becomes (-o) .')
		(array 'waitUntil' 'control#wait-until' 'Wait until the condition becomes (-o) .')
		(array 'return' 'control#return' 'Return (report) the given value from a function or script.')
		(array 'whenBroadcastReceived' 'control#when-received' 'Run when the given message is broadcast.')
		(array 'sendBroadcast' 'control#broadcast' 'Broadcast the given message.')
		(array 'comment' 'control#comment' 'Do nothing. Used to add notes and documentation.')
		(array 'for' 'control#for' 'Repeat the enclosed blocks with the variable set to the current iteration number or item.')
		(array 'repeatUntil' 'control#repeat-until' 'Repeat the enclosed blocks until the condition becomes (-o) .')
		(array 'stopTask' 'control#stop-this-task' 'Stop this task.')
		(array 'stopAll' 'control#stop-other-tasks' 'Stop all tasks except this one.')
		(array 'waitMicros' 'control#wait-microsecs' 'Wait the given number of microseconds.')
		(array 'getLastBroadcast' 'control#last-message' 'Report the last broadcast message received.')
		(array 'callCustomCommand' 'control#xxx' 'Call the function with the given name and optional parameter list.')
		(array 'callCustomReporter' 'control#xxx' 'Call the function with the given name and optional parameter list and report its return value.')

		// OPERATORS
		(array '+' 'operators#' 'Report the sum of the given numbers.')
		(array '-' 'operators#' 'Report the first number minus the second.')
		(array '*' 'operators#' 'Report the product of the given numbers.')
		(array '/' 'operators#' 'Report the first number divided by the second.')
		(array '%' 'operators#modulus' 'Report the remainder of dividing the first number by the second.')
		(array 'absoluteValue' 'operators#' 'Report the absolute value of the given number (always >= 0).')
		(array 'minimum' 'operators#' 'Report the minimum of the values.')
		(array 'maximum' 'operators#' 'Report the maximum of the values.')
		(array 'random' 'operators#random' 'Report a randomly chosen number in the given range.')
		(array '<' 'operators#' 'Report (-o) if the first value is less than the second one.')
		(array '<=' 'operators#' 'Report (-o) if the first value is less than or equal to the second one.')
		(array '==' 'operators#' 'Report (-o) if the two values are equal.')
		(array '!=' 'operators#' 'Report (-o) if the two values are not equal.')
		(array '>=' 'operators#' 'Report (-o) if the first value is greater than or equal to the second one.')
		(array '>' 'operators#' 'Report (-o) if the first value is greater than the second one.')
		(array 'booleanConstant' 'operators#boolean-true/false' 'Boolean constant ( (-o) or (o-) ).')
		(array 'not' 'operators#boolean-not' 'Report the logical inverse of a Boolean ( (-o) or (o-) ) value.')
		(array 'and' 'operators#boolean-and' 'Report (-o) if both values are (-o)')
		(array 'or' 'operators#boolean-or' 'Report (-o) if either value is (-o)')
		(array 'isType' 'operators#is-type' 'Report (-o) if first input is a value of the given data type.')
		(array 'hexToInt' 'operators#hex' 'Report the numerical value of a hexadecimal string (range: -0x1FFFFFFF to 0x1FFFFFFF)')
		(array '&' 'operators#bitwise-and' 'Report bitwise AND of two numbers.')
		(array '|' 'operators#bitwise-or' 'Report bitwise OR of two numbers.')
		(array '^' 'operators#bitwise-xor' 'Report bitwise XOR (exclusive OR) of two numbers.')
		(array '~' 'operators#bitwise-not' 'Report bitwise inverse of the given number.')
		(array '<<' 'operators#bitwise-left-shift' 'Report the given number shifted left by the given number of bits.')
		(array '>>' 'operators#bitwise-right-shift' 'Report the given number shifted right by the given number of bits (arithmetic shift; sign is maintained).')

		// VARIABLES
		(array 'v' 'variables#xxx' '')
		(array '=' 'variables#set-variable' 'Set a variable to the given value.')
		(array '+=' 'variables#change-variable' 'Change a variable by the given amount.')
		(array 'local' 'variables#initialize-local' 'Create a variable local to the containing script with the given initial value.')

		// DATA
		(array 'at' 'data#item' 'Report the Nth item of a list, string, or byte array.')
		(array 'size' 'data#length-of' 'Report the number of items in a list, string, or byte array.')
		(array '[data:join]' 'data#join' 'Join (concatenate) the given lists, strings, or byte arrays and report the result.')
		(array '[data:makeList]' 'data#list' 'Create and report a short list containing the given items. Length limited by available stack space.')
		(array '[data:addLast]' 'data#add-to-list' 'Add an item to the end of a list.')
		(array 'atPut' 'data#repllace-item' 'Replace the Nth item (or all items) of a list or byte array with the given value.')
		(array '[data:delete]' 'data#delete-item' 'Delete the Nth item (or all items) of a list.')
		(array '[data:find]' 'data#find' 'Find and report the index of an item in a list or a substring within a string. Report -1 if not found.')
		(array '[data:copyFromTo]' 'data#copy' 'Report a copy from the given index through the end (or optional stop index) of the given list, string, or byte array.')
		(array '[data:split]' 'data#split' 'Split the given string with the given delimiter and report the result (a list of strings).')
		(array '[data:joinStrings]' 'data#join-items-of-list' 'Combine the items of a list into a string, optionally separated by a delimiter (e.g. comma).')
		(array '[data:unicodeAt]' 'data#unicode' 'Report the Unicode value ("code point") of the Nth character of the given string.')
		(array '[data:unicodeString]' 'data#string-from-unicode' 'Report a string containing the given Unicode value ("code point") or list of values.')
		(array 'newList' 'data#new-list' 'Report a new list of the given length filled with zero or the optional value.')
		(array '[data:newByteArray]' 'data#new-byte-array' 'Report a new byte array of the given length filled with zero or the optional value.')
		(array '[data:asByteArray]' 'data#as-byte-array' 'Report a byte array containing the UTF-8 bytes of the given string.')
		(array '[data:freeMemory]' 'data#free-memory' 'Report the number of words of memory available. Stop button frees up memory.')

		// BASIC SENSORS LIBRARY
		(array '[sensors:tiltX]' '/libraries#tilt-x-y-z' 'Report x acceleration/tilt (+/-200).')
		(array '[sensors:tiltY]' '/libraries#tilt-x-y-z' 'Report y acceleration/tilt (+/-200).')
		(array '[sensors:tiltZ]' '/libraries#tilt-x-y-z' 'Report z acceleration/tilt (+/-200).')
		(array '[sensors:acceleration]' '/libraries#acceleration' 'Report total acceleration (0-346).')
		(array '[display:lightLevel]' '/libraries#light-level' 	'Report ambient light level (0-1023).')
		(array '[sensors:temperature]' '/libraries#temperature'	'Report ambient temperature in degrees Celsius.')
		(array '[sensors:magneticField]' '/libraries#magnetic-field' 'Report magnetic field strength (0-100000).')
		(array '_setAccelRange' '/libraries#set-acceleration-range'	'Set accelermeter range. Higher ranges are usefl for collisions.')

		// LED DISPLAY LIBRARY
		(array '[display:mbDisplay]' '/libraries#display' 'Display a 5x5 image on the LED display.')
		(array '[display:mbDisplayOff]' '/libraries#clear-display' 'Clear the LED display (all pixels off).')
		(array '[display:mbPlot]' '/libraries#plot-x-y' 'Turn on the LED at the given row and column (1-5).')
		(array '[display:mbUnplot]' '/libraries#unplot-x-y' 'Turn off the LED at the given row and column (1-5).')
		(array 'displayCharacter' '/libraries#display-character' 'Display a single character on the LED display.')
		(array 'scroll_text' '/libraries#scroll-text' 'Scroll words or numbers across the LED display.')
		(array 'stopScrollingText' 	'/libraries#stop-scrolling' 'Stop scrolling and clear the display.')

		// NEOPIXEL
		(array 'neoPixelAttach' '/libraries#attach-neopixel-led-to-pin' 'Set Neopixel count and pin number.')
		(array 'setNeoPixelColors10' '/libraries#set-neopixels' 'Set the colors of the first ten NeoPixels.')
		(array 'clearNeoPixels' '/libraries#clear-neopixels' 'Turn off all NeoPixels.')
		(array 'neoPixelSetAllToColor' '/libraries#set-all-neopixels-color' 'Set all NeoPixels to the given color.')
		(array 'setNeoPixelColor' '/libraries#set-neopixel-color' 'Set the given NeoPixel to the selected color.')
		(array 'rotateNeoPixelsBy' '/libraries#rotate-neopixels-by' 'Shift/rotate the NeoPixel colors by the given number.')
		(array 'colorFromRGB' '/libraries#color-r-g-b' 'Return a color defined by values of R G B (0-255).')
		(array 'randomColor' '/libraries#random-color' 'Return a random color.')

		// RADIO
		(array '[radio:sendInteger]' '/libraries#radio-send-number' 'Send a numerical message.')
		(array '[radio:sendString]' '/libraries#radio-send-string' 'Send a text message.')
		(array '[radio:sendPair]' '/libraries#radio-send-pair' 'Send a message containing both short text string and a number.')
		(array '[radio:messageReceived]' '/libraries#radio-message-received' 'Return (-o) when a new radio message is received.')
		(array '[radio:receivedInteger]' '/libraries#radio-last-number' 'Return the number part of the last radio message received.')
		(array '[radio:receivedString]' '/libraries#radio-last-string' 'Return the text part of the last radio message received.')
		(array '[radio:setGroup]' '/libraries#radio-set-group' 'Set the radio group number (0-255).')
		(array '[radio:setPower]' '/libraries#radio-set-power' 'Set the radio transmission power level (0-7).')

		// RINGTONE
		(array 'play ringtone' '/libraries#play-ringtone' 'Play the given ringtone string.')
		(array 'current song name' '/libraries#current-song-name' 'Report the name of the currently playing ringtone song.')

		// SERVO
		(array 'setServoAngle' '/libraries#set-servo-degrees' 'Set the angle of a positional servo.')
		(array 'setServoSpeed' '/libraries#set-servo-speed' 'Set the speed of a continuous rotation servo.')
		(array 'stopServo' '/libraries#servo-stop' 'Stop sending servo control pulses.')

		// TONE
		(array 'play tone' '/libraries#play-note' 'Play the given note in the given octave for milliseconds.')
		(array 'playMIDIKey' '/libraries#play-midi' 'Play the given piano key (0-127) for milliseconds. Middle C is 60.')
		(array 'play frequency' '/libraries#play-frequency' 'Play a note specified in Hertz (Hz). Middle C is ~261 Hz.')
		(array 'start tone' '/libraries#start-tone' 'Starts playing a tone specified in Hertz (Hz).')
		(array 'stop tone' '/libraries#stop-tone' 'Stops playing a note that was started with start tone.')
		(array 'attach buzzer to pin' '/libraries#attach-buzzer' 'Specify the pin used to play tones.')

		// IR Remote
		(array 'receiveIR' '/extension_libraries/irremote#receive-ir-code' 'Wait for an IR message then return its key code.')
		(array 'attachIR' '/extension_libraries/irremote#attach-ir-receiver' 'Set the IR receiver pin.')
		(array 'IR_Transmit' '/extension_libraries/irremote#ir-transmit-device' 'Send an IR command with the given device number and key code.')
		(array 'attachIRTransmitter' '/extension_libraries/irremote#xxx' 'Set the IR transmitter pin.')
		(array '_testIR' '/extension_libraries/irremote#test-ir' 'Wait for an IR message then say its device number and key code received')
		(array '_receiveIRFromDevice' '/extension_libraries/irremote#receive-ir-code-from-device' 'Return the next IR key code from the given device.')

		// PICOBRICKS
		(array 'pb_beep' '/extension_libraries/picobricks#picobricks-beep' 'Make a beep sound from the speaker.')
		(array 'pb_button' 	'/extension_libraries/picobricks#picobricks-button' 'Return (-o) if the button is pressed.')
		(array 'pb_humidity' '/extension_libraries/picobricks#picobricks-humidity' 'Return the relative humidity.')
		(array 'pb_light_sensor' '/extension_libraries/picobricks#picobricks-light-sensor' 'Return the light level (0-100).')
		(array 'pb_potentiometer' '/extension_libraries/picobricks#picobricks-potentiometer' 'Return the potentiometer value (0-1023).')
		(array 'pb_random_color' '/extension_libraries/picobricks#picobricks-random-color' 'Return a random color.')
		(array 'pb_rgb_color' '/extension_libraries/picobricks#picobricks-color' 'Return a color with the given RGB values (0-255).')
		(array 'pb_set_motor_speed'	'/extension_libraries/picobricks#picobricks-set-motor' 'Set the speed of a DC motor (0-100)')
		(array 'pb_set_red_LED' '/extension_libraries/picobricks#picobricks-set-red-led' 'Turn the red LED on (-o) or off (o-) .')
		(array 'pb_set_relay' '/extension_libraries/picobricks#picobricks-set-relay' 'Turn the relay on (-o) or off (o-) .')
		(array 'pb_set_rgb_color' '/extension_libraries/picobricks#picobricks-set-rgb-led-color' 'Set the RGB LED color using the color selector.')
		(array 'pb_temperature' '/extension_libraries/picobricks#picobricks-temperature' 'Return the temperature (Celsius).')
		(array 'pb_turn_off_RGB' '/extension_libraries/picobricks#picobricks-turn-off-rgb-led' 'Turn off the RGB LED.')

		// OLED
		(array 'OLEDInit_I2C' '/extension_libraries/oled#initialize-i2c' 'Initialize an I2C OLED display.')
		(array 'OLEDInit_SPI' '/extension_libraries/oled#initialize-spi' 'Initialize an SPI OLED display.')
		(array 'OLEDwrite' '/extension_libraries/oled#write-' 'Display the given value as a string.')
		(array 'OLEDshowGDBuffer' '/extension_libraries/oled#show-display-buffer' 'Reveal the contents of the virtual buffer if updates were deferred.')
		(array 'OLEDclear' '/extension_libraries/oled#clear-' 'Clear the display.')
		(array 'OLEDcontrast' '/extension_libraries/oled#set-contrast' 'Set the display contrast (1-4).')
		(array 'OLEDdrawCircle' '/extension_libraries/oled#draw-circle' 'Draw a circle with center at x,y.')
		(array 'OLEDdrawImage' '/extension_libraries/oled#draw-image' 'Draw an image at x,y. See OLEDmakeImage.')
		(array 'OLEDdrawLine' '/extension_libraries/oled#draw-line' 'Draw a line between two points.')
		(array 'OLEDdrawRect' '/extension_libraries/oled#draw-rectangle' 'Draw a rectangle at x,y with width and height.')
		(array 'OLEDfillRect' '/extension_libraries/oled#fill-rectangle' 'Draw a filled rectangle at x,y with width and height.')
		(array 'OLEDflip' '/extension_libraries/oled#_flip-display-top' 'Flip which side of the display is the top.')
		(array 'OLEDmakeImage' '/extension_libraries/oled#make-image' 'Make a 5x5 Sprite image for use with OLEDdrawImage.')
		(array 'OLEDpixel' '/extension_libraries/oled#set-pixel' 'Turn the pixel at x,y on (-o) or off (o-) .')
		(array 'OLEDsetVideo' '/extension_libraries/oled/set-videoa' 'Set the display to inverse video or normal mode.')
		(array 'OLEDwru' '/extension_libraries/oled#cursor-location' 'Report the cursor location.')
		(array 'defer display updates' '/extension_libraries/oled#defer-display-updates' 'Delay display updates during pixel level operations.')

		// MAQUEEN
		(array 'Maqueen beep' 'en/extension_libraries/maqueen/#maqueen-beep' 'Make a beep sound.')
		(array 'Maqueen distance (cm)' '/extension_libraries/maqueen/#maqueen-distance' 'Return the distance to a wall or obstacle.')
		(array 'Maqueen IR keycode' '/extension_libraries/maqueen/#maqueen-ir-keycode' 'Return the last received IR keycode.')
		(array 'Maqueen LED' '/extension_libraries/maqueen/#maqueen-led' 'Turn the left and/or right LEDs on (-o) or off (o-) .')
		(array 'Maqueen line sensor' '/extension_libraries/maqueen/#maqueen-line-sensor' 'Return the given line sensor value ( (-o) or (o-) )')
		(array 'Maqueen motor' '/extension_libraries/maqueen/#maqueen-motor' 'Set the motor directions and speeds.')
		(array 'Maqueen stop motors' '/extension_libraries/maqueen/#maqueen-stop-motors' 'Stop the motors.')
		(array 'Maqueen sees line on left' '/extension_libraries/maqueen/#maqueen-sees-line-on-left' 'Return (-o) if the given line sensor sees a black line.')

		// HUSKYLENS
		(array 'HL set Comms' '/extension_libraries/huskylens#hl-set-comms' 'Sets communication mode of the camera')
		(array 'HL change algorithm' '/extension_libraries/huskylens#hl-change-algorithm' 'Change recognition algorithm.')
		(array 'HL do' '/extension_libraries/huskylens#hl-do' 'Perform maintenance operation.')
		(array 'HL request' '/extension_libraries/huskylens#hl-request' 'Request recognized objects from HuskyLens.')
		(array 'HL request by ID' '/extension_libraries/huskylens#hl-request-by-id' 'Request only one object by id from HuskyLens.')
		(array 'HL get info' '/extension_libraries/huskylens#hl-get-info' 'Get Info details from HuskyData.')
		(array 'HL get block' '/extension_libraries/huskylens#hl-get-block' 'Get Block details from HuskyData.')
		(array 'HL get arrow' '/extension_libraries/huskylens#hl-get-arrow' 'Get Arrow details from HuskyData')
		(array 'HL learn current object as ID' '/extension_libraries/huskylens#hl-learn-as-id' 'Learn recognized object as ID#.')
		(array 'HL learn object as ID' '/extension_libraries/huskylens#hl-learn-as-id-and-name' 'Learn recognized object as ID# and assigns name')
		(array 'HL set CustomName' '/extension_libraries/huskylens#hl-set-custom-name' 'Set custom name for a learned object.')
		(array 'HL write' '/extension_libraries/huskylens#hl-write' 'Write text to HuskyLens screen @ x,y [0,0 is top left].')
		(array 'HL file' '/extension_libraries/huskylens#hl-file' 'Save/Load file to/from SDcard.')

		// WEBSOCKET SERVER
		(array 'start WebSocket server' '/network_libraries/websocket-server#start-websocket-server' 'Start running the WebSocket server.')
		(array '[net:webSocketLastEvent]' '/network_libraries/websocket-server#last-websocket-event' 'Return the last protocol message received.')
		(array 'ws client id' '/network_libraries/websocket-server#client-id-for-websocket-event' 'Return the WebSocket client ID (0-4).')
		(array 'ws event payload' '/network_libraries/websocket-server#payload-for-websocket-event' 'Return the content of the message received.')
		(array 'ws event type' '/network_libraries/websocket-server#type-of-websocket-event' 'Return the WebSocket event type.')
		(array '[net:webSocketSendToClient]' '/network_libraries/websocket-server#send-to-websocket-client'	'Send a message to any client using its client id.')

	)

	opDict = (dictionary)
	for e opEntries {
		atPut opDict (first e) e
	}
	return this
}

method entryForOp MicroBlocksHelp op {
	// Return a help entry, an array of: op name, Wiki path, description.

	if (isNil opDict) { return nil }
	return (at opDict op nil)
}
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Copyright 2019 John Maloney, Bernat Romagosa, and Jens MÃ¶nig

// MicroBlocksLibraryWidgets.gp - Provides morphs and dialogs to explore and load libraries

// Library Import Dialog
// ---------------------
// Explore and load libraries.
// Shows all library fields: name, author, version, dependencies, source, and description.

defineClass MicroBlocksLibraryImportDialog morph window filePicker propertiesFrame

to pickLibraryToOpen anAction defaultPath {
	page = (global 'page')
	dialog = (initialize (new 'MicroBlocksLibraryImportDialog') anAction defaultPath false)
	addPart page dialog
	dialogM = (morph dialog)
	setPosition dialogM (half ((width page) - (width dialogM))) (40 * (global 'scale'))
}

method initialize MicroBlocksLibraryImportDialog anAction defaultPath {
	filePicker = (initialize (new 'MicroBlocksFilePicker') anAction defaultPath (array '.ubl'))
	onSelectCloud filePicker (action 'promptLibUrl' this)

	morph = (morph filePicker)
	window = (window filePicker)
	setHandler morph this

	propertiesFrame = (newLibraryPropertiesFrame nil false window)
	addPart morph (morph propertiesFrame)

	onFileSelect filePicker (action 'updateLibraryInfo' this)
	onFolderSelect filePicker (action 'clearLibraryInfo' this)

	scale = (global 'scale')
	setMinExtent morph (600 * scale) (466 * scale)
	setExtent morph (600 * scale) (466 * scale)

	redraw this
	fixLayout this
	return this
}

method okay MicroBlocksLibraryImportDialog {
	okay filePicker
}

method updateLibraryInfo MicroBlocksLibraryImportDialog selectedPath {
	libName = (withoutExtension (substring selectedPath ((findLast selectedPath '/') + 1)))
	if (beginsWith selectedPath '//') {
		data = (readEmbeddedFile (substring selectedPath 3))
	} else {
		data = (readFile selectedPath)
	}
	cmdList = (parse data)
	library = (newMicroBlocksModule libName)
	loadFromCmds library cmdList

	setLibrary propertiesFrame library
}

method clearLibraryInfo MicroBlocksLibraryImportDialog {
	clearFields propertiesFrame
}

method promptLibUrl MicroBlocksLibraryImportDialog {
	page = (global 'page')
	url = (prompt page 'Library URL?' 'http://')
	if (and (notEmpty url) (endsWith url '.ubl') ((findLast url '/') > 10)) {
		result = (importLibraryFromUrl (scripter (smallRuntime)) url)
	} (notEmpty url) {
		inform page 'Invalid URL'
	}
	if result { destroy morph }
}

method redraw MicroBlocksLibraryImportDialog {
	redraw filePicker
	fixLayout this
}

method fixLayout MicroBlocksLibraryImportDialog {
	scale = (global 'scale')
	fixLayout filePicker
	listPaneM = (morph (listPane filePicker))

	margin = (10 * scale)

	// file list panel should take roughly half the space
	topInset = (55 * scale)
	bottomInset = (40 * scale)
	leftInset = (110 * scale)
	rightInset = (((width morph) / 2) - (20 * scale))
	setPosition listPaneM ((left morph) + leftInset) ((top morph) + topInset)
	setExtent listPaneM ((width morph) - (leftInset + rightInset)) ((height morph) - (topInset + bottomInset))

	propLeft = ((right listPaneM) + margin)
	propWidth = ((((width morph) - propLeft) + (left morph)) - (margin * 2))

	setPosition (morph propertiesFrame) propLeft (top listPaneM)
	setExtent (morph propertiesFrame) propWidth (height listPaneM)

	fixLayout propertiesFrame
}

// Library Info Dialog
// -------------------
// Inspect and edit libraries.
// Shows all library fields: name, author, version, dependencies, source, and description.

defineClass MicroBlocksLibraryInfoDialog morph window frame library propertiesFrame editFlag saveButton cancelButton

to showLibraryInfo lib forEditing {
	page = (global 'page')
	dialog = (initialize (new 'MicroBlocksLibraryInfoDialog') lib forEditing)
	addPart page dialog
	dialogM = (morph dialog)
	setPosition dialogM (half ((width page) - (width dialogM))) (40 * (global 'scale'))
}

method initialize MicroBlocksLibraryInfoDialog lib forEditing {
	library = lib
	window = (window (moduleName library))
	morph = (morph window)
	setHandler morph this

	propertiesFrame = (newLibraryPropertiesFrame library forEditing window)
	frame = (scrollFrame propertiesFrame (gray 230) true)

	editFlag = (isForEditing propertiesFrame)

	addPart morph (morph frame)

	if editFlag {
		saveButton = (pushButton 'Save' (gray 130) (action 'saveChanges' this))
		addPart morph (morph saveButton)
		cancelButton = (pushButton 'Cancel' (gray 130) (action 'close' this))
		addPart morph (morph cancelButton)
		setLibsDraggable (scripter (smallRuntime)) true
	}

	scale = (global 'scale')
	setMinExtent morph (320 * scale) (240 * scale)
	setExtent morph (420 * scale) (315 * scale)

	return this
}

method saveChanges MicroBlocksLibraryInfoDialog {
	saveChanges propertiesFrame
	close this
}

method close MicroBlocksLibraryInfoDialog {
	scripter = (scripter (smallRuntime))
	setLibsDraggable scripter false
	selectLibrary scripter (moduleName library)
	destroy morph false
}

method wantsDropOf MicroBlocksLibraryInfoDialog aHandler { return true }

method justReceivedDrop MicroBlocksLibraryInfoDialog aHandler {
	if (isClass aHandler 'Toggle') {
		libName = (data aHandler)
		dep = (libraryNamed (project (scripter (smallRuntime))) libName)
		if (and (notNil dep) (libName != (moduleName library))) {
			addDependency propertiesFrame dep
			fixLayout this
		}
	} (or (isAnyClass aHandler 'ColorPicker' 'Monitor') (hasField aHandler 'window')) {
		addPart (morph (global 'page')) (morph aHandler)
		return
	}
	animateBackToOldOwner (hand (global 'page')) (morph aHandler)
}

method redraw MicroBlocksLibraryInfoDialog {
	fixLayout this
	redraw window
	costumeChanged morph
}

method fixLayout MicroBlocksLibraryInfoDialog {
	scale = (global 'scale')

	fixLayout window

	topInset = (30 * scale)
	margin = (6 * scale)

	if editFlag {
		// buttons
		setRight (morph saveButton) ((right morph) - (2 * margin))
		setBottom (morph saveButton) ((bottom morph) - (2 * margin))
		setRight (morph cancelButton) ((left (morph saveButton)) - margin)
		setBottom (morph cancelButton) (bottom (morph saveButton))
		bottomInset = ((height (morph saveButton)) + margin)
	} else {
		bottomInset = 0
	}

	setPosition (morph frame) ((left morph) + margin) ((top morph) + topInset)
	setExtent (morph frame) ((width morph) - (2 * margin)) (((height morph) - topInset) - margin)

	setPosition (morph propertiesFrame) ((left (morph frame)) + margin) ((top (morph frame)) + margin)
	setExtent (morph propertiesFrame) ((width (morph frame)) - (2 * margin)) (((height (morph frame)) - (2 * margin)) - bottomInset)

	fixLayout propertiesFrame
}


// Horizontal list item viewer and editor
// --------------------------------------
// Embeddable morph that shows a list of items and lets you remove them or add
// new ones.
// When editable, remove an item by dragging it out of the container window.
// When used for libraries, drag and drop a library from the palette to the
// window to add it as a dependency, or click on the [ + ] button to add it by
// its explicit path (can be a URL).

defineClass MicroBlocksListItemViewer morph box contents newItemQueryString newItemQueryHint editFlag window itemRenderer label

to newItemViewer aList forEditing win {
	return (initialize (new 'MicroBlocksListItemViewer') aList forEditing win)
}

method initialize MicroBlocksListItemViewer aList forEditing win {
	box = (newBox nil (transparent) 0)
	morph = (morph box)
	window = win
	setClipping morph true
	editFlag = (or (and (notNil forEditing) forEditing) false)
	setContents this aList
	fixLayout this
	return this
}

method setLabel MicroBlocksListItemViewer aLabel { label = aLabel }

method contents MicroBlocksListItemViewer { return contents }
method setContents MicroBlocksListItemViewer aList {
	contents = (copy (toArray aList))
	buildListView this
}

method setItemRenderer MicroBlocksListItemViewer anAction {
	itemRenderer = anAction
}

method setNewItemQueryString MicroBlocksListItemViewer aString { newItemQueryString = aString }
method setNewItemQueryHint MicroBlocksListItemViewer aString { newItemQueryHint = aString }

method queryNewItem MicroBlocksListItemViewer {
	newItem = (prompt (global 'page') newItemQueryString '' 'line' nil newItemQueryHint)
	if (notEmpty newItem) {
		addItem this newItem
	}
}

method removeItem MicroBlocksListItemViewer itemName {
	for item contents {
		if ((renderedItemName this item) == itemName) {
			contents = (copyWithout contents item)
		}
	}
}

method addItem MicroBlocksListItemViewer item {
	if (not (contains contents (renderedItemName this item))) {
		contents = (copyWith contents item)
		buildListView this
		fixLayout this
	}
}

method itemDropped MicroBlocksListItemViewer itemMorph aHand {
	// If item is dropped outside owner window, we remove it
	if (or
		((handX) < (left (morph window)))
		((handX) > (right (morph window)))
		((handY) < (top (morph window)))
		((handY) > (bottom (morph window)))) {
		removeItem this (itemName itemMorph)
		removePart morph (morph itemMorph)
		destroy (morph itemMorph)
		buildListView this
		fixLayout this
	} else {
		animateBackToOldOwner aHand (morph itemMorph)
	}
}

method renderedItemName MicroBlocksListItemViewer item {
	if (notNil itemRenderer) {
		return (call itemRenderer item)
	} else {
		return item
	}
}

method buildListView MicroBlocksListItemViewer {
	fontName = 'Arial'
	labelFontName = 'Arial Bold'
	fontSize = (14 * (global 'scale'))
	if ('Linux' == (platform)) { fontSize = (12 * (global 'scale')) }

	removeAllParts morph
	if (or (and (notNil label) (notEmpty contents)) editFlag) {
		addPart morph (morph (newText label labelFontName fontSize (gray 0) 'center' nil 0 0 5 3))
	}
	for item contents {
		addPart morph (morph (newLibraryItem (renderedItemName this item) this editFlag))
	}
	if editFlag {
		addPart morph (morph (newLibraryItem '+' this false (action 'queryNewItem' this)))
	}
}

method fixLayout MicroBlocksListItemViewer {
	scale = (global 'scale')
	margin = (6 * scale)
	left = ((left morph) - (4 * scale))
	height = ((scale * 10) + (margin * 2))
	for text (parts morph) {
		setLeft text left
		if ((right text) > ((left morph) + (width morph))) {
			height = ((height + (height text)) + margin)
			left = (left morph)
			setLeft text left
		}
		setExtent morph (width morph) height
		setBottom text (bottom morph)
		left = ((left + (width text)) + margin)
	}
}

// LibraryItemMorph
// ----------------
// Represents a library or anything else that you want to be able to click and drag around.

defineClass MicroBlocksLibraryItemMorph text morph itemName itemViewer editFlag onClick

to newLibraryItem aName anItemViewer forEditing clickAction {
	return (initialize (new 'MicroBlocksLibraryItemMorph') aName anItemViewer forEditing clickAction)
}

method initialize MicroBlocksLibraryItemMorph aName anItemViewer forEditing clickAction {
	morph = (newMorph this)
	fontName = 'Arial'
	fontSize = (14 * (global 'scale'))
	if ('Linux' == (platform)) { fontSize = (12 * (global 'scale')) }

	itemName = aName
	itemViewer = anItemViewer
	editFlag = forEditing
	onClick = clickAction

	bm = (stringImage itemName fontName fontSize (gray 0) 'center' nil 0 0 5 3 (gray 200))
	setCostume morph bm
	if editFlag { setGrabRule morph 'handle' }
	return this
}

method itemName MicroBlocksLibraryItemMorph { return itemName }

method clicked MicroBlocksLibraryItemMorph { if (notNil onClick) { call onClick } }
method justDropped MicroBlocksLibraryItemMorph aHand { itemDropped itemViewer this aHand }

method handEnter MicroBlocksLibraryItemMorph aHand {
	if (notNil onClick) {
		setCostumeColor this (gray 180)
	}
}

method handLeave MicroBlocksLibraryItemMorph aHand {
	if (notNil onClick) {
		setCostumeColor this (gray 200)
	}
}

method setCostumeColor MicroBlocksLibraryItemMorph color {
	fontName = 'Arial'
	fontSize = (14 * (global 'scale'))
	if ('Linux' == (platform)) { fontSize = (12 * (global 'scale')) }

	bm = (stringImage itemName fontName fontSize (gray 0) 'center' nil 0 0 5 3 color)
	setCostume morph bm
}

// Library category picker
// -----------------------
// Simple colored box that lets you pick a category when clicked

defineClass MicroBlocksLibraryCategoryPicker morph box category

method initialize MicroBlocksLibraryCategoryPicker aCategory {
	box = (newBox)
	morph = (morph box)
	updateColor this
	setHandler morph this
	redraw this
	return this
}

method category MicroBlocksLibraryCategoryPicker { return category }

method setCategory MicroBlocksLibraryCategoryPicker aCategory {
	category = aCategory
	updateColor this
}

method pickCategory MicroBlocksLibraryCategoryPicker {
	scripter = (scripter (smallRuntime))
	menu = (menu)
	for cat (categories scripter) {
		addItem menu (localized cat) (action 'setCategory' this cat) '' (fullCostume (morph (newBox nil (blockColorForCategory (authoringSpecs) cat))))
	}
	addItem menu (localized 'Generic') (action 'setCategory' this 'Library') '' (fullCostume (morph (newBox nil (blockColorForCategory (authoringSpecs) 'Library'))))
	popUp menu (global 'page') (left morph) (bottom morph)
}

method clicked MicroBlocksLibraryCategoryPicker aCategory {
	pickCategory this
}

method updateColor MicroBlocksLibraryCategoryPicker {
	if (notNil category) {
		setColor box (blockColorForCategory (authoringSpecs) category)
		redraw this
	}
}

method redraw MicroBlocksLibraryCategoryPicker {
	redraw box
}

// Library properties frame
// ------------------------
// Embeddable frame that displays library information

defineClass MicroBlocksLibraryPropertiesFrame morph window library descriptionFrame descriptionText categoryPicker sourceFrame sourceText depsViewer versionText versionFrame authorText authorFrame editFlag

to newLibraryPropertiesFrame lib forEditing win {
	return (initialize (new 'MicroBlocksLibraryPropertiesFrame') lib forEditing win)
}

method initialize MicroBlocksLibraryPropertiesFrame lib forEditing win {
	fontName = 'Arial'
	fontSize = (16 * (global 'scale'))
	if ('Linux' == (platform)) { fontSize = (12 * (global 'scale')) }

	editFlag = (or (and (notNil forEditing) forEditing) false)
	morph = (morph (newBox nil (transparent) 0))
	window = win

	descriptionText = (newText '' fontName fontSize (gray 0) 'left' nil 0 0 5)
	if editFlag { setEditRule descriptionText 'editable' }
	descriptionFrame = (scrollFrame descriptionText (gray 255))
	addPart (morph descriptionFrame) (morph descriptionText)

	addPart morph (morph descriptionFrame)

	categoryPicker = (initialize (new 'MicroBlocksLibraryCategoryPicker'))
	addPart morph (morph categoryPicker)

	sourceText = (newText '' fontName fontSize (gray 0) 'left' nil 0 0 5)
	sourceFrame = (newBox nil (gray 255) 0)
	addPart (morph sourceFrame) (morph sourceText)
	addPart morph (morph sourceFrame)

	versionText = (newText '' fontName fontSize (gray 0) 'left' nil 0 0 5)
	if editFlag { setEditRule versionText 'editable' }
	versionFrame = (newBox nil (gray 255) 0)
	addPart (morph versionFrame) (morph versionText)
	addPart morph (morph versionFrame)

	authorText = (newText '' fontName fontSize (gray 0) 'left' nil 0 0 5)
	if editFlag { setEditRule authorText 'editable' }
	authorFrame = (newBox nil (gray 255) 0)
	setClipping (morph authorFrame) true
	addPart (morph authorFrame) (morph authorText)
	addPart morph (morph authorFrame)

	depsViewer = (newItemViewer (array) editFlag window)
	setNewItemQueryString depsViewer 'Dependency path, name or URL?'
	setNewItemQueryHint depsViewer (libraryImportHint this)
	addPart morph (morph depsViewer)

	if (notNil lib) { setLibrary this lib }

	fixLayout this

	return this
}

method libraryImportHint MicroBlocksLibraryPropertiesFrame {
	return (join
			(localized 'If you are adding a library that''s built into MicroBlocks, you can just enter its name.')
			(newline)
			(localized 'If your library is in the Libraries folder in your local MicroBlocks project folder, you need to prefix it with a slash (/).')
			(newline)
			(localized 'If the library is hosted online, please input its full URL.')
		)
}

method isForEditing MicroBlocksLibraryPropertiesFrame { return editFlag }
method getDescription MicroBlocksLibraryPropertiesFrame { return (contentsWithoutCRs descriptionText) }
method getVersion MicroBlocksLibraryPropertiesFrame {
	// Returns an array with the major and minor version parsed out of the string
	versionString = ''
	for c (letters (contentsWithoutCRs versionText)) {
		if (or (representsAnInteger c) (c == '.')) {
			versionString = (join versionString c)
		}
	}
	major = (toInteger (at (splitWith versionString '.') 1))
	minor = (toInteger (at (splitWith versionString '.') 2))
	return (array major minor)
}
method getAuthor MicroBlocksLibraryPropertiesFrame {
	// Returns the sanitized author name, without the trailing "by"
	return (trim (last (splitWithString (contentsWithoutCRs authorText) (join (localized 'by') ' '))))
}

method addDependency MicroBlocksLibraryPropertiesFrame dep {
	addItem depsViewer (path dep)
}

method setLibrary MicroBlocksLibraryPropertiesFrame lib {
	library = lib
	updateFields this
	fixLayout this
}

method saveChanges MicroBlocksLibraryPropertiesFrame {
	setDescription library (getDescription this)
	setDependencies library (contents depsViewer)
	setCategory library (category categoryPicker)
	setVersion library (getVersion this)
	setAuthor library (getAuthor this)
}

method clearFields MicroBlocksLibraryPropertiesFrame {
	setText descriptionText ''
	setText sourceText ''
	setContents depsViewer (array)
	setText versionText ''
	setText authorText ''
}

method updateFields MicroBlocksLibraryPropertiesFrame {
	setText descriptionText (description library)

	path = (path library)
	if (and editFlag (notNil path)) {
		if (beginsWith path '/') {
			setText sourceText (join (gpFolder) '/Libraries' path '.ubl')
		} (beginsWith path 'http://') {
			setText sourceText path
		} else {
			setText sourceText (localized 'built-in library')
		}
	} else {
		setText sourceText (localized 'user library')
	}

	setCategory categoryPicker (moduleCategory library)

	setItemRenderer depsViewer (action 'dependencyName' library)
	setLabel depsViewer (localized 'Depends:')
	setContents depsViewer (dependencies library)
	setText versionText (join
		'v' (toString (at (version library) 1)) '.' (toString (at (version library) 2)))
	setText authorText (join (localized 'by') ' ' (author library))
}

method fixLayout MicroBlocksLibraryPropertiesFrame {
	scale = (global 'scale')
	margin = (10 * scale)

	descriptionHeight = (height morph)
	depsBottom = (bottom morph)
	versionBottom = (bottom morph)

	setExtent (morph depsViewer) (width morph) 0
	fixLayout depsViewer
	setLeft (morph depsViewer) (left morph)
	setBottom (morph depsViewer) depsBottom

	if (or editFlag (and (notNil library) (notEmpty (dependencies library)))) {
		descriptionHeight = ((descriptionHeight - (height (morph depsViewer))) - margin)
		versionBottom = ((top (morph depsViewer)) - margin)
	}

	// version and author
	setExtent (morph versionFrame) ((width (morph versionText)) + margin) (height (morph versionText))
	setLeft (morph versionFrame) (left morph)
	setBottom (morph versionFrame) versionBottom
	setExtent (morph authorFrame) (((width morph) - (width (morph versionFrame))) - margin) (height (morph versionText))
	setLeft (morph authorFrame) ((right (morph versionFrame)) + margin)
	setBottom (morph authorFrame) (bottom (morph versionFrame))
	descriptionHeight = ((descriptionHeight - (height (morph versionFrame))) - margin)

	if editFlag {
		// category color
		setExtent (morph categoryPicker) ((width morph) / 6) (height (morph versionFrame))
		setLeft (morph categoryPicker) (left morph)
		setBottom (morph categoryPicker) ((top (morph versionFrame)) - margin)
		show (morph categoryPicker)

		// source
		setExtent (morph sourceFrame) (((width morph) - (width (morph categoryPicker))) - margin) (height (morph sourceText))
		setLeft (morph sourceFrame) ((right (morph categoryPicker)) + margin)
		setBottom (morph sourceFrame) ((top (morph versionFrame)) - margin)
		descriptionHeight = ((descriptionHeight - (height (morph sourceFrame))) - margin)
		show (morph sourceFrame)
	} else {
		hide (morph categoryPicker)
		hide (morph sourceFrame)
	}

	// description
	setPosition (morph descriptionFrame) (left morph) (top morph)
	setExtent (morph descriptionFrame) (width morph) descriptionHeight
	wrapLinesToWidth descriptionText ((width morph) - (18 * scale))
}
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Copyright 2019 John Maloney, Bernat Romagosa, and Jens MÃ¶nig

// MicroBlocksProject.gp - Representation of a MicroBlocks project and its libraries

to mbProj {
	// Just for debugging. Find the currently installed project.
	gc
	projects = (allInstances 'MicroBlocksProject')
	if ((count projects) > 1) {
		print 'multiple MicroBlocksProject instances'
	}
	return (first projects)
}

to newProjTest fileName {
	// Test that saving and reading projects in the new format preserves the project content.

	print (filePart fileName) '...'
	projectData = (readFile fileName true)
	project = (newMicroBlocksProject)
	if (endsWith fileName '.gpp') {
		// read old project
		mainClass = nil
		oldProj = (readProject (emptyProject) projectData)
		if ((count (classes (module oldProj))) > 0) {
			mainClass = (first (classes (module oldProj)))
			loadFromOldProjectClassAndSpecs project mainClass (blockSpecs oldProj)
		} else {
			error 'no class in old project'
		}
	} else {
		loadNewProjectFromData project (toString projectData)
	}
	if (not (saveLoadTest project)) { print '	FAILED!' }
}

// MicroBlocksProject Class

defineClass MicroBlocksProject main libraries blockSpecs

to newMicroBlocksProject {
	return (initialize (new 'MicroBlocksProject'))
}

method initialize MicroBlocksProject {
	main = (newMicroBlocksModule 'main')
	libraries = (dictionary)
	blockSpecs = (dictionary)
	return this
}

// Support

method choicesFor MicroBlocksProject selector {
	if (contains (choices main) selector) {
		return (at (choices main) selector)
	}
	for lib (values libraries) {
		libChoices = (choices lib)
		if (contains libChoices selector) { return (at libChoices selector) }
	}
	return nil // not found; return empty choices list
}

method extraCategories MicroBlocksProject { return (array) } // called by AuthoringSpecs>specsFor

method hasUserCode MicroBlocksProject {
	if (isNil main) { return false }
	if (and (isEmpty (scripts main)) (isEmpty (functions main)) (isEmpty (variableNames main))) {
		return false
	}
	return true
}

// Block Specs

method blockSpecs MicroBlocksProject { return blockSpecs }

method recordBlockSpec MicroBlocksProject opName spec {
	atPut blockSpecs opName spec
}

method deleteBlockSpecFor MicroBlocksProject functionName {
	remove blockSpecs functionName
}

// Libraries

method main MicroBlocksProject { return main }
method libraries MicroBlocksProject { return libraries }
method libraryNamed MicroBlocksProject name { return (at libraries name) }

method addLibrary MicroBlocksProject aMicroBlocksModule {
	libName = (moduleName aMicroBlocksModule)
	oldLib = (at libraries libName)
	if (notNil oldLib) {
		updatingLibrary oldLib aMicroBlocksModule
	}
	remove libraries libName
	atPut libraries libName aMicroBlocksModule

	// the functions in this new library supersede all earlier versions of those functions
	newFunctionNames = (dictionary)
	for f (functions aMicroBlocksModule) { add newFunctionNames (functionName f) }
	removeSupercededFunctions main newFunctionNames
	for lib (values libraries) {
		if (lib != aMicroBlocksModule) { removeSupercededFunctions lib newFunctionNames }
	}

	// update block specs
	newSpecs = (blockSpecs aMicroBlocksModule)
	for k (keys newSpecs) {
		atPut blockSpecs k (at newSpecs k)
	}
}

method removeLibraryNamed MicroBlocksProject libName {
	lib = (at libraries libName)
	if (isNil lib) { return }
	remove libraries libName
	for f (functions lib) {
		remove blockSpecs (functionName f)
	}
}

method categoryForOp MicroBlocksProject op {
	// Return the category for the give op if it is in one of my libraries.

	if ('-' == op) { return nil } // ignore dash used as a spacer in library block lists

	for lib (values libraries) {
		if (contains (blockList lib) op) { return (moduleCategory lib) }
	}
	return nil
}

method checkForNewerLibraryVersions MicroBlocksProject autoConfirm {
	// Check for newer versions of libraries used in this project.
	// If true is passed to the optional autoConfirm parameter, update old
	// libraries without asking. Otherwise ask the user for confirmation.

	if (isNil autoConfirm) { autoConfirm = false }

	for libName (keys libraries) {
		newVersion = (getNewerVersion (at libraries libName))
		if (notNil newVersion) {
			if (or
				autoConfirm
				(confirm (global 'page') nil (join
					(localized 'Found a newer version of ') libName (newline)
					(localized 'Do you want me to update the one in the project?')))
			) {
				addLibrary this newVersion
			}
		}
	}
}

// Functions

method allFunctions MicroBlocksProject {
	result = (list)
	addAll result (functions main)
	for lib (values libraries) {
		addAll result (functions lib)
	}
	return result
}

method functionNamed MicroBlocksProject functionName {
	f = (functionNamed main functionName)
	if (notNil f) { return f }
	for lib (values libraries) {
		f = (functionNamed lib functionName)
		if (notNil f) { return f }
	}
	return nil
}

method metaInfoForFunction MicroBlocksProject aFunc {
	// Return a tab-delimited string with meta information about the given function:
	//	libraryName libraryCategory blockType funcName specString argTypes
	// Return the empty string if the function doesn't have a block spec (shouldn't happen).

	funcName = (functionName aFunc)
	spec = (at blockSpecs funcName)
	if (isNil spec) { // no spec, so create one
		specString = funcName
		typeString = ''
		defaults = (list)
		for argName (argNames aFunc) {
			specString = (join specString ' _')
			typeString = (join typeString ' auto')
		}
		spec = (blockSpecFromStrings funcName ' ' specString typeString defaults)
	}

	parts = (toList (argList (first (parse (specDefinitionString spec)))))
	if ((count parts) < 4) {
		add parts '' // add empty arg types string for a parmeterless function
	} else {
		parts = (copyFromTo parts 1 4) // remove default arg values
	}

	libName = ''
	libCat = ''
	for pair (sortedPairs libraries) {
		lib = (first pair)
		if (notNil (functionNamed lib funcName)) {
			libName = (last pair)
			libCat = (moduleCategory lib)
		}
	}
	parts = (join (list libName libCat) parts)
	return (joinStrings parts (string 9)) // join fields with tab delimiter
}

// Variables

method allVariableNames MicroBlocksProject {
	result = (dictionary)
	addAll result (variableNames main)
	for lib (values libraries) {
		addAll result (variableNames lib)
	}
	return (sorted (keys result))
}

method addVariable MicroBlocksProject newVar {
	addVariable main newVar
}

method deleteVariable MicroBlocksProject varName {
	for lib (values libraries) {
		deleteVariable lib varName
	}
}

// Variables

method allBroadcasts MicroBlocksProject {
	result = (dictionary)
	for entry (scripts main) {
		for b (allBlocks (last entry)) {
			if (isOneOf (primName b) 'sendBroadcast' 'whenBroadcastReceived') {
				add result (first (argList b))
			}
		}
	}
	return (toList (sorted (keys result)))
}

// Loading

method loadFromOldProjectClassAndSpecs MicroBlocksProject aClass specList {
	// Used when reading projects in the old .gpp format.

	initialize this
	for f (functions (module aClass)) { addFunction main f }
	for v (variableNames (module aClass)) { addVariable main v }
	for k (keys specList) { atPut blockSpecs k (at specList k) }
	setScripts main (copy (scripts aClass))
	updatePrimitives this
	fixFunctionLocals this
	return this
}

method loadFromString MicroBlocksProject s updateLibraries {
	// Load project from a string in .ubp format. Keep libraries (modules) together.
	initialize this
	cmdList = (parse s)
	if (and (notEmpty cmdList) ('projectName' == (primName (first cmdList)))) {
		// skip projectName line, if any
		cmdList = (copyFromTo cmdList 2)
	}
	loadSpecs this cmdList
	cmdsByModule = (splitCmdListIntoModules this cmdList)
	isFirst = true
	for cmdList cmdsByModule {
		if isFirst { // main module
			loadFromCmds main cmdList
			isFirst = false
		} else { // library
			lib = (loadFromCmds (newMicroBlocksModule) cmdList true)
			atPut libraries (moduleName lib) lib
		}
	}
	if (isNil updateLibraries) { updateLibraries = true }
	if updateLibraries { checkForNewerLibraryVersions this }
	updatePrimitives this
	fixFunctionLocals this
	return this
}

method addLibraryFromString MicroBlocksProject s libName fileName {
	// Load a library from a string.
	cmdList = (parse s)
	loadSpecs this cmdList
	cmdsByModule = (splitCmdListIntoModules this cmdList)
	for cmdList cmdsByModule {
		lib = (loadFromCmds (newMicroBlocksModule) cmdList)
		if (isNil (moduleName lib)) {
			setModuleName lib libName
		}
		if (beginsWith fileName '//Libraries/') {
			setPath lib (withoutExtension (substring fileName ((count '//Libraries/') + 1)))
		} (beginsWith fileName 'http://') {
			setPath lib fileName
		} (beginsWith fileName (join (gpFolder) '/Libraries')) {
			setPath lib (withoutExtension (substring fileName ((count (join (gpFolder) '/Libraries')) + 1)))
		} else {
			// Local files sourced from places other than the MicroBlocks folder
			// are unsupported as dependencies.
			setPath lib nil
		}
		updatePrimitives lib
		fixFunctionLocals this
		importDependencies lib (scripter (smallRuntime))
		addLibrary this lib
	}
	return this
}

method parsedSpecs MicroBlocksProject cmdList {
	specs = (dictionary)
	for cmd cmdList {
		if ('spec' == (primName cmd)) {
			args = (argList cmd)
			blockType = (at args 1)
			op = (at args 2)
			specString = (at args 3)
			slotTypes = ''
			if ((count args) > 3) { slotTypes = (at args 4) }
			slotDefaults = (array)
			if ((count args) > 4) { slotDefaults = (copyArray args ((count args) - 4) 5) }
			spec = (blockSpecFromStrings op blockType specString slotTypes slotDefaults)
			atPut specs op spec
		}
	}
	return specs
}

method loadSpecs MicroBlocksProject cmdList {
	specs = (parsedSpecs this cmdList)
	for k (keys specs) {
		atPut blockSpecs k (at specs k)
	}
}

method splitCmdListIntoModules MicroBlocksProject cmdList {
	// Split the list of commands into a list of command lists for each module of the project.
	// Each module after the first (main) module begins with a 'module' command.

	result = (list)
	m = (list)
	for cmd cmdList {
		if ('module' == (primName cmd)) {
			if (not (isEmpty m)) { add result m }
			m = (list)
		}
		add m cmd
	}
	add result m // add final module
	return result
}

// Saving

method codeString MicroBlocksProject {
	// Return a string representing this project in the new .ubp format.

	// sort libraries by name (this canonicalizes their order)
	sortedLibs = (sorted
		(values libraries)
		(function a b {return ((moduleName a) < (moduleName b))}))

	result = (list)
	add result (codeString main this)
	for lib sortedLibs {
		add result (newline)
		add result (codeString lib this)
	}
	return (joinStrings result)
}

// Post-load processing

method fixFunctionLocals MicroBlocksProject {
	// Remove project variables for function locals.

	projectVars = (allVariableNames this)
	for f (allFunctions this) { removeFieldsFromLocals f projectVars }
}

method updatePrimitives MicroBlocksProject {
	// Update primitives that have been replaced with newer versions.

	updatePrimitives main
	for lib (values libraries) { updatePrimitives lib }
}

// save/load test

method saveLoadTest MicroBlocksProject {
	// Verify that this project can be saved and reloaded.

	s1 = (codeString this)
	p2 = (loadFromString (newMicroBlocksProject) s1)
	s2 = (codeString p2)
	if (s1 != s2) { print 'second codeString does not match first'; return false }
	if (not (equal this p2)) { print 'second project does not match first'; return false }
	return true
}

// equality

method equal MicroBlocksProject proj {
	// Return true if the given project has the same contents as this one.

	if (not (equal main (main proj))) { return false }
	for lib (values libraries) {
		if (not (equal lib (libraryNamed proj (moduleName lib)))) {
			print '	libs not equal:' (moduleName lib)
			return false
		}
	}
	sortedKeys = (sorted (keys blockSpecs))
	if (sortedKeys != (sorted (keys (blockSpecs proj)))) {
		print '	spec keys mismatch'
		return false;
	}
	for k sortedKeys {
		s1 = (specDefinitionString (at blockSpecs k))
		s2 = (specDefinitionString (at (blockSpecs proj) k))
		if (s1 != s2) {
			print '	spec mismatch' k
			return false
		}
	}
	return true
}

// MicroBlocksModule Class

defineClass MicroBlocksModule moduleName moduleCategory dependencies version author description tags path variableNames blockList functions scripts blockSpecs choices

to newMicroBlocksModule modName {
	return (initialize (new 'MicroBlocksModule') modName)
}

method initialize MicroBlocksModule name {
	moduleName = name
	moduleCategory = 'Library'
	dependencies = (array)
	version = (array 1 0)
	author = 'unknown'
	description = ''
	tags = (array)
	choices = (dictionary)
	variableNames = (array)
	blockList = (list)
	blockSpecs = (dictionary)
	functions = (array)
	scripts = (array)
	return this
}

method blockList MicroBlocksModule { return blockList }
method blockSpecs MicroBlocksModule { return blockSpecs }
method moduleCategory MicroBlocksModule { return moduleCategory }
method moduleName MicroBlocksModule { return moduleName }
method setModuleName MicroBlocksModule modName { moduleName = modName }
method toString MicroBlocksModule { return (join 'MicroBlocksModule(''' moduleName ''')') }
method description MicroBlocksModule { return description }
method version MicroBlocksModule { return (copy version) }
method author MicroBlocksModule { return author }
method tags MicroBlocksModule { return (copy tags) }
method choices MicroBlocksModule { return choices }
method path MicroBlocksModule { return path }
method dependencies MicroBlocksModule { return (copy dependencies) }
method setDependencies MicroBlocksModule deps { dependencies = (toArray (copy deps)) }
method setDescription MicroBlocksModule desc { description = desc }
method setAuthor MicroBlocksModule auth { author = auth }
method setCategory MicroBlocksModule cat { moduleCategory = cat }
method setVersion MicroBlocksModule versionArray {
	atPut version 1 (at versionArray 1)
	atPut version 2 (at versionArray 2)
}
method setTags MicroBlocksModule tagList { tags = (copy (toArray tagList)) }
method setPath MicroBlocksModule aPath { path = aPath }

method dependencyName MicroBlocksModule dep {
	slashPos = (findLast dep '/')
	if (slashPos > 0) { slashPos = (slashPos + 1) }
	poundPos = (findLast dep '#')
	if (poundPos > 0) {
		poundPos = (poundPos - 1)
	} else {
		poundPos = (count dep)
	}
	return (withoutExtension (substring dep slashPos poundPos))
}

method dependencyNames MicroBlocksModule {
	deps = (list)
	for dep dependencies {
		add deps (dependencyName this dep)
	}
	return deps
}

// scripts

method scripts MicroBlocksModule { return scripts }
method setScripts MicroBlocksModule newScripts { scripts = (toArray newScripts) }

// functions

method functions MicroBlocksModule { return functions }

method functionNamed MicroBlocksModule functionName {
	for f functions {
		if (functionName == (functionName f)) { return f }
	}
	return nil
}

method defineFunctionInModule MicroBlocksModule funcName funcParams funcBody {
	f = (newFunction funcName funcParams funcBody this)
	for i (count functions) {
		if ((functionName (at functions i)) == funcName) {
			atPut functions i f
			return f
		}
	}
	functions = (copyWith functions f)
	recompileNeeded (smallRuntime)
	return f
}

method addFunction MicroBlocksModule aFunction {
	if (notNil (indexOf functions aFunction)) { return } // already there
	for f (copy functions) {
		if ((functionName f) == (functionName aFunction)) {
			removeFunction this f
		}
	}
	setField aFunction 'module' this
	functions = (copyWith functions aFunction)
	recompileNeeded (smallRuntime)
}

method removeFunction MicroBlocksModule aFunction {
	functions = (copyWithout functions aFunction)
	recompileNeeded (smallRuntime)
}

method removeSupercededFunctions MicroBlocksModule superceded {
	for f (copy functions) {
		if (contains superceded (functionName f)) {
			removeFunction this f
		}
	}
	newBlockList = (list)
	for op blockList {
		if (not (contains superceded op)) { add newBlockList op }
	}
}

// variables

method variableNames MicroBlocksModule { return (copy variableNames) }

method removeAllVariables MicroBlocksModule {
	variableNames = (array)
}

method addVariable MicroBlocksModule newVar {
	if (not (contains variableNames newVar)) {
		variableNames = (copyWith variableNames newVar)
	}
}

method deleteVariable MicroBlocksModule varName {
	variableNames = (copyWithout variableNames varName)
}

// saving

method arrayToDeclaration MicroBlocksModule array title {
	declaration = (list title)
	for i array {
		if (needsQuotes this i) { i = (join '''' i '''') }
		add declaration (toString i)
	}
	add declaration (newline)
	return (joinStrings declaration ' ')
}

method codeString MicroBlocksModule owningProject newLibName {
	// Return a string containing the code for this MicroBlocksModule.
	// If newLibName is not nil, this module is being exported as a library.

	result = (list)
	modName = moduleName
	if (notNil newLibName) { modName = newLibName }
	if (needsQuotes this modName) { modName = (join '''' modName '''') }
	add result (join 'module ' modName)

	if ('Library' != moduleCategory) {
		modCat = moduleCategory
		if (needsQuotes this modCat) { modCat = (join '''' modCat '''') }
		add result (join ' ' modCat)
	}
	add result (newline)

	// add author
	by = author
	if (needsQuotes this author) { by = (join '''' author '''') }
	add result (join 'author ' by (newline))

	add result (arrayToDeclaration this version 'version')

	// add dependency declaration
	if ((count dependencies) > 0) {
		add result (arrayToDeclaration this dependencies 'depends')
	}

	// add tag declaration
	if ((count tags) > 0) {
		add result (arrayToDeclaration this tags 'tags')
	}

	// add choice lists
	if ((count (keys choices)) > 0) {
		for key (keys choices) {
			choice = (list key)
			addAll choice (at choices key)
			add result (arrayToDeclaration this choice 'choices')
		}
	}

	// add description
	add result (join 'description ' (printString description) (newline))

	// add variable declaration
	if ((count variableNames) > 0) {
		add result (arrayToDeclaration this variableNames 'variables')
	}

	add result (newline)

	projectSpecs = (blockSpecs owningProject)
	processed = (dictionary)

	for op blockList {
		if ('-' == op) {
			add result (join '  space' (newline))
		} else {
			spec = (at projectSpecs op)
			if (notNil spec) {
				add result (join '  ' (specDefinitionString spec) (newline))
				add processed op
			}
		}
	}

	if (not (isEmpty functions)) {
		// sort functions by name (this canonicalizes function order)
		sortedFunctions = (sorted
			functions
			(function a b {return ((functionName a) < (functionName b))})
		)
		// add function block specs
		for func sortedFunctions {
			op = (functionName func)
			if (not (contains processed op)) {
				spec = (at projectSpecs op)
				if (notNil spec) {
					add result (join '  ' (specDefinitionString spec) (newline))
					add processed op
				}
			}
		}
		add result (newline)

		// add function definitions
		pp = (new 'PrettyPrinter')
		for func sortedFunctions {
			add result (prettyPrintFunction pp func)
			add result (newline)
		}
	}

	// Add scripts if not exporting as a library
	if (isNil newLibName) {
		add result (scriptString this)
	}

	return (joinStrings result)
}

method scriptString MicroBlocksModule {
	if (isEmpty scripts) { return '' }

	// sort scripts so the scriptString does not depend on z-ordering of scripts
	sortedScripts = (sorted scripts
		(function e1 e2 {
			if ((at e1 2) == (at e2 2)) {
				return ((at e1 1) < (at e2 1)) // y's equal, sort by x
			} else {
				return ((at e1 2) < (at e2 2)) // sort by y
			}
		}))

	result = (list)
	pp = (new 'PrettyPrinter')
	for entry sortedScripts {
		x = (toInteger (at entry 1))
		y = (toInteger (at entry 2))
		expr = (at entry 3)
		add result (join 'script ' x ' ' y ' ')
		if (isClass expr 'Reporter') {
			add result (join '(' (prettyPrint pp expr) ')')
			add result (newline)
		} else {
			add result (join '{' (newline))
			add result (prettyPrintList pp expr)
			add result (join '}' (newline))
		}
		add result (newline)
	}
	return (joinStrings result)
}

method needsQuotes MicroBlocksModule s {
	// Return true if the given string needs to be quoted in order to be parsed as
	// a variable or function name.
	if (isNumber s) { return false }
	if (isOneOf s 'true' 'false') { return true }
	letters = (letters s)
	if (isEmpty letters) { return true }
	firstLetter = (first letters)
	if (or (isDigit firstLetter) ('-' == firstLetter)) { return true }
	if (not (or (isLetter firstLetter) ('_' == firstLetter))) { return true }
	for ch letters {
		if (not (or (isLetter ch) (isDigit ch) ('_' == ch))) { return true }
	}
	return false
}

// loading

method loadFromCmds MicroBlocksModule cmdList {
	loadModuleNameAndCategory this cmdList
	loadVersion this cmdList
	loadAuthor this cmdList
	loadDependencies this cmdList
	loadTags this cmdList
	loadDescription this cmdList
	loadChoices this cmdList
	loadVariables this cmdList
	loadBlockList this cmdList
	loadSpecs this cmdList
	loadFunctions this cmdList
	loadScripts this cmdList
	return this
}

method browserEmbeddedLibs MicroBlocksModule {
	result = (list)
	todo = (list 'Libraries')
	while (notEmpty todo) {
		libpath = (removeFirst todo)
		for dirName (listEmbeddedFiles libpath true) {
			add todo (join libpath '/' dirName)
		}
		for fName (listEmbeddedFiles libpath false) {
			if (endsWith fName '.ubl') {
				add result (join libpath '/' fName)
			}
		}
	}
	return result
}

method getNewerVersion MicroBlocksModule {
	// Return the embedded library with the same name and a newer version or nil if none found.

	if (moduleName == 'main') { return nil }

	embeddedFiles = (listEmbeddedFiles)
	if ('Browser' == (platform)) {
		embeddedFiles = (browserEmbeddedLibs this)
	}

	// Find the embedded lib path
	moduleFileName = (join moduleName '.ubl')
	v1 = version // current version
	for filePath embeddedFiles {
		if ((filePart filePath) == moduleFileName) {
			cmdList = (parse (readEmbeddedFile filePath))
			candidate = (newMicroBlocksModule moduleName)
			loadFromCmds candidate cmdList
			v2 = (version candidate)
			if (or
				((at v2 1) > (at v1 1))
				(and ((at v1 1) == (at v2 1)) ((at v2 2) > (at v1 2)))
			) {
				return candidate
			}
		}
	}
	return nil
}

method updatingLibrary MicroBlocksModule newerModule {
	// Called when updating an existing library (the receiver) to a newer version.
	// Update the block specs of existing functions that are being updated.
	// Retain the block specs for any functions that are being removed
	// and add "obsolete" to their labels to allow them to be identified
	// in any scripts in which they appear.

	newSpecs = (blockSpecs newerModule)
	projectSpecs = (blockSpecs (project (findProjectEditor)))
	for oldSpec (values (blockSpecs this)) { // for each spec in this module
		op = (blockOp oldSpec)
		if (contains newSpecs op) {
			// update exising spec for op
			atPut projectSpecs op (at newSpecs op)
		} else {
			// mark old function as obsolete and append to module
			obsoletedLabel = (join 'obsolete ' (first (specs oldSpec)))
			atPut (specs oldSpec) 1 obsoletedLabel
			atPut projectSpecs op oldSpec
			add (blockList newerModule) op
		}
	}
}

method loadModuleNameAndCategory MicroBlocksModule cmdList {
	if (not (isEmpty cmdList)) {
		cmd = (first cmdList)
		if ('module' == (primName cmd)) {
			arg = (first (argList cmd))
			if (isClass arg 'String') { // quoted var name
				moduleName = arg
			} else { // unquoted var: mapped to "(v 'varName')" block by the parser
				moduleName = (first (argList arg))
			}
			if ((count (argList cmd)) > 1) {
				cat = (at (argList cmd) 2)
				if (isClass cat 'Reporter') { cat = (first (argList cat)) } // unquoted var (see above)
				moduleCategory = cat
			}
		}
	}
}

method stringArgs MicroBlocksModule cmd {
	args = (list)
	for arg (argList cmd) {
		if (isClass arg 'String') { // quoted item
			add args arg
		} (isClass arg 'Integer') {
			add args arg
		} else { // unquoted item: mapped to "(v 'varName')" block by the parser
			add args (first (argList arg))
		}
	}
	return args
}

method loadDescription MicroBlocksModule cmdList {
	for cmd cmdList {
		if ('description' == (primName cmd)) {
			description = (first (stringArgs this cmd))
		}
	}
}

method loadChoices MicroBlocksModule cmdList {
	for cmd cmdList {
		if ('choices' == (primName cmd)) {
			i = (list)
			for input (stringArgs this cmd) {
				add i (toString input)
			}
			atPut choices (first (stringArgs this cmd)) (copyFromTo i 2)
		}
	}
}

method loadVersion MicroBlocksModule cmdList {
	for cmd cmdList {
		if ('version' == (primName cmd)) {
			atPut version 1 (at (argList cmd) 1)
			atPut version 2 (at (argList cmd) 2)
		}
	}
}

method loadAuthor MicroBlocksModule cmdList {
	for cmd cmdList {
		if ('author' == (primName cmd)) {
			author = (first (stringArgs this cmd))
		}
	}
}
method loadVariables MicroBlocksModule cmdList {
	varNames = (list)
	for cmd cmdList {
		if (isOneOf (primName cmd) 'variables' 'sharedVariables') {
			for v (stringArgs this cmd) {
				add varNames v
			}
		}
	}
	variableNames = (toArray varNames)
}

method loadDependencies MicroBlocksModule cmdList {
	deps = (list)
	for cmd cmdList {
		if ('depends' == (primName cmd)) {
			for libName (stringArgs this cmd) {
				lib = (toString libName)
				add deps lib
			}
		}
	}
	dependencies = (toArray deps)
}

method importDependencies MicroBlocksModule scripter {
	for dependency dependencies {
		importDependency this dependency scripter
	}
}

method importDependency MicroBlocksModule lib scripter {
	// dependencies look like either:
	// LibName						- Fetch from embedded FS
	// /LibName						- Fetch from ~/MicroBlocks/Libraries
	// http://url/LibName.ubp		- Fetch from server

	// Additionally, one can define version requirements like this:
	// LibName#>1.4					- Needs at least version 1.4
	// /LibName#=2.7				- Needs exactly version 2.7
	// http://url/LibName.ubp#>1.1	- Needs at least version 1.1

	// find version requirements
	vPosition = (findLast lib '#')
	vRequirement = ''
	reqVersion = (array 1 0)
	if (vPosition > 0) {
		vPosition = (vPosition + 1)
		vRequirement = (substring lib vPosition vPosition)
		atPut reqVersion 1 (toInteger (substring lib (vPosition + 1) ((findLast lib '.') - 1)))
		atPut reqVersion 2 (toInteger ((findLast lib '.') + 1))
		lib = (substring lib 1 (vPosition - 2))
	}

	// TODO Make sure we comply with version requirement (ex. >2.3, =1.5)

	if (beginsWith lib 'http') {
		// fetch library from remote URL
		importLibraryFromUrl scripter lib
	} (beginsWith lib '/') {
		// fetch library from [MicroBlocksFolder]/Library
		importLibraryFromFile scripter (join (gpFolder) '/Libraries' lib '.ubl')
	} else {
		// load embedded library
		importEmbeddedLibrary scripter lib
	}
}



method loadTags MicroBlocksModule cmdList {
	t = (list)
	for cmd cmdList {
		if ('tags' == (primName cmd)) {
			for tag (stringArgs this cmd) {
				add t (toLowerCase (toString tag))
			}
		}
	}
	tags = (toArray t)
}

method loadFunctions MicroBlocksModule cmdList {
	for cmd cmdList {
		if ('to' == (primName cmd)) {
			args = (toList (argList cmd))
			functionName = (removeFirst args)
			addFirst args nil
			f = (callWith 'functionFor' (toArray args))
			setField f 'functionName' functionName
			setField f 'module' this
			functions = (appendFunction this functions f)
		}
	}
	recompileNeeded (smallRuntime)
}

method appendFunction MicroBlocksModule anArray f {
	// Append function f to the given array of functions and return the new array. If the
	// array already contains a function with the same name, replace it and issue a warning.

	functionName = (functionName f)
	for i (count anArray) {
		item = (at anArray i)
		if ((functionName item) == functionName) {
			print 'Warning: There are multiple definitions of' functionName
			atPut anArray i f
			return anArray
		}
	}
	return (copyWith anArray f)
}

method loadScripts MicroBlocksModule cmdList {
	scripts = (list)
	for cmd cmdList {
		if ('script' == (primName cmd)) {
			add scripts (argList cmd)
		}
	}
}

method loadBlockList MicroBlocksModule cmdList {
	// The blockList is a list of blocks for this library's palette in order
	// of appearance. It is derived from the module specs. The 'space' keyword
	// can be used to add some space between groups of blocks.

	blockList = (list)
	for cmd cmdList {
		if ('space' == (primName cmd)) {
			add blockList '-' // spacer
		} ('spec' == (primName cmd)) {
			add blockList (at (argList cmd) 2)
		}
	}
}

method loadSpecs MicroBlocksModule cmdList {
	blockSpecs = (parsedSpecs (project (findProjectEditor)) cmdList)
}

// Updating primitives

method updatePrimitives MicroBlocksModule {
	// Update primitives that have been replaced with newer versions.

	for f functions {
		for b (allBlocks (cmdList f)) {
			newPrim = (newPrimFor this (primName b))
if (notNil newPrim) { print (primName b) '->' newPrim }
			if (notNil newPrim) { setField b 'primName' newPrim }
		}
	}
	for entry scripts {
		for b (allBlocks (at entry 3)) {
			newPrim = (newPrimFor this (primName b))
if (notNil newPrim) { print (primName b) '->' newPrim }
			if (notNil newPrim) { setField b 'primName' newPrim }
		}
	}
}

method newPrimFor MicroBlocksModule oldPrim {
	if ('mbDisplay' == oldPrim) { return '[display:mbDisplay]'
	} ('mbDisplayOff' == oldPrim) { return '[display:mbDisplayOff]'
	} ('mbPlot' == oldPrim) { return '[display:mbPlot]'
	} ('mbUnplot' == oldPrim) { return '[display:mbUnplot]'
	} ('mbDrawShape' == oldPrim) { return '[display:mbDrawShape]'
	} ('mbShapeForLetter' == oldPrim) { return '[display:mbShapeForLetter]'
	} ('neoPixelSetPin' == oldPrim) { return '[display:neoPixelSetPin]'
	} ('neoPixelSend' == oldPrim) { return '[display:neoPixelSend]'
	} ('mbTiltX' == oldPrim) { return '[sensors:tiltX]'
	} ('mbTiltY' == oldPrim) { return '[sensors:tiltY]'
	} ('mbTiltZ' == oldPrim) { return '[sensors:tiltZ]'
	} ('mbTemp' == oldPrim) { return '[sensors:temperature]'
	} ('newArray' == oldPrim) { return 'newList'
	} ('fillArray' == oldPrim) { return 'fillList'
	} ('sendBroadcastSimple' == oldPrim) { return 'sendBroadcast'
	} ('split' == oldPrim) { return '[data:split]'
	}
	return nil
}

// equality

method equal MicroBlocksModule otherMod {
	// Return true if the given module has the same content as this one.

	if (moduleName != (moduleName otherMod)) { return false }
	if (variableNames != (variableNames otherMod)) { return false }
	if ((count functions) != (count (functions otherMod))) { return false }
	if ((count scripts) != (count (scripts otherMod))) { return false }

	for i (count functions) {
		if (not (functionsEqual this (at functions i) (at (functions otherMod) i))) {
			print 'function mismatch:' (functionName (at functions i))
			return false
		}
	}

	// sort script entries by position
	scriptSortFunc = (function e1 e2 {
		if ((at e1 2) == (at e2 2)) {
			return ((at e1 1) < (at e2 1)) // y's equal, sort by x
		} else {
			return ((at e1 2) < (at e2 2)) // sort by y
		}
	})
	sortedScripts1 = (sorted scripts scriptSortFunc)
	sortedScripts2 = (sorted (scripts otherMod) scriptSortFunc)

	for i (count sortedScripts1) {
		e1 = (at sortedScripts1 i)
		e2 = (at sortedScripts2 i)
		if (not (and ((at e1 1) == (at e2 1))
					 ((at e1 2) == (at e2 2))
					 ((at e1 3) == (at e2 3))
					 )) {
			print 'script mismatch' e1 e2
			return false
		}
	}
	return true
}

method functionsEqual MicroBlocksModule f1 f2 {
	if ((functionName f1) != (functionName f1)) { return false }
	if ((classIndex f1) != (classIndex f1)) { return false }
	if ((argNames f1) != (argNames f1)) { return false }
	if ((localNames f1) != (localNames f1)) { return false }
	if ((cmdList f1) != (cmdList f1)) { return false }
	if ((module f1) != (module f1)) { return false }
	return true
}
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Copyright 2019 John Maloney, Bernat Romagosa, and Jens MÃ¶nig

// MicroBlocksRuntime.gp - Runtime support for MicroBlocks
// John Maloney, April, 2017

to smallRuntime aScripter {
	if (isNil (global 'smallRuntime')) {
		setGlobal 'smallRuntime' (initialize (new 'SmallRuntime') aScripter)
	}
	return (global 'smallRuntime')
}

defineClass SmallRuntime ideVersion latestVMVersion scripter chunkIDs chunkRunning chunkStopping msgDict portName port connectionStartTime lastScanMSecs pingSentMSecs lastPingRecvMSecs recvBuf oldVarNames vmVersion boardType lastBoardDrives loggedData loggedDataNext loggedDataCount vmInstallMSecs disconnected crcDict lastRcvMSecs readFromBoard decompiler decompilerStatus blockForResultImage fileTransferMsgs fileTransferProgress fileTransfer firmwareInstallTimer recompileAll

method scripter SmallRuntime { return scripter }
method serialPortOpen SmallRuntime { return (notNil port) }
method recompileNeeded SmallRuntime { recompileAll = true }

method initialize SmallRuntime aScripter {
	scripter = aScripter
	chunkIDs = (dictionary)
	readFromBoard = false
	clearLoggedData this
	return this
}

method evalOnBoard SmallRuntime aBlock showBytes {
	if (isNil showBytes) { showBytes = false }
	if showBytes {
		bytes = (chunkBytesFor this aBlock)
		print (join 'Bytes for chunk ' id ':') bytes
		print '----------'
		return
	}
	if ('not connected' == (updateConnection this)) {
		showError (morph aBlock) (localized 'Board not connected')
		return
	}
	step scripter // save script changes if needed
	if (isNil (ownerThatIsA (morph aBlock) 'ScriptEditor')) {
		// running a block from the palette, not included in saveAllChunks
		saveChunk this aBlock
	}
	runChunk this (lookupChunkID this aBlock)
}

method stopRunningBlock SmallRuntime aBlock {
	if (isRunning this aBlock) {
		stopRunningChunk this (lookupChunkID this aBlock)
	}
}

method chunkTypeFor SmallRuntime aBlockOrFunction {
	if (isClass aBlockOrFunction 'Function') { return 3 }
	if (and
		(isClass aBlockOrFunction 'Block')
		(isPrototypeHat aBlockOrFunction)) {
			return 3
	}

	expr = (expression aBlockOrFunction)
	op = (primName expr)
	if ('whenStarted' == op) { return 4 }
	if ('whenCondition' == op) { return 5 }
	if ('whenBroadcastReceived' == op) { return 6 }
	if ('whenButtonPressed' == op) {
		button = (first (argList expr))
		if ('A' == button) { return 7 }
		if ('B' == button) { return 8 }
		return 9 // A+B
	}
	if (isClass expr 'Command') { return 1 }
	if (isClass expr 'Reporter') { return 2 }

	error 'Unexpected argument to chunkTypeFor'
}

method chunkBytesFor SmallRuntime aBlockOrFunction {
	if (isClass aBlockOrFunction 'String') { // look up function by name
		aBlockOrFunction = (functionNamed (project scripter) aBlockOrFunction)
		if (isNil aBlockOrFunction) { return (list) } // unknown function
	}
	compiler = (initialize (new 'SmallCompiler'))
	code = (instructionsFor compiler aBlockOrFunction)
	bytes = (list)
	for item code {
		if (isClass item 'Array') {
			addBytesForInstructionTo compiler item bytes
		} (isClass item 'Integer') {
			addBytesForIntegerLiteralTo compiler item bytes
		} (isClass item 'String') {
			addBytesForStringLiteral compiler item bytes
		} else {
			error 'Instruction must be an Array or String:' item
		}
	}
	return bytes
}

method showInstructions SmallRuntime aBlock {
	// Display the instructions for the given stack.

	compiler = (initialize (new 'SmallCompiler'))
	code = (instructionsFor compiler (topBlock aBlock))
	result = (list)
	firstString = true
	for item code {
		if (not (isClass item 'Array')) {
			if firstString {
				add result '--------'
				firstString = false
			}
			add result (toString item) // string literal
		} ('metadata' == (first item)) {
			if ((count (last code)) > 0) {
				add result '--------'
			}
		} ('pushLiteral' == (first item)) {
			instr = (join (at item 1) ' ' (at item 2) ' ("' (at item 3) '")')
			addWithLineNum this result instr
		} ('pushImmediate' == (first item)) {
			arg = (at item 2)
			if (1 == (arg & 1)) {
				arg = (arg >> 1) // decode integer
				if (arg >= 4194304) { arg = (arg - 8388608) }
			} (0 == arg) {
				arg = false
			} (4 == arg) {
				arg = true
			}
			addWithLineNum this result (join 'pushImmediate ' arg)
		} ('pushBigImmediate' == (first item)) {
			addWithLineNum this result 'pushBigImmediate' // don't show arg count; could be confusing
		} ('callFunction' == (first item)) {
			arg = (at item 2)
			calledChunkID = ((arg >> 8) & 255)
			argCount = (arg & 255)
			addWithLineNum this result (join 'callFunction ' calledChunkID ' ' argCount)
		} (not (isLetter (at (first item) 1))) { // operator; don't show arg count
			addWithLineNum this result (toString (first item))
		} else {
			// instruction (an array of form <cmd> <args...>)
			instr = ''
			for s item { instr = (join instr s ' ') }
			addWithLineNum this result instr item
		}
	}
	ws = (openWorkspace (global 'page') (joinStrings result (newline)))
	setTitle ws 'Instructions'
	setFont ws 'Arial' (16 * (global 'scale'))
	setExtent (morph ws) (220 * (global 'scale')) (400 * (global 'scale'))
	fixLayout ws
}

method addWithLineNum SmallRuntime aList instruction items {
	currentLine = ((count aList) + 1)
	targetLine = ''
	if (and
		(notNil items)
		(isOneOf (first items)
			'pushLiteral' 'jmp' 'jmpTrue' 'jmpFalse'
			'decrementAndJmp' 'callFunction' 'forLoop')) {
		offset = (toInteger (last items))
		targetLine = (join ' (line ' (+ currentLine 1 offset) ')')
	}
	add aList (join '' currentLine ' ' instruction targetLine)
}

method showCompiledBytes SmallRuntime aBlock {
	// Display the instruction bytes for the given stack.

	bytes = (chunkBytesFor this (topBlock aBlock))
	result = (list)
	add result (join '[' (count bytes) ' bytes]' (newline))
	for i (count bytes) {
		add result (toString (at bytes i))
		if (0 == (i % 4)) {
			add result (newline)
		} else {
			add result ' '
		}
	}
	if (and ((count result) > 0) ((newline) == (last result))) { removeLast result }
	ws = (openWorkspace (global 'page') (joinStrings result))
	setTitle ws 'Instruction Bytes'
	setFont ws 'Arial' (16 * (global 'scale'))
	setExtent (morph ws) (220 * (global 'scale')) (400 * (global 'scale'))
	fixLayout ws
}

method showCallTree SmallRuntime aBlock {
	proto = (editedPrototype aBlock)
	if (notNil proto) {
		if (isNil (function proto)) { return }
		funcName = (functionName (function proto))
	} else {
		funcName = (primName (expression aBlock))
	}

	allFunctions = (dictionary)
	for f (allFunctions (project scripter)) { atPut allFunctions (functionName f) f }

	result = (list)
	appendCallsForFunction this funcName result '' allFunctions (array funcName)

	ws = (openWorkspace (global 'page') (joinStrings result (newline)))
	setTitle ws 'Call Tree'
	setFont ws 'Arial' (16 * (global 'scale'))
	setExtent (morph ws) (400 * (global 'scale')) (400 * (global 'scale'))
	fixLayout ws
}

method appendCallsForFunction SmallRuntime funcName result indent allFunctions callers {
	func = (at allFunctions funcName)

	argCount = (count (argNames func))
	localCount = (count (localNames func))
	stackWords = (+ 3 argCount localCount)
	info = ''
	if (or (argCount > 0) (localCount > 0)) {
		info = (join info ' (')
		if (argCount > 0) {
			info = (join info argCount ' arg')
			if (argCount > 1) { info = (join info 's') }
			if (localCount > 0) { info = (join info ', ') }
		}
		if (localCount > 0) {
			info = (join info localCount ' local')
			if (localCount > 1) { info = (join info 's') }
		}
		info = (join info ')')
	}
	add result (join indent funcName info ' ' stackWords)
	indent = (join '   ' indent)

	if (isNil (cmdList func)) { return }

	processed = (dictionary)
	for cmd (allBlocks (cmdList func)) {
		op = (primName cmd)
		if (and (contains allFunctions op) (not (contains processed op))) {
			if (contains callers op) {
				add result (join indent '   ' funcName ' [recursive]')
			} else {
				appendCallsForFunction this op result indent allFunctions (copyWith callers op)
			}
			add processed op
		}
	}
}

// Decompiler tests

method testDecompiler SmallRuntime aBlock {
	topBlock = (topBlock aBlock)
	gpCode = (decompileBytecodes -1 (chunkTypeFor this topBlock) (chunkBytesFor this topBlock))
	showCodeInHand this gpCode
}

method showCodeInHand SmallRuntime gpCode {
	if (isClass gpCode 'Function') {
		block = (scriptForFunction gpCode)
	} (or (isClass gpCode 'Command') (isClass gpCode 'Reporter')) {
		block = (toBlock gpCode)
	} else {
		// decompiler didn't return something that can be represented as blocks
		return
	}
	grab (hand (global 'page')) block
	fixBlockColor block
}

method compileAndDecompile SmallRuntime aBlockOrFunction {
	if (isClass aBlockOrFunction 'Function') {
		chunkID = (first (at chunkIDs (functionName aBlockOrFunction)))
	}
	chunkType = (chunkTypeFor this aBlockOrFunction)
	bytecodes1 = (chunkBytesFor this aBlockOrFunction)
	gpCode = (decompileBytecodes chunkID chunkType bytecodes1)
	bytecodes2 = (chunkBytesFor this gpCode)
	if (bytecodes1 == bytecodes2) {
		if ((count bytecodes1) > 750) {
			print 'ok chunkType:' chunkType 'bytes:' (count bytecodes1)
		}
	} else {
		print 'FAILED! chunkType:' chunkType 'bytes in:' (count bytecodes1) 'bytes out' (count bytecodes2)
	}
}

method decompileAll SmallRuntime {
	// Called by dev menu 'decompile all' for testing.

	decompileAllExamples this
}

method decompileAllExamples SmallRuntime {
	for fn (listEmbeddedFiles) {
		if (beginsWith fn 'Examples') {
			print fn
			openProjectFromFile (findMicroBlocksEditor) (join '//' fn)
			decompileAllInProject this
		}
	}
}

method decompileAllInProject SmallRuntime {
	assignFunctionIDs this
	for aFunction (allFunctions (project scripter)) {
		compileAndDecompile this aFunction
	}
	for aBlock (sortedScripts (scriptEditor scripter)) {
		if (not (isPrototypeHat aBlock)) { // functions are handled above
			compileAndDecompile this aBlock
		}
	}
}

method analyzeAllExamples SmallRuntime {
	for fn (listEmbeddedFiles) {
		if (beginsWith fn 'Examples') {
			print fn
			openProjectFromFile (findMicroBlocksEditor) (join '//' fn)
			analyzeProject this
		}
	}
}

method analyzeProject SmallRuntime {
	totalBytes = 0
	assignFunctionIDs this
	for aFunction (allFunctions (project scripter)) {
		byteCount = (count (chunkBytesFor this aFunction))
		if (byteCount > 700) { print ' ' (functionName aFunction) byteCount }
		totalBytes += byteCount
	}
	for aBlock (sortedScripts (scriptEditor scripter)) {
		if (not (isPrototypeHat aBlock)) { // functions are handled above
			byteCount = (count (chunkBytesFor this aBlock))
			if (byteCount > 700) { print '     script' byteCount }
			totalBytes += byteCount
		}
	}
	print '  Total:' totalBytes
	print '-----------'
}

// Decompiling

method readCodeFromNextBoardConnected SmallRuntime {
	readFromBoard = true
	disconnected = false
	if ('Browser' == (platform)) {
		// in browser, cannot add the spinner before user has clicked connect icon
		inform 'Plug in the board and click the USB icon to connect.'
		return
	}
	decompilerStatus = (localized 'Plug in the board.')
	spinner = (newSpinner (action 'decompilerStatus' (smallRuntime)) (action 'decompilerDone' (smallRuntime)))
	addPart (global 'page') spinner
}

method readCodeFromBoard SmallRuntime {
	decompiler = (newDecompiler)
	waitForPing this
	decompilerStatus = (localized 'Reading project from board...')

	if ('Browser' == (platform)) {
		prompter = (findMorph 'Prompter')
		if (notNil prompter) { destroy prompter } // remove the prompt to connect board

		if (not (canReplaceCurrentProject (findMicroBlocksEditor))) {
			return // uncommon: user started writing code before connecting the board
		}

		// in browser, spinner was not added earlier
		spinner = (newSpinner (action 'decompilerStatus' (smallRuntime)) (action 'decompilerDone' (smallRuntime)))
		addPart (global 'page') spinner
	}

	sendMsg this 'getVarNamesMsg'
	lastRcvMSecs = (msecsSinceStart)
	while (((msecsSinceStart) - lastRcvMSecs) < 100) {
		processMessages this
		waitMSecs 10
	}

	sendMsg this 'getAllCodeMsg'
	lastRcvMSecs = (msecsSinceStart)
	while (((msecsSinceStart) - lastRcvMSecs) < 2000) {
		processMessages this
		doOneCycle (global 'page')
		waitMSecs 10
	}
	if (isNil decompiler) { return } // decompilation was aborted

print 'Read' (count (getField decompiler 'vars')) 'vars' (count (getField decompiler 'chunks')) 'chunks'
	proj = (decompileProject decompiler)
	decompilerStatus = (localized 'Loading project...')
	doOneCycle (global 'page')
	installDecompiledProject this proj
	readFromBoard = false
	decompiler = nil
}

method decompilerDone SmallRuntime { return (and (isNil decompiler) (not readFromBoard)) }
method decompilerStatus SmallRuntime { return decompilerStatus }

method stopDecompilation SmallRuntime {
	readFromBoard = false
	spinnerM = (findMorph 'MicroBlocksSpinner')
	if (notNil spinnerM) { removeFromOwner spinnerM }

	if (notNil decompiler) {
		decompiler = nil
		clearBoardIfConnected this true
		stopAndSyncScripts this
	}
}

method waitForPing SmallRuntime {
	// Try to get a ping back from the board. Used to ensure that the board is responding.

	endMSecs = ((msecsSinceStart) + 1000)
	lastPingRecvMSecs = 0
	while (0 == lastPingRecvMSecs) {
		if ((msecsSinceStart) > endMSecs) { return } // no response within the timeout
		sendMsg this 'pingMsg'
		processMessages this
		waitMSecs 10
	}
}

method installDecompiledProject SmallRuntime proj {
	clearBoardIfConnected this true
	setProject scripter proj
	updateLibraryList scripter
	checkForNewerLibraryVersions (project scripter) true
	restoreScripts scripter // fix block colors
	cleanUp (scriptEditor scripter)
	saveAllChunksAfterLoad this
}

method receivedChunk SmallRuntime chunkID chunkType bytecodes {
	lastRcvMSecs = (msecsSinceStart)
	if (isEmpty bytecodes) {
		print 'truncated chunk!' chunkID chunkType (count bytecodes) // shouldn't happen
		return
	}
	if (notNil decompiler) {
		addChunk decompiler chunkID chunkType bytecodes
	}
}

method receivedVarName SmallRuntime varID varName byteCount {
	lastRcvMSecs = (msecsSinceStart)
	if (notNil decompiler) {
		addVar decompiler varID varName
	}
}

// HTTP server support

method readVarsFromBoard SmallRuntime client {
	if (notNil decompiler) { return }

	// pretend to be a decompiler to collect variable names
	decompiler = client
	waitForPing this
	sendMsg this 'getVarNamesMsg'
	lastRcvMSecs = (msecsSinceStart)
	while (((msecsSinceStart) - lastRcvMSecs) < 50) {
		processMessages this
		waitMSecs 10
	}
	// clear decompiler
	decompiler = nil
}


// chunk management

method syncScripts SmallRuntime {
	// Called by scripter when anything changes.

	if (isNil port) { return }
	if (notNil decompiler) { return }

	// force re-save of any functions in the scripting area
	for aBlock (sortedScripts (scriptEditor scripter)) {
		if (isPrototypeHat aBlock) {
			fName = (functionName (function (editedPrototype aBlock)))
			entry = (at chunkIDs fName nil)
			if (notNil entry) {
				// record that function is in scripting area so must be checked for changes
				atPut entry 5 true
			}
		}
	}

	saveAllChunks this false
}

method lookupChunkID SmallRuntime key {
	// If the given block or function name has been assigned a chunkID, return it.
	// Otherwise, return nil.

	entry = (at chunkIDs key nil)
	if (isNil entry) { return nil }
	return (first entry)
}

method removeObsoleteChunks SmallRuntime {
	// Remove obsolete chunks. Chunks become obsolete when they are deleted or inserted into
	// a script so they are no longer a stand-alone chunk. Functions become obsolete when
	// they are deleted or the library containing them is deleted.

	for k (keys chunkIDs) {
		isObsolete = false
		if (isClass k 'Block') {
			owner = (owner (morph k))
			isObsolete = (or
				(isNil owner)
				(isNil (handler owner))
				(not (isAnyClass (handler owner) 'Hand' 'ScriptEditor' 'BlocksPalette')))
		} (isClass k 'String') {
			isObsolete = (isNil (functionNamed (project scripter) k))
		}
		if isObsolete {
			deleteChunkFor this k
		}
	}
}

method unusedChunkID SmallRuntime {
	// Return an unused chunkID.

	inUse = (dictionary)
	for entry (values chunkIDs) {
		add inUse (first entry) // the chunk ID is first element of entry
	}
	for i 256 {
		id = (i - 1)
		if (not (contains inUse id)) { return id }
	}
	error 'Too many code chunks (functions and scripts). Max is 256).'
}

method ensureChunkIdFor SmallRuntime aBlock {
	// Return the chunkID for the given block. Functions are handled by assignFunctionIDs.
	// If necessary, register the block in the chunkIDs dictionary.

	entry = (at chunkIDs aBlock nil)
	if (isNil entry) {
		id = (unusedChunkID this)
		entry = (array id nil (chunkTypeFor this aBlock) '' false)
		atPut chunkIDs aBlock entry // block -> (<id>, <crc>, <chunkType>, <lastSrc>, <functionMayHaveChanged>)
	}
	return (first entry)
}

method chunkEntryForBlock SmallRuntime aBlock {
	return (at chunkIDs aBlock nil)
}

method assignFunctionIDs SmallRuntime {
	// Ensure that there is a chunk ID for every user-defined function.
	// This must be done before generating any code to allow for recursive calls.

	for func (allFunctions (project scripter)) {
		fName = (functionName func)
		if (not (contains chunkIDs fName)) {
			id = (unusedChunkID this)
			entry = (array id nil (chunkTypeFor this func) '' true)
			atPut chunkIDs fName entry // fName -> (<id>, <crc>, <chunkType>, <lastSrc>, <functionMayHaveChanged>)
		}
	}
}

method functionNameForID SmallRuntime chunkID {
	assignFunctionIDs this
	for pair (sortedPairs chunkIDs) {
		id = (first (first pair))
		if (id == chunkID) { return (last pair) } // return function name
	}
	return (join 'f' chunkID)
}

method deleteChunkFor SmallRuntime key {
	if (and (isClass key 'Block') (isPrototypeHat key)) {
		key = (functionName (function (editedPrototype key)))
	}
	entry = (at chunkIDs key nil)
	if (and (notNil entry) (notNil port)) {
		chunkID = (first entry)
		sendMsgSync this 'deleteChunkMsg' chunkID
		remove chunkIDs key
	}
}

method stopAndSyncScripts SmallRuntime alreadyStopped {
	// Stop everything. Sync and verify scripts with the board using chunk CRC's.

	removeHint (global 'page')
	if (and (notNil port) (true != alreadyStopped)) {
		sendStopAll this
		softReset this
	}
	clearRunningHighlights this
	doOneCycle (global 'page')

	if (shiftKeyDown (keyboard (global 'page'))) {
		recompileAll = true
	}
	suspendCodeFileUpdates this
	saveAllChunks this true
	resumeCodeFileUpdates this
}

method softReset SmallRuntime {
	// Stop everyting, clear memory, and reset the I/O pins.

	sendMsg this 'systemResetMsg' // send the reset message
}

method isWebSerial SmallRuntime {
	return (and ('Browser' == (platform)) (browserHasWebSerial))
}

method webSerialConnect SmallRuntime action {
	if ('disconnect' == action) {
		if ('boardie' != portName) {
			stopAndSyncScripts this
			sendStartAll this
		} else {
			browserCloseBoardie
		}
		closeSerialPort 1
		portName = nil
		port = nil
	} ('open Boardie' == action) {
		browserOpenBoardie
		disconnected = false
		connectionStartTime = (msecsSinceStart)
		portName = 'boardie'
		port = 1
	} else {
		if (and ('Browser' == (platform)) (not (or (browserIsChromeOS) (browserHasWebSerial)))) { // running in a browser w/o WebSerial (or it is not enabled)
			inform (localized 'Only recent Chrome and Edge browsers support WebSerial.')
			return
		}
		openSerialPort 'webserial' 115200
		disconnected = false
		connectionStartTime = (msecsSinceStart)
		portName = 'webserial'
		port = 1
	}
}

method selectPort SmallRuntime {
	if (isNil disconnected) { disconnected = false }

	if ('Browser' == (platform)) {
		menu = (menu 'Connect' (action 'webSerialConnect' this) true)
		if (and (isNil port) ('boardie' != portName)) {
			if (browserHasWebSerial) {
				addItem menu 'connect'
			}
			addItem menu 'open Boardie'
		} else {
			addItem menu 'disconnect'
		}
		popUpAtHand menu (global 'page')
		return
	}

	portList = (portList this)
	menu = (menu 'Connect' (action 'setPort' this) true)
	if (or disconnected (devMode)) {
		for s portList {
			if (or (isNil port) (portName != s)) { addItem menu s }
		}
		if (isEmpty portList) {
			addItem menu 'Connect board and try again'
		}
	}
	if (and (devMode) ('Browser' != (platform))) {
		addItem menu 'other...'
	}
	if (notNil port) {
		addLine menu
		if (notNil portName) {
			addItem menu (join 'disconnect (' portName ')')
		} else {
			addItem menu 'disconnect'
		}
	}
	popUpAtHand menu (global 'page')
}

method portList SmallRuntime {
	portList = (list)
	if ('Win' == (platform)) {
		portList = (list)
		for pname (listSerialPorts) {
			blackListed = (or
				((containsSubString pname 'Bluetooth') > 0)
				((containsSubString pname '(COM1)') > 0)
				((containsSubString pname 'Intel(R) Active Management') > 0))
			if (not blackListed) {
				add portList pname
			}
		}
	} ('Browser' == (platform)) {
		listSerialPorts // first call triggers callback
		waitMSecs 5
		portList = (list)
		for portName (listSerialPorts) {
			if (not (beginsWith portName '/dev/tty.')) {
				add portList portName
			}
		}
	} else {
		for fn (listFiles '/dev') {
			if (or	(notNil (nextMatchIn 'usb' (toLowerCase fn) )) // MacOS
					(notNil (nextMatchIn 'acm' (toLowerCase fn) ))) { // Linux
				add portList (join '/dev/' fn)
			}
		}
		if ('Linux' == (platform)) {
			// add pseudoterminal
			ptyName = (readFile '/tmp/ublocksptyname')
			if (notNil ptyName) {
				add portList ptyName
			}
		}
		// Mac OS lists a port as both cu.<name> and tty.<name>
		for s (copy portList) {
			if (beginsWith s '/dev/tty.') {
				if (contains portList (join '/dev/cu.' (substring s 10))) {
					remove portList s
				}
			}
		}
	}
	return portList
}

method setPort SmallRuntime newPortName {
	if (beginsWith newPortName 'Connect board and try again') { return }
	if (beginsWith newPortName 'disconnect') {
		if (notNil port) {
			stopAndSyncScripts this
			sendStartAll this
		}
		disconnected = true
		closePort this
		updateIndicator (findMicroBlocksEditor)
		return
	}
	if ('other...' == newPortName) {
		newPortName = (freshPrompt (global 'page') 'Port name?' (localized 'none'))
		if ('' == newPortName) { return }
	}
	closePort this
	disconnected = false

	// the prompt answer 'none' is entered by the user in the current language
	if (or (isNil newPortName) (newPortName == (localized 'none'))) {
		portName = nil
	} else {
		portName = newPortName
		openPortAndSendPing this
	}
	updateIndicator (findMicroBlocksEditor)
}

method closePort SmallRuntime {
	// Close the serial port and clear info about the currently connected board.

	if (notNil port) { closeSerialPort port }
	port = nil
	vmVersion = nil
	boardType = nil

	// remove running highlights and result bubbles when disconnected
	clearRunningHighlights this
}

method enableAutoConnect SmallRuntime success {
	closeAllDialogs (findMicroBlocksEditor)
	if ('Browser' == (platform)) {
		// In the browser, the serial port must be closed and re-opened after installing
		// firmware on an ESP board. Not sure why. Adding a delay did not help.
		closePort this
		closeSerialPort 1 // make sure port is really disconnected
		disconnected = true
		if success { otherReconnectMessage this }
		return
	}
	disconnected = false
	stopAndSyncScripts this
}

method tryToInstallVM SmallRuntime {
	// Invite the user to install VM if we see a new board drive and are not able to connect to
	// it within a few seconds. Remember the last set of boardDrives so we don't keep asking.
	// Details: On Mac OS (at least), 3-4 seconds elapse between when the board drive appears
	// and when the USB-serial port appears. Thus, the IDE waits a bit to see if it can connect
	// to the board before prompting the user to install the VM to avoid spurious prompts.

	if (and (notNil vmInstallMSecs) ((msecsSinceStart) > vmInstallMSecs)) {
		vmInstallMSecs = nil
		if (and (notNil port) (isOpenSerialPort port)) { return }
		ok = (confirm (global 'page') nil (join
			(localized 'The board is not responding.') (newline)
			(localized 'Try to Install MicroBlocks on the board?')))
		if ok { installVM this }
		return
	}

	boardDrives = (collectBoardDrives this)
	if (lastBoardDrives == boardDrives) { return }
	lastBoardDrives = boardDrives
	if (isEmpty boardDrives) {
		vmInstallMSecs = nil
	} else {
		vmInstallMSecs = ((msecsSinceStart) + 5000) // prompt to install VM in a few seconds
	}
}

method connectedToBoard SmallRuntime {
    pingTimeout = 8000
    if (or (isNil port) (not (isOpenSerialPort port))) { return false }
 	if (or (isNil lastPingRecvMSecs) (lastPingRecvMSecs == 0)) { return false }
    return (((msecsSinceStart) - lastPingRecvMSecs) < pingTimeout)
}

method updateConnection SmallRuntime {
	pingSendInterval = 2000 // msecs between pings
	pingTimeout = 8000
	if (isNil pingSentMSecs) { pingSentMSecs = 0 }
	if (isNil lastPingRecvMSecs) { lastPingRecvMSecs = 0 }
	if (isNil disconnected) { disconnected = false }

	if (notNil decompiler) { return 'connected' }
	if disconnected { return 'not connected' }

	// handle connection attempt in progress
	if (notNil connectionStartTime) { return (tryToConnect this) }

	// if port is not open, try to reconnect or find a different board
	if (or (isNil port) (not (isOpenSerialPort port))) {
		clearRunningHighlights this
		closePort this
		if ('Browser' == (platform)) {
			portName = nil // clear 'boardie' when boardie is closed with power button
			return 'not connected' // user must initiate connection attempt
		}
		return (tryToConnect this)
	}

	// if the port is open and it is time, send a ping
	now = (msecsSinceStart)
	if ((now - pingSentMSecs) > pingSendInterval) {
		if ((now - pingSentMSecs) > 5000) {
			// it's been a long time since we sent a ping; laptop may have been asleep
			// set lastPingRecvMSecs to N seconds into future to suppress warnings
			lastPingRecvMSecs = now
		}
		sendMsg this 'pingMsg'
		pingSentMSecs = now
		return 'connected'
	}

	msecsSinceLastPing = (now - lastPingRecvMSecs)
	if (msecsSinceLastPing < pingTimeout) {
		// got a ping recently: we're connected
		return 'connected'
	} else {
		// ping timeout: close port to force reconnection
		print 'Lost communication to the board'
		clearRunningHighlights this
		if (not (isWebSerial this)) { closePort this }
		return 'not connected'
	}
}

method justConnected SmallRuntime {
	// Called when a board has just connected (browser or stand-alone).

	print 'Connected to' portName
	connectionStartTime = nil
	vmVersion = nil
	sendMsgSync this 'getVersionMsg'
	sendStopAll this
	clearRunningHighlights this
	setDefaultSerialDelay this
	abortFileTransfer this
	processMessages this // process incoming version message
	if readFromBoard {
		readFromBoard = false
		readCodeFromBoard this
	} else {
		codeReuseDisabled = false // set this to false to attempt to reuse code on board
		if (or codeReuseDisabled (isEmpty chunkIDs) (not (boardHasSameProject this))) {
			if (not codeReuseDisabled) { print 'Full download' }
			clearBoardIfConnected this
		} else {
			print 'Incremental download' vmVersion boardType
		}
		recompileAll = true
		stopAndSyncScripts this true
		softReset this
	}
}

method tryToConnect SmallRuntime {
	// Called when connectionStartTime is not nil, indicating that we are trying
	// to establish a connection to a board the current serial port.
	if (and
		(not (hasUserCode (project (findProjectEditor))))
		(autoDecompileEnabled (findMicroBlocksEditor))
	) {
		readFromBoard = true
	}

	if (and (isWebSerial this) ('boardie' != portName)) {
		if (isOpenSerialPort 1) {
			portName = 'webserial'
			port = 1
			waitForPing this // wait up to 1 second for ping
			pingSentMSecs = (msecsSinceStart)
			justConnected this
			return 'not connected' // don't make circle green until successful ping
		} else {
			portName = nil
			port = nil
			return 'not connected'
		}
	}

	connectionAttemptTimeout = 5000 // milliseconds

	// check connection status only N times/sec
	now = (msecsSinceStart)
	if (isNil lastScanMSecs) { lastScanMSecs = 0 }
	msecsSinceLastScan = (now - lastScanMSecs)
	if (and (msecsSinceLastScan > 0) (msecsSinceLastScan < 20)) { return 'not connected' }
	lastScanMSecs = now

	if (notNil connectionStartTime) {
		sendMsg this 'pingMsg'
		processMessages this
		if (lastPingRecvMSecs != 0) { // got a ping; we're connected!
			justConnected this
			return 'connected'
		}
		if (now < connectionStartTime) { connectionStartTime = now } // clock wrap
		if ((now - connectionStartTime) < connectionAttemptTimeout) { return 'not connected' } // keep trying
	}

	closePort this
	connectionStartTime = nil

	if ('Browser' == (platform)) {  // disable autoconnect on ChromeOS
		disconnected = true
		return 'not connected'
	}

	portNames = (portList this)
	if (isEmpty portNames) { return 'not connected' } // no ports available

	// try the port following portName in portNames
	// xxx to do: after trying all the ports, call tryToInstallVM (but only if portNames isn't empty)
	i = 1
	if (notNil portName) {
		i = (indexOf portNames portName)
		if (isNil i) { i = 0 }
		i = ((i % (count portNames)) + 1)
	}
	portName = (at portNames i)
	openPortAndSendPing this
}

method openPortAndSendPing SmallRuntime {
	// Open port and send ping request
	closePort this // ensure port is closed
	connectionStartTime = (msecsSinceStart)
	ensurePortOpen this // attempt to reopen the port
	if (notNil port) {
		// discard any random bytes in buffer
		readSerialPort port true
	}
	lastPingRecvMSecs = 0
	sendMsg this 'pingMsg'
}

method ideVersion SmallRuntime { return ideVersion }
method latestVmVersion SmallRuntime { return latestVmVersion }

method ideVersionNumber SmallRuntime {
	// Return the version number portion of the version string (i.e. just digits and periods).

	for i (count ideVersion) {
		ch = (at ideVersion i)
		if (not (or (isDigit ch) ('.' == ch))) {
			return (substring ideVersion 1 (i - 1))
		}
	}
	return ideVersion
}

method readVersionFile SmallRuntime {
	// defaults in case version file is missing (which shouldn't happen)
	ideVersion = '0.0.0'
	latestVmVersion = 0

	data = (readEmbeddedFile 'versions')
	if (isNil data) { data = (readFile 'runtime/versions') }
	if (notNil data) {
		for s (lines data) {
			if (beginsWith s 'IDE ') { ideVersion = (substring s 5) }
			if (beginsWith s 'VM ') { latestVmVersion = (toNumber (substring s 4)) }
		}
	}
}

method showAboutBox SmallRuntime {
	vmVersionReport = (newline)
	if (notNil vmVersion) {
		vmVersionReport = (join ' (Firmware v' vmVersion ')' (newline))
	}
	(inform (global 'page') (join
		'MicroBlocks v' (ideVersion this) vmVersionReport (newline)
		(localized 'by') ' John Maloney, Bernat Romagosa, & Jens MÃ¶nig.' (newline)
		(localized 'Created with GP') ' (gpblocks.org)' (newline) (newline)
		(localized 'More info at http://microblocks.fun')) 'About MicroBlocks')
}

method checkBoardType SmallRuntime {
	if (and (isNil boardType) (notNil port)) {
		vmVersion = nil
		getVersion this
	}
	return boardType
}

method getVersion SmallRuntime {
	sendMsg this 'getVersionMsg'
}

method extractVersionNumber SmallRuntime versionString {
	// Return the version number from the versionString.
	// Version string format: vNNN, where NNN is one or more decimal digits,
	// followed by non-digits characters that are ignored. Ex: 'v052a micro:bit'

	words = (words (substring versionString 2))
	if (isEmpty words) { return -1 }
	result = 0
	for ch (letters (first words)) {
		if (not (isDigit ch)) { return result }
		digit = ((byteAt ch 1) - (byteAt '0' 1))
		result = ((10 * result) + digit)
	}
	return result
}

method extractBoardType SmallRuntime versionString {
	// Return the board type from the versionString.
	// Version string format: vNNN [boardType]

	words = (words (substring versionString 2))
	if (isEmpty words) { return -1 }
	return (joinStrings (copyWithout words (at words 1)) ' ')
}

method versionReceived SmallRuntime versionString {
	if (isNil versionString) { return } // bad version message
	if (isNil vmVersion) { // first time: record and check the version number
		vmVersion = (extractVersionNumber this versionString)
		boardType = (extractBoardType this versionString)
		checkVmVersion this
		installBoardSpecificBlocks this
	} else { // not first time: show the version number
		inform (global 'page') (join 'MicroBlocks Virtual Machine ' versionString) 'Firmware version'
	}
}

method checkVmVersion SmallRuntime {
	// prevent version check from running while the decompiler is working
	if (not readFromBoard) { return }
	if ((latestVmVersion this) > vmVersion) {
		ok = (confirm (global 'page') nil (join
			(localized 'The MicroBlocks in your board is not current')
			' (v' vmVersion ' vs. v' (latestVmVersion this) ').' (newline)
			(localized 'Try to update MicroBlocks on the board?')))
		if ok { installVM this }
	}
}

method installBoardSpecificBlocks SmallRuntime {
	// installs default blocks libraries for each type of board.

	if (or readFromBoard (notNil decompiler)) { return } // don't load libraries while decompiling
	if (hasUserCode (project scripter)) { return } // don't load libraries if project has user code
	if (boardLibAutoLoadDisabled (findMicroBlocksEditor)) { return } // board lib autoload has been disabled by user

	if ('Citilab ED1' == boardType) {
		importEmbeddedLibrary scripter 'ED1 Buttons'
		importEmbeddedLibrary scripter 'Tone'
		importEmbeddedLibrary scripter 'Basic Sensors'
		importEmbeddedLibrary scripter 'LED Display'
	} (isOneOf boardType 'micro:bit' 'micro:bit v2' 'Calliope' 'Mbits') {
		importEmbeddedLibrary scripter 'Basic Sensors'
		importEmbeddedLibrary scripter 'LED Display'
	} ('CircuitPlayground' == boardType) {
		importEmbeddedLibrary scripter 'Circuit Playground'
		importEmbeddedLibrary scripter 'Basic Sensors'
		importEmbeddedLibrary scripter 'NeoPixel'
		importEmbeddedLibrary scripter 'Tone'
	} ('M5Stack-Core' == boardType) {
		importEmbeddedLibrary scripter 'LED Display'
		importEmbeddedLibrary scripter 'Tone'
		importEmbeddedLibrary scripter 'TFT'
		importEmbeddedLibrary scripter 'HTTP client'
	} ('ESP8266' == boardType) {
		importEmbeddedLibrary scripter 'HTTP client'
	} ('IOT-BUS' == boardType) {
		importEmbeddedLibrary scripter 'LED Display'
		importEmbeddedLibrary scripter 'TFT'
		importEmbeddedLibrary scripter 'touchScreenPrims'
	} ('ESP32' == boardType) {
		importEmbeddedLibrary scripter 'HTTP client'
	} ('TTGO RP2040' == boardType) {
		importEmbeddedLibrary scripter 'LED Display'
	} ('Pico:ed' == boardType) {
		importEmbeddedLibrary scripter 'LED Display'
	} ('Wukong2040' == boardType) {
		importEmbeddedLibrary scripter 'WuKong2040'
	} ('Databot' == boardType) {
		importEmbeddedLibrary scripter 'Databot'
	}
}

method clearBoardIfConnected SmallRuntime doReset {
	if (notNil port) {
		sendStopAll this
		if doReset { softReset this }
		sendMsgSync this 'deleteAllCodeMsg' // delete all code from board
	}
	clearVariableNames this
	clearRunningHighlights this
	chunkIDs = (dictionary)
}

method sendStopAll SmallRuntime {
	sendMsg this 'stopAllMsg'
	clearRunningHighlights this
}

method sendStartAll SmallRuntime {
	step scripter // save script changes if needed
	sendMsg this 'startAllMsg'
}

// Saving and verifying

method reachableFunctions SmallRuntime {
	// Not currently used. This function finds all the functions in a project that
	// are called explicitly. This might be used to prune unused library functions
	// when downloading a project. However, it does not find dynamic calls that us
	// the "call" primitive, so it is a bit risky.

	proj = (project scripter)
	todo = (list)
	result = (dictionary)

	for aBlock (sortedScripts (scriptEditor scripter)) {
		if (isPrototypeHat aBlock) {
			// todo: add function name to todo list
		} else {
			add todo aBlock
		}
	}
	while (notEmpty todo) {
		blockOrFuncName = (removeFirst todo)
		expr = nil
		if (isClass blockOrFuncName 'Block') {
			expr = (expression blockOrFuncName)
		} (isClass blockOrFuncName 'String') {
			func = (functionNamed proj blockOrFuncName)
			if (notNil func) { expr = (cmdList func) }
		}
		if (notNil expr) {
			for b (allBlocks expr) {
				op = (primName b)
				if (and (not (contains result op)) (notNil (functionNamed proj op))) {
					add result op
					add todo op
				}
			}
		}
	}
	print (count result) 'reachable functions:'
	for fName (keys result) { print '  ' fName }
}

method suspendCodeFileUpdates SmallRuntime { sendMsgSync this 'extendedMsg' 2 (list) }
method resumeCodeFileUpdates SmallRuntime { sendMsg this 'extendedMsg' 3 (list) }

method saveAllChunksAfterLoad SmallRuntime {
	if (not (connectedToBoard this)) { return }
	suspendCodeFileUpdates this
	saveAllChunks this true
	resumeCodeFileUpdates this
}

method saveAllChunks SmallRuntime checkCRCs {
	// Save the code for all scripts and user-defined functions.

	if (isNil checkCRCs) { checkCRCs = true }
	if (not (connectedToBoard this)) { return }

	setCursor 'wait'

	t = (newTimer)
	editor = (findMicroBlocksEditor)
	totalScripts = (
		(count (allFunctions (project scripter))) +
		(count (sortedScripts (scriptEditor scripter))))
	progressInterval = (max 1 (floor (totalScripts / 20)))
	processedScripts = 0
	skipHiddenFunctions = true
	if (saveVariableNames this) { recompileAll = true }
	if recompileAll {
		// Clear the source code field of all chunk entries to force script recompilation
		// and possible re-download since variable offsets have changed.
		suspendCodeFileUpdates this
		for entry (values chunkIDs) {
			atPut entry 4 ''
			atPut entry 5 true
		}
		skipHiddenFunctions = false
	}
	assignFunctionIDs this
	removeObsoleteChunks this

	functionsSaved = 0
	for aFunction (allFunctions (project scripter)) {
		if (saveChunk this aFunction skipHiddenFunctions) {
			functionsSaved += 1
			if (0 == (functionsSaved % progressInterval)) {
				showDownloadProgress editor 3 (processedScripts / totalScripts)
			}
		}
		if (not (connectedToBoard this)) { return } // connection closed
		processedScripts += 1
	}
	if (functionsSaved > 0) { print 'Downloaded' functionsSaved 'functions to board' (join '(' (msecSplit t) ' msecs)') }

	scriptsSaved = 0
	for aBlock (sortedScripts (scriptEditor scripter)) {
		if (not (isPrototypeHat aBlock)) { // skip function def hat; functions get saved above
			if (saveChunk this aBlock skipHiddenFunctions) {
				scriptsSaved += 1
				if (0 == (scriptsSaved % progressInterval)) {
					showDownloadProgress editor 3 (processedScripts / totalScripts)
				}
			}
			if (not (connectedToBoard this)) { return } // connection closed
		}
		processedScripts += 1
	}
	if (scriptsSaved > 0) { print 'Downloaded' scriptsSaved 'scripts to board' (join '(' (msecSplit t) ' msecs)') }

	recompileAll = false
	if checkCRCs { verifyCRCs this }
	resumeCodeFileUpdates this
	showDownloadProgress editor 3 1

	setCursor 'default'
}

method forceSaveChunk SmallRuntime aBlockOrFunction {
	// Save the chunk for the given block or function even if it was previously saved.

	if (contains chunkIDs aBlockOrFunction) {
		// clear the old CRC and source to force re-save
		atPut (at chunkIDs aBlockOrFunction) 2 nil // clear the old CRC
		atPut (at chunkIDs aBlockOrFunction) 4 '' // clear the old source
	}
	saveChunk this aBlockOrFunction false
}

method sourceForChunk SmallRuntime aBlockOrFunction {
	pp = (new 'PrettyPrinter')
	source = ''
	if (isClass aBlockOrFunction 'Function') {
		source = (prettyPrintFunction pp aBlockOrFunction)
	} else {
		expr = (expression aBlockOrFunction)
		if (isClass expr 'Reporter') {
			source = (prettyPrint pp expr)
		} else {
			source = (prettyPrintList pp expr)
		}
	}
	return source
}

method saveChunk SmallRuntime aBlockOrFunction skipHiddenFunctions {
	// Save the given script or function as an executable code "chunk".
	// Also save the source code (in GP format) and the script position.

	if (isNil skipHiddenFunctions) { skipHiddenFunctions = true } // optimize by default

	pp = (new 'PrettyPrinter')
	if (isClass aBlockOrFunction 'String') {
		aBlockOrFunction = (functionNamed (project scripter) aBlockOrFunction)
		if (isNil aBlockOrFunction) { return false } // unknown function
	}
	if (isClass aBlockOrFunction 'Function') {
		functionName = (functionName aBlockOrFunction)
		chunkID = (lookupChunkID this functionName)
		entry = (at chunkIDs functionName)
		if (and skipHiddenFunctions (not (at entry 5))) { return false } // function is not in scripting area so has not changed
		atPut entry 5 false
		currentSrc = (prettyPrintFunction pp aBlockOrFunction)
	} else {
		expr = (expression aBlockOrFunction)
		if (isClass expr 'Reporter') {
			currentSrc = (prettyPrint pp expr)
		} else {
			currentSrc = (prettyPrintList pp expr)
		}
		chunkID = (ensureChunkIdFor this aBlockOrFunction)
		entry = (at chunkIDs aBlockOrFunction)
		if ((at entry 3) != (chunkTypeFor this aBlockOrFunction)) {
			// user changed A/B/A+B button hat type with menu
			atPut entry 3 (chunkTypeFor this aBlockOrFunction)
			atPut entry 4 '' // clear lastSrc to force save
		}
	}

	if (currentSrc == (at entry 4)) { return false } // source hasn't changed; save not needed
	atPut entry 4 currentSrc // remember the source of the code we're about to save

	// save the binary code for the chunk
	chunkType = (chunkTypeFor this aBlockOrFunction)
	chunkBytes = (chunkBytesFor this aBlockOrFunction)
	data = (list chunkType)
	addAll data chunkBytes
	if ((count data) > 1000) {
		if (isClass aBlockOrFunction 'Function') {
			inform (global 'page') (join
				(localized 'Function "') (functionName aBlockOrFunction)
				(localized '" is too large to send to board.'))
		} else {
			showError (morph aBlockOrFunction) (localized 'Script is too large to send to board.')
		}
		return false
	}

	// don't save the chunk if its CRC has not changed unless is a button or broadcast
	// hat because the CRC does not reflect changes to the button or broadcast name
	crcOptimization = true
	if (isClass aBlockOrFunction 'Block') {
		op = (primName (expression aBlockOrFunction))
		crcOptimization = (not (isOneOf op 'whenButtonPressed' 'whenBroadcastReceived'))
	}
	if (and crcOptimization ((at entry 2) == (computeCRC this chunkBytes))) {
		return false
	}

	restartChunk = (and (isClass aBlockOrFunction 'Block') (isRunning this aBlockOrFunction))

	// Note: micro:bit v1 misses chunks if time window is over 10 or 15 msecs
	if (((msecsSinceStart) - lastPingRecvMSecs) < 10) {
		sendMsg this 'chunkCodeMsg' chunkID data
		sendMsg this 'pingMsg'
	} else {
		sendMsgSync this 'chunkCodeMsg' chunkID data
	}
	processMessages this
	atPut entry 2 (computeCRC this chunkBytes) // remember the CRC of the code we just saved

	// restart the chunk if it was running
	if restartChunk {
		stopRunningChunk this chunkID
		waitForResponse this
		runChunk this chunkID
		waitForResponse this
	}
	return true
}

method computeCRC SmallRuntime chunkData {
	// Return the CRC for the given compiled code.

	crc = (crc (toBinaryData (toArray chunkData)))

	// convert crc to a 4-byte array
	result = (newArray 4)
	for i 4 { atPut result i (digitAt crc i) }
	return result
}

method verifyCRCs SmallRuntime {
	// Check that the CRCs of the chunks on the board match the ones in the IDE.
	// Resend the code of any chunks whose CRC's do not match.

	if (not (connectedToBoard this)) { return }

	// For testing: control type of CRC collection (default: forceIndividual = false)
	// collectCRCsIndividually is slower and less reliable than collectCRCsBulk but since
	// it works incrementally on the board it interferes less with real-time music performance.
	forceIndividual = false

	// collect CRCs from the board
	crcDict = (dictionary)
	if (and (notNil vmVersion) (vmVersion >= 159) (not forceIndividual)) {
		collectCRCsBulk this
	} else {
		collectCRCsIndividually this
	}

	// build dictionaries:
	//  ideChunks: maps chunkID -> block or functionName
	//  crcForChunkID: maps chunkID -> CRC
	ideChunks = (dictionary)
	crcForChunkID = (dictionary)
	for pair (sortedPairs chunkIDs) {
		id = (first (first pair))
		key = (last pair)
		if (and (isClass key 'String') (isNil (functionNamed (project scripter) key))) {
			remove chunkIDs key // remove reference to deleted function (rarely needed)
		} else {
			atPut ideChunks id (last pair)
			atPut crcForChunkID id (at (first pair) 2)
		}
	}

	editor = (findMicroBlocksEditor)
	totalCount = ((count crcDict) + (count ideChunks))
	processedCount = 0

	// process CRCs
	for chunkID (keys crcDict) {
		sourceItem = (at ideChunks chunkID)
		if (and (notNil sourceItem) ((at crcDict chunkID) != (at crcForChunkID chunkID))) {
			print 'CRC mismatch; resaving chunk:' chunkID
			forceSaveChunk this sourceItem
			showDownloadProgress editor 3 (processedCount / totalCount)
		}
		processedCount += 1
	}

	// check for missing chunks
	for chunkID (keys ideChunks) {
		if (not (contains crcDict chunkID)) {
			print 'Resaving missing chunk:' chunkID
			sourceItem = (at ideChunks chunkID)
			forceSaveChunk this sourceItem
			showDownloadProgress editor 3 (processedCount / totalCount)
		}
		processedCount += 1
	}
	showDownloadProgress editor 3 1
}

method boardHasSameProject SmallRuntime {
	// Return true if the board appears to have the same project as the IDE.

	if (not (connectedToBoard this)) { return false }

	// update chunkIDs dictionary for script/function additions or removals while disconnected
	assignFunctionIDs this
	for aBlock (sortedScripts (scriptEditor scripter)) {
		if (not (isPrototypeHat aBlock)) { // skip function def hat; functions get IDs above
			ensureChunkIdFor this aBlock
		}
	}

	// collect CRCs from the board
	crcDict = (dictionary)
	collectCRCsBulk this

	// build dictionaries:
	//  ideChunks: chunkID -> block or functionName
	//  crcForChunkID: chunkID -> CRC
	ideChunks = (dictionary)
	crcForChunkID = (dictionary)
	for pair (sortedPairs chunkIDs) {
		key = (last pair)
		chunkID = (at (first pair) 1)
		crc = (at (first pair) 2)
		atPut ideChunks chunkID key
		atPut crcForChunkID chunkID crc
	}

	// count matching chunks
	matchCount = 0
	for chunkID (keys crcDict) {
		entry = (at ideChunks chunkID)
		if (and (notNil entry) ((at crcDict chunkID) == (at crcForChunkID chunkID))) {
			matchCount += 1
		}
	}

	// count chunks missing from the board
	missingCount = 0
	for chunkID (keys ideChunks) {
		if (not (contains crcDict chunkID)) {
			missingCount += 1
		}
	}

	return (matchCount >= missingCount)
}

method collectCRCsIndividually SmallRuntime {
	// Collect the CRC's from all chunks on the board by requesting them individually

	crcDict = (dictionary)

	// request a CRC for every chunk
	for entry (values chunkIDs) {
		sendMsg this 'getChunkCRCMsg' (first entry)
		processMessages this
	}

	// if there are any chunks, wait for first CRC to arrive
	if ((count chunkIDs) > 0) {
		timeoutFirstCRC = 4000 // max time to wait for first CRC
		waitStartT = (msecsSinceStart)
		while (and
			(isEmpty crcDict)
			(((msecsSinceStart) - waitStartT) < timeoutFirstCRC)) {
				// wait for the first CRC to arrive
				processMessages this
				waitMSecs 10
		}
	}

	timeout = 120
	lastRcvMSecs = (msecsSinceStart)
	while (((msecsSinceStart) - lastRcvMSecs) < timeout) {
		processMessages this
		waitMSecs 10
	}
}

method crcReceived SmallRuntime chunkID chunkCRC {
	// Received an individual CRC message from board.
	// Record the CRC for the given chunkID.

	lastRcvMSecs = (msecsSinceStart)
	if (notNil crcDict) {
		atPut crcDict chunkID chunkCRC
	}
}

method collectCRCsBulk SmallRuntime {
	// Collect the CRC's from all chunks on the board via a bulk CRC request.

	crcDict = nil

	// request CRCs for all chunks on board
	sendMsgSync this 'getAllCRCsMsg'

	// wait until crcDict is filled in or timeout
	startT = (msecsSinceStart)
	while (and (isNil crcDict) (((msecsSinceStart) - startT) < 2000)) {
		processMessages this
		waitMSecs 5
	}

	if (isNil crcDict) { crcDict = (dictionary) } // timeout
}

method allCRCsReceived SmallRuntime data {
	// Received a message from baord with the CRCs of all chunks.
	// Create crcDict and record the (possibly empty) list of CRCs.
	// Each CRC record is 5 bytes: <chunkID (one byte)> <CRC (four bytes)>

	crcDict = (dictionary)
	byteCount = (count data)
	i = 1
	while (i <= (byteCount - 4)) {
		chunkID = (at data i)
		chunkCRC = (copyFromTo data (i + 1) (i + 4))
		atPut crcDict chunkID chunkCRC
		i += 5
	}
}

method saveVariableNames SmallRuntime {
	// If the variables list has changed, save the new variable names.
	// Return true if varibles have changed, false otherwise.

	newVarNames = (allVariableNames (project scripter))
	if (oldVarNames == newVarNames) { return false }

	editor = (findMicroBlocksEditor)
	varCount = (count newVarNames)
	progressInterval = (max 1 (floor (varCount / 20)))

	clearVariableNames this
	varID = 0
	for varName newVarNames {
		if (notNil port) {
			if (0 == (varID % 50)) {
				// send a sync message every N variables
				sendMsgSync this 'varNameMsg' varID (toArray (toBinaryData varName))
			} else {
				sendMsg this 'varNameMsg' varID (toArray (toBinaryData varName))
			}
		}
		varID += 1
		if (0 == (varID % progressInterval)) {
			showDownloadProgress editor 2 (varID / varCount)
		}
	}
	oldVarNames = (copy newVarNames)
	return true
}

method runChunk SmallRuntime chunkID {
	sendMsg this 'startChunkMsg' chunkID
}

method stopRunningChunk SmallRuntime chunkID {
	sendMsg this 'stopChunkMsg' chunkID
}

method sendBroadcastToBoard SmallRuntime msg {
	sendMsg this 'broadcastMsg' 0 (toArray (toBinaryData msg))
}

method getVar SmallRuntime varID {
	if (isNil varID) { varID = 0 }
	sendMsg this 'getVarMsg' varID
}

method getVarNamed SmallRuntime varName {
	sendMsg this 'getVarMsg' 255 (toArray (toBinaryData varName))
}

method setVar SmallRuntime varID val {
	body = nil
	if (isClass val 'Integer') {
		body = (newArray 5)
		atPut body 1 1 // type 1 - Integer
		atPut body 2 (val & 255)
		atPut body 3 ((val >> 8) & 255)
		atPut body 4 ((val >> 16) & 255)
		atPut body 5 ((val >> 24) & 255)
	} (isClass val 'String') {
		body = (toArray (toBinaryData (join (string 2) val)))
	} (isClass val 'Boolean') {
		body = (newArray 2)
		atPut body 1 3 // type 3 - Boolean
		if val {
			atPut body 2 1 // true
		} else {
			atPut body 2 0 // false
		}
	}
	if (notNil body) { sendMsg this 'setVarMsg' varID body }
}

method variablesChanged SmallRuntime {
	// Called by scripter when variables are added or removed.

	sendStopAll this
	clearVariableNames this
	scriptChanged scripter
}

method clearVariableNames SmallRuntime {
	if (notNil port) { sendMsgSync this 'clearVarsMsg' }
	oldVarNames = nil
}

// Serial Delay

method serialDelayMenu SmallRuntime {
	menu = (menu (join 'Serial delay' (newline) '(smaller is faster, but may fail if computer cannot keep up)') (action 'setSerialDelay' this) true)
	for i (range 1 5) { addItem menu i }
	for i (range 6 20 2) { addItem menu i }
	addLine menu
	addItem menu 'reset to default'
	popUpAtHand menu (global 'page')
}

method setDefaultSerialDelay SmallRuntime {
	setSerialDelay this 'reset to default'
}

method setSerialDelay SmallRuntime newDelay {
	if ('reset to default' == newDelay) {
		newDelay = 5
	}
	sendMsg this 'extendedMsg' 1 (list newDelay)
}

// Message handling

method msgNameToID SmallRuntime msgName {
	if (isClass msgName 'Integer') { return msgName }
	if (isNil msgDict) {
		msgDict = (dictionary)
		atPut msgDict 'chunkCodeMsg' 1
		atPut msgDict 'deleteChunkMsg' 2
		atPut msgDict 'startChunkMsg' 3
		atPut msgDict 'stopChunkMsg' 4
		atPut msgDict 'startAllMsg' 5
		atPut msgDict 'stopAllMsg' 6
		atPut msgDict 'getVarMsg' 7
		atPut msgDict 'setVarMsg' 8
		atPut msgDict 'getVarNamesMsg' 9
		atPut msgDict 'clearVarsMsg' 10
		atPut msgDict 'getChunkCRCMsg' 11
		atPut msgDict 'getVersionMsg' 12
		atPut msgDict 'getAllCodeMsg' 13
		atPut msgDict 'deleteAllCodeMsg' 14
		atPut msgDict 'systemResetMsg' 15
		atPut msgDict 'taskStartedMsg' 16
		atPut msgDict 'taskDoneMsg' 17
		atPut msgDict 'taskReturnedValueMsg' 18
		atPut msgDict 'taskErrorMsg' 19
		atPut msgDict 'outputValueMsg' 20
		atPut msgDict 'varValueMsg' 21
		atPut msgDict 'versionMsg' 22
		atPut msgDict 'chunkCRCMsg' 23
		atPut msgDict 'pingMsg' 26
		atPut msgDict 'broadcastMsg' 27
		atPut msgDict 'chunkAttributeMsg' 28
		atPut msgDict 'varNameMsg' 29
		atPut msgDict 'extendedMsg' 30
		atPut msgDict 'getAllCRCsMsg' 38
		atPut msgDict 'allCRCsMsg' 39
		atPut msgDict 'deleteFile' 200
		atPut msgDict 'listFiles' 201
		atPut msgDict 'fileInfo' 202
		atPut msgDict 'startReadingFile' 203
		atPut msgDict 'startWritingFile' 204
		atPut msgDict 'fileChunk' 205
	}
	msgType = (at msgDict msgName)
	if (isNil msgType) { error 'Unknown message:' msgName }
	return msgType
}

method errorString SmallRuntime errID {
	// Return an error string for the given errID from error definitions copied and pasted from interp.h

	defsFromHeaderFile = '
#define noError					0	// No error
#define unspecifiedError		1	// Unknown error
#define badChunkIndexError		2	// Unknown chunk index

#define insufficientMemoryError	10	// Insufficient memory to allocate object
#define needsListError			11	// Needs a list
#define needsBooleanError		12	// Needs a boolean
#define needsIntegerError		13	// Needs an integer
#define needsStringError		14	// Needs a string
#define nonComparableError		15	// Those objects cannot be compared for equality
#define arraySizeError			16	// List size must be a non-negative integer
#define needsIntegerIndexError	17	// List or string index must be an integer
#define indexOutOfRangeError	18	// List or string index out of range
#define byteArrayStoreError		19	// A ByteArray can only store integer values between 0 and 255
#define hexRangeError			20	// Hexadecimal input must between between -1FFFFFFF and 1FFFFFFF
#define i2cDeviceIDOutOfRange	21	// I2C device ID must be between 0 and 127
#define i2cRegisterIDOutOfRange	22	// I2C register must be between 0 and 255
#define i2cValueOutOfRange		23	// I2C value must be between 0 and 255
#define notInFunction			24	// Attempt to access an argument outside of a function
#define badForLoopArg			25	// for-loop argument must be a positive integer or list
#define stackOverflow			26	// Insufficient stack space
#define primitiveNotImplemented	27	// Primitive not implemented in this virtual machine
#define notEnoughArguments		28	// Not enough arguments passed to primitive
#define waitTooLong				29	// The maximum wait time is 3600000 milliseconds (one hour)
#define noWiFi					30	// This board does not support WiFi
#define zeroDivide				31	// Division (or modulo) by zero is not defined
#define argIndexOutOfRange		32	// Argument index out of range
#define needsIndexable			33	// Needs an indexable type such as a string or list
#define joinArgsNotSameType		34	// All arguments to join must be the same type (e.g. lists)
#define i2cTransferFailed		35	// I2C transfer failed
#define needsByteArray			36	// Needs a byte array
#define serialPortNotOpen		37	// Serial port not open
#define serialWriteTooBig		38	// Serial port write is limited to 128 bytes
#define needsListOfIntegers		39	// Needs a list of integers
#define byteOutOfRange			40	// Needs a value between 0 and 255
#define needsPositiveIncrement	41	// Range increment must be a positive integer
#define needsIntOrListOfInts	42	// Needs an integer or a list of integers
#define wifiNotConnected		43	// Not connected to a WiFi network
#define cannotConvertToInteger	44	// Cannot convert that to an integer
#define cannotConvertToBoolean	45	// Cannot convert that to a boolean
#define cannotConvertToList		46	// Cannot convert that to a list
#define cannotConvertToByteArray 47	// Cannot convert that to a byte array
#define unknownDatatype			48	// Unknown datatype
#define invalidUnicodeValue		49	// Unicode values must be between 0 and 1114111 (0x10FFFF)
'
	for line (lines defsFromHeaderFile) {
		words = (words line)
		if (and ((count words) > 2) ('#define' == (first words))) {
			if (errID == (toInteger (at words 3))) {
				msg = (joinStrings (copyFromTo words 5) ' ')
				return (join 'Error: ' msg)
			}
		}
	}
	return (join 'Unknown error: ' errID)
}

method sendMsg SmallRuntime msgName chunkID byteList {
	ensurePortOpen this
	if (isNil port) { return }

	if (isNil chunkID) { chunkID = 0 }
	msgID = (msgNameToID this msgName)
	if (isNil byteList) { // short message
		msg = (list 250 msgID chunkID)
	} else { // long message
		byteCount = ((count byteList) + 1)
		msg = (list 251 msgID chunkID (byteCount & 255) ((byteCount >> 8) & 255))
		addAll msg byteList
		add msg 254 // terminator byte (helps board detect dropped bytes)
	}
	dataToSend = (toBinaryData (toArray msg))

	if ('boardie' == portName) { // send all data at once to boardie
		(writeSerialPort port dataToSend)
		return
	}

	while ((byteCount dataToSend) > 0) {
		// Note: Adafruit USB-serial drivers on Mac OS locks up if >= 1024 bytes
		// written in one call to writeSerialPort, so send smaller chunks
		// Note: Maximum serial write in Chrome browser is only 64 bytes!
		byteCount = (min 64 (byteCount dataToSend))
		chunk = (copyFromTo dataToSend 1 byteCount)
		bytesSent = (writeSerialPort port chunk)
		if (not (isOpenSerialPort port)) {
			closePort this
			return
		}
		waitMSecs 2
		if (bytesSent < byteCount) { waitMSecs 200 } // output queue full; wait a bit
		dataToSend = (copyFromTo dataToSend (bytesSent + 1))
	}
}

method sendMsgSync SmallRuntime msgName chunkID byteList {
	// Send a message followed by a 'pingMsg', then a wait for a ping response from VM.

	readAvailableSerialData this
	sendMsg this msgName chunkID byteList
	if ('boardie' == portName) { return } // don't wait for a response

    if (not (connectedToBoard this)) { return }

	ok = (waitForResponse this)
	if (not ok) {
		print 'Lost communication to the board in sendMsgSync'
		closePort this
		return false
	}
	return true
}

method readAvailableSerialData SmallRuntime {
	// Read any available data into recvBuf so that waitForResponse will await fresh data.

	if (isNil port) { return }
	waitMSecs 20 // leave some time for queued data to arrive
	if (isNil recvBuf) { recvBuf = (newBinaryData 0) }
	s = (readSerialPort port true)
	if (notNil s) { recvBuf = (join recvBuf s) }
}

method waitForResponse SmallRuntime {
	// Wait for some data to arrive from the board. This is taken to mean that the
	// previous operation has completed. Return true if a response was received.

	sendMsg this 'pingMsg'
	timeout = 10000 // enough time for a long Flash compaction
	start = (msecsSinceStart)
	while (((msecsSinceStart) - start) < timeout) {
		if (isNil port) { return false }
		s = (readSerialPort port true)
		if (notNil s) {
			recvBuf = (join recvBuf s)
			return true
		}
		sendMsg this 'pingMsg'
		waitMSecs 5
	}
	return false
}

method ensurePortOpen SmallRuntime {
	if (true == disconnected) { return }
	if (isWebSerial this) { return }
	if (or (isNil port) (not (isOpenSerialPort port))) {
		if (and (notNil portName)
				(or (contains (portList this) portName)
				(notNil (findSubstring 'pts' portName)))) { // support for GnuBlocks
			port = (safelyRun (action 'openSerialPort' portName 115200))
			if (not (isClass port 'Integer')) { port = nil } // failed
			if (isNil port) { return }
			// connected!
			disconnected = false
			if ('Browser' == (platform)) { waitMSecs 100 } // let browser callback complete
		}
	}
}

method processMessages SmallRuntime {
	if (isNil recvBuf) { recvBuf = (newBinaryData 0) }
	repeat 100 { // process up to N messages
		if (not (processNextMessage this)) { return } // done!
	}
}

method processNextMessage SmallRuntime {
	// Process the next message, if any. Return false when there are no more messages.

	if (or (isNil port) (not (isOpenSerialPort port))) { return false }

	// Read any available bytes and append to recvBuf
	s = (readSerialPort port true)
	if (notNil s) { recvBuf = (join recvBuf s) }
	if ((byteCount recvBuf) < 3) { return false } // not enough bytes for even a short message

	// Parse and dispatch messages
	firstByte = (byteAt recvBuf 1)
	byteTwo = (byteAt recvBuf 2)
	if (or (byteTwo < 1) (and (40 <= byteTwo) (byteTwo < 200)) (byteTwo > 205)) {
		print 'Serial error, opcode:' (byteAt recvBuf 2)
		discardMessage this
		return true
	}
	if (250 == firstByte) { // short message
		msg = (copyFromTo recvBuf 1 3)
		recvBuf = (copyFromTo recvBuf 4) // remove message
		handleMessage this msg
	} (251 == firstByte) { // long message
		if ((byteCount recvBuf) < 5) { return false } // incomplete length field
		bodyBytes = (((byteAt recvBuf 5) << 8) | (byteAt recvBuf 4))
		if (bodyBytes >= 1024) {
			print 'Serial error, length:' bodyBytes
			discardMessage this
			return true
		}
		if ((byteCount recvBuf) < (5 + bodyBytes)) { return false } // incomplete body
		msg = (copyFromTo recvBuf 1 (bodyBytes + 5))
		recvBuf = (copyFromTo recvBuf (bodyBytes + 6)) // remove message
		handleMessage this msg
	} else {
		print 'Serial error, start byte:' firstByte
		print (toString recvBuf) // show the string (could be an ESP error message)
		discardMessage this
	}
	return true
}

method discardMessage SmallRuntime { skipMessage this true }

method skipMessage SmallRuntime discard {
	// Discard bytes in recvBuf until the start of the next message, if any.

	end = (byteCount recvBuf)
	i = 2
	while (i < end) {
		byte = (byteAt recvBuf i)
		if (or (250 == byte) (251 == byte)) {
		if (true == discard) { print '    ' (toString (copyFromTo recvBuf 1 (i - 1))) }
			recvBuf = (copyFromTo recvBuf i)
			return
		}
		i += 1
	}
	if (true == discard) { print '    ' (toString recvBuf) }
	recvBuf = (newBinaryData 0) // no message start found; discard entire buffer
}

// Message handling

method handleMessage SmallRuntime msg {
	lastPingRecvMSecs = (msecsSinceStart) // reset ping timer when any valid message is recevied
	op = (byteAt msg 2)
	if (op == (msgNameToID this 'taskStartedMsg')) {
		updateRunning this (byteAt msg 3) true
	} (op == (msgNameToID this 'taskDoneMsg')) {
		updateRunning this (byteAt msg 3) false
	} (op == (msgNameToID this 'taskReturnedValueMsg')) {
		chunkID = (byteAt msg 3)
		showResult this chunkID (returnedValue this msg) false true
		updateRunning this chunkID false
	} (op == (msgNameToID this 'taskErrorMsg')) {
		chunkID = (byteAt msg 3)
		showError this chunkID (errorString this (byteAt msg 6))
		updateRunning this chunkID false
	} (op == (msgNameToID this 'outputValueMsg')) {
		chunkID = (byteAt msg 3)
		if (chunkID == 255) {
			print (returnedValue this msg)
		} (chunkID == 254) {
			addLoggedData this (toString (returnedValue this msg))
		} else {
			showResult this chunkID (returnedValue this msg) false true
		}
	} (op == (msgNameToID this 'varValueMsg')) {
		varValueReceived (httpServer scripter) (byteAt msg 3) (returnedValue this msg)
	} (op == (msgNameToID this 'versionMsg')) {
		versionReceived this (returnedValue this msg)
	} (op == (msgNameToID this 'chunkCRCMsg')) {
		crcReceived this (byteAt msg 3) (copyFromTo (toArray msg) 6)
	} (op == (msgNameToID this 'allCRCsMsg')) {
		allCRCsReceived this (copyFromTo (toArray msg) 6)
	} (op == (msgNameToID this 'pingMsg')) {
		lastPingRecvMSecs = (msecsSinceStart)
	} (op == (msgNameToID this 'broadcastMsg')) {
		broadcastReceived (httpServer scripter) (toString (copyFromTo msg 6))
	} (op == (msgNameToID this 'chunkCodeMsg')) {
		receivedChunk this (byteAt msg 3) (byteAt msg 6) (toArray (copyFromTo msg 7))
	} (op == (msgNameToID this 'chunkAttributeMsg')) {
		print 'chunkAttributeMsg:' (byteCount msg) 'bytes'
	} (op == (msgNameToID this 'varNameMsg')) {
		receivedVarName this (byteAt msg 3) (toString (copyFromTo msg 6)) ((byteCount msg) - 5)
	} (op == (msgNameToID this 'fileInfo')) {
		recordFileTransferMsg this (copyFromTo msg 6)
	} (op == (msgNameToID this 'fileChunk')) {
		recordFileTransferMsg this (copyFromTo msg 6)
	} else {
		print 'msg:' (toArray msg)
	}
}

method updateRunning SmallRuntime chunkID runFlag {
	if (isNil chunkRunning) {
		chunkRunning = (newArray 256 false)
	}
	if (isNil chunkStopping) {
		chunkStopping = (dictionary)
	}
	if runFlag {
		atPut chunkRunning (chunkID + 1) runFlag
		remove chunkStopping chunkID
		updateHighlights this
	} else {
		// add chunkID to chunkStopping dictionary to be unhighlighted after a short pause
		stepCount = 2 // two scripter steps, about half a second
		atPut chunkStopping chunkID stepCount
	}
}

method updateStopping SmallRuntime {
	// Decrement the counts for chunks that are stopping.
	// Turn off highlights for chunks whose counts reach zero.

	if (and (isNil chunkStopping) (isEmpty chunkStopping))  { return }
	highlightChanged = false
	for chunkID (keys chunkStopping) {
		count = ((at chunkStopping chunkID) - 1) // decrement count
		if (count > 0) {
			atPut chunkStopping chunkID count // continue to wait
		} else {
			atPut chunkRunning (chunkID + 1) false
			remove chunkStopping chunkID
			highlightChanged = true
		}
	}
	if highlightChanged { updateHighlights this }
}

method isRunning SmallRuntime aBlock {
	chunkID = (lookupChunkID this aBlock)
	if (or (isNil chunkRunning) (isNil chunkID)) { return false }
	return (at chunkRunning (chunkID + 1))
}

// File Transfer Support

method boardHasFileSystem SmallRuntime {
	if (true == disconnected) { return false }
	if (and (isWebSerial this) (not (isOpenSerialPort 1))) { return false }
	if (not (connectedToBoard this)) { return false }
	if (isNil boardType) { getVersion this }
	return (isOneOf boardType 'Citilab ED1' 'M5Stack-Core' 'M5StickC+' 'M5StickC' 'M5Atom-Matrix' 'ESP32' 'ESP8266' 'RP2040' 'Pico W' 'Pico:ed' 'Wukong2040' 'TTGO RP2040' 'Boardie' 'Databot' 'Mbits')
}

method deleteFileOnBoard SmallRuntime fileName {
	msg = (toArray (toBinaryData fileName))
	sendMsg this 'deleteFile' 0 msg
}

method getFileListFromBoard SmallRuntime {
	if ('boardie' == portName) {
		return (boardieFileList)
	}

	sendMsg this 'listFiles'
	collectFileTransferResponses this

	result = (list)
	for msg fileTransferMsgs {
		fileNum = (readInt32 this msg 1)
		fileSize = (readInt32 this msg 5)
		fileName = (toString (copyFromTo msg 9))
		add result fileName
	}
	return result
}

method getFileFromBoard SmallRuntime {
	setCursor 'wait'
	fileNames = (sorted (toArray (getFileListFromBoard this)))
	fileNames = (copyWithout fileNames 'ublockscode')
	setCursor 'default'
	if (isEmpty fileNames) {
		inform 'No files on board.'
		return
	}
	menu = (menu 'File to read from board:' (action 'getAndSaveFile' this) true)
	for fn fileNames {
		addItem menu fn
	}
	popUpAtHand menu (global 'page')
}

method getAndSaveFile SmallRuntime remoteFileName {
	data = (readFileFromBoard this remoteFileName)
	if ('Browser' == (platform)) {
		browserWriteFile data remoteFileName 'fileFromBoard'
	} else {
		fName = (fileToWrite remoteFileName)
		if ('' != fName) { writeFile fName data }
	}
}

method readFileFromBoard SmallRuntime remoteFileName {
	if ('boardie' == portName) {
		return (boardieGetFile remoteFileName)
	}

	fileTransferProgress = 0
	spinner = (newSpinner (action 'fileTransferProgress' this 'downloaded') (action 'fileTransferCompleted' this))
	setStopAction spinner (action 'abortFileTransfer' this)
	addPart (global 'page') spinner

	msg = (list)
	id = (rand ((1 << 24) - 1))
	appendInt32 this msg id
	addAll msg (toArray (toBinaryData remoteFileName))
	sendMsg this 'startReadingFile' 0 msg
	collectFileTransferResponses this

	totalBytes = 0
	for msg fileTransferMsgs {
		// format: <transfer ID (4 byte int)><byte offset (4 byte int)><data...>
		transferID = (readInt32 this msg 1)
		offset = (readInt32 this msg 5)
		byteCount = ((byteCount msg) - 8)
		totalBytes += byteCount
		if (totalBytes > 0) {
			fileTransferProgress = (100 - (round (100 * (byteCount / totalBytes))))
			doOneCycle (global 'page')
		}
	}

	result = (newBinaryData totalBytes)
	startIndex = 1
	for msg fileTransferMsgs {
		byteCount = ((byteCount msg) - 8)
		endIndex = ((startIndex + byteCount) - 1)
		if (byteCount > 0) { replaceByteRange result startIndex endIndex msg 9 }
		startIndex += byteCount
	}

	fileTransferProgress = nil
	setCursor 'default'
	return result
}

method putFileOnBoard SmallRuntime {
	if ('Browser' == (platform)) {
		putNextDroppedFileOnBoard (findMicroBlocksEditor)
		browserReadFile ''
	} else {
		pickFileToOpen (action 'writeFileToBoard' this)
	}
}

method writeFileToBoard SmallRuntime srcFileName {
	if (notNil (findMorph 'MicroBlocksFilePicker')) {
		destroy (findMorph 'MicroBlocksFilePicker')
	}

	fileData = (readFile srcFileName true)
	if (isNil fileData) { return }

	targetFileName = (filePart srcFileName)
	if ((count targetFileName) > 30) {
		targetFileName = (substring targetFileName 1 30)
	}

	fileTransferProgress = 0
	spinner = (newSpinner (action 'fileTransferProgress' this 'uploaded') (action 'fileTransferCompleted' this))
	setStopAction spinner (action 'abortFileTransfer' this)
	addPart (global 'page') spinner

	sendFileData this targetFileName fileData
}

// busy tells the MicroBlocksEditor to suspend board communciations during file transfers
method busy SmallRuntime { return (notNil fileTransferProgress) }

method fileTransferProgress SmallRuntime actionLabel { return (join '' fileTransferProgress '% ' (localized actionLabel)) }

method abortFileTransfer SmallRuntime {
	if (not (fileTransferCompleted this)) { fileTransferProgress = nil }
}

method fileTransferCompleted SmallRuntime {
	// return true if the file transfer is complete or aborted
	return (or (isNil fileTransferProgress) (fileTransferProgress == 100))
}

method sendFileData SmallRuntime fileName fileData {
	if ('boardie' == portName) {
		boardiePutFile fileName fileData (byteCount fileData)
		return
	}

	// send data as a sequence of chunks
	setCursor 'wait'
	fileTransferProgress = 0

	totalBytes = (byteCount fileData)
	id = (rand ((1 << 24) - 1))
	bytesSent = 0

	msg = (list)
	appendInt32 this msg id
	addAll msg (toArray (toBinaryData fileName))
	sendMsgSync this 'startWritingFile' 0 msg

	while (bytesSent < totalBytes) {
		if (isNil fileTransferProgress) {
			print 'File transfer aborted.'
			return
		}
		msg = (list)
		appendInt32 this msg id
		appendInt32 this msg bytesSent
		chunkByteCount = (min 960 (totalBytes - bytesSent))
		repeat chunkByteCount {
			bytesSent += 1
			add msg (byteAt fileData bytesSent)
		}
		sendMsgSync this 'fileChunk' 0 msg
		if (totalBytes > 0) {
			fileTransferProgress = (round (100 * (bytesSent / totalBytes)))
			doOneCycle (global 'page')
		}
	}
	// final (empty) chunk
	msg = (list)
	appendInt32 this msg id
	appendInt32 this msg bytesSent
	sendMsgSync this 'fileChunk' 0 msg

	fileTransferProgress = nil
}

method appendInt32 SmallRuntime msg n {
	add msg (n & 255)
	add msg ((n >> 8) & 255)
	add msg ((n >> 16) & 255)
	add msg ((n >> 24) & 255)
}

method readInt32 SmallRuntime msg i {
	result = (byteAt msg i)
	result += ((byteAt msg (i + 1)) << 8)
	result += ((byteAt msg (i + 2)) << 16)
	result += ((byteAt msg (i + 3)) << 24)
	return result
}

method collectFileTransferResponses SmallRuntime {
	fileTransferMsgs = (list)
	timeout = 1000
	lastRcvMSecs = (msecsSinceStart)
	while (((msecsSinceStart) - lastRcvMSecs) < timeout) {
		if (notEmpty fileTransferMsgs) { timeout = 500 } // decrease timeout after first response
		processMessages this
		doOneCycle (global 'page')
		waitMSecs 10
	}
}

method recordFileTransferMsg SmallRuntime msg {
	// Record a file transfer message sent by board.

	if (notNil fileTransferMsgs) { add fileTransferMsgs msg }
	lastRcvMSecs = (msecsSinceStart)
}

// Script Highlighting

method clearRunningHighlights SmallRuntime {
	chunkRunning = (newArray 256 false) // clear all running flags
	updateHighlights this
}

method updateHighlights SmallRuntime {
	scale = (global 'scale')
	for m (parts (morph (scriptEditor scripter))) {
		if (isClass (handler m) 'Block') {
			if (isRunning this (handler m)) {
				addHighlight m
			} else {
				removeHighlight m
			}
		}
	}
}

method removeResultBubbles SmallRuntime {
	for m (allMorphs (morph (global 'page'))) {
		h = (handler m)
		if (and (isClass h 'SpeechBubble') (isClass (handler (clientMorph h)) 'Block')) {
			removeFromOwner m
		}
	}
}

method showError SmallRuntime chunkID msg {
	showResult this chunkID msg true
}

method showResult SmallRuntime chunkID value isError isResult {
	for m (join
			(parts (morph (scriptEditor scripter)))
			(parts (morph (blockPalette scripter)))) {
		h = (handler m)
		if (and (isClass h 'Block') (chunkID == (lookupChunkID this h))) {
			if (true == isError) {
				showError m value
			} else {
				showHint m value nil false
			}
			if (or (isNil value) ('' == value)) {
				removeHintForMorph (global 'page') m
			} else {
				if (shiftKeyDown (keyboard (global 'page'))) {
					setClipboard (toString value)
				}
			}
			if (and (true == isResult) (h == blockForResultImage)) {
				blockForResultImage = nil
				doOneCycle (global 'page')
				waitMSecs 500 // show result bubble briefly before showing menu
				exportAsImageScaled h value
			}
			if (and (true == isError) (h == blockForResultImage)) {
				blockForResultImage = nil
				doOneCycle (global 'page')
				waitMSecs 500 // show error bubble briefly before showing menu
				exportAsImageScaled h value true
			}
		}
	}
}

method exportScriptImageWithResult SmallRuntime aBlock {
	topBlock = (topBlock aBlock)
	if (isPrototypeHat topBlock) { return }
	blockForResultImage = topBlock
	if (not (isRunning this topBlock)) {
		evalOnBoard this topBlock
	}
}

// Return values

method returnedValue SmallRuntime msg {
	byteCount = (byteCount msg)
	if (byteCount < 7) { return nil } // incomplete msg

	type = (byteAt msg 6)
	if (1 == type) {
		if (byteCount < 10) { return nil } // incomplete msg
		return (+ ((byteAt msg 10) << 24) ((byteAt msg 9) << 16) ((byteAt msg 8) << 8) (byteAt msg 7))
	} (2 == type) {
		return (stringFromByteRange msg 7 (byteCount msg))
	} (3 == type) {
		return (0 != (byteAt msg 7))
	} (4 == type) {
		if (byteCount < 8) { return nil } // incomplete msg
		total = (((byteAt msg 8) << 8) | (byteAt msg 7))
		if (total == 0) { return '[empty list]' }
		sentItems = (readItems this msg)
		out = (list '[')
		for item sentItems {
			add out (toString item)
			add out ', '
		}
		if ((count out) > 1) { removeLast out }
		if (total > (count sentItems)) {
			add out (join ' ... and ' (total - (count sentItems)) ' more')
		}
		add out ']'
		return (joinStrings out)
	} (5 == type) {
		if (byteCount < 9) { return nil } // incomplete msg
		total = (((byteAt msg 8) << 8) | (byteAt msg 7))
		if (total == 0) { return '(empty byte array)' }
		sentCount = (byteAt msg 9)
		sentCount = (min sentCount (byteCount - 9))
		out = (list '(')
		for i sentCount {
			add out (toString (byteAt msg (9 + i)))
			add out ', '
		}
		if ((count out) > 1) { removeLast out }
		if (total > sentCount) {
			add out (join ' ... and ' (total - sentCount) ' more bytes')
		}
		add out ')'
		return (joinStrings out)
	} else {
		print 'Serial error, type: ' type
		return nil
	}
}

method readItems SmallRuntime msg {
	// Read a sequence of list items from the given value message.

	result = (list)
	byteCount = (byteCount msg)
	if (byteCount < 10) { return result } // corrupted msg
	count = (byteAt msg 9)
	i = 10
	repeat count {
		if (byteCount < (i + 1)) { return result } // corrupted msg
		itemType = (byteAt msg i)
		if (1 == itemType) { // integer
			if (byteCount < (i + 4)) { return result } // corrupted msg
			n = (+ ((byteAt msg (i + 4)) << 24) ((byteAt msg (i + 3)) << 16)
					((byteAt msg (i + 2)) << 8) (byteAt msg (i + 1)))
			add result n
			i += 5
		} (2 == itemType) { // string
			len = (byteAt msg (i + 1))
			if (byteCount < (+ i len 1)) { return result } // corrupted msg
			add result (toString (copyFromTo msg (i + 2) (+ i len 1)))
			i += (len + 2)
		} (3 == itemType) { // boolean
			isTrue = ((byteAt msg (i + 1)) != 0)
			add result isTrue
			i += 2
		} (4 == itemType) { // sublist
			if (byteCount < (i + 3)) { return result } // corrupted msg
			n = (+ ((byteAt msg (i + 2)) << 8) (byteAt msg (i + 1)))
			if (0 != (byteAt msg (i + 3))) {
				print 'skipping sublist with non-zero sent items'
				return result
			}
			add result (join '[' n ' item list]')
			i += 4
		} (5 == itemType) { // bytearray
			if (byteCount < (i + 3)) { return result } // corrupted msg
			n = (+ ((byteAt msg (i + 2)) << 8) (byteAt msg (i + 1)))
			if (0 != (byteAt msg (i + 3))) {
				print 'skipping bytearray with non-zero sent items inside a list'
				return result
			}
			add result (join '(' n ' bytes)')
			i += 4
		} else {
			print 'unknown item type in value message:' itemType
			return result
		}
	}
	return result
}

method showOutputStrings SmallRuntime {
	// For debuggong. Just display incoming characters.
	if (isNil port) { return }
	s = (readSerialPort port)
	if (notNil s) {
		if (isNil recvBuf) { recvBuf = '' }
		recvBuf = (toString recvBuf)
		recvBuf = (join recvBuf s)
		while (notNil (findFirst recvBuf (newline))) {
			i = (findFirst recvBuf (newline))
			out = (substring recvBuf 1 (i - 2))
			recvBuf = (substring recvBuf (i + 1))
			print out
		}
	}
}

// Virtual Machine Installer

method installVM SmallRuntime eraseFlashFlag downloadLatestFlag {
	if ('Browser' == (platform)) {
		installVMInBrowser this eraseFlashFlag downloadLatestFlag
		return
	}
	boards = (collectBoardDrives this)
	if ((count boards) == 1) {
		b = (first boards)
		copyVMToBoard this (first b) (last b)
	} ((count boards) > 1) {
		menu = (menu 'Select board:' this)
		for b boards {
			addItem menu (niceBoardName this b) (action 'copyVMToBoard' this (first b) (last b))
		}
		popUpAtHand menu (global 'page')
	} (notNil boardType) {
		if (and (contains (array 'Citilab ED1' 'M5Stack-Core' 'ESP8266' 'ESP32' 'Databot') boardType)
				(confirm (global 'page') nil (join (localized 'Use board type ') boardType '?'))) {
			flashVM this boardType eraseFlashFlag downloadLatestFlag
		} (isOneOf boardType 'CircuitPlayground' 'CircuitPlayground Bluefruit' 'Clue' 'Metro M0' 'MakerPort') {
			adaFruitResetMessage this
		} (isOneOf boardType 'RP2040' 'Pico W' 'Pico:ed' 'Wukong2040') {
			rp2040ResetMessage this
		}
	} else {
		disconnected = true
		closePort this
		menu = (menu 'Select board type:' this)
		if (not eraseFlashFlag) {
			for boardName (array 'microbit' 'Calliope mini') {
				addItem menu boardName (action 'noBoardFoundMessage' this)
			}
			addLine menu
		}
		for boardName (array 'Citilab ED1' 'M5Stack-Core' 'ESP32' 'ESP8266' 'Databot') {
			addItem menu boardName (action 'flashVM' this boardName eraseFlashFlag downloadLatestFlag)
		}
		if (not eraseFlashFlag) {
			addLine menu
			addItem menu 'ELECFREAKS Pico:ed' (action 'rp2040ResetMessage' this)
			addItem menu 'ELECFREAKS Wukong2040' (action 'rp2040ResetMessage' this)
			addItem menu 'RP2040 (Pico or Pico-W)' (action 'rp2040ResetMessage' this)
			addItem menu 'Adafruit Board' (action 'adaFruitResetMessage' this)
			addItem menu 'MakerPort' (action 'adaFruitResetMessage' this)
		}
		popUpAtHand menu (global 'page')
	}
}

method niceBoardName SmallRuntime board {
	name = (first board)
	if (beginsWith name 'MICROBIT') {
		return 'micro:bit'
	} (beginsWith name 'MINI') {
		return 'Calliope mini'
	} (beginsWith name 'CPLAYBOOT') {
		return 'Circuit Playground Express'
	} (beginsWith name 'CPLAYBTBOOT') {
		return 'Circuit Playground Bluefruit'
	} (beginsWith name 'CLUE') {
		return 'Clue'
	} (beginsWith name 'METRO') {
		return 'Metro M0'
	} (beginsWith name 'RPI-RP2') {
		return 'Raspberry Pi Pico'
	}
	return name
}

method collectBoardDrives SmallRuntime {
	result = (list)
	if ('Mac' == (platform)) {
		for v (listDirectories '/Volumes') {
			path = (join '/Volumes/' v '/')
			driveName = (getBoardDriveName this path)
			if (notNil driveName) { add result (list driveName path) }
		}
	} ('Linux' == (platform)) {
		for dir (listDirectories '/media') {
			prefix = (join '/media/' dir)
			for v (listDirectories prefix) {
				path = (join prefix '/' v '/')
				driveName = (getBoardDriveName this path)
				if (notNil driveName) { add result (list driveName path) }
			}
		}
	} ('Win' == (platform)) {
		for letter (range 65 90) {
			drive = (join (string letter) ':')
			driveName = (getBoardDriveName this drive)
			if (notNil driveName) { add result (list driveName drive) }
		}
	}
	return result
}

method getBoardDriveName SmallRuntime path {
	for fn (listFiles path) {
		if ('MICROBIT.HTM' == fn) {
			contents = (readFile (join path fn))
			return 'MICROBIT' }
		if (or ('MINI.HTM' == fn) ('Calliope.html' == fn)) { return 'MINI' }
		if ('INFO_UF2.TXT' == fn) {
			contents = (readFile (join path fn))
			if (notNil (nextMatchIn 'CPlay Express' contents)) { return 'CPLAYBOOT' }
			if (notNil (nextMatchIn 'Circuit Playground nRF52840' contents)) { return 'CPLAYBTBOOT' }
			if (notNil (nextMatchIn 'Adafruit Clue' contents)) { return 'CLUEBOOT' }
			if (notNil (nextMatchIn 'Adafruit CLUE nRF52840' contents)) { return 'CLUEBOOT' } // bootloader 0.7
			if (notNil (nextMatchIn 'Metro M0' contents)) { return 'METROBOOT' }
			if (notNil (nextMatchIn 'MakerPort' contents)) { return 'MAKERBOOT' }
			if (notNil (nextMatchIn 'RPI-RP2' contents)) { return 'RPI-RP2' }
		}
	}
	return nil
}

method picoVMFileName SmallRuntime {
	tmp = (array nil)
	menu = (menu 'Pico board type?' (action 'atPut' tmp 1) true)
	addItem menu 'ELECFREAKS Pico:ed'
	addItem menu 'ELECFREAKS Wukong2040'
	addItem menu 'RP2040 (Pico or Pico W)'
	waitForSelection menu
	result = (first tmp)
	if ('ELECFREAKS Pico:ed' == result) {
		return 'vm_pico_ed.uf2'
	} ('ELECFREAKS Wukong2040' == result) {
		return 'vm_wukong2040.uf2'
	} ('RP2040 (Pico or Pico W)' == result) {
		return 'vm_pico_w.uf2'
	}
	return 'none'
}

method copyVMToBoard SmallRuntime driveName boardPath {
	// disable auto-connect and close the serial port
	disconnected = true
	closePort this

	if ('MICROBIT' == driveName) {
		vmFileName = 'vm_microbit-universal.hex'
 	} ('MINI' == driveName) {
		vmFileName = 'vm_calliope.hex'
	} ('CPLAYBOOT' == driveName) {
		vmFileName = 'vm_circuitplay.uf2'
	} ('CPLAYBTBOOT' == driveName) {
		vmFileName = 'vm_cplay52.uf2'
	} ('CLUEBOOT' == driveName) {
		vmFileName = 'vm_clue.uf2'
	} ('METROBOOT' == driveName) {
		vmFileName = 'vm_metroM0.uf2'
	} ('MAKERBOOT' == driveName) {
		vmFileName = 'vm_makerport.uf2'
	} ('RPI-RP2' == driveName) {
		vmFileName = (picoVMFileName this)
	} else {
		print 'unknown drive name in "copyVMToBoard"' // shouldn't happen
		return
	}
	vmData = (readEmbeddedFile (join 'precompiled/' vmFileName) true)
	if (isNil vmData) {
		error (join (localized 'Could not read: ') (join 'precompiled/' vmFileName))
	}
	writeFile (join boardPath vmFileName) vmData
	print 'Installed' (join boardPath vmFileName) (join '(' (byteCount vmData) ' bytes)')
	waitMSecs 2000
	if (isOneOf driveName 'MICROBIT' 'MINI') { waitMSecs 4000 }
	disconnected = false
}

// Browser Virtual Machine Intaller

method installVMInBrowser SmallRuntime eraseFlashFlag downloadLatestFlag {
	if ('micro:bit' == boardType) {
		copyVMToBoardInBrowser this eraseFlashFlag downloadLatestFlag 'micro:bit'
	} ('micro:bit v2' == boardType) {
		copyVMToBoardInBrowser this eraseFlashFlag downloadLatestFlag 'micro:bit v2'
	} ('Calliope' == boardType) {
		copyVMToBoardInBrowser this eraseFlashFlag downloadLatestFlag 'Calliope mini'
	} ('CircuitPlayground' == boardType) {
		copyVMToBoardInBrowser this eraseFlashFlag downloadLatestFlag 'Circuit Playground Express'
	} ('CircuitPlayground Bluefruit' == boardType) {
		copyVMToBoardInBrowser this eraseFlashFlag downloadLatestFlag 'Circuit Playground Bluefruit'
	} ('Clue' == boardType) {
		copyVMToBoardInBrowser this eraseFlashFlag downloadLatestFlag 'Clue'
	} ('Metro M0' == boardType) {
		copyVMToBoardInBrowser this eraseFlashFlag downloadLatestFlag 'Metro M0'
	} ('MakerPort' == boardType) {
		copyVMToBoardInBrowser this eraseFlashFlag downloadLatestFlag 'Metro M0'
	} (isOneOf boardType 'RP2040' 'Pico W' 'Pico:ed' 'Wukong2040') {
		rp2040ResetMessage this
	} (and
		(isOneOf boardType 'Citilab ED1' 'M5Stack-Core' 'ESP32' 'ESP8266' 'Databot')
		(confirm (global 'page') nil (join (localized 'Use board type ') boardType '?'))) {
			flashVM this boardType eraseFlashFlag downloadLatestFlag
	} else {
		menu = (menu 'Select board type:' (action 'copyVMToBoardInBrowser' this eraseFlashFlag downloadLatestFlag) true)
		if eraseFlashFlag {
			addItem menu 'Citilab ED1'
			addItem menu 'Databot'
			addItem menu 'M5Stack-Core'
			addItem menu 'ESP32'
			addItem menu 'ESP8266'
		} else {
			addItem menu 'micro:bit'
			addItem menu 'Calliope mini'
			addLine menu
			addItem menu 'Citilab ED1'
			addItem menu 'Databot'
			addLine menu
			addItem menu 'ELECFREAKS Pico:ed'
			addItem menu 'ELECFREAKS Wukong2040'
			addItem menu 'RP2040 (Pico or Pico W)'
			addLine menu
			addItem menu 'MakerPort'
			addLine menu
			addItem menu 'Circuit Playground Express'
			addItem menu 'Circuit Playground Bluefruit'
			addItem menu 'Clue'
			addItem menu 'Metro M0'
			addLine menu
			addItem menu 'M5Stack-Core'
			addItem menu 'ESP32'
			addItem menu 'ESP8266'
		}
		popUpAtHand menu (global 'page')
	}
}

method flashVMInBrowser SmallRuntime boardName eraseFlashFlag downloadLatestFlag {
	if (isNil port) {
		// prompt user to open the serial port
		selectPort this
		timeout = 10000 // ten seconds
		start = (msecsSinceStart)
		while (and (not (isOpenSerialPort 1)) (((msecsSinceStart) - start) < timeout)) {
			// do UI cycles until serial port is opened or timeout
			doOneCycle (global 'page')
			waitMSecs 10 // refresh screen
		}
	}
	if (isOpenSerialPort 1) {
		port = 1
		flashVM this boardName eraseFlashFlag downloadLatestFlag
	}
}

method copyVMToBoardInBrowser SmallRuntime eraseFlashFlag downloadLatestFlag boardName {
	if (isOneOf boardName 'Citilab ED1' 'M5Stack-Core' 'ESP32' 'ESP8266' 'Databot') {
		flashVMInBrowser this boardName eraseFlashFlag downloadLatestFlag
		return
	}

	if ('micro:bit' == boardName) {
		vmFileName = 'vm_microbit-universal.hex'
		driveName = 'MICROBIT'
	} ('micro:bit v2' == boardName) {
		vmFileName = 'vm_microbit-universal.hex'
		driveName = 'MICROBIT'
	} ('Calliope mini' == boardName) {
		vmFileName = 'vm_calliope.hex'
		driveName = 'MINI'
	} ('Circuit Playground Express' == boardName) {
		vmFileName = 'vm_circuitplay.uf2'
		driveName = 'CPLAYBOOT'
	} ('Circuit Playground Bluefruit' == boardName) {
		vmFileName = 'vm_cplay52.uf2'
		driveName = 'CPLAYBTBOOT'
	} ('Clue' == boardName) {
		vmFileName = 'vm_clue.uf2'
		driveName = 'CLUEBOOT'
	} ('Metro M0' == boardName) {
		vmFileName = 'vm_metroM0.uf2'
		driveName = 'METROBOOT'
	} ('MakerPort' == boardName) {
		vmFileName = 'vm_makerport.uf2'
		driveName = 'MAKERBOOT'
	} ('RP2040 (Pico or Pico W)' == boardName) {
		vmFileName = 'vm_pico_w.uf2'
		driveName = 'RPI-RP2'
	} ('ELECFREAKS Pico:ed' == boardName) {
		vmFileName = 'vm_pico_ed.uf2'
		driveName = 'RPI-RP2'
	} ('ELECFREAKS Wukong2040' == boardName) {
		vmFileName = 'vm_wukong2040.uf2'
		driveName = 'RPI-RP2'
	} else {
		return // bad board name
	}

	prefix = ''
	if (endsWith vmFileName '.uf2') {
		if ('RPI-RP2' == driveName) {
			// Extra instruction for RP2040 Pico
			prefix = (join
				prefix
				(localized 'Connect USB cable while holding down the white BOOTSEL button before proceeding.')
				(newline) (newline))
		} ('MAKERBOOT' == driveName) {
			// Extra instruction for MakerPort
			prefix = (join
				prefix
				(localized 'Press the reset button on the board twice before proceeding.')
				(newline) (newline))
		} else {
			// Extra instruction for Adafruit boards
			prefix = (join
				prefix
				(localized 'Press the reset button on the board twice before proceeding. The NeoPixels should turn green.')
				(newline) (newline))
		}
	}
	msg = (join
		prefix
		(localized 'You will be asked to save the firmware file.')
		(newline)
		(newline)
		(localized 'Select')
		' ' driveName ' '
		(localized 'as the destination drive, then click Save.'))
	response = (inform msg (localized 'Firmware Install'))
	if (isNil response) { return }

	vmData = (readFile (join 'precompiled/' vmFileName) true)
	if (isNil vmData) { return } // could not read file

	// disconnect before updating VM; avoids micro:bit autoconnect issue on Chromebooks
	disconnected = true
	closePort this
	updateIndicator (findMicroBlocksEditor)

	if (endsWith vmFileName '.hex') {
		// for micro:bit, filename must be less than 9 letter before the extension
		vmFileName = 'firmware.hex'
		waitForFirmwareInstall this
	}

	browserWriteFile vmData vmFileName 'vmInstall'

	if (endsWith vmFileName '.uf2') {
		waitMSecs 1000 // leave time for file dialog box to appear before showing next prompt
		if (or ('MAKERBOOT' == driveName) ('RPI-RP2' == driveName)) {
			otherReconnectMessage this
		} else {
			adaFruitReconnectMessage this
		}
	}
}

method noBoardFoundMessage SmallRuntime {
	inform (localized 'No boards found; is your board plugged in?') 'No boards found'
}

method adaFruitResetMessage SmallRuntime {
	inform (localized 'For Adafruit boards and MakerPort, double-click reset button and try again.')
}

method adaFruitReconnectMessage SmallRuntime {
	msg = (join
		(localized 'When the NeoPixels turn off') ', '
		(localized 'reconnect to the board by clicking the "Connect" button (USB icon).'))
	inform msg
}

method rp2040ResetMessage SmallRuntime {
	inform (localized 'Connect USB cable while holding down the white BOOTSEL button and try again.')
}

method otherReconnectMessage SmallRuntime {
	title = (localized 'Firmware Installed')
	msg = (localized 'Reconnect to the board by clicking the "Connect" button (USB icon).')
	inform (global 'page') msg title nil true
}

method waitForFirmwareInstall SmallRuntime {
	firmwareInstallTimer = nil
	spinner = (newSpinner (action 'firmwareInstallStatus' this) (action 'firmwareInstallDone' this))
	addPart (global 'page') spinner
}

method startFirmwareCountdown SmallRuntime fileName {
	// Called by editor after firmware file is saved.

	if ('_no_file_selected_' == fileName) {
		spinner = (findMorph 'MicroBlocksSpinner')
		if (notNil spinner) { destroy (handler spinner) }
	} else {
		firmwareInstallTimer = (newTimer)
	}
}

method firmwareInstallSecsRemaining SmallRuntime {
	if (isNil firmwareInstallTimer) { return 0 }
	installWaitMSecs = 6000
	if (and ('Browser' == (platform)) (browserIsChromeOS)) {
		installWaitMSecs = 16000
	}
	return (ceiling ((installWaitMSecs - (msecs firmwareInstallTimer)) / 1000))
}

method firmwareInstallStatus SmallRuntime {
	if (isNil firmwareInstallTimer) { return 'Installing firmware...' }
	return (join '' (firmwareInstallSecsRemaining this) ' ' (localized 'seconds remaining') '.')
}

method firmwareInstallDone SmallRuntime {
	if (isNil firmwareInstallTimer) { return false }

	if ((firmwareInstallSecsRemaining this) <= 0) {
		firmwareInstallTimer = nil
		otherReconnectMessage this
		return true
	}
	return false
}

// espressif board flashing

method flasher SmallRuntime { return flasher }

method confirmRemoveFlasher SmallRuntime { // xxx needed?
	ok = (confirm
		(global 'page')
		nil
		(localized 'Are you sure you want to cancel the upload process?'))
	if ok { removeFlasher this }
}

method removeFlasher SmallRuntime {
	destroy flasher
	flasher = nil
}

method flashVM SmallRuntime boardName eraseFlashFlag downloadLatestFlag {
	if ('Browser' == (platform)) {
		disconnected = true
		flasherPort = port
		port = nil
	} else {
		setPort this 'disconnect'
		flasherPort = nil
	}
	flasher = (newFlasher boardName portName eraseFlashFlag downloadLatestFlag)
	addPart (global 'page') (spinner flasher)
	startFlasher flasher flasherPort
}

// data logging

method lastDataIndex SmallRuntime { return loggedDataNext }

method clearLoggedData SmallRuntime {
	loggedData = (newArray 10000)
	loggedDataNext = 1
	loggedDataCount = 0
}

method addLoggedData SmallRuntime s {
	atPut loggedData loggedDataNext s
	loggedDataNext = ((loggedDataNext % (count loggedData)) + 1)
	if (loggedDataCount < (count loggedData)) { loggedDataCount += 1 }
}

method loggedData SmallRuntime howMany {
	if (or (isNil howMany) (howMany > loggedDataCount)) {
		howMany = loggedDataCount
	}
	result = (newArray howMany)
	start = (loggedDataNext - howMany)
	if (start > 0) {
		replaceArrayRange result 1 howMany loggedData start
	} else {
		tailCount = (- start)
		tailStart = (((count loggedData) - tailCount) + 1)
		replaceArrayRange result 1 tailCount loggedData tailStart
		replaceArrayRange result (tailCount + 1) howMany loggedData 1
	}
	return result
}

// Install ESP firmware from URL

method installESPFirmwareFromURL SmallRuntime {
	defaultURL = ''
	if ('Databot' == boardType) {
		defaultURL = 'http://microblocks.fun/downloads/databot/databot2.0_V2.18.bin'
	}
	url = (trim (freshPrompt (global 'page') 'ESP32 firmware URL?' defaultURL))
	if ('' == url) { return }

	if ('Browser' == (platform)) {
		disconnected = true
		flasherPort = port
		port = nil
	} else {
		setPort this 'disconnect'
		flasherPort = nil
	}
	flasher = (newFlasher boardName portName false false)
	addPart (global 'page') (spinner flasher)
	installFromURL flasher flasherPort url
}
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Copyright 2019 John Maloney, Bernat Romagosa, and Jens MÃ¶nig

// MicroBlocksScripter.gp - MicroBlocks script editor w/ built-in palette

defineClass MicroBlocksScripter morph mbProject projectEditor saveNeeded categorySelector catResizer libHeader libSelector lastLibraryFolder blocksFrame blocksResizer scriptsFrame nextX nextY embeddedLibraries trashcan selection

method blockPalette MicroBlocksScripter { return (contents blocksFrame) }
method scriptEditor MicroBlocksScripter { return (contents scriptsFrame) }
method scriptsFrame MicroBlocksScripter { return scriptsFrame }
method project MicroBlocksScripter { return mbProject }
method httpServer MicroBlocksScripter { return (httpServer projectEditor) }

method selection MicroBlocksScripter { return selection }
method setSelection MicroBlocksScripter aSelection { selection = aSelection }

// initialization

method initialize MicroBlocksScripter aProjectEditor {
  mbProject = (newMicroBlocksProject)
  projectEditor = aProjectEditor
  scale = (global 'scale')
  morph = (newMorph this)
  listColor = (gray 240)
  fontName = 'Arial Bold'
  fontSize = 16
  if ('Linux' == (platform)) {
	fontName = 'Liberation Sans Bold'
	fontSize = 13
  }
  nextX = 0
  nextY = 0

  // how often to check for script changes
  setFPS morph 4
  saveNeeded = false

  makeLibraryHeader this
  lastLibraryFolder = 'Libraries'

  categorySelector = (newCategorySelector (categories this) (action 'categorySelected' this))
  setFont categorySelector fontName fontSize
  setExtent (morph categorySelector) (140 * scale) 100
  addPart morph (morph categorySelector)

  libSelector = (newCategorySelector (array) (action 'librarySelected' this))
  setFont libSelector fontName fontSize
  addPart morph (morph libSelector)

  blocksPane = (newBlocksPalette)
  setSortingOrder (alignment blocksPane) nil
  setPadding (alignment blocksPane) (15 * scale) // inter-column space
  setFramePadding (alignment blocksPane) (10 * scale) (10 * scale)
  blocksFrame = (scrollFrame blocksPane (gray 220))
  setExtent (morph blocksFrame) (260 * scale) (100 * scale)
  setAutoScroll blocksFrame false
  addPart morph (morph blocksFrame)

  scriptsPane = (newScriptEditor 10 10 nil)
  scriptsFrame = (scrollFrame scriptsPane (gray 220))
  addPart morph (morph scriptsFrame)

  // add resizers last so they are in front
  catResizer = (newPaneResizer (morph categorySelector) 'horizontal')
  addPart morph (morph catResizer)

  blocksResizer = (newPaneResizer (morph blocksFrame) 'horizontal')
  addPart morph (morph blocksResizer)

  setGrabRule morph 'ignore'
  for m (parts morph) { setGrabRule m 'ignore' }

  setMinExtent morph (scale * 235) (scale * 200)
  setExtent morph (scale * 600) (scale * 700)
  restoreScripts this

  smallRuntime this // create a SmallRuntime instance
  if (isNil projectEditor) { select categorySelector 'Control' }
  return this
}

method languageChanged MicroBlocksScripter {
  updateLibraryHeader this

  // update the scripts
  updateBlocks this
  saveScripts this
  restoreScripts this
  scriptChanged this
}

// library header

method makeLibraryHeader MicroBlocksScripter {
  scale = (global 'scale')
  libHeader = (newBox (newMorph) (colorHSV 180 0.045 1.0) 0 0)

  label = (newText (localized 'Libraries') 'Arial' (18 * scale) (gray 30))
  if ('Linux' == (platform)) {
	label = (newText (localized 'Libraries') 'Liberation Sans' (15 * scale) (gray 30))
  }
  setPosition (morph label) (6 * scale) (6 * scale)
  addPart (morph libHeader) (morph label)

  libAddButton = (addLibraryButton this '+' (33 * scale) (33 * scale))
  setPosition (morph libAddButton) (82 * scale) 0
  addPart (morph libHeader) (morph libAddButton)
  addPart morph (morph libHeader)
  return libHeader
}

method updateLibraryHeader MicroBlocksScripter {
  labelM = (first (parts (morph libHeader)))
  setText (handler labelM) (localized 'Libraries')

  addButton = (handler (last (parts (morph libHeader))))
  setHint addButton (localized 'Add Library')
}

method fixLibraryHeaderLayout MicroBlocksScripter {
  buttonM = (last (parts (morph libHeader)))
  setRight buttonM (right (owner buttonM))
}

method addLibraryButton MicroBlocksScripter label w h {
  scale = (global 'scale')
  setFont 'Arial Bold' (24 * scale)
  halfW = (1.5 * scale)
  lineW = (2 * halfW)
  halfLen = (7 * scale)
  len = (2 * halfLen)
  centerX = (toInteger (w / 2))
  centerY = (toInteger (h / 2))

  labelY = (6 * scale)
  bm1 = (newBitmap w h (topBarBlue projectEditor))
  fillRect bm1 (gray 60) (centerX - halfLen) (centerY - halfW) len lineW
  fillRect bm1 (gray 60) (centerX - halfW) (centerY - halfLen) lineW len

  bm2 = (newBitmap w h (topBarBlueHighlight projectEditor))
  fillRect bm2 (gray 30) (centerX - halfLen) (centerY - halfW) len lineW
  fillRect bm2 (gray 30) (centerX - halfW) (centerY - halfLen) lineW len

  button = (newButton '' (action 'importLibrary' this))
  setHint button (localized 'Add Library')
  setCostumes button bm1 bm2
  return button
}

// library item menu

method handleListContextRequest MicroBlocksScripter anArray {
  if (and ((first anArray) == categorySelector) ('My Blocks' == (last anArray))) {
    menu = (menu)
	addItem menu 'show all block definitions' (action 'showAllMyBlocks' this)
	addItem menu 'hide all block definitions' (action 'hideAllMyBlocks' this)
    popUpAtHand menu (global 'page')
    return
  }
  if ((first anArray) != libSelector) { return } // not a library list entry; ignore
  libName = (last anArray)
  menu = (menu)
  addItem menu 'library information' (action 'showLibraryInfo' this libName)
  if (devMode) {
	addItem menu 'show all block definitions' (action 'showAllLibraryDefinitions' this libName)
	addItem menu 'hide all block definitions' (action 'hideAllLibraryDefinitions' this libName)
	addItem menu 'export this library' (action 'exportLibrary' this libName)
  }
  addLine menu
  addItem menu 'delete library' (action 'removeLibraryNamed' this libName)
  popUpAtHand menu (global 'page')
}

method showAllMyBlocks MicroBlocksScripter libName {
  newY = (height (morph (contents scriptsFrame))) // current bottom
  for f (functions (main mbProject)) {
	internalShowDefinition this (functionName f)
  }
  saveScripts this
  updateSliders scriptsFrame
  scrollToY scriptsFrame newY
}

method scrollToXY MicroBlocksScripter x y {
	scrollToX scriptsFrame (x + (left (morph scriptsFrame)))
	scrollToY scriptsFrame (y + (top (morph scriptsFrame)))
}

method hideAllMyBlocks MicroBlocksScripter libName {
  for f (functions (main mbProject)) {
	internalHideDefinition this (functionName f)
  }
  saveScripts this
  scrollToX scriptsFrame 0
  scrollToY scriptsFrame 0
  updateSliders scriptsFrame
}

method removeLibraryNamed MicroBlocksScripter libName {
  removeLibraryNamed mbProject libName
  variablesChanged (smallRuntime)
  updateLibraryList this
  languageChanged this
}

method showLibraryInfo MicroBlocksScripter libName {
	library = (libraryNamed mbProject libName)
	showLibraryInfo library (devMode)
}

method showAllLibraryDefinitions MicroBlocksScripter libName {
  lib = (libraryNamed mbProject libName)
  if (isNil lib) { return }
  newY = (height (morph (contents scriptsFrame))) // current bottom
  for f (functions lib) {
	internalShowDefinition this (functionName f)
  }
  saveScripts this
  updateSliders scriptsFrame
  scrollToY scriptsFrame newY
}

method hideAllLibraryDefinitions MicroBlocksScripter libName {
  lib = (libraryNamed mbProject libName)
  if (isNil lib) { return }
  for f (functions lib) {
	internalHideDefinition this (functionName f)
  }
  saveScripts this
  scrollToX scriptsFrame 0
  scrollToY scriptsFrame 0
  updateSliders scriptsFrame
}

method exportLibrary MicroBlocksScripter libName {
  lib = (libraryNamed mbProject libName)
  if (isNil lib) { return }

  if ('Browser' == (platform)) {
	fName = (join (moduleName lib) '.ubl')
	browserWriteFile (codeString lib mbProject) fName 'library'
  } else {
	fName = (fileToWrite (moduleName lib) (array '.ubl'))
	if ('' == fName) { return false }
	if (not (endsWith fName '.ubl' )) { fName = (join fName '.ubl') }
	writeFile fName (codeString lib mbProject)
  }
}

// layout

method fixLayout MicroBlocksScripter {
  scale = (global 'scale')
  catWidth = (max (toInteger ((width (morph categorySelector)) / scale)) (20 * scale))
  catHeight = ((heightForItems categorySelector) / scale)
  blocksWidth = (max (toInteger ((width (morph blocksFrame)) / scale)) (20 * scale))
  columnHeaderHeight = 33

  // prevent pane dividers from going off right side
  catWidth = (min catWidth ((width morph) - (20 * scale)))
  blocksWidth = (min blocksWidth ((width morph) - (catWidth + (20 * scale))))

  packer = (newPanePacker (bounds morph) scale)
  packPanesH packer categorySelector catWidth blocksFrame blocksWidth scriptsFrame '100%'
  packPanesH packer libHeader catWidth blocksFrame blocksWidth scriptsFrame '100%'
  packPanesH packer libSelector catWidth blocksFrame blocksWidth scriptsFrame '100%'
  packPanesV packer categorySelector catHeight libHeader columnHeaderHeight libSelector '100%'
  packPanesV packer blocksFrame '100%'
  packPanesV packer scriptsFrame '100%'
  finishPacking packer

  // extra damage report for area below libSelector
  libSelectorM = (morph libSelector)
  reportDamage morph (rect 0 (bottom libSelectorM) (width libSelectorM) (height morph))

  fixResizerLayout this
  fixLibraryHeaderLayout this
  updateSliders blocksFrame
  updateSliders scriptsFrame
}

method fixResizerLayout MicroBlocksScripter {
  resizerWidth = (10 * (global 'scale'))

  // categories pane resizer
  setLeft (morph catResizer) (right (morph categorySelector))
  setTop (morph catResizer) (top morph)
  setExtent (morph catResizer) resizerWidth (height morph)

  // blocks pane resizer
  setLeft (morph blocksResizer) (right (morph blocksFrame))
  setTop (morph blocksResizer) (top morph)
  setExtent (morph blocksResizer) resizerWidth (height morph)
}

method hideScrollbars MicroBlocksScripter {
  hideSliders blocksFrame
  hideSliders scriptsFrame
}

method showScrollbars MicroBlocksScripter {
  showSliders blocksFrame
  showSliders scriptsFrame
}

// drawing

method drawOn MicroBlocksScripter ctx {
  scale = (global 'scale')
  borderColor = (gray 150)
  borderWidth = (2 * scale)
  x = (right (morph categorySelector))
  fillRect ctx (gray 240) 0 (top morph) x (height morph) // bg color for category/lib panes
  fillRect ctx borderColor x (top morph) borderWidth (height morph)
  x = (right (morph blocksFrame))
  fillRect ctx borderColor x (top morph) borderWidth (height morph)
  r = (bounds (morph libHeader))
  fillRect ctx borderColor (left r) ((top r) - borderWidth) (width r) borderWidth
  fillRect ctx borderColor (left r) (bottom r) (width r) borderWidth
}

// MicroBlocksScripter UI support

method developerModeChanged MicroBlocksScripter {
  catList = categorySelector
  setCollection catList (categories this)
  if (not (or (contains (collection catList) (selection catList))
  			  (notNil (selection libSelector)))) {
    select catList 'Output'
  } else {
    updateBlocks this
  }
}

method categories MicroBlocksScripter {
  initMicroBlocksSpecs (new 'SmallCompiler')
  result = (list 'Output' 'Input' 'Pins' 'Comm' 'Control' 'Operators' 'Variables' 'Data' 'My Blocks')
  if (not (devMode)) {
  	removeAll result (list 'Comm')
  }
  return result
}

method selectCategory MicroBlocksScripter aCategory {
  select categorySelector aCategory
  categorySelected this
}

method currentCategory MicroBlocksScripter {
  return (selection categorySelector)
}

method categorySelected MicroBlocksScripter {
   select libSelector nil // deselect library
   updateBlocks this
}

method selectLibrary MicroBlocksScripter aLibrary {
  select libSelector aLibrary
  librarySelected this
}

method currentLibrary MicroBlocksScripter {
  return (selection libSelector)
}

method librarySelected MicroBlocksScripter {
   select categorySelector nil // deselect category
   updateBlocks this
}

method updateBlocks MicroBlocksScripter {
  scale = (global 'scale')
  blocksPane = (contents blocksFrame)
  hide (morph blocksPane) // suppress damage reports while adding blocks
  removeAllParts (morph blocksPane)
  setRule (alignment blocksPane) 'none'

  nextX = ((left (morph (contents blocksFrame))) + (16 * scale))
  nextY = ((top (morph (contents blocksFrame))) + (16 * scale))

  cat = (selection categorySelector)
  if (isNil cat) {
	addBlocksForLibrary this (selection libSelector)
  } ('Variables' == cat) {
	addVariableBlocks this
    addAdvancedBlocksForCategory this cat
  } ('My Blocks' == cat) {
    addMyBlocks this
  } else {
	addBlocksForCategory this cat
  }
  cleanUp blocksPane
  show (morph blocksPane) // show after adding blocks
  updateSliders blocksFrame
}

method addBlocksForCategory MicroBlocksScripter cat {
  addBlocksForSpecs this (specsFor (authoringSpecs) cat)
  addAdvancedBlocksForCategory this cat
}

method addAdvancedBlocksForCategory MicroBlocksScripter cat {
  advancedSpecs = (specsFor (authoringSpecs) (join cat '-Advanced'))
  if (and (devMode) (not (isEmpty advancedSpecs))) {
	addSectionLabel this (localized 'Advanced:')
	addBlocksForSpecs this advancedSpecs
  }
}

method addBlocksForSpecs MicroBlocksScripter specList {
  for spec specList {
	if ('-' == spec) {
	  // add some vertical space
	   nextY += (20 * (blockScale))
	} else {
	  addBlock this (blockForSpec spec) spec
	}
  }
}

method addBlocksForLibrary MicroBlocksScripter libName {
  if (isNil libName) { return }
  lib = (at (libraries mbProject) libName)
  if (isNil lib) { return }

  for op (blockList lib) {
	if ('-' == op) {
	  // add some vertical space
	   nextY += (20 * (global 'scale'))
	} (or (showHiddenBlocksEnabled projectEditor) (not (beginsWith op '_'))) {
	  spec = (specForOp (authoringSpecs) op)
	  if (notNil spec) {
	  	addBlock this (blockForSpec spec) spec
	  }
	}
  }
}

to caseInsensitiveLessThan s1 s2 {
  return ((toUpperCase s1) < (toUpperCase s2))
}

method addVariableBlocks MicroBlocksScripter {
  scale = (global 'scale')

  addButton this (localized 'Add a variable') (action 'createVariable' this)
  visibleVars = (visibleVars this)
  if (notEmpty visibleVars) {
	addButton this (localized 'Delete a variable') (action 'deleteVariableMenu' this)
  }

  // add set/change variable
  nextY += (20 * scale)
  defaultVarName = ''
  if (notEmpty visibleVars) { defaultVarName = (first visibleVars) }

  addBlock this (toBlock (newCommand '=' defaultVarName 0)) nil false
  addBlock this (toBlock (newCommand '+=' defaultVarName 1)) nil false
  if (or (devMode) (contains (commandLine) '--allowMorphMenu')) {
    nextY += (10 * scale)
    addBlock this (toBlock (newCommand 'local' 'var' 0)) nil false
  }

  nextY += (20 * scale)

  if (notEmpty visibleVars) {
    visibleVars = (sorted (toArray visibleVars) 'caseInsensitiveLessThan')
	for varName visibleVars {
	    lastY = nextY
	    b = (toBlock (newReporter 'v' varName))
	    addBlock this b nil // true xxx
//	    readout = (makeMonitor b)
// 	    setGrabRule (morph readout) 'ignore'
// 	    setStyle readout 'varPane'
// 	    setPosition (morph readout) nextX lastY
// 	    addPart (morph (contents blocksFrame)) (morph readout)
// 	    step readout
	}
	nextY += (5 * scale)
  }

}

method addMyBlocks MicroBlocksScripter {
  scale = (global 'scale')

  addButton this (localized 'Add a command block') (action 'createFunction' this false)
  addButton this (localized 'Add a reporter block') (action 'createFunction' this true)
  nextY += (8 * scale)

  for f (functions (main mbProject)) {
	if (or (showHiddenBlocksEnabled projectEditor) (not (beginsWith (functionName f) '_'))) {
	  spec = (specForOp (authoringSpecs) (functionName f))
	  if (isNil spec) { spec = (blockSpecFor f) }
	  addBlock this (blockForSpec spec) spec
	}
  }
}

method addButton MicroBlocksScripter label action hint {
  btn = (newButton label action)
  if (notNil hint) { setHint btn hint }
  setPosition (morph btn) nextX nextY
  addPart (morph (contents blocksFrame)) (morph btn)
  nextY += ((height (morph btn)) + (7 * (global 'scale')))
}

method addBlock MicroBlocksScripter b spec isVarReporter {
  // install a 'morph' variable reporter for any slot that has 'morph' or 'Morph' as a hint

  if (isNil spec) { spec = (blockSpec b) }
  if (isNil isVarReporter) { isVarReporter = false }
  scale = (global 'scale')
  if (notNil spec) {
	inputs = (inputs b)
	for i (slotCount spec) {
	  hint = (hintAt spec i)
	  if (and (isClass hint 'String') (endsWith hint 'orph')) {
		replaceInput b (at inputs i) (toBlock (newReporter 'v' 'morph'))
	  }
	  if ('page' == hint) {
		replaceInput b (at inputs i) (toBlock (newReporter 'v' 'page'))
	  }
	}
  }
  fixLayout b
  setGrabRule (morph b) 'template'
  setPosition (morph b) nextX nextY
  if isVarReporter { setLeft (morph b) (nextX + (135 * scale)) }
  addPart (morph (contents blocksFrame)) (morph b)
  nextY += ((height (morph b)) + (4 * (global 'scale')))
}

// Palette Section Labels

method addSectionLabel MicroBlocksScripter label {
  scale = (global 'scale')
  labelColor = (gray 80)
  fontSize = (14 * scale)
  label = (newText label 'Arial Bold' fontSize labelColor)
  nextY += (12 * scale)
  setPosition (morph label) (nextX - (10 * scale)) nextY
  addPart (morph (contents blocksFrame)) (morph label)
  nextY += ((height (morph label)) + (12 * scale))
}

// project creation and loading

method createEmptyProject MicroBlocksScripter {
  mbProject = (newMicroBlocksProject)
  clearBoardIfConnected (smallRuntime) true
  if (notNil scriptsFrame) {
	removeAllParts (morph (contents scriptsFrame))
	restoreScripts this
	saveScripts this
  }
}

method loadOldProjectFromClass MicroBlocksScripter aClass specs {
  // Load an old-style (GP-format) MicroBlocks project from the given class and spec list.

  mbProject = (newMicroBlocksProject)
  clearBoardIfConnected (smallRuntime) true
  if (notNil aClass) {
	loadFromOldProjectClassAndSpecs mbProject aClass specs
  }
  restoreScripts this
}

method loadNewProjectFromData MicroBlocksScripter aString updateLibraries {
  // Load an new-style MicroBlocks project from the given string.

  mbProject = (newMicroBlocksProject)
  clearBoardIfConnected (smallRuntime) true
  loadFromString mbProject aString updateLibraries
  restoreScripts this
}

method setProject MicroBlocksScripter aMicroBlocksProject {
  mbProject = aMicroBlocksProject
  restoreScripts this
}

// variable operations

method visibleVars MicroBlocksScripter {
  // Include vars that start with underscore only in dev mode.

  allVars = (allVariableNames mbProject)
  if (showHiddenBlocksEnabled projectEditor) {
    return allVars
  } else {
    return (filter
      (function each { return (not (beginsWith each '_')) })
      allVars)
  }
}

method createVariable MicroBlocksScripter srcObj {
  varName = (trim (freshPrompt (global 'page') 'New variable name?' ''))
  if (varName != '') {
	addVariable (main mbProject) (uniqueVarName this varName)
	variablesChanged (smallRuntime)
	updateBlocks this
	if (isClass srcObj 'InputSlot') {
	  setContents srcObj varName
	}
  }
}

method uniqueVarName MicroBlocksScripter varName forScriptVar {
  // If varName matches global variable, return a unique variant of it.
  // Otherwise, return varName unchanged.

  if (isNil forScriptVar) { forScriptVar = false }
  existingVars = (toList (allVariableNames mbProject))
  scripts = (scripts (main mbProject))
  if (and (notNil scripts) (not forScriptVar)) {
	for entry scripts {
	  for b (allBlocks (at entry 3)) {
		if (isOneOf (primName b) 'local' 'for') {
		  add existingVars (first (argList b))
		}
	  }
	}
  }
  return (uniqueNameNotIn existingVars varName)
}

method deleteVariableMenu MicroBlocksScripter {
  if (isEmpty (visibleVars this)) { return }
  menu = (menu nil (action 'deleteVariable' this) true)
  for v (visibleVars this) {
    addItem menu v
  }
  popUpAtHand menu (global 'page')
}

method deleteVariable MicroBlocksScripter varName {
  deleteVariable (main mbProject) varName
  variablesChanged (smallRuntime)
  updateBlocks this
}

// save and restore scripts in class

method scriptChanged MicroBlocksScripter {
  runtime = (smallRuntime)
  updateHighlights runtime
  saveNeeded = true
// Check whether the block has just been moved.
// Commented out for now, since it seems to not be reliable enough, causing some
// changes to fail to propagate to the board.
//  for m (parts (morph (contents scriptsFrame))) {
//	b = (handler m)
//    if (isClass b 'Block') {
//	  entry = (chunkEntryForBlock runtime b)
//	  saveNeeded = (or (isNil entry) ((sourceForChunk runtime b) != (at entry 4)))
//	}
//  }
}

method functionBodyChanged  MicroBlocksScripter { saveNeeded = true }

method step MicroBlocksScripter {
  // Note: Sometimes get bursts of multiple 'changed' events, but those
  // events merely set the saveNeeded flag. This method does the actual
  // saveScripts if the saveNeeded flag is true.

  if saveNeeded {
    saveScripts this
	syncScripts (smallRuntime)
    saveNeeded = false
  }
  updateStopping (smallRuntime)
}

method saveScripts MicroBlocksScripter oldScale {
  scale = (blockScale)
  if (notNil oldScale) { scale = oldScale }
  scriptsPane = (contents scriptsFrame)
  paneX = (left (morph scriptsPane))
  paneY = (top (morph scriptsPane))
  scriptsCopy = (list)
  for m (parts (morph scriptsPane)) {
    if (isClass (handler m) 'Block') {
      x = (((left m) - paneX) / scale)
      y = (((top m) - paneY) / scale)
      script = (expression (handler m) 'main')
      if ('to' == (primName script)) {
        updateFunctionOrMethod this script
        args = (argList script)
        // only store the stub for a function in scripts
		script = (newCommand (primName script) (first args))
      }
      add scriptsCopy (array x y script)
    }
  }
  setScripts (main mbProject) scriptsCopy
}

method updateFunctionOrMethod MicroBlocksScripter script {
  args = (argList script)
  functionName = (first args)
  newCmdList = (last args)
  if ('to' == (primName script)) {
    f = (functionNamed mbProject functionName)
  }
  if (notNil f) {
    updateCmdList f newCmdList
    removeFieldsFromLocals f (allVariableNames mbProject)
  }
}

method restoreScripts MicroBlocksScripter {
  scale = (blockScale)
  scriptsPane = (contents scriptsFrame)
  removeAllParts (morph scriptsPane)
  clearDropHistory scriptsPane

  scripts = (scripts (main mbProject))
  if (notNil scripts) {
	editor = (findMicroBlocksEditor)
    scriptCount = (count scripts)
    paneX = (left (morph scriptsPane))
    paneY = (top (morph scriptsPane))
    for i scriptCount {
      entry = (at scripts i)
      dta = (last entry)
      if ('to' == (primName dta)) {
        func = (functionNamed mbProject (first (argList dta)))
        if (notNil func) {
		  block = (scriptForFunction func)
		} else {
		  // can arise when viewing a class from an imported module; just skip it for now
		  block = nil
		}
      } else {
        block = (toBlock dta)
      }
      if (notNil block) {
		x = (paneX + ((at entry 1) * scale))
		y = (paneY + ((at entry 2) * scale))
		fastMoveBy (morph block) x y
		addPart (morph scriptsPane) (morph block)
		fixBlockColor block
	  }
    }
  }
  updateSliders scriptsFrame
  updateBlocks this
}

method updateScriptAfterOperatorChange MicroBlocksScripter aBlock {
  // Rebuild the script containing aBlock after switching operators.

  topBlock = (topBlock aBlock)
  expr = (expression topBlock 'main')
  if ('to' == (primName expr)) {
    updateFunctionOrMethod this expr
    func = (functionNamed mbProject (first (argList expr)))
    newBlock = (scriptForFunction func)
  } else {
    newBlock = (toBlock expr)
  }
  removeFromOwner (morph topBlock)
  fastMoveBy (morph newBlock) (left (morph topBlock)) (top (morph topBlock))
  addPart (morph (contents scriptsFrame)) (morph newBlock)
  scriptChanged this
}

// hide/show block definition

method hideDefinition MicroBlocksScripter funcName {
  // Hide the given method/function definition.

  internalHideDefinition this funcName
  saveScripts this
  updateSliders scriptsFrame
}

method internalHideDefinition MicroBlocksScripter funcName {
  // Internal helper method.
  // Hide the given method/function definition but does not save the scripts.

  scriptsPaneM = (morph (contents scriptsFrame))
  for m (parts scriptsPaneM) {
    b = (handler m)
    if (isClass b 'Block') {
      proto = (editedPrototype b)
      if (and (notNil proto) (funcName == (functionName (function proto)))) {
        removeFromOwner m
      }
    }
  }
}

method showDefinition MicroBlocksScripter funcName {
  if (not (isShowingDefinition this funcName)) {
    internalShowDefinition this funcName
    saveScripts this
    updateSliders scriptsFrame
  }
  scrollToDefinitionOf this funcName
}

method internalShowDefinition MicroBlocksScripter funcName {
  // Internal helper method.
  // Adds function definition to scripts pane but does not save the scripts.

  if (isShowingDefinition this funcName) { return } // already showing
  f = (functionNamed mbProject funcName)
  if (isNil f) { return }
  scale = (blockScale)
  scriptsPaneM = (morph (contents scriptsFrame))

  // find a position for the defintion below all other scripts
  x = ((left scriptsPaneM) + (50 * scale))
  y = ((top scriptsPaneM) + (50 * scale))
  for m (parts scriptsPaneM) {
    if (isClass (handler m) 'Block') {
	  mBnds = (fullBounds m)
	  if ((left mBnds) < x) { x = (left mBnds) }
	  if ((bottom mBnds) > y) { y = (bottom mBnds) }
    }
  }

  // add the definition and save the scripts
  block = (scriptForFunction f)
  fastSetPosition (morph block) x y
  addPart scriptsPaneM (morph block)
}

method isShowingDefinition MicroBlocksScripter funcName {
  for entry (scripts (main mbProject)) {
	cmd = (at entry 3) // third item of entry is command
	if ('to' ==  (primName cmd)) {
	  if (funcName == (first (argList cmd))) { return true }
	}
  }
  return false // not found
}

method findDefinitionOf MicroBlocksScripter funcName {
  for m (parts (morph (contents scriptsFrame))) {
    if (isClass (handler m) 'Block') {
      def = (editedDefinition (handler m))
      if (notNil def) {
        if ((op def) == funcName) {
          return m
        }
      }
    }
  }
  return nil
}

method scrollToDefinitionOf MicroBlocksScripter funcName {
  m = (findDefinitionOf this funcName)
  if (notNil m) {
	scrollIntoView scriptsFrame (fullBounds m) true
  }
}

// Build Your Own Blocks

method createFunction MicroBlocksScripter isReporter {
  name = (freshPrompt (global 'page') 'Enter function name:' 'myBlock')
  if (name == '') {return}
  opName = (uniqueFunctionName this name)
  func = (defineFunctionInModule (main mbProject) opName (array) nil)
  blockType = ' '
  if isReporter { blockType = 'r' }
  spec = (blockSpecFromStrings opName blockType opName '')
  recordBlockSpec mbProject opName spec
  addToBottom this (scriptForFunction func)
  updateBlocks this
}

method copyFunction MicroBlocksScripter definition {
  primName = (primName definition)
  args = (argList definition)
  body = (last args)
  if (notNil body) { body = (copy body) }
  oldOp = (first args)
  oldSpec = (specForOp (authoringSpecs) oldOp)
  if ('to' == primName) {
	newOp = (uniqueFunctionName this oldOp)
	parameterNames = (copyFromTo args 2 ((count args) - 1))
	defineFunctionInModule (main mbProject) newOp parameterNames body
	if (notNil oldSpec) {
	  oldLabel = (first (specs oldSpec))
	  newLabel = (uniqueFunctionName this oldLabel)
	  newSpec = (copyWithOp oldSpec newOp oldLabel newLabel)
	} else {
	  newSpec = (blockSpecFor (functionNamed mbProject newOp))
	}
  }
  recordBlockSpec mbProject newOp newSpec
  return (newCommand primName newOp)
}

method uniqueFunctionName MicroBlocksScripter baseSpec {
  existingNames = (list)
  addAll existingNames (allOpNames (authoringSpecs))
  addAll existingNames (keys (blockSpecs (project projectEditor)))
  specWords = (words baseSpec)
  firstWord = (first specWords)
  if ('_' == firstWord) {
	firstWord = 'f'
	specWords = (join (array 'f') specWords)
  }
  atPut specWords 1 (uniqueNameNotIn existingNames firstWord)
  return (joinStrings specWords ' ')
}

// function deleting

method deleteFunction MicroBlocksScripter funcName {
  if (isShowingDefinition this funcName) { hideDefinition this funcName }
  f = (functionNamed mbProject funcName)
  if (notNil f) { removedUserDefinedBlock this f }
}

method removedUserDefinedBlock MicroBlocksScripter function {
  // Remove the given user-defined function.

  removeFunction (module function) function // in MicroBlocks the function "module" is its library
  deleteBlockSpecFor (project projectEditor) (functionName function)
  updateBlocks this
  saveNeeded = true
}

method addToBottom MicroBlocksScripter aBlock noScroll {
  if (isNil noScroll) {noScroll = false}
  space =  ((global 'scale') * 10)
  bottom = (top (morph (contents scriptsFrame)))
  left = ((left (morph (contents scriptsFrame))) + (50 * (global 'scale')))
  for script (parts (morph (contents scriptsFrame))) {
    left = (min left (left (fullBounds script)))
    bottom = (max bottom (bottom (fullBounds script)))
  }
  setPosition (morph aBlock) left (bottom + space)
  addPart (morph (contents scriptsFrame)) (morph aBlock)
  if (not noScroll) {
    scrollIntoView scriptsFrame (fullBounds (morph aBlock))
  }
  scriptChanged this
}

method blockPrototypeChanged MicroBlocksScripter aBlock {
  saveScripts this
  scriptsPane = (contents scriptsFrame)
  op = (primName (function aBlock))

  // update the definition body
  block = (handler (owner (morph aBlock)))
  nxt = (next block)
  if (and (notNil nxt) (containsPrim nxt op)) {
    body = (toBlock (cmdList (function aBlock)))
    setNext block nil
    setNext block body
    fixBlockColor block
  }

  // update the palette template
  updateBlocks this

  // update all calls
  if ('initialize' != op) {
	updateCallsOf this op
	updateCallsInScriptingArea this op
  }
  updateSliders scriptsFrame
}

method updateCallsOf MicroBlocksScripter op {
  // Update calls of the give operation to ensure that they have the minimum number
  // of arguments specified by the prototype and that the types of any constant
  // parameters match those of the the prototype.

  // get spec and extract arg types and default values
  spec = (specForOp (authoringSpecs) op)
  if (isNil spec) { return } // should not happen
  minArgs = (countInputSlots spec (first (specs spec)))
  isReporter = (isReporter spec)
  isVariadic = (or ((count (specs spec)) > 1) (repeatLastSpec spec))
  argTypes = (list)
  argDefaults = (list)
  for i (slotCount spec) {
	info = (slotInfoForIndex spec i)
	typeStr = (at info 1)
	defaultValue = (at info 2)
	if (and ('color' == typeStr) (isNil defaultValue)) {
      defaultValue = (color 35 190 30)
	}
	if (and ('auto' == typeStr) (isClass defaultValue 'String') (representsANumber defaultValue)) {
	  defaultValue = (toNumber defaultValue defaultValue)
	}
	add argTypes typeStr
	add argDefaults defaultValue
  }

  // update all calls
  s = (first (specs spec))
  origCmds = (list)
  newCmds = (list)
  gc
  for cmd (allCmdsInProject this) {
	if ((primName cmd) == op) {
	  add origCmds cmd
	  add newCmds (fixedCmd this cmd minArgs argTypes argDefaults isReporter isVariadic)
	}
  }
  // replace command/reporter objects with new versions
  replaceObjects (toArray origCmds) (toArray newCmds)
}

method allCmdsInProject MicroBlocksScripter {
  main = (main (project projectEditor))
  result = (dictionary)
  for f (functions main) {
	addAll result (allBlocks (cmdList f))
  }
  for s (scripts main) {
	addAll result (allBlocks (at s 3))
  }
  return (keys result)
}

method fixedCmd MicroBlocksScripter oldCmd minArgs argTypes argDefaults isReporter isVariadic {
  // Return an updated Command or Reporter.

  args = (toList (argList oldCmd))

  // add new arguments with default values
  while ((count args) < minArgs) {
	add args (at argDefaults ((count args) + 1))
  }

  // if not variadic, remove extra arguments
  if (not isVariadic) {
	while ((count args) > minArgs) {
	  removeLast args
	}
  }

  // fix type inconsistencies for non-expression arguments
 for i (min minArgs (count args) (count argTypes) (count argDefaults)) {
	arg = (at args i)
	if (not (isClass arg 'Reporter')) {
	  desiredType = (at argTypes i)
	  if (and ('auto' == desiredType) (not (or (isNumber arg) (isClass arg 'String')))) {
		atPut args i (at argDefaults i)
	  }
	  if (and ('bool' == desiredType) (not (isClass arg 'Boolean'))) {
		atPut args i (at argDefaults i)
	  }
	  if (and ('color' == desiredType) (not (isClass arg 'Color'))) {
		atPut args i (at argDefaults i)
	  }
	}
  }

  // create a new command/reporter with new args list
  if isReporter {
	result = (newIndexable 'Reporter' (count args))
  } else {
	result = (newIndexable 'Command' (count args))
	setField result 'nextBlock' (nextBlock oldCmd)
  }
  fixedFields = (fieldNameCount (classOf result))
  setField result 'primName' (primName oldCmd)
  for i (count args) {
    setField result (fixedFields + i) (at args i)
  }
  return result
}

method updateCallsInScriptingArea MicroBlocksScripter op {
  // Update scripts in the scripting pane that contain calls to the give op.

  // Workaround for recursive structure crash bug:
  offsetX = (left (morph (contents scriptsFrame)))
  offsetY = (top (morph (contents scriptsFrame)))
  restoreScripts this
  setLeft (morph (contents scriptsFrame)) offsetX
  setTop (morph (contents scriptsFrame)) offsetY
  return

// Caution: the following code can create recursive structure that crash!
  scriptsPane = (contents scriptsFrame)
  affected = (list)
  for m (parts (morph scriptsPane)) {
	b = (handler m)
	if (and (isClass b 'Block') (containsPrim b op)) {
	  add affected b
	}
  }
  for each affected {
	expr = (expression each)
	if ('to' == (primName expr)) {
	  func = (functionNamed mbProject (first (argList expr)))
	  block = (scriptForFunction func)
	} else {
	  block = (toBlock expr)
	  setNext block (next each)
	}
	x = (left (morph each))
	y = (top (morph each))
	destroy (morph each)
	setPosition (morph block) x y
	addPart (morph scriptsPane) (morph block)
	fixBlockColor block
  }
}

// Library import/export

method importLibrary MicroBlocksScripter {
  if (downloadInProgress (findProjectEditor)) { return }
  libraryWindow = (findMorph 'MicroBlocksLibraryImportDialog')
  if (notNil libraryWindow) { destroy libraryWindow }
  pickLibraryToOpen (action 'openLibraryFile' this) lastLibraryFolder (array '.ubl')
}

method openLibraryFile MicroBlocksScripter fileName {
	importLibraryFromFile this fileName
	saveAllChunksAfterLoad (smallRuntime)
}

method allFilesInDir MicroBlocksScripter rootDir {
	// Return a list of all files below the given directory.

	result = (list)
	todo = (list rootDir)
	while (notEmpty todo) {
		dir = (removeFirst todo)
		for fName (listFiles dir) {
			add result (join dir '/' fName)
		}
		for dirName (listDirectories dir) {
			add todo (join dir '/' dirName)
		}
	}
	return result
}

method importEmbeddedLibrary MicroBlocksScripter libName {
	if ('Browser' == (platform)) {
		libFileName = (join libName '.ubl')
		for filePath (allFilesInDir this 'Libraries') {
			if (endsWith filePath libFileName) {
				importLibraryFromFile this filePath
				return
			}
		}
		return
	}
	for filePath (listEmbeddedFiles) {
		if (endsWith filePath (join libName '.ubl')) {
			importLibraryFromFile this (join '//' filePath)
			return
		}
	}
}

method importLibraryFromFile MicroBlocksScripter fileName data {
  // Import a library with the given file path. If data is not nil, it came from
  // a browser upload or file drop. Use it rather than attempting to read the file.

  if (isNil data) {
	if (beginsWith fileName '//') {
	  data = (readEmbeddedFile (substring fileName 3))
      lastLibraryFolder = 'Libraries'
	} else {
	  data = (readFile fileName)
      lastLibraryFolder = (directoryPart fileName)
	}
	if (isNil data) { return } // could not read file
  }

  libName = (withoutExtension (filePart fileName))
  importLibraryFromString this (toString data) libName fileName
}

method importLibraryFromUrl MicroBlocksScripter fullUrl {
	if (beginsWith fullUrl 'http://') {
		url = (substring fullUrl 8)
	} (beginsWith fullUrl 'https://') {
		// HTTPS is not supported, but we'll try to fetch the lib via HTTP, just
		// in case the remote server supports both SSL and plain HTTP
		url = (substring fullUrl 9)
	} else {
		url = fullUrl
	}
	host = (substring url 1 ((findFirst url '/') - 1))
	libPath = (substring url (findFirst url '/'))
	libName = (substring libPath ((findLast libPath '/') + 1) ((findLast libPath '.') - 1))
	libSource = (httpGet host libPath)

	// Check if response is valid
	if (isEmpty libSource) {
		(inform (global 'page')
			(localized 'Host does not exist or is currently down.')
			'Could not fetch library')
		return false
	} ((findSubstring '404' (first (lines libSource))) > 0) {
		// 404 not found. Host seems okay, but file can't be fetched.
		(inform (global 'page')
			(localized 'File not found in server.')
			'Could not fetch library')
		return false
	} ((findSubstring '301' (first (lines libSource))) > 0) {
		// Moved permanently. Normally returned when we try to access a URL by
		// HTTP and are redirected to the HTTPS equivalent
		(inform (global 'page')
			(localized 'Server expects HTTPS, and MicroBlocks doesn''t currently support it.')
			'Could not fetch library')
		return false
	}

	importLibraryFromString this libSource libName fullUrl
	return true
}

method importLibraryFromString MicroBlocksScripter data libName fileName {
	addLibraryFromString mbProject (toString data) libName fileName
	variablesChanged (smallRuntime)

	// update library list and select the new library
	updateLibraryList this
	select categorySelector nil
	select libSelector libName
	updateBlocks this
	saveScripts this
	restoreScripts this
}

method updateLibraryList MicroBlocksScripter {
  libNames = (sorted (keys (libraries mbProject)))
  setCollection libSelector libNames
  oldSelection = (selection libSelector)
  if (not (contains libNames oldSelection)) {
	selectCategory this 'Control'
  }
}

method justGrabbedPart MicroBlocksScripter part {
	print 'scripter part grabbed'
	print part
}

method setLibsDraggable MicroBlocksScripter flag {
	// deprecated; do nothing
}

method exportAsLibrary MicroBlocksScripter defaultFileName {
  if ('Browser' == (platform)) {
	if (or (isNil defaultFileName) ('' == defaultFileName)) {
		defaultFileName = (localized 'my library')
	}
	libName = (freshPrompt (global 'page') (localized 'Library name?') defaultFileName)
	fName = (join libName '.ubl')
	browserWriteFile (codeString (main mbProject) mbProject libName) fName 'library'
  } else {
	fName = (fileToWrite (withoutExtension defaultFileName) '.ubl')
	if (isEmpty fName) { return }
	if (not (endsWith fName '.ubl' )) { fName = (join fName '.ubl') }
	libName = (withoutExtension (filePart fName))
	writeFile fName (codeString (main mbProject) mbProject libName)
  }
}

// importing libraries for dropped scripts

method installLibraryNamed MicroBlocksScripter libName {
  if (notNil (libraryNamed mbProject libName)) { return } // library already installed
  fileName = (fileNameForLibraryNamed this libName)
  if (isNil fileName) {
    print 'Unknown library:' libName
    return
  }
  if (not (endsWith fileName '.ubl')) { fileName = (join fileName '.ubl') }
  if ('Browser' != (platform)) { fileName = (join '//' fileName) }
  importLibraryFromFile this fileName
}

method fileNameForLibraryNamed MicroBlocksScripter libName {
  if (isNil embeddedLibraries) {
	// build a dictionary mapping libName -> fileName
	embeddedLibraries = (dictionary)
	if ('Browser' == (platform)) {
	  for filePath (allFilesInDir this 'Libraries') {
		if (endsWith filePath '.ubl') {
		  name = (extractLibraryName this (readFile filePath))
		  if (notNil name) {
			atPut embeddedLibraries name filePath
		  }
		}
	  }
	} else {
	  for filePath (listEmbeddedFiles) {
		if (endsWith filePath '.ubl') {
		  name = (extractLibraryName this (readEmbeddedFile filePath))
		  if (notNil name) {
			atPut embeddedLibraries name (withoutExtension filePath)
		  }
		}
	  }
	}
  }
  return (at embeddedLibraries libName)
}

method extractLibraryName MicroBlocksScripter libData {
  if (isNil libData) { return nil }
  for line (lines libData) {
    if (beginsWith line 'module') {
      i = (findFirst line '''')
      if (notNil i) { // quoted library name
        j = (findLast line '''')
        if ((j - i) > 2) { return (substring line (i + 1) (j - 1)) }
      }
      return (at (words line) 2)
    }
  }
  return nil
}

// support for script copy-paste via clipboard or embedding in a PNG files

method scriptStringFor MicroBlocksScripter aBlock {
  // Return a script string for the given script.

  return (join
  	'GP Script' (newline)
  	(exportScripts (newMicroBlocksExchange) this (list (morph (topBlock aBlock)))))
}

method allScriptsString MicroBlocksScripter {
  // Return a string with all scripts in the scripting area.

  scriptsPaneM = (morph (contents scriptsFrame))
  paneX = (left scriptsPaneM)
  paneY = (top scriptsPaneM)
  return (join
    'GP Scripts' (newline)
    (exportScripts (newMicroBlocksExchange) this (parts scriptsPaneM) paneX paneY))
}

method pasteScripts MicroBlocksScripter scriptString atHand {
  // hide the definitions of functions that will be pasted
  scriptString = (normalizeLineEndings scriptString)
  for entry (parse scriptString) {
    args = (argList entry)
    if (and ('script' == (primName entry)) (3 == (count args)) (notNil (last args))) {
      script = (last args)
      if ('to' == (primName script)) {
        funcName = (first (argList script))
        internalHideDefinition this funcName
      }
    }
  }

  // find destination position for scripts
  if (isNil atHand) { atHand = false }
  if atHand {
  	// current hand position, adjusted for approximate menu offset
    hand = (hand (global 'page'))
    dstX = ((x hand) - (40 * (global 'scale')))
    dstY = ((y hand) - (90 * (global 'scale')))
  } else {
    dstX = ((left (morph (contents scriptsFrame))) + (100 * (global 'scale')))
    dstY = ((scriptsBottom this) + (30 * (blockScale)))
  }

  scriptsPane = (contents scriptsFrame)
  clearDropHistory scriptsPane
  importScripts (newMicroBlocksExchange) this scriptString dstX dstY
  scriptChanged this
  updateBlocks this
  saveScripts this
  updateSliders scriptsFrame
  if (notNil block) {
    scrollIntoView scriptsFrame (fullBounds (morph block)) true // favorTopLeft
  }
}

method scriptsBottom MicroBlocksScripter {
  // Return the vertical position of the bottom-most script in the scripting area.

  scriptsM = (morph (contents scriptsFrame))
  result = (top scriptsM)
  for m (parts scriptsM) {
    if (isClass (handler m) 'Block') {
	  mBnds = (fullBounds m)
	  if ((bottom mBnds) > result) { result = (bottom mBnds) }
    }
  }
  return result
}
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Copyright 2023 John Maloney, Bernat Romagosa, and Jens MÃ¶nig

// MicroBlocksSelection.gp - Selection rectangle, to deal with several scripts
//							 at the same time

// Bernat Romagosa, February, 2023

// MicroBlocksSelection

to startSelecting aScripter aHand {
	(initialize (new 'MicroBlocksSelection' aScripter (rect (x aHand) (y aHand))) aHand)
	savePosition aHand
}

to cancelSelection {
	scripter = (scripter (findMicroBlocksEditor))
	for p (allMorphs (morph (scriptEditor scripter))) {
		if (isClass (handler p) 'Block') { unselect (handler p) }
	}
	for p (parts (morph scripter)) {
		if (isClass (handler p) 'MicroBlocksSelection') { destroy (handler p) }
	}
	setSelection scripter nil
}

defineClass MicroBlocksSelection scripter rectangle morph blocks selecting

method initialize MicroBlocksSelection aHand {
	cancelSelection
	setSelection scripter this
	selecting = true

	blocks = (list)
	morph = (newMorph this)
	addPart (morph scripter) morph

	focusOn aHand this

	return this
}

method destroy MicroBlocksSelection {
	selecting = false
	destroy morph
}

// mouse events

method handMoveFocus MicroBlocksSelection aHand {
	updateSelection this aHand
	return true
}

method handUpOn MicroBlocksSelection aHand {
	endSelection this
	return true
}

// selecting

method updateSelection MicroBlocksSelection aHand {
	if selecting {
		setLeft rectangle (min (oldX aHand) (x aHand))
		setTop rectangle (min (oldY aHand) (y aHand))
		setWidth rectangle (abs ((x aHand) - (oldX aHand)))
		setHeight rectangle (abs ((y aHand) - (oldY aHand)))
		intersect rectangle (bounds (morph (scriptsFrame scripter)))
	}
	fixLayout this
}

method endSelection MicroBlocksSelection {
	if ((area rectangle) > 1) {
		for p (allMorphs (morph (scriptEditor scripter))) {
			if (isClass (handler p) 'Block') {
				if (intersects rectangle (bounds p)) {
					tb = (topBlock (handler p))
					if (not (contains blocks tb)) {
						add blocks tb
						select tb
					}
				}
			}
		}
	}
	selecting = false
	destroy this
}


// debugging

method toString MicroBlocksSelection {
	return (join 'selection: ' (toString blocks))
}

// drawing

method fixLayout MicroBlocksSelection {
	setExtent morph (width rectangle) (height rectangle)
	setPosition morph (left rectangle) (top rectangle)
}

method drawOn MicroBlocksSelection ctx {
	fillRect ctx (color 0 128 0 50) (left rectangle) (top rectangle) (width rectangle) (height rectangle) 1
}

// testing

method notEmpty MicroBlocksSelection { return (notEmpty blocks) }

method contains MicroBlocksSelection aBlock {
	return (contains blocks (topBlock aBlock))
}

method containsDefinitions MicroBlocksSelection {
	for block blocks { if (isPrototypeHat block) { return true } }
	return false
}

method containsBlocks MicroBlocksSelection {
	for block blocks { if (not (isPrototypeHat block)) { return true } }
	return false
}

// events

method handUpOn MicroBlocksSelection aHand {
	endSelection this
	return true
}

method handMoveOver MicroBlocksSelection aHand {
	updateSelection this aHand
	return true
}

// actions

method contextMenu MicroBlocksSelection {
	menu = (menu nil this)
	addItem menu 'duplicate selection' 'duplicateBlocks'
	addItem menu 'drag selection' 'dragBlocks'
	addLine menu
	addItem menu 'delete selection' 'deleteBlocks'
	return menu
}

method deleteBlocks MicroBlocksSelection {
	for block blocks {
		removeFromOwner (morph block)
		destroy (morph block)
	}
	cancelSelection
}

method duplicateBlocks MicroBlocksSelection {
	cancelSelection
	showTrashcan (findMicroBlocksEditor)
	contents = (initialize (new 'MicroBlocksSelectionContents') blocks true scripter)
	grab (hand (global 'page')) contents
}

method dragBlocks MicroBlocksSelection {
	cancelSelection
	showTrashcan this
	if ((count blocks) == 1) {
		grab (hand (global 'page')) (first blocks)
	} else {
		contents = (initialize (new 'MicroBlocksSelectionContents') blocks false scripter)
		grab (hand (global 'page')) contents
	}
}

method showTrashcan MicroBlocksSelection {
	purpose = 'delete'
	containsDefs = (containsDefinitions this)
	containsBlocks = (containsBlocks this)
	if (and containsDefs containsBlocks) {
		purpose = 'hideAndDelete'
	} containsDefs {
		purpose = 'hide'
	}
	showTrashcan (findMicroBlocksEditor) purpose
}

defineClass MicroBlocksSelectionContents morph

method initialize MicroBlocksSelectionContents someBlocks duplicating aScripter {
	morph = (newMorph this)
	for block someBlocks {
		if duplicating {
			addPart morph (morph (duplicate block))
		} else {
			addPart morph (morph block)
		}
	}
	addPart (morph (scriptEditor aScripter)) morph // just so it can be animated back to its owner
	return this
}

method justDropped MicroBlocksSelectionContents aHand {
	droppedInto = (owner morph)
	if (isClass (handler droppedInto) 'ScriptEditor') {
		for blockMorph (parts morph) {
			addPart droppedInto blockMorph
		}
		removeFromOwner morph
		scripter = (scripter (findProjectEditor))
		saveScripts scripter
		restoreScripts scripter
		scriptChanged scripter
	}
	hideTrashcan (findMicroBlocksEditor)
}

method destroy MicroBlocksSelectionContents {
	removeFromOwner morph
	destroy morph
}

method morph MicroBlocksSelectionContents { return morph }
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Copyright 2020 John Maloney, Bernat Romagosa, and Jens MÃ¶nig

// MicroBlocksSpinner.gp - A modal spinner animation
// Bernat Romagosa, October 2020

defineClass MicroBlocksSpinner morph label sublabel rotation labelGetter doneGetter task stopAction

to newSpinner labelReporter doneReporter {
	return (initialize (new 'MicroBlocksSpinner') labelReporter doneReporter)
}

method initialize MicroBlocksSpinner labelReporter doneReporter {
	labelGetter = labelReporter
	doneGetter = doneReporter

	morph = (newMorph this)
	setCostume morph (gray 0 80)
	rotation = 0

	scale = (global 'scale')
	label = (newText (localized (call labelGetter)) 'Arial' (24 * scale) (gray 255))
	addPart morph (morph label)

	sublabel = (newText (localized '(press ESC to cancel)') 'Arial' (18 * scale) (gray 255))
	addPart morph (morph sublabel)

	pageM = (morph (global 'page'))
	setExtent morph (width (bounds pageM)) (height (bounds pageM))

	setFPS morph 4
	fixLayout this
	return this
}

method fixLayout MicroBlocksSpinner {
	pageM = (morph (global 'page'))
	setExtent morph (width (bounds pageM)) (height (bounds pageM))
	gotoCenterOf morph pageM
	gotoCenterOf (morph label) pageM
	gotoCenterOf (morph sublabel) pageM
	moveBy (morph label) 0 105
	moveBy (morph sublabel) 0 170
}

method drawOn MicroBlocksSpinner ctx {
	r = (bounds morph)
	fillRect ctx (costumeData morph) (left r) (top r) (width r) (height r) 1
	pen = (pen (getShapeMaker ctx))
	beginPath pen (hCenter r) (vCenter r)
	setHeading pen rotation
	repeat 2 {
		forward pen 50
		turn pen 180
		forward pen 100
		forward pen -50
		turn pen 90
	}
	stroke pen (gray 230) 25
}

method spinnerChanged MicroBlocksSpinner {
	bnds = (bounds morph)
	left = ((hCenter bnds) - 60)
	top = ((vCenter bnds) - 60)
	reportDamage (owner morph) (rect left top 120 120)
}

method task MicroBlocksSpinner { return task }
method setTask MicroBlocksSpinner aTask { task = aTask }

method setStopAction MicroBlocksSpinner anAction { stopAction = anAction }

method destroy MicroBlocksSpinner {
	setCursor 'default'
	if (notNil stopAction) {
		call stopAction
	}
	if (notNil task) {
		terminate task
	}
	destroy morph
}

method step MicroBlocksSpinner {
	if (call doneGetter) {
		setCursor 'default'
		destroy this
		return
	}

	setCursor 'wait'
	rotation = ((rotation + 30) % 360)
	spinnerChanged this
	setText label (localized (call labelGetter))
	setXCenter (morph label) (hCenter (bounds morph))
}
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Copyright 2019 John Maloney, Bernat Romagosa, and Jens MÃ¶nig

// MicroBlocksTipBar.gp - A bar that displays useful information about the item under the mouse
// Bernat Romagosa, November 2021

defineClass MicroBlocksTipBar morph title tipMorph tip contentDict iconsDict help

method initialize MicroBlocksTipBar {
	morph = (newMorph this)
	setClipping morph true
	setFPS morph 5

	initContents this
	initIcons this
	help = (initialize (new 'MicroBlocksHelp'))

	titleFontName = 'Arial Bold'
	titleFontSize = (14 * (global 'scale'))
	if ('Linux' == (platform)) { titleFontSize = (12 * (global 'scale')) }
	title = (newText '' titleFontName titleFontSize (gray 0) 'left' nil 0 0 5 3)
	addPart morph (morph title)

	tip = (newAlignment 'centered-line' 0 'bounds')
	tipMorph = (newMorph tip)
	setMorph tip tipMorph
	addPart morph tipMorph
	return this
}

method helpEntry MicroBlocksTipBar primName { return (entryForOp help primName) }
method title MicroBlocksTipBar { return title }
method setTitle MicroBlocksTipBar aTitle { setText title (localized aTitle) }
method tip MicroBlocksTipBar { return tip }

method setTip MicroBlocksTipBar aTip {
	// Tips can contain icon placeholders, like so:
	// [l] run this block [r] open context menu

	fontName = 'Arial'
	fontSize = (14 * (global 'scale'))
	if ('Linux' == (platform)) { fontSize = (12 * (global 'scale')) }

	removeAllParts tipMorph
	text = ' '
	if (isNil aTip) {
		return
	}
	for word (words (localized aTip)) {
		if (contains (keys iconsDict) word) {
			if ((count text) > 0) {
				addPart tipMorph (morph (newText text fontName fontSize (gray 0) 'left' nil 0 0 5 3))
				text = ' '
			}
			icon = (newMorph)
			setCostume icon (at iconsDict word)
			setPosition icon 0 0
			addPart tipMorph icon
		} else {
			text = (join text word ' ')
		}
	}
	if ((count text) > 0) {
		addPart tipMorph (morph (newText text fontName fontSize (gray 0) 'left' nil 0 0 5 3))
	}
	fixLayout tip
}

// drawing

method drawOn MicroBlocksTipBar ctx {
	fillRectangle (getShapeMaker ctx) (bounds morph) (gray 200)
}

// stepping

method step MicroBlocksTipBar {
	hand = (hand (global 'page'))
	if (and (isClass (grabbedObject hand) 'Block') (isClass (objectAt hand) 'BlocksPalette')) {
		updateTip this (objectAt hand)
	} (isBusy hand) {
		setTitle this ''
		setTip this ''
	} else {
		updateTip this (objectAt hand)
	}
}

method updateTip MicroBlocksTipBar anElement {
	contents = (contentsFor this anElement)
	setTitle this (at contents 1)
	setTip this (at contents 2)
	fixLayout this
}

method fixLayout MicroBlocksTipBar {
	scale = (global 'scale')
	page = (global 'page')
	setExtent morph (width page) (22 * scale)

	setLeft (morph title) ((left morph) + (3 * scale))
	setLeft tipMorph ((right (morph title)) + (1 * scale))

	top = (top morph)
	if ('Linux' != (platform)) { top += (2 * scale) }
	setTop (morph title) top
	setTop tipMorph top
}

// tip Contents

method initContents MicroBlocksTipBar {
	contentDict = (dictionary)
	atPut contentDict 'BooleanSlot' (array 'Boolean Input' '[l] toggle value, or drop a reporter into it.')
	atPut contentDict 'ColorSlot' (array 'Color Input' '[l] change the color, or drop a reporter into it.')
	atPut contentDict 'InputSlot' (array 'Input' '[l] edit its value, or drop a reporter into it.')
	atPut contentDict 'BlockDrawer' (array 'Block Extension' '[l] right arrow to show optional inputs, left arrow to hide.')

	atPut contentDict 'Command' (array 'Command Block' '[l] to run, or drag to build scripts. [r] menu.')
	atPut contentDict 'Hat' (array 'Hat Block' '[l] to run, or drag to build scripts. [r] menu.')
	atPut contentDict 'Reporter' (array 'Reporter Block' '[l] to see value, or drop into an input slot. [r] menu.')
	atPut contentDict 'Script' (array 'Script' '[l] to run. [r] menu.')

	atPut contentDict 'PaneResizer' (array 'Pane Divider' 'Drag to change pane width.')
	atPut contentDict 'Library' (array 'Library' '[l] to show the blocks in this library. [r] menu.')
	atPut contentDict 'BlockCategory' (array 'Block Category' '[l] to show the blocks in this category.')
	atPut contentDict 'BlocksPalette' (array 'Palette' 'Drag blocks from here to build scripts. Drop scripts here to delete them.')

	atPut contentDict 'ScriptEditor' (array 'Scripts Pane' 'Drag blocks here to build scripts. [r] menu.')
}

method contentsFor MicroBlocksTipBar anElement {
	key = (className (classOf anElement))
	if ('Button' == key) {
		return (array 'Button' (hint anElement))
	}
	block = nil
	if ('Block' == key) { block = anElement }
	if ('Text' == key) {
		if (notNil (ownerThatIsA (morph anElement) 'InputSlot')) {
			key = 'InputSlot'
		} (notNil (ownerThatIsA (morph anElement) 'Block')) {
			block = (handler (ownerThatIsA (morph anElement) 'Block'))
		}
	}
	if ('Slider' == key) {
		paneM = (ownerThatIsA (morph anElement) 'ScrollFrame')
		if (notNil paneM) {
			key = (className (classOf (contents (handler paneM))))
		}
	}
	if (notNil block) {
		topBlock = (topBlock block)
		if (and ('hat' == (type block)) (isNil (next block))) {
			key = 'Hat'
		} ('reporter' == (type block)) {
			if (block == topBlock) { // stand-alone reporter
				key = 'Reporter'
			} else { // reporter in a script
				key = 'Script'
			}
		} else {
			if (and (block == topBlock) (isNil (next block))) { // stand-alone command
				key = 'Command'
			} else {
				key = 'Script'
			}
		}
	}
	if (isClass anElement 'CategorySelector') {
		category = (categoryUnderHand anElement)
		items = (collection anElement)
		if (and (notEmpty items) ('Output' == (first items))) {
			key = 'BlockCategory'
		} else {
			key = 'Library'
		}
	}
	content = (at contentDict key)
	if (isNil content) { // no match
		devMode = false
		if devMode { return (array key '') } // show key in tip bar during development
		return (array '' '')
	}
	if (isOneOf key 'Reporter' 'Command' 'Hat') {
 		helpEntry = (helpEntry this (primName (expression block)))
 		if (notNil helpEntry) {
 			if (devMode) {
 				// just show the help string
 				fullDescription = (at helpEntry 3)
 			} else {
 				// show help string and gesture hints
				fullDescription = (join (localized (at helpEntry 3)) '    ' (localized (at content 2)))
 			}
 			content = (copy content)
 			atPut content 2 fullDescription
 		}
 	}
	return content
}

// icons

method initIcons MicroBlocksTipBar {
	iconsDict = (dictionary)
	atPut iconsDict '[l]' (leftClickLogo this)
	atPut iconsDict '[r]' (rightClickLogo this)
	atPut iconsDict '(-o)' (trueLogo this)
	atPut iconsDict '(o-)' (falseLogo this)
}

method rightClickLogo MicroBlocksTipBar {
	dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAABwAAAAkCAYAAACaJFpUAAAACXBIWXMAACRyAAAkcgG1MFKpAAAAGXRF
WHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAkhJREFUSInt17trFFEUx/HPLj6jaBJFRcUH
2NpYSFARBB8YiKIIEsTSRyHiX+ALW7EQxRAUIWgK0UL9C6ysRAW1EJOgJIKPqImaKDFrMWfJZPPYzZKx
8gcDe8/9nfOdO3P3XCZnci3BXjRhHVZgQYmnD914jQe4jw9l6o7RIlzCLxRS1w904E1cHRFLewZxEfWV
wrbiYyT34Qq2j7OytBZgB66iP3I/YEs5WHNqVa1YWuldprQMN4ys9uBExk0B+40jFRRuQwvOYidmlcwf
i1qDaChNXoieuKujFcDgu9Hv7hNOYWbKczzmupW8kgsxcbNC2HjA4vUIi1O+toifLwbqIvknlk8DsICn
mBe+lVG7X/IkHQpTyxRg5YAFXE95WyPWDO0xaJxm4B+sD29TxG7B8xhM9j+rBljA5fAujPEzkt3VN0VY
pcCOlL9ftLxhdGUEHMbs8HdhOI9cTGahnOQAEIxcPiNQWvkJBxloQNJl/hmwHUOlwQI6qyhWbtM8FJ0l
1InCjCpARR3GePnDeIWXEyVWu8KpqhOFf7FLR+k/8D9wysrhS/yuy5j1DUN5Sa+rRU2GsPmSA74nb6Qj
bMsQWKz9Ag5Ius2dDIF3g7Ef5uJdBHZlANsdtd9iTjHYGMEv2DyNsI34HLX3lE6ei4mfOCNZebWqiXoD
UfP0RMaTASygF9ewD6sqgKwOb4vkSRVv/kS5xLWSk3rQ2EO119gP0t5xfIO4jTWlxXOTgOslu6oBGyTf
fbXGPuoBfMV7PMFj3DPSUEbpLyCd4FksPh5fAAAAAElFTkSuQmCC'
	data = '
iVBORw0KGgoAAAANSUhEUgAAAA4AAAASCAYAAABrXO8xAAAACXBIWXMAABI5AAASOQEodzeCAAAAGXRF
WHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAQBJREFUOI2l07EuBFEUxvGfmdVSoeAlSBD2
Hai1REJJKd6EByCh8AYkhEhQUNlCqdmwG0RjjGLu2DXZzc7El9zk5nznf+45uffS0TA2cYEWXsJq4Rwb
IeePJnCNA8wi7vJizOEQVxjPjRousVWshjucYgURtkNHMazhqAcEX0jxjhMM4RircIaFAWCKN6xjMXSh
WZipH5jiOYzWjAKU9AGLGgtgHJUEcn3L5lQbkJjiI+xj2ZV8lgHn8xNkj+Gp23wt32mHqTrjr/4FJhUL
xEgiPKBeAazjHpZxg5ES0ChusZQHdtGQvcXJHsBU8BrYKZoz2Mcj2jofuR1ie5jOk38AxyA7mTaRsDIA
AAAASUVORK5CYII='
	if (2 == (global 'scale')) { data = dataRetina }
	return (readFrom (new 'PNGReader') (base64Decode data))
}

method leftClickLogo MicroBlocksTipBar {
	dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAABwAAAAkCAYAAACaJFpUAAAACXBIWXMAACRyAAAkcgG1MFKpAAAAGXRF
WHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAkVJREFUSInt18uLTnEcx/HXM0lmiEEuRS5l
w0ZZSChZaHLPpSRbkZKFP0DIVlYjkxTJLUmS/8DCSpNihXFpKJdxNy7Dsfh9h+M8z8w8M+ZYzbdOPb/v
9/v7vH+X73N+51fRv03FRqzHPMzA+ELOO3TiPq7jGl4OoFtlk3EMX5Hlnk94iAfxPAxfPucLjmJSvbAV
McIM79GKVTVmlrfxkXMcH6LvCywfCLY9N6uTmFbvKHM2Haf8me22vhKXBuwbdhZio9GCg2jD2TrAu/E9
oEuKwWY8j1HtKoD245W/9+ljHUDYE/mdCltyJAJncr4puFkADRZIWo0Mh3sdE0Pgs1T2MBbtfcAGC5wZ
2h8wAXaESFsu6XQ/sMECSQWYSUXpQjTWRHAhfgwzcF30Owd3otG7qa0DwIYCnBD92kkV+D4XfFwCkLSH
L+AnHoVzTLTLAD7CzwZUQoT0V6gMQawey1BpKDiL7WG3IqAT3f8T2INLZQJJa9uRazfjhuEvmg5ko2oE
3mItFmC+2vvaMwTgbyvOsCzrQFZ6VRZtBDgCHLRV8CZ+TyyZ9Q49DdL7sxlNJcLGSQf8swbcC+fKEoG9
2ndhq/S2uVwi8EowtkAjnoajpQTY6tB+In1RIH2xZVIBLRtG2GK8Du0NxeChCHyW7hCN/wBqCr3u0DzQ
V+K+AGbowglswqw6ILMjt01aqd7B7x2o41xclG49xYO3S/WFtKtG3hecx5yieH9faJOwWbpqLZLufc2q
l7pbOrSf4zZu4WoMpMp+AZVe3/Vj4nt+AAAAAElFTkSuQmCC'
	data = '
iVBORw0KGgoAAAANSUhEUgAAAA4AAAASCAYAAABrXO8xAAAACXBIWXMAABI5AAASOQEodzeCAAAAGXRF
WHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAQVJREFUOI2l008rRFEYx/GPe4clsWDByjug
KOY9sLZFYicbJe+EF0DKyh7lX4oNK16BmsxMiMVM1+Ke21zTNWbyq+d0zvP8vs+p53RoqR8buEQNryFq
uMB68PzQGG5xgBnEuVqMWRziBqNZoYRrbCLCEk5x394dW7gKjBUchc4neEOCRgEIx1iGc8xhG+8B6gTO
4wwq4baXHNQJLKESBWgAI78Y29VAHOUSSZcg0inCp/QpvvARomOjPlQxHM6TuX2i+EkEJl16VDX621Os
f4HNHhvEaEZ4RLkHsIwHWMQdBruAhqSTXsgSu3jGKsYLgAmsBc9Oe3Ea+3hCXesj10NuD1OZ+Rsiaz99
cgtWngAAAABJRU5ErkJggg=='
	if (2 == (global 'scale')) { data = dataRetina }
	return (readFrom (new 'PNGReader') (base64Decode data))
}

method trueLogo MicroBlocksTipBar {
	dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAADMAAAAcCAYAAADMW4fJAAAACXBIWXMAACYWAAAmFgGz33QBAAAAGXRF
WHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAABWxJREFUWIW1mE9MHPcVxz/vtzszyy4smLXN
slgOFmlsg6tUipKqh0RqVDknUGRMEsnyJeq9zSFRlKa3tFGlXtsc7B45OGCM4iiKeqtkyVIvrUjkhVUN
tWvhOLC7/N2dnfHM6wHvGowBw46/p/n9me/7fX+/37z35gl7YHBwMGlZ1lsiMgT8VES6VfUoEN/r3Sag
QBVYVtUp4LLv+99cv369sttLstPAhQsX0q7rfgT8FkhFutSDwQe+SCQSvx8dHV152oSnihkeHn5bVS+J
yOF6XxgLKWVLVNur1JI1AhMcaEV21Sb73ywtqy1b+o0x2LaNbdsEQYDv+/i+j6o+SVEJw/DitWvXJvYS
I+fOnftYRD4DDMDK4RWmfz7NDy/+gG/7BxJQR/ftbl79+lUsz2oI6OrqIpPJ0NHRgcjW5XieR7lc5sGD
BywvL28ZU9U/TkxM/G5HMefPn/9EVf8AEMQCpt6cYu7lOVS27c6+8cL3L/DKt68gumGyq6uL3t5ebNt+
pvfL5TKzs7NUKo8/GxH5fHx8/JNtYoaHh98GrgKm1lLj5rmbFHPFpkUAHL53mNe/fB0TGIwx9PX1kc1m
980TBAGFQoHFxcVGn4i8Mz4+PgaPxIyMjLSHYXgbyIQm5Ma7N1g4thCJENu1OXv5LE7VAaC/v59MJnNg
PlVlenq6IUhEXMdxukZHR1cMQBAEHwEZgO9++V1kQgBO3TzVEHLixImmhACICCdPnqS1tRUAVU24rvtn
AHPx4sWUiPwGYK1zjdmfzTZlbDOSK0n6/tUHQCqVoqenJxLe+lXd5DDeHxwcTJpqtfoWj+JI4bUCoQkj
MQhwbOYYJjAA9Pb2bvNWzSCdTtPZ2VlvxizLeseo6hCAijLfNx+ZMYBcIQeAZVkcOnQoUm7Y8Ih1iMiv
DXAGYOXICrVkLTJDsSBG5/2Nnevs7Iz0VOro6OjAGFNvnjJADqDStmvas28kVhONmJJMJiPlriMWi5FI
JOrNVgMcAai1RHcqAC3rj9OVZw2MB8EmbtvsNrEZKI+zhqfkV88FRkR+BEhUE3vN3RfclNt49jwvUu7N
qNUaN8ozqjoPbMtim4Xb6jZyumq1Gil3HWEYbhazZoDvAdILaZx1JzJDQTyg1F0CoFQqPZerViqVCMNG
XJw2qvoVgKiQ+08uUmPzP9mIW77vUy6XI+UGWFjYknZdMqlU6u/AGsBL/3wJE0bnE+6dukcY29i5ubm5
SE9ndXWVYrGR1Qee543Fpqam/IGBgSTwhu3a+AmfUq4UiUHf8bFdm8x8Bt/3McbQ3t7eNG8YhuTz+c2O
5fLk5OQ1AyAifxKRBwBn/nGGI/870rTBOqZ/Md2IYXfu3KFUam6jVJVCocDa2lq9y00kEh8CxABu3brl
nT59egZ4V1QkeztL8ViRalvzXiiIB5RyJY7njyOhUCwWcRynkcLviysImJmZafzLqKoaY967cuXKvxti
APL5fKG/v98DfhV/GOf4reP4CZ+l7NIuNZxnQyVdwW1zyd3OoaoUi0VqtRptbW3EYrG9CYClpSXy+fyT
tYDPr169+pd6YwtTPp+/MTAw4AJviopkZ7P0zPTw0HlIJV0hjB/892Dp6BLLR5fpnu3GBIb19XXu37+P
53kYY3AcZ1sy6vs+i4uLzM3NcffuXXz/cUFFVT+bmJj4dPP8nUpNg8DfeJS3wUapqZwtU0lXqKWeT6nJ
cRwsyyIMQzzP2ylzqARBcGFycnLyyYEdL9DQ0FBbPB7/UEQ+APZ/waOHD/zVGPPp2NjY2tMm7Pk1jIyM
tKjqWVUdUtUzItIDdBFxeVZVG9dMNwJSVUSWgakgCC5ZlvXN2NjYrh7p/+bgN+TqDPt+AAAAAElFTkSu
QmCC'
	data = '
iVBORw0KGgoAAAANSUhEUgAAABoAAAAOCAYAAAAxDQxDAAAACXBIWXMAABMLAAATCwErAKTWAAAAGXRF
WHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAlVJREFUOI2VlMFPE0EUxr8322XZsmBLlsYC
lmAgxEJDgopH41EPEtn/wcSIxpsX48lo4s1o4t9g0hI8ePNgTDx4JDWlhcZAONRDuy3ttoWys88DFDBi
d/2dXjLfm2/mZeYjnGF5eXmCiB7LkLwnPDFKHmkIgBCiWzITt1jyVwArmUzmZ3eBuoVlWQ8g8MaJOLw9
u93XMBtwVffcjYkJEz8mMJ4fR3+4H7HhGDRNg+d52Gvswa7YR6Yev8xkMs9OjCzLesjgt9lbWSpeLYKJ
/318BhY/LSKxlcDM1AxM0wQR/SHpdDrYLG6iZtcA4HU6nX5KlmVdZuJC9mY2tHV9y3dMk+uTWPi8gPnU
PIaGhnpqcxs52LYNAs0KInrSjDS5eK3oa0JMSH1LYWx0zNcEAKanpiFIQEr5XkhF3t1N7qo9x3XMcGkY
alNF/GLcVwsAqqrCHDFBCt0QJCnuRJxAjUbVACkEXdcD6QHAGDBATJrwl57C8L/1uRAgWOGSUTUC6ZvR
Jlgy2u12YA/HccDgAyFc8TGRS3SIybfJjts4HDhE6VcpkInruiiXy2DJ35W5ubmCeqA+ckOuUhmr9O4k
oKN1YKwbiEai0LTewZEv5NFqt+B53m0ll8vVkleS5dhO7I5UJdmj9pm8+JtarIbB6iD28/vQ+3WEw+Fz
P+xGYQNVuwoAr1ZXVz+cjaD7TPyueaHJO6mdvrpZDxRB+oCOkejISQTVG3VUKhXg6O28SKfTz4+HccrS
0tKlUCh0FKpSjBP/X6gymBncIqYvruuurK2tbXc1vwHLNft2gdi8QgAAAABJRU5ErkJggg=='
	if (2 == (global 'scale')) { data = dataRetina }
	return (readFrom (new 'PNGReader') (base64Decode data))
}

method falseLogo MicroBlocksTipBar {
	dataRetina = '
iVBORw0KGgoAAAANSUhEUgAAADMAAAAcCAYAAADMW4fJAAAACXBIWXMAACYWAAAmFgGz33QBAAAAGXRF
WHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAABSVJREFUWIXFmE1sVFUUx3/nzpuZzsyjbWaE
RqIBonwUCGm6MHGhiYkaE6QJpdUFwRiDC5YmLkS3sEAisjXRaEQWZtIxtmFhWGoMxgQWaNs0xUACCB1m
aOnMtPO+jov5YGgLbTrP8N/d++65/3veuefjHmEVHDhwIGlZ1n5jzFFgH9AJJABZTbYNeCIyo6q3gb9U
ddR13V/GxsYqTxJ67IEOHz7cWa1WT6jqMcAK+7TrQElEzsbj8dPnz59/sNKCFZUZHBwcEpHvqVng4WIR
otEosVgMYwyO4+A4DkEQPCK/QYRtsRgdsj7jBUA5CHgQBNzxPPxHP+dV9WgulxtdTRkZHBw8KSLHWye7
urrYtGkT6XSaWCz2KHEQMDc3x71795iZmWkqFhdhfyrFC9HouhRqoKrKP67LpcVF7vlNtQLgs5GRkVOA
NiYjrYJDQ0OngE8a42Qyya5du9iyZQu2bROJPLIcqFkrkUiQyWTo6enB8zzK5TI+MOk4dEUibFpBbq2w
RNgYidAXj5MU4YbvozUjvN7b21udmJj4bZkyhw4degc42xin02n27t1LMplcO7FlkclkSCaTFItFVJVr
rsvz0ShdxqxbIaid/lnLYotlMe26eICIvLZ79+4rExMTU01lhoeHu1T1d+qOvnHjRnp7ezHrPEAqlSKV
SpHP51HgH89jXzyOtU4fasUGY3jOshh3XRREVd/o7+//6urVq1UDEATBGSAOYNs2O3bsQNokzmQybN26
FYBKEHBpYaE9LVqw2bJ4taMDABF5ZmFh4WMAOXLkSKpSqcwBERGhr68P27ZDIVVVLl++TKVSISLC0c5O
Otu8bg0EwDdzc8zWAk7JcZweUyqV3qV+3TKZTGiKQC04NKzjqzLlOKHtbYCXEs3MYcdisTeNMebDxkxP
T09oZA2k02ksq5Zzp1w31L1fjEabuUVVB4yI7AQwxtDd3R0qGdSsk8lkALjtefiqq0isHSkRMvWwLyJ7
jaqmADo6OtYdvVZDon4dFCgtqRbaRYsPbjZAFFiW2cNE697lEC0DkHwYdXv+H1M8JRjABXBCjDRL0bq3
HfJVbrH0HSMiZYBqtbqs+g0LC/WEKdScNky0+OC/BpgE8H2f+/fvh0oEtcRZKBSAWuaOhKhMKQhaK+mr
xvf9rxujmZmZ0IgaKBaLeJ4HwPY2nwNLMV2rzwAQkVFj2/aPUHv/FAoF5ufnQyNTVa5fvw5ARISdIUZM
H/izWm0M56vV6kVz7ty5soh82yCfnp4OzXdu3rxJpVJ7tvfH46HVZQCXFxeZrV8xETkzNjZWMfXBR8AC
QKlUYmpqCm0zHxQKhaZVEiK8XK9yw8Atz+PXh1V43nGcL6AWmslmsyVjzHvNr/k84+Pj+L6/fKc1IJ/P
Mzk5SYNgwLaJh+T4tzyPn0qlRl8gAN4fHR2dh5aX5vj4+PiePXviwCtQC6fFYpFEIkHHGv+q4zhcu3aN
GzduoKoI8FYyyfYQfCVQ5Uq1yoVymUbWEpHjIyMj3zXWLPtdQ0NDJ1X109a57u7uZkMjuiQiqSqzs7MU
CgXu3r3b9LcY8LZtt93QWKw/vf9YXKTQ0tBQ1eO5XO7z1rUr2v7gwYODxpgfWKXV5Lruisl2gzFsi0bb
bjXN1VtNS8LRjKp+kMvlLiyVeyzbwMDAhmg0egI4Rr0YfcqYB740xpzOZrOllRas+uuGh4cTvu/vF5Gj
wD5V7QIS0m6T4MnwgLvATeBvVf05EolczGazT2wk/AfDzRDiodhsigAAAABJRU5ErkJggg=='
	data = '
iVBORw0KGgoAAAANSUhEUgAAABoAAAAOCAYAAAAxDQxDAAAACXBIWXMAABMLAAATCwErAKTWAAAAGXRF
WHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAj5JREFUOI2VlEFrE1EUhb/7Jpl0aGMwTcF0
J9ZqanGnm4K4cePCRUPJb5AiuHAhrsWNK0uhCP6DphF/gCCiC627Bim2uJC2kSYNRNLOTGbee26aatU2
41k9eOe8cznv3iv8hkqlciGKokVHqRuIeIAAGGNIAgWhgm0t8lJEFpaXl7/176R/mJ2dfaKUeiggo4UC
2WwWpRRBENDe28P3fUqZDNPp9IlGEdDSmnoY9jrWioV71Wr1+ZFRuVx+KiIP8vk8ExMTuK577AFrLbu7
u3zd3GQyleL28PCvCv8BC3wKAt74vgXmV1ZWlqRSqUxrrddG83lKU1OnRtPpdKivrXHL87iayZzKBfgQ
BLwLggiRS0prvaREuDg5OVCYy+UoFou8D0PsQDZcHxrijIg1xtxXwLXC2BipVCqBFIrj43S15nscD+QK
UHJd14E7SkQy2Ww2kQmA53k4StFO2Il5x8HAuLLWYm2SIP6u9n+ggLDb7SYW+L6PNoazSiXit7VGiWwr
a+3HVrNJnCBzgEajwYjjcC7Bnxpr+dzr9Qy8Uq7r3jXWsrGxMTDCTqdDY2eHmUwmUXSrYcgPYySO42dO
vV5vlkqlYd/3Z/b398nlcjiOc0zQH9gv6+tcdl1mPG/gwK4GAW8PDqwoNV+r1V4f8cvl8mOl1COslUKh
wMjhCgrDkHarxcHhCrqSTp9oEgHNOKYeRb2O1iAyX61WX8AfzTM3N3feGLOoRG4CHiL/tVQFQge2YqhZ
axdqtdpW/+4nM5r0sHyILZQAAAAASUVORK5CYII='
	if (2 == (global 'scale')) { data = dataRetina }
	return (readFrom (new 'PNGReader') (base64Decode data))
}
defineClass Module moduleName classes functions expanders variableNames variables exports codeHash

method initialize Module modName {
  if (isNil modName) { modName = '' }
  moduleName = modName
  classes = (array)
  functions = (array)
  expanders = nil
  variableNames = (array)
  variables = (array)
  exports = (dictionary)
  codeHash = nil
  return this
}

// accessors

method classes Module { return classes }
method functions Module { return functions }

method codeHash Module {
  if ((topLevelModule) === this) {
	if (isNil codeHash) {
	  codeHash = (sha256 (code this))
	}
  }
  return codeHash
}

// module exports

method at Module k {
  // Return the given exported item or nil.

  item = (at exports k)
  if (isClass item 'String') { // item is a variable
	i = (indexOf variableNames item)
	return (at variables i) // return the current value
  }
  return item
}

method keys Module {
  // Return an array containing the names of all exported items.

  return (keys exports)
}

// classes

method addClass Module aClass {
  classes = (copyWith classes aClass)
}

method removeClass Module aClass {
  remove exports (className aClass)
  classes = (copyWithout classes aClass)
}

method classNamed Module name {
  if (this === (topLevelModule)) { return (class name) }
  if (isNil classes) {return nil}
  for c classes {
	if ((className c) == name) {
	  return c
	}
  }
  return nil
}

method unusedClassName Module baseName {
  if (isNil (classNamed this baseName)) { return baseName }
  id = 2
  while true {
	className = (join baseName id)
	if (isNil (classNamed this className)) { return className }
	id += 1
  }
}

method defineClassInModule Module className fields... {
  cls = (classNamed this className)
  if (isNil cls) {
	fields = (list)
	for i ((argCount) - 2) {
	  add fields (arg (i + 2))
	}
	cls = (newClass className fields this)
	classes = (copyWith classes cls)
  }
  clearCaches cls
  return cls
}

// functions

method functionNamed Module fName {
  for f functions {
	if (fName == (functionName f)) { return f }
  }
  return nil
}

method defineFunctionInModule Module funcName funcParams funcBody {
  f = (newFunction funcName funcParams funcBody this)
  for i (count functions) {
	if ((functionName (at functions i)) == funcName) {
	  atPut functions i f
	  return f
	}
  }
  functions = (copyWith functions f)
  return f
}

method addFunction Module aFunction {
  if (notNil (indexOf functions aFunction)) { return } // already there
  for f functions {
	if ((functionName f) == (functionName aFunction)) {
	  error (join 'This modue already has a function named' (functionName aFunction))
	}
  }
  setField aFunction 'module' this
  functions = (copyWith functions aFunction)
}

method removeFunction Module aFunction {
  functions = (copyWithout functions aFunction)
  clearMethodCaches
}

// variables

method variableNames Module { return (copy variableNames) }

method removeAllVariables Module {
  variableNames = (newArray 0)
  variables = (newArray 0)
}

method addVar Module varName {
  if (not (contains variableNames varName)) {
	variableNames = (copyWith variableNames varName)
	variables = (copyWith variables 0)
  }
}

method deleteVar Module varName {
  // Remove the variable with the given name from this module.

  i = (indexOf variableNames varName)
  if (isNil i) { return }
  n = ((count variableNames) - 1)
  newVarNames = (newArray n)
  newVars = (newArray n)

  replaceArrayRange newVarNames 1 (i - 1) variableNames
  replaceArrayRange newVarNames i n variableNames (i + 1)
  replaceArrayRange newVars 1 (i - 1) variables
  replaceArrayRange newVars i n variables (i + 1)

  variableNames = newVarNames
  variables = newVars
}

// printing

method toString Module {
  list = (list)
  add list 'Module('
  if (notNil moduleName) { add list (toString moduleName) }
  add list ')'
  return (joinStringArray (toArray list))
}

// loading

to loadModule fileName args... {
  if (not (contains (letters fileName) '/')) {
	fileName = (join 'modules/' fileName)
  }
  if (not (endsWith fileName '.gpm')) {
	fileName = (join fileName '.gpm')
  }
  modName = (withoutExtension (filePart fileName))

  s = (readFile fileName)
  if (isNil s) {
	s = (readFile (join (directoryPart (appPath)) 'modules/' (filePart fileName)))
  }
  if (isNil s) {
	s = (readFile (join (directoryPart (appPath)) 'runtime/modules/' (filePart fileName)))
  }
  if (isNil s) { s = (readEmbeddedFile fileName) }
  if (isNil s) { error 'module file not found' fileName }

  result = (initialize (new 'Module') modName)
  loadModuleFromString result s

  // collect module args and call initializer
  args = (list)
  for i (argCount) {
	if (i > 1) { add args (arg i) }
  }
  callInitializer result args
  return result
}

method loadModuleFromString Module s {
  cmds = (parse s)
  loadClassDefinitions this cmds
  loadMethods this cmds
  loadScripts this cmds
  loadFunctions this cmds
  loadModuleVariables this cmds
  loadModuleExports this cmds
  clearMethodCache
  return this
}

method loadClassDefinitions Module cmdList {
  classDefs = (dictionary)
  for cmd cmdList {
	if ('defineClass' == (primName cmd)) {
	  args = (toList (argList cmd))
	  className = (removeFirst args)
	  if (contains classDefs className) {
		print 'Warning: Multple definitions of class' className 'in module' moduleName
	  } else {
		atPut classDefs className (list)
	  }
	  fields = (at classDefs className)
	  for n args {
		if (not (contains fields n)) { add fields n }
	  }
	}
  }
  for className (keys classDefs) {
	cl = (newClass className (at classDefs className) this)
	classes = (copyWith classes cl)
  }
}

method loadMethods Module cmdList {
  moduleClasses = (dictionary)
  for cl classes { atPut moduleClasses (className cl) cl }

  for cmd cmdList {
	if ('method' == (primName cmd)) {
	  args = (toList (argList cmd))
	  methodName = (removeFirst args)
	  className = (removeFirst args)

	  // create method
	  addFirst args 'this'
	  m = (callWith 'functionFor' (toArray args))
	  setField m 'functionName' methodName
	  setField m 'module' this

	  // install method in a module class or as an expander
	  cl = (at moduleClasses className)
	  if (notNil cl) {
		setField m 'classIndex' (classIndex cl)
		setField cl 'methods' (appendFunction this (methods cl) m)
	  } else {
		cl = (class className)
		setField m 'classIndex' (classIndex cl)
		if (isNil expanders) { expanders = (array) }
		  appendExpander this m cl
	  }
	  // remove field names from locals
	  removeFieldsFromLocals m (fieldNames cl)
	}
  }
}

method loadScripts Module cmdList {
  moduleClasses = (dictionary)
  for cl classes { atPut moduleClasses (className cl) cl }
  scriptsForClass = (dictionary) // className -> list of scripts

  for cmd cmdList {
	if ('script' == (primName cmd)) {
	  args = (argList cmd)
	  className = (first args)
	  scripts = (at scriptsForClass className)
	  if (isNil scripts) {
		scripts = (list)
		atPut scriptsForClass className scripts
	  }
	  add scripts (copyFromTo args 2)
	}
  }

  for className (keys scriptsForClass) {
	cl = (at moduleClasses className)
	if (notNil cl) {
	  setScripts cl (at scriptsForClass className)
	} else {
	  print 'Ignorning scripts for unknown class:' className
	}
  }
}

method appendFunction Module anArray f {
  // Append function f to the given array of functions and return the new array. If the
  // array already contains a function with the same name, replace it and issue a warning.

  functionName = (functionName f)
  for i (count anArray) {
	item = (at anArray i)
	if ((functionName item) == functionName) {
	  print 'Warning: There are multiple definitions of' functionName
	  atPut anArray i f
	  return anArray
	}
  }
  return (copyWith anArray f)
}

method appendExpander Module func cls {
  functionName = (functionName func)
  clsIdx = (classIndex cls)
  for i (count expanders) {
	item = (at expanders i)
	if (and ((functionName item) == functionName) (clsIdx == (classIndex item))) {
	  print 'Warning: There are multiple definitions of' functionName
	  atPut expanders i func
	  return
	}
  }
  expanders = (copyWith expanders func)
}

method loadFunctions Module cmdList {
  for cmd cmdList {
	if ('to' == (primName cmd)) {
	  args = (toList (argList cmd))
	  functionName = (removeFirst args)
	  addFirst args nil
	  f = (callWith 'functionFor' (toArray args))
	  setField f 'functionName' functionName
	  setField f 'module' this
	  functions = (appendFunction this functions f)
	}
  }
}

method loadModuleVariables Module cmdList {
  varNames = (list)
  for cmd cmdList {
	if ('moduleVariables' == (primName cmd)) {
	  for v (argList cmd) {
		if (isClass v 'String') { // quoted var name
		  add varNames v
		} else { // unquoted var: mapped to "(v 'varName')" block by the parser
		  add varNames (first (argList v))
		}
	  }
	}
  }
  variableNames = (toArray varNames)
  variables = (newArray (count varNames))
}

method loadModuleExports Module cmdList {
  for cmd cmdList {
	if ('moduleExports' == (primName cmd)) {
	  for v (argList cmd) {
		itemName = (first (argList v))
		item = (itemForExport this itemName)
		if (isNil item) {
		  print 'Error: Unknown exported item' itemName
		} else {
		  atPut exports itemName item
		}
	  }
	}
  }
}

method itemForExport Module itemName {
  result = nil
  for cl classes {
	if ((className cl) == itemName) {
	  result = cl
	}
  }
  for f functions {
	if ((functionName f) == itemName) {
	  if (notNil result) { print 'Warning: Ambiguous export' itemName }
	  result = f
	}
  }
  for v variableNames {
	if (v == itemName) {
	  if (notNil result) { print 'Warning: Ambiguous export' itemName }
	  result = v
	}
  }
  if (isNil result) {
	for e expanders {
	  if ((functionName e) == itemName) {
		print 'Error: You cannot export' (join '"' itemName '"') 'because its class is not defined in this module'
	  }
	}
  }
  return result
}

method callInitializer Module argList {
  // Call the module initializer, if any, with the given arguments.
  if (isNil argList) { argList = (array) }
  initFunc = nil
  for f functions {
	if ('initializeModule' == (functionName f)) {
	  if (isNil initFunc) {
		initFunc = f
	  } else {
		print 'Warning: Multiple initializeModule functions in' moduleName
	  }
	}
  }
  if (notNil initFunc) { callWith initFunc (toArray argList) }
}

// saving

method code Module {
  lf = (newline)
  aStream = (dataStream (newBinaryData 1000))
  nextPutAll aStream 'module'
  if (and (notNil moduleName) (moduleName != '')) {
	nextPutAll aStream ' '
	nextPutAll aStream moduleName
  }
  nextPutAll aStream lf

  printVarNamesOn this aStream
  printExportsOn this aStream

  // the above three lines come without extra blank lines

  if (and (notNil functions) ((count functions) > 0)) {
	nextPutAll aStream lf
	printFunctionsOn this aStream
  }
  if (and (notNil classes) ((count classes) > 0)) {
	nextPutAll aStream lf
	printClassesOn this aStream
	printScriptsOn this aStream
  }
  if (and (notNil expanders) ((count expanders) > 0)) {
	nextPutAll aStream lf
	printExpandersOn this aStream
  }
  return (stringContents aStream)
}

method printVarNamesOn Module aStream {
  if (and (notNil variableNames) ((count variableNames) > 0)) {
	lf = (newline)
	nextPutAll aStream 'moduleVariables'
	for v (sorted variableNames) {
	  nextPutAll aStream ' '
	  if (containsWhitespace v) {
		nextPutAll aStream (printString v)
	  } else {
		nextPutAll aStream v
	  }
	}
	nextPutAll aStream lf
  }
}

method printExportsOn Module aStream {
  if (and (notNil exports) ((count exports) > 0)) {
	lf = (newline)
	nextPutAll aStream 'moduleExports'
	for v (sorted (keys exports)) {
	 nextPutAll aStream ' '
	 nextPutAll aStream v
	}
	nextPutAll aStream lf
  }
}

method printFunctionsOn Module aStream {
  if (isNil functions) { return }
  lf = (newline)
  pp = (new 'PrettyPrinter')
  list = (sorted
	functions
	(function a b {return ((functionName a) < (functionName b))})
  )
  for f list {
	nextPutAll aStream (prettyPrintFunction pp f)
	if (not (f === (last list))) {
	  nextPutAll aStream lf
	}
  }
}

method printClassesOn Module aStream {
  if (isNil classes) { return }
  lf = (newline)
  pp = (new 'PrettyPrinter')
  list = (sorted
	classes
	(function a b {return ((className a) < (className b))})
  )
  for c classes {
	nextPutAll aStream (prettyPrintClass pp c)
	if (not (c === (last classes))) {
	  nextPutAll aStream lf
	}
  }
}

method printScriptsOn Module aStream {
  if (isNil classes) { return }
  for c classes {
	if (notNil (scripts c)) {
	  nextPutAll aStream (scriptString c)
	}
  }
}

method printExpandersOn Module aStream {
  if (isNil expanders) {return}
  lf = (newline)
  pp = (new 'PrettyPrinter')
  cls = (dictionary)
  allClasses = (classes)
  for e expanders {
	n = (className (at allClasses (classIndex e)))
	if (isNil (at cls n)) {
	  atPut cls n (list)
	}
	add (at cls n) e
  }
  cNameList = (sorted (keys cls))
  cList = (newArray (count cNameList))
  for i (count cNameList) {
	n = (at cNameList i)
	atPut cList i (at cls n)
  }
  for ms cList {
	mList = (sorted (toArray ms) function a b {return ((functionName a) <= (functionName b))})
	for m mList {
	  nextPutAll aStream (prettyPrintMethod pp m)
	  if (not (m === (last mList))) {
		nextPutAll aStream lf
	  }
	}
	if (not (ms === (last cList))) {
	  nextPutAll aStream lf
	}
  }
}

// serialization

method serializedFieldNames Module {
  return (getField this 'variableNames')
}

method serialize Module {
  return (copy (getField this 'variables'))
}

method deserialize Module fieldDict {
  for k variableNames {
    setShared k (at fieldDict k) this
  }
}
// Monitor - Readout for the value of a variable or expression

// { m = (newMonitor 'Seconds' (action 'second')); addPart page m }

defineClass Monitor morph getAction bgColor style dividerX label readout lastValue

method bgColor Monitor {
  // Fix monitors saved in projects before bgColor was added
  if (isNil bgColor) { bgColor = (gray 200) }
  return bgColor
}

method fieldInfo Monitor fieldName {
  if ('style' == fieldName) {
    info = (dictionary)
    atPut info 'type' 'options'
    atPut info 'options' (array 'labelOnLeft' 'labelOnTop' 'embedded')
    return info
  }
  return nil
}

to newMonitor labelString get bgColor {
  if (isNil bgColor) { bgColor = (gray 200) }
  result = (new 'Monitor' (newMorph) get bgColor 'labelOnLeft')
  setHandler (morph result) result
  setGrabRule (morph result) 'handle'
  setFPS (morph result) 10
  setClipping (morph result) true
  buildUI result labelString
  return result
}

method buildUI Monitor labelString {
  fontSize = (13 * (global 'scale'))
  label = (newText labelString 'Arial Bold' fontSize (gray 255))
  readout = (newText (toString lastValue) 'Arial' fontSize (gray 0))
  setPinToTopLeft (morph label)
  setPinToTopLeft (morph readout)
  removeAllParts morph
  addPart morph (morph label)
  addPart morph (morph readout)
  fixLayout this
}

method morph Monitor { return morph }
method style Monitor { return style }
method labelWidth Monitor { return (width (morph label)) }

method label Monitor { return label }
method readout Monitor { return readout }
method getAction Monitor { return getAction }

method value Monitor {
  if (isNil getAction) { return lastValue }
  return (call getAction)
}

method setStyle Monitor newStyle {
  if (isOneOf newStyle 'labelOnLeft' 'labelOnTop' 'embedded' 'varPane') {
    style = newStyle
    fixLayout this
  }
}

method setDividerX Monitor x {
  dividerX = x
  fixLayout this
}

method step Monitor {
  digitsAfterDecimal = 2
  if (isNil getAction) { return }
  newValue = (call getAction)
  if (newValue === lastValue) { return } // no change
  lastValue = newValue

  if (and (isAnyClass newValue 'Array' 'List') ((count newValue) > 20)) { // long Arrays/Lists
	s = (join '<' (className (classOf newValue)) '> (' (count newValue) ' items)')
  } (isAnyClass newValue 'Dictionary' 'Table') {
	s = (join '<' (className (classOf newValue)) '> (' (count newValue) ' items)')
  } (isClass newValue 'BinaryData') {
	s = (join '<' (className (classOf newValue)) '> (' (byteCount newValue) ' bytes)')
  } (isClass newValue 'String') {
	if ((count newValue) > 100) {
		s = (join (substring newValue 1 100) '...')
	} else {
		s = newValue
	}
  } else { // this case includes short Arrays and Lists
	if (implements lastValue 'copy') { // used to detect changes to arrays/lists
	  lastValue = (copy lastValue)
	}
	s = (toString newValue)
	if (and (isClass newValue 'Float') ((abs newValue) >= 0.01)) {
	  decimalIndex = (indexOf (letters s) '.')
	  if (decimalIndex > 0) {
		s = (substring s 1 (min (decimalIndex + digitsAfterDecimal) (count s)))
	  }
	}
  }
  if (s == (text readout)) { return }
  setText readout s
  redraw readout
  fixLayout this true
}

method fixLayout Monitor keepBitmap {
  scale = (global 'scale')
  oldScale = (scale morph)
  setScale morph 1
  labelW = (normalWidth (morph label))
  readoutW = (normalWidth (morph readout))
  borderColor = (gray 110)
  radius = (2 * scale)
  border = (2 * scale)

  if ('labelOnLeft' == style) {
    setInsetInOwner (morph label) (6 * scale) (4 * scale)
	readoutX = (labelW + (15 * scale))
    setInsetInOwner (morph readout) readoutX (4 * scale)
    bgWidth = ((labelW + readoutW) + (25 * scale))
    bgHeight = ((normalHeight (morph label)) + (8 * scale))
  } ('embedded' == style) {
    radius = 1
	border = 1
    setInsetInOwner (morph label) (6 * scale) (4 * scale)
	readoutX = (labelW + (20 * scale))
    setInsetInOwner (morph readout) readoutX (4 * scale)
//  bgWidth = (width (owner morph))
    bgWidth = 400
    bgHeight = ((normalHeight (morph label)) + (8 * scale))
  } ('varPane' == style) {
	hide (morph label)
	border = (1 * scale)
	readoutX = 0
    setInsetInOwner (morph readout) (6 * scale) (3 * scale)
    bgWidth = (110 * scale)
    bgHeight = (20 * scale)
  }

  bm = (costumeData morph)
  if (true != keepBitmap) { bm = nil } // always rebuild bitmap if not called
  if (or (isNil bm) (bgWidth >= (width bm)) (bgHeight >= (height bm))) {
    bm = (newBitmap bgWidth bgHeight)
	fillRoundedRect (newShapeMaker bm) (rect 0 0 bgWidth bgHeight) radius bgColor border borderColor borderColor
	if (notNil dividerX) {
      fillRect bm borderColor dividerX 0 1 bgHeight
	} else {
	  frameX = (readoutX - (4 * scale))
	  if ('varPane' == style) { frameX = border }
	  fillRect bm (gray 240) frameX border (bgWidth - (frameX + border)) (bgHeight - (2 * border))
	}
    setCostume morph bm
  }
  setPinToTopLeft morph
  setScale morph oldScale
}
// Morph

defineClass Morph owner parts handler bounds costume costumeData transformedCostume costumeChanged isVisible alpha grabRule noticesTransparentTouch isClipping minWidth minHeight fps lastStepTime acceptsEvents penTrails penTrailsData tag param pen drawOnOwner rotation rotateWithOwner scaleX scaleY pinX pinY vectorPen shouldRedraw

to newMorph handler {
  return (initialize (new 'Morph' nil (list) handler (rect) nil nil nil false true 255 'defer' false false 1 1 nil nil true))
}

method initialize Morph {
  drawOnOwner = true
  pinX = 0
  pinY = 0
  rotation = 0
  rotateWithOwner = true
  scaleX = 1
  scaleY = 1
  shouldRedraw = false
  noticesTransparentTouch = true
  return this
}

// info

method fieldInfo Morph fieldName {
  if ('grabRule' == fieldName) {
    info = (dictionary)
    atPut info 'type' 'options'
    atPut info 'options' (array 'defer' 'handle' 'template' 'draggableParts' 'ignore')
    return info
  }
  return nil
}

// backstop

to handler anyObject { return nil } // allow "(handler nil)" for convenience

// accessing

method owner Morph {return owner}
method parts Morph {return parts}
method handler Morph {return handler}
method setHandler Morph aHandler {handler = aHandler}
method bounds Morph {return bounds}
method setBounds Morph aRect {bounds = aRect}
method costumeData Morph {return costumeData}
method setTag Morph aString {tag = aString}
method tag Morph {return tag}
method setParam Morph value {param = value}
method param Morph {return param}
method pinX Morph {return pinX}
method pinY Morph {return pinY}
method rotateWithOwner Morph {return rotateWithOwner}

method isTopLevel Morph {
  return (or (isNil owner) (isAnyClass (handler owner) 'Page' 'Stage'))
}

// disabling events

method acceptsEvents Morph {
  if (isNil acceptsEvents) {acceptsEvents = true}
  return acceptsEvents
}

method acceptEvents Morph bool {acceptsEvents = bool}

// bounds accessing

method left Morph { return (left bounds) }
method right Morph { return (right bounds) }
method top Morph { return (top bounds) }
method bottom Morph { return (bottom bounds) }
method width Morph { return (width bounds) }
method height Morph { return (height bounds) }

method page Morph {
  page = (handler (root this))
  if (not (isClass page 'Page')) {
    return nil // error 'This morph is not in a page'
  }
  return page
}

// Costume

method setCostume Morph aBitmapColorOrNil ignoreBounds {
  changed this
  if (isNil ignoreBounds) {ignoreBounds = false}
  transformedCostume = nil
  if (isClass aBitmapColorOrNil 'Bitmap') {
    costumeData = aBitmapColorOrNil
  } (isClass aBitmapColorOrNil 'Color') {
	costumeData = aBitmapColorOrNil
	changed this
	return
  } (isNil aBitmapColorOrNil) {
    costumeData = nil
  } else {
    error 'expected a bitmap, color, or nil. Received ' aBitmapColorOrNil
  }
  if (and (not ignoreBounds) (notNil costumeData)) {
    setWidth bounds (scaleX * (width costumeData))
    setHeight bounds (scaleY * (height costumeData))
  }
  changed this
}

method costumeChanged Morph {
  // Called when the original costume is changed (e.g. pixel color changed).

  if costumeChanged { return } // change was already reported
  costumeChanged = true
  changed this
}

method updateCostume Morph {
  // Called when the scale or rotation changes.

  transformedCostume = nil
  changed this
}

method isNormal Morph {
  // NOTE: This optimization causes problems with stamping in WordSpinner project in
  // some cases (normal stage size, final stamp in the circle).
  // The problem seems to be that we don't know, when the optimization is performed,
  // if we might render the morph into a destination with scale other than 1.
  // Tried disabling this, but noticed some signs of running out of textures,
  // so am reenabled it for now.

  if ('iOS' == (platform)) { return false } // force use of textures on iOS
  if ('Browser' == (platform)) { return false } // force use of textures on browsers

  return (and
    (0 == (rotation % 360))
    (scaleX == 1)
    (scaleY == 1)
  )
}

method transformedCostume Morph {
  if (isNil transformedCostume) {
	updateTransformedCostume this
  }
  return transformedCostume
}

method updateTransformedCostume Morph {
  if (notNil transformedCostume) { return }
  if (isNil costumeData) { return }
  srcW = (width costumeData)
  srcH = (height costumeData)
  dstW = (width this)
  dstH = (height this)
  if (or
	(isNil transformedCostume)
	(!= (width transformedCostume) dstW)
	(!= (height transformedCostume) dstH)) {
	  transformedCostume = (newBitmap dstW dstH)
  }
  warpBitmap transformedCostume costumeData (dstW / 2) (dstH / 2) scaleX scaleY (0 - rotation)
}

// scaling and rotating

method rotation Morph {return rotation}
method rotatesWithOwner Morph {return rotateWithOwner}
method setRotateWithOwner Morph bool {rotateWithOwner = bool}
method toggleRotationStyle Morph {rotateWithOwner = (not rotateWithOwner)}
method scale Morph {return scaleX}
method scaleX Morph {return scaleX}
method scaleY Morph {return scaleY}
method rotationCenter Morph {return (transform this pinX pinY)}

method setRotationCenter Morph x y {
  pin = (normal this x y)
  setPin this (first pin) (last pin)
}

method setRotationCenterTo Morph another {setRotationCenter this (hCenter (bounds another)) (vCenter (bounds another))}

method placeRotationCenter Morph x y {
  rc = (rotationCenter this)
  if (isNil x) {x = (first rc)}
  if (isNil y) {y = (last rc)}
  moveBy this (x - (first rc)) (y - (last rc))
}

method setPin Morph x y {
  if (isNil x) {x = 0}
  if (isNil y) {y = pinY}
  pinX = x
  pinY = y
}

method setPinToTopLeft Morph {
  // Set pin point to top-left corner.
  pinX = ((normalWidth this) / -2)
  pinY = ((normalHeight this) / -2)
}

method setScale Morph newScale {rotateAndScale this rotation newScale nil nil nil true}
method setScaleAround Morph aroundX aroundY newScale {rotateAndScale this rotation newScale nil aroundX aroundY}

method rotateAndScale Morph heading xScale yScale aroundX aroundY noDraw {
  if (isNil heading) {heading = 0}
  if (isNil xScale) {xScale = 1}
  if (isNil yScale) {yScale = xScale}
  rc = (rotationCenter this)
  rx = (first rc)
  ry = (last rc)
  fixedX = aroundX
  fixedY = aroundY
  if (isNil fixedX) {fixedX = rx}
  if (isNil fixedY) {fixedY = ry}
  if (isNil noDraw) {noDraw = false}

  unrotated = (scaleAndRotateAround rx ry (- rotation) fixedX fixedY)
  distX = ((first unrotated) - fixedX)
  distY = ((last unrotated) - fixedY)
  unscaledX = ((first unrotated) - (distX - (distX / scaleX)))
  unscaledY = ((last unrotated) - (distY - (distY / scaleY)))
  centerX = (unscaledX - pinX)
  centerY = (unscaledY - pinY)

  normalBounds = (rect
    (centerX - ((normalWidth this) / 2))
    (centerY - ((normalHeight this) / 2))
    (normalWidth this)
    (normalHeight this)
  )

  // apply
  xDelta = (xScale / scaleX)
  yDelta = (yScale / scaleY)
  rDelta = (heading - rotation)
  scaleX = xScale
  scaleY = yScale
  rotation = (heading % 360)
  if (rotation < 0) { rotation += 360 } // ensure range is [0..360)
  changed this
  bounds = (scaledAndRotatedBoundingBox normalBounds scaleX scaleY rotation fixedX fixedY)
  updateCostume this

  // draw pen trails
  if (and (isPenDown this) (not noDraw)) {
    target = (penTarget this)
    if (and (notNil target) (notNil pen)) {
	  movePenBy this 0 0 // fix initial pen position after being manually dragged
      setCanvas pen (requirePenTrails target)
      penEnd = (rotationCenter this)
      if (and ((x pen) == 0) ((y pen) == 0)) {
        setX pen ((rx - (left target)) / (scaleX target))
        setY pen ((ry - (top target)) / (scaleY target))
      }
      goto pen (((first penEnd) - (left target)) / (scaleX target)) (((last penEnd) - (top target)) / (scaleY target))
      if (isVisible target) {changed target}
    }
  }

  // propagate
  for each parts {
    if (rotatesWithOwner each) {
      rotateAndScale each (+ rDelta (rotation each)) (* xDelta (scaleX each)) (* yDelta (scaleY each)) fixedX fixedY noDraw
    } else {
      r = (rotation each)
      //ps = (rotationCenter each)
      rotateAndScale each (+ rDelta (rotation each)) (* xDelta (scaleX each)) (* yDelta (scaleY each)) fixedX fixedY true
      rotateAndScale each r (scaleX each) (scaleY each) nil nil noDraw
    }
  }

  changed this
  return
}

method normalWidth Morph {
  if (isClass costumeData 'Bitmap') {return (width costumeData)}
  return ((width this) / scaleX)
}

method normalHeight Morph {
  if (isClass costumeData 'Bitmap') {return (height costumeData)}
  return ((height this) / scaleY)
}

method normal Morph x y {
  // answer an array containing the given global coordinates
  // transformed to local ones relative to the receiver's center
  xd = (x - (hCenter bounds))
  yd = (y - (vCenter bounds))
  unrotated = (scaleAndRotateAround xd yd (- rotation))
  return (array ((first unrotated) / scaleX) ((last unrotated) / scaleY))
}

method penPosition Morph x y {
  // answer an array containing the given globel coordinates
  // transformed to local ones relative to the receiver's topLeft corner
  normal = (normal this x y)
  return (array
    ((first normal) + ((normalWidth this) / 2))
    ((last normal) + ((normalHeight this) / 2))
  )
}

method transform Morph x y {
  // answer an array containing the given local (normal, relative to the receiver's
  // center) coordinates transformed to globally scaled and rotated ones
  if (rotation == 0) {
	return (array ((hCenter bounds) + (scaleX * x)) ((vCenter bounds) + (scaleY * y)))
  }
  localP = (scaleAndRotateAround x y rotation 0 0 scaleX scaleY)
  return (array (+ (hCenter bounds) (first localP)) (+ (vCenter bounds) (last localP)))
}

method drawingPoint Morph {
  // Return the point at which the costume should be drawn.
  // Deduced from its currently scaled and rotated bounds.

  w = (width bounds)
  h = (height bounds)

  // take into account that the bounds can exceed the
  // costume's dimensions, e.g. inside scroll frames
  if (and (isClass costumeData 'Bitmap') ((rotation % 360) == 0)) {
	costumeW = (scaleX * (width costumeData))
	costumeH = (scaleY * (height costumeData))
	if (costumeW < w) { w = costumeW }
	if (costumeH < h) { h = costumeH }
  }

  // the area's center is invariant for the rotation primitive
  rx = ((left bounds) + (w / 2))
  ry = ((top bounds) + (h / 2))

  // determine the scaled extent of the unrotated texture
  scaledWidth = (scaleX * (normalWidth this))
  scaledHeight = (scaleY * (normalHeight this))

  // the left-top point is invariant for the scaling primitive
  return (array
    (rx - (scaledWidth / 2))
    (ry - (scaledHeight / 2))
  )
}

method scaleTo Morph other {
  otherRC = (rotationCenter other)
  rc = (rotationCenter this)
  dx = ((first otherRC) - (first rc))
  dy = ((last otherRC) - (last rc))
  dist = (sqrt ((dx * dx) + (dy * dy)))
  scl = (dist / ((normalWidth this) / 2))
  rotateAndScale this rotation scl scl
}

method pointTo Morph other {
  otherRC = (rotationCenter other)
  rc = (rotationCenter this)
  dx = ((first otherRC) - (first rc))
  dy = ((last otherRC) - (last rc))
  rotateAndScale this (atan (- dy) dx) scaleX scaleY
}

// visibility

method alpha Morph { return alpha }
method transparency Morph { return ((255 - alpha) / 2.55) }

method setAlpha Morph anInteger {
  if (isNil anInteger) {anInteger = 255}
  alpha = anInteger
  changed this
}

method setTransparency Morph n {
  // Range: 0 is opaque, 100 fully transparent

  setAlpha this (clamp (round (2.55 * (100 - n))) 0 255)
}

method isVisible Morph {return isVisible}
method isHidden Morph {return (not isVisible)}

method hide Morph {
  if isVisible {
    changed this
    isVisible = false
  }
}

method show Morph {
  if isVisible {return}
  isVisible = true
  changed this
}

// scrolling into view

method scrollIntoView Morph {
  sf = (ownerThatIsA this 'ScrollFrame')
  if (notNil sf) {
    scrollIntoView (handler sf) bounds
  }
}

// discoverability

method grabRule Morph {return grabRule}

method setGrabRule Morph aString {
  // 'defer' (default) - I can be a handle for grabbing a morph in my owner chain
  // 'handle' - I can be dragged directly (along with my parts, if any)
  // 'template' - if grabbed I will produce a duplicate of my handler
  // 'ignore' - I eclipse all dragging events, handling them myself
  grabRule = aString
}

method noticesTransparentTouch Morph {return noticesTransparentTouch}
method setTransparentTouch Morph bool {noticesTransparentTouch = bool}

// clipping

method isClipping Morph {return isClipping}

method setClipping Morph bool {
  isClipping = bool
  changed this
}

// other settings

method minWidth Morph {return minWidth}
method minHeight Morph {return minHeight}

method setMinExtent Morph x y {
  if (isNil x) {x = minWidth}
  if (isNil y) {y = minHeight}
  minWidth = x
  minHeight = y
}

method resizingConstraint Morph xOffset yOffset {
  // answer an array denoting the minimum left and top coordinates for a resizing handle
  if (isNil xOffset) {xOffset = 0}
  if (isNil yOffset) {yOffset = 0}
  return (array ((left bounds) + (minWidth - xOffset)) ((top bounds) + (minHeight - yOffset)))
}

method fps Morph {return fps}

method setFPS Morph anIntegerOrNil {
  fps = anIntegerOrNil
  if (isNil fps) {
    lastStepTime = nil
  } else {
    lastStepTime = (msecsSinceStart)
  }
}

method disableStepping Morph {
  // Disable stepping. Used by the debugger to pause stepping when an error is encountered.
  // Details: Negative fps indicates stepping disabled. -1000 means original fps was nil.

  if (isNil fps) {
	fps = -1000
  } else {
	fps = (- (abs fps))
  }
}

method enableStepping Morph {
  // Enable stepping after it's been disabled.

  if (or (isNil fps) (fps > 0)) { return } // already enabled
  if (-1000 == fps) { setFPS this nil }
  setFPS this (abs fps)
}

// printing

method toString Morph {
  if (isNil handler) { return '<Morph>' }
  return (join '<Morph ' (className (classOf handler)) '>')
}

// constructing hierarchy

method addPart Morph another {
  if (notNil (owner another)) {removePart (owner another) another}
  add parts another
  setOwner another this
  changed another
}

method userAddPart Morph another {
  addPart this another
  setGrabRule another 'defer'
}

method removePart Morph another {
  uninterruptedly {
	changed another
	remove parts another
	setOwner another nil
	changed this
  }
}

method removeAllParts Morph {
  reportDamage this (fullBounds this) // remove damage enclosing all parts
  for p parts { setOwner p nil }
  parts = (list)
  changed this
}

method removeFromOwner Morph {
  if (notNil owner) {
	removePart owner this
  }
}

method comeToFront Morph {
  if (notNil owner) {
    addPart owner this
  }
}

method goBackBy Morph n {
  if (isNil owner) { return }
  if (isNil n) { n = 1 }
  ownerParts = (parts owner)
  i = (indexOf ownerParts this)
  if (isNil i) { return } // shouldn't happen
  remove ownerParts this
  addAt ownerParts (i - n) this
  changed this
}

method setOwner Morph another {
  // private - use 'addPart' to construct hierarchies
  owner = another
}

method printHierarchy Morph indent {
  if (isNil indent) { indent = 0 }
  prefix = (joinStrings (newArray (4 * indent) ' '))
  costumeBytes = ((4 * ((width bounds) * (height bounds))) / 1000)
  if (costumeBytes > 500) {
	if (isClass costumeData 'Bitmap') {
	  print prefix (className (classOf handler)) (width bounds) (height bounds) (join '' costumeBytes 'k')
	} else {
	  print prefix (className (classOf handler)) (className (classOf costumeData))
	}
  }
  for m parts {
	printHierarchy m (indent + 1)
  }
}

// accessing hierarchy

method root Morph {
  result = this
  while (notNil (owner result)) {result = (owner result)}
  return result
}

method allMorphs Morph includeHidden {
  // answer a list of myself and all my visible parts
  if (isNil includeHidden) { includeHidden = false }
  return (addAllMorphsTo this (list) includeHidden)
}

method addAllMorphsTo Morph aList includeHidden {
  // private - helper method for "allMorphs"
  if (or isVisible includeHidden) {
    add aList this
    for m parts {addAllMorphsTo m aList includeHidden}
  }
  return aList
}

method partThatIs Morph className {
  for m parts {
    if (isClass (handler m) className) {return m}
    result = (partThatIs m className)
    if (notNil result) {return result}
  }
  return nil
}

method morphsAt Morph x y result {
  // Answer a list of morphs at the given point.
  if (isNil result) { result = (list) }
  if (containsPoint bounds x y) {
	add result this
	for m parts {morphsAt m x y result}
  } else {
	if (not (isClipping this)) {
	  for m parts {morphsAt m x y result}
	}
  }
  return result
}

method allOwners Morph {
  // answer a list of all elements in my owner chain including myself
  result = (list)
  add result this
  m = owner
  while (notNil m) {
    add result m
    m = (owner m)
  }
  return result
}

method ownerThatIsA Morph className {
  m = this
  while (notNil m) {
	if (isClass (handler m) className) {return m}
	m = (owner m)
  }
  return nil
}

method parentHandler Morph {
  // Return the handler of this morph's owner or nil if the owner is nil.
  // skip stand-alone Morphs
  if (isNil owner) {return nil}
  if (notNil (handler owner)) {return (handler owner)}
  return (parentHandler owner)
}

method fullBounds Morph {
  result = (copy bounds)
  if (or isClipping (isEmpty parts)) { return result }
  for m parts {
    if (getField m 'isVisible') {
      merge result (fullBounds m)
    }
  }
  return result
}

method fullVisibleBounds Morph {
  result = (visibleBounds this)
  for m parts {
    if (getField m 'isVisible') {
      merge result (visibleBounds m)
    }
  }
  return result
}

method visibleBounds Morph {
  result = (copy bounds)
  for m (allOwners this) {
    if (isClipping m) {intersect result (bounds m)}
  }
  return result
}

method fullCostume Morph maxW maxH {
  fb = (fullBounds this)
  w = (ceiling (width fb))
  h = (ceiling (height fb))
  // truncate size to avoid running out of memory
  if (isNil maxW) { maxW = 2000 }
  if (isNil maxH) { maxH = 4000 }
  if (or (w > maxW) (h > maxH)) {
    w = (min w maxW)
    h = (min h maxH)
  }
  if (or (w == 0) (h == 0)) {return (newBitmap 1 1)}
  result = (newBitmap w h (gray 0 0))
  offX = ((left this) - (left fb))
  offY = ((top this) - (top fb))
  ctx = (newGraphicContextOn result)
  setOffset ctx (0 - (left fb)) (0 - (top fb))
  fullDrawOn this ctx
  return result
}

// shadow (bitmap shadow, used when not running the browser)

method shadow Morph transparency offset {
  if (isClass handler 'Block') { fixLayout handler }
  fb = (fullBounds this)
  bm = (fullCostume this)
  shadowBM = (newBitmap (width bm) (height bm) (gray 0 transparency))
  applyMask shadowBM bm
  s = (newMorph)
  setCostume s shadowBM // to do: make the shadow untouchable and neutral for fullBounds
  setPosition s ((left fb) + offset) ((top fb) + offset)
  return s
}

method stackPart Morph offset layers {
  clr = (color 153 255 213)
  drk = (darker clr 60)
  fb = (fullBounds this)
  fc = (fullCostume this)
  total = (layers * offset)
  bm = (newBitmap ((width fc) + total) ((height fc) + total))
  for l layers {
    drawBitmap bm fc (total - (offset * l)) (total - (offset * l))
  }
  mask = (newBitmap (width bm) (height bm))
  drawBitmap mask fc 0 0
  applyMask bm mask true // cut out fullCostume, offset left and up

  s = (newMorph)
  setTag s 'stack'
  setParam s layers
  setCostume s bm
  setPosition s (left fb) (top fb)
  return s
}

method getStackPart Morph {
  for each parts {
    if ((tag each) == 'stack') {return each}
  }
  return nil
}

method addStackPart Morph border layers {addPart this (stackPart this border layers)}

method removeStackPart Morph {
  st = (getStackPart this)
  if (notNil st) {
    removePart this st
    return true
  }
  return false
}

method signalPart Morph msg txtColor bgColor {
  if (isNil bgColor) {bgColor = (color 153 255 213)}
  if (isNil txtColor) {txtColor = (color)}
  drk = (darker bgColor 60)
  fb = (fullBounds this)

  scale = (global 'scale')
  bubble =  (stringImage (toString msg) 'Arial' (scale * 12) txtColor 'center' (lighter bgColor 80) scale scale 0 scale clr nil nil false)
  bm = (newBitmap (+ (width bubble) (height bubble)) ((height bubble) + 2))
  fillRoundedRect (newShapeMaker bm) (rect 0 0 (width bm) (height bm)) ((height bubble) / 2) bgColor 1 drk drk
  drawBitmap bm bubble ((height bubble) / 2) 1
  s = (newMorph)
  setTag s 'signal'
  setParam s msg
  setCostume s bm
  setPosition s (left fb) (top fb)
  return s
}

method getSignalPart Morph {
  for each parts {
    if ((tag each) == 'signal') {return each}
  }
  return nil
}

method addSignalPart Morph msg txtColor bgColor {addPart this (signalPart this msg txtColor bgColor)}

method removeSignalPart Morph {
  sp = (getSignalPart this)
  if (notNil sp) {
    removePart this sp
    return true
  }
  return false
}

// highlights

method highlight Morph size {
  highlightM = (getHighlight this)
  if (notNil highlightM) { return highlightM }

  if ('Browser' == (platform)) {
	highlightM = (morph (newShadowEffect handler 'highlight'))
  } else {
	s2 = (size * 2)
	bm = (fullCostume this)
	hl = (newBitmap (+ s2 (width bm)) (+ s2 (height bm)) (color 153 255 213))

	maskBM = (newBitmap (width hl) (height hl))
	drawBitmap maskBM bm 0 0
	drawBitmap maskBM bm size 0
	drawBitmap maskBM bm s2 0
	drawBitmap maskBM bm s2 size
	drawBitmap maskBM bm s2 s2
	drawBitmap maskBM bm size s2
	drawBitmap maskBM bm 0 s2
	drawBitmap maskBM bm 0 size
	applyMask hl maskBM // make silhouette

	fill maskBM (transparent)
	drawBitmap maskBM bm size size
	applyMask hl maskBM true // punch a hole the shape of fullCostume

	highlightM = (newMorph)
	setCostume highlightM hl
	setPosition highlightM (- (left bounds) size) (- (top bounds) size)
  }
  setTag highlightM 'highlight'
  return highlightM
}

method getHighlight Morph {
  for each parts {
    if ((tag each) == 'highlight') {return each}
  }
  return nil
}

method addHighlight Morph {
  highlightWidth = (4 * (global 'scale'))
  if (isNil (getHighlight this)) {
	highlightM = (highlight this highlightWidth)
    addPart this highlightM
    goBackBy highlightM 10000 // behind everything else!
  }
}

method removeHighlight Morph {
  hl = (getHighlight this)
  if (notNil hl) {
    removePart this hl
    return true
  }
  return false
}

// tooltip

method showTooltip Morph aString tipWidth {
  if (or (isNil aString) ('' == aString)) { return nil }
  if (isNil owner) { return nil } // morph deleted before hint was scheduled to appear (e.g. a menu)
  page = (global 'page')
  vis = (visibleBounds this)
  scale = (global 'scale')
  overlap = (scale * 7)
  tip = (newToolTip aString tipWidth)
  rightSpace = ((right (morph page)) - (right vis))
  setTop (morph tip) ((top bounds) - ((height (morph tip)) - overlap))
  if (rightSpace > (width (morph tip))) {
    setLeft (morph tip) (- (right vis) overlap)
  } else {
    setRight (morph tip) (+ (left vis) overlap)
  }
  showTooltip page tip
  reportDamage this (fullBounds (morph tip))
  return tip
}

// talk bubble

method showHint Morph hintData bubbleWidth isHint isError {
  if (isNil isHint) { isHint = true }
  if (or (isNil hintData) ('' == hintData)) {return nil}
  if (isNil owner) {return nil} // morph deleted before hint was scheduled to appear (e.g. a menu)
  page = (page this)
  if (and (isNil page) (isClass (handler owner) 'Hand')) {
	page = (page (handler owner))
  }
  if (isNil page) {return nil} // the morph requesting the hint has been deleted
  vis = (visibleBounds this)
  scale = (global 'scale')
  overlap = (scale * 7)
  bubble = (newBubble hintData bubbleWidth 'right' isError)
  setClientMorph bubble this
  rightSpace = ((right (morph page)) - (right vis))
  setTop (morph bubble) ((top bounds) - ((height (morph bubble)) - overlap))
  if (rightSpace > (width (morph bubble))) {
    setLeft (morph bubble) (- (right vis) overlap)
  } else {
    setField bubble 'direction' 'left'
    fixLayout bubble
    setRight (morph bubble) (+ (left vis) overlap)
  }
  removeHintForMorph page this
  showHint page bubble isHint
  reportDamage this (fullBounds (morph bubble))
  return bubble
}

method showError Morph errorMsg {
  showHint this errorMsg 300 false true
}

method say Morph s {
  sayNothing this
  bubble = (showHint this s 300 false)
  if (isNil bubble) { return } // can happen if morph is in hand
  setClientMorph bubble this
  step bubble
}

method sayNothing Morph {
  pageMorph = (morph (global 'page'))
  for m (copy (parts pageMorph)) {
	h = (handler m)
	if (and (isClass h 'SpeechBubble') ((clientMorph h) == this)) {
	  removePart pageMorph m
	}
  }
}

// deleting

method userDestroy Morph recoverable {
  if (or (isNil handler) (okayToBeDestroyedByUser handler)) {
    destroy this recoverable
    return true
  }
  return false
}

method destroy Morph recoverable {
  if (isNil recoverable) {recoverable = false}
  if (notNil owner) {
	reportDamage owner (fullBounds this)
	removePart owner this
  }
  if (not recoverable) {
    costumeData = nil
    penTrailsData = nil
  }
  while ((count parts) > 0) {destroy (at parts 1)}
  if (notNil handler) {destroyedMorph handler}
  stopTasksFor (global 'page') handler
}

// moving

method moveBy Morph xDelta yDelta {
  if (and (xDelta == 0) (yDelta == 0)) { return }
  fb = (fullBounds this)
  reportDamage this fb
  if (isPenDown this) { movePenBy this xDelta yDelta }
  fastMoveBy this xDelta yDelta
  reportDamage this (translatedBy fb xDelta yDelta)
}

// fast positioning functions -- these do not report damage!

method fastSetPosition Morph x y { fastMoveBy this (x - (left bounds)) (y - (top bounds)) }
method fastSetLeft Morph x { fastMoveBy this (x - (left bounds)) 0 }
method fastSetTop Morph y { fastMoveBy this 0 (y - (top bounds)) }
method fastSetRight Morph x {fastMoveBy this (x - (right bounds)) 0}
method fastSetBottom Morph y {fastMoveBy this 0 (y - (bottom bounds))}
method fastSetXCenter Morph x {fastMoveBy this (x - ((left bounds) + (half (width bounds)))) 0}
method fastSetYCenter Morph y {fastMoveBy this 0 (y - ((top bounds) + (half (height bounds))))}

method fastSetYCenterWithin Morph top bottom {
  ySpan = (bottom - top)
  height = (height bounds)
  if (height > ySpan) {
	fastSetTop this top
  } else {
	fastSetTop this (top + (half (ySpan - height)))
  }
}

method fastMoveBy Morph xDelta yDelta {
  // Internal helper for moveBy. Just moves the morph and all its descendent morphs.
  // Does not report damage or move the pen.

  if (and (xDelta == 0) (yDelta == 0)) { return }
  translateBy bounds xDelta yDelta
  todo = (list)
  addAll todo parts
  while (notEmpty todo) {
	m = (removeFirst todo)
	translateBy (bounds m) xDelta yDelta
	addAll todo (parts m)
  }
}

method movePenBy Morph xDelta yDelta {
  target = (penTarget this)
  if (and (notNil target) (notNil pen)) {
    setCanvas pen (requirePenTrails target)
    rc = (rotationCenter this)
    setX pen (((first rc) - (left target)) / (scaleX target))
    setY pen (((last rc) - (top target)) / (scaleY target))
    goto pen (+ (xDelta / (scaleX target)) (x pen)) (+ (yDelta / (scaleY target)) (y pen))
    if (isVisible target) {changed target}
  }
}

method setPosition Morph x y {moveBy this (x - (left bounds)) (y - (top bounds))}
method setLeft Morph x {moveBy this (x - (left bounds)) 0}
method setRight Morph x {moveBy this (x - (right bounds)) 0}
method setTop Morph y {moveBy this 0 (y - (top bounds))}
method setBottom Morph y {moveBy this 0 (y - (bottom bounds))}
method gotoCenterOf Morph another {setCenter this (hCenter (bounds another)) (vCenter (bounds another))}

method setCenter Morph x y {
  moveBy this (x - ((left bounds) + (half (width bounds)))) (y - ((top bounds) + (half (height bounds))))
}

method setXCenter Morph x {moveBy this (x - ((left bounds) + (half (width bounds)))) 0}
method setYCenter Morph y {moveBy this 0 (y - ((top bounds) + (half (height bounds))))}

method setYCenterWithin Morph top bottom {
  height = (bottom - top)
  setYCenter this (+ top (half height))
  if (height < (height this)) {
    error 'taller than confines'
  }
  if ((bottom this) > bottom) {
    setBottom this bottom
  }
  if ((top this) < top) {
    setTop this top
  }
}

method keepWithin Morph trgRect srcRect {
  // srcRect is optional, if provided it keeps that portion of the
  // receiver morph within the target area
  stayLeftAbove this (right trgRect) (bottom trgRect) srcRect
  stayRightBelow this (left trgRect) (top trgRect) srcRect
}

method stayRightBelow Morph x y srcRect {
  if (isNil srcRect) {srcRect = (fullBounds this)}
  if (isNil x) {x = (left srcRect)}
  if (isNil y) {y = (top srcRect)}
  leftOff = (min 0 ((left srcRect) - x))
  topOff = (min 0 ((top srcRect) - y))
  if (or (leftOff < 0) (topOff < 0)) {
    moveBy this (abs leftOff) (abs topOff)
  }
}

method stayLeftAbove Morph x y srcRect {
  if (isNil srcRect) {srcRect = (fullBounds this)}
  if (isNil x) {x = (right srcRect)}
  if (isNil y) {y = (bottom srcRect)}
  rightOff = (max 0 ((right srcRect) - x))
  bottomOff = (max 0 ((bottom srcRect) - y))
  if (or (rightOff > 0) (bottomOff > 0)) {
    moveBy this (0 - rightOff) (0 - bottomOff)
  }
}

// animation

method animateTo Morph dstX dstY doneAction {
  updatePosition = (action
	(function m srcX srcY dstX dstY ratio {
	  newX = (round (srcX + (ratio * (dstX - srcX))))
	  newY = (round (srcY + (ratio * (dstY - srcY))))
	  reportDamage m (expandBy (fullBounds m) 1) // why is this needed?
	  setPosition m newX newY
	})
	this (left this) (top this) dstX dstY)
  addSchedule (global 'page') (newAnimation 0.0 1.0 400 updatePosition doneAction true)
}

// insetting (relative to owner)

method setInsetInOwner Morph dx dy {
  // Inset my left-top corner by the given amounts relative to my owner.
  if (isNil owner) { return }
  scale = (scale owner)
  newLeft = ((left owner) + (scale * dx))
  newTop = ((top owner) + (scale * dy))
  moveBy this (newLeft - (left bounds)) (newTop - (top bounds))
}

// resizing

method setExtent Morph width height {
  if (isNil width) {width = (max 0 (width bounds))}
  if (isNil height) {height = (max 0 (height bounds))}

  // only redraw if the dimensions have changed
  if (and (width == (width bounds)) (height == (height bounds))) {return}

  changed this
  setWidth bounds width
  setHeight bounds height
  resizePenTrails this
  rerender this
}

// event-induced resizing

method setExtentToRightBottom Morph another {
  changed this
  setRight bounds (right another)
  setBottom bounds (bottom another)
  raise this 'fixLayout' handler
  redraw handler
}

method setWidthToRight Morph another {
  changed this
  setRight bounds (right another)
  raise this 'fixLayout' handler
  redraw handler
}

method setHeightToBottom Morph another {
  changed this
  setBottom bounds (bottom another)
  raise this 'fixLayout' handler
  redraw handler
}

// drawing

method fullDrawOn Morph aContext {
  if (not isVisible) { return }
  if (and (isClass handler 'Block') (true == (getField handler 'layoutNeeded'))) { fixLayout handler }
  if (and isClipping (not (intersectsClip aContext bounds))) { return }

  if shouldRedraw {
	redraw handler
	shouldRedraw = false
  }
  if costumeChanged {
	transformedCostume = nil
	costumeChanged = false
  }

  saveState aContext
  if isClipping { setClip aContext bounds }

  // draw the morph
  if (intersectsClip aContext bounds) {
	if (and (isNil handler) (notNil costumeData)) {
	  // this case (no handler) is used for the hand's shadow
	  if (isClass costumeData 'Bitmap') {
		drawBitmap aContext costumeData (left bounds) (top bounds)
	  } (isClass costumeData 'Color') {
		fillRect aContext costumeData (left bounds) (top bounds) (width bounds) (height bounds)
	  }
	} else {
	  useOldDraw = false
	  if useOldDraw {
		drawCostumeOn this aContext
	  } else {
		drawOn handler aContext
	  }
	}
  }

  // draw its parts
  for each parts { fullDrawOn each aContext }
  restoreState aContext
}

to drawOn aHandler aContext {
  // Backstop for handlers that have not implemented drawOn.

  if (isNil aHandler) { return }
  morph = nil
  if (hasField aHandler 'morph') { morph = (getField aHandler 'morph') }
  if (isNil morph) { // shouldn't happen
	print 'nil morph in drawOn of' (className (class aHandler))
	return
  }
  drawCostumeOn (getField aHandler 'morph') aContext
}

method drawCostumeOn Morph aContext {
  // Draw my costumeData on the given GraphicContext.
  // Called when a handler does not implement drawOn.

  x = (left bounds)
  y = (top bounds)

  if (isClass costumeData 'Color') {
	fillRect aContext costumeData x y (width this) (height this) 1 // blend mode
  } (isClass costumeData 'Bitmap') {
	if (0 == (rotation % 360)) {
	  if (and (scaleX == 1) (scaleY == 1)) { // neither scaled nor rotated
		drawBitmap aContext costumeData x y
	  } else { // scaled, but not rotated
		warpBitmap aContext costumeData x y scaleX scaleX
	  }
	} else { // rotated
	  rotatedBM = (transformedCostume this)
	  if (notNil rotatedBM) { drawBitmap aContext rotatedBM x y }
	}
  }
}

// Old draw method (still used for off-screen rendering right now)

method draw Morph destination xOffset yOffset destScaleX destScaleY clipRect {
  // Still used for off-screen rendering of morphs.

  if (not isVisible) {return}
  if (isNil xOffset) {xOffset = 0}
  if (isNil yOffset) {yOffset = xOffset}
  if (isNil destScaleX) {destScaleX = 1}
  if (isNil destScaleY) {destScaleY = destScaleX}

  if isClipping {
    bnds = (translatedBy bounds xOffset yOffset)
    if (isNil clipRect) {
      clipRect = bnds
    } else {
      clipRect = (intersection bnds clipRect)
    }
  }
  if (notNil clipRect) {
	if (or ((width clipRect) <= 0) ((height clipRect) <= 0)) { return }
  }

  origin = (drawingPoint this)
  x = (((first origin) + xOffset) * destScaleX)
  y = (((last origin) + yOffset) * destScaleY)

  if (isClass costumeData 'Color') {
	r = (rect x y (width bounds) (height bounds))
	if (notNil clipRect) { intersect r clipRect }
	fillRect destination costumeData (left r) (top r) (width r) (height r) 1 // blendMode=blend
  } (isClass costumeData 'Bitmap') {
	if (0 == (rotation % 360)) {
	  if (and (scaleX == 1) (scaleY == 1)) { // neither scaled nor rotated
		drawBitmap destination costumeData x y alpha 1 clipRect
	  } else { // scaled, but not rotated
		centerX = (x + (half (destScaleX * (width bounds))))
		centerY = (y + (half (destScaleY * (height bounds))))
		warpBitmap destination costumeData centerX centerY (scaleX * destScaleX) (scaleY * destScaleY) 0
	  }
	} else { // rotated
	  drawBitmap destination (transformedCostume this) x y alpha 1 clipRect
	}
  }

  if (notNil penTrailsData) {
	drawPenTrailsOn this destination x y destScaleX destScaleY
  }

  for each parts {
    draw each destination xOffset yOffset destScaleX destScaleY clipRect
  }
}

method takeSnapshot Morph {
  // Return a bitmap with a snapshot of the given morph at its normal size.

  return (takeSnapshotWithBounds this (fullBounds this))
}

method takeSnapshotWithBounds Morph rect {
  // Return a bitmap with a snapshot of this morph with the given global rectangle.

  bm = (newBitmap (width rect) (height rect))
  ctx = (newGraphicContextOn bm)
  setOffset ctx (- (left rect)) (- (top rect))
  fullDrawOn this ctx
  return bm
}

method takeThumbnail Morph thumbWidth thumbHeight {
  w = (width this)
  h = (height this)

  bm = (newBitmap thumbWidth thumbHeight)
  fillRect bm (color 240 240 240) 0 0 (width bm) (height bm)

  if (or (height == 0) (width == 0)) {
    return bm
  }

  orig = (takeSnapshot this)
  mag = (min (thumbWidth / w) (thumbHeight / h))
  fitW = ((thumbHeight / h) >= (thumbWidth / w))

  areaFilled = (((w * mag) * (h * mag)) / (thumbWidth * thumbHeight))

  if (areaFilled < 0.2) {
    // too big of a mismatch in aspect ratio
    mag = (max (thumbHeight / h) (thumbWidth / w))
    thumb = (thumbnail orig (w * mag) (h * mag))

    if fitW {
      drawBitmap bm thumb ((thumbWidth - (width thumb)) / 2) 0
    } else {
      drawBitmap bm thumb 0 ((thumbHeight - (height thumb)) / 2)
    }
    return bm
  }

  orig = (takeSnapshot this)
  thumb = (thumbnail orig (w * mag) (h * mag))

  if fitW {
    drawBitmap bm thumb 0 ((thumbHeight - (height thumb)) / 2)
  } else {
    drawBitmap bm thumb ((thumbWidth - (width thumb)) / 2) 0
  }
  return bm
}

// sensing

method isTransparentAt Morph x y {
  // Return true if the given morph is transparent at the given (global) position.
  // Fast in apps but expensive for large blocks in the browser (30-60 msecs).
  // May want to try a different stategy -- draw onto canvas, read back one pixel.

  if (rotation != 0) { return false } // don't deal with rotation for now
  bm = (newBitmap (width bounds) (height bounds))
  ctx = (newGraphicContextOn bm)
  setOffset ctx (0 - (left this)) (0 - (top this))
  drawOn (handler this) ctx

  relX = (round (x - (left bounds)))
  relY = (round (y - (top bounds)))
  if (or (relX < 0) (relX >= (width bm))) { return true }
  if (or (relY < 0) (relY >= (height bm))) { return true }
  return ((getAlpha bm relX relY) < 10)
}

// stepping

method step Morph {
  if (notNil handler) {
    if (isNil fps) {
      leftover = 0
    } (fps <= 0) {
      leftover = 1
    } else {
	  now = (msecsSinceStart)
	  if (now < lastStepTime) { lastStepTime = 0 } // clock wrap
      leftover = ((truncate (1000 / fps)) - (now - lastStepTime))
    }
    if (leftover < 1) {
      lastStepTime = (msecsSinceStart)
      step handler
    }
  }
  for each parts {step each}
}

// change propagation

method changed Morph {
  if (and isVisible (notNil owner)) {
	reportDamage owner bounds
  } (and (isClass handler 'Hand') (notEmpty parts)) {
	reportDamage (morph (global 'page')) (fullBounds this)
  }
}

method reportDamage Morph rect {
  // Pass a damage rectangle up the owner chain and record it in Page/s damage list.
  // Propagation is stopped by an invisble morph (whose subtree is also invisible).
  // The damage rectangle is clipped to the bounds of clipping morphs.

  if (not isVisible) { return }

  if (isClass handler 'Page') {
	addDamage handler rect
  } (isClass handler 'Hand') {
	if (not (isEmpty parts)) { reportDamage (morph (global 'page')) rect }
  } (isClass handler 'Stage') {
	if costumeChanged { return } // stage has already reported damage
	costumeChanged = true // stage uses this flag to indicate that damage has been reported
	reportDamage owner bounds
  } (and isVisible (notNil owner) (owner != this)) {
	if isClipping {
	  if (intersects rect bounds) {
		reportDamage owner (intersection bounds rect)
	  }
	} else {
	  reportDamage owner rect
	}
  }
}

method rerender Morph {
  if shouldRedraw { return } // already reported damage
  changed this
  shouldRedraw = true
}

method raise Morph eventName origin {
  if (notNil owner) {
    if (and (acceptsEvents owner) (implements (handler owner) eventName)) {
      call eventName (handler owner) origin
    } else {
      raise owner eventName origin
    }
  }
}

// pentrails layer

method deletePenTrails Morph { penTrailsData = nil }

method clearPenTrails Morph {
  transparent = (gray 255 0) // transparent white
  if (notNil penTrailsData) { fill penTrailsData transparent }
}

method drawPenTrailsOn Morph destination dstX dstY dstScaleX dstScaleY {
  centerX = (dstX + (half (width this)))
  centerY = (dstY + (half (height this)))
  drawScaleX = (scaleX * dstScaleX)
  drawScaleY = (scaleY * dstScaleY)
  warpBitmap destination penTrailsData centerX centerY drawScaleX drawScaleY
}

method requirePenTrails Morph {
  if (isNil penTrailsData) {
	penTrailsData = (newBitmap (normalWidth this) (normalHeight this))
  }
  return penTrailsData
}

method resizePenTrails Morph {
  if (notNil penTrailsData) {
    bm = (newBitmap (width this) (height this))
    drawBitmap bm penTrailsData
    penTrailsData = bm
  }
}

// pen

method requirePen Morph {
  if (vectorTrails) {
    if (isClass pen 'TurtlePen') {
      return pen
    }
    pen = (newTurtlePen)
  } else {
    if (isClass pen 'Pen') {
      return pen
    }
    pen = (newPen)
  }
  setLineWidth pen (global 'scale')
  return pen
}

method penDown Morph {down (requirePen this)}
method isPenDown Morph {return (and (notNil pen) (isDown pen))}
method penUp Morph {if (notNil pen) {up pen}}
method isPenUp Morph {return (not (isPenDown this))}
method setPenColor Morph aColor {setColor (requirePen this) aColor}
method penColor Morph {return (color (requirePen this))}
method setPenLineWidth Morph aNumber {setLineWidth (requirePen this) aNumber}
method penLineWidth Morph {return (getField (requirePen this) 'size')}
method setDrawOnOwner Morph bool {drawOnOwner = bool}

method penClear Morph {
  target = (penTarget this)
  if (notNil target) {
    deletePenTrails target
    changed target
  }
}

method stampCostume Morph stampTransparency {
  // Paste my costume onto my owner's penTrails layer.
  // Optional stampTransparency has range 0 (opaque) to 100 (fully transparent).

  target = (penTarget this)
  if (isNil target) { return }
  if (isNil stampTransparency) { stampTransparency = 0 }
  stampAlpha = (clamp (toInteger (2.55 * (100 - stampTransparency))) 0 255)
  if (0 == stampAlpha) { return } // completely transparent; no effect
  trails = (requirePenTrails target)
  oldAlpha = alpha
  wasHidden = (isHidden this)
  show this
  alpha = stampAlpha
  draw this trails (- (left target)) (- (top target)) (1 / (scaleX target)) (1 / (scaleY target))
  if wasHidden { hide this }
  alpha = oldAlpha
  changed target
}

method penTarget Morph {
  if (isNil owner) {return nil}
  if (isClass (handler owner) 'Hand') {return nil}
  if drawOnOwner {
	target = owner
  } (isAnyClass (handler owner) 'Page' 'Stage') { // common case optimization
	target = owner
  } else {
	target = (ownerThatIsA this 'Stage')
	if (isNil target) {
	  target = (morph (global 'page'))
	}
  }
  return target
}

// menu

method contextMenu Morph {
  menu = (menu (toString handler) this)
  scale = (global 'scale')
  if (isNil costumeData) {
    thm = (newBitmap (* scale 18) (* scale 18))
  } else {
    thm = (thumbnail costumeData (* scale 18) (* scale 18))
  }
  if (or (devMode) (isClass handler 'Turtle') (notNil (scripts (classOf handler)))) {
    addItem menu 'select' 'openScripter' 'show the scripts for this object'
  }
  if (devMode) {
	addLine menu
	addItem menu 'explore...' 'exploreHandler' 'open an explorer window on this object''s internals'
	addItem menu 'browse class...' 'browseHandler' 'open a browser window on this object''s class'
	addLine menu
  }
  if (notNil penTrailsData) {
	addLine menu
    addItem menu 'clear pen trails' 'deletePenTrails'
  }
  if (isClass handler 'Page') { return menu }

  addItem menu 'come to front' 'comeToFront' 'show this object on top of its siblings'
  addLine menu
  addItem menu 'duplicate' 'duplicateMorph' 'duplicate and grab this object'
  addItem menu 'delete' 'destroy'
  addLine menu
  addItem menu 'scale...' (action 'scalingHandle' handler) 'scale this object'
  addItem menu 'rotate...' (action 'rotationHandle' handler) 'rotate this object'
  addItem menu 'rotation point...' (action 'pinHandle' handler) 'edit the point about which this object rotates'
  if (or (pinX != 0) (pinY != 0)) {
    addItem menu 'set rotation point to center...' (action 'setPin' this 0 0) 'make this object''s rotation point be its center'
  }
  if rotateWithOwner {
    addItem menu 'rotate independently' 'toggleRotationStyle' 'keep current orientation instead of rotating with the owner'
  } else {
    addItem menu 'rotate with owner' 'toggleRotationStyle' 'rotate with owner, as if rigidly attached to it'
  }
  addLine menu
//  addItem menu 'attach...' 'attach' 'stick this object to another object'
  if (not (isTopLevel this)) {
    addItem menu 'slide...' (action 'moveHandle' handler) 'move this object without detaching it'
    addItem menu 'detach' 'userGrab' 'detach and grab this part'
  } else {
    addItem menu 'grab' 'userGrab' 'grab this instance'
  }
  if ((count parts) > 0) {
	addLine menu
	addItem menu 'detach all parts (ungroup)' 'detachAll' 'detach all my parts'
  }
  if ('draggableParts' == grabRule) {
    addItem menu 'do not allow parts to be dragged in and out' (action 'toggleDraggableParts' this)
  } else {
    addItem menu 'allow parts to be dragged in and out' (action 'toggleDraggableParts' this)
  }
  addLine menu
  addPropertyEditingItems this menu
  return menu
}

method exploreHandler Morph {explore (hand (page this)) handler}

method browseHandler Morph {
  page = (page this)
  brs = (newClassBrowser)
  setPosition (morph brs) (x (hand page)) (y (hand page))
  addPart page brs
  browse brs (classOf handler)
}

method openScripter Morph {
  showInScripter (handler this)
}

method grab Morph hand {
  if (isNil handler) {return}
  if (isNil hand) {hand = (hand (global 'page'))}
  setCenter this (x hand) (y hand)
  grab hand handler
}

method userGrab Morph hand {
  setGrabRule this 'handle'
  grab this hand
}

method grabCentered Morph aHandler {
  h = (hand (page this))
  setCenter (morph aHandler) (x h) (y h)
  grab h aHandler
}

method grabTopLeft Morph {
  // Grab this morph near it's top-left corner.

  scale = (global 'scale')
  h = (hand (global 'page'))
  setPosition this ((x h) - (7 * scale)) ((y h) - (7 * scale))
  grab h handler
}

method detachAll Morph {
  newOwner = (self_stageMorph)
  if (isNil newOwner) { return }
  for p parts {
    setGrabRule p 'handle'
    addPart newOwner p
  }
}

method duplicateMorph Morph {
  newMorph = (deepCopy this (array owner))
  grabCentered this (handler newMorph)
}

method attach Morph {
  scale = (global 'scale')
  fb = (fullVisibleBounds this)
  page = (page this)
  targets = (list)
  all = (allMorphs (morph page))
  removeAll all (allMorphs this)
  for each all {
    if (intersects fb (fullVisibleBounds each)) {add targets each}
  }
  menu = (menu (join 'attach ' (toString handler) ' to:') this)
  for each targets {
    if (or (devMode) (not (isAnyClass (handler each) 'Page' 'Stage' 'ProjectEditor'))) {
      if (isNil (costumeData each)) {
        thm = (newBitmap (* scale 18) (* scale 18))
      } else {
        thm = (thumbnail (costumeData each) (* scale 18) (* scale 18))
      }
      addItem menu (join (toString (handler each)) '...') (action 'userAddPart' each) nil thm
    }
  }
  addLine menu
  addItem menu 'cancel' 'nop'
  popUpAtHand menu (page this)
}

method toggleDraggableParts Morph {
  if ('draggableParts' == grabRule) {
    setGrabRule this 'handle'
  } else {
    setGrabRule this 'draggableParts'
  }
}

// property editing

method addPropertyEditingItems Morph menu {
  // Add menu items for interactively changing properties such as transparency, color, or size.
  // Most of these properties are optional and only displayed if the handler implements
  // a setter for that property.

  addItem menu 'set transparency...' (action 'changeTransparency' this)
  if (implements handler 'setColor') {
    addItem menu 'set color...' (action 'changeColor' this)
  }
  if (implements handler 'setWidth') {
    addItem menu 'set width...' (action 'changeWidth' this)
  }
  if (implements handler 'setHeight') {
    addItem menu 'set height...' (action 'changeHeight' this)
  }
  if (implements handler 'setRadius') {
    addItem menu 'set radius...' (action 'changeRadius' this)
  }
  if (implements handler 'setText') {
    addItem menu 'set text...' (action 'changeText' this)
  }
  if (implements handler 'setFontName') {
    addItem menu 'set font name...' (action 'changeFontName' this)
  }
  if (implements handler 'setFontSize') {
    addItem menu 'set font size...' (action 'changeFontSize' this)
  }
}

method changeTransparency Morph {
  promptForNumber 'Transparency?' (action 'setTransparency' this) 0 100 (transparency this)
}

method changeColor Morph {
  if (isClass costumeData 'Color') {
    currentColor = (costumeData morph)
  } (hasField handler 'color') {
    currentColor = (getField handler 'color')
  } else {
    currentColor = (gray 200)
  }
  colorPicker = (newColorPicker (action 'setColor' handler) currentColor)
  addPart (global 'page') (morph colorPicker)
}

method changeWidth Morph {
  current = (normalWidth this)
  promptForNumber 'Width?' (action 'setWidth' handler) 1 1000 current
}

method changeHeight Morph {
  current = (normalHeight this)
  promptForNumber 'Height?' (action 'setHeight' handler) 1 1000 current
}

method changeRadius Morph {
  current = (half (min (normalWidth this) (normalHeight this)))
  promptForNumber 'Radius?' (action 'setRadius' handler) 1 500 current
}

method changeText Morph {
  current = ''
  if (hasField handler 'text') { current = (getField handler 'text') }
  s = (prompt (global 'page') 'Text?' current)
  if ('' == s) { return }
  setText handler s
}

method changeFontName Morph {
  current = ''
  if (hasField handler 'fontName') { current = (getField handler 'fontName') }
  fn = (prompt (global 'page') 'Font Name?' current)
  if ('' == fn) { return }
  setFontName handler fn
}

method changeFontSize Morph {
  current = 18
  if (hasField handler 'fontSize') { current = (getField handler 'fontSize') }
  promptForNumber 'Font Size?' (action 'setFontSize' handler) 1 500 current
}

// serialization

method serializedFieldNames Morph {
  omittedFields = (array 'costume' 'pen' 'penTrails' 'penTrailsData')
  result = (list)
  addAll result (fieldNames (classOf this))
  removeAll result omittedFields
  return (toArray result)
}

method deserialize Morph fieldDict {
  // Initialize this morph from the given dictionary,
  // migrating old fields to new fields as needed.

  for k (fieldNames (classOf this)) {
	setField this k (at fieldDict k)
  }

  if (contains fieldDict 'originalCostume') {
	origCostume = (at fieldDict 'originalCostume')
	if (notNil origCostume) { costumeData = origCostume }
  }

  // Initialize recently added instance variables
  if (isNil drawOnOwner) { drawOnOwner = true }
  if (isNil rotation) {
	rotation = 0
	rotateWithOwner = true
	scaleX = 1
	scaleY = 1
	pinX = 0
	pinY = 0
  }

  // Field rename: identifier -> tag
  if (contains fieldDict 'identifier') {
	tag = (at fieldDict 'identifier')
  }
}

method preSerialize Morph {
  if (hasField handler 'window') {
	w = (getField handler 'window')
	if (isClass w 'Window') { preSerialize w }
  } (implements handler 'redraw') {
	setCostume (morph handler) nil
  }
  costume = nil
  penTrails = nil
  preSerialize handler
  for m parts { preSerialize m }
}

method postSerialize Morph {
  for m parts { postSerialize m }
  postSerialize handler
  doRedraw = false
  if (hasField handler 'window') {
	w = (getField handler 'window')
	if (isClass w 'Window') {
	  doRedraw = true
	  postSerialize w
	}
  }
  if (and (not doRedraw) (isNil costumeData) (implements handler 'redraw')) {
	doRedraw = true
	if (notNil owner) {
	  // Optimization to avoid redundant drawing (and bitmap creation):
	  //   Assume ScrollFrames are inside Windows, so will be redrawn later
	  //   Morphs owned by a ScrollFrame or Slider will be redrawn by their owner

	  if (isClass handler 'ScrollFrame') { doRedraw = false }
	  if (isAnyClass (handler owner) 'ScrollFrame' 'Slider') { doRedraw = false }
	}
  }
  if doRedraw { redraw handler true }
  gcIfNeeded
}
// MorphRefIcon - Display an arrow pointing to the target morph while pressed.
// The target is retrieved by evaluating an action.

defineClass MorphRefIcon morph isActive getTarget

method isActive MorphRefIcon { return isActive }

method targetMorph MorphRefIcon {
  if (isNil getTarget) { return nil }
  result = (call getTarget)
  if (hasField result 'morph') {
	result = (getField result 'morph')
  }
  if (not (isClass result 'Morph')) { return nil }
  return result
}

method initialize MorphRefIcon varName targetObj targetModule {
  morph = (newMorph this)
  setCostume morph (makeIcon this)
  setScale morph ((global 'scale') / 2)
  setTransparentTouch morph true
  setFPS morph 5
  hide morph // initially hidden; step will make it visible if it is a morph
  isActive = false
  if (notNil varName) {
	if (isNil targetObj) {
	  getTarget = (action 'shared' varName targetModule)
	} else {
	  if ('this' == varName) {
		getTarget = (action 'id' targetObj)
	  } else {
		getTarget = (action 'getField' targetObj varName)
	  }
	}
  }
  return this
}

method makeIcon MorphRefIcon {
  bm = (newBitmap 34 20)
  pen = (newVectorPen bm)

  beginPath pen 1 10
  setHeading pen 0
  forward pen 32 57
  setHeading pen 180
  forward pen 32 57
  stroke pen (gray 50) 2

  beginPath pen 10 10
  setHeading pen 270
  turn pen 360 7
  fill pen (gray 50)
  return bm
}

method step MorphRefIcon {
  // Show only when the target is a morph.
  if (isClass (targetMorph this) 'Morph') {
	show morph
  } else {
	hide morph
  }
}

method handDownOn MorphRefIcon hand {
  handLeave this hand // cancel the hint
  focusOn hand this
  isActive = true
  return true
}

method handUpOn MorphRefIcon hand {
  isActive = false
  return true
}

// hint

method handEnter MorphRefIcon aHand {
  hint = 'Press and hold to show an arrow pointing to the object referred to by this variable.
To make this variable refer to a different object, drop that object onto the readout.'

  hint = 'Press and hold to point to the object in this variable.
To refer to a different object, drop it onto the readout.'
  addSchedule (global 'page') (schedule (action 'showTooltip' morph hint) 800)
}

method handLeave MorphRefIcon aHand {
  removeSchedulesFor (global 'page') 'showTooltip' morph
  removeHint (page aHand)
}
defineClass PNGReader data allDataChunk unknownChunks colorType interlaceMethod bitmap width height depth palette transparency backColor bitsPerPixel bitsPerChannel bytesPerScanline BPP BlockWidth BlockHeight script

method init PNGReader {
  BPP = (array (array 1 2 4 8 16)
               (array 0 0 0 0 0)
               (array 0 0 0 24 48)
               (array 1 2 4 8 0)
               (array 0 0 0 16 32)
               (array 0 0 0 0 0)
               (array 0 0 0 32 64)
               (array 0 0 0 0 0))
  BlockWidth = (array 8 4 4 2 2 1 1)
  BlockHeight = (array 8 8 4 4 2 2 1)
  depth = 32
}

method getScriptText PNGReader d {
  // Extract a tEXt chunk with the key 'script'. If there isn't one, return nil.
  init this
  data = (dataStream d true)
  unknownChunks = (list)
  sig = (toArray (nextData data 8))
  if (sig != (array 137 80 78 71 13 10 26 10)) {
	error 'Bad PNG file signature'
  }
  script = nil
  while (not (atEnd data)) {
    // Process only 'tEXt' chunks; skip others.
    length = (nextUInt32 data)
    chunkType = (nextString data 4)
    chunk = (nextData data length)
    chunkCrc = (nextUInt32 data)
    crc = (crc chunk false (crc chunkType))
    if (and (crc == chunkCrc) (chunkType == 'tEXt')) {
      processTextChunk this chunk
    }
  }
  return script
}

method readFrom PNGReader d {
  init this
  data = (dataStream d true)
  unknownChunks = (list)
  sig = (toArray (nextData data 8))
  if (sig != (array 137 80 78 71 13 10 26 10)) {
	error 'Bad PNG file signature'
  }
  while (not (atEnd data)) {
    processNextChunk this
  }
  if ((count unknownChunks) > 0) {
//    print 'unknownChunks' unknownChunks
  }
  if (interlaceMethod == 0) {
     processNonInterlaced this allDataChunk
  } else {
     processInterlaced this allDataChunk
  }
  return bitmap
}

method processNextChunk PNGReader {
  length = (nextUInt32 data)
  chunkType = (nextString data 4)
  chunk = (nextData data length)
  chunkCrc = (nextUInt32 data)
  crc = (crc chunk false (crc chunkType))
  if (crc != chunkCrc) {
	error (join 'PNGReader crc error in chunk ' chunkType)
  }

  if (chunkType == 'IHDR') {
    processIHDRChunk this chunk
  } (chunkType == 'IEND') {
    return // *should* be the last chunk
  } (chunkType == 'PLTE') {
    processPLTEChunk this chunk
  } (chunkType == 'tRNS') {
    processTransparencyChunk this chunk
  } (chunkType == 'tEXt') {
    processTextChunk this chunk
  } (chunkType == 'iTXt') {
    processITextChunk this chunk
  } (chunkType == 'zTXt') {
    processZTextChunk this chunk
  } (chunkType == 'bKGD') {
    processBackgroundChunk this chunk
  } (chunkType == 'IDAT') {
    if (isNil allDataChunk) {
      allDataChunk = chunk
    } else {
      newChunk = (newBinaryData ((byteCount allDataChunk) + (byteCount chunk)))
      replaceByteRange newChunk 1 (byteCount allDataChunk) allDataChunk 1
      replaceByteRange newChunk ((byteCount allDataChunk) + 1) (byteCount newChunk) chunk 1
      allDataChunk = newChunk
    }
  } (chunkType == 'pHYs') {
    nop
  } (chunkType == 'iCCP') {
	nop
  } (chunkType == 'gAMA') {
    nop
  } (chunkType == 'sBIT') {
    nop
  } (chunkType == 'hIST') {
    nop
  } (chunkType == 'tIME') {
    nop
  } (chunkType == 'cHRM') {
    nop
  } (chunkType == 'sPLT') {
    nop
  } else {
    add unknownChunks chunkType
  }
}

method processIHDRChunk PNGReader chunk {
  s = (dataStream chunk true)
  width = (nextUInt32 s)
  height = (nextUInt32 s)
  bitsPerChannel = (nextUInt8 s)
  colorType = (nextUInt8 s)

  compression     = (nextUInt8 s)
  if (compression != 0) {error 'unsupported compression scheme'}
  filterMethod    = (nextUInt8 s)
  if (filterMethod != 0) {error 'unsupported compression scheme'}
  interlaceMethod = (nextUInt8 s)

  if (colorType == 0) { // grayscale
    palette = (grayColorsFor this bitsPerChannel)
  }
  bitsPerPixel = (at (at BPP (colorType + 1)) (highBit bitsPerChannel))
  bytesPerScanline = (truncate (((width * bitsPerPixel) + 7) / 8))
}

method grayColorsFor PNGReader d {
  // return a color table for a gray image

  palette = (newArray (1 << d))
  if (d == 1) {
    atPut palette 1 (color 0 0 0)
    atPut palette 2 (color 255 255 255)
  } (d == 2) {
    atPut palette 1 (color 0 0 0)
    atPut palette 2 (color 85 85 85)
    atPut palette 3 (color 170 170 170)
    atPut palette 4 (color 255 255 255)
  } (d == 4) {
    for i 16 {
      g = (i - 1)
      v = (truncate ((g * 255) / 15))
      atPut palette i (color v v v)
    }
  } (or (d == 8) (d == 16)) {
    for i 256 {
      v = (i - 1)
      atPut palette i (color v v v)
    }
  }
}

method processPLTEChunk PNGReader chunk {
  if (((byteCount chunk) % 3) != 0) {error 'wrong size palatte detected'}
  colorCount = (truncate ((byteCount chunk) / 3))
  palette = (newArray colorCount)
  for cc colorCount {
    index = (cc - 1)
    i = ((index * 3) + 1)
    atPut palette cc (color (byteAt chunk i) (byteAt chunk (i + 1)) (byteAt chunk (i + 2)))
  }
}

method processTransparencyChunk PNGReader chunk {
  s = (dataStream chunk true)
  if (colorType == 0) {
    transparency = (nextUInt16 s)
    transparency = (transparency & ((1 << bitsPerChannel) - 1))
  } (colorType == 2) {
    red = (nextUInt16 s)
    green = (nextUInt16 s)
    blue = (nextUInt16 s)
    red = (red & ((1 << bitsPerChannel) - 1))
    green = (green & ((1 << bitsPerChannel) - 1))
    blue = (blue & ((1 << bitsPerChannel) - 1))
    transparency = (array red green blue)
  } (colorType == 3) {
    index = 1
    while (not (atEnd s)) {
      alpha = (nextUInt8 s)
      c = (at palette index)
      atPut palette index (color (red c) (green c) (blue c) alpha)
      index += 1
    }
  }
}

method processBackgroundChunk PNGReader chunk {
  s = (dataStream chunk true)
  if (colorType == 3) {
    backColor = (at palette ((byteAt chunk 1) + 1))
    return
  }
  max = ((1 << bitsPerChannel) - 1)
  if (or (colorType == 0) (colorType == 4)) {
    val = (truncate (((nextUInt16 s) * 255) / max))
    backColor = (color val val val)
    return
  }
  if (or (colorType == 2) (colorType == 6)) {
    red = ((nextUInt16 s) * 255)
    green = ((nextUInt16 s) * 255)
    blue = ((nextUInt16 s) * 255)
    backColor = (color (red / max) (green / max) (blue / max))
  }
}

method processTextChunk PNGReader chunk {
  // TODO: Convert latin-1 to Unicode
  s = (dataStream chunk true)
  key = (nextNullTerminatedString s)
  val = (nextNullTerminatedString s)
  if ('script' == key) {
    script = val
  }
  ignore s key val
}

method processITextChunk PNGReader chunk {
  s = (dataStream chunk true)
  key = (nextNullTerminatedString s)
  compressionFlag = (nextUInt8 s)
  compressionMethod = (nextUInt8 s)
  lang = (nextNullTerminatedString s)
  trans = (nextNullTerminatedString s)
  val = (nextNullTerminatedString s)
  if (compressionFlag != 0) {
	val = (zlibDecode (toBinaryData val))
  }
  ignore key compressionMethod lang trans
}

method processZTextChunk PNGReader chunk {
  s = (dataStream chunk true)
  key = (nextNullTerminatedString s)
  compressionMethod = (nextUInt8 s)
  byteCount = ((byteCount chunk) - (position s))
  compressed = (nextData s byteCount)
  val = (zlibDecode compressed true)
  ignore key compressionMethod val
}

method processNonInterlaced PNGReader chunk {
  copyMethods = (array 'copyPixelsGray' nil 'copyPixelsRGB' 'copyPixelsIndexed' 'copyPixelsGrayAlpha' nil 'copyPixelsRGBA')
  copyMethod = (at copyMethods (colorType + 1))
  bitmap = (newBitmap width height)
  strm = (dataStream (zlibDecode chunk) false)
  prevScanline = (newBinaryData bytesPerScanline)
  for y height {
    filter = (nextUInt8 strm)
    thisScanline = (nextData strm bytesPerScanline)
    if (filter > 0) { filterScanline this thisScanline prevScanline filter bytesPerScanline }
    call copyMethod this (y - 1) thisScanline 0 1
    prevScanline = thisScanline
  }
  if (not (atEnd strm)) {error 'Unexpected data'}
}

method processInterlaced PNGReader chunk {
  startingCol =  (array 0 4 0 2 0 1 0)
  colIncrement = (array 8 8 4 4 2 2 1)
  rowIncrement = (array 8 8 8 4 4 2 2)
  startingRow =  (array 0 0 4 0 2 0 1)
  copyMethods = (array 'copyPixelsGray' nil 'copyPixelsRGB' 'copyPixelsIndexed' 'copyPixelsGrayAlpha' nil 'copyPixelsRGBA')
  copyMethod = (at copyMethods (colorType + 1))
  bitmap = (newBitmap width height)
  strm = (dataStream (zlibDecode chunk) false)
  prevScanline = (newBinaryData bytesPerScanline)

  for pass 7 {
    if (doPass this pass) {
      cx = (at colIncrement pass)
      sc = (at startingCol pass)
      bytesPerPass = (truncate ((((truncate ((((width - sc) + cx) - 1) / cx)) * bitsPerPixel) + 7) / 8))
      y = (at startingRow pass)
      while (y <= (height - 1)) {
        filter = (nextUInt8 strm)
		thisScanline = (nextData strm bytesPerPass)
        if (filter > 0) { filterScanline this thisScanline prevScanline filter bytesPerPass }
        call copyMethod this y thisScanline sc cx
        prevScanline = thisScanline
        y += (at rowIncrement pass)
      }
    }
  }
  if (not (atEnd strm)) {error 'Unexpected data'}
}

method doPass PNGReader pass {
  if (pass == 1) {return true}
  if (and (width == 1) (height == 1)) {return false}
  if (pass == 2) {return (width >= 5)}
  if (pass == 3) {return (height >= 5)}
  if (pass == 4) {return (or (width >= 3) (height >= 5))}
  if (pass == 5) {return (height >= 3)}
  if (pass == 6) {return (width >= 2)}
  if (pass == 7) {return (height >= 2)}
}

method copyPixelsGray PNGReader y thisScanline startX incX {
  // Handle grayscale color mode (colorType = 0)
  s = (dataStream thisScanline true)
  if (bitsPerChannel == 16) {
    x = startX
    while (not (atEnd s)) {
      d = (nextUInt16 s)
      v = ((truncate ((d * 255) / 65535)) & 255)
      if (transparency == d) {
        v = 0
        a = 0
      } else {
        a = 255
      }
      setRGBA bitmap x y v v v a
      x += incX
      if (x >= width) {return}
    }
   return
  }
  if (or (bitsPerChannel == 8) (bitsPerChannel == 4) (bitsPerChannel == 2) (bitsPerChannel == 1)) {
    x = startX
    mask = ((1 << bitsPerChannel) - 1)
    while (not (atEnd s)) {
      d = (nextUInt8 s)
      for i (8 / bitsPerChannel) {
        v = ((d >> (((8 / bitsPerChannel) - i) * bitsPerChannel)) & mask)
        if (transparency == v) {
          v = 0
          a = 0
        } else {
          v = ((v * 255) / mask)
          a = 255
        }
        setRGBA bitmap x y v v v a
        x += incX
        if (x >= width) {return}
      }
    }
  }
}

method copyPixelsRGB PNGReader y thisScanline startX incX {
  // Handle RGB color mode (colorType = 2)
  s = (dataStream thisScanline true)
  if (bitsPerChannel == 16) {
    x = startX
    while (not (atEnd s)) {
      r = (nextUInt16 s)
      g = (nextUInt16 s)
      b = (nextUInt16 s)
      if (and (notNil transparency)
              ((at transparency 1) == r)
              ((at transparency 2) == g)
              ((at transparency 3) == b)) {
        r = 0
        g = 0
        b = 0
        a = 0
      } else {
        r = ((truncate ((r * 255) / 65535)) & 255)
        g = ((truncate ((g * 255) / 65535)) & 255)
        b = ((truncate ((b * 255) / 65535)) & 255)
        a = 255
      }
      setRGBA bitmap x y r g b a
      x += incX
      if (x >= width) {return}
    }
  } (bitsPerChannel == 8) {
    x = startX
    while (not (atEnd s)) {
      r = (nextUInt8 s)
      g = (nextUInt8 s)
      b = (nextUInt8 s)
      if (and (notNil transparency)
              ((at transparency 1) == r)
              ((at transparency 2) == g)
              ((at transparency 3) == b)) {
        r = 0
        g = 0
        b = 0
        a = 0
      } else {
        a = 255
      }
      setRGBA bitmap x y r g b a
      x += incX
      if (x >= width) {return}
    }
  }
}

method copyPixelsIndexed PNGReader y thisScanline startX incX {
  // Handle indexed color mode (colorType = 3)
  s = (dataStream thisScanline true)
  if (or (bitsPerChannel == 1) (bitsPerChannel == 2)
         (bitsPerChannel == 4) (bitsPerChannel == 8)) {
    x = startX
    mask = ((1 << bitsPerChannel) - 1)
    while (not (atEnd s)) {
      d = (nextUInt8 s)
      for i (8 / bitsPerChannel) {
        v = ((d >> (((8 / bitsPerChannel) - i) * bitsPerChannel)) & mask)
        c = (at palette (v + 1))
        setRGBA bitmap x y (red c) (green c) (blue c) (alpha c)
        x += incX
        if (x >= width) {return}
      }
    }
  }
}

method copyPixelsGrayAlpha PNGReader y thisScanline startX incX {
  // Handle grayscale with alpha color mode (colorType = 4)
  s = (dataStream thisScanline true)
  if (bitsPerChannel == 16) {
    x = startX
    while (not (atEnd s)) {
      d = (nextUInt16 s)
      a = (nextUInt16 s)
      if (transparency == d) {
        v = 0
        a = 0
      } else {
        v = ((truncate ((d * 255) / 65535)) & 255)
        a = ((truncate ((a * 255) / 65535)) & 255)
      }
      setRGBA bitmap x y v v v a
      x += incX
      if (x >= width) {return}
    }
  } (bitsPerChannel == 8) {
    x = startX
    while (not (atEnd s)) {
      v = (nextUInt8 s)
      a = (nextUInt8 s)
      if (transparency == v) {
        v = 0
        a = 0
      }
      setRGBA bitmap x y v v v a
      x += incX
      if (x >= width) {return}
    }
  }
}

method copyPixelsRGBA PNGReader y thisScanline startX incX {
  // RGBA color modes (colorType = 6)
  s = (dataStream thisScanline true)
  if (bitsPerChannel == 16) {
    x = startX
    while (not (atEnd s)) {
      r = (nextUInt16 s)
      g = (nextUInt16 s)
      b = (nextUInt16 s)
      a = (nextUInt16 s)
      if (and (notNil transparency)
              ((at transparency 1) == r)
              ((at transparency 2) == g)
              ((at transparency 3) == b)) {
        r = 0
        g = 0
        b = 0
        a = 0
      } else {
        r = ((truncate ((r * 255) / 65535)) & 255)
        g = ((truncate ((g * 255) / 65535)) & 255)
        b = ((truncate ((b * 255) / 65535)) & 255)
        a = ((truncate ((a * 255) / 65535)) & 255)
      }
      setRGBA bitmap x y r g b a
      x += incX
      if (x >= width) {return}
    }
  } (bitsPerChannel == 8) {
    x = startX
    while (not (atEnd s)) {
      r = (nextUInt8 s)
      g = (nextUInt8 s)
      b = (nextUInt8 s)
      a = (nextUInt8 s)
      if (and (notNil transparency)
              ((at transparency 1) == r)
              ((at transparency 2) == g)
              ((at transparency 3) == b)) {
        r = 0
        g = 0
        b = 0
        a = 0
      }
      setRGBA bitmap x y r g b a
      x += incX
      if (x >= width) {return}
    }
  }
}

method filterScanline PNGReader thisScanline prevScanline filter count {
  // Note: These are ordered by frequency based on a collection of PNG photos.
  if (4 == filter) { filterPaeth this thisScanline prevScanline count
  } (2 == filter) { filterVertical this thisScanline prevScanline count
  } (3 == filter) { filterAverage this thisScanline prevScanline count
  } (1 == filter) { filterHorizontal this thisScanline prevScanline count
  } else {
	error 'unknown filter type' filter
  }
}

method filterHorizontal PNGReader thisScanline prevScanilne count {
  // Use the pixel to the left as a predictor
  delta = (max (truncate (bitsPerPixel / 8)) 1)
  for i count {
    if (i > delta) {
      byteAtPut thisScanline i (((byteAt thisScanline i) + (byteAt thisScanline (i - delta))) & 255)
    }
  }
}

method filterVertical PNGReader thisScanline prevScanline count {
  // Use the pixel above as a predictor
  for i count {
    byteAtPut thisScanline i (((byteAt thisScanline i) + (byteAt prevScanline i)) & 255)
  }
}


method filterAverage PNGReader thisScanline prevScanline count {
  // Use the average of the pixel to the left and the pixel above as a predictor
  delta = (max (truncate (bitsPerPixel / 8)) 1)
  for i count {
    if (i <= delta) {
	  byteAtPut thisScanline i (((byteAt thisScanline i) + (truncate ((byteAt prevScanline i) / 2))) & 255)
	} else {
      byteAtPut thisScanline i (((byteAt thisScanline i) +
                                 (truncate (((byteAt prevScanline i) + (byteAt thisScanline (i - delta))) / 2))) & 255)
    }
  }
}

method filterPaeth PNGReader thisScanline prevScanline count {
  // Use the pixel to the left, the pixel above, or the pixel to above-left to
  // predict the value of this pixel. Based on Paeth (GG II, 1991).
  delta = (max (truncate (bitsPerPixel / 8)) 1)
  for i count {
    if (i <= delta) {
	  byteAtPut thisScanline i (((byteAt thisScanline i) + (byteAt prevScanline i)) & 255)
	} else {
	  pred = (paethPredict this
		(byteAt thisScanline (i - delta))
		(byteAt prevScanline i)
		(byteAt prevScanline (i - delta)))
      byteAtPut thisScanline i (((byteAt thisScanline i) + pred) & 255)
    }
  }
}

method paethPredict PNGReader a b c {
  da = (b - c)
  db = (a - c)
  pa = (abs da)
  pb = (abs db)
  pc = (abs (da + db))
  if (and (pa <= pb) (pa <= pc)) {return a}
  if (pb <= pc) {return b}
  return c
}
defineClass PNGWriter bitmap dataStream

to encodePNG aBitmap pixelsPerInch scriptToEmbed { return (writeImage (new 'PNGWriter') aBitmap pixelsPerInch scriptToEmbed) }

method writeImage PNGWriter aBitmap pixelsPerInch scriptToEmbed {
  bitmap = aBitmap
  dataStream = (dataStream (newBinaryData ((width bitmap) * (height bitmap))) true)

  writeSignature this
  writeChunk this 'IHDR' (headerChunk this)
  if (notNil pixelsPerInch) { writeChunk this 'pHYs' (physChunk this pixelsPerInch) }
  if (notNil scriptToEmbed) { writeChunk this 'tEXt' (textChunk this scriptToEmbed) }
  writeChunk this 'IDAT' (dataChunk this)
  writeChunk this 'IEND' (newBinaryData 0)

  return (contents dataStream)
}

method writeSignature PNGWriter {
  pngSignature = (toBinaryData (array 137 80 78 71 13 10 26 10))
  nextPutAll dataStream pngSignature
}

method writeChunk PNGWriter chunkID data {
  length = (byteCount data)
  crc = (crc data false (crc chunkID))
  putUInt32 dataStream length
  nextPutAll dataStream chunkID
  nextPutAll dataStream data
  putUInt32 dataStream crc
}

method headerChunk PNGWriter {
  chunk = (dataStream (newBinaryData 20) true)
  putUInt32 chunk (width bitmap)
  putUInt32 chunk (height bitmap)
  putUInt8 chunk 8 // bitsPerChannel
  putUInt8 chunk 6 // colorType
  putUInt8 chunk 0 // compression
  putUInt8 chunk 0 // filter method
  putUInt8 chunk 0 // interface method
  return (contents chunk)
}

method physChunk PNGWriter pixelsPerInch {
  inchesPerMeter = 39.3700787
  pixelsPerMeter = (round (pixelsPerInch * inchesPerMeter))
  chunk = (dataStream (newBinaryData 20) true)
  putUInt32 chunk pixelsPerMeter
  putUInt32 chunk pixelsPerMeter
  putUInt8 chunk 1 // unit is meters
  return (contents chunk)
}

method dataChunk PNGWriter {
  width = (width bitmap)
  height = (height bitmap)
  pixels = (getField bitmap 'pixelData')
  widthBytes = (width * 4)
  scanLineBytes = (widthBytes + 1)
  dst = (newBinaryData (height * scanLineBytes))
  for yy height {
	y = (yy - 1)
	offset = ((y * scanLineBytes) + 2)
	replaceByteRange dst offset ((offset + widthBytes) - 1) pixels ((y * widthBytes) + 1)
	for x width {
	  tmp = (byteAt dst offset)
	  byteAtPut dst offset (byteAt dst (offset + 2))
	  byteAtPut dst (offset + 2) tmp
	  offset += 4
	}
  }
  compressed = (zlibEncode dst)
  return compressed
}

method textChunk PNGWriter aString {
  // Embed a tEXt chunk into the PNG data. Useful for storing actual scripts
  // into script images :)
  chunk = (dataStream (newBinaryData (7 + (count aString))) true)
  nextPutAll chunk 'script'
  putUInt8 chunk 0
  nextPutAll chunk aString
  return (contents chunk)
}
defineClass PaintEditor morph window saveAction canvas brushButton eraseButton bucketButton colorButton sizeButton

// To do:
//  [ ] set color (use a color swatch?)
//  [ ] set pen/eraser size
//  [ ] update pen/eraser display when size/color/mode changes
//  [ ] crop image when saving?
//  [ ] center image on canvas when editing
//  [ ] deal with rotation center
//  [ ] revert (or undo/redo?)
//  [ ] round pen
//  [ ] make system windows stay at page level when dropped on ProjectEditor
//  [ ] tweak window resize handle offset
//  [x] edit command in images tab
//  [x] save
//  [x] put in a system window

// addPart (global 'page') (morph (initialize (new 'PaintEditor')))

to openPaintEditorOn aBitmap actionOnSave {
  paintEditor = (initialize (new 'PaintEditor') aBitmap actionOnSave)
  pageM = (morph (global 'page'))
  gotoCenterOf (morph paintEditor) pageM
  addPart pageM (morph paintEditor)
  return paintEditor
}

method initialize PaintEditor originalImg actionOnSave {
  scale = (global 'scale')
  window = (window 'Interim Paint Editor')
  morph = (morph window)
  setHandler morph this
  setClipping morph true
  canvas = (initialize (new 'PaintEditorCanvas') 800 500)
  setPosition (morph canvas) (80 * scale) (35 * scale)
  addPart morph (morph canvas)
  setContents canvas originalImg
  setMinExtent morph (898 * scale) (570 * scale)
  setExtent morph (898 * scale) (570 * scale)
  addModeButtons this
  addSaveCancelButtons this
  saveAction = actionOnSave
  setMode this 'paintBrush' brushButton
  setBrushSize this (5 * scale)
  return this
}

// construction

method addModeButtons PaintEditor {
  scale = (global 'scale')
  buttonX = ((left morph) + (22 * scale))
  buttonY = ((top morph) + (35 * scale))
  dy = (50 * scale)
  brushButton = (addIconButton this buttonX buttonY 'paintBrush' (action 'setMode' this 'paintBrush'))
  buttonY += dy
  eraseButton = (addIconButton this buttonX buttonY 'eraser' (action 'setMode' this 'eraser'))
  buttonY += dy
  bucketButton = (addIconButton this buttonX buttonY 'paintBucket' (action 'setMode' this 'paintBucket'))
  buttonY += (70 * scale)
  colorButton = (addIconButton this buttonX buttonY 'chooseColor' (action 'chooseColor' this))
  buttonY += dy
  sizeButton = (addIconButton this buttonX buttonY 'brushSize' (action 'brushSizeMenu' this))
}

method addIconButton PaintEditor x y iconName action {
  scale = (global 'scale')
  size = (40 * scale)
  iconBM = (scaleAndRotate (call iconName (new 'PaintEditorIcons')) scale)
  button = (newButton '' action)
  setLabel button iconBM (gray 160) (gray 240) size size
  setPosition (morph button) x y
  addPart morph (morph button)
  return button
}

method addSaveCancelButtons PaintEditor {
  scale = (global 'scale')
  buttonX = ((right morph) - (20 * scale))
  buttonY = ((bottom morph) - (25 * scale))
  dx = (-10 * scale)

  b = (textButton this 0 0 'Save' 'saveAndClose')
  buttonX += (0 - (width (morph b)))
  setPosition (morph b) buttonX buttonY

  b = (textButton this 0 0 'Cancel' (action 'destroy' morph))
  buttonX += (dx - (width (morph b)))
  setPosition (morph b) buttonX buttonY
}

method textButton PaintEditor x y label selectorOrAction {
  if (isClass selectorOrAction 'String') {
	selectorOrAction = (action selectorOrAction this)
  }
  result = (pushButton label (gray 130) selectorOrAction)
  setPosition (morph result) x y
  addPart morph (morph result)
  return result
}

// actions

method saveAndClose PaintEditor {
  scale = (global 'scale')
  bm = (contents canvas)
  cropped = (cropTransparent bm)
  if (1 != scale) {
	cropped = (scaleAndRotate cropped (1.0 / scale))
  }
  setName cropped (name bm)
  if (notNil saveAction) { call saveAction cropped }
  removeFromOwner morph
}

method setMode PaintEditor newMode button {
  setOn brushButton false
  setOn bucketButton false
  setOn eraseButton false
  setOn button true
  setMode canvas newMode
  updateBrushButton this
}

method chooseColor PaintEditor button {
  colorPicker = (newColorPicker (action 'setPaintColor' this) (color canvas))
  addPart (global 'page') (morph colorPicker)
}

method setPaintColor PaintEditor newColor {
  setColor canvas newColor
  updateBrushButton this
}

method brushSizeMenu PaintEditor button {
  menu = (menu 'Brush size:' (action 'setBrushSize' this) true)
  for item (array 1 2 3 4 5 7 10 15 20 30 40 60 90 120 160) {
	addItem menu item
  }
  popUpAtHand menu (global 'page')
}

method setBrushSize PaintEditor newSize {
  setLineWidth (pen canvas) (2 * newSize)
  updateBrushButton this
}

method updateBrushButton PaintEditor {
  scale = (global 'scale')
  radius = (13 * scale)
  c = (color canvas)
  if ('eraser' == (mode canvas)) { c = (gray 250) }
  textColor = (gray 0)
  if ((brightness c) < 0.85) { textColor = (gray 255) }
  bm = (newBitmap (2 * radius) (2 * radius))
  drawCircle (newShapeMaker bm) radius radius radius c
  setFont 'Arial Bold' (13 * scale)
  sizeLabel = (toString (half (lineWidth (pen canvas))))
  drawString bm sizeLabel textColor (radius - (half (stringWidth sizeLabel))) (6 * scale)
  b = sizeButton
  setLabel b bm (gray 160) (gray 240) (width (morph b)) (height (morph b))
}

// drawing

method redraw PaintEditor {
  fixLayout window
  drawFrame this
}

method drawFrame PaintEditor {
  scale = (global 'scale')
  cornerRadius = (4 * scale)
  fillColor = (gray 200)
  borderW = (6 * scale)
  borderColor = (gray 80)
  w = (width morph)
  h = (height morph)
  bm = (newBitmap w h)
  pen = (newVectorPen bm)
  fillRoundedRect pen (rect 0 0 w h) cornerRadius fillColor borderW borderColor
  fillRoundedRect pen (rect 0 12 w (18 * scale)) 0 borderColor 0 borderColor
  drawCheckboard this bm
  setCostume morph bm
}

method drawCheckboard PaintEditor bm {
  squareSize = (4 * (global 'scale'))
  canvasRect = (translatedBy (bounds (morph canvas)) (- (left morph)) (- (top morph)))

  // fill with white
  fillRect bm (gray 255) (left canvasRect) (top canvasRect) (width canvasRect) (height canvasRect)

  // draw dark squares
  lineStartsDark = false
  y = (top canvasRect)
  while ((y + squareSize) <= (bottom canvasRect)) {
	isDark = lineStartsDark
	x = (left canvasRect)
	while ((x + squareSize) <= (right canvasRect)) {
	  if isDark {
		fillRect bm (gray 240) x y squareSize squareSize
	  }
	  isDark = (not isDark)
	  x += squareSize
	}
	lineStartsDark = (not lineStartsDark)
	y += squareSize
  }
}

defineClass PaintEditorCanvas morph bitmap pen paintColor mode lastX lastY undoHistory

method initialize PaintEditorCanvas w h {
  scale = (global 'scale')
  bitmap = (newBitmap (w * scale) (h * scale) (gray 250))
  morph = (newMorph this)
  setTransparentTouch morph true
  setGrabRule morph 'ignore'
  setCostume morph bitmap
  pen = (newPen bitmap)
  paintColor = (color 0 0 200)
  undoHistory = (list)
  mode = 'paintBrush'
  return this
}

method color PaintEditorCanvas { return paintColor }
method setColor PaintEditorCanvas color { paintColor = color }
method contents PaintEditorCanvas { return bitmap }
method mode PaintEditorCanvas { return mode }
method setMode PaintEditorCanvas newMode { mode = newMode }
method pen PaintEditorCanvas { return pen }

method setContents PaintEditorCanvas img {
  scale = (global 'scale')
  fill bitmap (transparent)
  if (notNil img) {
	if (1 == scale) {
	  scaled = img
	} else {
	  scaled = (scaleAndRotate img scale)
	}
	x = (max 0 (half ((width bitmap) - (width scaled))))
	y = (max 0 (half ((height bitmap) - (height scaled))))
	drawBitmap bitmap scaled x y
	setName bitmap (name img)
  }
  costumeChanged morph
}

// events

method handDownOn PaintEditorCanvas hand {
  if ('paintBucket' == mode) {
	fillArea this hand
	return true
  }
  up pen
  movePenToHand this hand
  if ('eraser' == mode) {
	setColor pen (transparent)
  } else {
	setColor pen paintColor
  }
  down pen
  focusOn hand this
  return true
}

method handMoveFocus PaintEditorCanvas hand {
  movePenToHand this hand
}

method movePenToHand PaintEditorCanvas hand {
  p = (normal morph (x hand) (y hand))
  newX = (toInteger ((first p) + ((normalWidth morph) / 2)))
  newY = (toInteger ((last p) + ((normalHeight morph) / 2)))
  goto pen newX newY
  costumeChanged morph
}

method fillArea PaintEditorCanvas hand {
  p = (normal morph (x hand) (y hand))
  seedX = (toInteger ((first p) + ((normalWidth morph) / 2)))
  seedY = (toInteger ((last p) + ((normalHeight morph) / 2)))
  floodFill bitmap seedX seedY paintColor
  costumeChanged morph
}

defineClass PaintEditorIcons

method chooseColor PaintEditorIcons {
  data = '
iVBORw0KGgoAAAANSUhEUgAAABUAAAASCAYAAAC0EpUuAAAAAXNSR0IArs4c6QAAAVlpVFh0WE1MOmNv
bS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9
IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8x
OTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9
IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgog
ICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpE
ZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KTMInWQAAAilJREFUOBGFlItOwzAM
Rd2tMBggHkLw/5/BDyHWPQpsLWzQlnOdhL1BmyU3cU99bSdZ+/zU2o3Z8szs1dY2t9w6u2aFTTf8RT8E
lCy9mZ1/mEfcxohLa3wjt+XYrPW/LVlaYHqndGiHd4INzTr8b1xA9o5NWK3NMlzysUus45fZijc/C9MH
4P5CZ/gTYC3bDvR8gH7xCMihU7OrudmARwG1JawF6MihSvwTI84zHdkp0HOeVIIVtpMp0BWSBJR8idiA
7mdKvI0R1TjwnidB0bIjvyFQQFUkQKVX8ndqmjIN0DuCKg/cqilNUk077AE3QfdqmuSrUappgfTGHvEi
dFO+oGSZIVJugh6VnzIt7AKohuwAVN0HmgOVuw89Kr/+FzpgGg9CPyoyYUxqPqecZCpBhdzGPT0R0GAV
w58CWF7gh9iwXBPXx/JxlDJhgt+ZZEnZnLkwmJShoSslQ6d4nRKaoD7I1ZIOzJhP9ClZXkTo9DQUnXx8
PNTJgFdqgqJ1xq6KroGOpzDNdmhuFaFxPCYoO9TJIIwdQcuodydTlUCZFi7/bZ1pifTjUF5pkT+jRn9k
OkRCT7eG15T4V+SoppKvmgb5OklRfsv8TDm2SutApjqFAzrSU01fYk0XkORuz5zwEdoBLCn8kUwlv88R
zQT1TLlqar4u+alR6XT8dr/jCiyxBI3d32xUh0aHevd7NBRaynRfPjANw5yrMMmP3VcltKRL8ou5EfQH
SfiMVe7b97UAAAAASUVORK5CYII='
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method eraser PaintEditorIcons {
  data = '
iVBORw0KGgoAAAANSUhEUgAAABkAAAASCAYAAACuLnWgAAAAAXNSR0IArs4c6QAAAVlpVFh0WE1MOmNv
bS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9
IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8x
OTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9
IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgog
ICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpE
ZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KTMInWQAAASxJREFUOBGdVCGShDAQ
HE7lHBKLRCJjkUgkFolEYpFIvoDkCfyHHxxujoYim90qkslOFQVFetLT05NEFByKQ1K0zkPgRHVdc1EU
LA0ixWma8o+UJo5j3raN1nUVpUTRLzH/UZIkIjxprbltW6mAEztN04nPsszfXhDkeS4mOCrnYRgMHh1w
SgGg6zqT4PsAwbIsBgYVSjkGpaqqIJMxEE3TGIK+7xl7PKqAgtApGsfxjQCT9UgAD0JahGJsgrIszwIf
CZAAEmnAA7sgTBT+PRLAJHsqfETYbJ5nA0P/nQSoHj2UBlryaTK68KjgMggmyR9bAdrlNPliliuAUlvx
PeYOBffSdyQ4dLj87l0873ASnOLLR8/Wr+VwEtGl9yKgSGCaBT/Qimjf9yNPHv8WUzPBF5/BMAAAAABJ
RU5ErkJggg=='
  return (readFrom (new 'PNGReader') (base64Decode data))
}


method paintBrush PaintEditorIcons {
  data = '
iVBORw0KGgoAAAANSUhEUgAAABsAAAARCAYAAAAsT9czAAAAAXNSR0IArs4c6QAAAVlpVFh0WE1MOmNv
bS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9
IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8x
OTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9
IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgog
ICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpE
ZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KTMInWQAAAP9JREFUOBHNVD0PgyAQ
xcahY9nsqBtu7ebaEX+vbP0LXd1krBsdu9k+kzOINC2GNF5C4A7u3ruPkLBIIqUc2lvLunu3iFjXNTPG
LOyrDADKs3zwCe6wVgV2nTYBdBLiPxmhpNFKB9afehQdCGA+2RRQ6k6XrYOprT/M01anc3EsmDgLppRK
JmPIwVcq2Fw79F+HwcsEGfl+ApA9lyWjDLM8Y5zzuBnRMIAEraqqZiUOqdr4Vl4kxV3sBEJ7cPC3w46c
wLS5NqTOdgxADBl7Bra+HrkgmDj87LrX3l5/I5QCCI/cwLYjBqHX/WhaCwTn9MD303TZAO4ZIFpp1xyk
vwDHG1SI5cichgAAAABJRU5ErkJggg=='
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method paintBucket PaintEditorIcons {
  data = '
iVBORw0KGgoAAAANSUhEUgAAABYAAAAZCAYAAAA14t7uAAAAAXNSR0IArs4c6QAAAVlpVFh0WE1MOmNv
bS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9
IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8x
OTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9
IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgog
ICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpE
ZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KTMInWQAAAO5JREFUSA2t1dsOwiAM
BmAwu8D3f1h3h6vwh1LbUqYkhqNfC26Y07KUOpacebR/anGUINm/hVuINT4Heczd//U24Vi2lN4GXGqt
r/CWgrBE15kHYImm1DL38cPf2zeK9YTn/DSfcTfj1ZnO87QDfMwfz84UGaOecYyWqmS8Rq8jgPCpNVy8
+z5KIBDeRhQekGXso/iyVyMorekZx1FkxREEw1yH4ygAreYozbOj0JbHxho639UXfGYZLca1VRpKMz3j
e7iFMpiae7iHCjiOr1AFXuMR1IBtPIrSsZLiFHrGW4n9Q/t3tAg0rkIx4Xbf1i9wePyJEZEAAAAASUVO
RK5CYII='
  return (readFrom (new 'PNGReader') (base64Decode data))
}

method brushSize PaintEditorIcons {
  bm = (newBitmap 26 26)
  drawCircle (newShapeMaker bm) 13 13 13 (gray 80)
  return bm
}
// PanePacker - handles layout of multi-pane windows

defineClass PanePacker rect border allPanes

to newPanePacker rect innerBorder outerBorder {
  if (isNil innerBorder) { innerBorder = 2 }
  if (isNil outerBorder) { outerBorder = 0 }
  scale = (global 'scale')
  result = (new 'PanePacker')
  setField result 'rect' (insetBy rect (outerBorder * scale))
  setField result 'border' (innerBorder * scale)
  setField result 'allPanes' (dictionary)
  return result
}

// Pane layout

method packPanesH PanePacker panesAndWidthSpecs... {
  scale = (global 'scale')
  panes = (list)
  widths = (list)
  spaceAvailable = (width rect)
  for i (range 2 (argCount) 2) {
    add panes (arg i)
    w = (arg (i + 1)) // a number for fixed space, "NN%" for percent, 'rest' for what's left, 'done' or an Action
    if (isNumber w) {
      w = (scale * (max 0 (toInteger w)))
      spaceAvailable = (spaceAvailable - w)
    }
    add widths w
  }

  spaceAvailable += (- (border * ((count panes) - 1)))
  x = (left rect)
  for i (count panes) {
    w = (at widths i)
    if (isClass w 'String') {
      if (w == 'rest') {
        w = ((right rect) - x)
      } (w == 'done') {
        noop // ignore
      } else {
        w = (percentOfSpace this w spaceAvailable)
      }
    } (isClass w 'Action') {
      w = (call w spaceAvailable)
    }
    pane = (at panes i)
    paneMorph = (morph pane)
    if (w == 'done') {
      x += (border + (width paneMorph))
    } else {
	  w = (max w 0)
      fastSetLeft paneMorph x
      setWidth (bounds paneMorph) w
      if (isClass pane 'Text') { setMinWidth pane w }
      x += (w + border)
    }
  }
  addAll allPanes panes
}

method packPanesV PanePacker panesAndHeightSpecs... {
  scale = (global 'scale')
  panes = (list)
  heights = (list)
  spaceAvailable = (height rect)
  for i (range 2 (argCount) 2) {
    add panes (arg i)
    h = (arg (i + 1)) // // a number for fixed space, "NN%" for percent, 'rest' for what's left, 'done' or an Action
    if (isNumber h) {
      h = (scale * (max 0 (toInteger h)))
      spaceAvailable = (spaceAvailable - h)
    }
    add heights h
  }

  spaceAvailable += (- (border * ((count panes) - 1)))
  y = (top rect)
  for i (count panes) {
    h = (at heights i)
    if (isClass h 'String') {
      if (h == 'rest') {
        h = ((bottom rect) - y)
      } (h == 'done') {
        noop // ignore
      } else {
        h = (percentOfSpace this h spaceAvailable)
      }
    } (isClass h 'Action') {
      h = (call h spaceAvailable)
    }
    pane = (at panes i)
    paneMorph = (morph pane)
    if (h == 'done') {
      y += (border + (height paneMorph))
    } else {
	  h = (max h 0)
      fastSetTop paneMorph y
      setHeight (bounds paneMorph) h
      if (isClass pane 'Text') { setMinHeight pane h }
      y += (h + border)
    }
  }
  addAll allPanes panes
}

method percentOfSpace PanePacker percent total {
  letters = (letters percent)
  if ((last letters) != '%') { error 'Size string should be a percentage such as "50%"' }
  s = (joinStringArray (copyArray letters ((count letters) - 1)))
  return (truncate (((toInteger s) * total) / 100))
}

method finishPacking PanePacker {
  for pane (keys allPanes) {
	bnds = (bounds (morph pane))
	setExtent (morph pane) (width bnds) (height bnds)
  }
}
defineClass PaneResizer morph target orientation isHighlit offsetX offsetY

to newPaneResizer aMorph orientationType {
	return (initialize (new 'PaneResizer') aMorph orientationType)
}

method initialize PaneResizer targetMorph orientationType {
	if (isNil orientationType) { orientationType = 'horizontal' }
	morph = (newMorph this)
	setGrabRule morph 'ignore'
	target = targetMorph
	orientation = orientationType
	isHighlit = false
	offsetX = 0
	offsetY = 0
	return this
}

method drawOn PaneResizer ctx {
	if isHighlit {
		c = (color 180 180 255 150)
		fillRect ctx c (left morph) (top morph) (width morph) (height morph)
	}
}

method handEnter PaneResizer aHand {
	if (isBusy aHand) { return }
	if (orientation == 'horizontal') {
		setCursor 'ew-resize'
	} (orientation == 'vertical') {
		setCursor 'ns-resize'
	}
	isHighlit = true
	changed morph
}
method handLeave PaneResizer aHand {
	setCursor 'default'
	isHighlit = false
	changed morph
}

method clicked PaneResizer { return true }
method rightClicked PaneResizer { return true }

method handDownOn PaneResizer aHand {
	focusOn aHand this
	offsetX = ((x aHand) - (left morph))
	offsetY = ((y aHand) - (top morph))

	scripter = (ownerThatIsA morph 'MicroBlocksScripter')
	if (notNil scripter) { hideScrollbars (handler scripter) }
	return true
}

method handUpOn PaneResizer aHand {
	scripter = (ownerThatIsA morph 'MicroBlocksScripter')
	if (notNil scripter) { showScrollbars (handler scripter) }
	return true
}

method handMoveFocus PaneResizer aHand {
	scale = (global 'scale')
	newX = ((x aHand) - offsetX)
	newY = ((y aHand) - offsetY)
	owner = (owner morph)
	if (notNil owner) {
		newX = (clamp newX (left owner) ((right owner) - (25 * scale)))
		newY = (clamp newY (top owner) ((bottom owner) - (25 * scale)))
	}

	if (orientation == 'horizontal') {
		fastSetLeft morph newX
		if (notNil target) { setWidthToRight target morph }
	} (orientation == 'vertical') {
		fastSetTop morph newY
		if (notNil target) { setHeightToBottom target morph }
	}
}
// Experimental GP PartsBin
//

defineClass PartsBin morph project window listBox listPane titleBox thumbnailPane buttonsPane notePane location selection directory projectNames

to newPartsBin loc proj {
  return (initialize (new 'PartsBin') loc proj)
}

to openPartsBin loc {
  page = (global 'page')
  editor = (findProjectEditor)
  proj = (project editor)
  partsBin = (newPartsBin loc proj)
  addPart page partsBin
  doRefresh partsBin
  setPosition (morph partsBin) (x (hand page)) (y (hand page))
  keepWithin (morph partsBin) (bounds (morph page))
  return partsBin
}

method initialize PartsBin loc proj {
  if (isNil loc) {
    conf = (gpServerConfiguration)
    if (notNil conf) {
      user = (at conf 'username')
      serverDirectory = (at conf 'serverDirectory')
      account = (at conf 'account')
      accountPassword = (at conf 'accountPassword')
      m = (loadModule 'modules/DAVDirectory.gpm')
      loc = (join serverDirectory user '/')
      directory = (new (at m 'DAVClient'))
      setUser directory account
      setPassword directory accountPassword
    }
  }
  if (isNil loc) {
     loc = 'projects/'
  }

  location = loc
  project = proj

  scale = (global 'scale')
  window = (window 'PartsBin')
  morph = (morph window)
  setHandler morph this

  buttonsPane = (newBox (newMorph nil) (gray 10 10 10) nil nil false false)
  addPart (morph buttonsPane) (makeButton this 'Load' 'doLoad')
  addPart (morph buttonsPane) (makeButton this 'Refresh' 'doRefresh')
  addPart morph (morph buttonsPane)

  titleBox = (newText)
  setEditRule titleBox 'static'
  setColor titleBox (color 0 0 0) nil (color 255 255 255)
  addPart morph (morph titleBox)

  setText titleBox location

  listBox = (listBox (array) 'name' (action 'select' this) (color 255 255 255))
  setFont listBox 'Arial' 14
 
  listPane = (scrollFrame listBox (clientColor window))

  addPart morph (morph listPane)

  thumbnailPane = (newBox (newMorph nil) (gray 250) nil nil false false)

  text = (newText)
  setFont text 'Arial' (14 * scale)
  //setEditRule text 'static'
  notePane = (scrollFrame text (color 255 255 255))

  addPart morph (morph thumbnailPane)
  addPart morph (morph notePane)

  setMinExtent morph (scale * 600) (scale * 400)
  setExtent morph (scale * 600) (scale * 400)

  fixLayout this
  return this
}

method isNetworkRepository PartsBin {
  return (and (notNil directory) (beginsWith location 'http'))
}

method listOfProjectNames PartsBin {
  if (isNetworkRepository this) {
    projectNames = (listFiles directory location)
  } else {
    projectNames = (listFiles location)
  }
  result = (list)
  for i (count projectNames) {
    elem = (at projectNames i)
    if ((count elem) > 0) {// ???
      add result elem
    }
  }
  projectNames = result
  return projectNames
}

method updateSelection PartsBin {
 scale = (global 'scale')
 if (isNil selection) {
    setText (contents notePane) ''
  }
  str = (notes selection location)
  if ((classOf str) == (class 'String')) {
    setText (contents notePane) str
  }

  loc = (fullPathIn selection location)
  setText titleBox loc

  thumb = (thumbnail selection loc)
  if (notNil thumb) {
    t = (thumbnail thumb ((400 - 40) * scale) ((300 - 40) * scale))
    setCostume (morph thumbnailPane) t
  } else {
    setCostume (morph thumbnailPane) nil
  }
  fixLayout this
}

method refreshContents PartsBin listOfProjectNames {
  // make a dictionary mapping projectNames to their icons
  oldIcons = (dictionary)
  for p (collection listBox) {
	icon = p
	atPut oldIcons (name icon) icon
  }

  // make a dictionary mapping instances to their icons
  newCollection = (list)
  for each listOfProjectNames {
	icon = (at oldIcons each)
	if (isNil icon) {
	  icon = (initialize (new 'PartsItem') each (action 'select' this each) this)
	}
	add newCollection icon
  }
  setCollection listBox newCollection
  fixLayout this
  gc
}

method makeButton PartsBin label selector {
  if (isClass selector 'String') {
	selector = (action selector this)
  }
  button = (pushButton label (color 130 130 130) selector)
  return (morph button)
}

method doRefresh PartsBin {
  safelyRun (action 'listOfProjectNames' this)
  refreshContents this projectNames
}

method doLoad PartsBin {
  if (isNil selection) {return}

  cacheProject selection location
  importExtension project nil (project selection)
  developerModeChanged (findProjectEditor) // update palette
}

// Layout

method redraw PartsBin {
  fixLayout this
  redraw window
}

method fixLayout PartsBin {
  scale = (global 'scale')
  fixLayout window
  area = (clientArea window)
  w = (width area)
  h = (height area)

  setExtent (morph buttonsPane) 200 40
  setPosition (morph buttonsPane) (left area) (top area)
  fixTitleLayout this

  setExtent (morph listPane) (w * 0.3) (h - 40)
  setPosition (morph listPane) (left area) ((top area) + 40)

  th = (((300 - 40) * scale) + 20)
  setExtent (morph thumbnailPane) ((w * 0.7) - 8) th
  ll = ((((w * 0.7) - 4) - ((400 - 40) * scale)) / 2.0)
  setPosition (morph thumbnailPane) (((left area) + (w * 0.3)) + ll) (((top area) + 40) + 10)

  setExtent (morph notePane) ((w * 0.7) - 8) (((h - th) - 40) - 8)
  setPosition (morph notePane) (((left area) + (w * 0.3)) + 4) ((((top area) + th) + 40) + 4)
  wrapLinesToWidth (contents notePane) (max 100 (((w * 0.7) - 8) - 16))
}

method fixTitleLayout PartsBin {
  area = (clientArea window)
  buttons = (parts (morph buttonsPane))

  r = (bounds (morph buttonsPane))
  y = (((height r) / 2) + (top r))
  extraW = (width r)
  for b buttons { extraW += (- (width b)) }
  interButtonSpace = (max 5 (extraW / ((count buttons) + 1)))

  x = (+ (left r) interButtonSpace 1)
  for b buttons {
    setLeft b x
    x += ((width b) + interButtonSpace)
    setYCenter b y
  }

  setExtent (morph titleBox) ((width area) - (width r)) 40
  setMinWidth titleBox ((((width area) - (width r)) - 10) - 100)
  setPosition (morph titleBox) ((right r) + 100) (top r)
}

method select PartsBin anObject {
  selection = anObject
  updateSelection this
}

method isSelected PartsBin aPartsItem {
  if (isNil selection) {return false}

  return ((name selection) == (name aPartsItem))
}

method selection PartsBin {return selection}

// PartsItem - a list item to represent a part
// name is a project name in string (from the file name for now...) 
// if project is loaded, project is filled in as a cache

defineClass PartsItem name toggle project

method project PartsItem { return project }
method name PartsItem { return name }

method fullPathIn PartsItem location {
  return (join location name)
}

method cacheProject PartsItem location {
  if (isNil project) {
    project = (new 'Project')
    data = (readData project (fullPathIn this location))
    project = (readProject project data)
  }
}

method notes PartsItem location {
  cacheProject this location
  return (notes project)
}

method thumbnail PartsItem location {
  cacheProject this location
  return (thumbnail project)
}

method initialize PartsItem aString onSelect list {
  if (isNil onSelect) {onSelect = 'nop'}
  name = aString
  query = (action 'isSelected' list this)
  toggle = (createToggle this onSelect query aString)
  return this
}

method createToggle PartsItem onSelect query aString {
  scale = (global 'scale')
  clr = (color 255 0 0)
  clr2 = (color 0 255 0)
  size = (scale * 46)
  corner = (scale * 3)
  border = scale

  trigger = (new 'Trigger' nil onSelect)
  m = (newMorph)
  setMorph trigger m
  setWidth (bounds m) size
  setHeight (bounds m) size
  tg = (new 'Toggle' m trigger query 'handEnter')
  setHandler m tg
  refresh tg
  return tg
}

method refresh PartsItem {refresh toggle}
// Pen - Turtle graphics and simple drawing on a drawing surface using fillRect.

defineClass Pen canvas color size xPos yPos heading isDown

to newPen canvas {
  return (new 'Pen' canvas (color) 1 0 0 0.0 false)
}
method canvas Pen {return canvas}
method setCanvas Pen aBitmap {canvas = aBitmap}

// pen color and thickness

method alpha Pen {return (alpha color)}
method color Pen {return color}
method lineWidth Pen {return size}

method setAlpha Pen a {setAlpha color a}
method setColor Pen aColor {color = aColor}
method setLineWidth Pen aNumber {size = (max 1 (round aNumber))}

// pen up/down

method isDown Pen {return isDown}
method down Pen {isDown = true}
method up Pen {isDown = false}

// position and motion

method x Pen {return xPos}
method y Pen {return yPos}
method setX Pen num {xPos = num}
method setY Pen num {yPos = num}

method goto Pen newX newY {
  if isDown {
	drawLine this xPos yPos newX newY
  }
  xPos = newX
  yPos = newY
}

method move Pen n {
  newX = (xPos + (n * (cos heading)))
  newY = (yPos + (n * (sin heading)))
  goto this newX newY
}

// direction

method direction Pen {return heading}
method setDirection Pen num {heading = (num % 360)}
method turn Pen degrees {setDirection this (heading + degrees)}

method turnTo Pen x y {
  deltaX = ((toFloat x) - (toFloat xPos))
  deltaY = ((toFloat y) - (toFloat yPos))
  setDirection this (atan deltaY deltaX)
}

// line drawing

method drawLine Pen x0 y0 x1 y1 {
  usePrimitive = (and (1 == size) (255 == (alpha color)) (isClass canvas 'Bitmap'))
  if usePrimitive {
    drawLineOnBitmap canvas x0 y0 x1 y1 color size false
    return
  }
  x0 = (truncate x0)
  y0 = (truncate y0)
  x1 = (truncate x1)
  y1 = (truncate y1)

  // check for vertical and horizontal layout
  if (and (size == 1) (or (x0 == x1) (y0 == y1))) {
    lx = (min x0 x1)
    rx = (max x0 x1)
    ty = (min y0 y1)
    by = (max y0 y1)
    fillRect this lx ty (max 1 (rx - lx)) (max 1 (by - ty))
    return
  }

  // Bresenham's algorithm
  dx = (abs (x1 - x0))
  dy = (abs (y1 - y0))
  if (x0 < x1) {sx = 1} else {sx = -1}
  if (y0 < y1) {sy = 1} else {sy = -1}
  err = (dx - dy)
  while true {
    plot this x0 y0
    if (and (x0 == x1) (y0 == y1)) {return}
    e2 = (2 * err)
    if (e2 > (0 - dy)) {
      err = (err - dy)
      x0 = (x0 + sx)
    }
    if (and (x0 == x1) (y0 == y1)) {
      plot this x0 y0
      return
    }
    if (e2 < dx) {
      err = (err + dx)
      y0 = (y0 + sy)
    }
  }
}

method plot Pen x y {
  if (size > 1) {
    s2 = (size / 2)
    x = (x - s2)
    y = (y - s2)
  }
  fillRect canvas color x y size size
}

// arrow support for showing links

method drawArrow Pen startX startY endX endY arrowColor noArrowHead {
  oldColor = color
  if (notNil arrowColor) { color = arrowColor } else { color = (gray 0) }
  scale = (global 'scale')
  headAngle = 25
  headLength = (10 * scale)
  if (noArrowHead == true) { headLength = 0 }

  if (notNil canvas) {
	drawVectorArrow this startX startY endX endY headAngle headLength
  } else {
	// draw a dotted line directly onto the display buffer
	drawDottedArrow this startX startY endX endY headAngle headLength
  }
  color = oldColor
}

method drawVectorArrow Pen startX startY endX endY headAngle headLength {
  scale = (global 'scale')
  vecPen = (newVectorPen canvas)
  beginPath vecPen startX startY
  goto vecPen endX endY
  if (headLength > 0) {
	angle = (atan (startY - endY) (startX - endX))
	turn vecPen (angle + headAngle)
	forward vecPen headLength
	forward vecPen (0 - headLength)
	turn vecPen (-2 * headAngle)
	forward vecPen headLength
  }
  stroke vecPen (gray 255) (2 * scale) 1 1 // thick white arrow
  stroke vecPen (gray 0) (0.5 * scale) 1 1 // thinner black arrow inside it
}

method drawDottedArrow Pen startX startY endX endY headAngle headLength {
  size = (global 'scale') // pen width
  drawDottedLine this startX startY endX endY
  if (headLength > 0) {
	a0 = (atan (startY - endY) (startX - endX))
	a1 = (a0 - headAngle)
	a2 = (a0 + headAngle)
	drawDottedLine this endX endY (endX + (headLength * (cos a1))) (endY + (headLength * (sin a1)))
	drawDottedLine this endX endY (endX + (headLength * (cos a2))) (endY + (headLength * (sin a2)))
  }
}

method drawDottedLine Pen x0 y0 x1 y1 {
  x0 = (truncate x0)
  y0 = (truncate y0)
  x1 = (truncate x1)
  y1 = (truncate y1)

  white = (gray 255)
  c = color

  // Bresenham's algorithm
  dx = (abs (x1 - x0))
  dy = (abs (y1 - y0))
  if (x0 < x1) {sx = 1} else {sx = -1}
  if (y0 < y1) {sy = 1} else {sy = -1}
  err = (dx - dy)
  while true {
	fillRect canvas c x0 y0 size size
    if (and (x0 == x1) (y0 == y1)) {return}
    e2 = (2 * err)
    if (e2 > (0 - dy)) {
      err = (err - dy)
      x0 = (x0 + sx)
    }
    if (and (x0 == x1) (y0 == y1)) {
	  fillRect canvas c x0 y0 size size
      return
    }
    if (e2 < dx) {
      err = (err + dx)
      y0 = (y0 + sy)
    }
    if (c == white) { c = color } else { c = white }
  }
}

// circles

method drawCircle Pen centerX centerY radius fillColor border borderColor {
  if (notNil fillColor) {
	fillCircle this centerX centerY radius fillColor
  }
  if (notNil borderColor) {
	oldSize = size
	oldColor = color
	size = (max 1 (round border))
	color = borderColor
	strokeCircle this centerX centerY radius
	size = oldSize
	color = oldColor
  }
}

method strokeCircle Pen x0 y0 radius {
  f = (1 - radius)
  ddf_x = 1
  ddf_y = (-2 * radius)
  x = 0
  y = radius
  plot this x0 (y0 - radius) // top
  plot this x0 (y0 + radius) // bottom
  plot this (x0 - radius) y0 // left
  plot this (x0 + radius) y0 // right
  while (x < y) {
    if (f >= 0) {
      y += -1
      ddf_y += 2
      f += ddf_y
    }
    x += 1
    ddf_x += 2
    f += ddf_x
    plot this (x0 - x) (y0 - y) // upper top left
    plot this (x0 + x) (y0 - y) // upper top right
    plot this (x0 - y) (y0 - x) // lower top left
    plot this (x0 + y) (y0 - x) // lower top right
    plot this (x0 - y) (y0 + x) // upper bottom left
    plot this (x0 + y) (y0 + x) // upper bottom right
    plot this (x0 - x) (y0 + y) // lower bottom left
    plot this (x0 + x) (y0 + y) // lower bottom right
  }
}

method fillCircle Pen x0 y0 radius fillColor {
  f = (1 - radius)
  ddf_x = 1
  ddf_y = (-2 * radius)
  x = 0
  y = radius
  fillRect canvas fillColor x0 (y0 - radius) 1 1 // top
  fillRect canvas fillColor x0 (y0 + radius) 1 1 // bottom
  fillRect canvas fillColor (x0 - radius) y0 ((2 * radius) + 1) 1 // middle line
  while (x < y) {
    if (f >= 0) {
      y += -1
      ddf_y += 2
      f += ddf_y
    }
    x += 1
    ddf_x += 2
    f += ddf_x
    w = ((2 * x) + 1)
	fillRect canvas fillColor (x0 - x) (y0 - y) w 1
	fillRect canvas fillColor (x0 - x) (y0 + y) w 1
    w = ((2 * y) + 1)
	fillRect canvas fillColor (x0 - y) (y0 - x) w 1
	fillRect canvas fillColor (x0 - y) (y0 + x) w 1
  }
}
// present an editable text box in a morphic window, adjust the text size to always fill it entirely

defineClass Presentation morph window text

method initialize Presentation contents {
  scale = (global 'scale')
  if (not (isClass contents 'String')) {contents = ''}
  window = (window 'Notes')
  morph = (morph window)
  border = (border window)

  text = (newText contents)
  setEditRule text 'editable'
  setGrabRule (morph text) 'ignore'
  setBorders text border border true
  align text 'center'
  addPart morph (morph text)

  setExtent morph (scale * 230) (scale * 200)
  setHandler morph this
  setMinExtent morph (scale * 120) (scale * 80)
  redraw this
}

method fixLayout Presentation {
  fixLayout window
  clientArea = (clientArea window)
  size = (fontSize text)
  border = (size / 5)
  extent = (extent text size border border)
  xDelta = ((width clientArea) - (width extent))
  yDelta = ((height clientArea) - (height extent))

  if (xDelta < 0) {
    ratio = (/ (toFloat (width clientArea)) (width extent))
    size = (truncate (* ratio size))
    border = (truncate (size / 5))
    extent = (extent text size border border)
    xDelta = ((width clientArea) - (width extent))
    yDelta = ((height clientArea) - (height extent))

    if (yDelta < 0) {
      ratio = (/ (toFloat (height clientArea)) (height extent))
      size = (truncate (* ratio size))
      border = (truncate (size / 5))
      extent = (extent text size border border)
      xDelta = ((width clientArea) - (width extent))
      yDelta = ((height clientArea) - (height extent))
    }

  } else {
    ratio = (/ (toFloat (width clientArea)) (width extent))
    size = (truncate (* ratio size))
    border = (truncate (size / 5))
    extent = (extent text size border border)
    xDelta = ((width clientArea) - (width extent))
    yDelta = ((height clientArea) - (height extent))

    if (yDelta < 0) {
      ratio = (/ (toFloat (height clientArea)) (height extent))
      size = (truncate (* ratio size))
      border = (truncate (size / 5))
      extent = (extent text size border border)
      xDelta = ((width clientArea) - (width extent))
      yDelta = ((height clientArea) - (height extent))
    }
  }

  while (or (> (width (extent text size border)) (width clientArea)) (> (height (extent text size border)) (height clientArea))) {
    size += -1
    border = (truncate (size / 5))
  }

  setBorders text border border
  setFont text nil size
  setCenter (morph text) (hCenter clientArea) (vCenter clientArea)
}

method updateScale Presentation {
  // Used to redraw window and contents when scale changes.
  updateScale window
  redraw this
}

method redraw Presentation {
  fixLayout window
  redraw window
  clientArea = (translatedBy (clientArea window) (0 - (left morph)) (0 - (top morph)))
  fillRect (costumeData morph) (clientColor window) (left clientArea) (top clientArea) (width clientArea) (height clientArea)
  updateCostume morph
  fixLayout this
}

method clicked Presentation hand {
  edit (keyboard (page hand)) text (slotAt text (left (morph text)) (top (morph text)))
  return false
}

method textEdited Presentation aText {fixLayout this}

to openPresentation page contents {
  ws = (new 'Presentation')
  initialize ws contents
  setPosition (morph ws) (x (hand page)) (y (hand page))
  addPart page ws
}

// serialization

method preSerialize Presentation {
  setCostume morph nil
}
defineClass PrettyPrinter gen offset useSemicolons

// public methods

method useSemicolons PrettyPrinter { useSemicolons = true }

method prettyPrint PrettyPrinter block generator {
  gen = generator
  offset = ((fieldNameCount (class 'Command')) + 1)
  if (isNil gen) {
    gen = (new 'PrettyPrinterGenerator' (list) 0 true true)
    if (true == useSemicolons) { useSemicolons gen }
  }
  printCmd this block
  return (joinStringArray (toArray (getField gen 'result')))
}

method prettyPrintFunction PrettyPrinter func generator {
  gen = generator
  offset = ((fieldNameCount (class 'Command')) + 1)
  if (isNil gen) {
    gen = (new 'PrettyPrinterGenerator' (list) 0 true true)
    if (true == useSemicolons) { useSemicolons gen }
  }
  printFunction this func
  return (joinStringArray (toArray (getField gen 'result')))
}

method prettyPrintMethod PrettyPrinter func generator {
  gen = generator
  offset = ((fieldNameCount (class 'Command')) + 1)
  if (isNil gen) {
    gen = (new 'PrettyPrinterGenerator' (list) 0 true true)
    if (true == useSemicolons) { useSemicolons gen }
  }
  printFunction this func (className (class (classIndex func)))
  return (joinStringArray (toArray (getField gen 'result')))
}

method prettyPrintList PrettyPrinter block generator {
  gen = generator
  offset = ((fieldNameCount (class 'Command')) + 1)
  if (isNil gen) {
    gen = (new 'PrettyPrinterGenerator' (list) 0 true true)
    if (true == useSemicolons) { useSemicolons gen }
  }

  currentBlock = block
  early = true
  while (notNil currentBlock) {
    tab gen
    early = (printCmd this currentBlock early)
    early = (early == true)
    crIfNeeded gen
    currentBlock = (getField currentBlock 'nextBlock')
  }
  result = (getField gen 'result')
  if (and ((count result) > 0) (';' == (last result))) { removeLast result }
  return (joinStringArray (toArray result))
}

method prettyPrintString PrettyPrinter aString {
  commands = (parse aString)
  output = (list)
  for i (count commands) {
    add output (prettyPrint this (at commands i))
    if (i < (count commands)) {
      if (true == useSemicolons) {
        add output ';'
      } else {
        add output (newline)
      }
    }
  }
  return (joinStringArray (toArray output))
}

method prettyPrintFile PrettyPrinter aFileName {
  return (prettyPrintString this (readFile aFileName))
}

method prettyPrintClass PrettyPrinter aClass withoutDefinition generator {
  offset = ((fieldNameCount (class 'Command')) + 1)
  gen = generator
  if (isNil gen) {
    gen = (new 'PrettyPrinterGenerator' (list) 0 true true)
    if (true == useSemicolons) { useSemicolons gen }
  }

  if (not (withoutDefinition === false)) {
    control gen 'defineClass'
    varName gen (className aClass)
    for f (fieldNames aClass) {
      varName gen f
    }
    crIfNeeded gen
    cr gen
  }

  mList = (sorted (methods aClass) (function a b {return ((functionName a) < (functionName b))}))
  for f mList {
    printFunction this f (className aClass)
    if (not (f === (last mList))) {
      cr gen
    }
  }
  return (joinStringArray (toArray (getField gen 'result')))
}

method prettyPrintFileToFile PrettyPrinter aFileName newFileName {
  writeFile newFileName (prettyPrintFile this aFileName)
}

// private methods

method infixOp PrettyPrinter token {
  return (or ('=' == token) ('+=' == token)
             ('+' == token) ('-' == token) ('*' == token) ('/' == token) ('%' == token)
             ('<' == token) ('<=' == token) ('==' == token)
             ('!=' == token) ('>=' == token) ('>' == token) ('===' == token)
             ('&' == token) ('|' == token) ('^' == token)
             ('<<' == token) ('>>' == token) ('>>>' == token)
             ('->' == token))
}

method allAlphaNumeric PrettyPrinter letters {
  for c letters {
    if (not (or (isLetter c) (isDigit c) ('_' == c))) { return false }
  }
  return true
}

method quoteOp PrettyPrinter value {
  if (isClass value 'String') {
    if (or (infixOp this value) (not (isLetter value))
           (value == 'false') (value == 'true') (value == 'nil') (value == 'else')) {
      return (join '''' value '''')
    }

    token = (toList (letters value))
    removeLast token
    if (allAlphaNumeric this token) { return value }
    return (join '''' value '''')
  }
}

method op PrettyPrinter value {
  if (isClass value 'String') {
    if (or (infixOp this value) (isLetter value)) {
      token = (toList (letters value))
      removeLast token
      if (allAlphaNumeric this token) { return value }
    }
  }
  return (join '''' value '''')
}

method printValue PrettyPrinter block {
  if (isClass block 'Reporter') {
    prim = (primName block)
    if (isOneOf prim 'v' 'my') {
      varRef = (getField block offset)
      if (or (varMustBeQuoted varRef) ('my' == prim)) {
        varRef = (join '(' prim ' ' (printString varRef) ')')
      }
      symbol gen varRef
    } else {
      openParen gen
      printCmd this block
      closeParen gen
    }
  } (isClass block 'Command') {
    printCmdList this block
  } (isClass block 'String') {
    const gen (printString block)
  } (isClass block 'Float') {
    const gen (toString block 20)
  } (isClass block 'Color') {
    c = block
    const gen (join '(colorSwatch ' (red c) ' ' (green c) ' ' (blue c) ' ' (alpha c) ')')
  } else {
    const gen (toString block)
  }
}

method printFunction PrettyPrinter func aClass {
  if (isNil aClass) {
    if (notNil (functionName func)) {
      control gen 'to'
      functionName gen (quoteOp this (functionName func))
    } else {
      control gen 'function'
    }
    for i (count (argNames func)) {
      varName gen (at (argNames func) i)
    }
  } else {
    control gen 'method'
    functionName gen (quoteOp this (primName func))
    for i (count (argNames func)) {
      if (i == 1) {
        varName gen aClass
      } else {
        varName gen (at (argNames func) i)
      }
    }
  }
  printCmdList this (cmdList func)
}

method printReporter PrettyPrinter block {
  prim = (primName block)
  if (and (infixOp this prim) ((count block) == (offset + 1))) {
    printValue this (getField block offset)
    symbol gen prim
    printValue this (getField block (offset + 1))
  } (prim == 'v') {
    symbol gen 'v'
    varName gen (getField block offset)
  } else {
    printOp this prim
    for i (count block) {
      if (i >= offset) {
        printValue this (getField block i)
      }
    }
  }
}

method printOp PrettyPrinter block {
  functionName gen (op this block)
}

method printCmdList PrettyPrinter block inIf {
  openBrace gen
  if (useSemicolons != true) {
    cr gen
    addTab gen
  }
  currentBlock = block
  early = true
  while (notNil currentBlock) {
    tab gen
    early = (printCmd this currentBlock early)
    early = (early == true)
    crIfNeeded gen
    currentBlock = (getField currentBlock 'nextBlock')
  }
  decTab gen
  tab gen
  closeBrace gen
  if (inIf != true) {
    crIfNeeded gen
  }
}

method printCmdListInControl PrettyPrinter block {
  if (isClass block 'Reporter') {
    printValue this block
  } (isClass block 'Command') {
    printCmdList this block
    crIfNeeded gen
  } else { // empty body
    openBrace gen
    closeBrace gen
    crIfNeeded gen
  }
}

method isShort PrettyPrinter bodyBlock {
  // Return true if the body of an 'if' command is empty or a single command that should
  // be put on the same line as the test.
  return (or (isNil bodyBlock) (isNil (nextBlock bodyBlock)))
}

method printCmdListShort PrettyPrinter block {
  openBrace gen
  skipSpace gen
  if (notNil block) { printCmd this block }
  closeBrace gen
  crIfNeeded gen
}

method printCmd PrettyPrinter block early {
  prim = (primName block)
  if (prim == 'to') {
    op = (getField block offset)
    control gen prim
    functionName gen (quoteOp this op)
    for i (count block) {
      if (and (i >= (offset + 1)) (i < (count block))) {
        varName gen (getField block i)
      }
    }
    printCmdListInControl this (getField block (count block))
  } (prim == 'function') {
    control gen prim
    for i (count block) {
      if (and (i >= offset) (i < (count block))) {
        varName gen (getField block i)
      }
    }
    printCmdListInControl this (getField block (count block))
  } (prim == 'defineClass') {
    control gen prim
    varName gen (getField block offset)
    for i (count block) {
      if (and (i >= (offset + 1)) (i <= (count block))) {
        varName gen (getField block i)
      }
    }
    crIfNeeded gen
  } (prim == 'method') {
    control gen prim
    symbol gen (quoteOp this (getField block offset))
    varName gen (getField block (offset + 1))
    for i (count block) {
      if (and (i >= (offset + 2)) (i < (count block))) {
        varName gen (getField block i)
      }
    }
    printCmdListInControl this (getField block (count block))
  } (prim == 'for') {
    control gen prim
    varName gen (getField block offset)
    printValue this (getField block (offset + 1))
    printCmdListInControl this (getField block (offset + 2))
  } (prim == 'while') {
    control gen prim
    printValue this (getField block offset)
    printCmdListInControl this (getField block (offset + 1))
  } (prim == 'if') {
    if (and (early == true) (((count block) - offset) == 1)
         (isShort this (getField block (offset + 1)))) {
      control gen prim
      printValue this (getField block (offset + 0))
      printCmdListShort this (getField block (offset + 1))
      return true
    } else {
      control gen prim
      ind = 0
      while ((offset + ind) < (count block)) {
        cond = (getField block (offset + ind))
        body = (getField block ((offset + ind) + 1))
        printed = false
        if ((offset + ind) == ((count block) - 1)) {
          if (cond == true) {
            symbol gen 'else'
            printed = true
          }
        }
        if (not printed) {
          printValue this cond
        }
        printCmdList this body true
        ind += 2
      }
    }
  } (prim == '=') {
    varName gen (getField block offset)
    symbol gen prim
    printValue this (getField block (offset + 1))
  } (prim == '+=') {
    varName gen (getField block offset)
    symbol gen prim
    printValue this (getField block (offset + 1))
  } else {
    printReporter this block
  }
}

defineClass PrettyPrinterGenerator result tabLevel hadCr hadSpace useSemicolons

method useSemicolons PrettyPrinterGenerator { useSemicolons = true }

method closeBrace PrettyPrinterGenerator {
  if (';' == (last result)) { removeLast result }
  nextPutAll this '}'
}

method addTab PrettyPrinterGenerator {
  tabLevel = (tabLevel + 1)
}

method closeParen PrettyPrinterGenerator {
  nextPutAll this ')'
}

method const PrettyPrinterGenerator value {
  nextPutAllWithSpace this value
}

method control PrettyPrinterGenerator value {
  nextPutAll this value
}

method crIfNeeded PrettyPrinterGenerator {
  if (not hadCr) {
    cr this
  }
}

method cr PrettyPrinterGenerator {
  if (true == useSemicolons) {
    nextPutAll this ';'
  } else {
    nextPutAll this (newline)
  }
  hadCr = true
}

method skipSpace PrettyPrinterGenerator {
  hadSpace = true
}

method decTab PrettyPrinterGenerator {
  tabLevel = (tabLevel - 1)
}

method functionName PrettyPrinterGenerator value {
  if (not (isClass value 'String')) {
    error 'non string'
  }
  nextPutAllWithSpace this value
}

method varName PrettyPrinterGenerator value {
  if (varMustBeQuoted value) {
    value = (printString value) // enclose in quotes
  }
  nextPutAllWithSpace this value
}

method nextPutAll PrettyPrinterGenerator value {
  add result value
  if ((count value) > 0) {
    last = (last (letters value))
    hadSpace = (isOneOf last ' ' '(' '{' (newline))
    hadCr = (isOneOf last ';' '{' (newline))
  }
}

method nextPutAllWithSpace PrettyPrinterGenerator value {
  if (not hadSpace) {
    nextPutAll this ' '
  }
  nextPutAll this value
}

method openBrace PrettyPrinterGenerator {
  nextPutAllWithSpace this '{'
}

method openParen PrettyPrinterGenerator {
  nextPutAllWithSpace this '('
}

method symbol PrettyPrinterGenerator value {
  nextPutAllWithSpace this value
}

method tab PrettyPrinterGenerator {
  useSemicolons = (useSemicolons == true)
  if (not useSemicolons) {
    repeat tabLevel {
      repeat 2 {
        nextPutAll this ' '
      }
    }
  }
}
defineClass Profile profileArray totalMSecs totalTicks totalEntries callTree primStats leafStats

to profile func args... {
  gc
  args = (newArray ((argCount) - 1))
  for i ((argCount) - 1) {
	atPut args i (arg (i + 1))
  }
  setField (currentTask) 'profileIndex' 1
  setField (currentTask) 'profileArray' (newArray 10000000)
  timer = (newTimer)
  startProfileClock
  callWith func args
  stopProfileClock
  msecs = (msecs timer)
  count = ((getField (currentTask) 'profileIndex') - 1)
  gc
  data = (copyArray (getField (currentTask) 'profileArray') count)
  gc
  return (new 'Profile' data msecs)
}

// String results, for use from command line

method prims Profile {
  if (isNil primStats) { analyzeProfileData this }
  pairs = (reversed (sortedPairs primStats))
  lines = (list 'Primitives:')
  for p pairs {
	n = (at p 1)
	percent = (((10000 * n) / totalTicks) / 100.0)
	add lines (join '  ' (at p 2) ' [' n '] ' (round percent 0.01) '%')
  }
  return (joinStrings lines (newline))
}

method methods Profile {
  if (isNil callTree) { analyzeProfileData this }
  root = callTree
  if ((count (children root)) == 1) { root = (first (children root)) } // skip root if it has only one child
  lines = (list 'Method statistics:')
  addMethodCounts this root 1 lines
  return (joinStrings lines (newline))
}

method addMethodCounts Profile node level lines {
  // Recursive helper function. Add method stats for the
  // given node and all its descendants.
  indent = (joinStringArray (newArray level '   '))
  percent = ((((count node) * 10000) / totalTicks) / 100.0)
  percent = (round percent 0.01) // round to two digits
  if (isEmpty (children node)) {
	add lines (join indent (functionName node) ' [' (count node) '] ' percent '%')
  } else {
	add lines (join indent (functionName node) ' [' (count node) '] ' percent '% {')
	for child (children node) {
	  addMethodCounts this child (level + 1) lines
	}
	add lines (join indent '}')
  }
}

method leaves Profile {
  if (isNil callTree) { analyzeProfileData this }
  lines = (list 'Leaf methods:')
  for p (reversed (sortedPairs leafStats)) {
	fName = (functionName (at p 2))
	if (isNil fName) { fName = '<function>' }
	n = (at p 1)
	percent = (((n * 10000) / totalTicks) / 100.0)
	add lines (join  '  ' fName ' [' n '] ' (round percent 0.01) '%')
  }
  return (joinStrings lines (newline))
}

// View results as a dictionary in an Explorer

method exploreProfile Profile {
  if (isNil callTree) { analyzeProfileData this }
  root = callTree
  if ((count (children root)) == 1) { root = (first (children root)) } // skip root if it has only one child
  result = (dictionary)
  atPut result 'info' (join 'Profile ' totalEntries ' entries ' totalTicks ' ticks in ' totalMSecs ' msecs')
  atPut result 'methods (call tree)' (methodTree this root)
  atPut result 'methods (flat)' (leavesDict this)
  atPut result 'primitives' (primsDict this)
  openExplorer result
}

method methodTree Profile node {
  // Recursive helper function. Return a dictionary for the given node.
  percent = ((((count node) * 10000) / totalTicks) / 100.0)
  label = (join (functionName node) ' [' (count node) ']   '  (round percent 0.01) '%')
  if (isEmpty (children node)) { return label }
  result = (dictionary)
  for child (children node) {
	percent = ((((count child) * 10000) / totalTicks) / 100.0)
	label = (join (functionName child) ' [' (count child) ']   ' (round percent 0.01) '%')
	atPut result label (methodTree this child totalTicks)
  }
  return result
}

method leavesDict Profile {
  result = (dictionary)
  i = 1
  for p (reversed (sortedPairs leafStats)) {
	fnc = (at p 2)
	fName = (functionName fnc)
	if (isNil fName) { fName = '<function>' }
	if (isMethod fnc) {
	  fName = (join fName ' (' (className (class (classIndex fnc))) ')')
	}
	n = (at p 1)
	percent = (((n * 10000) / totalTicks) / 100.0)
	k = (join (withLeadingZeros this i) '   ' fName ' [' n '] ' (round percent 0.01) '%')
	atPut result k n
	i += 1
  }
  return result
}

method primsDict Profile {
  result = (dictionary)
  i = 1
  for p (reversed (sortedPairs primStats)) {
	n = (at p 1)
	percent = (((10000 * n) / totalTicks) / 100.0)
	k = (join (withLeadingZeros this i) '   ' (at p 2) ' [' n '] ' (round percent 0.01) '%')
	atPut result k n
	i += 1
  }
  return result
}

method withLeadingZeros Profile n {
  s = (toString n)
  if (n < 10) {
	s = (join '00' s)
  } (n < 100) {
	s = (join '0' s)
  }
  return s
}

// Profile data processing

method analyzeProfileData Profile {
  // Scan the profileArray, recording the primitive and the call chain for each entry.
  // Each profile entry has the form:
  //	block (Command or Reporter)
  //	tick count (may be > 1 for long-running primitives)
  //	zero or more Functions (the call chain in revere order, possibly truncated).

  totalTicks = 0
  totalEntries = 0
  callTree = (new 'ProfileNode' 'root' 0 (array))
  primStats = (dictionary)
  leafStats = (dictionary)
  end = (count profileArray)
  i = 1
  while (i <= end) {

	block = (at profileArray i)
	ticks = (at profileArray (i + 1))
	totalTicks += ticks
	totalEntries += 1
	i += 2

	if (isClass block 'Function') { error 'Profile data entry should start with a Command or Reporter' }
	add primStats (primName block) ticks

	// Find the start of the next entry
	isLeaf = true
	while (and (i <= end) (isClass (at profileArray i) 'Function')) {
	  if isLeaf { add leafStats (at profileArray i); isLeaf = false }
	  i += 1
	}
	entryEnd = (i - 1)
	recordEntry this ticks entryEnd
  }
  profileArray = nil
}

method recordEntry Profile ticks i {
  // Record the entry with the given ending index. Process function calls in
  // reverse order, which is the original calling order.
  node = callTree
  incrCount node ticks
  while true {
	f = (at profileArray i)
	if (not (isClass (at profileArray i) 'Function')) { return } // done; reached start of this entry
	node = (childFor node f)
	incrCount node ticks
	i += -1
  }
}

defineClass ProfileNode function count children

method function ProfileNode { return function }
method count ProfileNode { return count }
method incrCount ProfileNode ticks { count += ticks }
method children ProfileNode { return children }

method functionName ProfileNode {
  if (isClass function 'String') { return function }
  if (isNil (functionName function)) { return '<function>' }
  if (isMethod function) {
	return (join (functionName function) ' (' (className (class (classIndex function))) ')')
  }
  return (functionName function)
}

method childFor ProfileNode func {
  // Return the child node for the given function. Add a new node for the function if necessary.
  for child children {
	if (func == (function child)) { return child }
  }
  newNode = (new 'ProfileNode' func 0 (array))
  children = (copyWith children newNode)
  return newNode
}
// Project.gp - A GP project, including it's pages, media. and notes.

defineClass Project pages images sounds notes projectVars blockSpecs paletteBlocks extraCategories module hash ancestor dependencies thumbnail

method pages Project { return pages }
method images Project { return images }
method sounds Project { return sounds }
method notes Project { return notes }
method setNotes Project s { notes = s }
method blockSpecs Project { return blockSpecs }
method paletteBlocks Project { return paletteBlocks }
method extraCategories Project { return extraCategories }
method projectVars Project s { return projectVars } // needed for reading old projects
method ancestor Project { return ancestor }
method module Project { return module }
method dependencies Project { return dependencies }
method thumbnail Project { return thumbnail }

to emptyProject {
  return (initialize (new 'Project'))
}

method initialize Project {
  pages = (list (newProjectPage (list)))
  images = (list (makeShip this) (makeGPLogo this))
  sounds = (list (makePopSound this))
  notes = ''
  blockSpecs = (dictionary) // op -> blockSpec
  paletteBlocks = (dictionary) // category -> (ordered list of ops)
  extraCategories = (list) // ordered list of category names
  module = (initialize (new 'Module'))
  // This is not exactly right as it has pages data but this ensures
  //  that it has a hash and has a common ancestor that is always identifiable.
  ancestor = (sha256 '')
  hash = (sha256 '')
  dependencies = (list)
  return this
}

method initializeFrom Project project myHash myAncestor {
  pages = (pages project)
  images = (images project)
  sounds = (sounds project)
  notes = (notes project)
  // ???
  if (notNil (blockSpecs project)) { blockSpecs = (blockSpecs project) }
  if (notNil (paletteBlocks project)) { paletteBlocks = (paletteBlocks project) }
  if (notNil (extraCategories project)) { extraCategories = (extraCategories project) }
  hash = myHash
  ancestor = myAncester
  module = (module project)
  dependencies = (dependencies project)
  if (isNil hash) {hash = (sha256 '')}
  if (isNil ancestor) {ancestor = (sha256 '')}
  if (isNil module) {module = (initialize (new 'Module'))}
  if (isNil dependencies) {dependencies = (list)}
  if (notNil (thumbnail project)) {
    thumbnail = (copy (thumbnail project))
  }
  return this
}

// **** Read Project ****

method readProject Project data {
  initialize this
  zip = (read (new 'ZipFile') data)
  scriptData = (extractNestedFile zip 'scripts.txt')
  morphData = (extractNestedFile zip 'objects.gpod')
  if (notNil morphData) {
    if ((version (new 'Serializer') morphData) == 2) {
      return (readProject2 this data) // new format
    }
	if (notNil scriptData) { installScripts this (toString scriptData) }
    project = (read (new 'Serializer') morphData)
  }
  zip = nil
  scriptData = nil
  morphData = nil
  gc

  pages = (list)
  if (isClass project 'Table') { // old format: Table of pages
	for r (rowCount project) {
	  morphsForPage = (list)
	  for m (cellAt project r 'contents') {
		if (not (isAnyClass (handler m) 'ScripterMenuBar' 'Scripter')) {
		  postSerialize m
		  add morphsForPage m
		}
	  }
	  convertToStageCoordinates this morphsForPage
	  add pages (newProjectPage morphsForPage)
	}
  } (isClass project 'Project') {
	pages = (pages project)
	images = (images project)
	sounds = (sounds project)
	notes = (notes project)
	projectVars = (projectVars project)
	if (notNil projectVars) {
	  for v (keys projectVars) {
		setShared v (at projectVars v) module
	  }
	  projectVars = nil
	}
  } else {
	print 'Unknown or obsolete project class:' (className (class project))
  }
  if (isEmpty pages) { pages = (list (newProjectPage (list))) }
  convert this
  clearMethodCaches
  gc
  return this
}

// **** Old project format open/save support ****

method convertToStageCoordinates Project morphList {
  // Convert the given morphs to stage coordinates (i.e. origin at center of stage).

  if (isEmpty morphList) { return }
  overallBounds = (copy (bounds (first morphList)))
  for m morphList { merge overallBounds (bounds m) }
  xCenter = (hCenter overallBounds)
  yCenter = (vCenter overallBounds)
  for m morphList {
	setPosition m ((left m) - xCenter) ((top m) - yCenter)
  }
}

method installScripts Project scriptData {
  cmds = (toList (parse scriptData))
  if (isEmpty cmds) { return }

  myClass = nil
  scripts = (list)
  for cmd cmds {
    if ('defineClass' == (primName cmd)) {
      if (notNil myClass) {
        setScripts myClass (toArray scripts)
      }
      myClass = nil
      scripts = (list)
      args = (argList cmd)
      if ((count args) > 1) {
        callWith 'defineClass' args
        myClass = (class (first args))
        clearCaches myClass
      }
    } else {
      args = (argList cmd)
      if (not (and ('script' == (primName cmd)) ((count args) == 3))) { return (error 'Bad script file') }
      expr = (at args 3)
      if ('method' == (primName expr)) {
		if (isNil myClass) { error 'Implementation error: method script with no class' }
		methodArgs = (argList expr)
		methodName = (first methodArgs)
		methodParams = (copyFromTo methodArgs 2 ((count methodArgs) - 1))
		methodBody = (last methodArgs)
		addMethod myClass methodName methodParams methodBody
      }
      add scripts args
    }
  }
  if (notNil myClass) {
    setScripts myClass scripts
  }
}

method projectData1 Project {
  // Return the serialized data for an old (non-module-based) project.
  objectsToOmit = (dictionary)
  for p pages {
	for m (morphs p) {
	  if (notNil (owner m)) {
		add objectsToOmit (owner m)
	  }
	  preSerialize m
	}
  }
  serializedData = (write (new 'Serializer') this (keys objectsToOmit))
  projectVars = nil

  // make and save zip file
  zip = (create (new 'ZipFile'))
  addFile zip 'objects.gpod' serializedData true
  addFile zip 'scripts.txt' (collectScripts1 this) true
  return (contents zip)
}

method collectScripts1 Project {
  result = (list)
  for cl (classes) {
	if (notNil (scripts cl)) {
	  add result (scriptString cl true)
	}
  }
  return (joinStrings result)
}

// **** New (module-based) project open/save ****

method readProject2 Project data {
  initialize this
  zip = (read (new 'ZipFile') data)
  scriptData = (extractNestedFile zip 'scripts.txt')
  morphData = (extractNestedFile zip 'objects.gpod')
  modules = (dictionary)
  dependencies = (list)

  for f (fileNames zip) {
    if (beginsWith f 'modules/') {
      data = (extractFile zip f)
      data = (stringFromByteRange data 1 (byteCount data))
      atPut modules (stringFromByteRange f ((count 'modules/') + 1) (count f)) data
    } (beginsWith f 'dependencies/') {
      add dependencies (stringFromByteRange f ((count 'dependencies/') + 1) (count f))
    } (or (f == 'thumbnail') (f == 'thumbnail.png')) {
      data = (extractFile zip f)
      if ((count data) > 0) {
		thumbnail = (readFrom (new 'PNGReader') data)
	  }
    } (or (f == 'notes') (f == 'notes.txt')) {
      myNotes = (toString (extractFile zip f))
    }
  }

  if (notNil morphData) {
    project = (read (new 'Serializer2') morphData modules)
  }

  myHash = (toString (extractFile zip 'hash'))
  myAncestor = (toString (extractFile zip 'ancestor'))

  topHash = (toString (extractFile zip 'topHash'))
// Note: The top level module changes often, so comment this out.
// It is also slow and used memory to generate the code of the topLevelModule,
// so commenting this out out also speeds up project loading, especially in browsers.
//  if (topHash != (codeHash (topLevelModule))) {
//	print 'This project was created on a different top level module.'
//  }

  initializeFrom this project myHash myAncestor
  if (isEmpty pages) { pages = (list (newProjectPage (list))) }
  if (notNil scriptData) { installScripts2 this (toString scriptData) }
  if ((count myNotes) > 0) {
    // reading a format where notes is a distinct entry in zip.
    // Otherwise, we keep the one that came in binary of 'project'
    setNotes this myNotes
  } else {
    setNotes this ''
  }
  return this
}

method saveProject Project fName thumb {
  // Save this project to a file with the given name.

  data = (projectData2 this fName thumb)
  writeData this fName data
}

method projectData2 Project fName thumb {
  // Return the serialized data for this project using modules.

  thumbnail = nil
  myNotes = notes
  if (isNil myNotes) { myNotes = '' }
  notes = nil

  png = nil
  if (notNil thumb) {
    png = (encodePNG thumb)
  } else {
	png = '' // needed for hash
  }

  objectsToOmit = (dictionary)
  for p pages {
    for m (morphs p) {
      if (notNil (owner m)) {
        add objectsToOmit (owner m)
      }
      preSerialize m
    }
  }

  oldAncestor = ancestor
  oldHash = hash
  if (isNil oldHash) {
    oldHash = (sha256 '')
  }
  ancestor = nil
  hash = nil

  serializedData = (write (new 'Serializer2') this (keys objectsToOmit))

  // make and save zip file
  zip = (create (new 'ZipFile'))
  objects = (at serializedData 1)
  if (notNil png) {
    addFile zip 'thumbnail.png' png true
  }
  addFile zip 'notes.txt' myNotes true
  addFile zip 'objects.gpod' (at serializedData 1) true
  dict = (at serializedData 2)
  topHash = (at serializedData 3)
  keys = (keys dict)
  for m keys {
    d = (at dict m)
    addFile zip (join 'modules/' m) (at dict m)
    // code for the modules that are found during serialization
  }

  if (notNil dependencies) {
    // dependencies contains list of hashes of projects.
    for m dependencies {
      addFile zip (join 'dependencies/' m) ''
    }
  }

  addFile zip 'topHash' topHash

  data = (dataStream (newBinaryData (+ (byteCount objects) (byteCount oldHash) (byteCount topHash) (byteCount png) (byteCount myNotes))))
  nextPutAll data objects
  nextPutAll data oldHash
  nextPutAll data topHash
  nextPutAll data png
  nextPutAll data myNotes
  data = (contents data)

  ancestor = oldHash
  hash = (sha256 data)
  addFile zip 'hash' hash false
  addFile zip 'ancestor' ancestor false

  notes = myNotes
  thumbnail = thumb
  return (contents zip)
}

method installScripts2 Project scriptData {
  cmds = (toList (parse scriptData))
  if (isEmpty cmds) { return }

  myClass = nil
  scripts = (list)
  for cmd cmds {
    if ('defineClass' == (primName cmd)) {
      if (notNil myClass) {
        setScripts myClass (toArray scripts)
      }
      myClass = nil
      scripts = (list)
      args = (argList cmd)
	  myClass = (classNamed module (first args))
    } else {
      args = (argList cmd)
      if ('script' != (primName cmd)) { return (error 'Bad script file') }
      expr = (last args)
      if ('method' == (primName expr)) {
		if (isNil myClass) { error 'Implementation error: method script with no class' }
		methodArgs = (argList expr)
		methodName = (first methodArgs)
		methodParams = (copyFromTo methodArgs 2 ((count methodArgs) - 1))
		methodBody = (last methodArgs)
		if (isClass methodBody 'Command') {
		  addMethod myClass methodName methodParams methodBody
		}
      }
      if ((count args) == 4) {
		// new external format is: className x y body; remove classname for internal use
		args = (copyFromTo args 2)
	  }
      add scripts args
    }
  }
  if (notNil myClass) {
    setScripts myClass (toArray scripts)
  }
}

method convert Project {
  for cl (classes) {
	if (and (notNil (scripts cl)) ((module cl) == (topLevelModule))) {
	  removeClass (topLevelModule) cl
      setField module 'classes' (copyWith (classes module) cl)
      setField cl 'module' module
    }
  }
}

// server support

method readData Project location {
  if (beginsWith location 'http://') {
    m = (loadModule 'modules/DAVDirectory.gpm')
    u = (url (initialize (new (at m 'URIParser')) location))
    c = (new (at m 'DAVClient'))
    maybeSetAccountFromConfFile c location
    openURL c u
    val = (get c)
    return val
  }
  return (readFile location true)
}

method writeData Project location data {
  if (beginsWith location 'http://') {
    m = (loadModule 'modules/DAVDirectory.gpm')
    u = (url (initialize (new (at m 'URIParser')) location))
    c = (new (at m 'DAVClient'))
    maybeSetAccountFromConfFile c location
    openURL c u
    return (put c data)
  }
  return (writeFile location data)
}

// media

method imageNamed Project imageName {
  for img images {
	if (imageName == (name img)) { return img }
  }
  return nil
}

method soundNamed Project sndName {
  for snd sounds {
	if (sndName == (name snd)) { return snd }
  }
  return nil
}

method imageNames Project imageName {
  result = (list)
  for img images {
	if (notNil (name img)) { add result (name img) }
  }
  return result
}

method soundNames Project imageName {
  result = (list)
  for snd sounds {
	if (notNil (name snd)) { add result (name snd) }
  }
  return result
}

method saveImageAs Project bm name {
  // Add the given bitmap with given name to my images.
  // If name is nil or not a string, generate a unique name.

  if (or (not (isClass name 'String')) ('' == name)) {
  	name = (uniqueNameNotIn (imageNames this) 'snapshot')
  }
  setName bm name
  oldImg = (imageNamed this name)
  if (notNil oldImg) { remove images oldImg }
  add images bm
}

method saveSoundAs Project snd name {
  // Add the given sound with given name to my sounds.
  // If name is nil or not a string, generate a unique name.

  if (or (not (isClass name 'String')) ('' == name)) {
  	name = (uniqueNameNotIn (soundNames this) 'sound')
  }
  if (isClass snd 'Array') {
	snd = (newSound snd 22050 false name)
  }
  if (not (isClass snd)) {
	error 'Saved sound must be a sound object or an array of samples'
  }
  setName snd name
  oldSnd = (soundNamed this name)
  if (notNil oldSnd) { remove sounds oldSnd }
  add sounds snd
}

// extensions

method recordBlockSpec Project opName spec {
	atPut blockSpecs opName spec
}

method specsForCategory Project cat {
  result = (list)
  for op (at paletteBlocks cat (array)) {
	spec = (at blockSpecs op)
	if (notNil spec) { add result spec }
  }
  return result
}

method exportToExtensionCategory Project block {
  if (isEmpty extraCategories) { // skip menu if no categories yet
	selectCategoryForBlock this block 'new category...'
	return
  }
  menu = (menu nil (action 'selectCategoryForBlock' this block) true)
  for cat extraCategories {
	addItem menu cat cat
  }
  addLine menu
  addItem menu 'new category...'
  popUpAtHand menu (global 'page')
}

method selectCategoryForBlock Project block cat {
  scripter = (scripter (findProjectEditor))
  if ('new category...' == cat) {
	newCategory = (prompt (global 'page') 'Category name?')
	if ('' == newCategory) { return nil }
	newCategory = (uniqueNameNotIn (devModeCategories scripter) newCategory)
	if (not (contains extraCategories newCategory)) {
	  add extraCategories newCategory
	}
	cat = newCategory
  }
  op = (primName (expression block))
  addSpecToCategory this op (blockSpec block) cat
  developerModeChanged scripter // update palette
}

method addSpecToCategory Project op spec cat {
  atPut blockSpecs op spec
  opsForCat = (at paletteBlocks cat (list))
  atPut paletteBlocks cat opsForCat
  if (not (contains opsForCat op)) {
	add opsForCat op // add op to category
  }
}

method isUserDefinedBlock Project block {
  blockOp = (primName (expression block))
  return (contains blockSpecs blockOp)
}

method showingAnExtensionCategory Project {
  scripter = (scripter (findProjectEditor))
  return (contains paletteBlocks (currentCategory scripter))
}

method removeFromCurrentCategory Project block {
  scripter = (scripter (findProjectEditor))
  opsForCat = (at paletteBlocks (currentCategory scripter) (list))
  blockOp = (primName (expression block))
  remove opsForCat blockOp
  removeEmptyExtraCategories this
}

method blockDeleted Project op {
  remove blockSpecs op
  for opList (values paletteBlocks) {
	remove opList op
  }
  removeEmptyExtraCategories this
}

method removeEmptyExtraCategories Project {
  for k (keys paletteBlocks) {
	if (isEmpty (at paletteBlocks k)) {
	  remove paletteBlocks k
	  remove extraCategories k
	}
  }
  developerModeChanged (scripter (findProjectEditor)) // update palette
}

method importExtension Project extensionName extensionProj {
  callInitializer (module extensionProj)

  // add extension block specs to this project
  extSpecs = (blockSpecs extensionProj)
  for op (keys extSpecs) {
	if (contains blockSpecs op) {
	  print 'Warning: This project already has a block spec for' op
	} else {
	  atPut blockSpecs op (at extSpecs op)
	}
  }

  // add extension blocks to palette
  extBlocks = (paletteBlocks extensionProj)
  for cat (keys extBlocks) {
	opsForCat = (at paletteBlocks cat (list))
	atPut paletteBlocks cat opsForCat
	for op (at extBlocks cat) {
	  if (notNil (functionNamed op (module extensionProj))) {
		// op is a function in the extension module (not just a method), so
		// create a forwarding function that to invoke that function in the module
		oldOp = op
		oldSpec = (at blockSpecs oldOp)
		op = (createForwarderForImportedFunction this op (module extensionProj))
		setField oldSpec 'blockOp' op
		atPut blockSpecs op oldSpec
		remove blockSpecs oldOp
	  }
	  if (not (contains opsForCat op)) {
		add opsForCat op // add op to category
	  }
	}
	if (not (contains extraCategories cat)) {
	  add extraCategories cat
	}
  }

  if (isNil dependencies) {dependencies = (list)}
  extHash = (toString (getField extensionProj 'hash'))
  depIndex = (indexOf dependencies extHash)
  if (isNil depIndex) {
    add dependencies extHash
  }
}

method createForwarderForImportedFunction Project op extension {
  // The given op refers to a generic function in the given extensionModule.
  // Create a forwarding function that extracts the function from the extension
  // module and calls it. Return the op of the new function.

  extensions = (shared 'extensions' module )
  if (isNil extensions) { // create if needed
	extensions = (array)
	setShared 'extensions' extensions module
  }

  extensionIndex = (indexOf extensions extension)
  if (isNil extensionIndex) {
	// add extension to the shared extensions array
	extensions = (copyWith extensions extension)
	setShared 'extensions' extensions module
	extensionIndex = (count extensions)
  }

  // create a function to call function named 'op' in an extension module
  f = (copy (function {
	op = 'nop' // to be filled in with actual op
	extensionIndex = 0 // to be filled in with index of extension in (shared 'extensions')
	extensions = (shared 'extensions')
	if (isNil extensions) { return }
	extensionModule = (at extensions extensionIndex)
	realFunction = (functionNamed op extensionModule)

	argList = (list)
	for i (argCount) { add argList (arg i) }
	return (callWith realFunction (toArray argList))
  }))

  // modify f to fill in the op and extension index
  for b (allBlocks (cmdList f)) {
	if (and ('=' == (primName b)) (8 == (count b))) {
	  varName = (getField b 7)
	  if ('op' == varName) { setField b 8 op }
	  if ('extensionIndex' == varName) { setField b 8 extensionIndex }
	}
  }

  // find an unused name for f and save it in this project's module
  existingNames = (list op)
  for existingFunc (join (functions) (functions module)) {
	add existingNames (functionName existingFunc)
  }
  newOpName = (uniqueNameNotIn existingNames op)
  setField f 'functionName' newOpName
  addFunction module f

  return newOpName
}

// class removal support

method removeClassFromPages Project aClass {
  for p pages {
	morphs = (morphs p)
	newMorphs = (list)
	for m morphs {
	  if (not (isClass (handler m) aClass)) { add newMorphs m }
	}
	setMorphs p (toArray newMorphs)
  }
}

// initial media

method makeShip Project {
  data = 'iVBORw0KGgoAAAANSUhEUgAAACgAAAAeCAYAAABe3VzdAAABmElEQVR4nGNgZ2f/D8V/1dTUDoiLiycw
MDDwMAwWwMnJ+RvJkWAsICDwGejYBTw8PA5AJYwD6kBlZeUOkKO4ZLn+S1aL/eez4P3PzoFwrJSU1COg
mnYWFhblgXIjm6Ki4mWQY0Rihf4r75P7r7BS5r9YhvB/bgUulJBVUVE5LSEhkcpA7yQAjGYzcFRzsv+X
nSIJdiQY75X7LztZ8r9QgMB/TgFOuEP5+Pi+qaurrwQmBR+gdia6OBIW1dwq3P+VtssiHAnFIDHJxoFN
AhhRjQsPWBLAGdW48EAkAVB04YtqXJieSQAR1TH4o3rAkgDJUT0QSYDcqKZnEqA4qmmeBGBRzcHJ8V92
uhRVHQlLAjITJP4LevH/5+TnwNUWIBjV4AKcRxUY1Tsoj2pcWHGLzH/JSmASMOZBSQJD24GDPYqJrvoG
JJOgNB6oELVULWYGe0FNcdTStKojN2rp0lgY7M2twd1gBUZDJ76oHdAm/2DvNA3ubie84y7N+V+iWBSj
LpSRkbkP9EADMAqV6OYoZDDohz4G++ARAFGPsWx+VWYhAAAAAElFTkSuQmCC'
  bm = (readFrom (new 'PNGReader') (base64Decode data))
  setName bm 'ship'
  return bm
}

method makeGPLogo Project {
  bm = (newBitmap 100 100)
  fillRoundedRect (newVectorPen bm) (rect 1 1 99 99) 10 (gray 250) 2 (gray 0)
  setFont 'Verdana' 66
  c = (color 56 191 40)
  drawString bm 'G' c 6 8
  drawString bm 'P' c 55 8
  setName bm 'GP'
  return bm
}

method makePopSound Project {
  samples = (array
  	213 771 1981 3442 5615 7507 9020 9371 8418 5803 1651 -3755 -9633 -15264 -19571
	-22167 -22382 -19995 -15033 -7871 755 9965 18385 24906 28541 28707 24842 17614 7658 -3286
	-14065 -22678 -28163 -29403 -26386 -19143 -8728 3298 15005 24644 30320 31157 26786 17880 5991
	-7094 -19092 -28038 -32290 -31125 -24719 -14194 -991 12514 23933 31199 32740 28983 19881 7350
	-6231 -18353 -26996 -30461 -28311 -20913 -9739 3164 15360 24400 28655 26903 20054 9226 -3471
	-15015 -23705 -27722 -26248 -19720 -9624 2467 13966 22379 26153 24482 18108 8181 -3384 -13821
	-21003 -23858 -21729 -15310 -5391 5312 14763 20776 22257 18740 11086 1027 -9428 -17730 -22292
	-22258 -17199 -8820 1724 11836 19328 22804 21031 14685 5036 -5604 -14991 -21075 -22743 -19526
	-12261 -2384 7845 16250 20936 20938 16235 8061 -1561 -10541 -16767 -18913 -16811 -10836 -2628
	6186 13186 16885 16516 12076 4876 -3497 -10849 -15437 -16395 -13452 -7268 634 8314 13961
	16262 14546 9274 1731 -6254 -12773 -16506 -16376 -12523 -5807 2155 9598 14880 16648 14517
	9110 1619 -6097 -12458 -15830 -15638 -11942 -5627 1865 8852 13783 15568 13804 9034 2394
	-4537 -10213 -13449 -13555 -10650 -5521 689 6546 10803 12408 11178 7484 2292 -3228 -7745
	-10312 -10506 -8276 -4336 461 4905 8028 9128 8008 5035 943 -3246 -6544 -8262 -7973
	-5837 -2356 1572 5083 7410 8010 6788 4041 380 -3356 -6347 -7923 -7802 -6022 -2969
	673 4140 6751 7952 7564 5726 2877 -396 -3353 -5430 -6250 -5756 -4128 -1799 724
	2824 4170 4498 3801 2359 537 -1159 -2403 -2922 -2595 -1577 -225 1166 2199 2583
	2186 1109 -415)
  return (newSound samples 11025 false 'pop')
}

defineClass ProjectPage label morphs

method label ProjectPage { return label }
method setLabel ProjectPage s { label = s }

method morphs ProjectPage { return morphs }
method setMorphs ProjectPage morphList { morphs = (toArray morphList) }

to newProjectPage morphList label {
  if (isNil label) { label = '' }
  result = (new 'ProjectPage')
  setLabel result label
  setMorphs result morphList
  return result
}
defineClass ProjectEditor morph fileName project imagesFolder soundsFolder stage scripter library viewer viewerWidth tabs leftItems rightItems rightItemsRow2 title connectorToggle fpsReadout lastFrameTime frameCount

method project ProjectEditor { return project }
method stage ProjectEditor { return stage }
method library ProjectEditor { return library }
method scripter ProjectEditor { return scripter }

to recover baseFilename {
  // Save any projects in memory (usually only one) to files.
  if (isNil baseFilename) { baseFilename = 'recovered' }
  baseFilename = (withoutExtension (filePart baseFilename))
  gc // dispose of unreachable projects
  for editor (allInstances 'ProjectEditor') {
	fileName = (uniqueNameNotIn (listFiles (gpFolder)) baseFilename 'gpp')
	saveProject (project editor) (join (gpFolder) '/' fileName)
  }
}

to startProjectEditorFromMorphic {
  // Start the project editor from the morphic background menu.
  page = (global 'page')
  if (not (confirm (global 'page') nil 'Enter project editor (current morphs will be lost)?')) {
  	return
  }
  removeAllParts (morph page)
  editor = (initialize (new 'ProjectEditor') (emptyProject))
  addPart page editor
  pageResized editor
  developerModeChanged editor
}

to o tryRetina devMode { openProjectEditor tryRetina devMode } // shortcut, because Jens needs it so often :-)

to openProjectEditor tryRetina devMode {
  if (isNil tryRetina) { tryRetina = true }
  if (isNil devMode) { devMode = true }
  if (isNil (global 'vectorTrails')) { setGlobal 'vectorTrails' true }
  if (and ('Browser' == (platform)) (browserIsMobile)) {
	page = (newPage 1024 640)
  } else {
	page = (newPage 1120 700)
  }
  setDevMode page devMode
  setGlobal 'page' page
  open page tryRetina
  editor = (initialize (new 'ProjectEditor') (emptyProject))
  addPart page editor
  projName = 'new project'
  if (notNil (global 'initialProject')) {
	dataAndURL = (global 'initialProject')
    projName = (filePart (last dataAndURL))
  	openProject editor (first dataAndURL) (last dataAndURL)
  }
  goFlag = false
  if ('Browser' == (platform)) {
	if ('go.html' == (extractCommand (browserURL))) { goFlag = true }
	hide (morph (first (getField editor 'rightItems'))) // hide the 'Present' button in browser
	browserPostMessage (join projName ' loaded') true
  }
  pageResized editor
  developerModeChanged editor
  if goFlag { enterPresentation editor }
  startSteppingSafely page goFlag
}

to findProjectEditor {
  page = (global 'page')
  if (notNil page) {
	for p (parts (morph page)) {
	  if (isClass (handler p) 'ProjectEditor') { return (handler p) }
	}
  }
  return nil
}

method initialize ProjectEditor aProject {
  scale = (global 'scale')
  morph = (newMorph this)
  project = aProject
  viewerWidth = ((width (global 'page')) - (800 * scale))
  viewerWidth = (max viewerWidth (400 * scale))
  addTopBarParts this
  scripter = (initialize (new 'Scripter') this)
  addPart morph (morph scripter)
  stage = (newStage 16 10)
  addPart morph (morph stage)
  library = (initialize (new 'SpriteLibrary') scripter)
  addPart morph (morph library)
  setStageMorph scripter (morph stage)
  tabs = (tabBar (list 'Scripts' 'Images' 'Sounds' 'Notes') nil (action 'showTab' this) (transparent) 12)
  setBGColors tabs (gray 240) (gray 150) (gray 100) // match tab colors to Scripter border and class pane colors
  addPart morph (morph tabs)

  select tabs 'Scripts'
  drawTopBar this
  clearProject this
  createInitialClass scripter
  fixLayout this
  return this
}

// top bar parts

method addTopBarParts ProjectEditor {
  scale = (global 'scale')
  page = (global 'page')
  space = (15 * scale)

  title = (newText '' 'Arial Bold' (14 * scale))
  addPart morph (morph title)

  connectorLabel = (newText 'Show arrows:' 'Arial' (11 * scale))
  connectorToggle = (toggleButton
	(action 'toggleConnectors' page) (action 'isShowingConnectors' page)
	(scale * 20) (scale * 13) (scale * 5) (max 1 (scale / 2)) false)
//   addPart morph (morph connectorLabel)
//   addPart morph (morph connectorToggle)

  leftItems = (list)
  add leftItems (textButton this 'New' 'newProject')
  add leftItems (textButton this 'Open' 'openProjectMenu')
  add leftItems (textButton this 'Save' 'saveProject')
  if (not (isOneOf (platform) 'Browser' 'iOS')) {
	add leftItems (textButton this 'Export as App' 'exportProjectAsApp')
	if (canExportToWeb this) {
	  add leftItems (textButton this 'Export to Web' 'exportProjectToWeb')
	}
  }

  rightItems = (list)
  add rightItems (textButton this 'Present' 'enterPresentation')
  add rightItems space
  add rightItems (textButton this 'Go' (action 'broadcastGo' page))
  add rightItems (textButton this 'Stop' (action 'stopAll' page))

  rightItemsRow2 = (list)
//   add rightItemsRow2 connectorLabel
//   add rightItemsRow2 connectorToggle
  add rightItemsRow2 space
  add rightItemsRow2 (addFPSReadout this)
}

method textButton ProjectEditor label selectorOrAction {
  if (isClass selectorOrAction 'String') {
	selectorOrAction = (action selectorOrAction this)
  }
  result = (pushButton label (color 130 130 130) selectorOrAction)
  addPart morph (morph result)
  return result
}

method clickLabel ProjectEditor label selectorOrAction {
  if (isClass selectorOrAction 'String') {
	selectorOrAction = (action selectorOrAction this)
  }
  result = (newText label 'Arial' (11 * (global 'scale')))
  tr = (new 'Trigger' (morph result) selectorOrAction)
  setHandler (morph tr) tr
  addPart morph (morph result)
  return result
}

// block updating

method languageChanged ProjectEditor {
  blockScaleChanged scripter
}

method saveToUserPreferences ProjectEditor {
  // not yet implemented
}

// project operations

method newProject ProjectEditor {
  ok = (confirm (global 'page') nil 'Discard current project?')
  if (not ok) { return }
  select tabs 'Scripts'
  clearProject this
  createInitialClass scripter
}

method clearProject ProjectEditor {
  // Remove old project morphs and classes and reset global state.

  page = (global 'page')
  stopAll page
  setTargetObj scripter nil
  removeAllParts (morph stage)
  for p (copy (parts (morph page))) {
	// remove explorers, table views -- everything but the ProjectEditor
	if (p != morph) { removePart (morph page) p }
  }
  clearLibrary library

  fileName = ''
  setText title ''
  project = (emptyProject)
  developerModeChanged scripter // clear extensions

  // reset global state (pen trails, stage color, connector state)
  deletePenTrails (morph stage)
  setColor (handler (morph stage)) (gray 240)
  setIsShowingConnectors page (not ('Browser' == (platform))) // show arrows
  refresh connectorToggle
}

method openProjectMenu ProjectEditor {
  examplesPath = (join (absolutePath '.') '/Examples')
  pickFileToOpen (action 'openProjectFromFile' this) examplesPath (array '.gpp' '.gpe')
}

method openProjectFromFile ProjectEditor location {
  // Open a project with the give file path or URL.

  data = (readData (new 'Project') location)
  if (isNil data) {
	error (join 'Could not read: ' location)
  }
  openProject this data location
}

method openProject ProjectEditor projectData projectName {
  clearProject this
  project = (readProject (emptyProject) projectData)
  fileName = projectName
  updateTitle this
  loadPage stage (first (pages project))
  if ((notes project) != '') {
    select tabs 'Notes'
  } else {
	refreshTab this
  }
  developerModeChanged scripter
}

method selectClassAndInstance ProjectEditor aTargetClass {
  // Select an arbitrary instance of a user class to show in the scriptor.
  // if aTargetClass is specified, select an arbitrary instance of it
  if (isNil scripter) { return }
  for m (parts (morph stage)) {
    cl = (classOf (handler m))
    if (or (cl == aTargetClass) (isNil aTargetClass)) {
      if (notNil (scripts cl)) {
        setTargetObj scripter (handler m)
        return
      }
    }
  }
  setTargetObj scripter nil
}

method saveProject ProjectEditor fName {
  if (and (isNil fName) (notNil fileName)) {
	fName = fileName
	if (beginsWith fName (gpExamplesFolder)) {
	  fName = (join (gpFolder) '/' (filePart fileName))
	}
  }

  if (isNil fName) {
	conf = (gpServerConfiguration)
    if (and (notNil conf) ((at conf 'beDefaultSaveLocation') == true)) {
      user = (at conf 'username')
      serverDirectory = (at conf 'serverDirectory')
      fName = (join serverDirectory user '/' (filePart fileName))
    } else {
	  fName = ''
	}
  }
  fName = (fileToWrite fName (array '.gpp' '.gpe'))
  if ('' == fName) { return false }

  if (and
	(not (isAbsolutePath this fName))
	(not (beginsWith fName 'http://'))
	(not (beginsWith fName (gpFolder)))) {
	  fName = (join (gpFolder) '/' fName)
  }
  if (not (or (endsWith fName '.gpp') (endsWith fName '.gpe'))) { fName = (join fName '.gpp') }

  fileName = fName
  updateTitle this
  if (isClass viewer 'MediaViewer') { saveNotes viewer }
  currentPage = (first (pages project))
  thumbnail = (takeThumbnail (morph stage) 400 400)

  unloadPage stage currentPage
  result = (safelyRun (action 'saveProject' project fileName thumbnail))
  loadPage stage currentPage
  if (isClass result 'Task') { // saveProject encountered an error
	addPart (global 'page') (new 'Debugger' result) // open debugger on the task
	return false
  }
  return true
}

method isAbsolutePath ProjectEditor fName {
  // Return true if this string is an absolute file path.
  letters = (letters fName)
  count = (count letters)
  if (and (count >= 1) ('/' == (first letters))) { return true } // Mac, Linux
  if (and (count >= 3) (':' == (at letters 2)) (isOneOf (at letters 3) '/' '\')) {
  	return true // Win
  }
  return false
}

method exportProjectAsApp ProjectEditor {
  extensions = nil
  if ('Mac' == (platform)) { extensions = (array '.app') }
  fName = (fileToWrite (withoutExtension (filePart fileName)) extensions)
  if ('' == fName) { return }

  if (isClass viewer 'MediaViewer') { saveNotes viewer }

  currentPage = (first (pages project))
  unloadPage stage currentPage
  exportApp (new 'AppMaker') project fName
  loadPage stage currentPage
}

method canExportToWeb ProjectEditor {
  conf = (gpServerConfiguration)
  if (isNil conf) { return false }
  user = (at conf 'username')
  serverDirectory = (at conf 'serverDirectory')
  return (and (notNil user) (notNil serverDirectory))
}

method exportProjectToWeb ProjectEditor {
  // Save this project to the web repository via DAV.

  conf = (gpServerConfiguration)
  if (isNil conf) { return }

  user = (at conf 'username')
  serverDirectory = (at conf 'serverDirectory')
  url = (join serverDirectory user '/' (withoutExtension (filePart fileName)))

  fName = (prompt (global 'page') 'Web app name:' (filePart fileName))
  if ('' == fName) { return }
  fName = (join serverDirectory user '/' fName)
  ok = (saveProject this fName)
  if (not ok) { return }

  if (beginsWith fName 'http://') {
	fName = (substring fName 8)
  }
  playURL = (join 'http://gpblocks.org/run/go.html#' fName)
  msg = (join
	(cr) playURL (cr) (cr)
	'Copy URL to clipboard?')
  if (confirm (global 'page') nil msg) {
	setClipboard playURL
  }
}

// project title

method updateTitle ProjectEditor {
  setText title (withoutExtension (filePart fileName))
  redraw title
  centerTitle this
}

method centerTitle ProjectEditor {
  m = (morph title)
  setLeft m (((width morph) - (width m)) / 2)
}

// tabs

method refreshTab ProjectEditor {
  // Update the contents of the current tab.
  select tabs (selection tabs)
}

method showTab ProjectEditor newTab {
  if (notNil viewer) {
	if (isClass viewer 'MediaViewer') { saveNotes viewer }
	removePart morph (morph viewer)
	viewer = nil
  }
  newTab = (selection tabs)
  if ('Scripts' == newTab) {
	newViewer = scripter
	restoreScripts scripter
  } ('Images' == newTab) {
	newViewer = (newMediaViewer project newTab)
  } ('Sounds' == newTab) {
	newViewer = (newMediaViewer project newTab)
  } ('Notes' == newTab) {
	newViewer = (newMediaViewer project newTab)
  }
  if (notNil newViewer) {
	viewer = newViewer
	setWidth (bounds (morph viewer)) viewerWidth
	redraw viewer
	addPart morph (morph viewer)
	addPart morph (morph tabs) // ensure tabs are in front
	fixLayout this
  }
}

// presentation mode

method enterPresentation ProjectEditor {
	page = (global 'page')
	if (notNil (focus (keyboard page))) {
	  cancel (focus (keyboard page))
	  focusOn (keyboard page) nil
	}
	setColor page (gray 0)
	addPart page (morph stage)
	hide morph
	hide (morph scripter) // disable arrows to the scripter
	pageResized stage
}

method exitPresentation ProjectEditor {
	page = (global 'page')
	setColor page (gray 250)
	addPart morph (morph stage)
	goBackBy (morph stage) 100
	show (morph scripter) // enable arrows to the scripter
	show morph
	pageResized this
}

// browser support

method processImportedFiles ProjectEditor {
	pair = (browserGetDroppedFile)
	if (isNil pair) { return }
	fName = (callWith 'string' (first pair))
	data = (last pair)
	processDroppedFile this fName data
}

method processDroppedFiles ProjectEditor {
	for evt (droppedFiles (global 'page')) {
	  fName = (at evt 'file')
	  data = (readFile fName true)
	  if (notNil data) {
		processDroppedFile this fName data
	  }
	}
}

method processDroppedFile ProjectEditor fName data {
	if (endsWith fName '.wav') {
	  addSoundToProject this data fName
	  showTab this 'Sounds'
	} (endsWith fName '.gpp') {
	  ok = (confirm (global 'page') nil 'Discard current project?')
	  if (not ok) { return }
	  while (notNil pair) { pair = (browserGetDroppedFile) } // clear dropped files
	  openProject this data fName
	} (endsWith fName '.mp3') {
	  inform (global 'page') 'Imported sound files must be WAV format.'
	} (endsWith fName '.gp') {
	  eval (toString data) nil (topLevelModule)
	  developerModeChanged scripter  // update block categories (after loading extension)
	} (endsWith fName '.gpe') {
		extension = (readProject (new 'Project') data)
		extensionName = (withoutExtension (filePart fName))
		importExtension project extensionName extension
		developerModeChanged this // update palette
	} else {
	  addImageToProject this data fName
	  showTab this 'Sounds'
	}
}

method checkForBrowserResize ProjectEditor {
  browserSize = (browserSize)
  w = (first browserSize)
  h = (last browserSize)
  winSize = (windowSize)
  if (and (w == (at winSize 1)) (h == (at winSize 2))) { return }
  openWindow w h
  pageM = (morph (global 'page'))
  setExtent pageM w h
  for each (parts pageM) { pageResized (handler each) w h this }
}

method processBrowserMessages ProjectEditor {
  while true {
	msg = (browserGetMessage)
	if (isNil msg) { return }
	if ('go' == msg) {
	  broadcastGo (global 'page')
	} ('stop' == msg) {
	  stopAll (global 'page')
	} ('seeInside' == msg) {
	   exitPresentation this
	   browserPostMessage 'hideButton SeeInsideButton'
	   browserPostMessage 'showButton PresentButton'
	} ('present' == msg) {
	   enterPresentation this
	   browserPostMessage 'showButton SeeInsideButton'
	   browserPostMessage 'hideButton PresentButton'
	}
  }
}

// media management

method importMediaFile ProjectEditor type {
  if ('Browser' == (platform)) {
	browserReadFile
  } else {
	if ('image' == type) {
	  if (isNil imagesFolder) { imagesFolder = (gpFolder) }
	  pickFileToOpen (action 'importImageNamed' this) imagesFolder (array '.png' '.jpg' '.jpeg')
	} ('sound' == type) {
	  if (isNil soundsFolder) { soundsFolder = (gpFolder) }
	  pickFileToOpen (action 'importSoundNamed' this) soundsFolder '.wav'
	}
  }
}

method importImageNamed ProjectEditor fName {
  data = (readFile fName true)
  if (isNil data) { error 'Could not read file' fName }
  addImageToProject this data fName
}

method addImageToProject ProjectEditor data fName {
  // Save an image with the given image data and file name.

  if (isNil data) { return }
  if (isNil fName) { fName = 'Unnamed' }
  imagesFolder = (directoryPart fName)
  if (isPNG data) {
	bm = (readFrom (new 'PNGReader') data)
  } (isJPEG data) {
	bm = (jpegDecode data)
  } else {
	error 'Unrecognized image format'
  }
  desiredSize = 500
  if (or ((width bm) > desiredSize) ((height bm) > desiredSize)) {
	if (confirm (global 'page') nil 'Reduce image size?') {
	  bm = (cropTransparent (thumbnail bm desiredSize desiredSize))
	}
  }
  baseName = (withoutExtension (filePart fName))
  setName bm (uniqueNameNotIn (imageNames project) baseName)
  add (images project) bm
  refreshTab this
}

method saveEditedImage ProjectEditor bm {
  // Save an image from the paint editor.

  imageName = (name bm)
  if (isEmpty imageName){
	imageName = (uniqueNameNotIn (imageNames project) 'image')
	setName bm imageName
  }
  images = (images project)
  oldIndex = nil
  for i (count images) {
	if ((name (at images i)) == imageName) { oldIndex = i }
  }
  if (notNil oldIndex) { // replace existing image
	atPut images oldIndex bm
  } else {
	add (images project) bm
  }
  refreshTab this
}

method importSoundNamed ProjectEditor fName {
  data = (readFile fName true)
  if (isNil data) { error 'Could not read file' fName }
  addSoundToProject this data fName
}

method addSoundToProject ProjectEditor data fName {
  // Import an image with the given file name.

  if (isNil data) { return }
  if (isNil fName) { fName = 'Unnamed' }
  soundsFolder = (directoryPart fName)
  snd = (decodeWAV data)
  if (isNil snd) { error 'Could not read WAV file' fName }
  snd = (shrinkSound snd)
  baseName = (withoutExtension (filePart fName))
  setName snd (uniqueNameNotIn (soundNames project) baseName)
  add (sounds project) snd
  refreshTab this
}

// FPS readout

method addFPSReadout ProjectEditor {
  fpsReadout = (newText '00.0 fps' 'Arial' (10 * (global 'scale')))
  setColor fpsReadout (gray 50)
  addPart morph (morph fpsReadout)
  lastFrameTime = (msecsSinceStart)
  frameCount = 0
  return fpsReadout
}

method step ProjectEditor {
  if ('Browser' == (platform)) {
  	processImportedFiles this
  	checkForBrowserResize this
  	processBrowserMessages this
  }
  processDroppedFiles this
  if (isNil fpsReadout) { return }
  frameCount += 1
  msecs = ((msecsSinceStart) - lastFrameTime)
  if (and (frameCount > 2) (msecs > 200)) {
	fps = ((1000 * frameCount) / msecs)
	setText fpsReadout (join '' (round fps 0.1) ' fps')
	lastFrameTime = (msecsSinceStart)
	frameCount = 0
  }
}

// handle drops

method wantsDropOf ProjectEditor aHandler { return true }

method justReceivedDrop ProjectEditor aHandler {
  if (or (isAnyClass aHandler 'ColorPicker' 'Monitor') (hasField aHandler 'window')) {
	addPart (morph (global 'page')) (morph aHandler)
  } else {
	animateBackToOldOwner (hand (global 'page')) (morph aHandler)
  }
}

// developer mode

method developerModeChanged ProjectEditor {
  devModeParts = (copyFromTo rightItemsRow2 3)
  for p devModeParts {
	if (not (isNumber p)) {
	  if (devMode) {
		show (morph p)
	  } else {
		hide (morph p)
	  }
	}
  }
  developerModeChanged scripter
  fixLayout this
}

// layout

method normalStageSize ProjectEditor {
  scale = (global 'scale')
  viewerWidth = ((width (global 'page')) - (800 * scale))
  viewerWidth = (max viewerWidth (100 * scale))
  setExtent (morph viewer) viewerWidth nil
  fixStageLayout this
}

method rebuild ProjectEditor {
  scale = (global 'scale')

  saveScripts scripter
  oldProject = project
  oldCategory = (currentCategory scripter)
  oldTargetObj = (targetObj scripter)
  oldTab = (selection tabs)
  oldPage = (first (pages project))
  unloadPage stage oldPage

  removeAllParts morph
  viewerWidth = ((width (global 'page')) - (800 * scale))
  viewerWidth = (max viewerWidth (400 * scale))
  addTopBarParts this
  scripter = (initialize (new 'Scripter') this)
  addPart morph (morph scripter)
  stage = (newStage 16 10)
  addPart morph (morph stage)
  library = (initialize (new 'SpriteLibrary') scripter)
  addPart morph (morph library)
  setStageMorph scripter (morph stage)
  tabs = (tabBar (list 'Scripts' 'Images' 'Sounds' 'Notes') nil (action 'showTab' this) (transparent) 12)
  setBGColors tabs (gray 240) (gray 150) (gray 100) // match tab colors to Scripter border and class pane colors
  addPart morph (morph tabs)

  loadPage stage (first (pages project))
  select tabs 'Scripts'
  selectCategory scripter oldCategory
  loadPage stage oldPage
  setTargetObj scripter oldTargetObj
  select tabs oldTab
  developerModeChanged scripter

  drawTopBar this
  fixLayout this
  return this
}

method scaleChanged ProjectEditor {
  rebuild this
}

method pageResized ProjectEditor {
  scale = (global 'scale')
  page = (global 'page')
  newWidth = (width (morph page))
  if (viewerWidth > (newWidth / 2)) {
	viewerWidth = (truncate (newWidth / 2))
  }
  if (newWidth == (1280 * scale)) {
	viewerWidth = (560 * scale)
	setExtent (morph viewer) viewerWidth nil
  }
  viewerWidth = (max viewerWidth (400 * (global 'scale')))
  if (not (isVisible morph)) { // presentation mode
	scaleToFit stage (width page) (height page)
	gotoCenterOf (morph stage) (morph page)
  } else {
	drawTopBar this
	fixLayout this
  }
}

method drawTopBar ProjectEditor {
  w = (width (morph (global 'page')))
  h = (48 * (global 'scale'))
  if ('iOS' == (platform)) { h += (13 * (global 'scale')) }
  oldC = (costumeData morph)
  if (or (isNil oldC) (w != (width oldC)) (h != (height oldC))) {
	setCostume morph (newBitmap w h (gray 200))
  if ('iOS' == (platform)) {
	fillRect (costumeData morph) (gray 255) 0 0 w (16 * (global 'scale')) }
  }
}

method fixLayout ProjectEditor {
  if (isNil tabs) { return }
  setBottom (morph tabs) ((height morph) + (2 * (global 'scale')))
  fixTopBarLayout this
  fixViewerLayout this
  fixStageLayout this
  fixLibraryLayout this
  viewerWidth = (width (morph viewer))
}

method fixTopBarLayout ProjectEditor {
  scale = (global 'scale')
  space = (5 * scale)
  centerTitle this
  setTop (morph title) (5 * scale)
  centerY = (17 * scale)
  if ('iOS' == (platform)) {
	setTop (morph title) (18 * scale)
	centerY += (13 * scale)
  }

  x = (10 * scale)
  for item leftItems {
	if (isNumber item) {
	  x += item
	} else {
	  m = (morph item)
	  y = (centerY - ((height m) / 2))
	  setPosition m x y
	  x += ((width m) + space)
	}
  }
  x = ((width morph) - (10 * scale))
  for item (reversed rightItems) {
	if (isNumber item) {
	  x += (0 - item)
	} else {
	  m = (morph item)
	  y = (centerY - ((height m) / 2))
	  setPosition m (x - (width m)) y
	  x = ((x - (width m)) - space)
	}
  }
  x = ((width morph) - (10 * scale))
  centerY += (20 * scale)
  if (devMode) {
	items = rightItemsRow2
  } else {
	items = (copyFromTo rightItemsRow2 1 2)
  }
  for item (reversed items) {
	if (isNumber item) {
	  x += (0 - item)
	} else {
	  m = (morph item)
	  if (isVisible m) {
		y = (centerY - ((height m) / 2))
		setPosition m (x - (width m)) y
		if (item == fpsReadout) {
		  x = (x - (8 * space))
		} else {
		  x = ((x - (width m)) - space)
		}
	  }
	}
  }
}

method fixViewerLayout ProjectEditor {
  m = (morph viewer)
  setPosition m 0 (bottom morph)
  maxW = (round (4096 / (global 'scale')))
  if ((width m) > maxW) {
	setExtent m maxW (height m)
	viewerWidth = maxW
  }
  newH = (max 1 ((height (morph (global 'page'))) - (top m)))
  if (newH != (height m)) {
	setExtent m viewerWidth newH
  }
}

method fixStageLayout ProjectEditor {
  viewerM = (morph viewer)
  pageM = (morph (global 'page'))
  newW = (max 1 ((width pageM) - (right viewerM)))
  newH = (max 1 ((height pageM) - (top viewerM)))
  scaleToFit stage newW newH
  setPosition (morph stage) (right viewerM) (bottom morph) true
  changed this
}

method fixLibraryLayout ProjectEditor {
  viewerM = (morph viewer)
  stageM = (morph stage)
  pageM = (morph (global 'page'))
  setPosition (morph library) (right viewerM) (bottom stageM) true
  newH = (((height pageM) - (top viewerM)) - (height stageM))
  setExtent (morph library) (width stageM) newH
}
// Prompter.gp - request text or yes/no input from the user

defineClass Prompter morph window textBox textFrame buttons slider answer isDone callback detailsText detailsFrame

method textBox Prompter {return textBox}
method answer Prompter {return answer}
method isDone Prompter {return isDone}

method initialize Prompter label default editRule anAction details {
  scale = (global 'scale')
  answer = ''
  isDone = false
  if (isNil label) {label = 'Prompter'}
  if (isNil default) {default = ''}
  if (isNil editRule) {editRule = 'line'}
  callback = anAction // optional

  window = (window label)
  clr = (clientColor window)
  border = (border window)
  morph = (morph window)
  setHandler morph this
  minW = (titleBarWidth window)
  fontName = 'Arial'
  fontSize = (14 * (global 'scale'))
  if ('Linux' == (platform)) { fontSize = (11 * (global 'scale')) }

  if (notNil details) {
	  detailsText = (newText details fontName fontSize)
	  setEditRule detailsText 'static'
	  setGrabRule (morph detailsText) 'ignore'
	  detailsFrame = (scrollFrame detailsText (transparent) true)
	  setExtent (morph detailsFrame) minW 0
	  wrapLinesToWidth detailsText (width (morph detailsFrame))
	  setExtent (morph detailsFrame) minW (height (morph detailsText))
	  addPart morph (morph detailsFrame)
	  minW = ((width (morph detailsFrame)) + (border * 8))
  }

  textBox = (newText default fontName fontSize)
  setBorders textBox border border true
  minW = (max minW ((width (morph textBox)) + (60 * scale)))
  setEditRule textBox editRule
  setGrabRule (morph textBox) 'ignore'
  textFrame = (scrollFrame textBox clr (== editRule 'line'))
  addPart morph (morph textFrame)

  createButtons this

  if (notNil details) {
	  minH = (+ (height buttons) (height (morph textFrame)) (height (morph detailsFrame)) (border * 4))
	  minH = (+ (scale * 100) (height (morph detailsFrame)) border)
  } else {
	  minW = (clamp minW (scale * 250) (scale * 400))
  	  minH = (scale * 100)
  }

  setExtent morph minW minH
  setMinExtent morph (width morph) (height morph)
}

method initializeForConfirm Prompter label question yesLabel noLabel anAction {
  answer = false
  isDone = false
  if (isNil label) {label = 'Confirm'}
  if (isNil question) {question = ''}
  if (isNil yesLabel) {yesLabel = 'Yes'}
  if (isNil noLabel) {noLabel = 'No'}
  callback = anAction // optional

  window = (window (localized label))
  hide (morph (getField window 'resizer'))
  border = (border window)
  morph = (morph window)
  setHandler morph this

  lbl = (getField window 'label')
  fontSize = (16 * (global 'scale'))
  if ('Linux' == (platform)) { fontSize = (13 * (global 'scale')) }
  textFrame = (newText (localized question) (fontName lbl) fontSize (gray 0) 'center')
  addPart morph (morph textFrame)
  createButtons this (localized yesLabel) (localized noLabel)

  textWidth = (width (morph textFrame))
  buttonWidth = (width buttons)
  labelWidth = (width (morph lbl))
  xBtnWidth = (width (morph (getField window 'closeBtn')))
  w = (max textWidth buttonWidth labelWidth)
  setExtent morph (+ w xBtnWidth (4 * border)) (+ (height (morph lbl)) (height (morph textFrame)) (height (bounds buttons)) (8 * border))
  setMinExtent morph (width morph) (height morph)
}

method initializeForInform Prompter label details okLabel {
  isDone = false

  if (isNil label) {label = 'Information'}
  if (isNil okLabel) {okLabel = 'OK'}

  scale = (global 'scale')
  window = (window (localized label))
  border = (border window)
  morph = (morph window)
  setHandler morph this
  minW = (max (titleBarWidth window) (380 * scale))
  lbl = (getField window 'label')
  fontName = 'Arial Bold'
  fontSize = (18 * (global 'scale'))
  if ('Linux' == (platform)) { fontSize = (15 * (global 'scale')) }

  if ((count (lines details)) == 1) { align = 'center' } else { align = 'left' }

  detailsText = (newText (localized details) fontName fontSize (gray 0) align)
  detailsFrame = (scrollFrame detailsText (transparent) true)
  setExtent (morph detailsFrame) minW 0
  wrapLinesToWidth detailsText (width (morph detailsFrame))
  setExtent (morph detailsFrame) minW (height (morph detailsText))
  addPart morph (morph detailsFrame)
  minW = ((width (morph detailsFrame)) + (border * 10))

  createButtons this (localized okLabel) nil true // single button
  minH = (+ (height (morph lbl)) (height (morph detailsFrame)) (height (bounds buttons)) (4 * border))
  setExtent morph minW minH
  setMinExtent morph (width morph) (height morph)
}

to promptForNumber title anAction minValue maxValue currentValue {
  page = (global 'page')
  p = (new 'Prompter')
  initializeForSlider p title anAction minValue maxValue currentValue
  setCenter (morph p) (x (hand page)) (y (hand page))
  keepWithin (morph p) (insetBy (bounds (morph page)) 50)
  addPart (morph page) (morph p)
  if (isNil anAction) {
    setField (hand page) 'lastTouchTime' nil
    while (not (isDone p)) { doOneCycle page }
    destroy (morph p)
    return (answer p)
  }
}

method initializeForSlider Prompter title anAction minValue maxValue currentValue {
  if (isNil title) {title = 'Number?'}
  if (isNil minValue) { minValue = 0 }
  if (isNil maxValue) { maxValue = 100 }
  if (isNil currentValue) { currentValue = 50 }

  answer = currentValue
  isDone = false
  callback = anAction // optional

  window = (window title)
  hide (morph (getField window 'resizer'))
  border = (border window)
  morph = (morph window)
  setHandler morph this

  scale = (global 'scale')
  slider = (slider 'horizontal' (150 * scale) callback (10 * scale) minValue maxValue currentValue)
  setPosition (morph slider) (20 * scale) (35 * scale)
  addPart morph (morph slider)
  createButtons this 'OK' 'Cancel'

  w = ((width (morph slider)) + (20 * scale))
  setExtent morph (+ w (4 * border)) (+ (height (morph slider)) (height (bounds buttons)) (60 * scale))
  setMinExtent morph (width morph) (height morph)
}

method createButtons Prompter okLabel cancelLabel singleButton {
  if (isNil singleButton) { singleButton = false }
  if (isNil okLabel) {okLabel = 'OK'}
  buttons = (newMorph)
  okButton = (pushButton okLabel (gray 130) (action 'accept' this) nil nil true) // default
  addPart buttons (morph okButton)

  if (not singleButton) {
	  if (isNil cancelLabel) {cancelLabel = 'Cancel'}
	  cancelButton = (pushButton cancelLabel (gray 130) (action 'cancel' this))
	  addPart buttons (morph cancelButton)
	  setPosition (morph cancelButton) (+ (right (morph okButton)) (border window)) (top (morph okButton))
  }

  setBounds buttons (fullBounds buttons)
  addPart morph buttons
}

method redraw Prompter {
  redraw window
  redrawShadow window
  drawInside this
  fixLayout this
}

method drawInside Prompter {
  scale = (global 'scale')
  cornerRadius = (4 * scale)
  fillColor = (gray 230)
  inset = (5 * scale)
  topInset = (24 * scale)
  w = ((width morph) - (2 * inset))
  h = ((height morph) - (topInset + inset))
  pen = (newVectorPen (costumeData morph) morph)
  fillRoundedRect pen (rect inset topInset w h) cornerRadius fillColor
}

method fixLayout Prompter {
  fixLayout window
  clientArea = (clientArea window)
  border = (border window)
  buttonHeight = (height (bounds buttons))
  hPadding = (3 * border)

  setXCenter buttons (hCenter clientArea)
  setBottom buttons ((bottom clientArea) - border)

  if (notNil detailsFrame) {
  	setLeft (morph detailsFrame) ((left clientArea) + hPadding)
	setTop (morph detailsFrame) ((top clientArea) + (2 * border))
	detailsHeight = (((height clientArea) - (height buttons)) - (5 * border))
	if (notNil textBox) {
		detailsHeight = ((detailsHeight - ((height (morph textBox)))) - border)
	}
	if ((alignment detailsText) == 'center') {
		setExtent (morph detailsFrame) (width (extent detailsText))
		setCenter (morph detailsFrame) (hCenter clientArea) ((vCenter clientArea) - border)
	} else {
		setExtent (morph detailsFrame) ((width clientArea) - (2 * hPadding)) detailsHeight
		wrapLinesToWidth detailsText (width (morph detailsFrame))
	}
  }

  if (notNil textFrame) {
	if (notNil slider) {
		setXCenter (morph slider) (hCenter clientArea)
	} (isNil textBox) { // confirmation dialog
		setBottom (morph textFrame) ((top buttons) - (2 * border))
		setXCenter (morph textFrame) (hCenter clientArea)
	} else { // prompter dialog
		if (notNil detailsText) {
		  textHeight = (height (extent textBox))
		  vPadding = (border * 2)
		} (== 'editable' (editRule textBox)) {
		  textHeight = ((height clientArea) - (+ buttonHeight (border * 2)))
		  vPadding = border
		} (== 'line' (editRule textBox)) {
		  textHeight = (height (extent textBox))
		  vPadding = (((height clientArea) - (+ textHeight buttonHeight border)) / 2)
		}
		setLeft (morph textFrame) ((left clientArea) + hPadding)
		setBottom (morph textFrame) ((top buttons) - vPadding)
		setExtent (morph textFrame) ((width clientArea) - (2 * hPadding)) textHeight
	}
  }
}

method accept Prompter {
  if (notNil slider) {
    answer = (value slider)
  } (isNil textBox) { // confirmation dialog
    answer = true
  } else {
    stopEditing textBox
    answer = (text textBox)
  }
  destroy morph
  if (notNil callback) {
    call callback answer
  }
}

method cancel Prompter {
  if (notNil textBox) {stopEditing textBox}
  if (and (notNil slider) (notNil callback) (notNil answer)) {
    call callback answer // restore the original value
  }
  destroy morph
}

method destroyedMorph Prompter {isDone = true}
method accepted Prompter {accept this}
method cancelled Prompter {cancel this}
// Readout  - mixin to readout and manipulate the value of a field

defineClass Readout name target field widget setter value

to readout name target field widget setter {
  return (new 'Readout' name target field widget setter)
}

method morph Readout {return (morph widget)}
method name Readout {return name}

method update Readout {
  if (isAnyClass target 'Dictionary' 'List') {
	v = (at target field)
  } else {
	v =  (getField target field)
  }
  if (v != value) {
    value = v
    call setter widget v
    changed (morph widget)
  }
}
// Rectangle

defineClass Rectangle left top width height

to rect x y w h {
  if (isNil x) {x = 0}
  if (isNil y) {y = 0}
  if (isNil w) {w = 0}
  if (isNil h) {h = 0}
  return (new 'Rectangle' x y w h)
}

// accessing

method left Rectangle {return left}
method setLeft Rectangle aNumber {left = aNumber}
method top Rectangle {return top}
method setTop Rectangle aNumber {top = aNumber}
method width Rectangle {return width}
method setWidth Rectangle aNumber {width = (max 0 aNumber)}
method right Rectangle {return (left + width)}
method setRight Rectangle aNumber {width = (max 0 (aNumber - left))}
method height Rectangle {return height}
method setHeight Rectangle aNumber {height = (max 0 aNumber)}
method bottom Rectangle {return (top + height)}
method setBottom Rectangle aNumber {height = (max 0 (aNumber - top))}
method hCenter Rectangle {return (+ left (width / 2))}
method vCenter Rectangle {return (+ top (height / 2))}
method copy Rectangle {return (rect left top width height)}
method area Rectangle {return (width * height)}

// converting

method toString Rectangle {
  return (join '(rect ' left ' ' top ' ' width ' ' height ')')
}

// equality

method '==' Rectangle other {
  if (this === other) { return true }
  if (not (isClass other 'Rectangle')) {return false}
  if (left != (left other)) {return false}
  if (top != (top other)) {return false}
  if (width != (width other)) {return false}
  if (height != (height other)) {return false}
  return true
}

// functions

method insetBy Rectangle x y {
  // y is optional
  if (isNil y) {y = x}
  return (rect
    (left + x)
    (top + y)
    (width - (x * 2))
    (height - (y * 2)))
}

method expandBy Rectangle x y {
  // y is optional
  if (isNil y) {y = x}
  return (insetBy this (0 - x) (0 - y))
}

method intersect Rectangle another {
  // (command version) - mutates the receiver
  newR = (min (right this) (right another))
  newB = (min (bottom this) (bottom another))
  left = (max left (left another))
  top = (max top (top another))
  setRight this newR
  setBottom this newB
}

method intersection Rectangle another {
  // (reporter version) - answer a new rectangle
  result = (rect (max left (left another)) (max top (top another)))
  setRight result (min (right this) (right another))
  setBottom result (min (bottom this) (bottom another))
  return result
}

method merge Rectangle another {
  // (command version) - mutates the receiver
  newR = (max (right this) (right another))
  newB = (max (bottom this) (bottom another))
  left = (min left (left another))
  top = (min top (top another))
  setRight this newR
  setBottom this newB
}

method mergedWith Rectangle another {
  // (reporter version) - answer a new rectangle
  result = (rect (min left (left another)) (min top (top another)))
  setRight result (max (right this) (right another))
  setBottom result (max (bottom this) (bottom another))
  return result
}

method roundToIntegers Rectangle {
  // Round to integer coordinates.

  left = (floor left)
  top = (floor top)
  width = (ceiling width)
  height = (ceiling height)
  return this
}

// intersecting line segments

method intersectionsWithLineSegment Rectangle x1 y1 x2 y2 {
  line = (array x1 y1 x2 y2)
  right = (right this)
  bottom = (bottom this)
  result = (list)
  lines = (array
    (array left top right top)
    (array left top left bottom)
    (array left bottom right bottom)
    (array right top right bottom)
  )
  for side lines {
    collision = (callWith 'intersectionOfLines' (join side line))
    if (notNil collision) {
      add result collision
      if (== 2 (count result)) {return result}
    }
  }
  return result
}

to intersectionOfLines p0x p0y p1x p1y p2x p2y p3x p3y {
  // return an array containing the x and y coordinates where two line segments
  // intersect, nil if they don't'
  // adapted from http://stackoverflow.com/a/14795484
  s10x = (p1x - p0x)
  s10y = (p1y - p0y)
  s32x = (p3x - p2x)
  s32y = (p3y - p2y)

  denom = ((s10x * s32y) - (s32x * s10y))
  if (denom == 0) {return nil} // collinear
  denomPositive = (denom > 0)

  s02x = (p0x - p2x)
  s02y = (p0y - p2y)
  sNumber = ((s10x * s02y) - (s10y * s02x))
  if ((sNumber < 0) == denomPositive) {return nil} // no collision

  tNumber = ((s32x * s02y) - (s32y * s02x))
  if ((tNumber < 0) == denomPositive) {return nil} // no collision

  if (or (== denomPositive (sNumber > denom)) (== denomPositive (tNumber > denom))) {return nil} // no collision

  // collision detected
  t = ((toFloat tNumber) / (toFloat denom))
  return (array (p0x + (toInteger (t * (toFloat s10x)))) (p0y + (toInteger (t * (toFloat s10y)))))
}

// testing

method containsPoint Rectangle x y {
  if (x <= left) {return false}
  if (x > (right this)) {return false}
  if (y <= top) {return false}
  return (y <= (bottom this))
}

method containsRectangle Rectangle another {
  return (and
    (containsPoint this (left another) (top another))
    (containsPoint this (right another) (bottom another))
  )
}

method intersects Rectangle another {
  if ((right another) < left) {return false}
  if ((bottom another) < top) {return false}
  if ((left another) > (right this)) {return false}
  return ((top another) <= (bottom this))
}

// transforming

method translateBy Rectangle factor yFactor {
  // modify me inline, yFactor is optional
  if (isNil yFactor) {yFactor = factor}
  left += factor
  top += yFactor
}

method translatedBy Rectangle factor yFactor {
  // answer a new rectangle, yFactor is optional
  if (isNil yFactor) {yFactor = factor}
  return (rect (left + factor) (top + yFactor) width height)
}

method scaledBy Rectangle factor {
  return (rect (left * factor) (top * factor) (width * factor) (height * factor))
}

method scaledAndRotatedBoundingBox Rectangle xFactor yFactor degrees centerX centerY {
  // answer new absolute boundingBox
  if (isNil yFactor) {yFactor = xFactor}
  if (isNil degrees) {degrees = 0}
  if (isNil centerX) {centerX = (hCenter this)}
  if (isNil centerY) {centerY = (vCenter this)}
  p1 = (scaleAndRotateAround left top degrees centerX centerY xFactor yFactor)
  p2 = (scaleAndRotateAround (right this) top degrees centerX centerY xFactor yFactor)
  p3 = (scaleAndRotateAround (right this) (bottom this) degrees centerX centerY xFactor yFactor)
  p4 = (scaleAndRotateAround left (bottom this) degrees centerX centerY xFactor yFactor)
  box = (rect
    (min (first p1) (first p2) (first p3) (first p4))
    (min (last p1) (last p2) (last p3) (last p4))
  )
  setRight box (max (first p1) (first p2) (first p3) (first p4))
  setBottom box  (max (last p1) (last p2) (last p3) (last p4))
  return box
}

to scaleAndRotateAround x y degrees centerX centerY scaleX scaleY {
  // scale first, then rotate
  if (isNil centerX) {centerX = 0}
  if (isNil centerY) {centerY = 0}
  if (isNil scaleX) {scaleX = 1}
  if (isNil scaleY) {scaleY = scaleX}
  xd = (scaleX * (x - centerX))
  yd = (scaleY * (y - centerY))
  if (degrees == 0) {
	return (array (centerX + xd) (centerY + yd))
  }
  dist = (sqrt (+ (* xd xd) (* yd yd)))
  dir = ((atan yd xd) - degrees)
  return (array (centerX + (dist * (cos dir))) (centerY + (dist * (sin dir))))
}
// Used to compare morphic rendering to drawing a display list of bitmaps.

defineClass RenderTest displayList

method displayList RenderTest { return displayList }

to newRenderTest {
  return (new 'RenderTest' (list))
}

// Capture the pixels drawn by one frame of the morphic event loop

method capture RenderTest {
  // Build a display list for the current page.

  page = (global 'page')
  displayList = (list)
  draw (morph page) this
  draw (morph (hand page)) this
}

method drawBitmap RenderTest aBitmap x y {
  if (not (isClass aBitmap 'Bitmap')) { error 'not bitmap' }
  add displayList (array aBitmap x y false)
}

method fillRect RenderTest aColor x y w h {
  if (not (isClass aColor 'Color')) { error 'not color' }
  add displayList (array (newBitmap w h aColor) x y false)
}

method warpBitmap RenderTest aBitmap centerX centerY scaleX scaleY rotation {
  if (not (isClass aBitmap 'Bitmap')) { error 'not bitmap' }
  if (0 != rotation)  { error 'non-zero rotation' }
  dstW = (scaleX * (width aBitmap))
  dstH = (scaleY * (height aBitmap))
  scaledBM = (thumbnail aBitmap dstW dstH)
  add displayList (array scaledBM x y false)
}

method countPixels RenderTest {
  // Return the total number of pixels captured.

  count = 0
  for entry displayList {
	bm = (first entry)
	count += ((width bm) * (height bm))
  }
  return count
}

// Benchmarking

method timeDisplayList RenderTest {
  count = 0
  t = (newTimer)
  while ((msecs t) < 1000) {
	for entry displayList {
	  bm = (first entry)
	  x = (at entry 2)
	  y = (at entry 3)
	  drawBitmap nil bm x y
	}
	count += 1
  }
  msecs = (msecs t)
  print 'display list' ((count * 1000) / msecs) 'fps;' count 'frames in' msecs 'msecs'
}

method timeMorphic RenderTest {
  page = (global 'page')
  count = 0
  t = (newTimer)
  while ((msecs t) < 1000) {
	draw (morph page) nil
	draw (morph (hand page)) nil
	count += 1
  }
  msecs = (msecs t)
  print 'morphic' ((count * 1000) / msecs) 'fps;' count 'frames in' msecs 'msecs'
}

method benchmark RenderTest {
  capture this
  timeMorphic this
  timeDisplayList this
}
// ScaledImage - Scaled image for presentations

defineClass ScaledImage morph image imgScale centerOnPage resizeStartY originalHeight

method morph ScaledImage { return morph }

to showImage aBitmap {
  // Example: showImage (newBitmap 100 100 (randomColor)

  result = (newScaledImage aBitmap)
  addPart (global 'page') result
  return result
}

to newScaledImage fileNameOrBitmap {
  result = (new 'ScaledImage' (newMorph) nil 1 false)
  setHandler (morph result) result
  setGrabRule (morph result) 'ignore'
  if (isClass fileNameOrBitmap 'String') {
	readFile result fileNameOrBitmap
  } (isClass fileNameOrBitmap 'Bitmap') {
	setImage result fileNameOrBitmap
  } else {
	setImage result (newBitmap 100 160 (randomColor))
  }
  setPosition (morph result) 100 100
  return result
}

method setImage ScaledImage bm {
  image = bm
  imgScale = 1
  redraw this
  return this
}

method setScale ScaledImage newScale {
  imgW = (max 1 (width image))
  imgH = (max 1 (height image))
  minScale = (min 1 (5 / (min imgW imgH)))
  maxScale = (max 1 (4000 / (max imgW imgH)))
  centerP = (rotationCenter morph)
  imgScale = (clamp newScale minScale maxScale)
  redraw this
  placeRotationCenter morph (first centerP) (last centerP)
  fixCentering this
}

// menu

method contextMenu ScaledImage {
  menu = (menu nil (action 'menuSelection' this) true)
  addItem menu 'bigger'
  addItem menu 'smaller'
  addItem menu 'normal size'
  addLine menu
  addItem menu 'center on page'
  addItem menu 'don''t center'
  addLine menu
  addItem menu 'read file'
  return menu
}

method menuSelection ScaledImage sel {
  factor = 2
  if ('bigger' == sel) { setScale this (factor * imgScale) }
  if ('smaller' == sel) { setScale this ((1.0 / factor) * imgScale) }
  if ('normal size' == sel) { setScale this 1.0 }
  if ('center on page' == sel) {
	centerOnPage = true
	fixCentering this
  }
  if ('don''t center' == sel) { centerOnPage = false }
  if ('read file' == sel) {
	fileName = (pickFileToOpen nil '' (array 'png' 'jpg'))
	if ('' != fileName) {
		readFile this fileName
		setScale this 1
	}
  }
}

method readFile ScaledImage fileName {
  data = (readFile fileName true)
  if (notNil data) {
	if (isPNG data) {
	  setImage this  (readFrom (new 'PNGReader') data)
	} (isJPEG data) {
	  setImage this  (jpegDecode data)
	} else {
	  error 'Unrecognized image format'
	}
  }
}

method fixCentering ScaledImage {
  if (true == centerOnPage) {
  	presentationWidth = (width (morph (global 'page')))
  	setLeft morph ((presentationWidth - (width morph)) / 2)
  }
}

method redraw ScaledImage {
  if (isNil imgScale) { imgScale = 1 }
  setCostume morph (scaleAndRotate image (imgScale * (global 'scale')))
}

// events

method rightClicked ScaledImage aHand {
  popUpAtHand (contextMenu this) (page aHand)
  return true
}

method handDownOn ScaledImage hand {
  if (shiftKeyDown (keyboard (page hand))) {
	resizeStartY = (y hand)
	originalHeight = (height (bounds morph))
	focusOn hand this
  } else {
	grab hand this
  }
  return true
}

method handMoveFocus ScaledImage hand {
  imgH = (max 1 (height image))
  minScale = (min 1 (5 / imgH))
  maxScale = (max 1 (4000 / imgH))
  newScale = ((originalHeight + (resizeStartY - (y hand))) / imgH)
  newScale = (clamp newScale minScale maxScale)
  setScale this newScale
}

method pageResized ScaledImage {
  fixCentering this
}
defineClass Schedule action when repeat timer

to schedule action inMsecs repeat {
  if (isNil inMsecs) {inMsecs = 0} // immediately, i.e. at the next step
  if (isNil repeat) {repeat = 1}
  return (new 'Schedule' action inMsecs repeat (newTimer))
}

method op Schedule {
  // Return the function name of my first action.
  if (isClass action 'Array') {
	return (function (first action))
  }
  return (function action)
}

method args Schedule {
  // Return the arguments to the function name of my first action.
  return (arguments action)
}

method step Schedule {
  if (or (isDone this) (when > (msecs timer))) {return}
  if (isClass action 'Array') {
    for each action {call each}
  } else {
    call action
  }
  if (isClass repeat 'Integer') {
    repeat += -1
  }
  reset timer
}

method isDone Schedule {
  return (or
    (repeat == 0)
    (and
      (isAnyClass repeat 'Action' 'Function' 'String')
      (not (call repeat))
    )
  )
}
// ScorePlayer.gp
// A ScorePlayer plays one or more voices on a synthesized instrument.
// Each voice is a sequence of ScoreNotes.

defineClass ScoreNote startTime key velocity duration

method key ScoreNote { return key }
method velocity ScoreNote { return velocity }
method duration ScoreNote { return duration }
method startTime ScoreNote { return startTime }
method endTime ScoreNote { return (startTime + duration) }

method setKey ScoreNote k { key = k }
method setStartTime ScoreNote t { startTime = t }
method setDuration ScoreNote dur { duration = dur }

to newScoreNote t key vel dur {
  return (new 'ScoreNote' t key vel dur)
}

defineClass ScorePlayer defaultInstrument instruments voices isMuted voiceIndex speed msecsPerBeat startTime prevTime endTime

method instruments ScorePlayer { return instruments }
method trackCount ScorePlayer { return (count voices) }
method voices ScorePlayer { return voices }
method tempo ScorePlayer { return (round (100 * speed)) }

method setTempo ScorePlayer beatsPerMinute {
  speed = (beatsPerMinute / 100)
  msecsPerBeat = (round (60000 / beatsPerMinute))
}

to newScorePlayer defaultInstrument beatsPerMinute {
   return (initialize (new 'ScorePlayer') defaultInstrument beatsPerMinute)
}

method initialize ScorePlayer defaultInstr beatsPerMinute {
  if (isNil defaultInstr) { defaultInstr = (newSampledInstrument 'guitar') }
  if (isNil beatsPerMinute) { beatsPerMinute = 100 }
  defaultInstrument = defaultInstr
  instruments = (list)
  voices = (list)
  isMuted = (list)
  voiceIndex = (list)
  setTempo this beatsPerMinute
  startTime = 0
  return this
}

method addVoice ScorePlayer v instr {
  // Add a voice (a list of ScoreNotes) to the score.
  add voices v
  if (isNil instr) {
	add instruments defaultInstrument
  } else {
	add instruments instr
  }
  add isMuted false
}

method instrumentForTrack ScorePlayer n {
  n = (toInteger n)
  if (or (n < 1) (n > (count instruments))) { return }
  return (instrumentName (at instruments n))
}

method setInstrumentForTrack ScorePlayer n instrName {
  n = (toInteger n)
  if (or (n < 1) (n > (count instruments))) { return }
  atPut instruments n (newSampledInstrument instrName)
}

method isTrackMuted ScorePlayer n {
  n = (toInteger n)
  if (or (n < 1) (n > (count isMuted))) { return }
  return (at isMuted n)
}

method setTrackMuted ScorePlayer n bool {
  n = (toInteger n)
  if (or (n < 1) (n > (count isMuted))) { return }
  return (atPut isMuted n (true == bool))
}

method notesForTrack ScorePlayer n {
  n = (toInteger n)
  if (or (n < 1) (n > (count voices))) { return (list) }
  return (at voices n)
}

method scoreTime ScorePlayer {
  mixer = (getMixer)
  fudgeFactor = (700 * ((count (getField mixer 'buffer')) / 4096))
  if (not (isPlaying mixer this)) { return 0 }
  approximateTime = (speed * (((estimatedMSecs mixer) - startTime) - fudgeFactor))
  return (max 0 (round approximateTime))
}

method playScore ScorePlayer {
  mixer = (getMixer)
  step mixer // ensure mixer is running
  voiceIndex = (newArray (count voices) 1)
  startTime = (msecs mixer)

  // set the start time to be the first multiple of msecsPerBeat after nextBufferTime
  nextBufferTime = (nextMSecs mixer)
  startTime = ((ceiling (nextBufferTime / msecsPerBeat)) * msecsPerBeat)

  prevTime = 0
  endTime = 0 // computed dynamically
  addSound mixer this

  if (notNil (global 'page')) {
	while (isPlaying mixer this) {
	  waitMSecs 10
	}
  } else {  // running in the command prompt
	while (hasPlayingSounds mixer) {
	  step mixer
	  waitMSecs 10
	}
  }
}

// sample generation (mixer API)

method sound ScorePlayer { return this }

method isDone ScorePlayer {
  for v (count voices) {
    if ((at voiceIndex v) <= (count (at voices v))) { return false }
  }
  mixer = (getMixer)
  t = ((msecs mixer) - startTime)
  return (t >= endTime)
}

method mixIntoBuffer ScorePlayer buffer {
  // Start new notes.
  mixer = (getMixer)
  t = (round (speed * ((msecs mixer) - startTime)))
  bufferMSecs = (round (2 * ((count buffer) / 22.05)))
  for v (count voices) {
	voice = (at voices v)
	instr = (at instruments v)
	voiceEnd = (count voice)
	i = (at voiceIndex v)
	while (and (i <= voiceEnd) ((startTime (at voice i)) < t)) {
	  evt = (at voice i)
	  // endTime determines how long the ScorePlayer waits after submitting the last note to the mixer
	  // make this a buffer plus a beat shorter than the last note duration to allow the next
	  // block to start a ScorePlayer that begins on the next beat boundary.
	  endTime = (max endTime ((t + (duration evt)) - (bufferMSecs + msecsPerBeat))) // xxx adjust for speed
	  delaySamples = (round (22.05 * ((startTime evt) - prevTime)))
	  delaySamples = (round (delaySamples / speed))
	  keyOrChord = (key evt)
	  if (not (at isMuted v)) {
		if (isAnyClass keyOrChord 'Array' 'List') {
		  for pair keyOrChord {
			k = (first pair)
			if (k > 0) {
			  dur = (floor ((last pair) / speed))
			  note = (notePlayer instr k dur (velocity evt))
			  setStartDelay note delaySamples
			  mixIntoBuffer note buffer
			  addSound mixer note
			}
		  }
		} (keyOrChord > 0) { // single note (not a chord and not a rest)
		  dur = (floor ((duration evt) / speed))
		  note = (notePlayer instr keyOrChord dur (velocity evt))
		  setStartDelay note delaySamples
		  mixIntoBuffer note buffer
		  addSound mixer note
		}
	  }
	  i += 1
	}
	atPut voiceIndex v i
  }
  prevTime = t
}

method totalScoreTime ScorePlayer {
  // Return the total score time in seconds.
  totalTime = 0
  for v voices {
	for evt v {
	  if ((endTime evt) > totalTime) { totalTime = (endTime evt) }
	}
  }
  return (totalTime / (1000.0 * speed))
}

method generateAllSamples ScorePlayer keepFlag {
  // Generate all the samples for this score. Used for performance testing.
  // If keepFlag is true, return a list of buffers containing the generated sound.

  if (isNil keepFlag) { keepFlag = false }
  voiceIndex = (newArray (count voices) 1)
  buffer = (newArray 200 0)
  scoreTime = 0
  playingNotes = (list)
  isPlaying = true
  if keepFlag { result = (list) }

  while (or isPlaying ((count playingNotes) > 0)) {
	isPlaying = false
	for v (count voices) {
	  voice = (at voices v)
	  instr = (at instruments v)
	  voiceEnd = (count voice)
	  i = (at voiceIndex v)
	  if (i <= voiceEnd) { isPlaying = true }
	  while (and (i <= voiceEnd) ((startTime (at voice i)) < scoreTime)) {
		evt = (at voice i)
		keyOrChord = (key evt)
		if (not (at isMuted v)) {
		  if (isAnyClass keyOrChord 'Array' 'List') {
			for pair keyOrChord {
			  k = (first pair)
			  if (k > 0) {
				dur = (floor ((last pair) / speed))
				note = (notePlayer instr k dur (velocity evt))
				setStartDelay note 0
				add playingNotes note
			  }
			}
		  } (keyOrChord > 0) { // single note (not a chord and not a rest)
			dur = (floor ((duration evt) / speed))
			note = (notePlayer instr keyOrChord dur (velocity evt))
			setStartDelay note 0
			add playingNotes note
		  }
		}
		i += 1
	  }
	  atPut voiceIndex v i
	}
	for n (copy playingNotes) {
	  mixIntoBuffer n buffer
	  if (isDone n) { remove playingNotes n }
	}
	if keepFlag {
	  add result buffer
	  buffer = (newArray (count buffer) 0)
	}
	scoreTime += (round (speed * ((count buffer) / 22.050)))
  }
  if keepFlag {
	allSamples = (callWith 'join' (toArray result))
	return (newSound allSamples 22050 false)
  }
}
// Widget to select and grab a bitmap from the screen.

defineClass ScreenGrabber morph mode grabAction

to screenGrab action {
  grabber = (initialize (new 'ScreenGrabber') action)
  setPosition (morph grabber) (handX) (handY)
  addPart (global 'page') (morph grabber)
  focusOn (hand (global 'page')) grabber
}

method initialize ScreenGrabber action {
  mode = 'move'
  grabAction = action
  scale = (global 'scale')
  morph = (newMorph this)
  setExtent morph (14 * scale) (14 * scale)
  setTransparentTouch morph true
  setGrabRule morph 'ignore'
  redraw this
  return this
}

method redraw ScreenGrabber {
  color = (color 200 0 200)
  w = (width morph)
  h = (height morph)
  bm = (newBitmap w h)
  fillRect bm color 0 0 2 h
  fillRect bm color (w - 2) 0 2 h
  fillRect bm color 0 0 w 2
  fillRect bm color 0 (h - 2) w 2
  setCostume morph bm
}

method handDownOn ScreenGrabber hand {
  // Start dragging to resize.
  mode = 'resize'
  focusOn hand this
  return true
}

method handMoveFocus ScreenGrabber hand {
  x = (x hand)
  y = (y hand)
  if ('move' == mode) {
	setPosition morph x y
  } else {
	if (or (x < (left morph)) (y < (top morph))) {
	  setPosition morph x y
	}
	scale = (global 'scale')
	w = (max (14 * scale) (x - (left morph)))
	h = (max (14 * scale) (y - (top morph)))
	setExtent morph w h
  }
  return true
}

method handUpOn ScreenGrabber hand {
  // If resizing, grab the screen area and exit.
  if ('resize' == mode) {
	if (notNil grabAction) {
	  inset = (2 * (global 'scale'))
	  bm = (takeSnapshotWithBounds (morph (global 'page')) (insetBy (bounds morph) inset))
	  call grabAction bm
	}
	removeFromOwner morph
  }
  return true
}
// ScriptEditor -- Supports constructing and editing block scripts by drag-n-drop.

defineClass ScriptEditor morph feedback scale focus lastDrop

to newScriptEditor width height {
  return (initialize (new 'ScriptEditor') width height)
}

method initialize ScriptEditor width height {
  morph = (newMorph this)
  setExtent morph width height
  setMinExtent morph 100 150
  feedback = (newMorph)
  scale = (global 'scale')
  return this
}

// stepping

method step ScriptEditor {
  hide feedback
  hand = (hand (handler (root morph)))
  if (containsPoint (bounds morph) (left (morph hand)) (top (morph hand))) {
    load = (grabbedObject hand)
    if (isClass load 'Block') {updateFeedback this load hand}
  }
  updateHighlights this
}

// events

method wantsDropOf ScriptEditor aHandler {
  return (or
    (isAnyClass aHandler 'Block' 'CommandSlot')
    (and
      (devMode)
      (isClass aHandler 'Text')
      (== 'code' (editRule aHandler))))
}

method justReceivedDrop ScriptEditor aHandler {
  scriptChanged this
}

method rightClicked ScriptEditor aHand {
  popUpAtHand (contextMenu this) (page aHand)
  return true
}

method justGrabbedPart ScriptEditor part {
  if (isClass (handler (owner morph)) 'ScrollFrame') {
    updateSliders (handler (owner morph))
  }
}

method clicked ScriptEditor hand {
  kbd = (keyboard (page hand))
  if (and (devMode) (keyDown kbd 'space')) {
    txt = (newText '' 'Arial' ((global 'scale') * 12) (gray 0))
    setEditRule txt 'code'
    setGrabRule (morph txt) 'ignore'
    setCenter (morph txt) (x hand) (y hand)
    addPart morph (morph txt)
    edit txt hand
    return true
  } (shiftKeyDown kbd) {
    edit this this nil (x hand) (y hand)
    return true
  } (notNil focus) {
    cancel focus
    return true
  }
  return false
}

method textChanged ScriptEditor text {
  if ('code' == (editRule text)) {
    if ('' == (text text)) {
      destroy (morph text)
      return
    }
	if (beginsWith (text text) '(') {
	  parsed = (parse (text text))
	} else {
	  parsed = (parse (join '{' (text text) '}'))
	}
    if (isEmpty parsed) {
      literal = (parse (text text))
      if (isEmpty literal) {
        setColor text (color 180 0 0)
      } else {
        setColor text (color 0 0 180)
      }
      setGrabRule (morph text) 'handle'
    } else {
      element = (at parsed 1)
      if (isClass element 'Command') {
        element = (at (parse (join '{' (newline) (text text) (newline) '}')) 1)
      }
      if ('method' == (primName element)) {
		args = (toList (argList element))
		methodName = (removeFirst args)
		methodClass = (class (removeFirst args))
		methodBody = (removeLast args)
		methodParams = (join (array 'this') args)
		func = (addMethod methodClass methodName methodParams methodBody)
        block = (scriptForFunction func)
      } else {
        block = (toBlock element)
      }
      addSchedule (global 'page') (newAnimation 1.0 1.2 200 (action 'setScaleAround' (morph text) (left (morph text)) (top (morph text))) (action 'swapBlockForText' this block text) true)
      return
    }
  }
  raise morph 'textChanged' text
}

method layoutChanged ScriptEditor { changed morph }

// swapping blocks for text

method swapBlockForText ScriptEditor block text {
  setPosition (morph block) (left (morph text)) (top (morph text))
  addPart morph (morph block)
  fixBlockColor block
  destroy (morph text)
  snap block
}

method swapTextForBlock ScriptEditor text block hand {
  setPosition (morph text) (left (morph block)) (top (morph block))
  addPart morph (morph text)
  edit text hand
  destroy (morph block)
}

// snapping

method targetFor ScriptEditor block x y {
  // answer a snapping target or nil
  if ((type block) == 'reporter') {return (inputFor this block x y)}
  isHatSrc = (== (type block) 'hat')
  scale = (blockScale)
  thres = (15 * scale)
  x = (left (morph block))
  y = (top (morph block))
  yb = (bottom (morph (bottomBlock block)))
  others = (reversed (allMorphs morph))
  remove others morph
  remove others (morph block)
  for i (count others) {
    b = (at others i)
    if (and (isClass (handler b) 'Block') (isNil (function (handler b)))) {
      if isHatSrc {
        if (and ((type (handler b)) == 'command') (this === (handler (owner b)))) { // top of stack
          xd = (abs (x - (left b)))
          yd = (abs ((top b) - yb))
          if (and (xd < thres) (yd < thres)) {return (array (handler b))}
        }
      } else {
        if ((type (handler b)) == 'command') {
          xd = (abs (x - (left b)))
          yd = (abs (y - (bottom b)))
          if (and (xd < thres) (yd < thres)) {return (handler b)}
          if (this === (handler (owner b))) { // top of stack
            yd = (abs ((top b) - yb))
            if (and (xd < thres) (yd < thres)) {return (array (handler b))}
          }
        } ((type (handler b)) == 'hat') {
          xd = (abs (x - (left b)))
          yd = (abs (y - (bottom b)))
          if (and (xd < thres) (yd < thres)) {return (handler b)}
        }
      }
    } (and (not isHatSrc) (isClass (handler b) 'CommandSlot')) {
      xd = (abs (x - (+ (scaledCorner (handler b)) (left b))))
      yd = (abs (y - (+ (scaledCorner (handler b)) (top b))))
      if (and (xd < thres) (yd < thres)) {return (handler b)}
    }
  }
  return nil
}

method inputFor ScriptEditor block x y {
  // answer an input (slot or reporter) for dropping the block or nil
  area = (bounds (morph block))
  others = (reversed (allMorphs morph))
  remove others morph
  removeAll others (allMorphs (morph block))
  if (notNil x) {
    for i (count others) {
      b = (at others i)
      if (isAnyClass (handler b) 'InputSlot' 'BooleanSlot' 'ColorSlot') {
        bounds = (bounds b)
        if (and (isReplaceableByReporter (handler b)) (containsPoint bounds x y)) {
          return (handler b)
        }
      }
    }
  }
  for i (count others) {
    b = (at others i)
    if (or
        (and (isReplaceableByReporter (handler b)) (isAnyClass (handler b) 'InputSlot' 'BooleanSlot' 'ColorSlot'))
        (and
          (isClass (handler b) 'Block')
          ((type (handler b)) == 'reporter')
          (isClass (handler (owner b)) 'Block')
          ((grabRule b) != 'template')
          (not (isPrototype (handler b)))
        )
      ) {
      bounds = (bounds b)
      if (intersects bounds area) {
        return (handler b)
      }
    }
  }
  return nil
}

method updateFeedback ScriptEditor block hand {
  hide feedback
  if (isNil block) {return}
  trgt = (targetFor this block (x hand) (y hand))
  if (notNil trgt) {
    if ((type block) != 'reporter') { // command or hat types
      showCommandDropFeedback this trgt
    } ((type block) == 'reporter') {
      showReporterDropFeedback this trgt
    }
    addPart morph feedback // come to front
    show feedback
  }
}

method showCommandDropFeedback ScriptEditor target {
  setHeight (bounds feedback) (scale * 5)
  if (isClass target 'Block') {
    nb = (next target)
    top = (bottom (morph target))
    if (notNil nb) {top = (bottomLine target)}
    setPosition feedback (left (morph target)) top
  } (isClass target 'Array') {
    target = (at target 1)
    top = ((top (morph target)) - (height feedback))
    setPosition feedback (left (morph target)) top
  } (isClass target 'CommandSlot') {
    nb = (nested target)
    top = (+ (top (morph target)) (scaledCorner target))
    if (isNil nb) {top += (scaledCorner target)}
    setPosition feedback (+ (scaledCorner target) (left (morph target))) top
  }
  setCostume feedback (newBitmap (width (morph target)) (scale * 5) (gray 255))
}

method showReporterDropFeedback ScriptEditor target {
  setBounds feedback (expandBy (bounds (morph target)) (12 * scale))
  area = (rect 0 0 (width feedback) (height feedback))
  radius = (10 * scale)
  border = (3 * scale)
  fillColor = (gray 255 150) // translucent
  borderColor = (gray 255)
  bm = (newBitmap (width area) (height area))
  fillRoundedRect (newShapeMaker bm) area radius fillColor border borderColor borderColor
  setCostume feedback bm
}

// context menu

method contextMenu ScriptEditor {
  menu = (menu nil this)
  addItem menu 'set block size...' 'setBlockSize' 'make blocks smaller'
  addLine menu
  addItem menu 'clean up' 'cleanUp' 'arrange scripts'
  if (notNil lastDrop) {
    addItem menu 'undrop' 'undrop' 'undo last drop'
  }
  addLine menu
  addItem menu 'set exported script scale' 'setExportedScriptScale'
  addItem menu 'save picture of all scripts' 'saveScriptsImage'
  addItem menu 'copy all scripts to clipboard' 'copyScriptsToClipboard'
  clip = (readClipboard)
  if (beginsWith clip 'GP Scripts') {
	addItem menu 'paste scripts' 'pasteScripts'
  } (beginsWith clip 'GP Script') {
	addItem menu 'paste script' 'pasteScripts'
  }
  cb = (ownerThatIsA morph 'ClassBrowser')
  if (notNil cb) {
    if (wasEdited (handler cb)) {
      addLine menu
      addItem menu 'save changes' (action 'saveEditedFunction' (handler cb))
      addItem menu 'revert' (action 'revertEditedFunction' (handler cb))
    }
  }
  return menu
}

method cleanUp ScriptEditor {
  order = (function m1 m2 {return ((top m1) < (top m2))})
  alignment = (newAlignment 'multi-line' nil 'fullBounds' order)
  setPadding alignment (20 * (blockScale))
  setVPadding alignment (20 * (blockScale))
  setMorph alignment morph
  fixLayout alignment
}

method setBlockSize ScriptEditor {
  menu = (menu nil (action 'setBlockScalePercent' this) true)
  currentPercent = ((global 'blockScale') * 100)
  for percent (list 50 75 100 125 150 200 250) {
	  if (currentPercent == percent) {
	  	addItem menu (join '' percent '% â') percent
	  } else {
	  	addItem menu (join '' percent '%') percent
	  }
  }
  popUpAtHand menu (global 'page')
}

method setBlockScalePercent ScriptEditor percent {
  if (or (percent < 25) (percent > 300)) { return }
  pe = (findProjectEditor)
  oldBlockScale = (global 'blockScale')
  if (notNil pe) {
	setGlobal 'blockScale' (percent / 100)
	languageChanged pe
	saveToUserPreferences pe 'blockSizePercent' percent
  }
  factor = ((global 'blockScale') / oldBlockScale)
  if (1 == factor) { return }

  originX = (left morph)
  originY = (top morph)
  for m (parts morph) {
	if (isClass (handler m) 'Block') {
	  dx = (round (factor * ((left m) - originX)))
	  dy = (round (factor * ((top m) - originY)))
	  setPosition m (originX + dx) (originY + dy)
    }
  }
  if (isClass (parentHandler morph) 'ScrollFrame') {
    updateSliders (parentHandler morph)
  }
}

// highlighting

method updateHighlights ScriptEditor {
  scripter = (ownerThatIsA morph 'Scripter')
  if (and (isNil scripter) (notNil (ownerThatIsA morph 'MicroBlocksScripter'))) { return }
  if (notNil scripter) { targetObj = (targetObj (handler scripter)) }
  taskMaster = (getField (page morph) 'taskMaster')
  for m (parts morph) {
    if (isClass (handler m) 'Block') {
      tasks = (numberOfTasksRunning taskMaster  (expression (handler m)) targetObj)
      if (tasks > 0) {
        addHighlight m
        if (tasks > 1) {
          st = (getStackPart m)
          if (isNil st) {
            addStackPart m (scale * 6) 2
          }
          sp = (getSignalPart m)
          if (isNil sp) {
            addSignalPart m tasks
          } ((param sp) != tasks) {
            removeSignalPart m
            addSignalPart m tasks
          }
        } else {
          removeSignalPart m
        }
      } else {
        removeSignalPart m
        removeStackPart m
        removeHighlight m
      }
    }
  }
}

// auto-resizing

method adjustSizeToScrollFrame ScriptEditor scrollFrame {
  box = (copy (bounds (morph scrollFrame)))
  area = (scriptsArea this)
  if (notNil area) {
    merge box (expandBy area (50 * (global 'scale')))
  }
  setBounds morph box
}

method scriptsArea ScriptEditor {
  area = nil
  for m (parts morph) {
    if (isNil area) {
      area = (fullBounds m)
    } else {
      merge area (fullBounds m)
    }
  }
  return area
}

// serialization

method preSerialize ScriptEditor {
  setCostume morph nil
  setCostume feedback nil
}

method postSerialize ScriptEditor {
  redraw (handler feedback)
}

// keyboard editing

method edit ScriptEditor elementOrNil aFocus x y {
  page = (page morph)
  stopEditing (keyboard page)
  focus = aFocus
  if (isNil focus) {focus = (initialize (new 'ScriptFocus') this elementOrNil x y)}
  if (and (notNil x) (notNil y)) {setCenter (morph focus) x y}
  focusOn (keyboard page) focus
  scriptChanged this
}

method startEditing ScriptEditor {
  page = (page morph)
  inset = (50 * (global 'scale'))
  sorted = (sortedScripts this)
  if (notEmpty sorted) {
    elem = (first sorted)
  } else {
    elem = this
    x = (+ inset (left morph))
    y = (+ inset (top morph))
  }
  stopEditing (keyboard page)
  focus = (initialize (new 'ScriptFocus') this elem x y)
  if (and (notNil x) (notNil y)) {setPosition (morph focus) x y}
  focusOn (keyboard page) focus
}

method stopEditing ScriptEditor {
  if (isNil focus) { return }
  focus = nil
  root = (handler (root morph))
  if (isClass root 'Page') {stopEditing (keyboard root) this}
  scriptChanged this
}

method focus ScriptEditor {return focus}
method setFocus ScriptEditor aScriptFocus {focus = aScriptFocus}

method sortedScripts ScriptEditor {
  sortingOrder = (function m1 m2 {return ((top m1) < (top m2))})
  morphs = (sorted (toArray (parts morph)) sortingOrder)
  result = (list)
  for each morphs {
    hdl = (handler each)
    if (isClass hdl 'Block') {add result hdl}
  }
  return result
}

method accepted ScriptEditor aText {
  if (notNil focus) {
    inp = (handler (ownerThatIsA (morph aText) 'InputSlot'))
    addSchedule (global 'page') (schedule (action 'edit' this inp))
  }
}

method cancelled ScriptEditor aText {
  if (notNil focus) {
    inp = (handler (ownerThatIsA (morph aText) 'InputSlot'))
    edit this inp
  }
}

// undrop

method clearDropHistory ScriptEditor {lastDrop = nil}

method recordDrop ScriptEditor block target input next {
  lastDrop = (new 'DropRecord' block target input next)
}

method undrop ScriptEditor {
  if (notNil lastDrop) {restore lastDrop this}
  lastDrop = nil
  scriptChanged this
}

method grab ScriptEditor aBlock {
  h = (hand (handler (root morph)))
  setCenter (morph aBlock) (x h) (y h)
  grab h aBlock
  changed h
}

// change detection

method scriptChanged ScriptEditor {
  scripterM = (ownerThatIsA morph 'Scripter')
  if (isNil scripterM) { scripterM = (ownerThatIsA morph 'MicroBlocksScripter') }
  if (notNil scripterM) { scriptChanged (handler scripterM) }
}

// saving script image

method setExportedScriptScale ScriptEditor {
  // Set the scale used for exported scripts.

  menu = (menu nil (action 'setExportScale' this) true)
  addItem menu 'small (50%)' 50
  addItem menu 'normal (65%)' 65
  addItem menu 'large (100%)' 100
  addItem menu 'printable (200%)' 200
  popUpAtHand menu (global 'page')
}

method setExportScale ScriptEditor percent {
  setGlobal 'blockExportScale' (percent / 100)
}

method saveScriptsImage ScriptEditor fName doNotCrop {
  // draw scripts (cropped to the dimensions of the ScriptEditor's scroll frame)
  // Use the current block scale, not blockExportScale to support semi-WYSIWYG.

  timer = (newTimer)
  bm = (croppedScriptsCostume this doNotCrop)

  scriptsString = nil
  mbScripter = (ownerThatIsA morph 'MicroBlocksScripter')
  if (notNil mbScripter) {
    scriptsString = (join 'GP Scripts' (newline) (allScriptsString (handler mbScripter)))
  }

  if (or ((width bm) == 0) ((height bm) == 0)) { return } // no scripts; empty bitmap
  pngData = (encodePNG bm nil scriptsString)

  defaultFileName = (join 'allScripts' (msecsSinceStart) '.png')
  if ('Browser' == (platform)) {
    if ((msecs timer) > 4000) {
      // if it has been more than a few seconds the user must click again to allow file save
      inform (global 'page') (localized 'PNG preparation complete.')
    }
	browserWriteFile pngData defaultFileName 'scriptImage'
  } else {
    if (isNil fName) {
      fName = (fileToWrite defaultFileName '.png')
      if ('' == fName) { return }
    }
    if (not (endsWith fName '.png')) { fName = (join fName '.png') }
	writeFile fName pngData
  }
}

method croppedScriptsCostume ScriptEditor doNotCrop {
  r = (scriptsRect this)
  w = (ceiling (width r))
  h = (ceiling (height r))
  if (or (w == 0) (h == 0)) { return (newBitmap 1 1) }

  if (true != doNotCrop) {
    // limit size to dimensions of ScriptEditor's scroll frame
    bnds = (bounds (owner morph))
    if (or (w > (width bnds)) (h > (height bnds))) {
      print 'Cropping scripts image to avoid running out of memory'
      w = (min w (width bnds))
      h = (min h (height bnds))
    }
  }
  if ('Browser' == (platform)) { // in browser, draw on Texture for speed
    result = (newTexture w h (gray 0 0))
  } else {
    result = (newBitmap w h (gray 0 0))
  }
  ctx = (newGraphicContextOn result)
  setOffset ctx (0 - (left r)) (0 - (top r))
  fullDrawOn morph ctx
  if ('Browser' == (platform)) {
    result = (toBitmap result)
  }
  return result
}

method scriptsRect ScriptEditor {
  // Return a rectangle that enclose all my scripts.

  if (isEmpty (parts morph)) { return (rect 0 0 0 0) }
  for m (parts morph) {
    if (isNil result) {
      result = (fullBounds m)
    } else {
      merge result (fullBounds m)
    }
  }
  return result
}

// script copy/paste via clipboard

method copyScriptsToClipboard ScriptEditor {
  scripter = (ownerThatIsA morph 'Scripter')
  if (isNil scripter) { scripter = (ownerThatIsA morph 'MicroBlocksScripter') }
  if (isNil scripter) { return }
  targetObj = (targetObj (handler scripter))
  setClipboard (join 'GP Scripts' (newline) (scriptStringWithDefinitionBodies (classOf targetObj)))
}

method pasteScripts ScriptEditor {
  scripter = (ownerThatIsA morph 'Scripter')
  if (isNil scripter) { scripter = (ownerThatIsA morph 'MicroBlocksScripter') }
  if (isNil scripter) { return }
  s = (readClipboard)
  i = (find (letters s) (newline))
  s = (substring s i)
  pasteScripts (handler scripter) s true
  scriptChanged (handler scripter)
}
// Block editing handler

defineClass ScriptFocus morph editor element atEnd options menu

method initialize ScriptFocus aScriptEditor initialElementOrNil x y {
  atEnd = false
  morph = (newMorph this)
  setFPS morph 2
  if (notNil aScriptEditor) {
    edit this aScriptEditor initialElementOrNil x y
    return this
  }
}

method redraw ScriptFocus {
  clr = (gray 255)
  if (notNil editor) {
    scale = (global 'scale')
    h = (scale * 5)
    bigger = (scale * 12)
    if (and (isClass element 'Block') ((type element) != 'reporter')) { // command or hat block types
      setHeight (bounds morph) h
      if atEnd {
          top = (bottom (morph element))
      } else {
          top = ((top (morph element)) - ((height morph) / 2))
      }
      setPosition morph (left (morph element)) top
      setCostume morph (newBitmap (width (morph element)) h clr)
    } (isClass element 'CommandSlot') {
      setHeight (bounds morph) h
      nb = (nested element)
      top = (+ (top (morph element)) (scaledCorner element))
      if (isNil nb) {top += (scaledCorner element)}
      setPosition morph (+ (scaledCorner element) (left (morph element))) top
      setCostume morph (newBitmap (width (morph element)) h clr)
    } (isClass element 'ScriptEditor') {
        setHeight (bounds morph) h
        atEnd = false
        setCostume morph (newBitmap (scale * 100) h clr)
    } else {
      setAlpha clr 150
      setBounds morph (expandBy (bounds (morph element)) bigger)
      area = (rect 0 0 (width morph) (height morph))
      bm = (newBitmap (width area) (height area))
	  radius = (10 * scale)
	  border = (3 * scale)
	  borderColor = (gray 255)
	  fillRoundedRect (newShapeMaker bm) area radius clr border borderColor borderColor
      setCostume morph bm
    }
    addPart (morph editor) morph // come to front
    show morph
    scrollIntoView morph
  }
}

method step ScriptFocus {
  if (or (and (isAnyClass element 'CommandSlot' 'ScriptEditor') (isEmpty (parts morph))) (and (isClass element 'Block') ((type element) != 'reporter') (isEmpty (parts morph)))) { // command or hat block types
    if (isVisible morph) {
      hide morph
    } else {
      show morph
    }
  } (not (isVisible morph)) {
    show morph
  }
}

method edit ScriptFocus anEditor anElement x y {
  if (isNil anEditor) {return}
  editor = anEditor
  element = anElement
  if (isClass element 'ScriptEditor') {
    setPosition morph x y
    redraw this
    return
  }
  scripts = (sortedScripts editor)
  if (isEmpty scripts) {return}
  if (isNil element) {element = (first scripts)}
  if (and (notNil x) (notNil y)) {
    setPosition morph x y
  }
  redraw this
  if (onHat this) {nextCommand this true} // no shift
}

// events

method keyDown ScriptFocus evt keyboard {
  closeUnclickedMenu (page keyboard) this
  code = (at evt 'keycode')
  shiftDown = (1 == (at evt 'modifierKeys'))

  if (8 == code) { deleteLeft this // delete
  } (9 == code) { // tab
    if shiftDown {
        lastScript this
    } else {
        nextScript this
    }
  } (13 == code) { enterKey this // enter
  } (27 == code) { cancel this // escape
  } (32 == code) { spaceKey this // escape
  } (37 == code) { lastElement this // left arrow
  } (38 == code) { lastCommand this // up arrow
  } (39 == code) { nextElement this // right arrow
  } (40 == code) { nextCommand this // down arrow
  } (not (isClass element 'BlockDrawer')) {
	charCode = (at evt 'char')
	if (and (32 < charCode) (charCode < 127)) {
	  findBlock this (string charCode)
	}
  }
}

method keyUp ScriptFocus evt keyboard {
  nop
}

method textinput ScriptFocus evt keyboard {
  nop
}

method nextScript ScriptFocus {
  scripts = (sortedScripts editor)
  if (isEmpty scripts) {return}
  if (isClass element 'ScriptEditor') {
    element = (first scripts)
  }
  tb = (topBlock (handler (ownerThatIsA (morph element) 'Block')))
  next = ((indexOf scripts tb) + 1)
  if (next > (count scripts)) {next = 1}
  element = (at scripts next)
  scrollIntoView (morph element)
  atEnd = false
  if (onHat this) {
      nextElement this
      return
  }
  redraw this
}

method lastScript ScriptFocus {
  scripts = (sortedScripts editor)
  if (isEmpty scripts) {return}
  if (isClass element 'ScriptEditor') {
    element = (first scripts)
  }
  tb = (topBlock (handler (ownerThatIsA (morph element) 'Block')))
  next = ((indexOf scripts tb) - 1)
  if (next < 1) {next = (count scripts)}
  element = (at scripts next)
  scrollIntoView (morph element)
  atEnd = false
  if (onHat this) {
      nextElement this true // ignore shift-key
      return
  }
  redraw this
}

method nextCommand ScriptFocus noShift {
  if (or (isClass element 'ScriptEditor') (shiftKeyDown (keyboard (global 'page')))) {
    if (not (noShift == true)) {
      shiftScript this 0 50
      return
    }
  }
  cm = (commandParentOf this element)
  if (isNil cm) {return}
  if atEnd {
    cs = (ownerThatIsA (morph cm) 'CommandSlot')
    if (isNil cs) {
      tb = (commandParentOf this (topBlock cm))
      if (notNil tb) {
        element = tb
        atEnd = false
        if (onHat this) {
          nextCommand this
        }
      }
    } else {
      element = (commandParentOf this (handler cs))
      atEnd = false
      nextCommand this
    }
  } else {
    nb = (next cm)
    if (isNil nb) {
      element = cm
      atEnd = true
    } else {
      element = nb
    }
  }
  redraw this
}

method lastCommand ScriptFocus {
  cm = (commandParentOf this element)
  if (isNil cm) {
    if (isClass element 'ScriptEditor') {
      shiftScript this 0 -50
    }
    return
  }
  if (shiftKeyDown (keyboard (global 'page'))) {
    shiftScript this 0 -50
    return
  }
  if (and (isClass element 'Block') (!= 'reporter' (type element))) {
    if atEnd {
      atEnd = false
    } else {
      pb = (commandParentOf this (handler (owner (morph cm))))
      if (isNil pb) {
        pb = (bottomBlock (topBlock cm))
        if (notNil pb) {
          element = pb
          atEnd = true
        }
      } else {
        element = pb
      }
    }
  } else {
    element = cm
    atEnd = false
  }
  if (and (not atEnd) (onHat this)) {
    lastCommand this
  }
  redraw this
}

method nextElement ScriptFocus ignoreShift {
  if (isNil ignoreShift) {ignoreShift = false}
  items = (items this)
  if (and (not ignoreShift) (or (isEmpty items) (shiftKeyDown (keyboard (global 'page'))))) {
    shiftScript this 50 0
    return
  }
  idx = ((indexOf items element) + 1)
  if (idx > (count items)) {
    idx = 1
  }
  atEnd = false
  element = (at items idx)
  if (isClass element 'CommandSlot') {
    nb = (nested element)
    if (notNil nb) {element = nb}
  } (onHat this) {
    if ((count items) == 1) {
      atEnd = true
    } else {
      nextElement this
    }
  }
  redraw this
}

method lastElement ScriptFocus {
  items = (items this)
  if (or (isEmpty items) (shiftKeyDown (keyboard (global 'page')))) {
    shiftScript this -50 0
    return
  }
  if atEnd {
    element = (last items)
    atEnd = false
  } else {
    idx = ((indexOf items element) - 1)
    if (idx < 1) {idx = (count items)}
    element = (at items idx)
  }
  if (and (isClass element 'CommandSlot') (notNil (nested element))) {
    lastElement this
  } (onHat this) {
    if (> (count items) 1) {
      lastElement this
    } else {
      atEnd = true
    }
  }
  redraw this
}

method deleteLeft ScriptFocus {
  if (isClass element 'Block') {
    b = element
    if atEnd {
      element = (handler (owner (morph element)))
    } (== 'reporter' (type element)) {
      lastElement this
    } else { // 'command' or 'hat'
      if (isClass (handler (owner (morph b))) 'CommandSlot') {return}
      b = (previous b)
      if (isNil b) {return}
    }
    delete b
    if (isEmpty (sortedScripts editor)) {
      stopEditing editor
      return
    }
    redraw this
  } (isClass element 'BlockDrawer') {
    b =  (handler (ownerThatIsA (morph element) 'Block'))
    collapse element
    inp = (inputs b)
    if (notEmpty inp) {
      element = (last (inputs b))
      nextElement this
    } else {
      element = b
      lastElement this
    }
  } (isClass element 'BooleanSlot') {
    setContents element false
  }
}

method enterKey ScriptFocus {
  keyb = (keyboard (global 'page'))
  if (shiftKeyDown keyb) {
    if (commandKeyDown keyb) {
      runScript this
    } else {
      newScript this
    }
    return
  } (isClass element 'BlockDrawer') {
    b =  (handler (ownerThatIsA (morph element) 'Block'))
    trigger element
    inp = (inputs b)
    if (notEmpty inp) {
      element = (last (inputs b))
      nextElement this
    } else {
      element = b
      lastElement this
    }
  } (isClass element 'InputSlot') {
    destroy morph
    trigger element this
  } (isAnyClass element 'Block' 'BooleanSlot' 'ColorSlot') {
    trigger element
  }
  setField editor 'focus' this
}

method spaceKey ScriptFocus {
  if (isClass element 'BlockDrawer') {
    b =  (handler (ownerThatIsA (morph element) 'Block'))
    trigger element
    inp = (inputs b)
    if (notEmpty inp) {
      element = (last (inputs b))
      nextElement this
    } else {
      element = b
      lastElement this
    }
  } (isAnyClass element 'Block' 'BooleanSlot' 'ColorSlot' 'InputSlot') {
    trigger element
  }
  setField editor 'focus' this
}

method cancel ScriptFocus {
  stopEditing editor
}

method runScript ScriptFocus {
  if (isClass element 'ScriptEditor') {return}
  page = (page morph)
  block = (handler (ownerThatIsA (morph element) 'Block'))
  tb = (topBlock block)
  cmdList = (expression tb)
  // if this block is in a Scripter, run it in the context of the Scriptor's targetObj
  scripter = (ownerThatIsA (morph tb) 'Scripter')
  if (notNil scripter) { targetObj = (targetObj (handler scripter)) }
  if (isRunning page cmdList targetObj) {
    stopRunning page cmdList targetObj
  } else {
    launch page cmdList targetObj (action 'showResult' tb)
  }
}

method newScript ScriptFocus {
  if (isClass element 'ScriptEditor') {return}
  block = (handler (ownerThatIsA (morph element) 'Block'))
  tb = (topBlock block)
  fb = (fullBounds (morph tb))
  setPosition morph (left fb) (+ (bottom fb) (50 * (global 'scale')))
  element = editor
  redraw this
}

// identifying elements

method onHat ScriptFocus {return (and (isClass element 'Block') (== 'hat' (type element)))}

method commandParentOf ScriptFocus handler {
  if (isNil handler) {handler = element}
  cm = handler
  if (cm == editor) {return nil}
  while (not (and (isClass cm 'Block') (!= 'reporter' (type cm)))) {
    cm = (handler (owner (morph cm)))
    if (cm == editor) {return nil}
  }
  return cm
}

// moving scripts

method shiftScript ScriptFocus x y {
  if (isNil x) {x = 0}
  if (isNil y) {y = 0}
  x = (x * (global 'scale'))
  y = (y * (global 'scale'))
  if (isClass element 'ScriptEditor') {
    moveBy morph x y
  } else {
    tb = (topBlock (handler (ownerThatIsA (morph element) 'Block')))
    if (notNil tb) {
      moveBy (morph tb) x y
    }
  }
  justGrabbedPart editor // update sliders
  redraw this
}

// navigating

method items ScriptFocus {
  if (isClass element 'ScriptEditor') {return (list)}
  b = (ownerThatIsA (morph element) 'Block')
  all = (allMorphs (morph (topBlock (handler b))))
  result = (list)
  for each all {
    if (isAnyClass (handler each) 'InputSlot' 'BooleanSlot' 'ColorSlot' 'CommandSlot' 'Block' 'BlockDrawer') {
      add result (handler each)
    }
  }
  return result
}

// destroying

method destroy ScriptFocus {
  setFocus editor nil
  // showKeyboard false
  if (notNil menu) {destroy (morph menu)}
  destroy morph
}

// finding matching blocks

method findBlock ScriptFocus spec {
  scale = (global 'scale')
  removeAllParts morph
  if (isNil spec) {spec = ''}
  searchText = (newText spec)
  setFont searchText nil (scale * 15)
  setEditRule searchText 'line'
  setGrabRule (morph searchText) 'ignore'
  setColor searchText nil (color 240 240 240) (color 240 240 240)
  setBorders searchText (scale * 2) (scale * 2) true
  setLeft (morph searchText) ((left morph) + (scale * 5))
  setYCenter (morph searchText) (vCenter (bounds morph))
  addPart morph (morph searchText)
  edit searchText (hand (page morph)) true // keep focus
  gotoSlot (caret searchText) ((count spec) + 1)
  changed (morph searchText)
  textEdited this searchText
}

method textEdited ScriptFocus aText {
  if (and (isClass element 'Block') (or ('command' == (type element)) (and atEnd ('hat' == (type element))))) {
    searchTypes = (list ' ')
  } (isClass element 'CommandSlot') {
    searchTypes = (list ' ')
  } (isClass element 'ScriptEditor') {
    searchTypes = nil
  } (not (and (isClass element 'Block') ('hat' == (type element)))) {
    searchTypes = (list 'r')
  } else {
    return
  }
  specList = (findSpecsMatching this (text aText) searchTypes 5)
  menu = (menu nil this)
  setField menu 'returnFocus' this
  for spec specList {
    if (isClass spec 'Array') { // field name or temporary variable
      blck = (toBlock (newReporter 'v' (first spec)))
    } else {
      blck = (blockForSpec spec)
    }
    addBlock this blck menu
  }
  popUp menu (page morph) (left (morph aText)) (bottom (morph aText)) true // suppress focus
  selectFirstItem menu
}

method accepted ScriptFocus aText {
  trigger menu
  return
}

method cancelled ScriptFocus aText {
  edit editor element this
  redraw this
}

method downArrow ScriptFocus aText {
  selectNextItem menu
}

method upArrow ScriptFocus aText {
  selectPreviousItem menu
}

method addBlock ScriptFocus aBlock aMenu {addItem aMenu (fullCostume (morph aBlock)) (action 'insert' this aBlock)}

method insert ScriptFocus aBlock {
  spec = (blockSpec aBlock)
  if (notNil spec) {showBlockCategory (categoryFor (authoringSpecs) (blockOp spec))}
  if (isClass element 'ScriptEditor') {
    setCenter (morph aBlock) (hCenter (bounds morph)) (vCenter (bounds morph))
    addPart (morph editor) (morph aBlock)
  } (isClass element 'CommandSlot') {
    setNested element aBlock
  } (isClass element 'Block') {
    if (and (not atEnd) ('command' == (type element))) {
      parent = (handler (owner (morph element)))
      if (isClass parent 'CommandSlot') {
        setNested parent aBlock
      } else {
        p = (previous element)
        if (notNil p) {
          setNext p aBlock
        } else { // at the top
          if ('reporter' != (type aBlock)) {
            addPart (morph editor) (morph aBlock)
            setBottom (morph aBlock) (bottom (morph element))
            setLeft (morph aBlock) (left (morph element))
            setNext aBlock element
          }
        }
      }Ã¥
    } atEnd {
      setNext element aBlock
    }
  } else { // must be an input
    b = (handler (ownerThatIsA (owner (morph element)) 'Block'))
    replaceInput b element aBlock
  }
  edit editor aBlock this
  element = aBlock
  nextElement this
}

method findSpecsMatching ScriptFocus prefix types max {
  result = (list)
  if ('' == prefix) { return result }

  // find matching variables
  if (or (isNil types) (contains types 'r')) {
    localVars = (list)
    targetObj = (targetObj this)
    if (notNil targetObj) {
      add localVars 'this'
      addAll localVars (fieldNames (classOf targetObj))
    }
    if (not (isClass element 'ScriptEditor')) {
      block = (ownerThatIsA (morph element) 'Block')
      if (notNil block) {
        tb = (topBlock (handler block))
        for each (keys (collectLocals (expression tb))) {
          if (not (contains localVars) each) {
            add localVars each
          }
        }
        // find formal parameters, if any
        def = (editedDefinition tb)
        if (notNil def) {
          for each (inputNames def) {
            if (not (contains localVars) each) {
              add localVars each
            }
          }
        }
      }
    }
    for name localVars {
      if (beginsWith name prefix) {
        add result (array name)
      }
    }
  }

  // find matching blocks
  entries = (dictionary)
  authoringSpecs = (authoringSpecs)
  for entry (allSpecs authoringSpecs) {
    fType = (at entry 1)
    if (or (isNil types) (contains types fType)) {
      fName = (at entry 2)
      spec = (at entry 3)
      if (beginsWith fName prefix) {
        if (not (contains entries fName)) {
          add entries fName
          add result (specForEntry authoringSpecs entry)
        }
      } else {
        specWords = (copyWithout (words spec) '_')
        s = (joinStringArray specWords ' ')
        if (or (beginsWith s prefix) (allWordsMatch this (words prefix) specWords)) {
          if (not (contains entries fName)) {
            add entries fName
            add result (specForEntry authoringSpecs entry)
          }
        }
      }
      if ((count result) >= max) {return result}
    }
  }
  return result
}

method allWordsMatch ScriptFocus patterns words {
  for each patterns {
    if (not (anyWordBeginsWith this words each)) {
      return false
    }
  }
  return true
}

method anyWordBeginsWith ScriptFocus words matchString {
  for each words {
    if (beginsWith each matchString) {
      return true
    }
  }
  return false
}

method targetObj ScriptFocus {
  if (notNil editor) {
    sm = (ownerThatIsA morph 'Scripter')
    if (notNil sm) {return (targetObj (handler sm))}
  }
  return nil
}
// Scripter.gp - authoring-level scripter w/ built-in palette

defineClass Scripter morph targetObj projectEditor stageMorph saveNeeded classPane classReadout searchBox classMenuButton newInstanceButton categoriesFrame catResizer blocksFrame blocksResizer scriptsFrame resizer nextX nextY

method targetModule Scripter {
  if (notNil targetObj) { return (module (classOf targetObj)) }
  return (module (project projectEditor))
}

method targetObj Scripter { return targetObj }
method targetClass Scripter { return (classOf targetObj) }

method setTargetObj Scripter obj {
  if (targetObj === obj) { return }
  oldClass = (classOf targetObj)
  targetObj = obj
  if ((classOf obj) != oldClass) {
    restoreScripts this
    saveScripts this
  }
  if ('Variables' == (selection (contents categoriesFrame))) {
	updateBlocks this
  }
}

to showInScripter targetObj {
  if (and (not (isUserDefined (classOf targetObj))) (not (shiftKeyDown (keyboard (global 'page'))))) {return}
  for m (parts (morph (global 'page'))) {
	if (isClass (handler m) 'Scripter') { scripter = (handler m) }
	if (isClass (handler m) 'ProjectEditor') { scripter = (scripter (handler m)) }
  }
  if (isNil scripter) {
    page = (global 'page')
    scripter = (initialize (new 'Scripter'))
	top = ((25 * (global 'scale')) + 7)
    setPosition (morph scripter) 5 top
	h = (((height (morph page)) - top) - 5)
	w = (clamp ((width (morph page)) / 2) 500 1200)
	setExtent (morph scripter) w h
    addPart page scripter
  }
  setTargetObj scripter targetObj
}

to startEditingScripts {
  page = (global 'page')
  for m (parts (morph page)) {
    if (isClass (handler m) 'Scripter') { scripter = (handler m) }
    if (isClass (handler m) 'ProjectEditor') { scripter = (scripter (handler m)) }
  }
  if (or (isNil scripter) (not (isVisible (morph scripter)))) {
    // don't initiate editing scripts in presentation mode
    return
  }
  startEditing (contents (getField scripter 'scriptsFrame'))
  (focus (keyboard page))
}

to showBlockCategory aCategory {
  page = (global 'page')
  for m (parts (morph page)) {
    if (isClass (handler m) 'Scripter') { scripter = (handler m) }
    if (isClass (handler m) 'ProjectEditor') { scripter = (scripter (handler m)) }
    if (isClass (handler m) 'MicroBlocksScripter') { scripter = (handler m) }
  }
  if (isNil scripter) {return}
  selectCategory scripter aCategory
}

// initialization

method initialize Scripter aProjectEditor {
  targetObj = nil
  projectEditor = aProjectEditor
  scale = (global 'scale')
  morph = (newMorph this)
  setCostume morph (gray 150) // border color
  setClipping morph true
  listColor = (gray 240)
  fontName = 'Arial'
  fontSize = 13
  nextX = 0
  nextY = 0

  // save scripts once a second, if they could have changed
  setFPS morph 1
  saveNeeded = false

  classPane = (makeClassPane this)
  addPart morph (morph classPane)

  lbox = (listBox (categories this) nil (action 'updateBlocks' this) listColor)
  setFont lbox fontName fontSize
  categoriesFrame = (scrollFrame lbox listColor)
  setExtent (morph categoriesFrame) (82 * scale) // initial width
  addPart morph (morph categoriesFrame)

  blocksPane = (newBlocksPalette)
  setSortingOrder (alignment blocksPane) nil
  setPadding (alignment blocksPane) (15 * scale) // inter-column space
  setFramePadding (alignment blocksPane) (10 * scale) (10 * scale)
  blocksFrame = (scrollFrame blocksPane (gray 220))
  setAutoScroll blocksFrame false
  setExtent (morph blocksFrame) nil (285 * scale) // initial height
  addPart morph (morph blocksFrame)

  scriptsPane = (newScriptEditor 10 10 nil)
  scriptsFrame = (scrollFrame scriptsPane (gray 220))
  addPart morph (morph scriptsFrame)

  // add resizers last so they are in front
  catResizer = (resizeHandle categoriesFrame 'horizontal')
  addPart morph (morph catResizer)

  blocksResizer = (resizeHandle blocksFrame 'vertical')
  addPart morph (morph blocksResizer)

  resizer = (resizeHandle this 'horizontal')

  setGrabRule morph 'ignore'
  for m (parts morph) { setGrabRule m 'ignore' }

  setMinExtent morph (scale * 235) (scale * 200)
  setExtent morph (scale * 600) (scale * 700)
  restoreScripts this

  if (isNil projectEditor) { select (contents categoriesFrame) 'Control' }
  return this
}

method makeClassPane Scripter {
  scale = (global 'scale')
  space = (5 * scale)
  labelTop = (7 * scale)

  classPane = (newBox nil (gray 220) nil nil false false)
  setCorner classPane 0

  classReadout = (newText '---' 'Arial Bold' (14 * scale))
  setPosition (morph classReadout) (2 * space) labelTop
  addPart (morph classPane) (morph classReadout)

  classMenuButton = (makeMenuButton this (action 'classMenu' this))
  addPart (morph classPane) (morph classMenuButton)
  if (notNil projectEditor) { hide (morph classMenuButton) }

  newInstanceButton = (pushButton 'New instance' (color 130 130 130) (action 'addInstance' this))
  setHint newInstanceButton 'Add a new instance of this class to the page'
  addPart (morph classPane) (morph newInstanceButton)
  if (notNil projectEditor) { hide (morph newInstanceButton) }

  searchBox = (newBlockSearchBox 90 19)
  addPart (morph classPane) (morph searchBox)

  return classPane
}

method makeMenuButton Scripter action {
  scale = (global 'scale')
  w = (17 * scale)
  h = (13 * scale)
  hCenter = (w / 2)
  arrowW = (9 * scale)
  arrowH = (7 * scale)
  arrowX = ((w / 2) - (arrowW / 2))
  arrowY = (3 * scale)
  arrowRect = (rect arrowX arrowY arrowW arrowH)

  normalBM = (newBitmap w h (gray 210))
  fillArrow (newShapeMaker normalBM) arrowRect 'down' (gray 80)

  highlightBM = (newBitmap w h (gray 210))
  fillArrow (newShapeMaker highlightBM) arrowRect 'down' (gray 150)

  btn = (new 'Trigger' (newMorph) action)
  setHandler (morph btn) btn
  replaceCostumes btn normalBM highlightBM highlightBM
  setCostume (morph btn) normalBM
  return btn
}

// layout

method redraw Scripter {
  fixLayout this
}

method fixLayout Scripter {
  innerBorder = 2
  outerBorder = 2
  catWidth = (max (toInteger ((width (morph categoriesFrame)) / (global 'scale'))) 20)
  blocksHeight = (max (toInteger ((height (morph blocksFrame)) / (global 'scale'))) 5)
  packer = (newPanePacker (bounds morph) innerBorder outerBorder)
  packPanesH packer classPane '100%'
  packPanesH packer categoriesFrame catWidth blocksFrame '100%'
  packPanesH packer scriptsFrame '100%'
  packPanesV packer classPane 28 categoriesFrame blocksHeight scriptsFrame '100%'
  packPanesV packer classPane 28 blocksFrame blocksHeight
  finishPacking packer

  fixClassPaneLayout this
  redraw blocksFrame
  redraw scriptsFrame
  fixResizerLayout this
  if (notNil projectEditor) { fixLayout projectEditor }
}

method fixClassPaneLayout Scripter {
  scale = (global 'scale')

  m = (morph newInstanceButton)
  x = ((right (morph classPane)) - ((width m) + (10 * scale)))
  y = ((top (morph classPane)) + ((((height (morph classPane))) - (height m)) / 2))
  setPosition m x y

  m = (morph classMenuButton)
  x = ((right (morph classReadout)) + (3 * scale))
  y = ((top (morph classReadout)) + (1 * scale))
  setPosition m x y

  m = (morph searchBox)
  x = ((right (morph classPane)) - ((width m) + (5 * scale)))
  y = ((top (morph classPane)) + ((((height (morph classPane))) - (height m)) / 2))
  setPosition m x y
}

method fixResizerLayout Scripter {
  scale = (global 'scale')
  size = (10 * scale)
  border = (2 * scale)

  // categories pane resizer
  setLeft (morph catResizer) (right (morph categoriesFrame))
  setTop (morph catResizer) (top (morph categoriesFrame))
  setExtent (morph catResizer) size (height (morph categoriesFrame))
  drawPaneResizingCostumes catResizer

  // blocks pane resizer
  setLeft (morph blocksResizer) (left morph) // ((bottom (morph blocksFrame)) - extra)
  setTop (morph blocksResizer) (bottom (morph blocksFrame))
  setExtent (morph blocksResizer) (width morph) size
  drawPaneResizingCostumes blocksResizer

  // scripter width resizer
  setLeft (morph resizer) ((right morph) - (width (morph resizer)))
  setTop (morph resizer) (top morph)
  setExtent (morph resizer) size (height morph)
  drawPaneResizingCostumes resizer
  addPart morph (morph resizer) // bring to front
}

// animation

method slideOpen Scripter end {
  show morph
  if (isNil end) { end = 50 }
  start = (- (height morph))
  addSchedule (global 'page') (newAnimation start end 250 (action 'setTop' morph))
}

method slideClosed Scripter {
  start = (top morph)
  end = (-5 - (height morph)) // off the top of the screen
  addSchedule (global 'page') (newAnimation start end 250 (action 'setTop' morph) (action 'hide' morph))
}

// scripter UI support

method blockScaleChanged Scripter {
  updateBlocks this
  saveScripts this
  restoreScripts this
}

method developerModeChanged Scripter {
  catList = (contents categoriesFrame)
  setCollection catList (categories this)
  if (not (contains (collection catList) (selection catList))) {
    select catList 'Control'
  } else {
    updateBlocks this
  }
}

method updateClassName Scripter {
  setText classReadout (className (classOf targetObj))
  redraw classReadout
  fixClassPaneLayout this
}

method devModeCategories Scripter {
  return (array 'Control' 'Motion' 'Looks' 'Drawing' 'Drawing - Paths' 'Color' 'Pixels' 'Sensing' 'Pen' 'Sound' 'Music' 'Operators' 'Variables' 'Words' 'Data' 'Table' 'Structure' 'Network' 'Functions' 'Serial Port' 'File Stream' 'Debugging' 'My Blocks')
}

method userModeCategories Scripter {
  return (array 'Control' 'Motion' 'Looks' 'Drawing' 'Color' 'Pixels' 'Sensing' 'Pen' 'Sound' 'Operators' 'Variables' 'Words' 'Data' 'Structure' 'Network' 'My Blocks')
}

method categories Scripter {
  if (devMode) {
	result = (devModeCategories this)
  } else {
	result = (userModeCategories this)
  }
  result = (join result (extraCategories (project projectEditor)))
  return result
}

method selectCategory Scripter aCategory {
  select (contents categoriesFrame) aCategory
}

method currentCategory Scripter {
  return (selection (contents categoriesFrame))
}

method isUserBlock Scripter spec {
  // Return true if the given block should be shown in the palette  in user mode.

  devOnlyBlocks = (array
	'whenPageResized' 'whenTracking' 'whenScrolled'
	'stageWidth' 'stageHeight'
	'ln' 'exp' 'toFloat' 'maxInt' 'minInt'
	'&' '|' '^' '<<' '>>' '>>>'
	'gather' 'canonicalizedWord' 'string'
	'self_addPart' 'self_owner' 'self_stage' 'self_parts'
	'httpGet' 'jsonFormat' 'jsonStringify' 'jsonParse' 'openExplorer' 'print' 'points' 'showText'
	'self_localMouseX' 'self_localMouseY' 'self_setPinXY' 'self_floodFill'
	'fftOfSamples' 'clamp' 'isAnyClass' 'allInstances')
  return (not (contains devOnlyBlocks (blockOp spec)))
}

method updateBlocks Scripter {
  blocksPane = (contents blocksFrame)
  removeAllParts (morph blocksPane)

  cat = (selection (contents categoriesFrame))
  setRule (alignment blocksPane) 'multi-column'
  if ('Variables' == cat) {
	setRule (alignment blocksPane) 'none'
	addVariableBlocks this
  } ('My Blocks' == cat) {
	setRule (alignment blocksPane) 'none'
    addMyBlocks this
  } else {
    specs = (specsFor (authoringSpecs) cat)
    for spec specs {
      if (or (devMode) (isUserBlock this spec)) {
        addBlock this (blockForSpec spec) spec
      }
    }
  }
  cleanUp blocksPane
}

method addVariableBlocks Scripter {
  scale = (global 'scale')
  nextX = ((left (morph (contents blocksFrame))) + (20 * scale))
  nextY = ((top (morph (contents blocksFrame))) + (-3 * scale))

  addSectionLabel this 'Shared Variables'
  addButton this 'Add a shared variable' (action 'createSharedVariable' this) 'A shared variable is visible to all scripts in all classes. Any script can view or change shared variables, making them useful for things like game scores.'
  sharedVars = (sharedVars this)
  if (notEmpty sharedVars) {
	addButton this 'Delete a shared variable' (action 'deleteSharedVariable' this)
	nextY += (8 * scale)
	for varName sharedVars {
	  lastY = nextY
	  b = (toBlock (newReporter 'shared' varName))
	  addBlock this b nil true
	  readout = (makeMonitor b)
	  setGrabRule (morph readout) 'ignore'
	  setStyle readout 'varPane'
	  setPosition (morph readout) nextX lastY
	  addPart (morph (contents blocksFrame)) (morph readout)
	  step readout
	  refIcon = (initialize (new 'MorphRefIcon') varName nil (targetModule this))
	  setPosition (morph refIcon) (nextX + (114 * scale)) (lastY + (5 * scale))
	  addPart (morph (contents blocksFrame)) (morph refIcon)
	}
	nextY += (5 * scale)
	addBlock this (toBlock (newCommand 'setShared' (first sharedVars) 0)) nil false
	addBlock this (toBlock (newCommand 'increaseShared' (first sharedVars) 1)) nil false
  }

  if (notNil targetObj) {
	localVars = (toList (fieldNames (classOf targetObj)))
	if (devMode) {
	  addFirst localVars 'this'
	} else {
	  remove localVars 'morph'
	}
	removeableVars = (copyWithout (toArray localVars) 'morph')

	addSectionLabel this 'Instance Variables'
	addButton this 'Add an instance variable' (action 'createInstanceVariable' this) 'An instance variable stores a value specific to that instance. Every instance has its own value for each instance variable. For example, in a racing game instances of "Car" might have different values for their "speed" instance variable.'
	if (notEmpty removeableVars) {
	  addButton this 'Delete an instance variable' (action 'deleteInstanceVariable' this)
	}
	nextY += (8 * scale)

	if ((count localVars) > 0) {
	  firstVar = (first localVars)
	  if (devMode) {
		if ((count localVars) > 2) {
		  firstVar = (at localVars 3) // first user instance variable
		} else {
		  firstVar = 'n' // no user instance variables; use 'n' as placeholder
		}
	  }
	  for varName localVars {
		lastY = nextY
		if ('this' == varName) {
		  b = (toBlock (newReporter 'v' varName))
		} else {
		  b = (toBlock (newReporter 'my' varName))
		}
		addBlock this b nil true
		readout = (makeMonitor b)
		setGrabRule (morph readout) 'ignore'
		setStyle readout 'varPane'
		setPosition (morph readout) nextX lastY
		addPart (morph (contents blocksFrame)) (morph readout)
		step readout
		refIcon = (initialize (new 'MorphRefIcon') varName targetObj)
		setPosition (morph refIcon) (nextX + (114 * scale)) (lastY + (5 * scale))
		addPart (morph (contents blocksFrame)) (morph refIcon)
	  }
	  nextY += (5 * scale)
	  addBlock this (toBlock (newCommand 'setMy' firstVar 0)) nil false
	  addBlock this (toBlock (newCommand 'increaseMy' firstVar 1)) nil false
	}
  }

  if (devMode) {
	addSectionLabel this 'Script Variables'
	nextY += (2 * scale)
	addBlock this (toBlock (newCommand 'local' 'var' 0)) nil false
	addBlock this (toBlock (newCommand '=' 'var' 0)) nil false
	addBlock this (toBlock (newCommand '+=' 'var' 1)) nil false
  }
}

method addMyBlocks Scripter {
  scale = (global 'scale')
  nextX = ((left (morph (contents blocksFrame))) + (20 * scale))
  nextY = ((top (morph (contents blocksFrame))) + (-3 * scale))
  if (isNil targetObj) { return }

  addSectionLabel this 'Shared Blocks'
  addButton this 'Make a shared block' (action 'createSharedBlock' this)
  nextY += (8 * scale)

  for f (functions (targetModule this)) {
	spec = (specForOp (authoringSpecs) (functionName f))
	if (isNil spec) { spec = (blockSpecFor f) }
	addBlock this (blockForSpec spec) spec
  }

  addSectionLabel this 'Methods (i.e blocks for this class only)'
  addButton this 'Make a method' (action 'createMethodBlock' this)
  if (not (implements targetObj 'initialize')) {
	addButton this 'Make an initialize method' (action 'createInitializeMethodBlock' this)
  }
  nextY += (8 * scale)

  // add method blocks
  for m (methods (classOf targetObj)) {
    op = (functionName m)
    spec = (specForOp (authoringSpecs) op)
    if (isNil spec) {spec = (blockSpecFor m)}
    addBlock this (blockForSpec spec) spec
  }
}

method addSharedBlocks Scripter {
  scriptsPane = (contents scriptsFrame)
  for m (parts (morph scriptsPane)) {
    if (isClass (handler m) 'Block') {
      script = (expression (handler m) (className (classOf targetObj)))
      if ('to' == (primName script)) {
        op = (first (argList script))
        spec = (specForOp (authoringSpecs) op)
        if (isNil spec) {spec = (blockSpecFor (functionNamed op))}
        addBlock this (blockForSpec spec) spec
      }
    }
  }
}

method addButton Scripter label action hint {
  btn = (pushButton label (gray 130) action)
  if (notNil hint) { setHint btn hint }
  setPosition (morph btn) nextX nextY
  addPart (morph (contents blocksFrame)) (morph btn)
  nextY += ((height (morph btn)) + (7 * (global 'scale')))
}

method addSectionLabel Scripter label {
  scale = (global 'scale')
  labelColor = (gray 60)
  fontSize = (14 * scale)
  label = (newText label nil fontSize labelColor)
  nextY += (15 * scale)
  setPosition (morph label) (nextX - (10 * scale)) nextY
  addPart (morph (contents blocksFrame)) (morph label)
  nextY += ((height (morph label)) + (8 * scale))
}

method addBlock Scripter b spec isVarReporter {
  // install a 'morph' variable reporter for any slot that has 'morph' or 'Morph' as a hint
  if (isNil spec) { spec = (blockSpec b) }
  if (isNil isVarReporter) { isVarReporter = false }
  scale = (global 'scale')
  targetClass = (classOf targetObj)
  if (notNil spec) {
	inputs = (inputs b)
	for i (slotCount spec) {
	  hint = (hintAt spec i)
	  if (and (isClass hint 'String') (endsWith hint 'orph')) {
		replaceInput b (at inputs i) (toBlock (newReporter 'v' 'morph'))
	  }
	  if ('page' == hint) {
		replaceInput b (at inputs i) (toBlock (newReporter 'v' 'page'))
	  }
	  if (or ('this' == hint) (and ('list' != hint) ((className targetClass) == hint))) {
		replaceInput b (at inputs i) (toBlock (newReporter 'v' 'this'))
	  }
	}
  }
  fixLayout b
  setGrabRule (morph b) 'template'
  setPosition (morph b) nextX nextY
  if isVarReporter { setLeft (morph b) (nextX + (135 * scale)) }
  addPart (morph (contents blocksFrame)) (morph b)
  nextY += ((height (morph b)) + (4 * (global 'scale')))
}

// variable operations

method sharedVars Scripter {
  return (copyWithout (variableNames (targetModule this)) 'extensions')
}

method createInstanceVariable Scripter {
  varName = (prompt (global 'page') 'New variable name?' '')
  if (varName != '') {
	addVariable this (uniqueVarName this varName)
	updateBlocks this
  }
}

method createSharedVariable Scripter {
  // Temporary hack. Create shared variables in the session module.
  varName = (prompt (global 'page') 'New shared variable name?' '')
  if (varName != '') {
	setShared (uniqueVarName this varName) 0 (targetModule this)
	updateBlocks this
  }
}

method uniqueVarName Scripter varName forScriptVar {
  // If varName matches an instance or shared variable, return a unique variant of it.
  // Otherwise, return varName unchanged.

  if (isNil forScriptVar) { forScriptVar = false }
  existingVars = (toList (join (sharedVars this) (fieldNames (classOf targetObj))))
  scripts = (scripts (classOf targetObj))
  if (and (notNil scripts) (not forScriptVar)) {
	for entry scripts {
	  for b (allBlocks (at entry 3)) {
		if (isOneOf (primName b) 'v' '=' '+=' 'local' 'for') {
		  add existingVars (first (argList b))
		}
	  }
	}
  }
  return (uniqueNameNotIn existingVars varName)
}

method deleteInstanceVariable Scripter {
  removeableVars = (toList (fieldNames (classOf targetObj)))
  remove removeableVars 'morph'
  if (isEmpty removeableVars) { return }

  menu = (menu nil (action 'removeInstanceVariable' this) true)
  for v removeableVars { addItem menu v }
  popUpAtHand menu (global 'page')
}

method removeInstanceVariable Scripter varName {
  deleteInstVarMonitors this (classOf targetObj) varName
  if (hasField targetObj varName) {
	deleteField (classOf targetObj) varName
  }
  updateBlocks this
}

method deleteInstVarMonitors Scripter class instVarName {
  for m (allMorphs (morph (global 'page'))) {
	if (isClass (handler m) 'Monitor') {
	  monitorAction = (getAction (handler m))
	  if (and (notNil monitorAction) ((count (arguments monitorAction)) >= 2)) {
		args = (arguments monitorAction)
		if (and (instVarName == (at args 2)) (class == (classOf (first args)))) {
		  removeFromOwner m
		}
	  }
	}
  }
}

method deleteSharedVariable Scripter {
  if (isEmpty (sharedVars this)) { return }
  menu = (menu nil (action 'removeSharedVariable' this) true)
  for v (sharedVars this) { addItem menu v }
  popUpAtHand menu (global 'page')
}

method removeSharedVariable Scripter varName {
  deleteSharedVarMonitors this (targetModule this) varName
  deleteVar (targetModule this) varName
  updateBlocks this
}

method deleteSharedVarMonitors Scripter module sharedVarName {
  for m (allMorphs (morph (global 'page'))) {
	if (isClass (handler m) 'Monitor') {
	  monitorAction = (getAction (handler m))
	  if (and (notNil monitorAction) ((count (arguments monitorAction)) >= 2)) {
		args = (arguments monitorAction)
		if (and (sharedVarName == (at args 1)) (module == (at args 2))) {
		  removeFromOwner m
		}
	  }
	}
  }
}

method addVariable Scripter varName {
  if (isNil targetObj) { error 'No target object' }
  addField (classOf targetObj) varName
  for each (allInstances (classOf targetObj)) {
	setField each varName 0
  }
  updateBlocks this
}

method renameInstanceVariable Scripter oldName newName {
  if (isNil targetObj) { error 'No target object' }
  renameField (classOf targetObj) oldName newName
  updateBlocks this
}

// morph reference arrow support

method drawMorphRefLinks Scripter pen {
  if (or (isNil (owner morph)) (isHidden morph)) { return }
  if ('Variables' != (currentCategory this)) { return }
  arrowColor = (gray 100)
  for m (parts (morph (contents blocksFrame))) {
	h = (handler m)
	if (isClass h 'MorphRefIcon') {
	  if (isActive h) {
		targetM = (targetMorph h)
		if (notNil targetM) {
		  startX = (hCenter (bounds m))
		  startY = (vCenter (bounds m))
		  endX = (hCenter (bounds targetM))
		  endY = (vCenter (bounds targetM))
		  drawArrow pen startX startY endX endY arrowColor
		}
	  }
	}
  }
}

// handle drops

method wantsDropOf Scripter aHandler {
  return (and
	('Variables' == (currentCategory this))
	(not (hasField aHandler 'window'))
	(intersects (bounds (morph aHandler)) (bounds (morph blocksFrame))))
}

method justReceivedDrop Scripter aHandler {
  hand = (hand (global 'page'))
  dropX = (x hand)
  dropY = (y hand)
  for m (parts (morph (contents blocksFrame))) {
	h = (handler m)
	if (isClass h 'Monitor') {
	  if (containsPoint (bounds m) dropX dropY) {
		getter = (getField h 'getAction')
		getterArgs = (arguments getter)
		if ('shared' == (function getter)) {
		  setShared (first getterArgs) aHandler (last getterArgs)
		} ('getFieldOrNil' == (function getter)) {
		  varName = (last getterArgs)
		  if ('morph' != varName) {
			setField (first getterArgs) varName aHandler
		  }
		}
	  }
	}
  }
  animateBackToOldOwner (hand (global 'page')) (morph aHandler)
}

// instance creation

method addInstance Scripter {
  if (isNil targetObj) { return }
  setTargetObj this (instantiate (classOf targetObj) (stageMorph this))
}

// class operations

method classMenu Scripter {
  menu = (menu nil (action 'viewClassNamed' this) true)
  for className (sortedUserClassNames this) {
	addItem menu className
  }
  addLine menu
  addItem menu 'create a new class' '_createClass'
  addItem menu 'rename this class' '_renameClass'
  popUpAtHand menu (global 'page')
}

method sortedUserClassNames Scripter {
  result = (list)
  for cl (classes (targetModule this)) {
    if (notNil (scripts cl)) { add result (className cl) }
  }
  return (sorted result)
}

method viewClassNamed Scripter className {
  if (beginsWith className '_') { // class operation
	if ('_createClass' == className) { createClass this }
	if ('_renameClass' == className) { renameClass this (classOf targetObj) }
	return
  }
  if (isNil (class className)) { return }
  if (not (isClass targetObj className)) {
	setTargetObj this (findInstance this (classOf targetObj))
  }
}

method createClass Scripter isHelperClass {
  newClassName = (prompt (global 'page') 'Class name?' 'MyClass')
  if (or (isNil newClassName) (newClassName == '')) { return }
  cl = (makeNewClass this newClassName isHelperClass)
  removeAllParts (morph (contents scriptsFrame))
  setTargetObj this (instantiate cl (stageMorph this))
}

method createInitialClass Scripter {
  cl = (makeNewClass this 'MyClass')
  removeAllParts (morph (contents scriptsFrame))
  targetObj = (instantiate cl (stageMorph this))
  restoreScripts this
  saveScripts this
}

method setStageMorph Scripter stageM { stageMorph = stageM }

method stageMorph Scripter {
  // Return the morph of the stage, if there is one, or the morph of the page.
  if (notNil stageMorph) { return stageMorph }
  if (notNil projectEditor) { return (morph (stage projectEditor)) }
  return (morph (global 'page'))
}

method makeNewClass Scripter baseName isHelperClass {
  if (isNil isHelperClass) { isHelperClass = false }
  module = (targetModule this)
  newClassName = (unusedClassName module baseName)
  if isHelperClass {
	result = (defineClassInModule module newClassName)
  } else {
	result = (defineClassInModule module newClassName 'morph')
  }
  return result
}

method findInstance Scripter aClass {
  for m (allMorphs (morph (global 'page'))) {
    if (isClass (handler m) aClass) { return (handler m) }
  }
  return nil
}

method renameClass Scripter aClass {
  if ((module aClass) === (topLevelModule)) { return }
  oldClassName = (className aClass)
  newClassName = (prompt (global 'page') 'New class name?' oldClassName)
  if (or (newClassName == '') (newClassName == oldClassName)) { return }
  if (notNil (classNamed (module aClass) newClassName)) {
	inform (global 'page') (join 'Sorry, "' newClassName '" is already used')
	return
  }
  setName aClass newClassName
  if (aClass == (classOf targetObj)) {
	updateClassName this
  }
}

method exportClass Scripter aClass {
  fileName = (fileToWrite (className aClass) '.gp')
  if (isEmpty fileName) { return }
  pp = (new 'PrettyPrinter')
  contents = (join
	(specStringForFunctionsAndMethodsDefinedInClass aClass)
	(defStringForFunctionsDefinedInClass aClass)
	(prettyPrintClass pp aClass)
	(newline)
	(scriptString aClass))
  writeFile fileName contents
}

method importClass Scripter {
  pickFileToOpen (action 'importClassFromFile' this) (gpFolder) '.gp'
}

method importClassFromFile Scripter fileName {
  // Import a class from the given source file.

  projectModule = (targetModule this)
  s = (readFile fileName)
  m = (loadModuleFromString (initialize (new 'Module')) s)

  // import classes
  existingClassNames = (list)
  for c (classes projectModule) {
	add existingClassNames (className c)
  }
  classNameMap = (dictionary)
  for c (classes m) {
    newName = (uniqueNameNotIn existingClassNames (className c))
    atPut classNameMap (className c) newName
	setName c newName
	setField c 'module' projectModule
	addClass projectModule c
  }

  // import global functions
  // xxx later: deal with name conflicts (need to rename both the function and it's block spec)
  for f (functions m) {
	addFunction projectModule f
  }

  // add specs
  specDB = (authoringSpecs)
  for expr (parse s) {
	if (and (isClass expr 'Reporter') ('spec' == (primName expr))) {
	  spec = (specForEntry specDB (argList expr))
	  updateClassHint spec classNameMap
	  // xxx if block spec already exists, need to rename both spec and underlying method name
	  recordBlockSpec specDB (blockOp spec) spec
	}
  }

  // select imported class
  if ((count classNameMap) > 0) {
 	newClassName = (first (keys classNameMap))
	setTargetObj this (instantiate (classNamed projectModule newClassName) (stageMorph this))
  }
}

method deleteClass Scripter aClass {
  if ((module aClass) === (topLevelModule)) { return }
  if ('Variables' == (currentCategory this)) { selectCategory this 'Control' }
  className = (className aClass)
  targetObj = nil
  clearLibrary (library projectEditor)
  removeClassFromPages (project projectEditor) aClass
  deleteInstances this (allInstances aClass)
  gc
  instCount = (count (allInstances aClass))
  if (instCount > 0) {
	inform (global 'page') (join 'There are still ' instCount ' references to instances of this class; cannot delete')
	return
  }
  if (not (beginsWith className 'Obsolete')) {
	setField aClass 'className' (join 'Obsolete ' className)
  }
  setField aClass 'scripts' nil
  setField aClass 'comments' (array)
  removeClass (module aClass) aClass
  showAnotherClass this
}

method deleteInstances Scripter instances {
  // Remove the given list of instances from their owners.
  for obj instances {
	if (hasField obj 'morph') {
	  m = (morph obj)
	  o = (owner m)
	  if (notNil o) { removePart o m }
	}
  }
}

method showAnotherClass Scripter {
  // Try to view an existing instance of an existing user-defined class.
  // If no classes have instances, create one.
  // If there are no user-defined classes, view nil.
  module = (targetModule this)
  otherClasses = (sortedUserClassNames this)
  for className otherClasses {
	cl = (classNamed module className)
	if ((count (allInstances cl)) > 0) {
	  	setTargetObj this (findInstance this cl)
		return
	}
  }
  if ((count otherClasses) > 0) {
    cls = (classNamed module (first otherClasses))
    setTargetObj = (instantiate cls (stageMorph this))
  } else {
	setTargetObj this nil
  }
}

// save and restore scripts in class

method scriptChanged Scripter { saveNeeded = true }

method step Scripter {
  // Note: Sometimes get bursts of multiple 'changed' events, but those
  // events merely set the saveNeeded flag. This method does the actual
  // saveScripts if the saveNeeded flag is true.

  if saveNeeded {
	clearMethodCaches  // reset all cached after any programming change (probably only needs to be done for my scripts)
    saveScripts this
    saveNeeded = false
  }
}

method saveScripts Scripter {
  scale = (global 'scale')
  if (isNil targetObj) { return }
  scriptsPane = (contents scriptsFrame)
  paneX = (left (morph scriptsPane))
  paneY = (top (morph scriptsPane))
  scriptsCopy = (list)
  for m (parts (morph scriptsPane)) {
    if (isClass (handler m) 'Block') {
      x = (((left m) - paneX) / scale)
      y = (((top m) - paneY) / scale)
      script = (expression (handler m) (className (classOf targetObj)))
      if (isOneOf (primName script) 'method' 'to') {
        updateFunctionOrMethod this script
        args = (argList script)
        // only store the stub for a method or function in scripts
        if ('method' == (primName script)) {
          script = (newCommand (primName script) (first args) (at args 2))
        } else {
	      script = (newCommand (primName script) (first args))
        }
      }
      add scriptsCopy (array x y script)
    }
  }
  setScripts (classOf targetObj) scriptsCopy
}

method renameScriptToAPublicName Scripter from to {
  if (isNil targetObj) { return }
  cl = (classOf targetObj)
  scripts = (scripts cl)
  for s scripts {
    cmd = (at s 3)
    if (and ((primName cmd) == 'method') ((getField cmd 7) == from) ((getField cmd 8) == (className cl))) {
      setField cmd 7 to
    }
  }
  updateBlocks this
}

method updateFunctionOrMethod Scripter script {
  args = (argList script)
  functionName = (first args)
  newCmdList = (last args)
  if ('to' == (primName script)) {
    f = (functionNamed functionName)
  } ('method' == (primName script)) {
    f = (methodNamed (classOf targetObj) functionName)
  }
  if (notNil f) { updateCmdList f newCmdList }
}

method restoreScripts Scripter {
  scale = (global 'scale')
  updateClassName this
  scriptsPane = (contents scriptsFrame)
  removeAllParts (morph scriptsPane)
  clearDropHistory scriptsPane
  updateSliders scriptsFrame
  if (isNil targetObj) { return }
  targetClass = (classOf targetObj)
  scripts = (scripts targetClass)
  if (notNil scripts) {
    paneX = (left (morph scriptsPane))
    paneY = (top (morph scriptsPane))
    for entry (reversed scripts) {
      dta = (last entry)
      if ('method' == (primName dta)) {
        func = (methodNamed targetClass (first (argList dta)))
        block = (scriptForFunction func)
      } ('to' == (primName dta)) {
        func = (functionNamed (first (argList dta)))
        if (notNil func) {
		  block = (scriptForFunction func)
		} else {
		  // can arise when viewing a class from an imported module; just skip it for now
		  block = nil
		}
      } else {
        block = (toBlock dta)
      }
      if (notNil block) {
		x = (paneX + ((at entry 1) * scale))
		y = (paneY + ((at entry 2) * scale))
		fastMoveBy (morph block) x y
		addPart (morph scriptsPane) (morph block)
		fixBlockColor block
	  }
    }
  }
  updateSliders scriptsFrame
  updateBlocks this
  changed scriptsPane
}

method pasteScripts Scripter scriptString {
  scale = (global 'scale')
  updateClassName this
  scriptsPane = (contents scriptsFrame)
  clearDropHistory scriptsPane
  scripts = (parse scriptString)
  if (notNil scripts) {
	hand = (hand (global 'page'))
    x = (x hand)
    y = ((y hand) - (40 * scale)) // adjust for menu offset
    for entry scripts {
      if ('script' == (primName entry)) {
		script = (last (argList entry))
		if  ('method' == (primName script)) {
		  targetClass = (classOf targetObj)
		  cmd = (copyMethodOrFunction this script targetClass)
		  block = (scriptForFunction (methodNamed targetClass (first (argList cmd))))
		} ('to' == (primName script)) {
		  cmd = (copyMethodOrFunction this script nil)
		  block = (scriptForFunction (functionNamed (first (argList cmd))))
		} else {
		  block = (toBlock script)
		}
		moveBy (morph block) x y
		y += ((height (fullBounds (morph block))) + (10 * scale))
		addPart (morph scriptsPane) (morph block)
		fixBlockColor block
      }
    }
    scriptChanged this
  }
  updateSliders scriptsFrame
  updateBlocks this
}

method scrollToDefinitionOf Scripter aFunctionName {
  for m (parts (morph (contents scriptsFrame))) {
    if (isClass (handler m) 'Block') {
      def = (editedDefinition (handler m))
      if (notNil def) {
        if (== (op def) aFunctionName) {
          scrollIntoView scriptsFrame (fullBounds m) true // favorTopLeft
        }
      }
    }
  }
}

// Build Your Own Blocks

method createSharedBlock Scripter {
  page = (global 'page')
  cls = (classOf targetObj)
  name = (prompt page 'Enter a new block name:' 'myBlock')
  if (name == '') {return}
  opName = (uniqueMethodOrFunctionName this name)
  func = (defineFunctionInModule (targetModule this) opName (array) nil)
  spec = (blockSpecFromStrings opName ' ' name '')
  recordBlockSpec (authoringSpecs) opName spec
  addToBottom this (scriptForFunction func)
  updateBlocks this
}

method createMethodBlock Scripter {
  page = (global 'page')
  cls = (classOf targetObj)
  name = (prompt page 'Enter a new block name:' 'myBlock')
  if (name == '') {return}
  opName = (uniqueMethodOrFunctionName this name cls)
  func = (addMethod cls opName)
  spec = (blockSpecFromStrings opName ' ' (join name ' _') (className cls))
  recordBlockSpec (authoringSpecs) opName spec
  addToBottom this (scriptForFunction func)
  updateBlocks this
}

method copyMethodOrFunction Scripter definition targetClass {
  primName = (primName definition)
  args = (argList definition)
  body = (last args)
  if (notNil body) { body = (copy body) }
  oldOp = (first args)
  oldSpec = (specForOp (authoringSpecs) oldOp)
  if ('method' == primName) {
	newOp = (uniqueMethodOrFunctionName this oldOp targetClass)
	parameterNames = (copyFromTo args 3 ((count args) - 1))
	addMethod targetClass newOp parameterNames body
	if (notNil oldSpec) {
	  oldClassName = (at args 2)
	  newSpec = (copyWithOp oldSpec newOp oldClassName (className targetClass))
	} else {
	  newSpec = (blockSpecFor (methodNamed targetClass newOp))
	}
  } else {
	newOp = (uniqueMethodOrFunctionName this oldOp)
	parameterNames = (copyFromTo args 2 ((count args) - 1))
	defineFunctionInModule (targetModule this) newOp parameterNames body
	if (notNil oldSpec) {
	oldLabel = (first (specs oldSpec))
	newLabel = (uniqueFunctionName this oldLabel)
	newSpec = (copyWithOp oldSpec newOp oldLabel newLabel)
	} else {
	  newSpec = (blockSpecFor (functionNamed (targetModule this) newOp))
	}
  }
  recordBlockSpec (authoringSpecs) newOp newSpec
  return (newCommand primName newOp)
}

method uniqueMethodName Scripter targetClass baseSpec {
  existingNames = (list)
  allSpecs = (blockSpecs (project projectEditor))
  for method (methods targetClass) {
	methodSpec = (at allSpecs (functionName method)) // should always find a spec
	if (notNil methodSpec) {
	  add existingNames (first (words (first (specs methodSpec))))
	}
  }
  specWords = (words baseSpec)
  firstWord = (first specWords)
  if ('_' == firstWord) {
	firstWord = 'm'
	specWords = (join (array 'm') specWords)
  }
  atPut specWords 1 (uniqueNameNotIn existingNames firstWord)
  return (joinStrings specWords ' ')
}

method uniqueFunctionName Scripter baseSpec {
  existingNames = (list)
  for spec (values (blockSpecs (project projectEditor))) {
	add existingNames (first (words (first (specs spec))))
  }
  specWords = (words baseSpec)
  firstWord = (first specWords)
  if ('_' == firstWord) {
	firstWord = 'f'
	specWords = (join (array 'f') specWords)
  }
  atPut specWords 1 (uniqueNameNotIn existingNames firstWord)
  return (joinStrings specWords ' ')
}

method createInitializeMethodBlock Scripter {
  opName = 'initialize'
  cls = (classOf targetObj)
  func = (addMethod cls opName (array 'this'))
  addToBottom this (scriptForFunction func)
  updateBlocks this
}

method removedUserDefinedBlock Scripter function {
  // Remove the given user-defined function or method.

  if (isMethod function) {
	removeMethodNamed (class (classIndex function)) (functionName function)
  } else {
	removeFunction (module function) function
  }

  blockDeleted (project projectEditor) (functionName function)
}

method uniqueMethodOrFunctionName Scripter baseName aClass {
  baseName = (withoutTrailingDigits baseName)
  if (baseName == '') { baseName = 'm' }
  existingNames = (list)
  addAll existingNames (allOpNames (authoringSpecs))
  if (isNil aClass) {
	for f (globalFuncs) { add existingNames (functionName f) }
	for f (functions (targetModule this)) { add existingNames (functionName f) }
  } else {
	addAll existingNames (methodNames aClass)
  }
  return (uniqueNameNotIn existingNames baseName)
}

method addToBottom Scripter aBlock noScroll {
  if (isNil noScroll) {noScroll = false}
  space =  ((global 'scale') * 10)
  bottom = (top (morph (contents scriptsFrame)))
  left = ((left (morph (contents scriptsFrame))) + (50 * (global 'scale')))
  for script (parts (morph (contents scriptsFrame))) {
    left = (min left (left (fullBounds script)))
    bottom = (max bottom (bottom (fullBounds script)))
  }
  setPosition (morph aBlock) left (bottom + space)
  addPart (morph (contents scriptsFrame)) (morph aBlock)
  if (not noScroll) {
    scrollIntoView scriptsFrame (fullBounds (morph aBlock))
  }
  scriptChanged this
}

method reactToMethodDelete Scripter aPalette {
  if (== 'My Blocks' (selection (contents categoriesFrame))) {
    updateBlocks this
  }
}

method blockPrototypeChanged Scripter aBlock {
  scriptsPane = (contents scriptsFrame)
  op = (primName (function aBlock))

  // update the definition body
  block = (handler (owner (morph aBlock)))
  nxt = (next block)
  if (and (notNil nxt) (containsPrim nxt op)) {
    body = (toBlock (cmdList (function aBlock)))
    setNext block nil
    setNext block body
  }

  // update the palette template
  updateBlocks this

  // update all calls
  if ('initialize' != op) {
	updateCallsOf this op
	updateCallsInScriptingArea this op
  }
  updateSliders scriptsFrame
}

method updateCallsOf Scripter op {
  // Update calls of the give operation to ensure that they have the minimum number
  // of arguments specified by the prototype and that the types of any constant
  // parameters match those of the the prototype.

  // get spec and extract arg types and default values
  spec = (specForOp (authoringSpecs) op)
  if (isNil spec) { return } // should not happen
  minArgs = (countInputSlots spec (first (specs spec)))
  isReporter = (isReporter spec)
  isVariadic = (or ((count (specs spec)) > 1) (repeatLastSpec spec))
  argTypes = (list)
  argDefaults = (list)
  for i (slotCount spec) {
	info = (slotInfoForIndex spec i)
	typeStr = (at info 1)
	defaultValue = (at info 2)
	if (and (isNil defaultValue) ('color' == typeStr)) {
      defaultValue = (color 35 190 30)
	}
	add argTypes typeStr
	add argDefaults defaultValue
  }

  // update all calls
  s = (first (specs spec))
  origCmds = (list)
  newCmds = (list)
  gc
  for cmd (allCmdsInProject this) {
	if ((primName cmd) == op) {
	  add origCmds cmd
	  add newCmds (fixedCmd this cmd minArgs argTypes argDefaults isReporter isVariadic)
	}
  }
  // replace command/reporter objects with new versions
  replaceObjects (toArray origCmds) (toArray newCmds)
}

method allCmdsInProject Scripter {
  m = (module (project projectEditor))
  result = (dictionary)
  for f (functions m) {
	addAll result (allBlocks (cmdList f))
  }
  for c (classes m) {
	for m (methods c) {
	  addAll result (allBlocks (cmdList m))
	}
	scripts = (scripts c)
	if (notNil (scripts c)) {
	  for s (scripts c) {
		addAll result (allBlocks (at s 3))
	  }
	}
  }
  return (keys result)
}

method fixedCmd Scripter oldCmd minArgs argTypes argDefaults isReporter isVariadic {
  // Return an updated Command or Reporter.

  args = (toList (argList oldCmd))

  // add new arguments with default values
  while ((count args) < minArgs) {
	add args (at argDefaults ((count args) + 1))
  }

  // if not variadic, remove extra arguments
  if (not isVariadic) {
	while ((count args) > minArgs) {
	  removeLast args
	}
  }

  // fix type inconsistencies for non-expression arguments
 for i (min minArgs (count args) (count argTypes) (count argDefaults)) {
	arg = (at args i)
	if (not (isClass arg 'Reporter')) {
	  desiredType = (at argTypes i)
	  if (and ('auto' == desiredType) (not (or (isNumber arg) (isClass arg 'String')))) {
		atPut args i (at argDefaults i)
	  }
	  if (and ('bool' == desiredType) (not (isClass arg 'Boolean'))) {
		atPut args i (at argDefaults i)
	  }
	  if (and ('color' == desiredType) (not (isClass arg 'Color'))) {
		atPut args i (at argDefaults i)
	  }
	}
  }

  // create a new command/reporter with new args list
  if isReporter {
	result = (newIndexable 'Reporter' (count args))
  } else {
	result = (newIndexable 'Command' (count args))
  }
  fixedFields = (fieldNameCount (classOf result))
  setField result 'primName' (primName oldCmd)
  for i (count args) {
    setField result (fixedFields + i) (at args i)
  }
  return result
}

method updateCallsInScriptingArea Scripter op {
  // Update scripts in the scripting pane that contain calls to the give op.

  scriptsPane = (contents scriptsFrame)
  affected = (list)
  for m (parts (morph scriptsPane)) {
	b = (handler m)
	if (and (isClass b 'Block') (containsPrim b op)) {
	  add affected b
	}
  }
  for each affected {
	expr = (expression each)
	if ('method' == (primName expr)) {
	  func = (methodNamed (classOf targetObj) (first (argList expr)))
	  block = (scriptForFunction func)
	} ('to' == (primName expr)) {
	  func = (functionNamed (first (argList expr)))
	  block = (scriptForFunction func)
	} else {
	  block = (toBlock expr)
	  setNext block (next each)
	}
	x = (left (morph each))
	y = (top (morph each))
	destroy (morph each)
	setPosition (morph block) x y
	addPart (morph scriptsPane) (morph block)
	fixBlockColor block
  }
}
defineClass ScrollFrame morph contents hSlider vSlider noSliders enableAutoScroll

to area aHandler {return (fullBounds (morph aHandler))}

to scrollFrame contents aColor noSliderFlag {
  return (initialize (new 'ScrollFrame') contents aColor noSliderFlag)
}

method initialize ScrollFrame newContents aColor noSliderFlag {
  sliderTransparency = 180
  if (isNil aColor) { aColor = (gray 200) }
  if (isNil noSliderFlag) { noSliderFlag = false }
  morph = (newMorph this)
  setCostume morph aColor
  contents = newContents
  noSliders = noSliderFlag
  enableAutoScroll = true
  addPart morph (morph contents)
  setTransparentTouch morph true
  setClipping morph true
  hSlider = (slider 'horizontal')
  setAlpha (morph hSlider) sliderTransparency
  addPart morph (morph hSlider)
  vSlider = (slider 'vertical')
  setAlpha (morph vSlider) sliderTransparency
  addPart morph (morph vSlider)
  setAction hSlider (action 'scrollToX' this)
  setAction vSlider (action 'scrollToY' this)
  updateSliders this
  return this
}

method contents ScrollFrame {return contents}
method setAutoScroll ScrollFrame bool {enableAutoScroll = bool}

method setContents ScrollFrame aHandler {
  idx = (indexOf (parts morph) (morph contents))
  setOwner (morph contents) nil
  atPut (parts morph) idx (morph aHandler)
  setOwner (morph aHandler) morph
  contents = aHandler
  setPosition (morph contents) (left morph) (top morph)
  updateSliders this
  changed morph
}

method drawOn ScrollFrame ctx {
  // Fill bounds with my color.
  drawCostumeOn morph ctx
}

method hideSliders ScrollFrame {
  noSliders = true
  hide (morph hSlider)
  hide (morph vSlider)
}

method showSliders ScrollFrame {
  noSliders = false
  updateSliders this
}

method updateSliders ScrollFrame doNotAdjustContents {
  if (true != doNotAdjustContents) { adjustContents this }
  if noSliders {
    hide (morph hSlider)
    hide (morph vSlider)
    return
  }
  hw = (height (morph hSlider))
  vw = (width (morph vSlider))
  b = (bounds morph)
  bc = (fullBounds (morph contents))
  if (isClass contents 'TreeBox') {bc = (area contents)}
  w = (width b)
  wc = (width bc)
  h = (height b)
  hc = (height bc)

  if ((+ hc hw) > h) {
    show (morph vSlider)
    fastSetPosition (morph vSlider) ((right b) - vw) (top b)
    setHeight (bounds (morph vSlider)) (- h hw)
    if ((bottom bc) < (- (bottom b) hw)) {setBottom (morph contents) (- (bottom b) hw)}

    shift = ((top b) - (top bc))
    overlap = ((hc + hw) - h)
    if (or (shift == 0) (overlap == 0)) {
      val = 0
    } else {
      ratio = (shift / overlap)
      val = (ratio * (hc + hw))
    }
    update vSlider 0 (+ hc hw) val h

  } else {
    hide (morph vSlider)
    fastSetTop (morph contents) (top b)
  }

  if (or (and (isVisible (morph vSlider)) ((+ wc vw) > w)) (and (not (isVisible (morph vSlider))) (wc > w))) {
    show (morph hSlider)
    fastSetPosition (morph hSlider) (left b) ((bottom b) - hw)
    setWidth (bounds (morph hSlider)) (- w vw)
    if ((right bc) < (- (right b) vw)) {fastSetRight (morph contents) (- (right b) vw)}

    shift = ((left b) - (left bc))
    overlap = ((wc + vw) - w)
    if (or (shift == 0) (overlap == 0)) {
      val = 0
    } else {
      ratio = (shift / overlap)
      val = (ratio * (wc + vw))
    }
    update hSlider 0 (+ wc vw) val w

  } else {
    hide (morph hSlider)
    fastSetLeft (morph contents) (left b)
  }

  if (and (not (isVisible (morph hSlider))) (hc <= h)) {
    hide (morph vSlider)
  } (not (isVisible (morph hSlider))) {
    setExtent (morph vSlider) nil h

    shift = ((top b) - (top bc))
    overlap = (hc - h)
    if (or (shift == 0) (overlap == 0)) {
      val = 0
    } else {
      ratio = (shift / overlap)
      val = (ratio * hc)
    }
    update vSlider 0 hc val h
  }
  changed morph
}

method updateSliderPositions ScrollFrame {
  if (not (or (isVisible (morph vSlider)) (isVisible (morph hSlider)))) {
	return // neither slider is visible
  }

  frameBnds = (bounds morph)
  contentBnds = (fullBounds (morph contents))
  if (isClass contents 'TreeBox') { contentBnds = (area contents) }

  if (isVisible (morph vSlider)) {
    shift = ((top frameBnds) - (top contentBnds))
    overlap = ((height contentBnds) - (height frameBnds))
    if (or (shift == 0) (overlap == 0)) {
      val = 0
    } else {
      ratio = (shift / overlap)
      val = (ratio * (height contentBnds))
    }
    update vSlider 0 (height contentBnds) val (height frameBnds)
  }

  if (isVisible (morph hSlider)) {
	totalW = ((width contentBnds) + (width (morph vSlider)))
    shift = ((left frameBnds) - (left contentBnds))
    overlap = (totalW - (width frameBnds))
    if (or (shift == 0) (overlap == 0)) {
      val = 0
    } else {
      ratio = (shift / overlap)
      val = (ratio * totalW)
    }
    update hSlider 0 totalW val (width frameBnds)
  }
}

method adjustContents ScrollFrame {
  if (isAnyClass contents 'ListBox' 'TreeBox') {
    h = (height (area contents))
    if (and (isVisible (morph hSlider)) ((+ h (height (morph hSlider))) > (height morph))) {
      setMinWidth contents (- (width morph) (width (morph vSlider)))
    } else {
      setMinWidth contents (width morph)
    }
  } (implements contents 'adjustSizeToScrollFrame') {
    adjustSizeToScrollFrame contents this
  }
  changed morph
}

method scrollToX ScrollFrame x {
  if (0 == (ceiling hSlider)) {
    // special case when empty
    fastSetLeft (morph contents) (left morph)
    return
  }

  w = (width (area contents))
  overlap = (toFloat (-
    (+ w (width (morph vSlider)))
    (width morph)
  ))
  fastSetLeft (morph contents) (-
    (left morph)
    (toInteger (* (/ (toFloat x) (ceiling hSlider)) overlap))
  )
  changed morph
}

method scrollToY ScrollFrame y {
  if (0 == (ceiling vSlider)) {
    // special case when empty
    fastSetTop (morph contents) (top morph)
    return
  }

  h = (height (area contents))
  if (not (isVisible (morph hSlider))) {
      overlap = (toFloat (- h (height morph)))
  } else {
      overlap = (toFloat (-
        (+ h (height (morph hSlider)))
        (height morph)
      ))
  }
  fastSetTop (morph contents) (-
    (top morph)
    (toInteger (* (/ (toFloat y) (ceiling vSlider)) overlap))
  )
  changed morph
}

method scrollIntoView ScrollFrame aRect favorTopLeft {
  ca = (clientArea this)
  trgt = aRect
  if (true == favorTopLeft) {
    trgt = (copy aRect)
    setWidth trgt (min (width trgt) (width ca))
    setHeight trgt (min (height trgt) (height ca))
  }
  currentlyClipping = (isClipping morph)
  setClipping morph false
  if (isClass contents 'Text') {
    keepWithin (morph contents) (insetBy ca (borderX contents) (borderY contents)) trgt
  } else {
    keepWithin (morph contents) ca trgt
  }
  updateSliders this
  setClipping morph currentlyClipping
}

method clientArea ScrollFrame {
  sw = (getField hSlider 'thickness')
  b = (bounds morph)
  if (isVisible (morph hSlider)) {
    return (rect (left b) (top b) ((width b) - sw) ((height b) - sw))
  }
  return (rect (left b) (top b) ((width b) - sw) (height b))
}

// events

method clicked ScrollFrame hand {
  if (and (isClass contents 'Text') ((editRule contents) != 'static')) {
    edit (keyboard (page hand)) contents
    selectAll contents
  }
  return false
}

method rightClicked ScrollFrame {
  raise morph 'handleContextRequest' this
  return true
}

// Scrolling with scrollwheel and keys

method swipe ScrollFrame x y {
  changeScrollOffset this (0 - x) (0 - y)
  return true
}

method scrollEnd ScrollFrame { changeScrollOffset this 0 1000000 }
method scrollHome ScrollFrame { changeScrollOffset this 0 -1000000 }

method arrowKey ScrollFrame dx dy {
	if (or
		(isClass contents 'TreeBox')
		(isClass contents 'ListBox')
	) {
		arrowKey contents dx dy this
		return
	}
	stepSize = (-50 * (global 'scale'))
	changeScrollOffset this (dx * stepSize) (dy * stepSize)
}

method scrollPage ScrollFrame dir {
  stepSize = ((height morph) / 3)
  changeScrollOffset this 0 (dir * stepSize)
}

method changeScrollOffset ScrollFrame dx dy {
  contentsM = (morph contents)

  maxXOffset = (max 0 ((width contentsM) - (width morph)))
  maxYOffset = (max 0 ((height contentsM) - (height morph)))

  if (isVisible (morph vSlider)) { maxXOffset += (width (morph vSlider)) }
  if (isVisible (morph hSlider)) { maxYOffset += (height (morph hSlider)) }

  xOffset = (((left morph) - (left contentsM)) + dx)
  yOffset = (((top morph) - (top contentsM)) + dy)

  xOffset = (round (clamp xOffset 0 maxXOffset))
  yOffset = (round (clamp yOffset 0 maxYOffset))

  fastSetPosition contentsM ((left morph) - xOffset) ((top morph) - yOffset)
  changed morph
  updateSliderPositions this
}

// auto-scrolling

method step ScrollFrame {
  hand = (hand (global 'page'))
  dragged = (grabbedObject hand)
  if (and
      enableAutoScroll
      (notNil dragged)
      (containsPoint (bounds morph) (x hand) (y hand))
      (wantsDropOf (contents this) dragged)
  ) {
    autoScroll this hand dragged
  }
}

method autoScroll ScrollFrame hand obj {
  thres = (80 * (global 'scale'))
  jump = (15 * (global 'scale'))
  dx = 0
  dy = 0

  if (((x hand) - (left morph)) < thres) { dx = jump }
  if (((right morph) - (x hand)) < thres) { dx = (0 - jump) }
  if (((y hand) - (top morph)) < thres) { dy = jump }
  if (((bottom morph) - (y hand)) < thres) { dy = (0 - jump) }

  if (or (dx != 0) (dy != 0)) {
    extra = (10 * (global 'scale'))
    contentBounds = (bounds (morph contents))
    frameBounds = (bounds morph)
    minX = ((right frameBounds) - ((width contentBounds) + extra))
    minY = ((bottom frameBounds) - ((height contentBounds) + extra))
    newX = (clamp ((left contentBounds) + dx) minX (left frameBounds))
    newY = (clamp ((top contentBounds) + dy) minY (top frameBounds))

    fastSetPosition (morph contents) newX newY
    changed morph
    updateSliders this true
  }
}
// Serializer.gp - Object structure serialization/deserialization
//
// The serializer packs an arbitrary graph of objects into a binary
// representation that can be saved in a file or transmitted to another
// computer, allowing a copy of the original object graph to be reconstructed
// later or elsewhere.
//
// The API has two top level functions:
//
//	write - takes the root of an object structure and an optional list of
//	  objects to ignore and returns the serialization (a BinaryData object)
//
//	read - converts a serialization (BinaryData) into a reconstruction of the
//		original object structure and returns the root of that structure
//
// The API calls write and read a single root object, but multiple of objects
// can be handled simply by serializing a list or array.
//
// Implementation Details
//
// A serialization has the following structure:
//
//	prefix string
//	class table (className, class field names)
//	object table (classIndex, indexable field count or nil, field values)
//    OR an immediate value
//	postfix string
//
// The prefix and postfix strings are human-readable and designed to allow
// serialized object data to be embedded in a text file and possibly copied
// and pasted as a unit into some other text file using a generic text editor.
// (The binary data in between appears as gibberish, of course, and can't be
// meaningfully edited as text.)
//
// Except for the pre- and postfix strings, all data in the file is rendered
// as a sequence of low-level data objects (numbers, strings, arrays, etc.)
// represented as a tag byte followed by zero or more data bytes. Higher level
// structures such as the class and object tables are built out of low-level objects.
//
// Classes can control their serialized representation by implementing three methods:
//
//	serialize - returns an array of field values (including unnamed indexable fields)
//	serializedFieldNames - returns an array of field names
//  deserialze - called on an uninitialized instance with a dictionary of fieldName, fieldValue pairs
//
// Default serialization behavior is suppled generic versions of these functions
// that simply save and restore all the fields of the object's class.
//
// Although there is no explicit class version number, this representation is fairly
// robust in the face of class evolution. For example, a class in the destination
// system can have its fields in a different order than the system that created
// the serialization, or it can have missing or extra fields. Furthermore, the
// deserialization method can tell from the dictionary keys that a field is
// missing and can supply a default or computed value.
//
// Any classes mentioned in the class table that do not exist in the destination
// system are created as "stubs" with the given field names. This allows instances
// of those classes to be deserialized as simple records, even though the stub
// class has no behavior. This allows the deserialized objects to be inspected.
// Behavior can be added the stub class incrementally to bring these objects to life.
//
// As mentioned, the write call takes an optional list of objects that should
// not be included in the serialization. All references to these objects will be
// replaced by nils in the serialization.

// Default serialization methods (classes may override to customize serialized data)

to serializedFieldNames obj {
  // Return an array of field names for this object's serialization array.
  // This default method just returns the field names for the object's class.

  return (fieldNames (classOf obj))
}

to serialize obj {
  // Return an array that captures the state of this object,
  // where the array entries correspond to serializedFieldNames.

  result = (list)
  for fieldName (serializedFieldNames obj) {
    add result (getField obj fieldName)
  }
  return (toArray result)
}

to deserialize obj fieldDict {
  // Initialize this object from the given dictionary.

  for k (fieldNames (classOf obj)) {
	setField obj k (at fieldDict k)
  }
}

defineClass ObjRef objID

method objID ObjRef { return objID }

defineClass Serializer verbose stream objectTable objects objectsToIgnore classTable classes fieldsForClass prefix postfix version t_nil t_ref t_true t_false t_int t_float t_string t_binary t_array

// Constants

method initConstants Serializer {
  version = 1
  crlf = (string 13 10)
  prefix = (join '~=== Begin GP Object Data ===~' crlf)
  postfix = (join crlf '~=== End GP Object Data ===~')
  verbose = false
  t_nil = 0
  t_true = 1
  t_false = 2
  t_int = 3
  t_float = 4
  t_string = 5
  t_binary = 6
  t_array = 7
  t_ref = 255
}

// Writing

method write Serializer rootObj ignoring {
  // Serialize the given object and all objects reachable from it
  // and return the resulting BinaryData. Objects in the optional
  // parameter 'ignoring' will be omitted from the serialization.

  if (notNil ignoring) {
	objectsToIgnore = (dictionary)
	addAll objectsToIgnore ignoring
  }
  initConstants this
  stream = (dataStream (newBinaryData 100000))
  if (isImmediate this rootObj) {
	writeImmediate this rootObj
	return (contents stream)
  }
  gc
  objectTable = (table 'object' 'className' 'fields')
  objects = (dictionary)
  grow objects 10000
  classes = (dictionary)
  fieldsForClass = (dictionary)

  collectObjects this rootObj
  linkObjects this
  gc

  // Note: write prefix and postfix as raw strings to support copy/paste in text editor
  nextPutAll stream prefix
  writeNext this version
  writeClassTable this
  writeObjectTable this
  nextPutAll stream postfix

  // free up memory
  objectTable = nil
  objects = nil
  classes = nil
  gc

  return (contents stream)
}

method writeImmediate Serializer rootObj {
  nextPutAll stream prefix
  writeNext this version
  writeNext this (array) // empty class table
  writeNext this rootObj // write an immediate object instead of object table
  nextPutAll stream postfix
}

method collectObjects Serializer rootObj {
  toDo = (list rootObj)
  while (notEmpty toDo) {
    obj = (removeFirst toDo)
    if (not (contains objects obj)) { // obj is not already in the object table; add it

	  className = (className (classOf obj))
	  if (not (contains classes className)) {
		// record this class and its serializedFieldNames
		classID = ((count classes) + 1)
		atPut classes className classID
		atPut fieldsForClass className (serializedFieldNames obj)
	  }

	  if (isOneOf className 'String' 'BinaryData') {
		add objectTable obj className nil
	  } else {
		if ('Array' == className) {
		  fields = (clone obj)
		} else {
		  fields = (serialize obj)
		}
		add objectTable obj className fields

		// add any references to objects that have not been processed to the toDo list
		for i (count fields) {
		  o = (at fields i)

		  if (isClass o 'Module') {
			// don't follow references to Modules
			if (not (isOneOf o (topLevelModule) (sessionModule))) {
			  // print warning if reference is not to the top or session module
			  print 'warning: Serializer is ignoring reference to module' o 'from' obj
			}
			atPut fields i nil
			o = nil
		  }

		  if (and (notNil objectsToIgnore) (contains objectsToIgnore o)) {
			// nil out references to objects in the 'ignore' list
		    atPut fields i nil
			o = nil
		  }
		  if (and (notNil o) (not (isImmediate this o)) (not (contains objects o))) {
			add toDo o
		  }
		}
	  }
	  objID = (rowCount objectTable)
	  atPut objects obj objID
	}
  }
}

method isImmediate Serializer obj {
  // An immediate object is encoded inline; it does not have an entry in the object table.
  return (isAnyClass obj 'Integer' 'Boolean' 'Float' 'ExternalReference' 'Nil')
}

method linkObjects Serializer {
  // Replace object references in fields arrays with instances of ObjRef
  // that link to the corresponding object table entry.

  for r (rowCount objectTable) {
    fields = (cellAt objectTable r 'fields')
	if (notNil fields) { // object has a fields array
	  for i (count fields) {
		obj = (at fields i)
		objID = (at objects obj)
		if (notNil objID) {
		  atPut fields i (new 'ObjRef' objID)
		}
	  }
	}
  }
}

method writeClassTable Serializer {
  // Write the class table to my stream.

  if verbose {
	print 'Writing class table,' (count classes) 'classes:'
  }
  classTable = (list)
  for p (sortedPairs classes) {
    className = (last p)
	add classTable className
	add classTable (at fieldsForClass className)
	if verbose { print '   ' className (at fieldsForClass className) }
  }
  writeNext this (toArray classTable)
  if verbose {
    print 'Wrote class table,' (position stream) 'bytes.'
  }
}

method writeObjectTable Serializer {
  // Write the object table to my stream.

  if verbose {
	print 'Writing object table,' (rowCount objectTable) 'objects:'
  }
  table = (list)
  for r (rowCount objectTable) {
	indexableCount = nil
    obj = (cellAt objectTable r 'object')
	className = (cellAt objectTable r 'className')
	objData = (cellAt objectTable r 'fields')
	if (isNil objData) {  // binary data
	  objData = obj
	} ('Array' != className) {
	  indexableCount = ((objWords obj) - (count (fieldNames (classOf obj))))
	  if (indexableCount == 0) { indexableCount = nil }
	}
	add table (at classes className)
	add table indexableCount
	if verbose { print '  ' className }
    add table objData
  }
  startPos = (position stream)
  writeNext this (toArray table)
  if verbose {
	print 'Wrote object table,' ((position stream) - startPos) 'bytes.'
  }
}

// Reading

method version Serializer data {
  initConstants this
  stream = (dataStream data)
  readPrefix this
  return (readNext this)
}

method read Serializer data {
  // Read and reconstruct a serialized object structure from the given BinaryData.

  initConstants this
  stream = (dataStream data)
  readPrefix this
  readVersion this
  readClassTable this
  ensureClassesDefined this
  readObjectTable this
  resolveReferences this
  deserializeObjects this
  fixMethodsAndMonitors this
  readPostfix this
  return (cellAt objectTable 1 'object')
}

method readPrefix Serializer {
  s = (nextString stream (byteCount prefix))
  if (s != prefix) { error 'serialize: bad prefix' }
}

method readVersion Serializer {
  v = (readNext this)
  if (v != version) { error (join 'serialize: cannot read object data version' v) }
}

method readPostfix Serializer {
  s = (nextString stream (byteCount postfix))
  if (s != postfix) { error 'serialize: bad postfix' }
}

method readClassTable Serializer {
  // Read the class table, an array of (className, fieldList) pairs.

  classArray = (readNext this)
  classTable = (list)
  fieldsForClass = (list)
  i = 1
  if verbose { print 'Reading' ((count classArray) / 2) 'classes:' }
  repeat ((count classArray) / 2) {
	add classTable (at classArray i)
	add fieldsForClass (at classArray (i + 1))
	if verbose { print '  ' (count classTable) (at classArray i) (at classArray (i + 1)) }
    i += 2
  }
  classTable = (toArray classTable)
  fieldsForClass = (toArray fieldsForClass)
}

method ensureClassesDefined Serializer {
  // Ensure that all the classes in the class table are defined.

  existingClasses = (dictionary)
  for c (classes) { add existingClasses (className c) }

  for i (count classTable) {
    className = (at classTable i)
	if (not (contains existingClasses className)) {
	  callWith 'defineClass' (join (array className) (at fieldsForClass i))
	  clearCaches (class className)
	}
  }
}

method readObjectTable Serializer {
  // Read the object array, instantiate objects, and build the object table.

  objectTable = (table 'classIndex' 'className' 'fields' 'object')
  objArray = (readNext this)
  if (not (isClass objArray 'Array')) { // serialized object is an immediate value
	add objectTable nil nil nil objArray
	return
  }
  i = 1
  if verbose { print 'Reading' ((count objArray) / 3) 'objects' }
  repeat ((count objArray) / 3) {
	classIndex = (at objArray i)
	indexableCount = (at objArray (i + 1))
	fields = (at objArray (i + 2))
	className = (at classTable classIndex)
	if (and (isClass fields 'Array') ('Array' != className)) {
	  // instantiate objects that are neither binary objects nor Arrays
	  if (notNil indexableCount) {
		object = (newIndexable className indexableCount)
	  } else {
		object = (new className)
	  }
	} else {
	  object = fields
	}
	add objectTable classIndex className fields object
	i += 3
  }
}

method resolveReferences Serializer {
  // Replace all object references (instances of ObjRef) with
  // references to the corresponding object in the object table.

  for r (rowCount objectTable) {
    fields = (cellAt objectTable r 'fields')
	if (isClass fields 'Array') {
	  for i (count fields) {
		ref = (at fields i)
		if (isClass ref 'ObjRef') {
		  obj = (cellAt objectTable (objID ref) 'object')
		  atPut fields i obj
		}
	  }
	}
  }
}

method deserializeObjects Serializer {
  // Initialize object contents from their field dictionaries.

  empty = (array)
  for r (rowCount objectTable) {
    obj = (cellAt objectTable r 'object')
	if (and (not (isAnyClass obj 'Array' 'String' 'BinaryData')) (notNil (cellAt objectTable r 'classIndex')))  {
	  // build a field dictionary and call deserialize
	  fieldNames = (at fieldsForClass (cellAt objectTable r 'classIndex'))
	  fieldNameCount = (count fieldNames)
	  fields = (cellAt objectTable r 'fields')
	  fieldCount = (count fields)
	  d = (dictionary)
	  for i (min fieldNameCount fieldCount) {
		atPut d (at fieldNames i) (at fields i)
	  }
	  extraCount = (fieldCount - fieldNameCount)
	  if (extraCount > 0) {
		extraFields = (copyArray fields extraCount (fieldNameCount + 1))
	  } else {
	    extraFields = empty
	  }
	  deserialize obj d extraFields
	}
  }
}

// low-level serialization

method readNext Serializer {
  tag = (nextUInt8 stream)
  if (t_nil == tag) { return nil }
  if (t_int == tag) { return (nextInt stream) }
  if (t_ref == tag) { return (new 'ObjRef' (nextUInt32 stream)) }
  if (t_true == tag) { return true }
  if (t_false == tag) { return false }
  if (t_float == tag) { return (nextFloat32 stream) } // need prim for double
  if (t_array == tag) {
    count = (nextUInt32 stream)
	result = (newArray count)
	for i count {
	  atPut result i (readNext this)
	}
	return result
  } (t_string == tag) {
	count = (nextUInt32 stream)
	return (nextString stream count)
  } (t_binary == tag) {
    count = (nextUInt32 stream)
	return (nextData stream count)
  } else {
	error 'unknown tag; serialized data corrupted?'
  }
}

method writeNext Serializer obj {
  if (isNil obj) { putUInt8 stream t_nil; return }
  if (true === obj) { putUInt8 stream t_true; return }
  if (false === obj) { putUInt8 stream t_false; return }
  className = (className (classOf obj))
  if ('Integer' == className) {
    putUInt8 stream t_int
	putInt stream obj
  } ('Float' == className) {
    putUInt8 stream t_float
	putFloat32 stream obj
  } ('Array' == className) {
    putUInt8 stream t_array
	putUInt32 stream (count obj)
	for i (count obj) {
	  writeNext this (at obj i)
	}
  } ('String' == className) {
    putUInt8 stream t_string
	putUInt32 stream (byteCount obj)
	nextPutAll stream obj
  } ('ObjRef' == className) {
    putUInt8 stream t_ref
	putUInt32 stream (objID obj)
  } ('BinaryData' == className) {
    putUInt8 stream t_binary
	putUInt32 stream (byteCount obj)
	nextPutAll stream obj
  } ('ExternalReference' == className) {
	putUInt8 stream t_nil // replace ExternalReferences with nil
  } else {
    error (join 'cannot serialize ' className)
  }
}

// tests

method lowLevelTest Serializer {
  // lowLevelTest (new 'Serializer')
  testData = (array nil true false 1 0.5 'GP Rocks!' (array 1 2 3))
  initConstants this
  verbose = true
  stream = (dataStream (newBinaryData 100))

  for datum testData {
	setPosition stream 0
	writeNext this datum
	setPosition stream 0
	out = (readNext this)
	assert out datum
  }

  setPosition stream 0
  writeNext this (newBinaryData 10)
  writeNext this (new 'ObjRef' 42)
  writeNext this testData
  setPosition stream 0

  out = (readNext this)
  assert (classOf out) (class 'BinaryData')
  assert (byteCount out) 10

  out = (readNext this)
  assert (classOf out) (class 'ObjRef')
  assert (objID out) 42

  out = (readNext this)
  assert (classOf out) (class 'Array')
  assert (count out) (count testData)
}

// work-around for serialized methods

method fixMethodsAndMonitors Serializer {
  // The serializer does not yet handle functions with non-zero
  // classIndex fields (i.e. methods). The index of the desired
  // class may be different when it is deserialized, so references
  // to classes should be stored in some other form (e.g. module + class name).
  // Until then, method object should not be serialized at all but, in
  // case they are, then their class index is set to zero when deserialized
  // to avoid being associated with an unexpected (or non-existant) class.
  // Some old projects have Monitor objects with (broken) method
  // objects in them, so this method replaces the actions of those
  // Monitors with noops, allowing the project to be opened so that
  // the broken Monitors can be replaced.

  // First, fix the monitors
  for r (rowCount objectTable) {
    if ('Monitor' == (cellAt objectTable r 'className')) {
	  monitor = (cellAt objectTable r 'object')
	  if (hasMethod this (getField monitor 'getAction')) {
		setField monitor 'getAction' (action 'noop')
	  }
	}
  }

  // Then, fix the methods
  for r (rowCount objectTable) {
	if ('Function' == (cellAt objectTable r 'className')) {
	  fnc = (cellAt objectTable r 'object')
	  setField fnc 'classIndex' 0
	}
  }
}

method hasMethod Serializer action {
  if (not (isClass action 'Action')) { return false }
  fnc = (function action)
  return (and (isClass fnc 'Function') (isMethod fnc))
}

// debugging

method traceFunctionRefs Serializer {
  for r (rowCount objectTable) {
    cl = (cellAt objectTable r 'className')
	if ('Function' == cl) {
	  showTrace this r 0 (dictionary)
	}
  }
}

method showTrace Serializer objIndex indent visited {
  // For debugging. Trace the path to the given object.
  add visited objIndex
  prefix = (joinStringArray (newArray indent '  '))
  print prefix objIndex (cellAt objectTable objIndex 'className')
  for r (allRefs this objIndex) {
	if (not (contains visited r)) {
	  showTrace this r (indent + 1) visited
	}
  }
}

method allRefs Serializer objIndex {
  result = (list)
  for r (rowCount objectTable) {
    fields = (cellAt objectTable r 'fields')
	if (isClass fields 'Array') {
	  for ref fields {
		if (and (isClass ref 'ObjRef') ((objID ref) == objIndex)) {
		  add result r
		}
	  }
	}
  }
  return result
}
defineClass Serializer2 verbose stream root classIDs classes clusters modules moduleCode moduleIDs topHash objects objFields objectsToIgnore classTable fieldsForClass prefix postfix version t_nil t_ref t_true t_false t_int t_float t_string t_binary t_array ObjRef Array BinaryData Boolean ExternalReference Float Integer Module Nil String

// Constants

method initConstants Serializer2 {
  version = 2
  crlf = (string 13 10)
  prefix = (join '~=== Begin GP Object Data ===~' crlf)
  postfix = (join crlf '~=== End GP Object Data ===~')
  verbose = false
  t_nil = 0
  t_true = 1
  t_false = 2
  t_int = 3
  t_float = 4
  t_string = 5
  t_binary = 6
  t_array = 7
  t_ref = 255

  ObjRef = (class 'ObjRef')
  Array = (class 'Array')
  Boolean = (class 'Boolean')
  BinaryData = (class 'BinaryData')
  ExternalReference = (class 'ExternalReference')
  Float = (class 'Float')
  Integer = (class 'Integer')
  Module = (class 'Module')
  Nil = (class 'Nil')
  String = (class 'String')
}

// Writing

method write Serializer2 rootObj ignoring {
  // Serialize the given object and all objects reachable from it
  // and return the resulting BinaryData. Objects in the optional
  // parameter 'ignoring' will be omitted from the serialization.

  if (notNil ignoring) {
    objectsToIgnore = (dictionary)
    addAll objectsToIgnore ignoring
  }
  initConstants this
  stream = (dataStream (newBinaryData 100000))

  if (isImmediate this rootObj) {
    writeImmediate this rootObj
    return (array (contents stream) (array))
  }

  gc

  root = rootObj
  clusters = (dictionary)       // {class -> {object -> fields}}
  objects = (dictionary)        // {object -> objectID}
  classIDs = (dictionary)       // {class -> classID}
  classes = (list)              // [class]
  fieldsForClass = (dictionary) // {class -> fields}
  modules = (dictionary)        // {module-instance -> module-code-static-hash}
  moduleCode = (dictionary)     // {module-code-static-hash -> serialized code}
  moduleIDs = (dictionary)      // {module-instance -> moduleID}

  topHash = (codeHash (topLevelModule))

  grow objects 10000

  collectObjects this rootObj
  assignIDs this
  linkObjects this
  gc

  // Note: write prefix and postfix as raw strings to support copy/paste in some text editor
  nextPutAll stream prefix
  writeNext this version
  writeModuleTable this
  writeClassTable this
  writeObjects this
  writeNext this (at objects rootObj)
  nextPutAll stream postfix

  // temporary store a value into a temp
  code = moduleCode

  // free up memory
  classIDs = nil
  classes = nil
  clusters = nil
  modules = nil
  moduleIDs = nil
  moduleCode = nil
  objects = nil
  objFields = nil
  objectsToIgnore = nil
  classTable = nil
  fieldsForClass = nil
  gc

  return (array (contents stream) code topHash)
}

method writeImmediate Serializer2 rootObj {
  nextPutAll stream prefix
  writeNext this version
  writeNext this (array) // empty module table
  writeNext this (array) // empty class table
  writeNext this 1 // object count
  writeNext this rootObj // write an immediate object instead of object table
  nextPutAll stream postfix
}

method collectObjects Serializer2 rootObj {
  modID = 0
  toDo = (list rootObj)
  while (notEmpty toDo) {
    obj = (removeFirst toDo)
    if (not (contains objects obj)) { // obj is not already in the object table; add it
      class = (classOf obj)
      module = (module class)
      if (not (contains clusters class)) {
        atPut clusters class (dictionary)
        atPut fieldsForClass class (serializedFieldNames obj)
        atPut classIDs class ((count classIDs) + 1)
        add classes class
      }
      if (not (contains modules module)) {
        if (not (module === (topLevelModule))) {
          code = (code module)
          hash = (sha256 code)
          atPut modules module hash
          atPut moduleCode hash code
          modID = (modID + 1)
          atPut moduleIDs module modID
          add toDo module
        }
      }
      if (isAnyClass obj 'String' 'BinaryData') {
        // non-pointers
        atPut (at clusters class) obj nil
      } else {
        if (Array === class) {
          // indexable
          fields = (clone obj)
        } else {
          // Assume: (serialize obj) returns a reference to a temporary object, not a
          // subpart of obj, since the returned object is mutated by the serializer
          fields = (serialize obj)
        }
        atPut (at clusters class) obj fields

        // add any references to objects that have not been processed to the toDo list
        for i (count fields) {
          o = (at fields i)
          if ((classOf o) === Module) {
            if (not (contains modules o)) {
              if (o === (topLevelModule)) {
                atPut modules o topHash
                o = nil
              } else {
                code = (code o)
                hash = (sha256 code)
                atPut modules o hash
                atPut moduleCode hash code
                modID = (modID + 1)
                atPut moduleIDs o modID
              }
            }
          }
          if (and (notNil objectsToIgnore) (contains objectsToIgnore o)) {
            // nil out references to objects in the 'ignore' list
            atPut fields i nil
            o = nil
          }
          if (and (notNil o) (not (isImmediate this o)) (not (contains objects o))) {
            add toDo o
          }
        }
      }
      atPut objects obj 0
    }
  }
}

method isImmediate Serializer2 obj {
  // An immediate object is encoded inline; it does not have an entry in the object table.
  return (isAnyClass obj 'Integer' 'Boolean' 'Float' 'ExternalReference' 'Nil')
}

method assignIDs Serializer2 {
  objID = 0
  for c classes {
    cluster = (at clusters c)
    objs = (keys cluster)
    for obj objs {
      objID = (objID + 1)
      atPut objects obj objID
    }
  }
}

method linkObjects Serializer2 {
  // Replace object references in fields arrays with instances of ObjRef
  // that link to the corresponding object table entry.

  for c classes {
    cluster = (at clusters c)
    objs = (keys cluster)
    for r (count objs) {
      fields = (at cluster (at objs r))
      if (notNil fields) { // object has a fields array
        for i (count fields) {
          obj = (at fields i)
          objID = (at objects obj)
          if (notNil objID) {
            atPut fields i (new ObjRef objID)
          }
        }
      }
    }
  }
}

method writeModuleTable Serializer2 {
  mods = (newArray (count moduleIDs)) // [module-static-hash] indexed by id
  for m (keys moduleIDs) {
    id = (at moduleIDs m)
    atPut mods id (at modules m)
  }
  writeNext this mods
}

method writeClassTable Serializer2 {
  // Write the class table to my stream.

  classTable = (newArray ((count clusters) * 3)) // [id, className, fields]
  for cls classes {
    id = (at classIDs cls)
    atPut classTable (((id - 1) * 3) + 1) (at moduleIDs (module cls))
    atPut classTable (((id - 1) * 3) + 2) (className cls)
    atPut classTable (((id - 1) * 3) + 3) (at fieldsForClass cls)
  }

  writeNext this classTable
}

method writeModules Serializer2 {
  classID = (at classIDs Module)
  cluster = (at clusters Module)

  objs = (keys cluster)
  table = (list)
  add table classID
  add table (count objs)
  add table false
  for obj objs {
    objData = (at cluster obj)
    add table (at moduleIDs obj)
    add table objData
  }
  writeNext this (toArray table)
}

method writeObjects Serializer2 {
  // Write the object table to my stream.

  writeNext this (count objects)
  for c classes {
    if (c === Module) {
      writeModules this
    } else {
      classID = (at classIDs c)
      cluster = (at clusters c)
      isIndexable = (or (c === Array) (c ===  BinaryData) (c === String))
      fieldCount = (count (fieldNames c))
      objs = (keys cluster)
      table = (list)
      add table classID
      add table (count objs)
      add table isIndexable
      for obj objs {
        objData = (at cluster obj)
        if (isNil objData) {  // non-pointer
          objData = obj
        }
        if isIndexable {
          indexableCount = ((objWords obj) - fieldCount)
          add table indexableCount
          add table objData
        } else {
          add table objData
        }
      }
      writeNext this (toArray table)
    }
  }
}

// Reading

method version Serializer2 data {
  initConstants this
  stream = (dataStream data)
  readPrefix this
  return (readNext this)
}

method read Serializer2 data mods {
  // Read and reconstruct a serialized object structure from the given BinaryData.

  initConstants this
  stream = (dataStream data)
  if (notNil mods) {
    moduleCode = mods
  }
  readPrefix this
  readVersion this
  readModuleTable this
  readClassTable this

  if ((count clusters) === 0) {
    v = (readNext this)
    readPostfix this
    return v
  }

  readObjects this
  resolveReferences this
  deserializeObjects this
  rootObj = (readNext this)
  readPostfix this

  return (at objects rootObj)
}

method readPrefix Serializer2 {
  s = (nextString stream (byteCount prefix))
  if (s != prefix) { error 'serialize: bad prefix' }
}

method readVersion Serializer2 {
  v = (readNext this)
  if (v != version) { error (join 'serialize: cannot read object data version' v) }
}

method readPostfix Serializer2 {
  s = (nextString stream (byteCount postfix))
  if (s != postfix) { error 'serialize: bad postfix' }
}

method readModuleTable Serializer2 {
  modulesArray = (readNext this) // [module-static-hash] indexed by id; may have duplicates for multiple instances
  modules = (dictionary)         // {module index -> module instance}
  for i (count modulesArray) {
    m = (loadModuleFromString (initialize (new 'Module')) (at moduleCode (at modulesArray i)))
    atPut modules i m
  }
}

method readClassTable Serializer2 {
  classData = (readNext this)
  clusters = (dictionary)
  fieldsForClass = (dictionary)
  classIDs = (newArray ((count classData) / 3))

  for i ((count classData) / 3) {
    mod = (at modules (at classData ((3 * (i - 1)) + 1)))
    name = (at classData ((3 * (i - 1)) + 2))
    fieldNames = (at classData ((3 * (i - 1)) + 3))
    if (isNil mod) {
      mod = (topLevelModule)
      cls = (class name)
    } else {
      cls = (classNamed mod name)
    }
    if (notNil cls) {
      atPut clusters cls (list)
      atPut fieldsForClass cls fieldNames
      atPut classIDs i cls
    } else {
      error (join 'Missing class ' name ' ' mod ' in Serializer2 readClassTable: corrupted file?')
    }
  }
}

method readObjects Serializer2 {
  totalCount = (readNext this)
  objects = (newArray totalCount)

  objFields = (newArray totalCount)
  ind = 0
  while (totalCount > 0) {
    i = 0
    table = (readNext this)
    i = (i + 1)
    classIndex = (at table i)
    i = (i + 1)
    count = (at table i)
    i = (i + 1)
    isIndexable = (at table i)
    cluster = (newArray count)
    cls = (at classIDs classIndex)
    atPut clusters cls cluster
    totalCount = (totalCount - count)
    if isIndexable {
      for c count {
        i = (i + 1)
        indexableCount = (at table i)
        i = (i + 1)
        objData = (at table i)
        ind = (ind + 1)
        if (cls === Array) {
          inst = objData
          atPut objects ind inst
          atPut objFields  ind inst
          atPut cluster c ind
        } (or (cls === String) (cls === BinaryData)) {
          atPut objects ind objData
          atPut objFields  ind nil
          atPut cluster c ind
        }
      }
    } (cls === Module) {
      for c count {
        i = (i + 1)
        id = (at table i)
        inst = (at modules id)
        i = (i + 1)
        objData = (at table i)
        ind = (ind + 1)
        atPut objects ind inst
        atPut objFields ind objData
        atPut cluster c ind
      }
    } (isOneOf (className cls) 'Command' 'Reporter') {
	  // Workaround because current format doesn't include the number of indexable fields
	  fixedFieldCount = 2
	  if ('Reporter' == (className cls)) { fixedFieldCount = 1 }
      for c count {
        i = (i + 1)
        objData = (at table i)
        ind = (ind + 1)
        atPut objects ind (newIndexable cls ((count objData) - fixedFieldCount))
        atPut objFields ind objData
        atPut cluster c ind
      }
    } else {
      for c count {
        i = (i + 1)
        objData = (at table i)
        ind = (ind + 1)
        atPut objects ind (new cls)
        atPut objFields ind objData
        atPut cluster c ind
      }
    }
  }
}

method resolveReferences Serializer2 {
  // Replace all object references (instances of ObjRef) with
  // references to the corresponding object in the object table.

  keys = (keys clusters)
  for cls keys {
    cluster = (at clusters cls)
    for ind cluster {
      objData = (at objFields ind)
      if (isClass objData Array) {
        for i (count objData) {
          ref = (at objData i)
          if ((classOf ref) === ObjRef) {
            obj = (at objects (objID ref))
            atPut objData i obj
          }
        }
      }
    }
  }
}

method deserializeObjects Serializer2 {
  // Initialize object contents from their field dictionaries.

  empty = (array)

  for c (count classIDs) {
    cls = (at classIDs c)
    fieldNames = (at fieldsForClass cls)
    fieldNameCount = (count fieldNames)
    cluster = (at clusters cls)
    for ind cluster {
      if (not (cls === Array)) {
        obj = (at objects ind)
        fields = (at objFields ind)
        fieldCount = (count fields)
        d = (dictionary)
        for i (min fieldNameCount fieldCount) {
          atPut d (at fieldNames i) (at fields i)
        }
        extraCount = (fieldCount - fieldNameCount)
        if (extraCount > 0) {
          extraFields = (copyArray fields extraCount (fieldNameCount + 1))
        } else {
          extraFields = empty
        }
        deserialize obj d extraFields
      }
    }
  }
}

// low-level serialization

method readNext Serializer2 {
  tag = (nextUInt8 stream)
  if (t_nil == tag) { return nil }
  if (t_int == tag) { return (nextInt stream) }
  if (t_ref == tag) { return (new ObjRef (nextUInt32 stream)) }
  if (t_true == tag) { return true }
  if (t_false == tag) { return false }
  if (t_float == tag) { return (nextFloat32 stream) } // need prim for double
  if (t_array == tag) {
    count = (nextUInt32 stream)
    result = (newArray count)
    for i count {
      atPut result i (readNext this)
    }
    return result
  } (t_string == tag) {
    count = (nextUInt32 stream)
    return (nextString stream count)
  } (t_binary == tag) {
    count = (nextUInt32 stream)
    return (nextData stream count)
  } else {
    error 'unknown tag; serialized data corrupted?'
  }
}

method writeNext Serializer2 obj {
  if (isNil obj) {
    putUInt8 stream t_nil
    return
  }
  if (true === obj) {
    putUInt8 stream t_true
    return
  }
  if (false === obj) {
    putUInt8 stream t_false
    return
  }
  class = (classOf obj)
  if (Integer === class) {
    putUInt8 stream t_int
    putInt stream obj
  } (Float === class) {
    putUInt8 stream t_float
    putFloat32 stream obj
  } (Array === class) {
    putUInt8 stream t_array
    putUInt32 stream (count obj)
    for i (count obj) {
      writeNext this (at obj i)
    }
  } (String === class) {
    putUInt8 stream t_string
    putUInt32 stream (byteCount obj)
    nextPutAll stream obj
  } (ObjRef === class) {
    putUInt8 stream t_ref
    putUInt32 stream (objID obj)
  } (BinaryData === class) {
    putUInt8 stream t_binary
    putUInt32 stream (byteCount obj)
    nextPutAll stream obj
  } (ExternalReference === class) {
    putUInt8 stream t_nil // replace ExternalReferences with nil
  } else {
    error (join 'cannot serialize ' className)
  }
}
// ShadowEffect
// Browser only! Uses DOM Canvas "shadow" effects to draw a dropshadow or highlight around
// a stack of blocks.
//
// John Maloney, May 2021

defineClass ShadowEffect morph targetBlock color offset blur

to newShadowEffect aBlock effectType {
	return (initialize (new 'ShadowEffect') aBlock effectType)
}

method initialize ShadowEffect aBlock effectType {
	morph = (newMorph this)
	acceptEvents morph false
	targetBlock = aBlock
	scale = (global 'scale')
	if ('highlight' == effectType) {
		color = (colorHSV 120 1.0 0.6)
		offset = 0
		blur = (20 * scale)
	} else {
		color = (gray 0 60)
		offset = (7 * scale)
		blur = (1 * scale)
	}
	r = (expandBy (fullBounds (morph targetBlock)) (20 * scale))
	r = (translatedBy r offset)
	setExtent morph (width r) (height r)
	setPosition morph (left r) (top r)
	return this
}

method drawOn ShadowEffect ctx {
	if ('Browser' != (platform)) { return }
	if (notNil (getField ctx 'surface')) { return } // don't draw shadow on surface; very slow!

	blockBodies = (list)
	for m (allMorphs (morph targetBlock)) {
		if (isClass (handler m) 'Block') {
			addFirst blockBodies (handler m)
		}
	}
	browserSetShadow color offset blur
	for b blockBodies { drawOn b ctx }
	browserClearShadow
}
defineClass ShapeMaker pen recordedPaths

method pen ShapeMaker { return pen }

to newShapeMaker bitmap {
  return (initialize (new 'ShapeMaker') bitmap)
}

to newShapeMakerForPathRecording {
  return (initForRecording (new 'ShapeMaker'))
}

method initialize ShapeMaker aBitmap {
  if (isNil aBitmap) {
    pen = (newVectorPenPrims)
  } else {
    pen = (newVectorPen aBitmap)
  }
  recordedPaths = nil
  return this
}

// path recording

method initForRecording ShapeMaker {
  pen = (newVectorPen aBitmap)
  recordedPaths = (list)
  return this
}

method isRecording ShapeMaker { return (notNil recordedPaths) }
method recordedPaths ShapeMaker { return recordedPaths }

method fill ShapeMaker fillColor {
  if (notNil recordedPaths) {
    add recordedPaths (array 'fill' (copyWith (path pen) 'Z') fillColor)
  } else {
    fill pen fillColor
  }
}

method fillAndStroke ShapeMaker fillColor borderColor borderWidth {
  if (notNil recordedPaths) {
    add recordedPaths (array 'fillAndStroke' (path pen) fillColor borderColor borderWidth)
  } else {
    fillAndStroke pen fillColor borderColor borderWidth
  }
}

method stroke ShapeMaker borderColor borderWidth joint cap {
  if (isNil joint) { joint = 0 }
  if (isNil cap) { cap = 0 }
  if (notNil recordedPaths) {
    add recordedPaths (array 'stroke' (path pen) borderColor borderWidth joint cap)
  } else {
    stroke pen borderColor borderWidth joint cap
  }
}

// shapes

method fillRectangle ShapeMaker rect fillColor {
  beginPath pen (left rect) (bottom rect)
  roundedRectPath this rect 0
  fill this fillColor
}

method outlineRectangle ShapeMaker rect border borderColor {
  if (border <= 0) { return }
  beginPath pen (left rect) (bottom rect)
  roundedRectPath this rect 0
  stroke this borderColor border
}

method fillRoundedRect ShapeMaker rect radius color border borderColorTop borderColorBottom {
  if (isNil border) {border = 0}
  if (border > 0) {
    if (isNil borderColorTop) {borderColorTop = (darker color)}
    if (isNil borderColorBottom) {borderBolorBottom = borderColorTop}
    rect = (insetBy rect (border / 2))
  }
  if (or ((width rect) <= 0) ((height rect) <= 0)) { return }

  radius = (min radius ((height rect) / 2) ((width rect) / 2))
  beginPath pen (left rect) ((bottom rect) - radius)
  roundedRectPath this rect radius
  fill this color

  if (border > 0) {
    beginPath pen (left rect) ((bottom rect) - radius)
    setHeading pen 270
    roundedRectHalfPath this rect radius
    stroke this borderColorTop border

    beginPath pen (right rect) ((top rect) + radius)
    setHeading pen 90
    roundedRectHalfPath this rect radius
    stroke this borderColorBottom border
  }
}

method roundedRectPath ShapeMaker rect radius {
  setHeading pen 270
  if (0 == radius) {
	w = (width rect)
	h = (height rect)
	repeat 2 {
	  forward pen h
	  turn pen 90
	  forward pen w
	  turn pen 90
	}
  } else {
	repeat 2 {
	  roundedRectHalfPath this rect radius
	}
  }
}

method roundedRectHalfPath ShapeMaker rect radius {
  radius = (min radius ((height rect) / 2) ((width rect) / 2))
  w = ((width rect) - (radius * 2))
  h = ((height rect) - (radius * 2))
  corner = (sqrt ((radius * radius) * 2))
  forward pen h
  turn pen 45
  forward pen corner 50
  turn pen 45
  forward pen w
  turn pen 45
  forward pen corner 50
  turn pen 45
}

method drawCircle ShapeMaker centerX centerY radius fillColor borderWidth borderColor {
  // Draw a circle with an optional border. If color is nil or transparent,
  // the circle is not filled.

  if (isNil borderWidth) { borderWidth = 0 }
  startY = (centerY - radius)
  beginPath pen centerX startY
  turn pen 360 radius
  fillAndStroke this fillColor borderColor borderWidth
}

method fillArrow ShapeMaker rect orientation fillColor {
  if (isNil fillColor) { fillColor = (gray 0) }
  if (orientation == 'right') {
    baseLength = (height rect)
    ak = (width rect)
    beginPath pen (left rect) (bottom rect)
    setHeading pen 270
  } (orientation == 'left') {
    baseLength = (height rect)
    ak = (width rect)
    beginPath pen (right rect) (top rect)
    setHeading pen 90
  } (orientation == 'up') {
    baseLength = (width rect)
    ak = (height rect)
    beginPath pen (right rect) (bottom rect)
    setHeading pen 180
  } (orientation == 'down') {
    baseLength = (width rect)
    ak = (height rect)
    beginPath pen (left rect) (top rect)
    setHeading pen 0
  } else {
    error (join 'unsupported orientation "' orientation '"')
  }
  gk = (baseLength / 2)
  tipLength = (sqrt ((gk * gk) + (ak * ak)))
  tipAngle = (90 + (atan gk ak))
  forward pen baseLength
  turn pen tipAngle
  forward pen tipLength
  fill this fillColor
}

method drawLine ShapeMaker x0 y0 x1 y1 thickness color joint cap {
  beginPath pen x0 y0
  lineTo pen x1 y1
  stroke this color thickness joint cap
}

// Tab

method drawTab ShapeMaker rect radius border color {
  radius = (min radius ((height rect) / 2) ((width rect) / 4))
  if (isNil border) {border = 0}
  halfBorder = (border / 2)
  rect = (rect ((left rect) + halfBorder) (top rect) ((width rect) - border) ((height rect) - halfBorder))

  // start at bottom right and draw base first (helps filling heuristic when simulating vector primitives)
  beginPath pen (right rect) (bottom rect)
  tabPath this rect radius
  fillAndStroke this color (lighter color) border
}

method tabPath ShapeMaker rect radius {
  w = ((width rect) - (radius * 4))
  h = ((height rect) - (radius * 2))
  corner = (sqrt ((radius * radius) * 2))

  // start at bottom right and draw base first (helps filling heuristic when simulating vector primitives)
  beginPath pen (right rect) (bottom rect)
  setHeading pen 180
  forward pen (width rect)

  setHeading pen 0
  turn pen -45
  forward pen corner -50
  turn pen -45
  forward pen h
  turn pen 45
  forward pen corner 50
  turn pen 45
  forward pen w
  turn pen 45
  forward pen corner 50
  turn pen 45

  setHeading pen 90
  forward pen h
  turn pen -45
  forward pen corner -50
  turn pen -45
}

// Speech bubble

method drawSpeechBubble ShapeMaker rect scale direction fillColor borderColor {
  if (isNil direction) { direction = 'left' }
  if (isNil fillColor) { fillColor = (gray 250) }
  if (isNil borderColor) { borderColor = (gray 140) }

  border = (2 * scale)
  radius = (5 * scale)
  tailH = (8 * scale) // height of tail
  tailW = (4 * scale) // width of tail base
  indent = (8 * scale) // horizontal distance from edge to tail

  r = (insetBy rect border)
  w = ((width r) - (2 * radius))
  h = (((height r) - tailH) - (2 * radius))

  beginPath pen (left r) ((top r) + (h + radius))
  setHeading pen 270
  forward pen h
  turn pen 90 radius
  forward pen w
  turn pen 90 radius
  forward pen h
  turn pen 90 radius
  if ('left' == direction) {
	forward pen (indent - radius)
	lineTo pen (right r) (bottom r)
	lineTo pen ((right r) - (+ indent tailW radius)) ((bottom r) - tailH)
  } ('right' == direction) {
	forward pen (w - (indent + tailW))
	lineTo pen (left r) (bottom r)
	lineTo pen ((left r) + indent) ((bottom r) - tailH)
  }
  lineTo pen ((left r) + radius) ((bottom r) - tailH)
  turn pen 90 radius

  fillAndStroke this fillColor borderColor border
}

// Grips

method circleWithCrosshairs ShapeMaker size circleRadius color {
  center = (size / 2)
  circleBorder = (size / 6)
  drawCircle this center center circleRadius nil circleBorder color
  fillRectangle this (rect 0 (center - 1) size 2) color
  fillRectangle this (rect (center - 1) 0 2 size) color
}

method drawRotationHandle ShapeMaker size circleRadius color {
  center = (size / 2)
  circleBorder = (size / 6)
  drawCircle this center center circleRadius nil circleBorder color
}

method drawResizer ShapeMaker x y width height orientation isInset {
  right = (x + width)
  if ('horizontal' == orientation) { right = x }
  off = 0
  if isInset { off = 2 }
  w = 0.8
  c = (gray 130)
  space = (truncate (width / 3))
  if ('vertical' == orientation) {
	for i (width / space) {
	  baseY = (+ y ((i - 1) * space) off)
	  drawLine this x (baseY + (w * 1)) right (baseY + (w * 1)) w c
	  drawLine this x (baseY + (w * 2)) right (baseY + (w * 2)) w c
	  drawLine this x (baseY + (w * 3)) right (baseY + (w * 3)) w c
	}
  } else { // 'horizontal' or 'free'
	bottom = (y + height)
	for i (width / space) {
	  baseLeft = (+ x ((i - 1) * space) off)
	  baseRight = (+ right ((i - 1) * space) off)
	  drawLine this (baseLeft + (w * 1)) bottom (baseRight + (w * 1)) y w c
	  drawLine this (baseLeft + (w * 2)) bottom (baseRight + (w * 2)) y w c
	  drawLine this (baseLeft + (w * 3)) bottom (baseRight + (w * 3)) y w c
	}
  }
}

// Button

method drawButton ShapeMaker x y width height buttonColor corner border isInset {
  if (isNil isInset) {isInset = false}
  if isInset {
    topColor = (darker buttonColor)
    bottomColor = (lighter buttonColor)
  } else {
    topColor = (lighter buttonColor)
    bottomColor = (darker buttonColor)
  }
  fillRoundedRect this (rect x y width height) corner buttonColor border topColor bottomColor
}

// Blocks

method drawReporter ShapeMaker rect blockColor radius {
  fillRoundedRect this rect radius blockColor (blockBorder this) (topColor this blockColor) (darker blockColor)
}

method drawBlock ShapeMaker rect blockColor radius dent inset {
  // fill the block
  beginPath pen (left rect) ((bottom rect) - (radius * 2))
  blockTopPath this rect radius dent inset
  blockBottomPath this rect radius dent inset
  fill this blockColor

  // add outline
  rect = (insetBy rect (blockBorderInset this)) // draw highlight/shadow lines inset by half the border

  beginPath pen (left rect) ((bottom rect) - (radius * 2))
  blockTopPath this rect radius dent inset
  stroke this (topColor this blockColor) (blockBorder this)

  beginPath pen (right rect) ((top rect) + radius)
  blockBottomPath this rect radius dent inset
  stroke this (darker blockColor) (blockBorder this)
}

method drawHatBlock ShapeMaker rect hatWidth blockColor radius dent inset {
  hatHeight = ((hatWidth / (sqrt 2)) - (hatWidth / 2))

  // fill the block
  beginPath pen (left rect) ((bottom rect) - (radius * 2))
  hatBlockTopPath this rect radius dent inset hatWidth
  blockBottomPath this rect radius dent inset
  fill this blockColor

  // add outline
  rect = (insetBy rect (blockBorderInset this)) // draw highlight/shadow lines inset by half the border

  beginPath pen (left rect) ((bottom rect) - (radius * 2))
  hatBlockTopPath this rect radius dent inset hatWidth
  stroke this (topColor this blockColor) (blockBorder this)

  beginPath pen (right rect) (+ (top rect) hatHeight radius)
  setHeading pen 90
  blockBottomPath this rect radius dent inset
  stroke this (darker blockColor) (blockBorder this)
}

method drawBlockWithCommandSlots ShapeMaker rect commandSlots blockColor radius dent inset {
  scale = (blockScale)

  // contruct and fill a path including command slots
  beginPath pen (left rect) ((bottom rect) - (radius * 2))
  blockTopPath this rect radius dent inset
  for cslot commandSlots {
	slotTopPath this cslot rect radius dent inset
	slotBottomPath this cslot rect radius dent inset
  }
  blockBottomPath this rect radius dent inset
  fill this blockColor

  // add outline
  rect = (insetBy rect (blockBorderInset this)) // draw highlight/shadow lines inset by half the border

  beginPath pen (left rect) ((bottom rect) - (radius * 2))
  blockTopPath this rect radius dent inset
  stroke this (topColor this blockColor) (blockBorder this)
  for cslot commandSlots {
    beginPathFromCurrentPostion pen
    slotTopPath this cslot rect radius dent inset
    stroke this (darker blockColor) (blockBorder this)

    beginPathFromCurrentPostion pen
    slotBottomPath this cslot rect radius dent inset
    stroke this (topColor this blockColor) (blockBorder this)
  }
  beginPathFromCurrentPostion pen
  blockBottomPath this rect radius dent inset
  stroke this (darker blockColor) (blockBorder this)
}

method slotTopPath ShapeMaker cslot rect radius dent inset {
  scale = (blockScale)

  slotTop = (((at cslot 1) - (2 * scale)) - 1)
  slotH = (((at cslot 2) - (12 * scale)) + 1)
  upperIndentInset = ((24 * scale) + 1)

  setHeading pen 90 // down
  lineTo pen (right rect) ((top rect) + slotTop)

  turn pen 90 radius

  // top slot edge to notch
  forward pen ((width rect) - upperIndentInset)

  // top notch
  blockNotch this radius (dent + 0.5) -1

  // top edge inset
  forward pen (1.5 * scale)

  // inner left of slot
  turn pen -90 radius
  forward pen slotH
}

method slotBottomPath ShapeMaker cslot rect radius dent inset {
  // bottom edge of slot and corner
  turn pen -90 radius
  lineTo pen ((right rect) - radius) (y pen)
  turn pen 90 radius
}

method blockTopPath ShapeMaker rect radius dent inset {
  dent += 2 // increase width of top indentation
  halfExtraDent = 1

  // left side
  setHeading pen 270
  forward pen ((height rect) - (radius * 3))

  // top left corner
  roundedCorner this radius 1

  // upper inset
  forward pen ((inset - radius) - halfExtraDent)

  // upper notch
  blockNotch this radius dent 1

  // top edge
  forward pen ((width rect) - (+ inset dent (radius * 3)))
  forward pen halfExtraDent

  // upper right corner
  roundedCorner this radius 1
}

method blockBottomPath ShapeMaker rect radius dent inset {
  // right side
  setHeading pen 90
  lineTo pen (x pen) ((bottom rect) - (radius * 2))

  // bottom right corner
  roundedCorner this radius 1

  // bottom edge
  forward pen ((width rect) - (+ inset dent (radius * 3)))

  // bottom notch
  blockNotch this radius dent -1

  // bottom inset
  forward pen (inset - radius)

  // bottom left corner
  roundedCorner this radius 1
}

method hatBlockTopPath ShapeMaker rect radius dent inset hatWidth {
  hatHeight = ((hatWidth / (sqrt 2)) - (hatWidth / 2))

  // left side
  setHeading pen 270
  forward pen ((height rect) - (+ hatHeight (radius * 2)))

  // top hat-curve
  turn pen 90
  forward pen hatWidth 40
  forward pen ((width rect) - (hatWidth + radius))

  // upper right corner
  roundedCorner this radius 1
}

method roundedCorner ShapeMaker radius dir {
  // Turn by 90 degrees with rounding.
  // dir is 1 for a right turn, -1 for a left turn.

  turn pen (dir * 45)
  forward pen (sqrt ((radius * radius) * 2)) (dir * 50)
  turn pen (dir * 45)
}

method blockNotch ShapeMaker radius dent dir {
  // Draw a block notch.
  // dir is 1 if notch starts with a right turn, -1 if it starts with left turn.

  diagonal = (sqrt ((radius * radius) * 2))
  turn pen (dir * 45)
  forward pen diagonal
  turn pen (dir * -45)
  forward pen dent
  turn pen (dir * -45)
  forward pen diagonal
  turn pen (dir * 45)
}

method topColor ShapeMaker blockColor {
  if (global 'flatBlocks') { return (darker blockColor) }
  return (lighter blockColor)
}

method blockBorder ShapeMaker { return (max 1 (half (blockScale))) }
method blockBorderInset ShapeMaker { return ((blockBorder this) / 2) }
// SlideText - Text items for presentations

defineClass SlideText morph text centering

method morph SlideText { return morph }
method text SlideText { return text }
method centering SlideText  { return centering }

to newSlideText string fontSize centering {
  if (isNil string) { string = 'Slide Text'}
  if (isNil fontSize) { fontSize = (46 * (global 'scale')) }
  txt = (newText string 'Arial' fontSize)
  acceptEvents (morph txt) false
  setEditRule txt 'editable'
  result = (new 'SlideText' (newMorph) txt)
  setHandler (morph result) result
  setGrabRule (morph result) 'handle'
  setField result 'centering' centering
  addPart (morph result) (morph txt)
  setPosition (morph result) 100 100
  return result
}

// mouse events

method rightClicked SlideText aHand {
  popUpAtHand (contextMenu this) (page aHand)
  return true
}

method clicked SlideText {return (clicked text)}
method doubleClicked SlideText hand {return (doubleClicked text hand)}
method handDownOn SlideText hand {return (handDownOn text hand)}
// ignore handMoveOver, so the SlideText can be dragged without trying to select portions of the embedded text

// menu

method contextMenu SlideText {
  menu = (menu nil (action 'menuSelection' this) true)
  addItem menu 'title' 56
  addItem menu 'big' 46
  addItem menu 'medium' 38
  addItem menu 'small' 32
  addItem menu 'tiny' 28
  addLine menu
  addItem menu 'center'
  addItem menu 'left'
  addItem menu 'indent 1'
  addItem menu 'indent 2'
  addLine menu
  addItem menu 'center align text'
  addItem menu 'left align text'
  addLine menu
  addItem menu 'duplicate'
  addItem menu 'edit...'
  return menu
}

method menuSelection SlideText sel {
  if (isNumber sel) {
	newSize = (sel * (global 'scale'))
	setFont text 'Arial' newSize
	return
  }
  if ('duplicate' == sel) {
	dup = (newSlideText (text text) (fontSize text) centering)
	hand = (hand (handler (root morph)))
	setPosition (morph dup) ((x hand) - 10) ((y hand) - 10)
	grab hand dup
  }
  pageAlignments = (array 'center' 'left' 'indent 1' 'indent 2')
  if (contains pageAlignments sel) {
	centering = sel
	fixCentering this
  }
  if ('center align text' == sel) {
	align text 'center'
  } ('left align text' == sel) {
	align text 'left'
  } ('edit...' == sel) {
    popUpAtHand (contextMenu text) (global 'page')
  }
}

method justDropped SlideText { fixCentering this }
method pageResized SlideText { fixCentering this }

method fixCentering SlideText {
  if (isNil centering) { return }
  scale = (global 'scale')
//  presentationWidth = (1024 * scale)
  presentationWidth = (width (morph (global 'page')))
  x = (left morph)
  y = (top morph)
  if ('center' == centering) {
	x = ((presentationWidth - (width (morph text))) / 2)
  } ('left' == centering) {
	x = (80 * scale)
  } ('indent 1' == centering) {
	x = (160 * scale)
  } ('indent 2' == centering) {
	x = (240 * scale)
  }
  setPosition morph x y
}

method adjustToScaleBy SlideText factor {
  // Used to switch from retina to normal mode if necessary
  setPosition morph (truncate (factor * (left morph))) (truncate (factor * (top morph)))
  setFont text nil (truncate (factor * (fontSize text)))
}

to addSlideText s { addPart (global 'page') (newSlideText s) }

// serialization

method postSerialize SlideText {
  acceptEvents (morph text) false
}

defineClass Slider morph orientation action floor ceiling value size thickness

to slider orientation span action thickness floor ceiling value size {
	if (isNil span) { span = 100 }
	if (isNil action) { action = 'nop' }
	if (isNil thickness) { thickness = (10 * (global 'scale')) }
	if (isNil floor) { floor = 0 }
	if (isNil ceiling) { ceiling = 100 }
	if (isNil value) { value = 50 }
	if (isNil size) { size = 10 }
	result = (new 'Slider' nil orientation action floor ceiling value size thickness)
	return (initialize result span)
}

method initialize Slider span {
	if (orientation == 'horizontal') {
		w = span
		h = thickness
	} else {
		w = thickness
		h = span
	}
	morph = (newMorph this)
	setExtent morph w h
	return this
}

method ceiling Slider { return ceiling }
method floor Slider { return floor }
method value Slider { return value }
// method unit Slider {
// 	span = (height morph)
// 	if (orientation == 'horizontal') { span = (width morph) }
// 	span = (toFloat span)
// 	valueRange = (max 1 (ceiling - floor))
// 	stretch = (max thickness (toInteger ((span / valueRange) * size)))
// 	return ((span - stretch) / valueRange)
// }

method setAction Slider anAction {action = anAction}
method setSize Slider num {update this nil nil nil num}
method setValue Slider num {update this nil nil num}

method update Slider floorNum ceilNum valNum sizeNum {
	if (isNil floorNum) {floorNum = floor}
	if (isNil ceilNum) {ceilNum = ceiling}
	if (isNil valNum) {valNum = value}
	if (isNil sizeNum) {sizeNum = size}
	floor = floorNum
	ceiling = ceilNum
	value = valNum
	size = sizeNum
	call action value
	changed morph
}

method drawOn Slider ctx {
	scale = (global 'scale')
	sliderSize = (20 * scale)

	bgColor = (gray 255 90)
	fillRect ctx bgColor (left morph) (top morph) (width morph) (height morph)
	if ((ceiling - floor) == 0) {
		frac = 0
	} else {
		frac = ((value - floor) / (ceiling - floor))
	}
	if (orientation == 'horizontal') {
		sliderRange = ((width morph) - sliderSize)
		offset = (toInteger (frac * sliderRange))
		sliderRect = (rect ((left morph) + offset) (top morph) sliderSize (height morph))
	} (orientation == 'vertical') {
		sliderRange = ((height morph) - sliderSize)
		offset = (toInteger (frac * sliderRange))
		sliderRect = (rect (left morph) ((top morph) + offset) (width morph) sliderSize)
	}

	sliderCorner = (4 * scale)
	sliderColor = (gray 110 180)
	fillRoundedRect (getShapeMaker ctx) sliderRect sliderCorner sliderColor 0
}

// events

method clicked Slider { return true }
method rightClicked Slider { return true }

method handDownOn Slider aHand {
	focusOn aHand this
	handMoveFocus this aHand
	return true
}

method handMoveFocus Slider aHand {
	if (orientation == 'horizontal') {
		frac = (((x aHand) - (left morph)) / (width morph))
	} (orientation == 'vertical') {
		frac = (((y aHand) - (top morph)) / (height morph))
	}
	frac = (clamp frac 0 1)
	value = (floor + (frac * (ceiling - floor)))
	value = (clamp value floor ceiling)
	call action value
}
defineClass SourceManager originalDir overwriteFlag module parsedFiles

// Note: There are ten functions with empty bodies; this won't know what file they are from.

to newSourceManager originalDir overwriteFlag aModule {
  return (init (new 'SourceManager') originalDir overwriteFlag aModule)
}

method init SourceManager origDir overwrite aModule {
  if (isNil origDir) { origDir = 'lib' }
  if (isNil overwrite) { overwrite = false }
  if (isNil aModule) { aModule = (topLevelModule) }
  originalDir = origDir
  overwriteFlag = overwrite
  module = aModule
  return this
}

method fileForClass SourceManager cl {
  // Return the file name associated with the given class (from the first non-empty method).
  // Return nil if the class has no methods.

  for m (methods cl) {
	if (notNil (cmdList m)) {
	  fn = (fileName (cmdList m))
	  if ('<parse>' != fn) { return (filePart fn) }
	}
  }
  return nil
}

method fileForFunction SourceManager f {
  if (isNil (cmdList f)) { return nil }
  return (filePart (fileName (cmdList f)))
}

method allFileNames SourceManager {
  // Return a sorted list of all source file names referenced in my module.

  d = (dictionary)
  for cl (classes module) {
	fn = (fileForClass this cl)
	if (notNil fn) { add d (filePart fn) }
  }
  for f (functions module) {
	if (notNil (cmdList f)) {
	  fn = (fileName (cmdList f))
	  if (notNil fn) { add d (filePart fn) }
	}
  }
  remove d '<parse>'
  return (sorted (keys d))
}

method parseSourceFiles SourceManager {
  // Parse all source files and stores results in a dictionary keyed by file name.

  parsedFiles = (dictionary)
  for fn (allFileNames this) {
	contents = (readFile (join originalDir '/' fn))
	if (isNil contents) {
	  print 'Could not read source file:' fn
	} else {
	  atPut parsedFiles fn (parse contents)
	}
  }
}

method originalClassFields SourceManager cl {
  // Return a list of field names from the original class definition.

  fn = (fileForClass this cl)
  if (isNil fn) { return (array) } // true for classes with no methods such as Nil

  parsedContents = (at parsedFiles fn)
  if (isNil parsedContents) { error 'No entry for' fn }

  for cmd parsedContents {
	if ('defineClass' == (primName cmd)) {
	  args = (argList cmd)
	  if ((first args) == (className cl)) {
		return (copyFromTo args 2) // use first definition found
	  }
	}
  }
  return (array)
}

method showDiffs SourceManager {
  if (isNil parsedContents) { parseSourceFiles this }
  for cl (classes module) {
	origFields = (originalClassFields this cl)
	if (isNil origFields) {
	  print 'New class:' (className cl)
	} else {
	  if ((fieldNames cl) != origFields) {
		print 'Class definition changed:' (className cl)
	  }
	}
  }
}

// 1. every method in memory matches source file
// 2. every source file method matches the one in memory
// Possible: new methods, deleted methods, changed methods

// morphic speech bubble handlers, used for hints, errors, and tool tips

defineClass SpeechBubble morph contents direction isError isTooltip clientMorph lastClientVis

to newBubble aString bubbleWidth direction isError isTooltip {
  return (initialize (new 'SpeechBubble') aString bubbleWidth direction isError isTooltip)
}

method initialize SpeechBubble someData bubbleWidth dir isErrorFlag isTooltipFlag {
  if (isNil someData) {someData = 'hint!'}
  if (isNil bubbleWidth) {bubbleWidth = (175 * (global 'scale')) }
  if (isNil dir) {dir = 'right'}
  direction = dir
  isError = false
  isTooltip = false
  if (true == isErrorFlag) { isError = true }
  if (true == isTooltipFlag) { isTooltip = true }

  scale = (blockScale)
  if isTooltip { scale = (global 'scale') }
  font = 'Arial'
  fontSize = (18 * scale)
  if ('Linux' == (platform)) { fontSize = (13 * scale) }
  maxLines = 30

  setFont font fontSize
  if (isClass someData 'Boolean') {
    contents = (newBooleanSlot someData)
  } else {
    someData = (toString someData)
    lines = (toList (wordWrapped someData bubbleWidth))
    if ((count lines) > maxLines) {
      lines = (copyFromTo lines 1 maxLines)
      add lines '...'
    }
    contents = (newText (joinStrings lines (newline)) font fontSize (gray 0) 'center')
  }

  morph = (newMorph this)
  addPart morph (morph contents)
  fixLayout this
  return this
}

method layoutChanged SpeechBubble {fixLayout this}

method fixLayout SpeechBubble {
  scale = (blockScale)
  if isTooltip { scale = (global 'scale') }
  fontSize = (18 * scale)
  if ('Linux' == (platform)) { fontSize = (13 * scale) }
  hInset = (11 * scale)
  vInset = (7 * scale)
  tailH = (7 * scale) // height of bubble tail
  if isTooltip { tailH = scale }
  setPosition (morph contents) ((left morph) + hInset) ((top morph) + vInset)
  w = ((width (morph contents)) + (2 * hInset))
  h = (+ (height (morph contents)) (2 * vInset) tailH)
  setExtent morph w h
}

method drawOn SpeechBubble ctx {
  if isTooltip {
    // used for button tooltips
    border = (1 * (global 'scale'))
    corner = (3 * (global 'scale'))
    fillColor = (color 255 255 230)
    fillRoundedRect (getShapeMaker ctx) (bounds morph) corner fillColor border (gray 140) (gray 140)
    return
  }

  border = (blockScale)
  r = (insetBy (bounds morph) (2 * border))
  if isError {
    fillColor = (colorHSV 0 0.05 1.0)
    borderColor = (colorHSV 0 1.0 0.7)
    drawSpeechBubble (getShapeMaker ctx) r border direction fillColor borderColor
  } else {
    drawSpeechBubble (getShapeMaker ctx) r border direction
  }
}

// talk bubble support

method clientMorph SpeechBubble { return clientMorph }
method setClientMorph SpeechBubble m { clientMorph = m }

method step SpeechBubble {
  // Make bubble follow a moving clientMorph.

  if (isNil clientMorph) { return }
  if (isNil (owner clientMorph)) { // client was deleted
	removePart (owner morph) morph
	return
  }
  vis = (visibleBounds clientMorph)
  if (lastClientVis == vis) { return }
  overlap = (5 * (blockScale)) // xxx
  rightSpace = ((right (owner morph)) - (right vis))
  bottomY = ((top vis) + overlap)
  if (isClass (handler clientMorph) 'Block') {
    b = (handler clientMorph)
    if ('hat' == (type b)) { bottomY = (vCenter vis) }
  }
  setBottom morph bottomY
  if (rightSpace > (width morph)) {
	setDirection this 'right'
    setLeft morph ((right vis) - overlap)
  } else {
	setDirection this 'left'
    setRight morph ((left vis) + overlap)
  }
  keepWithin morph (insetBy (bounds (owner morph)) (3 * (global 'scale')))
  lastClientVis = vis
}

method setDirection SpeechBubble newDir {
  if (newDir == direction) { return }
  direction = newDir
  fixLayout this
}
// SpriteIcon - a library icon of a user-defined class

defineClass SpriteIcon morph target toggle thumb

method target SpriteIcon { return target }

method initialize SpriteIcon aHandler onSelect query {
  if (isNil onSelect) {onSelect = 'nop'}
  if (isNil query) {query = (function {return false})}
  target = aHandler
  scale = (global 'scale')
  toggle = (createToggle this onSelect query)
  morph = (morph toggle)
  setHandler morph this
  if (hasField target 'morph') {
	addPart morph (morph (thumbnailFor target))
  } else {
	box = (newBox nil (gray 200) 0 0 false false)
	w =  (40 * (global 'scale'))
	setExtent (morph box) w w
	addPart morph (morph box)
  }
  fixLayout this
  return this
}

method createToggle SpriteIcon onSelect query {
  scale = (global 'scale')
  clr = (gray 200)
  size = (scale * 46)
  corner = (scale * 3)
  border = scale
  fbm = (buttonBitmap nil (color 0 0 0 0) size size false corner border false true)
  pbm = (buttonBitmap nil clr size size false corner border false false)
  tbm = (buttonBitmap nil clr size size false corner border true false)
  trigger = (new 'Trigger' nil onSelect fbm tbm pbm)
  m = (newMorph)
  setMorph trigger m
  setWidth (bounds m) size
  setHeight (bounds m) size
  tg = (new 'Toggle' m trigger query 'handEnter')
  setHandler m tg
  refresh tg
  return tg
}

method fixLayout SpriteIcon {
  setCenter (first (parts morph)) (hCenter (bounds morph)) (vCenter (bounds morph))
}

method handDownOn SpriteIcon aHand {return (handDownOn toggle aHand)}
method handEnter SpriteIcon aHand {handEnter toggle aHand}
method handLeave SpriteIcon aHand {handLeave toggle aHand}
method clicked SpriteIcon {return (clicked toggle)}
method doubleClicked SpriteIcon {return (doubleClicked toggle)}
method setHint SpriteIcon aStringOrNil {setHint toggle aStringOrNil}
method rightClicked SpriteIcon {return (rightClicked toggle)}
method refresh SpriteIcon {refresh toggle}
// a container displaying a list of user-edited classes and a list of instances for the selected class

defineClass SpriteLibrary morph scripter newClassButton newInstanceButton clearButton classes classesFrame instances instancesFrame lastClasses instanceLabelWidth

method initialize SpriteLibrary aScripter {
  scripter = aScripter
  classes = (listBox (array) 'className' (action 'selectClass' this) (gray 240))
  setFont classes 'Arial' 13
  classesFrame = (scrollFrame classes (gray 240))
  instances = (initialize (new 'SpriteList'))
  instancesFrame = (scrollFrame instances (gray 220))
  morph = (newMorph this)
  setTransparentTouch morph true
  newClassButton = (makeNewThingButton this 'createClass' 'Make a new class')
  newInstanceButton = (makeNewThingButton this 'addInstance' 'Make a new instance of this class')
  clearButton = (pushButton 'Clear' (gray 120) (action 'clearInstances' this))
  setHint clearButton 'Remove all instances of this class except the selected one'

  addPart morph (morph classesFrame)
  addPart morph (morph instancesFrame)
  addPart morph (morph newClassButton)
  addPart morph (morph newInstanceButton)
  addPart morph (morph clearButton)
  updateClasses this
  setExtent morph 800 400
  setFPS morph 2
  return this
}

method redraw SpriteLibrary {
  scale = (global 'scale')
  border = (2 * scale)
  titleBarH = (24 * scale)
  fontSize = (15 * scale)
  bnds = (bounds morph)
  bm = (newBitmap (max 1 (width bnds)) (max 1 (height bnds)) (gray 150))
  fillRect bm (gray 220) 0 border ((width bnds) - border) (titleBarH - border)
  fillRect bm (gray 150) (100 * scale) border border (titleBarH - border)
  setFont 'Arial Bold' fontSize
  drawString bm 'Classes'  (gray 50) (points 4) (points 4)
  instancesLabel = 'Instances'
  targetObj = (targetObj scripter)
  if (notNil targetObj) {
	targetClass = (classOf targetObj)
	instancesLabel = (join 'Instances of ' (className targetClass))
  }
  drawString bm instancesLabel (gray 50) (points 108) (points 4)
  instanceLabelWidth = (stringWidth instancesLabel)
  setCostume morph bm
  fixLayout this
}

method fixLayout SpriteLibrary {
  scale = (global 'scale')
  border = (scale * 2)
  titleBarH = (24 * scale)
  setPosition (morph classesFrame) (left morph) (+ (top morph) titleBarH border)
  setExtent (morph classesFrame) (scale * 100) (max 0 ((height morph) - (titleBarH + (2 * border))))
  setPosition (morph instancesFrame) (+ border (right (morph classesFrame))) (+ (top morph) titleBarH border)
  setExtent (morph instancesFrame) (max 0 (((width morph) - (width (morph classesFrame))) - (2 * border))) (max 0 (height (morph classesFrame)))
  setInsetInOwner (morph newClassButton) (81 * scale) (5 * scale)
  setInsetInOwner (morph newInstanceButton) (+ (width (morph classesFrame)) instanceLabelWidth (25 * scale)) (5 * scale)
  setInsetInOwner (morph clearButton) ((width morph) - ((width (morph clearButton)) + (10 * scale))) (7 * scale)
}

method clearLibrary SpriteLibrary {
  lastClasses = (dictionary)
  setCollection classes (array)
  select classes nil
  clear instances
}

// stepping

method step SpriteLibrary {
  if (classesHaveChanged this) { updateClasses this }
  if (isNil scripter) {return}
  targetObj = (targetObj scripter)
  if (and (notNil targetObj) (not (isSelected instances targetObj))) {
	targetClass = (classOf targetObj)
	select classes targetClass
	setClass instances targetClass targetObj
	redraw this
  }
}

method classesHaveChanged SpriteLibrary {
  // This called by step a few times a second, so it has to
  // be efficient. This version runs in about 35 useconds
  // and does minimal object creation.

  if (isNil lastClasses) { lastClasses = (dictionary) }
  count = 0
  for cl (classes (targetModule scripter)) {
	oldName = (at lastClasses cl)
	if (isNil oldName) { return true } // new class
	if ((className cl) != oldName) { return true } // class name changed
	count += 1
  }
  return (count != (count lastClasses)) // class deleted
}

method updateClasses SpriteLibrary {
  // Update my class list when a class change is detected.
  // If the currently selected class has been deleted, select another.

  lastClasses = (dictionary)
  newClasses = (list)

  for cl (classes (targetModule scripter)) {
	atPut lastClasses cl (className cl)
	add newClasses cl
  }
  newClasses = (sorted newClasses (function c1 c2 { return ((className c1) < (className c2)) }))
  selectedClass = (selection classes)
  setCollection classes newClasses
  if (not (contains newClasses selectedClass)) {
	if (isEmpty newClasses) {
	  selectedClass = nil
	  clear instances
	} else {
	  selectedClass = (first newClasses)
	}
	select classes selectedClass
  }
}

// class selection

method selectClass SpriteLibrary aClass {
  // User clicked on a name in the class list.

  if (aClass != (targetClass instances)) {
    setClass instances aClass
    if (notNil scripter) {
      // view some instance of the newly selected class
      obj = (selectFirst instances)
      if (isNil obj) { // no instaces yet; create one
        obj = (instantiate (targetClass instances) (stageMorph scripter))
      }
      setTargetObj scripter obj
    }
    redraw this
  }
}

// operations

method clearInstances SpriteLibrary {
  stageM = (stageMorph scripter)
  targetClass = (targetClass instances)
  toDelete = (list)
  for m (parts stageM) {
	if (isClass (handler m) targetClass) { add toDelete m }
  }
  if ((count toDelete) > 1) {
	if (notNil (targetObj scripter)) {
	  remove toDelete (morph (targetObj scripter))
	} else {
	  removeFirst toDelete
	}
	for m2 toDelete {
	  removePart stageM m2
	}
  }
  clear instances
  gc
}

// class menu

method handleListContextRequest SpriteLibrary pair {
  if (isNil scripter) {return}
  cl = (data (last pair))
  menu = (menu)
  addItem menu 'make a new class' (action 'createClass' scripter false)
  if (devMode) {
	addItem menu 'make a helper (non-visible) class' (action 'createClass' scripter true)
  }
  addItem menu 'import a class' (action 'importClass' scripter)
  addLine menu
  if (devMode) {
	addItem menu 'browse this class' (action 'browseClass' cl)
	addItem menu 'export this class' (action 'exportClass' scripter cl)
  }
  addItem menu 'rename this class' (action 'renameClass' scripter cl)
  addLine menu
  addItem menu 'delete this class' (action 'deleteClass' scripter cl)
  popUpAtHand menu (global 'page')
}

// script copy by dropping

method wantsDropOf SpriteLibrary aHandler {
  // Accept drops of Blocks dropped on a class name in the class list.
  return (and (isClass aHandler 'Block') (notNil (dropTargetClass this aHandler)))
}

method dropTargetClass SpriteLibrary aBlock {
  // Return the class on which the given Block was dropped or nil.
  hand = (hand (global 'page'))
  dropX = (x hand)
  dropY = (y hand)
  for m (parts (morph classes)) {
	if (containsPoint (bounds m) dropX dropY) {
	  return (data (handler m))
	}
  }
  return nil
}

method justReceivedDrop SpriteLibrary aBlock {
  if (not (isClass aBlock 'Block')) { return }
  targetClass = (dropTargetClass this aBlock)
  if (isNil targetClass) { return }
  script = (expression aBlock (className targetClass))
  if (isOneOf (primName script) 'method' 'to') {
	script = (copyMethodOrFunction scripter script targetClass)
  } else {
	script = (copy script)
  }
  if (isNil (scripts targetClass)) {
	setScripts targetClass (list)
  }
  scriptList = (toList (scripts targetClass))
  add scriptList (array (rand 100) (rand 100) script)
  setScripts targetClass (toArray scriptList)
  if (targetClass == (classOf (targetObj scripter))) {
	restoreScripts scripter
  }
  animateBackToOldOwner (hand (global 'page')) (morph aBlock)
}

// new class/instance buttons

method makeNewThingButton SpriteLibrary selector hint {
  btn = (new 'Trigger' (newMorph) (action selector scripter))
  setHandler (morph btn) btn
  m = (morph btn)
  setTransparentTouch m true
  if (notNil hint) { setHint btn hint }
  setCostume m (plusIcon this)
  setScale m ((global 'scale') / 2)
  return (handler m)
}

method plusIcon SpriteLibrary {
  data = '
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEEBAIBAAIEBAIAAAAAAAAA
AAAAAAAAAAAAAAAAAAIEAAAAAAAAAAAAAAQCAAAAAAAAAAAAAAAAAAAAAAAEAAAWXZm9zc2/nGEaAAAE
AAAAAAAAAAAAAAAAAAABAwAem/D///////////OiJQACAQAAAAAAAAAAAAAAAQAAa/j////mwKqpvuP/
///8dgAAAgAAAAAAAAAAAAEAAJv///+zSQ0AAAAAC0Or////qAAAAQAAAAAAAAAAAwCb///oRwAAAAUI
CAYAAAA94P//qQACAAAAAAAAAAQAa///1hIABAMCAAAAAAAEBQAKy///ewAEAAAAAAACAB74/+cSAAYA
AQBEaWRdBwAABgAJ3v//KgACAAAAAAQAm///RwAGAAAEALr///8SAAEABQA4//+qAAQAAAABABbw/7MA
BAAAAAMAq//86xAAAQAABQCk//ghAAIAAAQAXf//SQADAgQEBwCw///vFAAFBAMDADr//20ABAAABACZ
/+YNAAIAAAAAAKn//+0AAAAAAAEABdv/qAAEAAACAL3/wAAFAEirnaGa4f//+aaenqh5AAUAsv/KAAEA
AAEAzf+qAAgAe////////v///////84ABgCb/9kDAAEAAADN/6kACABz//n9/f7////9/fr/wAAGAJv/
2QQAAQACAL//vgAGAHD/8vf2/P////f29P+7AAUAsP/MAAEAAAQAnP/jCwAADR4bHw+3///wKhgcHRUA
AAPZ/6sABAAABABh//9DAAQAAAAAAKz//+4KAAAAAAMANf//cQAEAAACABrz/6wABQACAgUArf/97BIA
AwIBBQCc//smAAIAAAAEAKL//z0ABgAABAC2///5EQABAAUAL/7/sgADAAAAAAIAJf3/4AoABQADAI3a
z8ENAAEFAALV//8xAAMAAAAAAAQAdv//ywkABQMBAAAAAAADBQACv///hgAEAAAAAAAAAAIAqP//3jgA
AAAEBQUEAAAAL9X//7YAAQEAAAAAAAAAAQAAqf///6Q6BQAAAAADNZz+//+2AAACAAAAAAAAAAAAAgAA
e//////bspubsNn/////hgAAAgAAAAAAAAAAAAAAAQIAKqr4///////////7sjEAAQIAAAAAAAAAAAAA
AAAAAAQAACFtqMrZ2cyrcSYAAAQBAAAAAAAAAAAAAAAAAAAAAAIEAAAAAAMEAAAAAAMDAAAAAAAAAAAA
AAAAAAAAAAAAAAACBAQBAAABBAQCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQAAAAAAAAAAAAAA
AAAAAA=='
  bm = (newBitmap 32 32)
  applyAlphaChannel bm (base64Decode data) (gray 80)
  return bm
}
// Displays selectable icons for all instances of a given user-defined class.

defineClass SpriteList morph targetClass selection alignment onSelect lastInstances

method targetClass SpriteList {return targetClass}
method selection SpriteList {return selection}

method initialize SpriteList selectionAction {
  if (isNil selectionAction) {selectionAction = 'showInScripter'}
  onSelect = selectionAction
  morph = (newMorph this)
  setTransparentTouch morph true
  alignment = (newAlignment 'multi-line' (2 * (global 'scale')) 'bounds')
  setMorph alignment morph
  setFPS morph 2
  return this
}

method clear SpriteList {
  targetClass = nil
  selection = nil
  lastInstances = (array)
  removeAllParts morph
}

method setClass SpriteList aClass anInstance {
  targetClass = aClass
  if (notNil anInstance) {selection = anInstance}
  updateContents this (collectInstances this)
}

method step SpriteList {
  newInstances = (collectInstances this)
  if (lastInstances == newInstances) { return }
  lastInstances = newInstances
  updateContents this newInstances
}

method updateContents SpriteList newInstances {
  if (isNil targetClass) {
	removeAllParts morph
	return
  }
  if (not (contains (fieldNames targetClass) 'morph')) { // helper class
	removeAllParts morph
	return
  }

  // make a dictionary mapping instances to their icons
  oldIcons = (dictionary)
  for p (parts morph) {
	icon = (handler p)
	atPut oldIcons (target icon) icon
  }

  // make a dictionary mapping instances to their icons
  removeAllParts morph
  for each newInstances {
	icon = (at oldIcons each)
	if (isNil icon) {
	  icon = (initialize (new 'SpriteIcon') each (action 'select' this each) (action 'isSelected' this each))
	  setGrabRule (morph icon) 'defer'
	}
	addPart morph (morph icon)
  }
  fixLayout this
  refreshAll this
}

method collectInstances SpriteList {
  if (isNil targetClass) { return (array) }
  editor = (ownerThatIsA morph 'ProjectEditor')
  if (notNil editor) { stage = (stage (handler editor)) }
  if (isNil stage) { return (array) }
  result = (list)
  if (isUserDefined targetClass) {
	if (contains (fieldNames targetClass) 'morph') {
	  for m (allMorphs (morph stage) true) { // include hidden sprites
		if (isClass (handler m) targetClass) { add result (handler m) }
	  }
	  for m (allMorphs (morph (hand (global 'page')))) {
		if (isClass (handler m) targetClass) { add result (handler m) }
	  }
	} else {
	  result = (allInstances targetClass)
	}
  } else {
	result = (allInstances targetClass)
  }
  return result
}

method selectFirst SpriteList {
  if (isEmpty (parts morph)) {return nil}
  selection = (target (handler (first (parts morph))))
  refreshAll this
  return selection
}

method refreshAll SpriteList {
  // Update the highlight after the selection has changed.

  for each (parts morph) {refresh (handler each)}
}

method isSelected SpriteList anObject {return (anObject === selection)}

method select SpriteList anObject {
  selection = anObject
  refreshAll this
  call onSelect anObject
}

method redraw SpriteList {fixLayout this}
method fixLayout SpriteList {fixLayout alignment}

method adjustSizeToScrollFrame SpriteList aScrollFrame {
  adjustSizeToScrollFrame alignment aScrollFrame
}
// a self-updating thumbnail of a morphic handler

defineClass SpriteThumbnail morph target lastTargetCostume

to thumbnailFor aHandler {
  if (isClass aHandler 'Morph') {aHandler = (handler aHandler)}
  return (initialize (new 'SpriteThumbnail') aHandler)
}

method initialize SpriteThumbnail aHandler {
  target = aHandler
  morph = (newMorph this)
  setTransparentTouch morph true
  setWidth (bounds morph) (40 * (global 'scale'))
  setHeight (bounds morph) (40 * (global 'scale'))
  setFPS morph 5
  step this
  return this
}

method step SpriteThumbnail {
  // This is a placeholder during the Morphic rewrite. It responds to costume
  // switches but not to rotation or costume modifications. It will get replaced
  // by a drawOn method and possibly invalidated by the "change" mechanism.

  if (isNil target) { return }
  targetM = (morph target)
  if (lastTargetCostume === (costumeData targetM)) { return }

  side = (min (width morph) (height morph))
  setCostume morph (thumbnail (costumeData targetM) side side)
  lastTargetCostume = (costumeData targetM)
}

method rightClicked SpriteThumbnail {
  popUpAtHand (contextMenu this) (global 'page')
  return true
}

method contextMenu SpriteThumbnail {
  menu = (menu nil this)
  targetM = (morph target)
  addItem menu 'show' 'showTarget' 'unhide and/or move instance onstage'
  addItem menu 'come to front' (action 'comeToFront' (morph target)) 'show this object on top of its siblings'
  addLine menu
  addItem menu 'delete' (action 'destroy' (morph target) false)
  addLine menu
  addItem menu 'scale...' (action 'scalingHandle' target) 'scale this object'
  addItem menu 'rotate...' (action 'rotationHandle' target) 'rotate this object'
  addItem menu 'rotation point...' (action 'pinHandle' target) 'edit the point about which this object rotates'
  if (or ((pinX targetM) != 0) ((pinY targetM) != 0)) {
    addItem menu 'set rotation point to center...' (action 'setPin' targetM 0 0) 'make this object''s rotation point be its center'
  }
  if (rotateWithOwner targetM) {
	addItem menu 'rotate independently' (action 'toggleRotationStyle' targetM) 'keep current orientation instead of rotating with the owner'
  } else {
	addItem menu 'rotate with owner' (action 'toggleRotationStyle' targetM) 'rotate with owner, as if rigidly attached to it'
  }
  addLine menu
  if ((count (parts targetM)) > 0) {
	addLine menu
    addItem menu 'detach all parts (ungroup)' (action 'detachAll' targetM) 'detach all my parts'
  }
  if ('draggableParts' == (grabRule targetM)) {
	addItem menu 'do not allow parts to be dragged in and out' (action 'toggleDraggableParts' targetM)
  } else {
	addItem menu 'allow parts to be dragged in and out' (action 'toggleDraggableParts' targetM)
  }
  return menu
}

method showTarget SpriteThumbnail {
  container = (ownerThatIsA (morph target) 'Stage')
  if (isNil container) {container = (morph (global 'page'))}
  m = (morph target)
  keepWithin m (bounds container)
  setAlpha m 255
  show m
}

// drag/drop

method wantsDropOf SpriteThumbnail aHandler {
  if (aHandler == target) { return false } // reject drop of my target
  oldOwner = (oldOwner (hand (global 'page')))
  return (isClass oldOwner 'Stage')
}

method justReceivedDrop SpriteThumbnail aHandler {
  h = (hand (global 'page'))
  returnGrabbedObjectToOldPosition h aHandler
  addPart (morph target) (morph aHandler)
  setGrabRule (morph aHandler) 'defer'
}
// Stage.gp - Application stage

defineClass Stage morph color backgroundImage project

method backgroundImage Stage { return backgroundImage }
method color Stage { return color }
method project Stage { return project }
method setProject Stage p { project = p }

method setBackgroundImage Stage bm {
  backgroundImage = bm
  setColor this color // draw background on costume
}

method setColor Stage aColor {
  if (isNil aColor) { aColor = (gray 240) }
  color = aColor
  if (notNil backgroundImage) {
	costumeData = (costumeData morph)
	if (not (isClass costumeData 'Bitmap')) {
	  costumeData = (newBitmap 800 500)
	  setCostume morph costumeData
	}
	fill costumeData color
	x = (half ((width costumeData) - (width backgroundImage)))
	y = (half ((height costumeData) - (height backgroundImage)))
	drawBitmap costumeData backgroundImage x y
	updateCostume morph
  } else {
	setCostume morph color
  }
}

to newStage w h {
  return (initialize (new 'Stage') w h)
}

method initialize Stage w h {
  morph = (newMorph this)
  setClipping morph true
  setTransparentTouch morph true
  setColor this (gray 240)
  setExtent morph 800 500
  return this
}

method setAspectRatio Stage w h {
  majorAxis = 800
  if (or (isNil w) (isNil h)) {
	w = 16
	h = 10
  }
  if (w > h) {
	newW = majorAxis
    newH = (round ((h * majorAxis) / w) 2)
  } else {
	newW = (round ((w * majorAxis) / h) 2)
	newH = majorAxis
  }
  oldW = (width morph)
  oldH = (height morph)
  bm = (costumeData morph)
  if (or (isNil bm) ((width bm) != newW) ((height bm) != newH)) {
	setCostume morph (newBitmap newW newH color)
  }
  if (or (oldW == 0) (oldH == 0)) {
	oldW = newW
	oldH = newH
  }
  scaleToFit this oldW oldH
}

method scaleToFit Stage w h {
  bm = (costumeData morph)
  if (isClass bm 'Bitmap') {
	newScale = (min (w / (width bm)) (h / (height bm)))
  } else {
	newScale = (min (w / 800) (h / 500))
  }
  if (or (newScale != (scaleX morph)) (newScale != (scaleY morph))) {
    setScale morph newScale
  }
}

method wantsDropOf Stage aHandler {
  if (isAnyClass aHandler 'Block' 'ColorPicker') { return false }
  if (and (hasField aHandler 'window') (isClass (getField aHandler 'window') 'Window')) {
	return false
  }
  return true
}

// load/unload

method openProjectFromFile Stage fileName {
  // Open a project with the give file path or URL.
  // First try reading the project from the embedded file system.
  // If that does not exist, try to read it from app's directory.

  data = (readEmbeddedFile fileName true)
  if (isNil data) {
	prefix = (appPath)
	i = (findLast prefix '/')
	prefix = (substring prefix 1 (i - 1))
	fileName = (join prefix '/' fileName)
	data = (readFile fileName true)
  }
  if (isNil data) {
	error (join 'Could not read: ' fileName)
  }
  openProject this data
}

method openProject Stage projectData {
  page = (global 'page')
  setColor page (gray 0)
  addPart page morph
  scaleToFit this (width page) (height page)
  gotoCenterOf morph (morph page)
  if (notNil (focus (keyboard page))) {
	cancel (focus (keyboard page))
	focusOn (keyboard page) nil
  }
  project = (readProject (emptyProject) projectData)
  loadPage this (first (pages project))
}

method loadPage Stage projectPage {
  // Add the morphs of the given page to the stage.

  stageScale = (scale morph)
  originX = (hCenter (bounds morph))
  originY = (vCenter (bounds morph))
  removeAllParts morph
  for m (morphs projectPage) {
	postSerialize m
	p = (rotationCenter m)
	x = (originX + (stageScale * (first p)))
	y = (originY + (stageScale * (last p)))
	setScale m ((scale m) * stageScale)
	if (isClass (handler m) 'Monitor') { fixLayout (handler m) }
	placeRotationCenter m x y
	addPart morph m
  }
}

method unloadPage Stage projectPage {
  // Remove all morphs from the stage and save them in the given page.

  stageScale = (scale morph)
  originX = (hCenter (bounds morph))
  originY = (vCenter (bounds morph))
  mlist = (toArray (parts morph))
  for m mlist {
	removePart morph m
	p = (rotationCenter m)
	x = (((first p) - originX) / stageScale)
	y = (((last p) - originY) / stageScale)
	setScale m ((scale m) / stageScale)
	placeRotationCenter m x y
	preSerialize m
  }
  setMorphs projectPage mlist
}

// window resizing

method pageResized Stage {
  page = (global 'page')
  scaleToFit this (width page) (height page)
  gotoCenterOf morph (morph page)
  if (and ('iOS' == (platform)) ((height page) > (width page)) (isPresenting this)) {
	setTop morph (100 * (global 'scale'))
	showKeyboard true
  }
}

// menu

method rightClicked Stage {
  if (isPresenting this) {
	menu = (presentationModeMenu this)
  } else {
	menu = (scriptingModeMenu this)
  }
  popUpAtHand menu (global 'page')
  return true
}

method isPresenting Stage {
  return (isClass (handler (owner morph)) 'Page')
}

method presentationModeMenu Stage {
  page = (global 'page')
  menu = (menu 'Presentation Menu' page)
  addItem menu 'broadcast "go"' 'broadcastGo'
  addItem menu 'stop all' 'stopAll' 'halt all currently running threads'
  if (hasEditor this) {
	addLine menu
	addItem menu 'exit presentation mode' (action 'exitPresentationMode' this) 'return to the project editor'
  }
  return menu
}

method hasEditor Stage {
  for m (parts (morph (global 'page'))) {
	if (isClass (handler m) 'ProjectEditor') {
	  return true
	}
  }
  return false
}

method exitPresentationMode Stage {
  for m (parts (morph (global 'page'))) {
	if (isClass (handler m) 'ProjectEditor') {
	  exitPresentation (handler m)
	  return
	}
  }
}

method scriptingModeMenu Stage {
  page = (global 'page')
  menu = (menu 'Stage Menu' page)
  addItem menu 'GP version...' 'showGPVersion'
  addLine menu
  addItem menu 'show all' (action 'showAll' this) 'move any offscreen objects back into view'
  addItem menu 'normal stage size' (action 'normalStageSize' this) 'make the stage be normal size'
  addItem menu 'grab image from screen' (action 'grabImageFromScreen' this) 'copy a part of of this window as an image'
  addLine menu
  addItem menu 'load extension...' (action 'loadExtension' this) 'load GP extension file'
  addLine menu
  if (not (devMode)) {
	addItem menu 'enter developer mode' 'enterDeveloperMode'
  } else {
	addItem menu 'exit developer mode' 'exitDeveloperMode'
	addLine menu
	addItem menu 'workspace...' 'openWorkspace' 'open a text window'
	addItem menu 'presentation...' 'openPresentation' 'open a window for presenting big, centered text'
	addItem menu 'system palette...' (action 'openSystemPalette' nil) 'open a palette of blocks for all methods in the system'
	addItem menu 'Parts Bin...' (action 'openPartsBin' 'runtime/parts/') 'Open the Parts Viewer'
	addLine menu
	addItem menu 'load source file...' (action 'loadSourceFile' this) '(re)load a .gp source file'
	addLine menu
	addItem menu 'benchmark...' 'runBenchmarks' 'run some simple compute-speed benchmarks'
	addItem menu 'start profiling' 'startProfiling'
	addItem menu 'end profiling' 'endProfiling'
	addLine menu
	if (vectorTrails) {
	  addItem menu 'use sharp-edged pen' 'toggleVectorTrails'
	} else {
	  addItem menu 'use smooth-edged pen' 'toggleVectorTrails'
	}
// 	if (fakeVectors) {
// 	  addItem menu 'use vector primitives' 'toggleFakeVectors'
// 	} else {
// 	  addItem menu 'simulate vector primitives' 'toggleFakeVectors'
// 	}
	addItem menu 'resize window to 720p' (action 'setWindowSize' (global 'page') 1280 720)
//	addItem menu 'resize window to 780p' (action 'setWindowSize' (global 'page') 1038 778)
  }
  addLine menu
  addItem menu 'quit' 'confirmToQuit'
  return menu
}

method showAll Stage {
  for m (parts morph) {
    keepWithin m (bounds morph)
    setAlpha m 255
	show m
  }
}

method normalStageSize Stage {
  editor = (handler (owner morph))
  if (isClass editor 'ProjectEditor') {
	normalStageSize editor
  }
}

method loadExtension Stage {
  pickFileToOpen (action 'loadExtensionFileNamed' this) (gpFolder)  (array '.gpp' '.gpe')
}

method loadExtensionFileNamed Stage fName {
  // Load an extension with the give full path name.

  editor = (ownerThatIsA morph 'ProjectEditor')
  if (isNil editor) { return }
  editor = (handler editor)

  data = (readFile fName true)
  if (isNil data) {
	error (join 'Could not read: ' fName)
  }
  extProject = (readProject (new 'Project') data)
  projName = (withoutExtension (filePart fName))
  importExtension (project editor) projName extProject
  developerModeChanged editor // update palette
}

method loadSourceFile Stage {
  pickFileToOpen (action 'reloadSourceFileNamed' this) (gpFolder) '.gp'
}

method reloadSourceFileNamed Stage fName {
  // Reload a source with the give full path name.

  reload fName
  editor = (ownerThatIsA morph 'ProjectEditor')
  if (notNil editor) {
	developerModeChanged (scripter (handler editor)) // update block categories
  }
}

method grabImageFromScreen Stage {
  screenGrab (action 'imageGrabbed' this)
}

method imageGrabbed Stage bm {
  editor = (handler (owner morph))
  if (isClass editor 'ProjectEditor') {
	proj = (project editor)
	name = (uniqueNameNotIn (imageNames proj) 'screenshot')
	saveImageAs proj bm name
	inform (join name ' saved in "images" tab')
  }
}

// let the user switch between vector trails and conventional ones

to vectorTrails {return (!= false (global 'vectorTrails'))}
to toggleVectorTrails {setGlobal 'vectorTrails' (not (vectorTrails))}

to fakeVectors {return (== true (global 'fakeVectors'))}
to toggleFakeVectors {setGlobal 'fakeVectors' (not (fakeVectors))}
// Concatenating

method join String args... {
  // Return a string that joins the string representations of all arguments.

  strings = (list)
  for i (argCount) { add strings (toString (arg i)) }
  return (joinStringArray (toArray strings))
}

// Testing

method beginsWith String prefix {
  n = (byteCount prefix)
  if (n > (byteCount this)) { return false }
  for i n {
    b1 = (byteAt this i)
    b2 = (byteAt prefix i)
    if (b1 != b2) { return false }
  }
  return true
}

method endsWith String postfix {
  i = (((byteCount this) - (byteCount postfix)) + 1)
  if (i < 1) { return false }
  j = 1
  repeat (byteCount postfix) {
    b1 = (byteAt this i)
    b2 = (byteAt postfix j)
    if (b1 != b2) { return false }
	i += 1
	j += 1
  }
  return true
}

method isLetter String {
  // Just for now, afterwards, it'd have to look at the Unicode attributes
  return (or (and ('A' <= this) (this <= 'Z'))
             (and ('a' <= this) (this <= 'z')))
}

method isUpperCase String {
  // Just for now, afterwards, it'd have to look at the Unicode attributes
  return (and ('A' <= this) (this <= 'Z'))
}

method isLowerCase String {
  // Just for now, afterwards, it'd have to look at the Unicode attributes
  return (and ('a' <= this) (this <= 'z'))
}

method isDigit String {
  // Just for now, afterwards, it'd have to look at the Unicode attributes
  return (and ('0' <= this) (this <= '9'))
}

method isHexDigit String {
  return (or
  	(and ('0' <= this) (this <= '9'))
  	(and ('A' <= this) (this <= 'F'))
  	(and ('a' <= this) (this <= 'f')))
}

method isSymbol String {
  // Return true if this character is an ASCII symbol
  return (or (and ('!' <= this) (this <= '/'))
             (and (':' <= this) (this <= '@'))
             (and ('[' <= this) (this <= '`'))
             (and ('{' <= this) (this <= '~')))
}

method isWhiteSpace String {
  // Just for now, afterwards, it'd have to look at the Unicode attributes
  return (this <= ' ')
}

method containsWhitespace String {
  space = 32
  for i (byteCount this) {
	if ((byteAt this i) <= space) { return true }
  }
  return false
}

// Sorting

method caseInsensitiveSort String aString {
  // Return true if this string would come before aString in a case-insensitive ASCII sort.
  // NOTE: Does not sort Unicode characters correctly!

  count = (min (count this) (count aString))
  for i count {
	ch1 = (at this i)
	ch2 = (at aString i)
	if (isLowerCase ch1) { ch1 = (string ((byteAt ch1 1) - 32)) }
	if (isLowerCase ch2) { ch2 = (string ((byteAt ch2 1) - 32)) }
	if (ch1 < ch2) { return  true }
	if (ch1 > ch2) { return  false }
  }
  return (count this) <= (count aString)
}

// Splitting file paths

method directoryPart String {
  // Return the directory part of the given full file name.
  // The directory part is everything up to and including the last '/'.
  // If there is no '/', return the empty string.

  i = (findLast this '/')
  if (isNil i) { return '' }
  return (substring this 1 i)
}

method filePart String {
  // Return the file part of the given full file name or URL.
  // The directory part is everything after the last '/'.
  // If there is no '/' return the entire string.

  i = (findLast this '/')
  if (isNil i) {
    j = (findLast this '\') // check for Windows file separater (e.g. from drag-file file name)
    if (isNil j) { return this }
    i = j
  }
  return (substring this (i + 1))
}

method parentDir String {
  // Return a path to the parent directory of the given path.

  if (or ('/' == this) ('' == this)) { return '/' }
  pathParts = (splitWith this '/')
  if ((count pathParts) < 2) { return '' }
  if ('' == (last pathParts)) { // path ended with '/')
	pathParts = (copyFromTo pathParts 1 ((count pathParts) - 1))
  }
  pathParts = (copyFromTo pathParts 1 ((count pathParts) - 1)) // remove last dir in path
  if (and ('' == (first pathParts)) ((count pathParts) == 1)) { return '/' }
  return (joinStrings pathParts '/')
}

method withoutExtension String {
  // Return this string without any file extension. (A file extension
  // is a '.' followed by a suffix indicating the file type). If there
  // is no '.' in the string, return the entire string.

  i = (findLast this '.')
  if (isNil i) { return this }
  return (substring this 1 (i - 1))
}

method findFirst String ch {
  // Return the index of the first instance of ch or nil if not found.

  letters = (letters this)
  count = (count letters)
  i = 1
  while (i <= count) {
	if ((at this i) == ch) { return i }
	i += 1
  }
  return nil // ch not found
}

method findLast String ch {
  // Return the index of the last instance of ch or nil if not found.

  letters = (letters this)
  i = (count letters)
  while (i > 0) {
	if ((at this i) == ch) { return i }
	i += -1
  }
  return nil // ch not found
}

// Searching

method findSubstring String stringToSearch startIndex {
  // Return the index of the next instance of this string found in stringToSearch,
  // or nil if not found. If startIndex is provided, the search starts there.

  if (isNil startIndex) { startIndex = 1 }
  if (0 == (count this)) { error 'Pattern string cannot be empty' }
  firstByte = (byteAt this 1)
  end = (((byteCount stringToSearch) + 1) - (byteCount this))
  i = startIndex
  while (i <= end) {
	if (firstByte == (byteAt stringToSearch i)) {
	  if (foundMatch this stringToSearch i) { return i }
	}
	i += 1
  }
  return nil
}

method foundMatch String stringToSearch matchIndex {
  j = matchIndex
  for i (byteCount this) {
	if ((byteAt this i) != (byteAt stringToSearch j)) { return false }
	j += 1
  }
  return true
}

method findAllMatches String stringToSearch {
  result = (list)
  i = 1
  while true {
	match = (findSubstring this stringToSearch i)
	if (isNil match) { return result }
	add result match
	i = (match + (byteCount this))
  }
  return result
}

// Indexed access

method at String index {
  // Return the letter of this string at the given index.
  // Note: For heavy use, it is more efficient to covert the string
  // to an array of letters once and work with that.

  return (at (letters this) index)
}

// White space characters

to space { return (string 32) }
to tab { return (string 9) }
to newline { return (string 10) }
to cr { return (string 13) }

// Converting

method toBinaryData String {
  byteCount = (byteCount this)
  result = (newBinaryData byteCount)
  if (byteCount > 0) { replaceByteRange result 1 byteCount this }
  return result
}

method toInteger String {
  letters = (letters this)
  n = (count letters)
  if (n == 0) { return 0 }
  result = 0
  sign = 1
  index = 1
  if ((at letters 1) == '-') {
    sign = -1
    index = 2
  }
  while (index <= n) {
    c = (at letters index)
	if (isDigit c) {
	  digit = ((byteAt c 1) - (byteAt '0' 1))
	} else {
	  error 'this string does not represent an integer'
	}
    result = ((10 * result) + digit)
    index += 1
  }
  return (sign * result)
}

method toNumber String failValue {
  // Return this string as a number, if possible.
  // Otherwise, return failValue (0 by default).

  if ((argCount) < 2) { failValue = 0 } // allow nil as failValue
  if (')' == this) { return failValue } // suppress parse warning
  a = (parse this)
  if ((count a) != 1) { return failValue }
  n = (first a)
  if (or (isClass n 'Integer') (isClass n 'Float')) { return n }
  return failValue
}

method separateCamelCase String {
  words = (list)
  thisWord = (list)
  for ch (letters this) {
    if (isUpperCase ch) {
	  if ((count thisWord) > 0) {
	    add words (joinStringArray (toArray thisWord))
		thisWord = (list)
	  }
	  ch = (string ((byteAt ch 1) + 32))
	}
	add thisWord ch
  }
  if ((count thisWord) > 0) {
    add words (joinStringArray (toArray thisWord))
  }
  return (joinStringArray (toArray words) ' ')
}

method toUnixPath String {
  // Convert from Windows to Unix/Mac directory delimitors.

  letters = (letters this)
  for i (count letters) {
    if ('\' == (at letters i)) { atPut letters i '/' }
  }
  return (joinStringArray letters)
}

// Printing and Formatting

method toString String { return this }

method printString String {
  // Returns a parsable version of this string, enclosed in single
  // quotes and with any embedded single quotes doubled.

  singleQuote = ''''
  cr = (cr)
  newline = (newline)
  result = (list)
  add result singleQuote
  for c (letters this) {
    if (c == singleQuote) {
      add result singleQuote
      add result singleQuote
    } (c == cr) {
	  add result newline // replace CR with newline
    } else {
      add result c
    }
  }
  add result singleQuote
  return (joinStringArray (toArray result))
}

method format String args... {
  in = (splitWith this '%')
  inP = 1
  argP = 2
  out = (list)
  while (inP < (count in)) {
    add out (at in inP)
    add out (toString (arg argP))
    inP += 1
    argP += 1
  }
  if ((at in inP) != '') {
    add out (at in inP)
  }
  return (joinStringArray (toArray out))
}

// parsing and evalution

method eval String obj module {
  // Evaluate the given string. If obj is supplied, evaluate the
  // string in the context of that object.
  // If module is supplied, evaluate the string in the module
  if (this == '') { return nil }
  if (this == 'nil') { return nil }
  if (not (isClass module 'Module')) { module = nil }
  if (isNil module) { module = (module (classOf obj)) }
  parseResult = (parse this)
  if (isEmpty parseResult) {
    print 'Could not parse' (printString this) '; syntax error?'
	return nil
  }
  for p parseResult {
    cmdList = p
    if (isClass cmdList 'Command') {
      if (not (isControlStructure cmdList)) {
        cmdList = (newCommand 'return' (toReporter cmdList))
      }
    } (isClass cmdList 'Reporter') {
	  if (isControlStructure cmdList) {
		cmdList = (toCommand cmdList)
	  } else {
		cmdList = (newCommand 'return' cmdList)
	  }
    } else {
      return cmdList // literal value
    }
    if (isNil obj) {
      func = (function cmdList)
	  if (notNil module) { setField func 'module' module }
      val = (call func)
    } else {
      // Evaluate in the context of an object
        found = false
      for v (fieldNames (classOf obj)) {
        // field name by itself? return field value
        if (and ((primName p) == v) (isNil (nextBlock p))) {
          found = true
          val = (getField obj v)
        }
      }
      if (and (not found) ((primName p) == 'this') (isNil (nextBlock p))) {
          found = true
          val = obj
      }
	  if (not found) {
        func = (functionFor obj cmdList)
		if (notNil module) { setField func 'module' module }
        val = (call func obj)
      }
    }
  }
  return val
}

// Handy Utilities

method splitWith String delimiter {
  in = (letters this)
  inP = 1
  inCount = (count in)
  if (inCount == 0) { return (array) }
  out = (list)
  start = 1
  if ((at in inP) == delimiter) {
    add out ''
    inP += 1
    start = 2
  }
  while (inP <= inCount) {
    c = (at in inP)
    if (c == delimiter) {
      add out (joinStringArray (toArray (copyArray in (inP - start) start)))
      start = (inP + 1)
    }
    inP += 1
  }
  add out (joinStringArray (toArray (copyArray in (inCount - (start - 1)) start)))
  return (toArray out)
}

method trim String {
  // Return a copy of this string without leading and trailing whitespace.

  space = 32
  end = (byteCount this)
  if (0 == end) { return this }
  if (and ((byteAt this 1) > space) ((byteAt this end) > space)) { return this }
  start = 1
  while (and (start <= end) ((byteAt this start) <= space)) { start += 1 }
  while (and (end > start) ((byteAt this end) <= space)) { end += -1 }
  return (substring this start end)
}

method wordWrapped String width {
  // Return a list of lines word-wrapped to the given width
  // using the current font.
  if (isNil width) { width = 500 }
  result = (list)
  for line (lines this) {
	addAll result (wordWrappedLine line width)
  }
  return (toArray result)
}

method wordWrappedLine String width {
  // Return a list of lines word-wrapped to the given width
  // using the current font, ignoring line endings.
  if (isNil width) { width = 150 }
  width = (width * (global 'scale'))
  result = (list)
  startIndex = 1
  endIndex = 0
  separators = (array ' ' ',' ';' ':' '.')
  charCount = (count this)

  for c (letters this) {
    endIndex = (endIndex + 1)
	stringSoFar = (substring this startIndex endIndex)
	lineWidth = (stringWidth stringSoFar)
	if (and (contains separators c) (lineWidth > width)) {
		add result stringSoFar
		startIndex = (endIndex + 1)
	} (endIndex == charCount) {
		add result stringSoFar
	}
  }

  return result
}

method containsSubString String target start {
  count = (byteCount target)
  if (or ((count this) == 0) (count == 0)) {return 0}
  if (isNil start) {start = 1}
  if ((byteCount this) < ((start - 1) + count)) {return 0}
  for i (range start (((byteCount this) - count) + 1)) {
    in = true
    j = 1
    while (and in (j <= count)) {
      if (not ((byteAt this (+ i j -1)) === (byteAt target j))) {
        in = false
      }
      j += 1
    }
    if in {
      return i
    }
  }
  return 0
}

method splitWithString String terminator {
  result = (list)
  ind = 1
  more = true
  while (and more (ind <= (byteCount this))) {
    pos = (containsSubString this terminator ind)
    if (pos > 0) {
      add result (stringFromByteRange this ind (pos - 1))
      ind = (pos + (byteCount terminator))
    } else {
      more = false
    }
  }
  if (not more) {
    // xabc
    if (ind < (byteCount this)) {
      add result (stringFromByteRange this ind (byteCount this))
    }
  } else {
    if (ind == ((byteCount this) + 1)) {
      add result ''
    }
  }
  return (toArray result)
}

method toUpperCase String {
  result = (list)
  offset = ((byteAt 'a' 1) - (byteAt 'A' 1))
  for c (letters this) {
    if (isLowerCase c) {
      c = (string ((byteAt c 1) - offset))
    }
    add result c
  }
  return (joinStringArray (toArray result))
}

method toLowerCase String {
  result = (list)
  offset = ((byteAt 'a' 1) - (byteAt 'A' 1))
  for c (letters this) {
    if (isUpperCase c) {
      c = (string ((byteAt c 1) + offset))
    }
    add result c
  }
  return (joinStringArray (toArray result))
}

method leftPadded String desiredLength char {
  if (isNil char) { char = (string 32) } // space
  result = this
  while ((count result) < desiredLength) { result = (join '' char result) }
  return result
}

method rightPadded String desiredLength char {
  if (isNil char) { char = (string 32) } // space
  result = this
  while ((count result) < desiredLength) { result = (join result char) }
  return result
}

method escapeDoubleQuotes String {
  if ('' == this) { return this }
  result = (list)
  for ch (letters this) {
	if ('"' == ch) { add result '\' }
	add result ch
  }
  return (joinStrings result)
}

method normalizeLineEndings String {
  return (joinStringArray (lines this) (newline))
}

method copyReplacing String aChar newChar {
  // Return a copy of this string with all instances of aChar replaced by newChar.

  result = (toList (letters this))
  for i (count result) {
    if (aChar == (at result i)) {
      atPut result i newChar
    }
  }
  return (joinStrings result)
}

method varMustBeQuoted String {
  if ('' == this) { return true } // empty string
  if (contains (letters this) ' ') { return true }
  ch = (at this 1)
  if (or (isDigit ch) ('-' == ch)) { return true }
  return false
}

// Unicode encoding

method codePoints String {
  result = (list)
  i = 1
  while (i <= (byteCount this)) {
	c1 = (byteAt this i)
	if (c1 <= 127) {
	  add result c1
	  i += 1
	} ((c1 & 224) == 192) {
	  c2 = (byteAt this (i + 1))
	  add result (((c1 & 31) << 6) + (c2 & 63))
	  i += 2
	} ((c1 & 240) == 224) {
	  c2 = (byteAt this (i + 1))
	  c3 = (byteAt this (i + 2))
	  add result (+ ((c1 & 15) << 12) ((c2 & 63) << 6) (c3 & 63))
	  i += 3
	} ((c1 & 248) == 240) {
	  c2 = (byteAt this (i + 1))
	  c3 = (byteAt this (i + 2))
	  c4 = (byteAt this (i + 3))
	  add result (+ ((c1 & 7) << 18) ((c2 & 63) << 12) ((c3 & 63) << 6) (c4 & 63))
	  i += 4
	} else {
	  error 'Bad UTF-8 string'
	}
  }
  return result
}

to stringFromCodePoints codePoints {
  result = (list)
  for cp codePoints {
    addAll result (bytesForCodePoint cp)
  }
  return (toString (toBinaryData (toArray result)))
}

to bytesForCodePoint codePoint {
  if (codePoint < 128) { return (array codePoint) }
  masks = (array 128 192 224 240 248 252 254 255)
  result = (list)
  nBytes = (truncate (((highBit codePoint) + 3) / 5))
  mask = (at masks nBytes)
  shift = ((nBytes - 1) * 6)
  add result (mask | (codePoint >> shift))
  repeat (nBytes - 1) {
	shift = (shift - 6)
	add result (128 | ((codePoint >> shift) & 63))
  }
  return (toArray result)
}

method quoted String { return this }

method canonicalizedWord String {
  // Return a string containing only lower-case ASCII letters,
  // (no digits, symbols, or extended characters).

  result = (list)
  for ch (letters this) {
	if (or (isLetter ch) (ch == '-')) {
	  if (isUpperCase ch) {
		ch = (string ((byteAt ch 1) + 32))
	  }
	  add result ch
    }
  }
  while (and ((count result) > 0) ((last result) == '-')) { removeLast result }
  return (joinStringArray (toArray result))
}

method urlDecode String {
  result = (list)
  letters = (letters this)
  n = (count letters)
  i = 1
  while (i <= n) {
	ch = (at letters i)
	if (and
	  ('%' == ch)
	  (i <= (n - 2))
	  (isHexDigit (at letters (i + 1)))
	  (isHexDigit (at letters (i + 2)))) {
		hexDigits = (join (at letters (i + 1)) (at letters (i + 2)))
		add result (hex hexDigits)
		i += 3
	} else {
		addAll result (toArray (toBinaryData ch))
		i += 1
	}
  }
  return (toString (toBinaryData (toArray result)))
}

method percentEncode String {
  return (urlEncode this true)
}

method urlEncode String safeOnly {
  safe = (toArray (toBinaryData '-_.~'))
  // Note: could add some of these: '$''()*,' to reserved but it seems best to escape them
  reserved = (toArray (toBinaryData '!#&+/:;=?@'))
  if (true == safeOnly) { reserved = (array) } // percent encode reserved characters
  result = (list)
  for ch (toArray (toBinaryData this)) {
	if (or
		(and (97 <= ch) (ch <= 122)) // a-z
		(and (65 <= ch) (ch <= 90)) // A-Z
		(and (48 <= ch) (ch <= 57)) // 0-9
		(contains safe ch)
		(contains reserved ch)) {
			// ch does not need to be encoded
			add result (string ch)
	} else {
			// ch must be percent-encoded (this includes the bytes of utf-8 encoded characters
			hexDigits = (toStringBase16 ch)
			if ((count hexDigits) < 2) { hexDigits = (join '0' hexDigits) }
			add result (join '%' hexDigits)
	}
  }
  return (joinStringArray (toArray result))
}

method withoutTrailingDigits String {
  i = (count this)
  while (and (i > 0) (isDigit (at this i))) {
	i += -1
  }
  return (substring this 1 i)
}

method representsANumber String {
  hasDecimalPoint = false
  hasExponent = false
  lastC = nil
  for c (letters this) {
	if ('-' == c) {
	  if (not (or (isNil lastC) (isOneOf lastC 'e' 'E'))) {
		return false
	  }
	} ('+' == c) {
	  if (not (isOneOf lastC 'e' 'E')) {
		return false
	  }
	} ('.' == c) {
	  if hasDecimalPoint { return false }
	  if (not (or (isNil lastC) (isDigit lastC))) {
	  	return false
	  }
	  hasDecimalPoint = true
	} (isOneOf c 'e' 'E') {
	  if hasExponent { return false }
	  if (not (and (notNil lastC) (isDigit lastC))) {
		return false
	  }
	  hasExponent = true
	} (not (isDigit c)) {
	  return false
	}
	lastC = c
  }
  return true
}

method representsAnInteger String {
  if ('' == this) { return false }
  if ('-' == (at this 1)) {
  	return (and ((count this) > 1) (allDigits (substring this 2)))
  }
  return (allDigits this)
}

method allDigits String {
  for c (letters this) {
	if (not (isDigit c)) { return false }
  }
  return true
}
// explore the GP code base

defineClass Synopsis morph window globals globalsFrame globalScripts localScripts globalScriptsFrame localScriptsFrame classes classesFrame fieldTabs fieldTabsFrame fields fieldsFrame methods methodsFrame functionTabs globalTabs localTabs methodTabs methodTabsFrame globalCode globalCodeFrame localCode localCodeFrame

to newSynopsis {
  syn = (new 'Synopsis')
  initialize syn
  return syn
}

method initialize Synopsis {
  scale = (global 'scale')
  window = (window 'Synopsis')
  border = (border window)
  clr = (clientColor window)
  morph = (morph window)
  setHandler morph this
  setMinExtent morph (scale * 300) (scale * 200)

  functionTabs = (tabBar (array 'text' 'blocks') nil (action 'functionTab' this 'functions'))
  addPart morph (morph functionTabs)

  globals = (listBox (sortedFunctions this) 'functionName'  (action 'selectGlobal' this) clr (action 'blockify' this))
  globalsFrame = (scrollFrame globals clr)
  addPart morph (morph globalsFrame)

  globalTabs = (tabBar (array 'text' 'blocks') nil (action 'tab' this 'global'))
  addPart morph (morph globalTabs)

  globalCode = (newText)
  setEditRule globalCode 'code'
  setGrabRule (morph globalCode) 'ignore'
  setBorders globalCode border border true

  globalCodeFrame = (scrollFrame globalCode clr)
  addPart morph (morph globalCodeFrame)

  globalScripts = (newScriptEditor 10 10)

  classes = (listBox (sortedClasses this) 'className'  (action 'selectClass' this) clr)
  classesFrame = (scrollFrame classes clr)
  addPart morph (morph classesFrame)

  fieldTabs = (tabBar (array 'text' 'blocks') nil (action 'fieldTab' this))
  fieldTabsFrame = (newMorph)
  setClipping fieldTabsFrame true true
  addPart fieldTabsFrame (morph fieldTabs)
  addPart morph fieldTabsFrame

  fields = (listBox (array) 'id' (action 'selectField' this) clr)
  fieldsFrame = (scrollFrame fields clr)
  addPart morph (morph fieldsFrame)

  localTabs = (tabBar (array 'text' 'blocks') nil (action 'tab' this 'local'))
  addPart morph (morph localTabs)

  methodTabs = (tabBar (array 'text' 'blocks') nil (action 'functionTab' this 'methods'))
  methodTabsFrame = (newMorph)
  setClipping methodTabsFrame true true
  addPart methodTabsFrame (morph methodTabs)
  addPart morph methodTabsFrame

  methods = (listBox (array) 'functionName' (action 'selectMethod' this) clr (action 'blockify' this))
  methodsFrame = (scrollFrame methods clr)
  addPart morph (morph methodsFrame)

  localScripts = (newScriptEditor 10 10)

  localCode = (newText)
  setEditRule localCode 'code'
  setGrabRule (morph localCode) 'ignore'
  setBorders localCode border border true

  localCodeFrame = (scrollFrame localCode clr)
  addPart morph (morph localCodeFrame)

  setExtent morph (scale * 400) (scale * 300)

  setFramePadding (alignment functionTabs) (4 * scale)
  fixLayout (alignment functionTabs)
  select functionTabs 'text' true

  setFramePadding (alignment globalTabs) (4 * scale)
  fixLayout (alignment globalTabs)
  select globalTabs 'text' true

  setFramePadding (alignment fieldTabs) (4 * scale)
  fixLayout (alignment fieldTabs)
  select fieldTabs 'text' true

  setFramePadding (alignment methodTabs) (4 * scale)
  fixLayout (alignment methodTabs)
  select methodTabs 'text' true

  setFramePadding (alignment localTabs) (4 * scale)
  fixLayout (alignment localTabs)
  select localTabs 'text' true
}

method sortedFunctions Synopsis {
  return (sorted (functions) (function f1 f2 { return ((functionName f1) < (functionName f2)) }))
}

method sortedClasses Synopsis {
  return (sorted (classes) (function c1 c2 { return ((className c1) < (className c2)) }))
}

method fixLayout Synopsis {
  fixLayout window
  clientArea = (clientArea window)
  border = (border window)

  setPosition (morph functionTabs) (left clientArea) (top clientArea)

  setPosition (morph globalsFrame) (left clientArea) (bottom (morph functionTabs))
  setExtent (morph globalsFrame) (((width clientArea) / 2) - border) ((((height clientArea) / 2) - border) - (height (morph functionTabs)))

  setPosition (morph globalTabs) (left (morph globalsFrame)) (+ (bottom (morph globalsFrame)) border)

  setPosition (morph globalCodeFrame) (left (morph globalsFrame)) (bottom (morph globalTabs))
  setExtent (morph globalCodeFrame) (width (morph globalsFrame)) (((height clientArea) / 2) - (height (morph globalTabs)))

  setPosition (morph classesFrame) (+ (right (morph globalsFrame)) border) (top clientArea)
  setExtent (morph classesFrame) ((width clientArea) / 4) (+ (height (morph globalsFrame)) (height (morph functionTabs)))

  setPosition fieldTabsFrame (+ (right (morph classesFrame)) border) (top clientArea)
  setExtent fieldTabsFrame (((width clientArea) / 4) - border) (height (morph fieldTabs))

  setPosition (morph fieldsFrame) (+ (right (morph classesFrame)) border) (bottom fieldTabsFrame)
  setExtent (morph fieldsFrame) (((width clientArea) / 4) - border) ((((height clientArea) / 5) - border) - (height fieldTabsFrame))

  setPosition methodTabsFrame (+ (right (morph classesFrame)) border) (+ (bottom (morph fieldsFrame)) border)
  setExtent methodTabsFrame (width (morph fieldsFrame)) (height (morph methodTabs))

  setPosition (morph methodsFrame) (+ (right (morph classesFrame)) border) (bottom methodTabsFrame)
  setExtent (morph methodsFrame) (width (morph fieldsFrame)) (- (- (- ((height clientArea) / 2) (height (morph fieldsFrame))) (border * 2)) (height (morph methodTabs)))

  setPosition (morph localTabs) (+ (right (morph globalsFrame)) border) (+ (bottom (morph classesFrame)) border)

  setPosition (morph localCodeFrame) (left (morph localTabs)) (bottom (morph localTabs))
  setExtent (morph localCodeFrame) ((width (morph globalsFrame)) + border) (((height clientArea) / 2) - (height (morph globalTabs)))
}

method redraw Synopsis {
  redraw window
  fixLayout this
}

method selectGlobal Synopsis aFunction {
  setText globalCode (codeFor this aFunction)
  removeAllParts (morph globalScripts)
  if (isVisible (morph globalScripts)) {
    showBlocks this aFunction globalScripts
  }
}

method showBlocks Synopsis aFunction aPane {
  removeAllParts (morph aPane)
  if (isNil aFunction) {return}
  block = (scriptForFunction aFunction)
  setGrabRule (morph block)'ignore'
  setPosition (morph block) (left (morph aPane)) (top (morph aPane))
  off = ((global 'scale') * 10)
  moveBy (morph block) off off
  addPart (morph aPane) (morph block)
  frame = (handler (owner (morph aPane)))
  setPosition (morph aPane) (left (morph frame)) (top (morph frame))
  updateSliders frame
}

method functionTab Synopsis target choice {
  if (target == 'methods') {
    listPane = methods
    frame = methodsFrame
  } (target == 'functions') {
    listPane = globals
    frame = globalsFrame
  }
  if (choice == 'text') {
    setField listPane 'getEntry' 'functionName'
    setField listPane 'normalAlpha' 255
  } (choice == 'blocks') {
    setField listPane 'getEntry' 'blockForFunction'
    setField listPane 'normalAlpha' 230
  }
  updateMorphContents listPane
  sel = (selectedMorph listPane)
  if (notNil sel) {scrollIntoView frame (bounds sel)}
}

method fieldTab Synopsis choice {
  if (choice == 'text') {
    setField fields 'getEntry' 'id'
    setField fields 'normalAlpha' 255
  } (choice == 'blocks') {
    setField fields 'getEntry' (action 'newReporter' 'v')
    setField fields 'normalAlpha' 230
  }
  idx = (selectionIndex fields)
  updateMorphContents fields
  if (notNil idx) {
    select fields (at (collection fields) idx)
    sel = (selectedMorph fields)
    if (notNil sel) {scrollIntoView fieldsFrame (bounds sel)}
  }
}

method tab Synopsis target choice {
  if (target == 'global') {
    frame = globalCodeFrame
    text = globalCode
    scripts = globalScripts
    listPane = globals
  } (target == 'local') {
    frame = localCodeFrame
    text = localCode
    scripts = localScripts
    listPane = methods
  }
  if (choice == 'text') {
    setContents frame text
  } (choice == 'blocks') {
    setContents frame scripts
    if (isEmpty (parts (morph scripts))) {
      showBlocks this (selection listPane) scripts
    }
  }
}

method blockify Synopsis aFunction {
  page = (page morph)
  block = (toBlock (cmdList aFunction))
  setPosition (morph block) (x (hand page)) (y (hand page))
  addPart page block
}

method browse Synopsis aClass {
  select classes aClass
  scrollIntoView classesFrame (bounds (selectedMorph classes))
}

method selectClass Synopsis aClass {
  setCollection fields (fieldNames aClass)
  setCollection methods (sortedMethods this aClass)
}

method selectField Synopsis fieldName {
  if (shiftKeyDown (keyboard (handler (root morph)))) {
    select fields nil
    cls = (selection classes)
    mth = (array)
    if (notNil cls) {mth = (sortedMethods this cls)}
    setCollection methods mth
    return
  }
  setCollection methods (accessors this fieldName)
}

method accessors Synopsis fieldName {
  result = (list)
  for m (sortedMethods this (selection classes)) {
    if (contains (varsUsed m) fieldName) {add result m}
  }
  return (toArray result)
}


method sortedMethods Synopsis aClass {
  return (sorted (methods aClass) (function f1 f2 { return ((functionName f1) < (functionName f2)) }))
}

method selectMethod Synopsis aFunction {
  setText localCode (codeFor this aFunction)
  removeAllParts (morph localScripts)
  if (isVisible (morph localScripts)) {
    showBlocks this aFunction localScripts
  }
  func = (functionNamed (functionName aFunction))
  if (notNil func) {
    select globals func
    scrollIntoView globalsFrame (bounds (selectedMorph globals))
  }
}

method codeFor Synopsis aFunction {
  pp = (new 'PrettyPrinter')
  // parms = ''
  // for each (argNames aFunction) {parms = (join parms ' ' each)}
  // code = (join (functionName aFunction) ' ' parms (newline))
  code = ''
  nb = (cmdList aFunction)
  while (notNil nb) {
    code = (join code (prettyPrint pp nb) (newline))
    nb = (nextBlock nb)
  }
  return code
}

method textChanged Synopsis origin {
  if (origin === globalCode) {
    cmd  = (parse this globalCode)
    if (notNil cmd) {setField (selection globals) 'cmdList' cmd}
    selectGlobal this (selection globals)
  } else {
    cmd  = (parse this localCode)
    if (notNil cmd) {setField (selection methods) 'cmdList' cmd}
    selectMethod this (selection methods)
  }
}

method parse Synopsis aText {
  parsed = (parse (join '{' (text aText) '}'))
  if ((count parsed) != 1) {return nil}
  element = (at parsed 1)
  if (isClass element 'Command') {return element}
  return nil
}

// serialization

method preSerialize Synopsis {
  // Clear the function and classs lists before serializing. We don't want
  // to save them and the environment may be different when deserialized).
  setCollection globals (array)
  setCollection classes (array)

  // depending on the tab settings, some of these components may not be
  // in the morph structure, so call preSerialize manually on them
  preSerialize globalCode
  preSerialize localCode
  preSerialize globalScripts
  preSerialize localScripts
}

method postSerialize Synopsis {
  // Restore the function and classs lists.
  setCollection globals (sortedFunctions this)
  setCollection classes (sortedClasses this)

  // depending on the tabs, some of these components may not be
  // in the morph structure, so call postSerialize manually on them
  postSerialize globalCode
  postSerialize localCode
  postSerialize globalScripts
  postSerialize localScripts
}
// Palette of GP blocks by class

to openSystemPalette defaultClassOrNil {
  page = (global 'page')
  pal = (newSystemPalette)
  if (notNil defaultClassOrNil) { browse pal defaultClassOrNil }
  setPosition (morph pal) (x (hand page)) (y (hand page))
  addPart page pal
  return pal
}

defineClass SystemPalette morph window classListFrame blocksPane blocksFrame

to newSystemPalette {
  return (initialize (new 'SystemPalette'))
}

method initialize SystemPalette {
  scale = (global 'scale')
  window = (window 'System Palette')
  clr = (clientColor window)
  morph = (morph window)
  setHandler morph this
  setMinExtent morph (scale * 300) (scale * 200)

  classList = (listBox (sortedClasses this) nil (action 'selectClass' this) clr (action 'openClassBrowser' this nil))
  classListFrame = (scrollFrame classList clr)
  addPart morph (morph classListFrame)

  blocksPane = (newBlocksPalette)
  blocksFrame = (scrollFrame blocksPane (gray 220))
  addPart morph (morph blocksFrame)

  setExtent morph (scale * 400) (scale * 200)
  return this
}

method sortedClasses SystemPalette {
  classList = (list)
  for c (classes) {
    if ((count (methods c)) > 0) { add classList (className c) }
  }
  result = (sorted classList)
  addFirst result '<Global Blocks>'
  return result
}

method browse SystemPalette aClass {
  select (contents classListFrame) aClass
  m = (selectedMorph (contents classListFrame))
  if (notNil m) { scrollIntoView classListFrame (bounds m) }
}

method selectClass SystemPalette className {
  removeAllParts (morph blocksPane)
  fList = (list)
  if ('<Global Blocks>' == className) {
	for f (functions (topLevelModule)) {
	  if (isNil (specForOp (authoringSpecs) (primName f))) { add fList f }
	}
  } else {
    aClass = (class className)
    if (notNil aClass) { fList = (methods aClass) }
  }
  fList = (sorted fList (function f1 f2 { return ((functionName f1) < (functionName f2)) }))
  for f fList {
    b = (morph (blockForSpec (blockSpecFor f)))
    setGrabRule b 'template'
    addPart (morph blocksPane) b
  }
  cleanUp blocksPane
}

// item menu

method handleListContextRequest SystemPalette anArray {
  classList = (contents classListFrame)
  item = (data (last anArray))
  if (classList == (first anArray)) {
    menu = (menu nil this)
    if ('<Global Blocks>' == item) {
      addItem menu 'browse global blocks...' (action 'browseClass'item)
    } else {
      addItem menu 'browse class...' (action 'browseClass'item)
    }
    popUpAtHand menu (global 'page')
  }
}

// top bar menu

method rightClicked SystemPalette aHand {
  popUpAtHand (contextMenu this) (page aHand)
  return true
}

method contextMenu SystemPalette {
  menu = (menu nil this)
  addItem menu 'find system block matching...' (action 'findBlock' this)
  addItem menu 'find primitives matching...' (action 'findPrimitive' this)
  return menu
}

method findBlock SystemPalette {
  searchString = (toLowerCase (prompt (global 'page') 'Block name?'))
  if ('' == searchString) { return }
  selectors = (dictionary)
  for f (allInstances 'Function') { add selectors (functionName f) }
  addAll selectors (primitives)
  startMatches = (list)
  otherMatches = (list)
  for sel (sorted (keys selectors)) {
	lowercaseSel = (toLowerCase sel)
    if (beginsWith lowercaseSel searchString) {
      add startMatches sel
    } ((containsSubString lowercaseSel searchString) > 0) {
      add otherMatches sel
    }
  }
  totalMatches = ((count startMatches) + (count otherMatches))
  if (0 == totalMatches) { return } // no matches
  if (1 == totalMatches) {
	browseImplementors this (first (join startMatches otherMatches))
	return
  }
  if (totalMatches > 30) {
	n = (30 - (count startMatches))
	otherMatches = (copyFromTo otherMatches 1 n)
  }

  menu = (menu 'Implementors of:' (action 'browseImplementors' this) true) // reverse call
  for sel startMatches { addItem menu sel }
  addLine menu
  for sel otherMatches { addItem menu sel }
  popUpAtHand menu (global 'page')
}

method browseImplementors SystemPalette selector {
  implementors = (implementors selector)
  if (0 == (count implementors)) { return }
  if (1 == (count implementors)) {
    openClassBrowser this selector (first implementors)
    return
  }
  menu = (menu (join 'implementations of' (newline) selector) (action 'openClassBrowser' this selector) true) // reverse call
  for each implementors {
    addItem menu (join each '...') each
  }
  popUpAtHand menu (global 'page')
}

method showPrimitive SystemPalette primName {
  inform (global 'page') (join primName ' is a primitive' (newline) (primitiveHelpString primName))
}

method openClassBrowser SystemPalette methodName className {
  if ('<primitive>' == className) {
    showPrimitive this methodName
    return
  }
  page = (global 'page')
  brs = (newClassBrowser)
  setPosition (morph brs) (x (hand page)) (y (hand page))
  addPart page brs
  aClass = (class className)
  if (notNil aClass) {
    browse brs aClass methodName
  } else {
    if ('<generic>' == className) {
      className = (globalBlocksName brs)
    }
    browse brs className (functionNamed methodName)
  }
}

method findPrimitive SystemPalette {
  searchString = (toLowerCase (prompt (global 'page') 'Primitive name?'))
  if ('' == searchString) { return }
  result = (dictionary)
  for p (sorted (primitives)) {
	lowercaseSel = (toLowerCase p)
    if ((containsSubString (toLowerCase p) searchString) > 0) {
      atPut result p (primitiveHelpString p)
    }
  }
  if ((count result) > 0) {
    openExplorer result
  }
}

// layout

method redraw SystemPalette {
  fixLayout window
  redraw window
  fixLayout this
}

method fixLayout SystemPalette {
  classesWidth = (action 'spaceBoundedBy' window (action 'allWidth' (contents classListFrame)) 25)
  packer = (newPanePacker (clientArea window))
  packPanesH packer classListFrame classesWidth blocksFrame 'rest'
  packPanesV packer classListFrame 'rest'
  packPanesV packer blocksFrame 'rest'
  finishPacking packer
}
// Morphic TabBar handler

defineClass TabBar morph listBox alignment tabCorner

to tabBar aCollection getEntry onSelect bgColor fontSize onDoubleClick {
  if (isNil getEntry) {getEntry = 'id'}
  if (isNil onSelect) {onSelect = 'nop'}
  lb = (new 'ListBox' nil aCollection onSelect getEntry nil bgColor)
  onDoubleClick lb onDoubleClick
  tb = (new 'TabBar' nil lb)
  initialize tb 'line' fontSize
  buildMorph tb
  return tb
}

method initialize TabBar alignRule fontPixelSize {
  if (isNil fontPixelSize) {fontPixelSize = 11}
  scale = (global 'scale')
  setField listBox 'fontName' 'Arial Bold'
  fontSize = (scale * fontPixelSize)
  setField listBox 'fontSize' fontSize
  tabCorner = ((fontSize / 2) + (scale + 0))
  setField listBox 'txtClrNormal' (color 230 230 230)
  setField listBox 'txtClrReady' (color 255 255 255)
  setField listBox 'txtClrSelected' (color)
  bgClrSelected = (color 200 200 200)
  setField listBox 'bgClrSelected' bgClrSelected
  setField listBox 'bgClrNormal' (darker bgClrSelected 50)
  setField listBox 'bgClrReady' (darker bgClrSelected 30)
  alignment = (newAlignment alignRule (0 - (fontSize + (scale * 2))))
  setVPadding alignment 0
  setFramePadding alignment 0 0
}

method setBGColors TabBar selectedColor normalColor readyColor {
  if (notNil selectedColor) { setField listBox 'bgClrSelected' selectedColor }
  if (notNil normalColor) { setField listBox 'bgClrNormal' normalColor }
  if (notNil readyColor) { setField listBox 'bgClrReady' readyColor }
  buildMorph this
}

method alignment TabBar {return alignment}
method collection TabBar { return (collection listBox)}
method selection TabBar {return (selection listBox)}
method onSelect TabBar anAction {onSelect listBox anAction}
method onDoubleClick TabBar anAction {onDoubleClick listBox anAction}

method buildMorph TabBar {
  if (notNil morph) {destroy morph}
  morph = (newMorph this)
  setMorph alignment morph
  setMorph listBox morph
  setTransparentTouch morph true
  updateMorphContents this
}

method select TabBar aListItem silently {
  select listBox aListItem silently
  addPart morph (selectedMorph listBox) // bring to front
}

method setCollection TabBar aCollection {
  setField listBox 'collection' aCollection
  updateMorphContents this
}

method updateMorphContents TabBar {
  // remove all existing list items, if any
  repeat (count (parts morph)) {destroy (at (parts morph) 1)}

  // create items
  for item (collection this) {
    lbl = (normalCostume this item)
    li = (newTab this item)
    setHeight (bounds (morph li)) (height lbl)
    setWidth (bounds (morph li)) (width lbl)
    addPart morph (morph li)
  }
  fixLayout alignment

  // create a new background bitmap
  bg = (newBitmap (max 1 (width morph)) (max 1 (height morph)) (getField listBox 'bgColor'))
  setCostume morph bg

  // refresh every item
  for i (count (parts morph)) {
    item = (handler (at (parts morph) i))
    refresh item
  }

  // update sliders, if any
  owner = (owner morph)
  if (and (notNil owner) (isClass (handler owner) 'ScrollFrame'))  {updateSliders (handler owner)}
}

method newTab TabBar item {
  tab = (listItem listBox item)
  tr = (getField tab 'trigger')
  setAction tr (action 'select' this item)
  setRenderer tr this
  return tab
}

// tabs rendering

method normalCostume TabBar data {
  return (tabBitmap
    this
    (toString (call (getField listBox 'getEntry') data))
    (getField listBox 'txtClrNormal')
    (getField listBox 'bgClrNormal')
    false
    (getField listBox 'bgClrSelected')
  )
}

method highlightCostume TabBar data {
  return (tabBitmap
    this
    (toString (call (getField listBox 'getEntry') data))
    (getField listBox 'txtClrSelected')
    (getField listBox 'bgClrSelected')
    true
    (getField listBox 'bgClrSelected')
  )
}

method pressedCostume TabBar data {
  return (tabBitmap
    this
    (toString (call (getField listBox 'getEntry') data))
    (getField listBox 'txtClrReady')
    (getField listBox 'bgClrReady')
    false
    (getField listBox 'bgClrSelected')
  )
}

method tabBitmap TabBar label color bodyColor isInFront frontColor {
  if (isNil color) {color = (color 255 255 255)}
  if (isNil bodyColor) {bodyColor = (color 130 130 130)}
  if (isNil isInFront) {isInFront = false}
  scale = (global 'scale')
  if (isClass label 'String') {
    off = (max (scale / 2) 1)
    shadowColor = (darker bodyColor)
    shift = -1
    if (and ((red color) == 0) ((green color) == 0) ((blue color) == 0)) {
      shadowColor = (color 255 255 255)
      shift = 1
    }
    lbm = (stringImage
      label
      (getField listBox 'fontName')
      (getField listBox 'fontSize')
      color
      'center'
      shadowColor
      (off * shift)
    )
  } else {
    lbm = nil
  }
  tabBorder = 0 // flat

  w = (+ (width lbm) (tabCorner * 4) (tabBorder * 2))
  h = (+ (height lbm) (tabBorder * 2))
  bm = (newBitmap w h)
  if isInFront {
	clr = (gray 220)
  } else {
	clr = (gray 120)
  }
  drawTab (newShapeMaker bm) (rect 0 0 w h) tabCorner tabBorder clr
  drawBitmap bm lbm ((w - (width lbm)) / 2) ((h - (height lbm)) / 2)
  return bm
}

// serialization

method preSerialize TabBar {
  removeAllParts (morph listBox)
  setCostume (morph listBox) nil
  setCostume morph nil
}

method postSerialize TabBar {
  updateMorphContents this
}
defineClass Table columnNames rows changeCount

method columnNames Table { return columnNames }
method columnCount Table { return (count columnNames) }
method rowCount Table { return (count rows) }
method count Table { return (count rows) }
method isEmpty Table { return ((count rows) == 0) }
method changeCount Table { return changeCount }
method rows Table { return rows }

to table columnNames... {
  colNames = (list)
  for i (argCount) {
	cName = (arg i)
	if (isNil cName) { cName = (join 'C' i) }
    add colNames (toString cName)
  }
  return (new 'Table' (toArray colNames) (list) 0)
}

method addRow Table data {
  // Add the given row (a list or array) to this table.
  // If newRow is not as wide as the table, pad it with empty cells.
  // If it is wider, discard any extra cells.

  colCount = (count columnNames)
  if (colCount < 1) { return }
  if (isAnyClass data 'Array' 'List') {
	newRow = (newArray colCount '')
	for i (min colCount (count data)) {
	  atPut newRow i (at data i)
	}
  } else {
	newRow = (newArray colCount '')
	atPut newRow 1 data
  }
  add rows newRow
  changeCount += 1
}

method add Table rowData... {
  colCount = (columnCount this)
  i = 2
  newRow = (newArray colCount)
  for c colCount {
    atPut newRow c (arg i)
    i += 1
  }
  add rows newRow
  changeCount += 1
}

method addAll Table aList {
  colCount = (columnCount this)
  newRowCount = (ceiling ((count aList) / colCount))
  addCount = (count aList)
  i = 1
  repeat newRowCount {
    newRow = (newArray colCount)
	for c colCount {
	  if (i < addCount) { atPut newRow c (at aList i) }
	  i += 1
	}
	add rows newRow
  }
  changeCount += 1
}

method cellAt Table row col {
  r = (at rows row)
  if (isClass r 'Array') {
	return (at r (columnIndex this col))
  } else {
	if (isClass col 'Integer') {
	  if (and (1 <= col) (col <= (count columnNames))) {
		col = (at columnNames col)
	  }
	}
	if (hasField r col) {
	  return (getField r col)
	} else {
	  return nil
	}
  }
}

method cellAtPut Table row col value {
  r = (at rows row)
  if (isClass r 'Array') {
	atPut r (columnIndex this col) value
  } else {
	if (isClass col 'Integer') {
	  if (and (1 <= col) (col <= (count columnNames))) {
		col = (at columnNames col)
	  }
	}
	if (hasField r col) { setField r col value }
  }
  changeCount += 1
}

method row Table row {
  return (at rows row)
}

method rowAtPut Table rowIndex newRow {
  atPut rows rowIndex newRow
  changeCount += 1
}

method insertRow Table rowIndex newRow {
  addAt rows rowIndex newRow
  changeCount += 1
}

method removeRow Table rowIndex {
  removeAt rows rowIndex
  changeCount += 1
}

method column Table col {
  cIndex = (columnIndex this col)
  result = (list)
  for i (count rows) {
	v = (cellAt this i cIndex)
	if (notNil v) { add result v }
  }
  return result
}

method renameColumn Table col newName {
  cIndex = (columnIndex this col)
  if (notNil cIndex) {
	atPut columnNames cIndex newName
  }
  changeCount += 1
}

method removeColumn Table col {
  cIndex = (columnIndex this col)
  if (isNil cIndex) { return }
  columnNames = (join (copyFromTo columnNames 1 (cIndex - 1)) (copyFromTo columnNames (cIndex + 1)))
  newRows = (list)
  for r rows {
	if (isClass r 'Array') {
	  add newRows (join (copyFromTo r 1 (cIndex - 1)) (copyFromTo r (cIndex + 1)))
	} else {
	  add newRows r
	}
  }
  rows = newRows
  changeCount += 1
}

method insertColumnAfter Table col newColName {
  if (or (isNil newColName) ('' == newColName)) { newColName = 'C' }
  newColName = (uniqueNameNotIn columnNames newColName)
  cIndex = (columnIndex this col)
  if (isNil cIndex) { cIndex = (columnCount this) }
  columnNames = (join (copyFromTo columnNames 1 cIndex) (array newColName) (copyFromTo columnNames (cIndex + 1)))
  newRows = (list)
  for r rows {
	if (isClass r 'Array') {
	  add newRows (join (copyFromTo r 1 cIndex) (array '') (copyFromTo r (cIndex + 1)))
	} else {
	  add newRows r
	}
  }
  rows = newRows
  changeCount += 1
}

method summarizeColumn Table col {
  if ((count rows) == 0) { return 'no data' }
  cIndex = (columnIndex this col)
  firstRowValue = (cellAt this 1 cIndex)
  if (isNumber firstRowValue) {
	values = (sorted (column this col))
	result = (dictionary)
	atPut result 'min' (first values)
	atPut result 'max' (last values)
	atPut result 'median' (at values (half (count values)))
	atPut result 'mean' ((sum values) / (count values))
	return result
  } else {
	count = (count (uniqueValuesForColumn this col))
	return (join '' count ' unique values')
  }
}

method uniqueValuesForColumn Table col {
  // Return an array of unique values for the given column in their order of appearance.
  cIndex = (columnIndex this col)
  result = (list)
  unique = (dictionary)
  for r (count rows) {
    v = (cellAt this r cIndex)
    if (not (contains unique v)) {
	  add result v
	  add unique v
	}
  }
  return result
}

method filterInPlace Table col op value {
  filtered = (filtered this col op value)
  rows = (rows filtered)
  changeCount += 1
}

method filtered Table col op value {
  // Return a table containing rows for which the given column
  // satisfies the selection operation and value.

  if ((count rows) == 0) { return (new 'Table' columnNames  (array)) }

  if ('=' == op) { op = '==' } // allow '=' as a synonym for '=='

  cIndex = (columnIndex this col)
  firstRowValue = (cellAt this 1 cIndex)
  if ((classOf value) != (classOf firstRowValue)) {
	if (and (isClass value 'String') (isNumber firstRowValue)) { value = (toNumber value) }
	if (and (isClass firstRowValue 'String') (isNumber value)) { value = (toString value) }
  }

  matchingRows = (list)
  for r (count rows) {
    v = (cellAt this r cIndex)
    if (call op v value) { add matchingRows (at rows r) }
  }
  return (new 'Table' columnNames matchingRows)
}

method find Table col value startIndex {
  // Return the index of the first row for which the given column
  // has the given value or zero if no match is found.

  if (isNil startIndex) { startIndex = 1 }
  cIndex = (columnIndex this col)
  r = startIndex
  last = (count rows)
  while (r <= last) {
    if (value == (cellAt this r cIndex)) { return r }
	r += 1
  }
  return 0
}

method firstRowWhere Table col value... {
  // Return the  first row for which the given columns have the given values,
  // or nil if no match is found.
  // To do: Use an index dictionary to speed up repeated searches.

  cNames = (list)
  cIndices = (list)
  values = (list)
  i = 2
  while (i < (argCount)) {
	cIndex = (columnIndex this (arg i))
	if (isNil cIndex) { return nil }
	add cNames (arg i)
	add cIndices cIndex
	add values (arg (i + 1))
	i += 2
  }
  if (isEmpty cIndices) { return nil }
  cNames = (toArray cNames)
  cIndices = (toArray cIndices)
  values = (toArray values)
  cCount = (count cIndices)

  for row rows {
	match = true
 	j = 1
	while (and match (j <= cCount)) {
	  if (isClass row 'Array') {
		v = (at row (at cIndices j))
	  } else {
		cName = (at cNames j)
		if (hasField row cName) {
		  v = (getField row cName)
		} else {
		  v = nil
		  match = false
		}
	  }
	  if (v != (at values j)) { match = false }
	  j += 1
	}
	if match { return row }
  }
  return nil
}

method sortInPlace Table col op value {
  sorted = (sorted this col op value)
  rows = (rows sorted)
  changeCount += 1
}

method sorted Table col ascending {
  // Return a table containing rows of this table sorted by the
  // given column and sorting operation. If sortOp is not provided
  // it defaults to '<' (i.e. ascending order).

  sortOp = '<'
  if (ascending != true) { sortOp = '>' }
  if (isEmpty rows) { return (new 'Table' columnNames) }
  if (isClass (first rows) 'Array') {
	sortAction = (action
	  (function cIndex op r1 r2 { return (call op (at r1 cIndex) (at r2 cIndex)) })
	  (columnIndex this col)
	  sortOp
	)
	sorted = (sorted (toArray rows) sortAction)
  } else {
	// For now, assume the table contains only objects that have the field (column) used for sorting
	sortAction = (action
	  (function fName op r1 r2 { return (call op (getField r1 fName) (getField r2 fName)) })
	  col
	  sortOp
	)
	sorted = (sorted (toArray rows) sortAction)
  }
  return (new 'Table' columnNames (toList sorted))
}

method columnIndex Table col {
  if (isNumber col) { return (truncate col) }
  if (isClass col 'String') {
    index = (indexOf columnNames col)
	if (isNil index) {
	  error (join 'No column named ' col ' in table')
	}
	return index
  }
  return nil
}

method toString Table limit {
  if (isNil limit) { limit = 10 }
  tab = (string 9)
  cr = (newline)
  result = (list (join tab (joinStrings columnNames tab) cr))
  if ((count rows) == 0) {
	add result (join tab '(empty table)')
  } else {
	colCount = (count columnNames)
	for r (min (count rows) limit) {
	  add result (toString r)
	  add result tab
      for c colCount {
		add result (printString (cellAt this r c))
		if (c < colCount) { add result tab }
	  }
	  add result cr
	}
  }
  return (joinStrings (toArray result))
}

// Import/export

to importTableFromFile fileName hasColumnNames delimiter {
  data = (readFile fileName)
  if (and (isNil data) (not (endsWith fileName '.csv'))) {
  	data = (readFile (join fileName '.csv'))
  }
  if (isNil data) { error 'Could not read file ' fileName }
  return (importCSV (table) data hasColumnNames delimiter)
}

method importCSV Table s hasColumnNames delimiter {
  // Import string data in "comma separated value" (.csv) format, replacing any
  // current data in this table. If hasColumnNames is true (the default), the
  // first line of data provides column names. If hasColumnNames and/or delimiter
  // are not provided, attempt to guess them.

  if (isNil delimiter) {
  	delimiter = (guessDelimiter this  s)
	if (isNil delimiter) {
	  error 'Could not guess delimiter; data may not be CSV format'
	}
  }
  if (isNil hasColumnNames) {
	hasColumnNames = (guessHasColumnNames this s delimiter)
  }
  rowData = (list)
  for line (lines s) {
	gcIfNeeded
	if (',' == delimiter) {
	  row = (list)
	  item = (list)
	  inQuote = false
	  for ch (letters line) {
		if ('"' == ch) {
		  inQuote = (not inQuote)
		} else {
		  if (and (not inQuote) (delimiter == ch)) {
			add row (joinStrings item)
			item = (list)
		  } else {
			add item ch
		  }
		}
	  }
	  add row (joinStrings item)
	} else {
	  row = (splitWith line delimiter)
	}
	if ((count row) > 0) {
	  if ('' == (last row)) {
		// many CSV files contain empty final columns; remove them
		i = (count row)
		while (and (i > 0) ('' == (at row i))) { i += -1 }
		row = (copyFromTo row 1 i)
	  }
	  if ((count row) > 0) { add rowData (toArray row) }
	}
  }
  if (isEmpty rowData) { error 'no data in CSV file' }

  if hasColumnNames { columnNames = (removeFirst rowData) }
  rows = rowData
  ensureAllColumnsHaveNames this
  padRowsIfNeeded this
  autoConvertNumericColumns this
  gc
  return this
}

method guessDelimiter Table s {
  lines = (firstTenLinesFrom this s)
  if ((count lines > 5)) { lines = (copyFromTo lines 2) } // skip first ine
  for delimiter (array ',' '	' ':' '|' ' ') { // try: comma, tab, colon, pipe, space
	counts = (dictionary)
	for line lines {
	  n = 0
	  inQuotes = false
	  for ch (letters line) {
		if ('"' == ch) { inQuotes = (not inQuotes) }
		if (and (not inQuotes) (ch == delimiter)) { n += 1 }
	  }
	  add counts n
	}
	if (and ((count counts) == 1) ((first (keys counts)) > 0)) {
	  return delimiter
	}
  }
  return nil
}

method guessHasColumnNames Table s delimiter {
  // Assume that the first line of a table is the column names for the table if the
  // any column has a string in the first row and a numeric value in in the second.
  // If in doubt, consider the first line to be data.
  lines = (firstTenLinesFrom this s)
  if ((count lines) < 2) { return false }
  fields1 = (splitWith (at lines 1) delimiter)
  fields2 = (splitWith (at lines 2) delimiter)
  for i (count fields1) {
	cell1 = (at fields1 i)
	cell2 = (at fields2 i)
	if (and (not (isNumber (toNumber cell1 nil))) (isNumber (toNumber cell2 nil))) {
	  return true
	}
  }
  return false
}

method firstTenLinesFrom Table s {
  // Return a the first ten lines from the string s.
  // If s has fewer than ten lines, return as many lines as possible.
  byteCount = (byteCount s)
  i = 1
  lineCount = 0
  while (i < byteCount) {
	ch = (byteAt s i)
	if (or (ch == 10) (ch == 13)) {
	  lineCount += 1
	  if (lineCount == 10) { return (lines (substring s 1 (i - 1))) }
	  if (i < byteCount) {
		if (and (ch == 10) ((byteAt s (i + 1)) == 13)) { i += 1 } // CR-LF line ending
		if (and (ch == 13) ((byteAt s (i + 1)) == 10)) { i += 1 } // LF-CR line ending
	  }
	}
	i += 1
  }
  return (lines s) // fewer than 10 lines
}

method ensureAllColumnsHaveNames Table {
  // Ensure that columnNames is the size of the longest row and that every column has a name.

  columnCount = 0
  for r rows {
	cols = (count r)
	if (cols > columnCount) { columnCount = cols }
  }

  oldNames = columnNames
  columnNames = (newArray columnCount)
  for i columnCount {
    if (i <= (count oldNames)) {
	  atPut columnNames i (at oldNames i)
	} else {
	  atPut columnNames i (join 'C' i)
	}
  }
}

method padRowsIfNeeded Table {
  // Ensure every row has at least columnCount entries.

  columnCount = (count columnNames)
  for i (count rows) {
	row = (at rows i)
	if ((count row) < columnCount) {
	  while ((count row) < columnCount) { row = (copyWith row '') } // pad short rows with empty strings
	  atPut rows i row
	}
  }
}

method autoConvertNumericColumns Table {
  if (isEmpty this) { return }

  columnCount = (count columnNames)
  newColumnData = (newArray columnCount)
  for i columnCount {
	atPut newColumnData i (list)
  }

  for r rows {
	for i columnCount {
	  done = true // set to false if we're still converting at least one column
	  if (notNil (at newColumnData i)) {
		v = (at r i)
		if (notNil v) { v = (toNumber v nil) }
		if (isNil v) {
		  atPut newColumnData i nil // stop converting column i
		} else {
		  add (at newColumnData i) v
		  done = false
		}
	  }
	}
	if done { return } // early out if no column is all numbers
  }

  for r rows {
	for i columnCount {
	  if (notNil (at newColumnData i)) {
		atPut r i (removeFirst (at newColumnData i))
	  }
	}
  }
}

method exportCSVToFile Table fileName delimiter {
  if (or (isNil fileName) (fileName == '')) {
	fileName = (uniqueNameNotIn (listFiles) 'tableData' 'csv')
  }
  if (not (endsWith fileName '.csv')) { fileName = (join fileName '.csv') }
  data = (exportCSV this delimiter)
  writeFile fileName data
}

method exportCSV Table delimiter {
  // Return a string representing this table in "comma separated value" (.csv) format,
  // using the given delimiter. The first line will be the column names.

  if (isNil delimiter) { delimiter = ',' }
  colCount = (count columnNames)
  lines = (list)
  add lines (joinStrings columnNames delimiter)
  rowStrings = (newArray colCount)
  for r (count rows) {
	for c colCount {
	  atPut rowStrings c (toString (cellAt this r c))
	}
	add lines (joinStrings rowStrings delimiter)
  }
  return (joinStrings lines (newline))
}
// basic Morphic text handler and renderer

to stringImage aString fontName fontSize color alignment shadowColor shadowOffsetX shadowOffsetY borderX borderY bgColor minWidth minHeight flat {
  // answer a new bitmap depicting a string rendered
  // with the specified font settings and alignment
  // the bitmap's width and height resemble the exact
  // bounding box's dimensions of the rendered text
  // borderX and borderY resemble optional space around the text

  if (isNil aString) {aString = ''}
  if (aString == '') {aString = ' '}
  if (not (isClass aString 'String')) {aString = (toString aString)}
  if (isNil fontName) {fontName = 'Arial'}
  if (isNil fontSize) {fontSize = 12}
  if (isNil color) {color = (color)}
  if (isNil alignment) {alignment = 'left'}
  if (isNil shadowOffsetX) {shadowOffsetX = 0}
  if (isNil shadowColor) {
    if (shadowOffsetX != 0) {shadowColor = (color 230 230 230)}
  }
  if (isNil shadowOffsetY) {shadowOffsetY = shadowOffsetX}
  if (isNil flat) {flat = true}
  flat = true // force flat text

  if flat {
    shadowOffsetX = 0
    shadowOffsetY = 0
    shadowColor = nil
  }

  if (isNil borderX) {borderX = 0}
  if (isNil borderY) {borderY = 0}
  if (isNil bgColor) {
    if (notNil shadowColor) {
      bgColor = (copy shadowColor)
    } else {
      bgColor = (copy color)
    }
    setAlpha bgColor 0
  }

  lines = (lines aString)
  widths = (newArray (count lines))
  setFont fontName fontSize

  // determine width
  w = 0
  if (notNil minWidth) { w = minWidth }
  for i (count lines) {
    lw = (+ (stringWidth (at lines i)) (borderX * 2))
	if (lw > 4000) { lw = 4000 } // truncate really wide strings
    atPut widths i lw
    w = (max w lw)
  }

  // determine height
  lineHeight = (fontHeight)
  h = (+ (borderY * 2) ((count lines) * lineHeight))
  if (notNil minHeight) { h = (max h minHeight) }

  // create bitmap
  bm = (newBitmap (+ w (abs shadowOffsetX)) (+ h (abs shadowOffsetY)) bgColor)

  // render the shadow, if any
  if (or (shadowOffsetX != 0) (shadowOffsetY != 0)) {
    for i (count lines) {
      if (shadowOffsetX < 0) {
        offsetX = 0
      } else {
        offsetX = shadowOffsetX
      }
      if (shadowOffsetY < 0) {
        offsetY = 0
      } else {
        offsetY = shadowOffsetY
      }
      if (alignment == 'right') {
        startX = (w - (at widths i))
      } (alignment == 'center') {
        startX = (half (w - (at widths i)))
      } else {
        startX = 0
      }
      drawString bm (at lines i) shadowColor (+ startX offsetX borderX) (+ ((i - 1) * lineHeight) offsetY borderY)
    }
  }

  // render the actual text
  for i (count lines) {
    if (shadowOffsetX >= 0) {
      offsetX = 0
    } else {
      offsetX = (abs shadowOffsetX)
    }
    if (shadowOffsetY >= 0) {
      offsetY = 0
    } else {
      offsetY = (abs shadowOffsetY)
    }
    if (alignment == 'right') {
      startX = (w - (at widths i))
    } (alignment == 'center') {
      startX = (half (w - (at widths i)))
    } else {
      startX = 0
    }
    drawString bm (at lines i) color (+ startX offsetX borderX) (+ ((i - 1) * lineHeight) offsetY borderY)
  }

  return bm
}

defineClass Text morph text fontName fontSize color alignment shadowColor shadowOffsetX shadowOffsetY borderX borderY editRule bgColor isFlat minWidth minHeight caret startMark endMark codeContext scrubValue clickedForEdit cachedBM

to newText aString fontName fontSize color alignment shadowColor shadowOffsetX shadowOffsetY borderX borderY editRule bgColor flat {
  scale = (global 'scale')
  if (isNil aString) {aString = ''}
  if (isNil fontName) {fontName = 'Arial'}
  if (isNil fontSize) {fontSize = (scale * 12)}
  if (isNil color) {color = (color)}
  if (isNil alignment) {alignment = 'left'}
  if (isNil shadowOffsetX) {shadowOffsetX = 0}
  if (isNil shadowColor) {
    if (shadowOffsetX != 0) {shadowColor = (color 230 230 230)}
  }
  if (isNil shadowOffsetY) {shadowOffsetY = shadowOffsetX}
  if (isNil borderX) {borderX = 0}
  if (isNil borderY) {borderY = 0}
  if (isNil editRule) {editRule = 'static'}

  txt = (new 'Text' nil aString fontName fontSize color alignment shadowColor shadowOffsetX shadowOffsetY borderX borderY editRule bgColor flat)
  morph = (newMorph txt)
  setTransparentTouch morph true
  setMorph txt morph
  fixLayout txt
  return txt
}

method initialize Text {
  scale = (global 'scale')
  if (isNil scale) { scale = 1 }
  text = 'Text'
  fontName = 'Arial'
  fontSize = (scale * 12)
  color = (gray 0)
  alignment = 'left'
  shadowColor = nil
  shadowOffsetX = 0
  shadowOffsetY = 0
  borderX = 0
  borderY = 0
  editRule = 'static'
  minWidth = 0
  minHeight = 0
  clickedForEdit = false
  return this
}

method fieldInfo Text fieldName {
  info = (dictionary)
  if ('editRule' == fieldName) {
    atPut info 'type' 'options'
    atPut info 'options' (array 'static' 'editable' 'code' 'numerical' 'line')
    return info
  } ('alignment' == fieldName) {
    atPut info 'type' 'options'
    atPut info 'options' (array 'left' 'center' 'right')
    return info
  }
  return nil
}

method text Text {return text}

method setText Text aString {
  text = aString
  startMark = nil
  endMark = nil
  fixLayout this
  raise morph 'textEdited' this
}

method fontName Text {return fontName}
method fontSize Text {return fontSize}

method setFont Text name size {
  if (isNil name) {name = fontName}
  if (isNil size) {size = fontSize}
  if (and (name == fontName) (size == fontSize)) { return } // no change
  fontName = name
  fontSize = size
  fixLayout this
}

method color Text {return color}
method shadowColor Text {return shadowColor}
method bgColor Text {return bgColor}

method setColor Text textColor shadeColor backgroundColor {
  if (isNil textColor) {textColor = color}
  if (isNil shadeColor) {shadeColor = shadowColor}
  if (isNil backgroundColor) {backgroundColor = bgColor}
  color = textColor
  shadowColor = shadeColor
  bgColor = backgroundColor
  changed morph
}

method alignment Text {return alignment}

method align Text optionString {
  // optionString can be 'left', 'center' or 'right'
  alignment = optionString
  fixLayout this
}

method shadowOffsetX Text {return shadowOffsetX}
method shadowOffsetY Text {return shadowOffsetY}

method setShadowOffset Text x y {
  if (isNil x) {x = shadowOffsetX}
  if (isNil y) {y = shadowOffsetY}
  shadowOffsetX = x
  shadowOffsetY = y
  fixLayout this
}

method borderX Text {return borderX}
method borderY Text {return borderY}

method setBorders Text x y silently {
  if (isNil x) {x = borderX}
  if (isNil y) {y = borderY}
  borderX = x
  borderY = y
  if silently {return}
  fixLayout this
}

method editRule Text {return editRule}

method setEditRule Text string {
  // governs whether and how the text element is editable:
  // 'static' - cannot be edited
  // 'editable' - editable without restrictions (multi-line, alphanumerical)
  // 'code' - unrestricted multi-line editing with EVAL-bindings and menu
  // 'numerical' - accepts only keystrokes that can be used within a number
  // 'line' - blocks multi-line editing (which is possible by default)
  editRule = string
}

method codeContext Text {return codeContext}
method setCodeContext Text anObjectOrNil {codeContext = anObjectOrNil}
method setMinWidth Text w {minWidth = (max 0 (truncate w))}
method setMinHeight Text h {minHeight = (max 0 (truncate h))}

method drawOn Text ctx {
// 	h = (handler (owner morph))
// 	if (or (isClass h 'Block') (isClass h 'InputSlot')) {
// 		if (isNil cachedBM) {
// 			cachedBM = (newBitmap (width morph) (height morph) (color h))
// 			bmCtx = (newGraphicContextOn cachedBM)
// 			setFont bmCtx fontName fontSize // set font before getting fontHeight
// 			drawString bmCtx (first (lines text)) color 0 0
// 		}
// 		drawBitmap ctx cachedBM (left morph) (top morph)
// 		return
// 	}

  setFont ctx fontName fontSize // set font before getting fontHeight
  lineHeight = (fontHeight)
  w = ((width morph) - (2 * borderX))
  if (notNil bgColor) {
    r = (insetBy (bounds morph) borderX borderY)
    fillRect ctx bgColor (left r) (top r) (width r) (height r) 1
  }

  x = ((left morph) + borderX)
  y = ((top morph) + borderY)
  for s (lines text) {
	if (alignment == 'right') {
	  inset = (w - (stringWidth s))
	} (alignment == 'center') {
	  inset = (half (w - (stringWidth s)))
	} else {
	  inset = 0
	}
	drawString ctx s color (x + inset) y
	y += lineHeight
  }
  drawSelectionOn this ctx
}

method drawSelectionOn Text ctx {
	if ((count text) == 0) { return }
	if (or (isNil startMark) (isNil endMark)) { return }
	begin = (min startMark endMark)
	end = ((max startMark endMark) - 1)
	marked = (substring text begin end)
	lines = (lines marked)
	setFont ctx fontName fontSize
	lineHeight = (fontHeight)
	slot = begin
	for row (count lines) {
		s = (at lines row)
		pos = (relativeSlotPosition this slot)
		xPos = ((left morph) + (at pos 1))
		yPos = ((top morph) + (at pos 2))
		fillRect ctx (color 0 0 100) xPos yPos (stringWidth s) lineHeight
		drawString ctx s (gray 255) xPos yPos
		slot += ((count (at lines row)) + 1)
	}
}

method fixLayout Text {
  changed morph
  computeBounds this
  changed morph
  raise morph 'layoutChanged' this
}

method computeBounds Text {
  lines = (lines text)
  setFont fontName fontSize

  // determine width
  w = 0
  if (notNil minWidth) { w = minWidth }
  for s lines {
    lw = ((stringWidth s) + (2 * borderX))
	if (lw > 4000) { lw = 4000 } // truncate really wide strings
    w = (max w lw)
  }
  setWidth (bounds morph) w

  // determine height
  lineHeight = (fontHeight)
  h = (((count lines) * lineHeight) + (2 * borderY))
  if (notNil minHeight) { h = (max h minHeight) }
  setHeight (bounds morph) h
}

method adjustSizeToScrollFrame Text aScrollFrame {
  ca = (clientArea aScrollFrame)
  computeBounds this
  bnds = (bounds morph)
  setWidth bnds (max (width bnds) (width ca))
  setHeight bnds (max (height bnds) (height ca))
}

// events

method clicked Text hand {
  return (notNil caret)
}

method doubleClicked Text hand {
  if (isNil caret) {return false}
  selectWordAt this (slotAt this (x hand) (y hand))
  return true
}

method handDownOn Text hand {
  scrubValue = nil
  clickedForEdit = false
  if ('static' != editRule) {
    if (isNil caret) {
      clickedForEdit = true
      edit this hand
    }
    if (shiftKeyDown (keyboard (page hand))) {
      if (isNil startMark) {startMark =  (slot caret)}
      gotoSlot caret (slotAt this (x hand) (y hand))
    } else {
      pos = (max 1 (slotAt this (x hand) (y hand)))
      unmark this
      gotoSlot caret pos
      startMark = (slot caret)
    }
    if  clickedForEdit {raise morph 'clickedForEdit' this}
    return true
  }
  return false
}

method handMoveOver Text hand {
  closeUnclickedMenu (page hand) this
  if (isNil caret) {return}
  if (isNil startMark) {startMark =  (slot caret)}
  gotoSlot caret (max 1 (slotAt this (x hand) (y hand)))
}

method touchHold Text hand {
  if (notNil caret) { // edited
    if ('numerical' == editRule) {
      startScrubbing this hand
      return true
    }
    raise morph 'scrubAnyway' this
    return true
  }
  return false
}

method rightClicked Text hand {
  if (notNil caret) { // edited
    popUpAtHand (contextMenu this) (page hand) true // no focus
    return true
  }
  return false
}

method handEnter Text aHand {
  if (editRule != 'static') {
	setCursor 'text'
  }
}

method handLeave Text aHand {
  // handEnter happens before handLeave, so cursor wouldn't go back to finger
  // when you move between two buttons without any space in between. A temporary
  // solution is to re-trigger handEnter on the new morph under the hand.
  if (isNil caret) {
	setCursor 'default'
	handEnter (objectAt aHand) aHand
  }
}

// context menu

method contextMenu Text {
  menu = (menu nil this)
  if (and (editRule == 'code') ((count (selected this)) > 0)) {
    addItem menu 'do it...' 'doIt' 'execute the marked text as GP code'
    addItem menu 'print it...' 'printIt' 'insert the result of executing the marked text as GP code'
    // addItem menu 'inspect it...' 'inspectIt' 'open a window on the result of executing the marked text as GP code'
    addItem menu 'explore it...' 'exploreIt' 'open an explorer on the result of executing the marked text as GP code'
    addItem menu 'blockify it...' 'blockifyIt' 'create a graphical block representing the marked text as GP code'
    addItem menu 'definitions...' 'browseImplementors' 'lookup the implementations of the selected expression'
    addLine menu
  }
  edits = false
  if ((selected this) != '') {
    edits = true
    addItem menu 'cut' (action 'copyToClipboard' caret true)
    addItem menu 'copy' (action 'copyToClipboard' caret false)
  }
  txt = (readClipboard)
  if (txt != '') {
    edits = true
    addItem menu 'paste' (action 'insertRight' caret txt)
  }
  if edits {addLine menu}
  if ((originalContents caret) != text) {
    addItem menu 'accept' (action 'accept' caret)
    addItem menu 'revert' (action 'cancel' caret)
  } else {
    addItem menu 'stop editing' 'stopEditing'
  }
  addItem menu 'select all' 'selectAll'
  if (isClass (handler (owner morph)) 'InputSlot') {
	addLine menu
	addSlotSwitchItems (handler (owner morph)) menu
  }
  return menu
}

// editing

method edit Text hand keepFocus {
  root = (handler (root morph))
  if (isClass root 'Page') {edit (keyboard root) this (slotAt this (x hand) (y hand)) keepFocus}
  setCursor 'text'
}

method stopEditing Text {
  unmark this
  root = (handler (root morph))
  if (isClass root 'Page') {stopEditing (keyboard root) this}
  setCursor 'default'
}

// measuring

method extent Text aFontSize xBorder yBorder {
  // answer a rectangle describing the area actually used by the text
  // at a hypothetical fontsize and border coordinates
  if (isNil aFontSize) {aFontSize = fontSize}
  if (isNil xBorder) {xBorder = borderX}
  if (isNil yBorder) {yBorder = borderY}
  w = 0
  lines = (lines text)
  setFont fontName aFontSize
  lineHeight = (fontHeight)
  for line lines {
    w = (max w (stringWidth line))
  }
  return (rect (left morph) (top morph) (w + (xBorder * 2)) (((count lines) * lineHeight) + (yBorder * 2)))
}

method columnRow Text slot {
  // answer the logical position of the given index ("slot")
  if (slot == 1) {return (array 1 1)}
  idx = 1
  lines = (lines text)
  for row (count lines) {
    for col (count (at lines row)) {
      if (idx == slot) {return (array col row)}
      idx += 1
    }
    if (isNil col) {col = 0}
    if (idx == slot) {return (array (col + 1) row)}
    idx += 1
  }
  return (array (+ 1 (count (at lines (count lines)))) (count lines))
}

method slotPosition Text slot {
  // answer a two-element array representing the physical coordinates of the given
  // index ("slot"), where the caret should be placed
  relative = (relativeSlotPosition this slot)
  return (array (+ (left morph) (at relative 1)) (+ (top morph) (at relative 2)))
}

method relativeSlotPosition Text slot {
  // answer a two-element array representing the physical coordinates of the given
  // index ("slot") relative to the morph's origin
  lines = (lines text)
  if ((count lines) == 0) {return (array borderX borderY)}
  colRow = (columnRow this slot)
  col = (at colRow 1)
  row = (at colRow 2)
  setFont fontName fontSize
  lineHeight = (fontHeight)
  indent = 0
  extent = (extent this)
  if (alignment == 'center') {
    indent = (half (((width extent) - (borderX * 2)) - (stringWidth (at lines row))))
  } (alignment == 'right') {
    indent = (((width extent) - (borderX * 2)) - (stringWidth (at lines row)))
  }
  if ((count (at lines row)) == 0) {
    xOffset = (+ borderX indent)
  } else {
    xOffset = (+ (stringWidth (substring (at lines row) 1 (col - 1))) borderX indent)
  }
  yOffset = (((row - 1) * lineHeight) + borderY)
  return (array xOffset yOffset)
}

method slotAt Text x y {
  // answer the slot (index) closest to the given coordinates
  // so the caret can be moved accordingly
  slot = 0
  lines = (lines text)
  setFont fontName fontSize
  lineHeight = (fontHeight)

  row = 0
  lineY = (+ (top morph) borderY)
  while (and (lineY < y) (row <= (count lines))) {
    if (row > 0) {slot += (+ 1 (count (at lines row)))}
    row += 1
    lineY = (+ (top morph) borderY (row * lineHeight))
  }
  row = (max 1 (min row (count lines)))
  line = (at lines row)
  col = 0
  indent = 0
  if (alignment == 'center') {
    indent = (half ((width morph) - (stringWidth line)))
  } (alignment == 'right') {
    indent = ((width morph) - (stringWidth line))
  }
  lineX = (+ (left morph) borderX indent)
  while (lineX < x) {
    slot += 1
    col += 1
    if (col > (count line)) {return (min slot ((count text) + 1))}
    lineX = (+ (left morph) borderX indent (stringWidth (substring line 1 col)))
  }
  return (min slot ((count text) + 1))
}

// marking

method startMark Text {return startMark}
method endMark Text {return endMark}
method setStartMark Text aSlotOrNil {startMark = aSlotOrNil}
method setEndMark Text aSlotOrNil {endMark = aSlotOrNil}
method caret Text {return caret}
method setCaret Text caretOrNil {caret = caretOrNil}

method selected Text {
  if (or (isNil startMark) (isNil endMark)) {return ''}
  begin = (min startMark endMark)
  end = ((max startMark endMark) - 1)
  return (substring text begin end)
}

method unmark Text {
  if (notNil startMark) {
    startMark = nil
    endMark = nil
    changed morph
  }
}

method selectAll Text {
  startMark = 1
  endMark = ((count text) + 1)
  changed morph
}

method selectWordAt Text slot {
  letters = (letters text)
  while (and (slot > 1) (not (isWhiteSpace (at letters (min (slot - 1) (count letters)))))) {slot += -1}
  startMark = slot
  slot += 1
  while (and (slot <= (count text)) (not (isWhiteSpace (at letters slot)))) {slot += 1}
  slot = (min slot ((count text) + 1))
  endMark = slot
  changed morph
}

// evaluating

method doIt Text {
  page = (handler (root morph))
  expr = (selected this)
  unmark this
  editor = (findProjectEditor)
  mod = nil
  if (notNil editor) {
    mod = (module (project editor))
  }
  launch page (newReporter 'eval' expr codeContext mod)
}

method printIt Text {
  page = (handler (root morph))
  expr = (selected this)
  mod = nil
  editor = (findProjectEditor)
  if (notNil editor) {
    mod = (module (project editor))
  }
  launch page (newReporter 'eval' expr codeContext mod) nil (action 'printResult' this)
}

method printResult Text result {
  if (isNil caret) {
    page = (handler (root morph))
    edit (keyboard page) this 1
	selectAll this
  }
  gotoSlot caret (max startMark endMark)
  startMark = nil
  start = (slot caret)
  insertRight caret (join ' ' (printString result))
  startMark = start
  endMark = (slot caret)
  fixLayout this
}

method inspectIt Text {
  page = (handler (root morph))
  expr = (selected this)
  mod = nil
  editor = (findProjectEditor)
  if (notNil editor) {
    mod = (module (project editor))
  }
  launch page (newReporter 'eval' expr codeContext mod) nil (action 'inspectResult' this)
}

method exploreIt Text {
  page = (handler (root morph))
  expr = (selected this)
  mod = nil
  editor = (findProjectEditor)
  if (notNil editor) {
    mod = (module (project editor))
  }
  launch page (newReporter 'eval' expr codeContext mod) nil (action 'exploreResult' this)
}

method inspectResult Text result {
  page = (handler (root morph))
  ins = (inspectorOn result)
  setPosition (morph ins) (x (hand page)) (y (hand page))
  addPart page ins
  keepWithin (morph ins) (bounds (morph page))
  stopEditing this
}

method exploreResult Text result {
  page = (handler (root morph))
  ins = (explorerOn result)
  setPosition (morph ins) (x (hand page)) (y (hand page))
  addPart page ins
  keepWithin (morph ins) (bounds (morph page))
  stopEditing this
}

method blockifyIt Text {
  parsed = (parse (selected this))
  if (isEmpty parsed) {return}
  element = (at parsed 1)
  if (isAnyClass element 'Command' 'Reporter') {
    stopEditing this
    page = (handler (root morph))
	if (and (isClass element 'Reporter') (isControlStructure element)) {
	  element = (toCommand element)
	}
    block = (toBlock element)
    setPosition (morph block) (x (hand page)) (y (hand page))
    addPart page block
    keepWithin (morph block) (bounds (morph page))
  }
}

method browseImplementors Text {
  name = (selected this)
  implementors = (implementors name)
  menu = (menu (join 'implementations of' (newline) name) (action 'openClassBrowser' this name) true) // reverse call
  for each implementors {
    addItem menu (join each '...') each
  }
  popUpAtHand menu (global 'page')
}

method openClassBrowser Text functionName aClassName {
  browseClass aClassName functionName
}

// scrubbing

method startScrubbing Text hand {
  if (isNil hand) {hand = (hand (page morph))}
  stopEditing this
  scrubValue = (toNumber text)
  focusOn hand this
}

method handUpOn Text hand {
  if (notNil scrubValue) {
    changed = (scrubValue != (toNumber text))
    scrubValue = nil
    if changed { return true }
  }
  return false
}

method handMoveFocus Text hand {
  if (notNil scrubValue) {scrub this hand}
}

method scrub Text hand {
  stopEditing this

  // scrub delta is vertical distance (positive or negative) from center
  delta = (truncate (((vCenter (bounds morph)) - (y hand)) / (3 * (global 'scale'))))
  setText this (toString (scrubValue + delta))
  raise morph 'textChanged' this
}

// Line wrapping
// Note: This is a hack. CR characters are used to mark soft line wraps.
// Before the text is reflowed, the newlines are removed.

method wrapLinesToWidth Text wrapWidth {
  newline = (newline)
  cr = (cr)
  result = (list)
  lines = (lines (contentsWithoutCRs this))
  if (and ((count lines) > 0) ((count (last lines)) == 0)) {
	// if the last line is empty, remove it
	lines = (copyArray lines ((count lines) - 1))
  }
  setFont fontName fontSize
  for line lines {
	remaining = line
	while (remaining != '') {
	  end = (findLineBreak this remaining wrapWidth)
	  add result (substring remaining 1 end)
	  remaining = (substring remaining (end + 1))
	  if (remaining != '') {
		add result cr // soft line break
	  }
	}
	add result newline // hard line break
  }
  setText this ''
  setText this (joinStringArray (toArray result))
}

method contentsWithoutCRs Text {
  // Return my contents without CR characters (soft line breaks).
  cr = (cr)
  result = (list)
  for ch (letters text) {
	if (ch != cr) { add result ch }
  }
  return (joinStringArray (toArray result))
}

method findLineBreak Text s wrapWidth {
  len = (count s)
  if (len < 2) { return len }

  w = (stringWidth s)
  if (w < wrapWidth) { return len }

  avgLetterWidth = (w / len)
  initializeGuess = (max (truncate (wrapWidth / avgLetterWidth)) 1)
  i = (wordEndAfter this s initializeGuess)

  // find the end of the first word beyond wrapWidth
  while (and (i < len) ((stringWidth (substring s 1 i)) < wrapWidth)) {
  	i = (wordEndAfter this s (i + 1))
  }

  // back up by words until the line fits
  i = (wordEndBefore this s i)
  while (and (i > 1) ((stringWidth (substring s 1 i)) > wrapWidth)) {
  	i = (wordEndBefore this s i)
  }

  if (i == 1) { // no word break before wrapWidth, break the word
	while (and (i < len) ((stringWidth (substring s 1 i)) < wrapWidth)) {
	  i += 1
	}
  }

  // skip whitespace (leave terminating whitespace at end of line)
  space = 32
  while (and (i < len) ((byteAt s (i + 1)) <= space)) {
  	i += 1
  }

  return i
}

method wordEndAfter Text s i {
  space = 32
  len = (count s)
  // skip whitespace
  while (and (i < len) ((byteAt s i) <= space)) {
  	i += 1
  }
  // find word end
  while (and (i < len) ((byteAt s (i + 1)) > space)) {
  	i += 1
  }
  return i
}

method wordEndBefore Text s i {
  space = 32
  // skip whitespace
  while (and (i > 1) ((byteAt s i) <= space)) {
  	i += -1
  }
  // find word start
  while (and (i > 1) ((byteAt s i) > space)) {
  	i += -1
  }
  // find end of the previous word
  while (and (i > 1) ((byteAt s i) > space)) {
  	i += -1
  }
  return i
}

// HTML export

method toHTML Text {
  // Experimental. Return an absolute-positioned HTML <p> element representing this text.
  scale = (global 'scale')
  fontColor = (toStringBase16 (pixelRGB color))
  tag = (format '<p style="left:%px;top:%px;font-family:''%'';font-size:%px;color:#%;position:absolute;margin:0px">'
	(truncate ((left morph) / scale)) (truncate ((top morph) / scale)) fontName (truncate (fontSize / scale)) fontColor)
  return (join tag text '</p>')
}
defineClass TextEditorLine contents lineStart

method contents TextEditorLine { return contents }
method lineStart TextEditorLine { return lineStart }
method setLineStart TextEditorLine n { lineStart = n }

to newTextEditorLine aString lineStart {
  return (new 'TextEditorLine' aString lineStart)
}

defineClass TextEditor morph slider fontName fontSize lines wrapCache firstWrapLine firstLine desiredWidth selStart selEnd selAnchor

// openPage
// ed = (testEditor)

to testEditor {
  ed = (newTextEditor 'Hello, World!')
  addPart (global 'page') (morph ed)
  setGutenburgText ed (readFile '20000Leagues.txt')
  return ed
}

method lines TextEditor { return lines } // debugging

method checkLines TextEditor {
  pos = 0
  for i (count lines) {
	line = (at lines i)
	if (pos != (lineStart line)) {
	  error 'Mismatch at:' i ';' pos '!=' (lineStart line)
	}
	pos += ((count (contents line)) + 1)
	i += 1
  }
  return 'okay'
}

// To do:
// [x] support changing window size (reflow, change slider height, redraw, etc.)
// [ ] maintain approx. scroll position when changing window width
// [ ] selection: set, get, draw, get selection contents
// [ ] editing operations: insert text, delete seletion, cut/copy/paste

to newTextEditor aString {
  result = (initialize (new 'TextEditor'))
  if (notNil aString) { setText result aString }
  return result
}

method initialize TextEditor {
  morph = (newMorph this)
  setGrabRule (morph this) 'ignore'
  slider = (slider 'vertical')
  setAction slider (action 'setScroll' this)
  addPart morph (morph slider)
  fontName = 'Arial'
  fontSize = (14 * (global 'scale'))
  lines = (list)
  wrapCache = (list)
  firstWrapLine = 1
  firstLine = 1
  desiredWidth = nil
  setSelection this 0
  setExtent (morph this) 600 800
  return this
}

method fontName TextEditor { return fontName }
method fontSize TextEditor { return (fontSize / (global 'scale')) }

method setFontAndSize TextEditor newName newSize {
  if (notNil newName) { fontName = newName }
  if (notNil newSize) { fontSize = (newSize * (global 'scale')) }
  desiredWidth = nil
  redraw this
}

method text TextEditor {
  result = (list)
  for line lines {
	s = (contents line)
	add result s
  }
  return (joinStringArray (toArray result) (newline))
}

method setText TextEditor aString {
  lines = (list)
  pos = 0
  lastLine = nil
  for s (lines aString) {
	add lines (newTextEditorLine s pos)
	lastLine = s
	pos += ((count s) + 1)
  }
  if (and (notNil lastLine) ((count lastLine) == 0)) {
	finalChar = (substring aString ((count aString) - 1))
	if (or (finalChar == (newline)) (finalChar == (cr)))  {
	  removeLast lines
	}
  }
  redraw this
}

method setGutenburgText TextEditor aString {
  // Load a plain-text book in which argraph breaks are indicated by a blank line.
  lines = (list)
  paragraph = (list)
  pos = 0
  for s (lines aString) {
	if (isEmpty s) {
	  if (not (isEmpty paragraph)) {
		paraString = (joinStrings paragraph ' ')
		add lines (newTextEditorLine paraString pos)
		pos += ((count paraString) + 1)
		add lines (newTextEditorLine '' pos) // blank line
		pos += 1
		paragraph = (list)
	  }
	} else {
	  add paragraph s
	}
  }
  if (not (isEmpty paragraph)) { // add final line
	paraString = (joinStrings paragraph ' ')
	add lines (newTextEditorLine paraString pos)
  }
checkLines this // xxx
  desiredWidth = nil
  redraw this
}

// Drawing

method redraw TextEditor {
  scale = (global 'scale')
  bgColor = (gray 255)
  selectionColor = (color 178 216 250)
  textColor = (gray 0)
  setFont fontName fontSize
  descent = (fontDescent)

  fixLayout this
  bm = (costumeData morph)
  if (or (isNil bm) ((width bm) != (width morph)) ((width bm) != (width morph))) {
	bm = (newBitmap (width morph) (height morph))
  }
  fill bm bgColor

  x = (15 * scale)
  y = (15 * scale)
  i = 1
  end = (count wrapCache)
  h = (height morph)
  while (and (i <= end) (y < h)) {
	line = (at wrapCache i)
	lineText = (contents line)
	lineStart = (lineStart line)
	lineEnd = (+ lineStart (count lineText) -1)
//	if (not (endsParagraph line)) { lineEnd += -1 }

	// show selection, if visible
	if (not (or (lineEnd < selStart) (lineStart > selEnd))) {
	  left = (x - (5 * scale))
	  right = ((width bm) - ((10 * scale) + (width (morph slider))))
	  if (selStart > lineStart) {
		setFont fontName fontSize
		left = (x + (stringWidth (substring lineText 1 (selStart - lineStart))))
	  }
	  if (selEnd <= lineEnd) {
		setFont fontName fontSize
		right = (x + (stringWidth (substring lineText 1 (selEnd - lineStart))))
	  }
	  fillRect bm selectionColor left (y + descent) (right - left) fontSize
	}

	setFont fontName fontSize
	drawString bm lineText textColor x y
	y += fontSize
	i += 1
  }
print 'displayed' (i - 1) 'lines; wrapcache size:' (count wrapCache)
  setCostume morph bm
}

// Layout

method fixLayout TextEditor {
  bnds = (bounds morph)

  // update slider bounds
  setPosition (morph slider) ((right bnds) - (width (morph slider))) (top bnds)
  setHeight (bounds (morph slider)) (height bnds)
  redraw slider // update slider appearance in case rewrapping takes a while

return // xxx

  // rewrap text, if necessary
  rewrap this

  // update slider after wrapping
  linesInView = (truncate ((height morph) / fontSize))
  if (isEmpty lines) {
	scrollPercent = 0
	percentVisible = 100
  } else {
	srollableLines = (max 1 ((count lines) - 5))
	scrollPercent = (clamp ((100 * firstLine) / srollableLines) 0 100)
	percentVisible = (clamp ((100 * linesInView) / (count lines)) 0 100)
  }
  setSize slider percentVisible
  setValue slider scrollPercent
}

// Scrolling

method setScroll TextEditor n {
  lineCount = (count lines)
  firstLine = (clamp ((n * lineCount) / 100) 1 (max 1 (lineCount - 5)))
  redraw this
}

method swipe TextEditor x y {
  firstLine = (max 1 (firstLine - (y / 3)))
  redraw this
  return true
}

// Selection

method handDownOn TextEditor aHand {
  focusOn aHand this
  selAnchor = (characterIndexForXY this (x aHand) (y aHand))
  handMoveFocus this aHand
  return true
}

method handMoveFocus TextEditor aHand {
  oldStart = selStart
  oldEnd = selEnd
  i = (characterIndexForXY this (x aHand) (y aHand))
  setSelection this selAnchor i
  if (or (selStart != oldStart) (selEnd != oldEnd)) {
	redraw this
  }
}

method characterIndexForXY TextEditor x y {
  // Return the character index for the given global position.

  scale = (global 'scale')
  localXY = (normal morph x y)
  x = (round ((first localXY) + ((normalWidth morph) / 2)))
  y = (round ((last localXY) + ((normalHeight morph) / 2)))
  x = (clamp x 0 (normalWidth morph))
  y = (clamp y 0 (normalHeight morph))
  lineOffset = (truncate ((y - (15 * scale)) / fontSize))
  lineIndex = (clamp ((round firstLine) + lineOffset) 1 (count lines))
  line = (at lines lineIndex)
  s = (contents line)
  for inset (count s) {
	setFont fontName fontSize
	endX = ((15 * scale) + (stringWidth (substring s 1 inset)))
	if (endX > x) { return (+ (lineStart line) inset -1) }
  }
  result = ((lineStart line) + (count s))
  if (not (endsParagraph line)) { result += -1 }
  return result
}

method setSelection TextEditor start end {
  if (isNil end) { end = start }
  selStart = (min start end)
  selEnd = (max start end)
}

// Line wrapping

method rewrap TextEditor {
  scale = (global 'scale')
  leftMargin = (15 * scale)
  rightMargin = ((15 * scale) + (width (morph slider)))
  currentWrapWidth = desiredWidth
  desiredWidth = ((width morph) - (leftMargin + rightMargin))
  if (desiredWidth == currentWrapWidth) { return }
  pos = 0
  newLines = (list)
  para = (list)
  for line lines {
	add para (contents line)
	if (endsParagraph line) {
	  s = (joinStrings para)
	  addAll newLines (splitParagraph this s pos)
	  pos += ((count s) + 1)
	  removeAll para
	  gcIfNeeded
	}
  }
  lines = newLines
}

method fillWrapCache TextEditor startLine {
  if (isNil startLine) { startLine = 1 }
  scale = (global 'scale')
  leftMargin = (15 * scale)
  rightMargin = ((15 * scale) + (width (morph slider)))
  desiredWidth = ((width morph) - (leftMargin + rightMargin))
  minLines = (ceiling ((height morph) / fontSize))
  wrapCache = (list)
  for i (range startLine (count lines)) {
	line = (at lines i)
	addAll wrapCache (splitParagraph this (contents line) (lineStart line))
	if ((count wrapCache) >= minLines) {
print i 'wrapCache lines:' (count wrapCache) 'min:' minLines
	  return // we have enough lines to display
	}
  }
}

method splitParagraph TextEditor s pos {
  result = (list)
  i = 1
  while true {
	i = (findBreakIndex this s i)
	if (i < (count s)) {
	  add result (newTextEditorLine (substring s 1 i) pos)
	  pos += i
	  s = (substring s (i + 1))
	} else {
	  add result (newTextEditorLine s pos)
	  return result
	}
  }
}

method findBreakIndex TextEditor s guess {
  // Return the index i at which to break s such that (substring 1 i) <= desiredWidth.
  // Try to break at a whitespace character, but break in the middle of a word if necessary.
  // Details: Scan forward from guess to first whitespace after the desired width,
  // then scan backward to find a whitespace such such that the entire string up to
  // that break is less than the desired width.

  if (isEmpty s) { return 0 }

  letters = (letters s)
  end = (count letters)
  i = (min guess end)
  w = -1

  while (w < desiredWidth) {
	while (and (i < end) ((at letters i) > ' ')) { i += 1 } // find start of next whitespace
	setFont fontName fontSize
	w = (stringWidth (substring s 1 (i - 1)))
	if (i >= end) {
	  if (w <= desiredWidth) { return end } // entire line fits
	  w = (desiredWidth + 1) // exit this loop
	}
	if (w < desiredWidth) {
	  while (and (i < end) ((at letters i) <= ' ')) { i += 1 } // skip whitespace
	}
  }

  while true {
	while (and (i > 0) ((at letters i) > ' ')) { i += -1 } // find previous whitespace

	if (i == 0) { // no previous whitespace found; fit as many letters as possible (but at least 1)
	  return (breakWord this s)
	}

	possibleEnd = i // includes trailing white space
	while (and (i > 0) ((at letters i) <= ' ')) { i += -1 } // find start of whitespace
	setFont fontName fontSize
	w = (stringWidth (substring s 1 i))
	if (w < desiredWidth) { return possibleEnd }
  }
}

method breakWord TextEditor s {
  end = (count s)
  for i (end - 1) {
	setFont fontName fontSize
	w = (stringWidth (substring s 1 (i + 1)))
	if (w > desiredWidth) { return i }
  }
  return end
}
defineClass TextEditorLine1 contents endsParagraph lineStart

method contents TextEditorLine1 { return contents }
method endsParagraph TextEditorLine1 { return endsParagraph }
method lineStart TextEditorLine1 { return lineStart }
method setLineStart TextEditorLine1 n { lineStart = n }

to newTextEditorLine1 aString endsParagraph lineStart {
  return (new 'TextEditorLine1' aString endsParagraph lineStart)
}

defineClass TextEditor1 morph slider fontName fontSize lines firstLine desiredWidth selStart selEnd selAnchor

// openPage
// ed = (testEditor1)

to testEditor1 {
  ed = (newTextEditor1 'Hello, World!')
  addPart (global 'page') (morph ed)
  setGutenburgText ed (readFile '20000Leagues.txt')
  return ed
}

method checkLines TextEditor1 {
  i = 1
  pos = 0
  for line lines {
	if (pos != (lineStart line)) {
	  error 'Mismatch at:' i ';' pos '!=' (lineStart line)
	}
	pos += (count (contents line))
	if (endsParagraph line) { pos += 1 }
	i += 1
  }
}

// To do:
// [x] support changing window size (reflow, change slider height, redraw, etc.)
// [ ] maintain approx. scroll position when changing window width
// [ ] selection: set, get, draw, get selection contents
// [ ] editing operations: insert text, delete seletion, cut/copy/paste

to newTextEditor1 aString {
  result = (initialize (new 'TextEditor1'))
  if (notNil aString) { setText result aString }
  return result
}

method initialize TextEditor1 {
  morph = (newMorph this)
  setGrabRule (morph this) 'ignore'
  slider = (slider 'vertical')
  setAction slider (action 'setScroll' this)
  addPart morph (morph slider)
  fontName = 'Arial'
  fontSize = (14 * (global 'scale'))
  lines = (list)
  firstLine = 1
  desiredWidth = nil
  setSelection this 0
  setExtent (morph this) 600 800
  return this
}

method fontName TextEditor1 { return fontName }
method fontSize TextEditor1 { return (fontSize / (global 'scale')) }

method setFontAndSize TextEditor1 newName newSize {
  if (notNil newName) { fontName = newName }
  if (notNil newSize) { fontSize = (newSize * (global 'scale')) }
  desiredWidth = nil
  redraw this
}

method text TextEditor1 {
  newline = (newline)
  result = (list)
  for line lines {
	s = (contents line)
	add result s
	if (endsParagraph line) {
	  add result newline
	}
  }
  return (joinStringArray (toArray result))
}

method setText TextEditor1 aString {
  lines = (list)
  pos = 0
  for s (lines aString) {
	add lines (newTextEditorLine1 s true pos)
	pos += ((count s) + 1)
  }
  finalChar = (substring aString ((count aString) - 1))
  if ((count aString) > 0) {
	removeLast lines
  }
  desiredWidth = nil
  redraw this
}

method setGutenburgText TextEditor1 aString {
  // Load a plain-text book in which argraph breaks are indicated by a blank line.
  lines = (list)
  paragraph = (list)
  pos = 0
  for s (lines aString) {
	if (isEmpty s) {
	  if (not (isEmpty paragraph)) {
		paraString = (joinStrings paragraph ' ')
		add lines (newTextEditorLine1 paraString true pos)
		pos += ((count paraString) + 1)
		add lines (newTextEditorLine1 '' true pos) // blank line
		pos += 1
		paragraph = (list)
	  }
	} else {
	  add paragraph s
	}
  }
  if (not (isEmpty paragraph)) { // add final line
	paraString = (joinStrings paragraph ' ')
	add lines (newTextEditorLine1 paraString true pos)
  }
checkLines this // xxx
  desiredWidth = nil
  redraw this
}

// Drawing

method redraw TextEditor1 {
  scale = (global 'scale')
  bgColor = (gray 255)
  selectionColor = (color 178 216 250)
  textColor = (gray 0)
  setFont fontName fontSize
  descent = (fontDescent)

  fixLayout this
  bm = (costumeData morph)
  if (or (isNil bm) ((width bm) != (width morph)) ((width bm) != (width morph))) {
	bm = (newBitmap (width morph) (height morph))
  }
  fill bm bgColor

  x = (15 * scale)
  y = (15 * scale)
  i = (max 1 (round firstLine))
  end = (count lines)
  h = (height morph)
  while (and (i <= end) (y < h)) {
	line = (at lines i)
	lineText = (contents line)
	lineStart = (lineStart line)
	lineEnd = (lineStart + (count lineText))
	if (not (endsParagraph line)) { lineEnd += -1 }

	// show selection, if visible
	if (not (or (lineEnd < selStart) (lineStart > selEnd))) {
	  left = (x - (5 * scale))
	  right = ((width bm) - ((10 * scale) + (width (morph slider))))
	  if (selStart > lineStart) {
		setFont fontName fontSize
		left = (x + (stringWidth (substring lineText 1 (selStart - lineStart))))
	  }
	  if (selEnd <= lineEnd) {
		setFont fontName fontSize
		right = (x + (stringWidth (substring lineText 1 (selEnd - lineStart))))
	  }
	  fillRect bm selectionColor left (y + descent) (right - left) fontSize
	}

	setFont fontName fontSize
	drawString bm lineText textColor x y
	y += fontSize
	i += 1
  }
  setCostume morph bm
}

// Layout

method fixLayout TextEditor1 {
  bnds = (bounds morph)

  // update slider bounds
  setPosition (morph slider) ((right bnds) - (width (morph slider))) (top bnds)
  setHeight (bounds (morph slider)) (height bnds)
  redraw slider // update slider appearance in case rewrapping takes a while

  // rewrap text, if necessary
  rewrap this

  // update slider after wrapping
  linesInView = (truncate ((height morph) / fontSize))
  if (isEmpty lines) {
	scrollPercent = 0
	percentVisible = 100
  } else {
	srollableLines = (max 1 ((count lines) - 5))
	scrollPercent = (clamp ((100 * firstLine) / srollableLines) 0 100)
	percentVisible = (clamp ((100 * linesInView) / (count lines)) 0 100)
  }
  setSize slider percentVisible
  setValue slider scrollPercent
}

// Scrolling

method setScroll TextEditor1 n {
  lineCount = (count lines)
  firstLine = (clamp ((n * lineCount) / 100) 1 (max 1 (lineCount - 5)))
  redraw this
}

method swipe TextEditor1 x y {
  firstLine = (max 1 (firstLine - (y / 3)))
  redraw this
  return true
}

// Selection

method handDownOn TextEditor1 aHand {
  focusOn aHand this
  selAnchor = (characterIndexForXY this (x aHand) (y aHand))
  handMoveFocus this aHand
  return true
}

method handMoveFocus TextEditor1 aHand {
  oldStart = selStart
  oldEnd = selEnd
  i = (characterIndexForXY this (x aHand) (y aHand))
  setSelection this selAnchor i
  if (or (selStart != oldStart) (selEnd != oldEnd)) {
	redraw this
  }
}

method characterIndexForXY TextEditor1 x y {
  // Return the character index for the given global position.

  scale = (global 'scale')
  localXY = (normal morph x y)
  x = (round ((first localXY) + ((normalWidth morph) / 2)))
  y = (round ((last localXY) + ((normalHeight morph) / 2)))
  x = (clamp x 0 (normalWidth morph))
  y = (clamp y 0 (normalHeight morph))
  lineOffset = (truncate ((y - (15 * scale)) / fontSize))
  lineIndex = (clamp ((round firstLine) + lineOffset) 1 (count lines))
  line = (at lines lineIndex)
  s = (contents line)
  for inset (count s) {
	setFont fontName fontSize
	endX = ((15 * scale) + (stringWidth (substring s 1 inset)))
	if (endX > x) { return (+ (lineStart line) inset -1) }
  }
  result = ((lineStart line) + (count s))
  if (not (endsParagraph line)) { result += -1 }
  return result
}

method setSelection TextEditor1 start end {
  if (isNil end) { end = start }
  selStart = (min start end)
  selEnd = (max start end)
}

// Line wrapping

method rewrap TextEditor1 {
  scale = (global 'scale')
  leftMargin = (15 * scale)
  rightMargin = ((15 * scale) + (width (morph slider)))
  currentWrapWidth = desiredWidth
  desiredWidth = ((width morph) - (leftMargin + rightMargin))
  if (desiredWidth == currentWrapWidth) { return }
  pos = 0
  newLines = (list)
  para = (list)
  for line lines {
	add para (contents line)
	if (endsParagraph line) {
	  s = (joinStrings para)
	  addAll newLines (splitParagraph this s pos)
	  pos += ((count s) + 1)
	  removeAll para
	  gcIfNeeded
	}
  }
  lines = newLines
}

method splitParagraph TextEditor1 s pos {
  result = (list)
  i = 1
  while true {
	i = (findBreakIndex this s i)
	if (i < (count s)) {
	  add result (newTextEditorLine1 (substring s 1 i) false pos)
	  pos += i
	  s = (substring s (i + 1))
	} else {
	  add result (newTextEditorLine1 s true pos)
	  return result
	}
  }
}

method findBreakIndex TextEditor1 s guess {
  // Return the index i at which to break s such that (substring 1 i) <= desiredWidth.
  // Try to break at a whitespace character, but break in the middle of a word if necessary.
  // Details: Scan forward from guess to first whitespace after the desired width,
  // then scan backward to find a whitespace such such that the entire string up to
  // that break is less than the desired width.

  if (isEmpty s) { return 0 }

  letters = (letters s)
  end = (count letters)
  i = (min guess end)
  w = -1

  while (w < desiredWidth) {
	while (and (i < end) ((at letters i) > ' ')) { i += 1 } // find start of next whitespace
	setFont fontName fontSize
	w = (stringWidth (substring s 1 (i - 1)))
	if (i >= end) {
	  if (w <= desiredWidth) { return end } // entire line fits
	  w = (desiredWidth + 1) // exit this loop
	}
	if (w < desiredWidth) {
	  while (and (i < end) ((at letters i) <= ' ')) { i += 1 } // skip whitespace
	}
  }

  while true {
	while (and (i > 0) ((at letters i) > ' ')) { i += -1 } // find previous whitespace

	if (i == 0) { // no previous whitespace found; fit as many letters as possible (but at least 1)
	  return (breakWord this s)
	}

	possibleEnd = i // includes trailing white space
	while (and (i > 0) ((at letters i) <= ' ')) { i += -1 } // find start of whitespace
	setFont fontName fontSize
	w = (stringWidth (substring s 1 i))
	if (w < desiredWidth) { return possibleEnd }
  }
}

method breakWord TextEditor1 s {
  end = (count s)
  for i (end - 1) {
	setFont fontName fontSize
	w = (stringWidth (substring s 1 (i + 1)))
	if (w > desiredWidth) { return i }
  }
  return end
}
defineClass Timer start splitStart

to newTimer { return (new 'Timer' (time) (time)) }

method reset Timer {
  start = (time)
  splitStart = start
}

method secs Timer {
  now = (time)
  return ((at now 1) - (at start 1))
}

method msecs Timer {
  now = (time)
  secs = ((at now 1) - (at start 1))
  usecs = ((at now 2) - (at start 2))
  return ((1000 * secs) + (truncate (usecs / 1000)))
}

method usecs Timer {
  now = (time)
  secs = ((at now 1) - (at start 1))
  usecs = ((at now 2) - (at start 2))
  return ((1000000 * secs) + usecs)
}

method usecSplit Timer {
  // A 'split' allows a single timer to measure and report the time for
  // subparts of while also keeping track of the total time.
  now = (time)
  secs = ((at now 1) - (at splitStart 1))
  usecs = ((at now 2) - (at splitStart 2))
  splitStart = (time)
  return ((1000000 * secs) + usecs)
}

method msecSplit Timer { return (truncate ((usecSplit this) / 1000)) }

to usecsToRun f args... {
  args = (newArray ((argCount) - 1))
  for i ((argCount) - 1) {
    atPut args i (arg (i + 1))
  }
  t = (newTimer)
  callWith f args
  return (usecs t)
}

to secsSinceMidnight useGMT {
    return ((at (time (useGMT != true)) 1) % (24 * (60 * 60)))
}

to hour useGMT   { return (truncate ((secsSinceMidnight useGMT) / (60 * 60))) }
to minute useGMT { return (truncate (((secsSinceMidnight useGMT) % (60 * 60)) / 60)) }
to second useGMT { return ((secsSinceMidnight useGMT) % 60) }
// morphic toggle handlers, used for radio buttons and list items

defineClass Toggle morph trigger query transitionSelector

method setData Toggle obj {setData trigger obj}
method data Toggle {return (data trigger)}

method refresh Toggle {
  if (call query) {
    highlight trigger
  } else {
    normal trigger
  }
}

method isOn Toggle {return (call query)}

method handDownOn Toggle aHand {
  if (transitionSelector == 'handDownOn') {handDownOn trigger aHand}
  return true
}

method handEnter Toggle aHand {
  setCursor 'pointer'
  if (transitionSelector == 'handEnter') {
    if (and (not (isDown aHand)) (not (isOn this))) {
      handDownOn trigger aHand
      raise morph 'highlightOn' this
    }
  }
  if (notNil (hint trigger)) {
    addSchedule (global 'page') (schedule (action 'showTooltip' morph (hint trigger)) 300)
  }
}

method handLeave Toggle aHand {
  setCursor 'default'
  // handEnter happens before handLeave, so cursor wouldn't go back to finger
  // when you move between two buttons without any space in between. A temporary
  // solution is to re-trigger handEnter on the new morph under the hand.
  handEnter (objectAt aHand) aHand
  if (notNil (hint trigger)) {removeHint (page aHand)}
  raise morph 'highlightOff' this
  refresh this
}

method clicked Toggle {
  clicked trigger
  refresh this
  return true
}

method doubleClicked Toggle {return (doubleClicked trigger)}
method setHint Toggle aStringOrNil {setHint trigger aStringOrNil}

method rightClicked Toggle {
  raise morph 'handleContextRequest' this
  return true
}

method replaceCostumes Toggle normalBitmap highlightBitmap pressedBitmap {
  replaceCostumes trigger normalBitmap highlightBitmap pressedBitmap
}

method removeCostume Toggle costumeName {removeCostume trigger costumeName}

to toggleButton action query width height corner border hasFrame flat {
  scale = (global 'scale')
  if (isNil width) {width = (scale * 45)}
  if (isNil height) {height = (scale * 30)}
  if (isNil corner) {corner = (scale * 13)}
  if (isNil border) {border = (max 1 (scale / 2))}
  if (isNil hasFrame) {hasFrame = true}
  if (isNil flat) {flat = true}
  frameSize = 2
  incr = 0
  if (not hasFrame) {
    frameSize = 0
    incr = 2
  }
  btnColor = (color 130 130 130)
  btn = (buttonBitmap nil btnColor (height - frameSize) (height - frameSize) false (corner - frameSize) border nil flat)

  tbm = (buttonBitmap nil (color 100 200 100) width height true (corner + incr) border hasFrame flat)
  drawBitmap tbm btn (width - (height - frameSize)) (frameSize / 2)

  fbm = (buttonBitmap nil (color 180 100 100) width height true (corner + incr) border hasFrame flat)
  drawBitmap fbm btn 0 (frameSize / 2)

  pbm = (buttonBitmap nil (darker btnColor) width height true (corner + incr) border hasFrame flat)
  drawBitmap pbm btn ((width - (height - frameSize)) / 2) (frameSize / 2)

  bt = (new 'Trigger' nil action fbm tbm pbm)
  m = (newMorph)
  setMorph bt m
  setWidth (bounds m) width
  setHeight (bounds m) height
  tg = (new 'Toggle' m bt query) // 'handDownOn')
  setHandler m tg
  refresh tg
  return tg
}
// Tooltip for buttons and menu items.

defineClass ToolTip morph contents

to newToolTip aString tipWidth {
  return (initialize (new 'ToolTip') aString tipWidth)
}

method morph ToolTip { return morph }

method initialize ToolTip aString tipWidth {
	scale = (global 'scale')

	if (isNil aString) { aString = 'Tooltip!' }
	if (isNil tipWidth) { tipWidth = (200 * scale) }

	font = 'Arial'
	fontSize = (18 * scale)
	if ('Linux' == (platform)) { fontSize = (13 * scale) }

	setFont font fontSize
	aString = (toString aString)
	lines = (toList (wordWrapped aString tipWidth))
	maxLines = 10
	if ((count lines) > maxLines) {
		lines = (copyFromTo lines 1 maxLines)
		add lines '...'
	}
	contents = (newText (joinStrings lines (newline)) font fontSize (gray 0) 'center')

	morph = (newMorph this)
	addPart morph (morph contents)
	fixLayout this
	return this
}

method layoutChanged ToolTip { fixLayout this }

method fixLayout ToolTip {
	scale = (global 'scale')
	fontSize = (18 * scale)
	if ('Linux' == (platform)) { fontSize = (13 * scale) }
	hInset = (11 * scale)
	vInset = (7 * scale)
	setPosition (morph contents) ((left morph) + hInset) ((top morph) + vInset)
	w = ((width (morph contents)) + (2 * hInset))
	h = (+ (height (morph contents)) (2 * vInset))
	setExtent morph w h
}

method drawOn ToolTip ctx {
	border = (1 * (global 'scale'))
	corner = (3 * (global 'scale'))
	fillColor = (color 255 255 230)
	fillRoundedRect (getShapeMaker ctx) (bounds morph) corner fillColor border (gray 140) (gray 140)
}
// delete morphs by dropping them in a morphic window
// undelete the last one

defineClass TrashCan morph window contents

method initialize TrashCan {
  scale = (global 'scale')
  window = (window 'Trash')
  morph = (morph window)
  setHandler morph this
  setMinExtent morph (scale * 100) (scale * 100)
  setExtent morph (scale * 100) (scale * 100)
}

method fixLayout TrashCan {fixLayout window}

method redraw TrashCan {
  redraw window
  fixLayout this
}

to openTrashCan page contents {
  tc = (new 'TrashCan')
  initialize tc contents
  setPosition (morph tc) (x (hand page)) (y (hand page))
  addPart page tc
}

// events

method wantsDropOf TrashCan aHandler {return true}

method justReceivedDrop TrashCan aHandler {
  emptyTrash this
  contents = aHandler
  hide (morph aHandler)
}

method rightClicked TrashCan aHand {
  popUpAtHand (contextMenu this) (page aHand)
  return true
}


// context menu

method contextMenu TrashCan {
  menu = (menu nil this)
  if (notNil contents) {
    addItem menu 'undelete last' 'undeleteLast'
    addItem menu 'empty trash' 'emptyTrash'
  } else {
    addItem menu '(trash is empty)' 'nop'
  }
  return menu
}

method emptyTrash TrashCan {
  if (notNil contents) {
    destroy (morph contents)
    contents = nil
  }
}

method undeleteLast TrashCan {
  if (notNil contents) {
    show (morph contents)
    grab (morph contents) (hand (global 'page'))
    contents = nil
  }
}
// morphic tree node handlers, used for hierarchical tree list items

// example:
// addPart (global 'page') (treeBox nil (array 'foo' 'bar' 'baz' (array 'quux' 'frob' (array 'fred' 'brum')) 'garply' (array 'bla' 'blubb' 'brabbel') 'spam'))

defineClass TreeBox morph toggle level isCollapsed getEntry getBranches data onSelect onDoubleClick getHint selection omitRoot bgColor highlighted

to treeBox trunk data getEntryAction getBranchesAction onSelect bgColor onDoubleClick getHint omitRoot {
  if (isNil getEntryAction) {getEntryAction = 'toString'}
  if (isNil getBranchesAction) {getBranchesAction = 'id'}
  if (isNil onSelect) {onSelect = 'nop'}
  if (isNil bgColor) {bgColor = (color 255 255 255)}
  if (isNil omitRoot) {omitRoot = false}

  tn = (new 'TreeBox')
  setField tn 'getEntry' getEntryAction
  setField tn 'getBranches' getBranchesAction
  setField tn 'isCollapsed' true
  setField tn 'data' data
  setField tn 'bgColor' bgColor
  setField tn 'onSelect' onSelect
  setField tn 'getHint' getHint
  setField tn 'onDoubleClick' onDoubleClick

  if (isNil trunk) {
    if omitRoot {
      setField tn 'level' 0
    } else {
      setField tn 'level' 1
    }
  } else {
    setField tn 'level' (+ 1 (level trunk))
  }
  initialize tn omitRoot
  return tn
}

method initialize TreeBox hideRoot {
  omitRoot = hideRoot
  tr = (new 'Trigger' nil (action 'select' this))
  if (notNil getHint) {setHint tr (call getHint data)}
  if (notNil onDoubleClick) {onDoubleClick tr (action onDoubleClick data)}
  setRenderer tr this
  morph = (newMorph this)
  setTransparentTouch morph true
  setMorph tr morph
  toggle = (new 'Toggle' morph tr (action 'isSelected' this) 'handEnter')
  addPart morph (morph (arrowToggle this))
  if omitRoot {
    createBranches this
  } else {
    setCostume morph (normalCostume this)
    refresh toggle
  }
  fixLayout this
}

method select TreeBox silently {
  if (isNil silently) {silently = false}
  r = (root this)
  setField r 'selection' this
  if (not silently) {
    call onSelect data
    for each (allMorphs (morph r)) {
      if (isClass (handler each) (className (classOf this))) {
        refresh (handler each)
      }
    }
  }
}

method unselect TreeBox {
  if (isSelected this) {
    setField (root this) 'selection' nil
    refresh this
  }
  for each (parts morph) {
    if (isClass (handler each) (className (classOf this))) {
      unselect (handler each)
    }
  }
}

method isSelected TreeBox {
  return (=== this (getField (root this) 'selection'))
}

method arrowKey TreeBox dx dy scrollFrame {
	if (dx < 0) {
		// right arrow
		if (isCollapsed selection) {
			toggleExpansion selection
		}
	} (dx > 0) {
		// left arrow
		if (not (isCollapsed selection)) {
			toggleExpansion selection
		}
	} (dy < 0) {
		// down arrow
		// find next item in parent
		selectNext this
	} (dy > 0) {
		// up arrow
		// find previous item in parent
		selectPrevious this
	}
	scrollIntoView scrollFrame (fullBounds (morph selection)) true
}

method selectNext TreeBox {
	owner = (owner (morph selection))
	items = (parts owner)
	index = (indexOf items (morph selection))
	if (and
		(not (isCollapsed selection))
		(hasBranches selection)
	) {
		// select the first item inside subtree
		select (handler (at (parts (morph selection)) 2))
	} else {
		if (index < (count items)) {
			// select next item at same level
			select (handler (at items (index + 1)))
		} else {
			// select first item at next subtree
			items = (parts (owner owner))
			index = (indexOf items owner)
			if (index < (count items)) {
				next = (handler (at items (index + 1)))
				if (isClass next 'TreeBox') {
					select next
				} else {
					print next
				}
			}
		}
	}
}

method selectPrevious TreeBox {
	owner = (owner (morph selection))
	items = (parts owner)
	index = (indexOf items (morph selection))
	if (index > 2) {
		previous = (handler (at items (index - 1)))
		if (and
			(not (isCollapsed previous))
			(hasBranches previous)
		) {
			// select last item at previous subtree
			items = (parts (morph previous))
			select (handler (last items))
		} else {
			// select previous item at same level
			select previous
		}
	} (and
		(not (isCollapsed (handler owner)))
		((level (handler owner)) > 0)
	) {
		// select parent
		select (handler owner)
	}
}

method handDownOn TreeBox aHand {return (handDownOn toggle aHand)}

method handEnter TreeBox aHand {
  if (containsPoint (bounds morph) (x aHand) (y aHand)) {
    handEnter toggle aHand
  }
}

method isSelectable TreeBox aHand {
  if (containsPoint (bounds morph) (x aHand) (y aHand)) {
    return true
  }
  return false
}

method handLeave TreeBox aHand {handLeave toggle aHand}
method clicked TreeBox aHand {return (clicked toggle aHand)}
method doubleClicked TreeBox {return (doubleClicked toggle)}
method setHint TreeBox aStringOrNil {setHint toggle aStringOrNil}
method rightClicked TreeBox {return (rightClicked toggle)}
method level TreeBox {return level}
method isCollapsed TreeBox {return isCollapsed}
method data TreeBox {return data}
method toggle TreeBox {return toggle}
method selection TreeBox {return selection}

method refresh TreeBox {
  clr = (gray 128)
  wht = bgColor
  arrow = (handler (first (parts morph)))
  refresh toggle
  if (isSelected this) {
    replaceCostumes arrow (arrowCostume this 'down' wht) (arrowCostume this 'right' wht)
  } else {
    replaceCostumes arrow (arrowCostume this 'down' clr) (arrowCostume this 'right' clr)
  }
  refresh arrow
}

method area TreeBox {
  if omitRoot {
    ans = (rect (left morph) (top morph) 0 0)
    for i ((count (parts morph)) - 1) {
      each = (at (parts morph) (i + 1))
      merge ans (fullBounds each)
    }
    return ans
  }
  return (fullBounds morph)
}

method indent TreeBox {
  scale = (global 'scale')
  fontSize = (12 * scale)
  fontName = 'Arial'
  setFont fontName fontSize
  return (+ (scale * 2) (fontHeight))
}

method root TreeBox {
  if (isNil (owner morph)) {return this}
  parent = (handler (owner morph))
  if (isClass parent (className (classOf this))) {
    return (root parent)
  }
  return this
}

method isRoot TreeBox {
  if (isNil (owner morph)) {return true}
  return (not (isClass (handler (owner morph)) (className (classOf this))))
}

method hasBranches TreeBox {
  branches = (call getBranches data)
  return (and (isAnyClass branches 'Array' 'List') (not (isEmpty branches)))
}

method createBranches TreeBox {
  removeAllBranches this
  branches = (call getBranches data)
  if (not (isAnyClass branches 'Array' 'List')) {return}
  for each branches {
    addPart morph (morph (treeBox this each getEntry getBranches onSelect bgColor onDoubleClick getHint))
  }
  if ((count branches) > 0) {toggleExpansion this true}
}

method removeAllBranches TreeBox {
  arrow = (first (parts morph))
  removeAllParts morph
  addPart morph arrow
}

method fixLayout TreeBox {
  paddingX = (3 * (global 'scale'))
  x = (left morph)
  y = (bottom morph)
  for i (count (parts morph)) {
    each = (at (parts morph) i)
    if (i == 1) { // arrow
        setPosition each (+ x paddingX (* (indent this) (level - 1))) (top morph)
    } else {
        setPosition each x y
        y += (height (fullBounds each))
    }
  }
  if (isRoot this) {
    parent = nil
    if (notNil (owner morph)) {
      parent = (handler (owner morph))
    }
    if (isClass parent 'ScrollFrame') {
      adjustContents parent
      updateSliders parent
    } else {
      adjustWidths this
    }
  }
}

method setMinWidth TreeBox minWidth {adjustWidths this minWidth}

method adjustWidths TreeBox maxWidth {
  if (isNil maxWidth) {maxWidth = 0}
  itemsWidth = (maxItemWidth this)
  mw = (max maxWidth itemsWidth)
  for each (allVisibleNodes this) {
    setWidth (bounds (morph each)) mw
  }
  if (notNil selection) {
    removeCostume (toggle selection) 'highlight'
    refresh selection
  }
}

method maxItemWidth TreeBox {
  mw = 0
  for each (allVisibleNodes this) {
    if (not (isHidden (morph each))) {
      nc = (getField each 'toggle' 'trigger' 'normalCostume')
      if (isClass nc 'Bitmap') {
        mw = (max mw (width nc))
      }
    }
  }
  return mw
}

method allVisibleNodes TreeBox {
  if (isHidden (morph this)) {return (list)}
  ans = (list this)
  for i ((count (parts morph)) - 1) {
    each = (at (parts morph) (i + 1))
    addAll ans (allVisibleNodes (handler each))
  }
  return ans
}

method normalCostume TreeBox inputData accessor {
  if omitRoot {return (newBitmap 0 0)}
  return (itemCostume this data (color) nil nil getEntry)
}

method highlightCostume TreeBox inputData accessor {
  return (itemCostume this data bgColor (gray 130) nil getEntry)
}

method pressedCostume TreeBox inputData accessor {
  return (itemCostume this data (color) (darker bgColor 10) nil getEntry)
}

method itemCostume TreeBox inputData foregroundColor backgroundColor alpha accessor {
  // private - return a bitmap representing a list item

  // simulate constants
  scale = (global 'scale')
  paddingX = (3 * scale)
  paddingY = scale
  fontName = 'Arial'
  fontSize = (12 * (global 'scale'))

  if (isNil accessor) {accessor = getEntry}
  dta = (call accessor inputData)
  if (isClass dta 'Bitmap') {
    indent = (* level (indent this))
    bm = (newBitmap (max (+ indent (* 2 paddingX) (width dta)) (width morph)) (+ (height dta) (* 2 paddingY)) backgroundColor)
    drawBitmap bm dta (+ indent paddingX) paddingY alpha
    return bm
  } (isClass dta 'Morph') {
    return (itemCostume this (fullCostume dta) foregroundColor backgroundColor alpha 'id')
  } (hasField dta 'morph') {
    return (itemCostume this (fullCostume (getField dta 'morph')) foregroundColor backgroundColor alpha 'id')
  } (isAnyClass dta 'Command' 'Reporter') {
    return (itemCostume this (fullCostume (morph (toBlock dta))) foregroundColor backgroundColor alpha 'id')
  } (isClass dta 'String') {
    return (itemCostume this (stringImage dta fontName fontSize foregroundColor) foregroundColor backgroundColor alpha 'id')
  } else {
    return (itemCostume this (toString dta) foregroundColor backgroundColor alpha 'id')
  }
}

method arrowToggle TreeBox {
  clr = (gray 128)
  tr = (new 'Trigger' nil (action 'toggleExpansion' this))
  m = (newMorph)
  setMorph tr m
  setTransparentTouch m true
  ar = (new 'Toggle' m tr (action 'isCollapsed' this))
  setHandler m ar
  replaceCostumes tr (arrowCostume this 'down' clr) (arrowCostume this 'right' clr)
  side = (indent this)
  setWidth (bounds m) side
  setHeight (bounds m) side
  refresh ar true
  if (not (hasBranches this)) {hide (morph ar)}
  return ar
}

method toggleExpansion TreeBox expand {
  if (isNil expand) {
    isCollapsed = (not isCollapsed)
  } else {
    isCollapsed = (not expand)
  }
  if isCollapsed {
    for i (- (count (parts morph)) 1) { // hide branches
      branch = (at (parts morph) (i + 1))
      hide branch
      unselect (handler branch)
    }
  } else {
    if ((count (parts morph)) < 2) {
      createBranches this
    } else {
      for i (- (count (parts morph)) 1) { // show branches
        show (at (parts morph) (i + 1))
      }
    }
  }
  refresh (handler (first (parts morph))) true
  cm = morph
  fixLayout this
  while (and (notNil (owner cm)) (isClass (handler (owner cm)) (className (classOf this)))) {
    cm = (owner cm)
    fixLayout (handler cm)
  }
}

method arrowCostume TreeBox direction color {
  // direction can be 'right', 'left', 'up' or 'down'
  side = (indent this)
  border = (side / 4)
  bm = (newBitmap side side)
  fillArrow (newShapeMaker bm) (rect border border (side - (border * 2)) (side - (border * 2))) direction color
  return bm
}

method highlighted TreeBox {return highlighted}
method highlightOn TreeBox aListItem {highlighted = aListItem}

method highlightOff TreeBox aListItem {
  if (highlighted === aListItem) {
    highlighted = nil
  }
}

method selectedMorph TreeBox {
  sel = (selection (root this))
  if (isNil sel) {return nil}
  return (morph sel)
}
// basic morphic button handlers

defineClass Trigger morph action normalCostume highlightCostume pressedCostume data renderer onDoubleClick hint downX downY

method setAction Trigger aCallableOrArray {action = aCallableOrArray}
method setData Trigger obj {data = obj}
method data Trigger {return data}
method setRenderer Trigger obj {renderer = obj}
method onDoubleClick Trigger anAction {onDoubleClick = anAction}
method setHint Trigger aStringOrNil {hint = aStringOrNil}
method hint Trigger {return hint}

method trigger Trigger anAction {
  if (isNil anAction) {anAction = action}
  if (isClass anAction 'Array') {
    for each anAction {call each}
  } else {
    call anAction
  }
}

method normal Trigger {
  if (isNil normalCostume) {
    if (notNil renderer) {
      normalCostume = (call 'normalCostume' renderer data)
    }
  }
  if (notNil normalCostume) { setCostume morph normalCostume true }
  if (notNil renderer) {
      highlightCostume = nil
      pressedCostume = nil
  }
}

method highlight Trigger {
  if (isNil highlightCostume) {
    if (notNil renderer) {
      highlightCostume = (call 'highlightCostume' renderer data)
    }
  }
  if (notNil highlightCostume) { setCostume morph highlightCostume true }
}

method press Trigger {
  if (isNil pressedCostume) {
    if (notNil renderer) {
      pressedCostume = (call 'pressedCostume' renderer data)
    }
  }
  if (notNil pressedCostume) { setCostume morph pressedCostume true }
}

method handEnter Trigger aHand {
  setCursor 'pointer'
  highlight this
  if (notNil hint) {
	addSchedule (global 'page') (schedule (action 'showTooltip' morph hint) 300)
  }
}

method handLeave Trigger aHand {
  setCursor 'default'
  // handEnter happens before handLeave, so cursor wouldn't go back to finger
  // when you move between two buttons without any space in between. A temporary
  // solution is to re-trigger handEnter on the new morph under the hand.
  handEnter (objectAt aHand) aHand
  normal this
  if (notNil hint) {removeTooltip (page aHand)}
  removeSchedulesFor (global 'page') 'showTooltip' morph
}

method handDownOn Trigger aHand {
  press this
  return true
}

method handUpOn Trigger aHand {
  wasDragged = (isNil (getField aHand 'lastTouched'))
  setField aHand 'lastTouched' nil // cancel clicked event
  press this
  if (notNil hint) {removeHint (page aHand)}
  removeSchedulesFor (global 'page') 'showHint' morph
  doOneCycle (page aHand)
  if (not wasDragged) {
       trigger this
       return true
  } else { print 'TriggerUpMoved' }
  return false
}

method clicked Trigger {
  highlight this
  trigger this
  return true
}

method doubleClicked Trigger {
  trigger this onDoubleClick
  return true
}

method rightClicked Trigger {
  raise morph 'handleContextRequest' this
  return true
}

method normalCostume Trigger { return normalCostume }

method replaceCostumes Trigger normalBM highlightBM pressedBM {
  if (notNil normalBM) {
	setExtent morph (width normalBM) (height normalBM)
  }
  normalCostume = normalBM
  highlightCostume = highlightBM
  pressedCostume = pressedBM
  normal this
}

method removeCostume Trigger costumeName {
  if (costumeName == 'normal') {
    normalCostume = nil
  } (costumeName == 'highlight') {
    highlightCostume = nil
  } (costumeName == 'pressed') {
    pressedCostume = nil
  }
}

method clearCostumes Trigger {
  normalCostume = nil
  highlightCostume = nil
  pressedCostume = nil
  setCostume morph nil
}

to pushButton label color action minWidth minHeight makeDefault {
  btn = (new 'Trigger' (newMorph) action)
  setHandler (morph btn) btn
  setGrabRule (morph btn) 'ignore'
  drawLabelCostumes btn label color minWidth minHeight makeDefault
  return btn
}

method drawLabelCostumes Trigger label color minWidth minHeight makeDefault {
  if (isNil minWidth) {minWidth = 0}
  if (isNil minHeight) {minHeight = 0}
  if makeDefault {
	normalCostume = (buttonBitmap label (mixed color 50 (color 0 100 0)) minWidth minHeight)
  } else {
	normalCostume = (buttonBitmap label color minWidth minHeight)
  }
  highlightCostume = (buttonBitmap label (darker color) minWidth minHeight)
  pressedCostume = (buttonBitmap label (darker color) minWidth minHeight true)
  setCostume morph normalCostume
}

to buttonBitmap label color w h isInset corner border hasFrame flat {
  if (isNil flat) {flat = true}
  if (isClass label 'String') {
    scale = (global 'scale')
    off = (max (scale / 2) 1)
    fontName = 'Arial Bold'
    fontSize = (11 * scale)
    lbm = (stringImage (localized label) fontName fontSize (gray 255) 'center' (darker color) (off * -1) nil nil nil nil nil nil flat)
  } else {
    lbm = nil
  }
  return (buttonImage lbm color corner border isInset hasFrame w h flat)
}

to buttonImage labelBitmap color corner border isInset hasFrame width height flat {
  // answer a new bitmap depicting a push button rendered
  // with the specified box settings.
  // the bitmap's width and height are determined by the - optional -
  // labelBitmap's dimensions, width and height are also optional arguments
  // allowing the image to be bigger than the automatic minimum

  scale = (global 'scale')

  if (isNil color) {color = (color 130 130 130)}
  if (isNil corner) {corner = (scale * 6)}
  if (isNil border) {border = (max 1 (scale / 2))}
  if (isNil isInset) {isInset = false}
  if (isNil hasFrame) {hasFrame = true}
  if (isNil width) {width = (+ corner corner border border)}
  if (isNil height) {height = (+ border border)}
  if (isNil flat) {flat = true}

  lblWidth = 0
  if (isClass labelBitmap 'Bitmap') {lblWidth = (width labelBitmap)}
  lblHeight = 0
  if (isClass labelBitmap 'Bitmap') {lblHeight = (height labelBitmap)}

  if flat {border = 0}

  w = (max (+ lblWidth corner corner border border) width)
  h = (max (+ lblHeight border border) height)

  bm = (newBitmap w h)
  drawButton (newShapeMaker bm) 0 0 w h color corner border isInset
  if (isClass labelBitmap 'Bitmap') {
    off = 0
    if isInset {off = (max (border / 2) 1)}
    drawBitmap bm labelBitmap (((w - (width labelBitmap)) / 2) + off) (((h - (height labelBitmap)) / 2) + off)
  }
  if ('Browser' != (platform)) { unmultiplyAlpha bm }
  return bm
}

// serialization

method preSerialize Trigger {
  if (notNil renderer) { clearCostumes this }
}
// Turtle.gp - Minimal turtle
// John Maloney, March 2014

defineClass Turtle morph x y direction penDown penSize penColor

to newTurtle {
  turtle = (initialize (new 'Turtle'))
  setField turtle 'morph' (newMorph turtle)
  setGrabRule (getField turtle 'morph') 'handle'
  redraw turtle
  return turtle
}

method initialize Turtle {
  x = 0
  y = 0
  direction = 0
  penDown = false
  penSize = 3
  penColor = (color)
  return this
}

method redraw Turtle {
  scale = (global 'scale')
  r = (scale * 15)
  bm = (newBitmap (2 * r) (2 * r))
  shapeMaker = (newShapeMaker bm)
  drawCircle shapeMaker r r (r - 5) (color 0 0 250)
  pen = (pen shapeMaker)
  beginPath pen r r
  setHeading pen direction
  forward pen r
  stroke pen (color 255 0 0) (2 * scale)
  setCostume morph bm
}

method grab Turtle aBlock {
  h = (hand (handler (root morph)))
  setCenter (morph aBlock) (x h) (y h)
  grab h aBlock
}

method justDropped Turtle {
  x = (left morph)
  y = (top morph)
}

// context menu

method rightClicked Turtle aHand {
  popUpAtHand (turtleMenu this) (page aHand)
  return true
}

method turtleMenu Turtle {
  menu = (menu 'Turtle' this)
  addBlock this (toBlock (newCommand 'forward' this 50)) menu
  addBlock this (toBlock (newCommand 'turn' this 15)) menu
  addBlock this (toBlock (newReporter 'direction' this)) menu
  addBlock this (toBlock (newCommand 'clear' this)) menu
  addBlock this (toBlock (newCommand 'penDown' this)) menu
  addBlock this (toBlock (newCommand 'penUp' this)) menu
  addBlock this (toBlock (newCommand 'setPenSize' this 5)) menu
  addBlock this (toBlock (newCommand 'setPenColor' this (color 0 0 200))) menu
  addBlock this (toBlock (newCommand 'repeat' 10 nil)) menu
  addBlock this (toBlock (newCommand 'animate' nil)) menu
  return menu
}

method addBlock Turtle aBlock menu {
  addItem menu (fullCostume (morph aBlock)) (action 'grab' this aBlock)
}

// block ops

method forward Turtle n {
  oldX = x
  oldY = y
  x += (n * (cos direction))
  y += (n * (sin direction))
  setPosition morph x y
  if penDown { drawTrail this oldX oldY }
}

method turn Turtle degrees {
  direction = ((direction + degrees) % 360)
  redraw this
}

method direction Turtle {return direction}
method clear Turtle {penClear morph}
method penDown Turtle {penDown = true}
method penUp Turtle {penDown = false}
method setPenSize Turtle n {penSize = (max n 1)}
method setPenColor Turtle c {penColor = c}

method drawTrail Turtle startX startY {
  if (or (not penDown) (isNil (owner morph))) {return}
  r = ((width morph) / 2)
  startPos = (penPosition (owner morph) startX startY)
  endPos = (penPosition (owner morph) (left morph) (top morph))
  pen = (newVectorPen (requirePenTrails (owner morph)))
  beginPath pen ((first startPos) + r) ((last startPos) + r)
  lineTo pen ((first endPos) + r) ((last endPos) + r)
  stroke pen penColor penSize 1 1
  changed (owner morph)
}
// TurtlePen
// graphics primitives for Morphs

defineClass TurtlePen canvas pen color size xPos yPos heading isDown

to newTurtlePen aBitmap {
  return (new 'TurtlePen' aBitmap (newVectorPen aBitmap) (color) 1 0 0 0.0 false)
}
method alpha TurtlePen {return (alpha color)}
method setAlpha TurtlePen a {setAlpha color a}
method setColor TurtlePen aColor {color = aColor}
method color TurtlePen {return color}
method canvas TurtlePen {return canvas}

method setCanvas TurtlePen aBitmap {
  canvas = aBitmap
  setField pen 'bitmap' aBitmap
}

method setLineWidth TurtlePen aNumber {size = aNumber}

// turtle graphics

method isDown TurtlePen {return isDown}
method down TurtlePen {isDown = true}
method up TurtlePen {isDown = false}

method x TurtlePen {return xPos}
method y TurtlePen {return yPos}
method setX TurtlePen num {xPos = num}
method setY TurtlePen num {yPos = num}

method goto TurtlePen newX newY {
  drawLine this xPos yPos newX newY
  xPos = newX
  yPos = newY
}

method move TurtlePen n {
  newX = (xPos + (n * (cos heading)))
  newY = (yPos + (n * (sin heading)))
  goto this newX newY
}

method direction TurtlePen {return heading}
method setDirection TurtlePen num {heading = (num % 360)}
method turn TurtlePen degrees {setDirection this (heading + degrees)}

method turnTo TurtlePen x y {
  deltaX = ((toFloat x) - (toFloat xPos))
  deltaY = ((toFloat y) - (toFloat yPos))
  setDirection this (atan deltaY deltaX)
}

// shapes

method drawLine TurtlePen x0 y0 x1 y1 {
  beginPath pen x0 y0
  addSegment pen x0 y0 x1 y1
  stroke pen color size 0 1
}
// VectorPen.gp -- Turtle-style vector graphics with stroked and/or filled paths.

// VectorPen includes an incomplete simulation of vector graphics for use when the vector
// graphics primitives are not available (e.g. when porting to a new platform). This
// simulation does not handle paths that cross themselves or have holes, anti-aliasing,
// or line cap and joint styles. It may also omit future features of GP vector graphics
// primitives such as gradients.

defineClass VectorPen offsetX offsetY penX penY heading bitmap svgData clipRect owner path usePrimitives pathWidth halfWidth color

method examples VectorPen {
  showImage (drawCircle (newVectorPen))
  showImage (drawBox (newVectorPen))
  showImage (drawFatBox (newVectorPen))
  showImage (drawStar (newVectorPen))
  showImage (drawPentagon (newVectorPen))
  showImage (drawRoundedRect (newVectorPen))

  // simulated:
  showImage (drawCircle (newVectorPen nil nil true))
  showImage (drawBox (newVectorPen nil nil true))
  showImage (drawFatBox (newVectorPen nil nil true))
  showImage (drawStar (newVectorPen nil nil true))
  showImage (drawPentagon (newVectorPen nil nil true))
  showImage (drawRoundedRect (newVectorPen nil nil true))
}

to newVectorPenOnScreen {
  return (intialize (new 'VectorPen'))
}

to newVectorPen bitmap owningMorph noPrimitives {
  if (isNil bitmap) {
	bitmap = (newBitmap 200 200)
  }
  return (intialize (new 'VectorPen') bitmap owningMorph noPrimitives)
}

to newVectorPenForSVG pageW pageH {
  return (initSVG (intialize (new 'VectorPen')) pageW pageH)
}

method x VectorPen { return (penX - offsetX) }
method y VectorPen { return (penY - offsetY) }
method bitmap VectorPen { return bitmap }
method setColor VectorPen c { noop } // for compatability with pen; ignore
method setClipRect VectorPen aRect { clipRect = aRect }
method setHeading VectorPen degrees { heading = degrees }
method path VectorPen { return (toArray path) }

method intialize VectorPen aBitmap aMorph noPrimitives {
  offsetX = 0
  offsetY = 0
  penX = 100
  penY = 100
  heading = 0
  bitmap = aBitmap
  owner = aMorph
  path = (list)
  usePrimitives = (hasPrimitive 'vectorFillPath')
  if (noPrimitives == true) { usePrimitives = false }
if (true == (global 'fakeVectors')) { usePrimitives = false } // xxx for testing
  return this
}

method setOffset VectorPen x y {
  offsetX = x
  offsetY = y
}

method beginPath VectorPen x y {
  if (isNil x) { x = 100 }
  if (isNil y) { y = 100 }
  penX = (x + offsetX)
  penY = (y + offsetY)
  heading = 0
  path = (list 'M' penX penY)
}

method beginPathFromCurrentPostion VectorPen {
  path = (list 'M' penX penY)
}

method goto VectorPen dstX dstY {
  // For compatability with Pen
  lineTo this dstX dstY
}

method lineTo VectorPen dstX dstY curvature {
  startX = penX
  startY = penY
  penX = (dstX + offsetX)
  penY = (dstY + offsetY)
  addSegment this startX startY penX penY curvature
}

method curveTo VectorPen dstX dstY cx cy {
  startX = penX
  startY = penY
  penX = (dstX + offsetX)
  penY = (dstY + offsetY)
  addAll path (array 'C' dstX dstY (cx + offsetX) (cy + offsetY))
}

method cubicCurveTo VectorPen c1X c1Y c2X c2Y dstX dstY {
  // Approximate a cubic Bezier with four quadratic ones.
  // Based on Timothee Groleau's Bezier_lib.as - v1.2, 19/05/02, which
  // uses a simplified version of the midpoint algorithm by Helen Triolo.
  // http://www.timotheegroleau.com/Flash/articles/cubic_bezier_in_flash.htm

  c1X += offsetX
  c1Y += offsetY
  c2X += offsetX
  c2Y += offsetY
  dstX += offsetX
  dstY += offsetY

  startX = penX
  startY = penY
  penX = (dstX + offsetX)
  penY = (dstY + offsetY)

  // points used to calculate the control points pc2 and pc3
  paX = (interpolate startX c1X 0.75)
  paY = (interpolate startY c1Y 0.75)
  pbX = (interpolate dstX c2X 0.75)
  pbY = (interpolate dstY c2Y 0.75)

  // 1/16 of the [start, dst] segment
  dx = ((dstX - startX) / 16)
  dy = ((dstY - startY) / 16)

  // control point 1
  pc1X = (interpolate startX c1X 0.375)
  pc1Y = (interpolate startY c1Y 0.375)

  // control point 2
  pc2X = ((interpolate paX pbX 0.375) - dx)
  pc2Y = ((interpolate paY pbY 0.375) - dy)

  // control point 3
  pc3X = ((interpolate pbX paX 0.375) + dx)
  pc3Y = ((interpolate pbY paY 0.375) + dy)

  // control point 4
  pc4X = (interpolate dstX c2X 0.375)
  pc4Y = (interpolate dstY c2Y 0.375)

  // three intermediate anchor points
  pa1X = (interpolate pc1X pc2X 0.5)
  pa1Y = (interpolate pc1Y pc2Y 0.5)

  pa2X = (interpolate paX pbX 0.5)
  pa2Y = (interpolate paY pbY 0.5)

  pa3X = (interpolate pc3X pc4X 0.5)
  pa3Y = (interpolate pc3Y pc4Y 0.5)

  // draw the four quadratic subsegments
  addAll path (array 'C' pa1X pa1Y pc1X pc1Y)
  addAll path (array 'C' pa2X pa2Y pc2X pc2Y)
  addAll path (array 'C' pa3X pa3Y pc3X pc3Y)
  addAll path (array 'C' dstX dstY pc4X pc4Y)
}

method forward VectorPen dist curvature {
  startX = penX
  startY = penY
  penX += (dist * (cos heading))
  penY += (dist * (sin heading))

  // make almost vertical or horizontal exact (compenstates for tiny floating point errors)
  if ((abs (penX - startX)) < 0.000001) { penX = startX }
  if ((abs (penY - startY)) < 0.000001) { penY = startY }

  addSegment this startX startY penX penY curvature
}

method turn VectorPen degrees radius {
  // If radius is nil or zero, turn in place. If radius > 0, move the given number of
  // degrees along an approximately circular arc. To ensure minimal error, the arc is
  // approximated by a sequence of short, quadratic Bezier arc segments.

  if (degrees == 0) { return } // no turn

  if (or (isNil radius) (radius == 0)) { // turn in place
	heading = ((heading + degrees) % 360)
	return
  }

  if (degrees > 0) { // right turn (clockwise)
	centerX = (penX - (radius * (sin heading)))
	centerY = (penY + (radius * (cos heading)))
	angle = (heading - 90) // bearing from center point to pen
  } else { // left turn (counter-clockwise)
	centerX = (penX + (radius * (sin heading)))
	centerY = (penY - (radius * (cos heading)))
	angle = (heading + 90) // bearing from center point to pen
  }
  maxDegreesPerStep = 45
  steps = ((truncate ((abs degrees) / maxDegreesPerStep)) + 1)
  degreesPerStep = (degrees / steps)
  repeat steps {
	midAngle = (angle + (degreesPerStep / 2))
	endAngle = (angle + degreesPerStep)
	cx = ((((-0.5 * ((cos angle) + (cos endAngle))) + (2 * (cos midAngle))) * radius) + centerX)
	cy = ((((-0.5 * ((sin angle) + (sin endAngle))) + (2 * (sin midAngle))) * radius) + centerY)

	penX = (centerX + (radius * (cos endAngle)))
	penY = (centerY + (radius * (sin endAngle)))
	addAll path (array 'C' penX penY cx cy)
	angle = endAngle
  }
  heading = ((heading + degrees) % 360)
}

method stroke VectorPen borderColor width joint cap {
  if (isNil borderColor) { borderColor = (gray 0) }
  if (isNil width) { width = 1 }
  if (isNil joint) { joint = 0 }
  if (isNil cap) { cap = 0 }

  if (notNil svgData) {
	add svgData (join '	<path stroke=' (svgColor this borderColor) ' stroke-width="' width 'mm" ' (svgPath this path) '/>')
	return
  }
  if usePrimitives {
	vectorStrokePath bitmap (toArray path) borderColor width joint cap clipRect
  } else {
	// Simulate vector primitives. Cap and joint are ignored.
	color = borderColor
	drawPath this (max 1 (round width))
  }
  if (notNil owner) { costumeChanged owner }
}

method fill VectorPen fillColor {
  if (isNil fillColor) { fillColor = (gray 0) }
  if (notNil svgData) {
	add svgData (join '	<path fill=' (svgColor this fillColor) ' ' (svgPath this path true) '/>')
	return
  }
  if usePrimitives {
	closedPath = (copy path)
	add closedPath 'Z'
	vectorFillPath bitmap (toArray closedPath) fillColor clipRect
  } else {
	if (fillColor == (gray 0)) { fillColor = (gray 1) } // avoid black/transparent confusion
	oldPath = path
	path = (closedPath this)
	color = fillColor
	drawPath this 1
	fillPath this
	path = oldPath
  }
  if (notNil owner) { costumeChanged owner }
}

method fillAndStroke VectorPen fillColor borderColor borderWidth {
  if (isNil borderColor) { borderColor = (gray 0) }
  if (isNil borderWidth) { borderWidth = 1 }
  if (and (notNil fillColor) ((alpha fillColor) > 0)) {
    fill this fillColor
  }
  if (and ((alpha borderColor) > 0) (borderWidth > 0)) {
    stroke this borderColor borderWidth
  }
}

// SVG support

method initSVG VectorPen pageW pageH {
  if (isNil pageW) { pageW = 200 }
  if (isNil pageH)  {pageH = 250 }
  svgData = (list)
  add svgData '<svg version="1.1"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns="http://www.w3.org/2000/svg"
	fill="none" fill-rule="evenodd"
	stroke="#000000" stroke-width="0.1mm"
	stroke-linecap="butt" stroke-linejoin="round"'
  add svgData (join '	viewBox="0 0 ' pageW ' ' pageH '"')
  add svgData (join '	width="' pageW 'mm"')
  add svgData (join '	height="' pageH 'mm">')
  add svgData '  <g>'
  return this
}

method saveSVGFile VectorPen fileName {
  data = (joinStrings svgData (newline))
  data = (join data (newline) '  </g>
</svg>')
  writeFile fileName data
}

method twoHexDigits VectorPen n {
  result = (toStringBase16 n)
  if ((count result) == 1) { result = (join '0' result) }
  return result
}

method svgColor VectorPen aColor {
  return (join '"#'
    (twoHexDigits this (red aColor))
    (twoHexDigits this (green aColor))
    (twoHexDigits this (blue aColor))
    '"')
}

method newSVGGroup VectorPen {
  add svgData '  </g>'
  add svgData '  <g>'
}

method svgPath VectorPen aColor closeFlag {
  result = (list 'd="')
  i = 1
  while (i <= (count path)) {
	cmd = (at path i)
	if ('M' == cmd) {
	  startX = (at path (i + 1))
	  startY = (at path (i + 2))
	  add result (join 'M ' startX ' ' startY)
	  i += 3
	} ('L' == cmd) {
	  endX = (at path (i + 1))
	  endY = (at path (i + 2))
	  add result (join 'L ' endX ' ' endY)
	  i += 3
	} ('C' == cmd) {
	  endX = (at path (i + 1))
	  endY = (at path (i + 2))
	  cx = (at path (i + 3))
	  cy = (at path (i + 4))
	  add result (join 'Q ' cx ' ' cy ' ' endX ' ' endY)
	  i += 5
	}
  }
  if (true == closeFlag) { add result 'Z' }
  add result '"'
  return (joinStrings result ' ')
}

// shapes

method fillRoundedRect VectorPen rect radius fillColor border borderColor {
  // Draw a rounded rectangle. If fillColor is nil, just draw the border.
  // If border is nil or 0, just draw the fill. borderColor defaults to black.

  if (isNil radius) { radius = 4 }
  if (isNil border) { border = 0 }
  adjustedW = ((width rect) - ((2 * radius) + border))
  adjustedH = ((height rect) - ((2 * radius) + border))

  beginPath this (+ (left rect) (half border) radius) (+ (top rect) (half border))
  setHeading this 0
  repeat 2 {
	forward this adjustedW
	turn this 90 radius
	forward this adjustedH
	turn this 90 radius
  }
  if (notNil fillColor) {
	fill this fillColor
  }
  if (border > 0) {
	if (isNil borderColor) { borderColor = (gray 0) }
	stroke this borderColor border
  }
}

// internal method

method addSegment VectorPen x1 y1 x2 y2 curvature {
  if (isNil curvature) { curvature = 0 }
  if (curvature == 0) {
	addAll path (array 'L' x2 y2)
  } else {
	// control point is on a line perpendicular to the segment
	// at it's midpoint, scaled by (curvature / 100)
	curvature = (curvature / 100)
	midpointX = ((x1 + x2) / 2)
	midpointY = ((y1 + y2) / 2)
	cx = (midpointX + (curvature * (y2 - y1)))
	cy = (midpointY + (curvature * (x1 - x2)))
	addAll path (array 'C' x2 y2 cx cy)
  }
}

method closedPath VectorPen {
  if ((count path) < 4) { return path }
  firstX = (at path 2)
  firstY = (at path 3)
  if (and ((round penX) == (round firstX)) ((round penY) == (round firstY))) {
	return path
  }
  result = (copy path)
  addAll result (array 'L' firstX firstY)
  return result
}

method drawPath VectorPen width {
  pathWidth = width
  halfWidth = (half pathWidth)
  startX = 0
  startY = 0
  i = 1
  while (i <= (count path)) {
	cmd = (at path i)
	if ('M' == cmd) {
	  startX = (at path (i + 1))
	  startY = (at path (i + 2))
	  i += 3
	} ('L' == cmd) {
	  endX = (at path (i + 1))
	  endY = (at path (i + 2))
	  drawLine this startX startY endX endY
	  startX = endX
	  startY = endY
	  i += 3
	} ('C' == cmd) {
	  endX = (at path (i + 1))
	  endY = (at path (i + 2))
	  cx = (at path (i + 3))
	  cy = (at path (i + 4))
	  quadBezier this startX startY endX endY cx cy
	  startX = endX
	  startY = endY
	  i += 5
	}
  }
}

method quadBezier VectorPen x0 y0 x1 y1 cx cy {
  stepCount = 20
  x = x0
  y = y0
  for i stepCount {
	p = (quadaticBezier x0 y0 x1 y1 cx cy i stepCount)
	nextX = (first p)
	nextY = (last p)
	drawLine this x y nextX nextY
	x = nextX
	y = nextY
  }
}

method quadBezierNoPrimitive VectorPen x0 y0 x1 y1 cx cy {
  // This version computes the Bezier points in GP instead of using a primitive.
  stepCount = 10
  x = x0
  y = y0
  for i stepCount {
	t = (i / stepCount)
	invT = (1 - t)
	a = (invT * invT)
	b = (2 * (t * invT))
	c = (t * t)
	nextX = (+ (a * x0) (b * cx) (c * x1))
	nextY = (+ (a * y0) (b * cy) (c * y1))
	drawLine this x y nextX nextY
	x = nextX
	y = nextY
  }
}

method drawLine VectorPen x0 y0 x1 y1 {
  x0 = (truncate x0)
  y0 = (truncate y0)
  x1 = (truncate x1)
  y1 = (truncate y1)

  // use line drawing primitive:
  drawLineOnBitmap bitmap x0 y0 x1 y1 color pathWidth
  return

  if (x0 == x1) { // vertical line
	top = (min y0 y1)
	h = (abs (y1 - y0))
	if (pathWidth <= 1) {
	  fillRect bitmap color x0 top 1 (h + 1)
	} else {
	  fillRect bitmap color (x0 - halfWidth) (top - halfWidth) pathWidth (h + pathWidth)
	}
	return
  } (y0 == y1) { // horizontal line
	left = (min x0 x1)
	w = (abs (x1 - x0))
	if (pathWidth <= 1) {
	  fillRect bitmap color left y0 (w + 1) 1
	} else {
	  fillRect bitmap color (left - halfWidth) (y0 - halfWidth) (w + pathWidth) pathWidth
	}
	return
  }

  // Bresenham's algorithm
  dx = (abs (x1 - x0))
  dy = (abs (y1 - y0))
  if (x0 < x1) {sx = 1} else {sx = -1}
  if (y0 < y1) {sy = 1} else {sy = -1}
  err = (dx - dy)
  while true {
	fillRect bitmap color (x0 - halfWidth) (y0 - halfWidth) pathWidth pathWidth
	if (and (x0 == x1) (y0 == y1)) {return}
	  e2 = (2 * err)
	if (e2 > (0 - dy)) {
	  err = (err - dy)
	  x0 = (x0 + sx)
	}
	if (and (x0 == x1) (y0 == y1)) {
	  fillRect bitmap color (x0 - halfWidth) (y0 - halfWidth) pathWidth pathWidth
	  return
	}
	if (e2 < dx) {
	  err = (err + dx)
	  y0 = (y0 + sy)
	}
  }
}

method fillPath VectorPen {
  // Use flood fill to fill a closed path, using a point on the right side of the first
  // segment as the seed. Does not work for paths that cross themselves, for donuts, etc.

  if ((count path) < 6) { return }
  n = 1
  firstX = (at path 2)
  firstY = (at path 3)
  if (not (isClass (at path 4) 'String')) { print 'first cmd:' (at path 1); return }
  dx = ((at path 5) - firstX)
  dy = ((at path 6) - firstY)
  len = (sqrt (+ (dx * dx) (dy * dy)))
  if (len > 0) {
	centerX = (firstX + (dx / 2))
	centerY = (firstY + (dy / 2))
	seedX = (round (centerX - ((2 * dy) / len)))
	seedY = (round (centerY + ((2 * dx) / len)))
  } else {
	pathCenter = (pathCenter this)
	seedX = (round (first pathCenter))
	seedY = (round (last pathCenter))
  }
  if (or (seedX < 0) (seedY < 0)) {
	print 'bad seed' seedX seedY
	return
  }
  floodFill bitmap seedX seedY color
  if false { fillRect bitmap (color 0 255 255) seedX seedY 2 2 } // show fill point (debugging)
}

method pathCenter VectorPen {
  // Return an array containing the center of this path.

  if ((count path) < 3) { return (array 0 0) } // shouldn't happen
  firstX = (at path 2)
  firstY = (at path 3)
  sumX = firstX
  sumY = firstY
  n = 1
  i = 4
  while (i <= (count path)) {
	cmd = (at path i)
	if ('M' == cmd) {
	  sumX += (at path (i + 1))
	  sumY += (at path (i + 2))
	  i += 3
	} ('L' == cmd) {
	  sumX += (at path (i + 1))
	  sumY += (at path (i + 2))
	  i += 3
	} ('C' == cmd) {
	  sumX += (at path (i + 1))
	  sumY += (at path (i + 2))
	  i += 5
	}
	n += 1
  }
  return (array (sumX / n) (sumY / n))
}

// examples

method drawCircle VectorPen {
  beginPath this 100 10
  setHeading this 0
  turn this 360 80
  fill this (randomColor)
  stroke this (gray 0) 1
  return (bitmap this)
}

method drawBox VectorPen {
  beginPath this 80 10
  setHeading this 0
  repeat 4 {
	forward this 100
	turn this 90
  }
  fill this (randomColor)
  stroke this (color 0 0 200) 8
  return (bitmap this)
}

method drawFatBox VectorPen {
  beginPath this 20 20
  setHeading this 0
  repeat 4 {
	forward this 100 10
	turn this 90
  }
  fill this (randomColor)
  stroke this (gray 0) 3
  return (bitmap this)
}

method drawStar VectorPen {
  beginPath this 30 80
  repeat 6 {
	// go one extra stroke to ensure a good miter at the starting point
	forward this 150
	turn this 144
  }
  jointStyle = 0 // 0 - sharp (mitered), 1 - rounded, 2 - beveled
  fill this (randomColor)
  stroke this (gray 0) 10 jointStyle
  return (bitmap this)
}

method drawPentagon VectorPen {
  beginPath this 50 20
  setHeading this 5
  repeat 5 {
	forward this 100
	turn this 72
  }
  fill this (randomColor)
  stroke this (gray 0) 3
  return (bitmap this)
}

method drawRoundedRect VectorPen {
  radius = 10
  borderThickness = 3
  fillRoundedRect this (rect 10 10 100 100) radius (randomColor) borderThickness (gray 0)
  return (bitmap this)
}
// VectorPenPrims.gp -- Wrapper for fast version of VectorPen implemented as primitives.

defineClass VectorPenPrims

to newVectorPenPrims { return (new 'VectorPenPrims') }

method x VectorPenPrims { return (pathX) }
method y VectorPenPrims { return (pathY) }
method setClipRect VectorPenPrims aRect { pathSetClipRect aRect }
method setHeading VectorPenPrims degrees { pathSetHeading degrees }
method setOffset VectorPenPrims x y { pathSetOffset x y }
method beginPath VectorPenPrims x y { pathBeginPath x y }
method beginPathFromCurrentPostion VectorPenPrims { pathBeginPathFromHere }
method lineTo VectorPenPrims x y { pathLineTo x y }

method goto VectorPenPrims x y {
  // For compatability with Pen
  pathLineTo x y
}

method forward VectorPenPrims dist curvature {
	if (isNil curvature) { curvature = 0 }
	pathForward dist curvature
}

method turn VectorPenPrims degrees radius {
	if (isNil radius) { radius = 0 }
	pathTurn degrees radius
}

method stroke VectorPenPrims borderColor borderWidth {
	if (isNil borderWidth) { borderWidth = 1 }
	pathStroke borderColor borderWidth
}

method fill VectorPenPrims fillColor {
	pathFill fillColor
}

method fillAndStroke VectorPenPrims fillColor borderColor borderWidth {
	if (isNil borderColor) { borderColor = (gray 0) }
	if (isNil borderWidth) { borderWidth = 1 }

	pathFillAndStroke fillColor borderColor borderWidth
}

// FakeVectorPen does nothing. It is used for performance testing.

defineClass FakeVectorPen

to newFakeVectorPen { return (new 'FakeVectorPen') }

method x FakeVectorPen { }
method y FakeVectorPen { }
method setClipRect FakeVectorPen aRect { }
method setHeading FakeVectorPen degrees { }
method setOffset FakeVectorPen x y { }
method beginPath FakeVectorPen x y { }
method beginPathFromCurrentPostion FakeVectorPen { }
method lineTo FakeVectorPen x y { }
method goto FakeVectorPen x y { }
method forward FakeVectorPen dist curvature { }
method turn FakeVectorPen degrees radius { }
method stroke FakeVectorPen borderColor borderWidth { }
method fill FakeVectorPen fillColor { }
method fillAndStroke FakeVectorPen fillColor borderColor borderWidth { }
// WAVFile - Encode and decode sounds in the WAV file format

defineClass WAVFile stream

to readWAVFile fileName {
	data = (readFile fileName true)
	if (isNil data) { error 'File not found:' fileName }
	return (decodeWAV data)
}

to decodeWAV data { return (read (new 'WAVFile') data) }
to encodeWAV snd doCompress { return (write (new 'WAVFile') snd doCompress ) }

method read WAVFile data {
  // Return the sound encoded by the given WAV file data.

  stream = (dataStream data false)

  // read WAVE file header
  if ('RIFF' != (nextString stream 4)) { error 'WAVFile: bad file header' }
  totalSize = (nextUInt32 stream)
  if ((byteCount data) != (totalSize + 8)) { print 'WAVFile: bad RIFF size; ignoring' }
  if ('WAVE'!= (nextString stream 4)) { error 'WAVFile: not a WAVE file' }

  // read format chunk
  formatChunk = (extractChunk this 'fmt ')
  if (isNil formatChunk) { error 'WAVFile: No format chunk; not a WAVE file' }
  if ((byteCount formatChunk) < 16) { error 'WAVFile: format chunk is too small' }
  s = (dataStream formatChunk)
  encoding = (nextUInt16 s)
  channels = (nextUInt16 s)
  samplingRate = (nextUInt32 s)
  bytesPerSecond = (nextUInt32 s)
  blockAlignment = (nextUInt16 s)
  bitsPerSample = (nextUInt16 s)
  if ((remaining s) >= 4) { // extra info for ADPCM (encoding 17)
	skip s 2  // skip extra header byte count
	samplesPerBlock = (nextUInt16 s)
  }

  // extract the samples
  byteCount = (findChunk this 'data') // positions stream at start of data
  if (1 == encoding) { // uncompressed
	if (16 == bitsPerSample) {
	  sampleCount = (floor (byteCount / 2))
	  samples = (newArray sampleCount)
	  for i sampleCount {
		atPut samples i (nextInt16 stream)
	  }
	} (8 == bitsPerSample) {
	  sampleCount = byteCount
	  samples = (newArray sampleCount)
	  for i sampleCount {
		atPut samples i (nextInt8 stream)
	  }
	} else {
	   error 'WAVFile: can only handle 8-bit or 16-bit uncompressed PCM data'
	}
  } (17 == encoding) {
	if (1 != channels) { error 'WAVFile: ADPCM supports only one channel (monophonic)' }
	if (isNil samplesPerBlock) { error 'WAVFile: ADPCM format chunk is too small' }
	adpcmBlockSize = ((half (samplesPerBlock - 1)) + 4) // block size in bytes
	factChunk = (extractChunk this 'fact')
	if (and (notNil factChunk) (4 == (byteCount factChunk))) {
	  sampleCount = (nextUInt32 (dataStream factChunk false))
	} else {
	  // this should never happen, since there should always be a 'fact' chunk
	  sampleCount = (2 * byteCount)  // slight over-estimate; doesn't take ADPCM headers into account
	}
	// XXX decode ADPCM here...
  } else {
	 error (join 'WAVFile: unknown encoding' encoding)
  }

  return (newSound samples samplingRate (channels == 2))
}

method extractChunk WAVFile desiredType {
  // Return the contents of the first chunk of the given type or nil if not found.
  chunkSize = (findChunk this desiredType)
  if (isNil chunkSize) { return nil }
  return (nextData stream chunkSize)
}

method findChunk WAVFile desiredType {
  // Position the stream at start of the first chunk of the given type and return its size.
  // Return nil if the chunk is not found.
  setPosition stream 12
  while ((remaining stream) > 8) {
	chunkType = (nextString stream 4)
	chunkSize = (nextUInt32 stream)
	if (chunkType == desiredType) {
	  if (chunkSize > (remaining stream)) { return nil }
	  return chunkSize
	} else {
	  setPosition stream ((position stream) + chunkSize)
	}
  }
  return nil
}

method write WAVFile snd compressFlag {
  // Return a BinaryData object that encodes the given sound in WAV file format.

compressFlag = false // xxx

  formatChunkBytes = 16
  if compressFlag { formatChunkBytes += 4 }
  headerBytes = (formatChunkBytes + 20)
  totalBytes = ((2 * (count (samples snd))) + headerBytes)
  stream = (dataStream (newBinaryData totalBytes) false)

  // RIFF + WAVE header
  nextPutAll stream 'RIFF'
  putUInt32 stream totalBytes	// total size, excluding 8-byte RIFF header
  nextPutAll stream 'WAVE'

  // format chunk
  rate = (samplingRate snd)
  channels = 1
  if (isStereo snd) { channels = 2 }
  nextPutAll stream 'fmt '
  putUInt32 stream 16			// chunk size
  putUInt16 stream 1			// encoding; 1 = PCM
  putUInt16 stream channels		// channels
  putUInt32 stream rate			// samplesPerSecond
  if (isStereo snd) {
	putUInt32 stream (4 * rate)	// bytesPerSecond
	putUInt16 stream 4			// blockAlignment
  } else {
	putUInt32 stream (2 * rate)	// bytesPerSecond
	putUInt16 stream 2			// blockAlignment
  }
  putUInt16 stream 16			// bitsPerSample

  // data chunk
  samples = (samples snd)
  nextPutAll stream 'data'
  putUInt32 stream (2 * (count samples))	// chunk size (in bytes)
  for n samples {
	putUInt16 stream n
  }

  return (contents stream)
}

//-----------------------------------------------------------------------
// ADPCM Sound Compression (WAV file IMA/DVI format, 4-bits per sample)
//-----------------------------------------------------------------------

method stepTable WAVFile {
  return (array
	7 8 9 10 11 12 13 14 16 17 19 21 23 25 28 31 34 37 41 45
	50 55 60 66 73 80 88 97 107 118 130 143 157 173 190 209 230
	253 279 307 337 371 408 449 494 544 598 658 724 796 876 963
	1060 1166 1282 1411 1552 1707 1878 2066 2272 2499 2749 3024 3327
	3660 4026 4428 4871 5358 5894 6484 7132 7845 8630 9493 10442 11487
	12635 13899 15289 16818 18500 20350 22385 24623 27086 29794 32767)
}

method indexTable WAVFile {
  return (array
	-1 -1 -1 -1 2 4 6 8
	-1 -1 -1 -1 2 4 6 8)
}

method imaCompress WAVFile samples blockSize {
  // Compress monophonic sample data using the IMA ADPCM algorithm (4-bits/sample).

  if (isNil blockSize) { blockSize = 512 }
  stepTable = (stepTable this)
  indexTable = (indexTable this)
  index = 0
  savedNibble = -1	// -1 indicates that there is no saved nibble
  srcIndex = 1		// index of next sample to compress
  end = (count samples)

  // Round sample count up to an integral number of blocks
  samplesPerBlock = ((2 * (blockSize - 4)) + 1)
  blockCount = (floor (((count samples) + (samplesPerBlock - 1)) / samplesPerBlock))
  sampleCount = (samplesPerBlock * blockCount)
  out = (dataStream (newBinaryData (blockCount * blockSize)) false)

  repeat sampleCount {
	// get next sample
	if (srcIndex <= end) {
	  sample = (at samples srcIndex)
	  srcIndex += 1
	} else {
	  sample = 0
	}

	if (((position out) % blockSize) == 0) { // write the block header
	  putUInt16 out sample
	  putUInt8 out index
	  putUInt8 out 0
	  predicted = sample
	} else {
	  // compute the 4-bit code for this sample and the delta it encodes
	  diff = (sample - predicted)
	  step = (at stepTable (index + 1))
	  code = 0
	  delta = 0
	  if (diff < 0) { code = 8; diff = (- diff) } // negative difference
	  if (diff >= step) { code += 4; diff += (- step); delta += step }
	  step = (step >> 1)
	  if (diff >= step) { code += 2; diff += (- step); delta += step }
	  step = (step >> 1)
	  if (diff >= step) { code += 1; diff += (- step); delta += step }
	  delta += (step >> 1)

	  // output code (two codes per byte)
	  if (savedNibble < 0) {
		savedNibble = code
	  } else {
		putUInt8 out ((code << 4) | savedNibble)
		savedNibble = -1
	  }

	  // compute the predicted next sample
	  if ((code & 8) > 0) {
		predicted += (- delta)
	  } else {
		predicted += delta
	  }
	  if (predicted > 32767) { predicted = 32767 }
	  if (predicted < -32768) { predicted = -32768 }

	  // compute the next index
	  index += (at indexTable (code + 1))
	  if (index > 88) { index = 88 }
	  if (index < 0) { index = 0 }
	}
  }
  if (savedNibble >= 0) { putUInt8 out savedNibble }
  return (contents out)
}

method imaDecompress WAVFile compressedData blockSize {
  // Decompress sample data using the IMA ADPCM algorithm (one channel, 4-bits/sample).

  if (isNil blockSize) { blockSize = 512 }
  stepTable = (stepTable this)
  indexTable = (indexTable this)

  compressed = (dataStream compressedData false)
  index = 0
  lastByte = -1	// -1 indicates that there is no saved lastByte
  out = (list)

  while true {
	if (and (((position compressed) % blockSize) == 0) (lastByte < 0)) {	// read block header
	  if (atEnd compressed) { return (toArray out) }
	  sample = (nextInt16 compressed)
	  index = (nextUInt8 compressed)
	  if (index > 88) { index = 88 }
	  skip compressed 1		// skip extra header byte
	  add out sample
	} else {
	  // read 4-bit code and compute delta from previous sample
	  if (lastByte < 0) {
		if (atEnd compressed) { return (toArray out) }
		lastByte = (nextUInt8 compressed)
		code = (lastByte & 15)
	  } else {
		code = ((lastByte >> 4) & 15)
		lastByte = -1
	  }
	  step = (at stepTable (index + 1))
	  delta = 0
	  if ((code & 4) > 0) { delta += step }
	  if ((code & 2) > 0) { delta += (step >> 1) }
	  if ((code & 1) > 0) { delta += (step >> 2) }
	  delta += (step >> 3)

	  // compute next index
	  index += (at indexTable (code + 1))
	  if (index > 88) { index = 88 }
	  if (index < 0) { index = 0 }

	  // compute and output sample
	  if ((code & 8) > 0) {
		sample += (0 - delta)
	  } else {
		sample += delta
	  }
	  if (sample > 32767) { sample = 32767 }
	  if (sample < -32768) { sample = -32768 }
	  add out sample
	}
  }
  return (toArray out)
}
// system window component - to be used in morphic handlers

defineClass Window morph label closeBtn resizer border color clientArea clientColor scale shadow

to window label {
  window = (new 'Window')
  initialize window label
  return window
}

method morph Window {return morph}
method border Window {return border}
method clientColor Window {return clientColor}
method clientArea Window {return clientArea}
method labelString Window {return (text label)}

method initialize Window labelString {
  scale = (global 'scale')
  border = (scale * 5)
  color = (gray 80)
  clientColor = (gray 255)
  morph = (newMorph this)
  setGrabRule morph 'handle'
  setTransparentTouch morph false // optimization
  label = (newText (localized labelString) 'Arial Bold' (scale * 12) clientColor)
  addPart morph (morph label)
  closeBtn = (pushButton 'X' (color 140 100 100) (action 'destroy' (morph this)))
  addPart morph (morph closeBtn)
  resizer = (resizeHandle this)
}

method updateScale Window {
  scale = (global 'scale')
  border = (scale * 5)
  setFont label nil (scale * 12)
  removePart morph (morph closeBtn)
  closeBtn = (pushButton 'X' (color 140 100 100) (action 'destroy' (morph this)))
  addPart morph (morph closeBtn)
}

method fixLayout Window {
  labelSize = (+ (height (morph label)) border)
  clientArea = (rect (+ (left morph) border) (+ (top morph) labelSize border) (- (width morph) (border * 2)) ((height morph) - (+ labelSize (border * 2))))
  setPosition (morph label) (+ (left morph) ((- (width morph) (width (morph label))) / 2)) (+ (top morph) border)
  setTop (morph closeBtn) (+ (top morph) border)
  setRight (morph closeBtn) ((right morph) - border)
  setRight (morph resizer) (right clientArea)
  setBottom (morph resizer) (bottom clientArea)
  addPart morph (morph resizer) // bring to front
}

method redraw Window {
  w = (width morph)
  h = (height morph)
  bm = (newBitmap w h)
  fillRoundedRect (newShapeMaker bm) (rect 0 0 w h) (scale * 4) color 1 (lighter color 20)
  setCostume morph bm
}

method redrawShadow Window {
  if (isNil shadow) {return}
  w = (width morph)
  h = (height morph)
  radius = (4 * scale)
  off = (0 - (scale * 5))
  bm = (newBitmap w h)
  fillRoundedRect (newShapeMaker bm) (rect 0 0 w h) radius (gray 0)
  fillRect bm (transparent) off off w h
  setCostume shadow bm
}

method addShadow Window {
  shadow = (newMorph)
  setAlpha shadow 128
  off = (scale * 5)
  setPosition shadow (+ off (left morph)) (+ off (top morph))
  redrawShadow this
  addPart morph shadow
}

method setLabelString Window aString {
  setText label (localized aString)
  redraw label
  fixLayout this
}

method spaceBoundedBy Window max percent total {
  // let the user specify a dynamic space bounded by a percentage of the given total
  // and either a maximum unscaled size, or an Action
  if (isNumber max) {
    ceil = (scale * max)
  } else {
    ceil = (call max)
  }
  return (min ceil ((percent * total) / 100))
}

method titleBarWidth Window {
  return (+ (width (morph label)) (width (morph closeBtn)) (4 * border))
}

// serialization

method preSerialize Window {
  setCostume morph nil
  clearCostumes closeBtn
  clearCostumes resizer
}

method postSerialize Window {
  drawLabelCostumes closeBtn 'X' (color 140 100 100)
  drawResizeCostumes resizer
}
// interactively eval GP code in a morphic window

defineClass Workspace morph window textBox textFrame

method initialize Workspace contents {
  scale = (global 'scale')
  if (not (isClass contents 'String')) {contents = ''}
  window = (window 'Workspace')
  morph = (morph window)
  setHandler morph this
  setMinExtent morph (scale * 140) (scale * 50)

  textBox = (newText contents)
  setEditRule textBox 'code'
  setGrabRule (morph textBox) 'ignore'
  setBorders textBox (border window) (border window)
  textFrame = (scrollFrame textBox (clientColor window))
  addPart morph (morph textFrame)

  setExtent morph (scale * 200) (scale * 120)
}

method fixLayout Workspace {
  fixLayout window
  clientArea = (clientArea window)
  setPosition (morph textFrame) (left clientArea) (top clientArea)
  setExtent (morph textFrame) (width clientArea) (height clientArea)
}

method redraw Workspace {
  redraw window
  fixLayout this
}

method setTitle Workspace s {
  setLabelString window s
}

method setFont Workspace fontName fontSize {
  setFont textBox fontName fontSize
}

to openWorkspace page contents {
  ws = (new 'Workspace')
  initialize ws contents
  setPosition (morph ws) (x (hand page)) (y (hand page))
  addPart page ws
  return ws
}
// Zipfile.gp - Read and write ZIP files
//
// To build a zip file: create, addFile, contents
// To read a zip file: read, fileNames, extractFile
// See zipTest for sample code.

defineClass ZipFile stream entries version fileEntryID dirEntryID endID crcTable

method entries ZipFile { return entries }

method zipTest ZipFile data outFileName {
  // Create, then read a zip file. If data is provided, include it in the
  // zip file. If outFileName is provided, write the zip data to that file.
  // Ex: zipTest (new 'ZipFile') (readFile '20000Leagues.txt') 'test.zip'

  if (isNil data) { data = 'This is file 2.' }
  zip = (create (new 'ZipFile'))
  addFile zip 'file1.txt' 'This is file 1.'
  addFile zip 'file2.txt' data true
  data = (contents zip)
  if (notNil outFileName) { writeFile outFileName data }

  reader = (read (new 'ZipFile') data)
  fileNames = (fileNames reader)
  print 'Read' (count fileNames) 'files:'
  for fileName fileNames {
	fileData = (extractFile reader fileName)
    print '  ' fileName (byteCount fileData) 'bytes'
  }
}

// Entry points - writing

method create ZipFile {
  // Prepare for writing.

  initConstants this
  entries = (table 'fileName' 'fileData' 'compressionMethod' 'offset' 'uncompressedSize' 'compressedSize' 'dosTime' 'crc')
  return this
}

method addFile ZipFile fileName fileData useCompression {
  // Add the given file to this zip file.

  if (isNil useCompression) { useCompression = false }
  i = (find entries 'fileName' fileName)
  if (i != 0) { removeRow entries i } // remove old entry for fileName, if any
  compressionMethod = 0
  if useCompression { compressionMethod = 8 }
  add entries fileName fileData compressionMethod
}

method contents ZipFile {
  // Call this method after creating and adding files.
  // Builds a zip file from the files added and returns its contents (a BinaryData).

  stream = (dataStream (newBinaryData 100000) false) // little endian
  for r (rowCount entries) {
    writeEntry this r
  }
  finishWriting this
  return (contents stream)
}

// Entry points - reading

method read ZipFile data {
  // Read the given zip file data and read its directory.
  // Files can then be read using extractFile.

  initConstants this
  stream = (dataStream data false) // little endian
  entries = (table 'fileName' 'dosTime' 'offset' 'compressionMethod' 'uncompressedSize' 'compressedSize' 'crc')
  findEndRecord this
  entryCount = (readEndRecord this) // positions stream at the first directory entry
  for i entryCount { readDirectoryEntry this }
  return this
}

method fileNames ZipFile {
  return (column entries 'fileName')
}

method extractNestedFile ZipFile fileName {
  for fullPath (fileNames this) {
	if ((filePart fullPath) == fileName) {
	  return (extractFile this fullPath)
	}
  }
  return nil
}

method extractFile ZipFile fileName {
  // Extract and return the given file, or nil if the file is missing.
  // Details: Read the file entry data. Decompress the file contents, if necessary, and check the CRC.

  entryIndex = (find entries 'fileName' fileName)
  if (entryIndex == 0) { return nil }

  offset = (cellAt entries entryIndex 'offset')
  setPosition stream offset
  if (fileEntryID != (nextUInt32 stream)) { error 'zip: bad local file header' }

  versionNeeded = (nextUInt16 stream)
  flags = (nextUInt16 stream)
  compressionMethod = (nextUInt16 stream)
  dosTime = (nextUInt32 stream)
  crc = (nextUInt32 stream)
  compressedSize = (nextUInt32 stream)
  uncompressedSize = (nextUInt32 stream)
  nameLength = (nextUInt16 stream)
  extraLength = (nextUInt16 stream)
  fileName = (nextString stream nameLength)
  extra = (nextData stream extraLength)

  ignore versionNeeded dosTime uncompressedSize extra

  if ((flags & 8) != 0) {
	// use the sizes and crc values from directory entry
	// (these values are also stored following the data)
	compressedSize = (cellAt entries entryIndex 'compressedSize')
	uncompressedSize = (cellAt entries entryIndex 'uncompressedSize')
	crc = (cellAt entries entryIndex 'crc')
  }

  if ((flags & 1) != 0) { error 'zip: cannot read encrypted files' }
  if (and (compressionMethod != 0) (compressionMethod != 8)) {
    error (join 'zip: cannot handle zip compression method' compressionMethod)
  }

  data = (nextData stream compressedSize)
  if (compressionMethod == 8) {
	data = (inflate data)
  }
  if (crc != (crc data)) { error (join 'zip: bad CRC for ' fileName) }

  return data
}

// utilities

method initConstants ZipFile {
  version = 10
  fileEntryID = (hex '04034b50')
  dirEntryID = (hex '02014b50')
  endID = (hex '06054b50')
}

// utilities - writing

method writeEntry ZipFile e {
  fileName = (cellAt entries e 'fileName')
  compressionMethod = (cellAt entries e 'compressionMethod')
  data = (cellAt entries e 'fileData')
  uncompressedSize = (byteCount data)
  crc = (crc data)
  dosTime = (dosTime this)
  cellAtPut entries e 'offset' (position stream)
  cellAtPut entries e 'uncompressedSize' uncompressedSize
  cellAtPut entries e 'compressedSize' uncompressedSize
  cellAtPut entries e 'dosTime' dosTime
  cellAtPut entries e 'crc' crc
  if (compressionMethod == 8) {
	data = (deflate data)
	cellAtPut entries e 'compressedSize' (byteCount data)
  }

  // write file entry
  putUInt32 stream fileEntryID
  putUInt16 stream version
  putUInt16 stream 0 // flags
  putUInt16 stream compressionMethod
  putUInt32 stream dosTime
  putUInt32 stream crc
  putUInt32 stream (byteCount data)
  putUInt32 stream uncompressedSize
  putUInt16 stream (byteCount fileName)
  putUInt16 stream 0 // extra info length
  nextPutAll stream fileName
  nextPutAll stream data
}

method finishWriting ZipFile {
  // Write the central directory and end record.

  dirStart = (position stream)

  // write directory entries
  for e (rowCount entries) {
	fileName = (cellAt entries e 'fileName')
	putUInt32 stream dirEntryID
	putUInt16 stream version // created by version
	putUInt16 stream version // minimum version needed to extract
	putUInt16 stream 0 // flags
	putUInt16 stream (cellAt entries e 'compressionMethod')
	putUInt32 stream (cellAt entries e 'dosTime')
	putUInt32 stream (cellAt entries e 'crc')
	putUInt32 stream (cellAt entries e 'compressedSize')
	putUInt32 stream (cellAt entries e 'uncompressedSize')
	putUInt16 stream (byteCount fileName)
	putUInt16 stream 0 // extra info length
	putUInt16 stream 0 // comment length
	putUInt16 stream 0 // starting disk number
	putUInt16 stream 0 // internal file attributes
	putUInt32 stream 0 // external file attributes
	putUInt32 stream (cellAt entries e 'offset')
	nextPutAll stream fileName
  }

  // write the end record
  dirSize = ((position stream) - dirStart)
  entryCount = (rowCount entries)
  putUInt32 stream endID
  putUInt16 stream 0			// number of this disk
  putUInt16 stream 0			// central directory start disk
  putUInt16 stream entryCount	// number of directory entries on this disk
  putUInt16 stream entryCount	// total number of directory entries
  putUInt32 stream dirSize		// length of central directory in bytes
  putUInt32 stream dirStart		// offset of central directory from start of file
  putUInt32 stream 0			// comment length
}

method dosTime ZipFile {
  dateAndTime = (secondsToDateAndTime (at (time) 1))
  year = ((at dateAndTime 1) - 1980)
  month = (at dateAndTime 2)
  day = (at dateAndTime 3)
  hour = (at dateAndTime 4)
  minute = (at dateAndTime 5)
  second = (at dateAndTime 6)
  return (((toLargeInteger year) << 25) | (+ (month << 21) (day << 16) (hour << 11) (minute << 5) (second >> 1)))
}

// utilities - reading

method findEndRecord ZipFile {
  // Scan backwards from the end of the data to the last EndOfCentralDiretory record.
  // If successful, leave the buffer positioned at the start of that record.
  data = (data stream)
  i = ((byteCount data) - 4)
  while (i >= 0) {
     if ((byteAt data i) == 80) { // found first byte of possible endID
	  setPosition stream (i - 1)
	  if (endID == (nextUInt32 stream)) { // found complete endID
	    setPosition stream (i - 1)
		return
	  }
	}
	i += -1
  }
}

method readEndRecord ZipFile {
  // Read the end-of-central-directory record. If successful, leave the stream
  // positioned at the start of the directory and return the number of entries.

  if (endID != (nextUInt32 stream)) { error 'zip: bad zip end record' }

  thisDiskNum = (nextUInt16 stream)
  startDiskNum = (nextUInt16 stream)
  entriesOnThisDisk = (nextUInt16 stream)
  totalEntries = (nextUInt16 stream)
  directorySize = (nextUInt32 stream)
  directoryOffset = (nextUInt32 stream)
  commentLength = (nextUInt16 stream)
  comment = (nextString stream commentLength)
  ignore directorySize comment

  if (or (thisDiskNum != startDiskNum) (entriesOnThisDisk != totalEntries)) {
	error 'cannot read multiple disk zip files'
  }
  setPosition stream directoryOffset
  return totalEntries
}

method readDirectoryEntry ZipFile {
  // Add the directory entry at the current stream position to the entries table.

  if (dirEntryID != (nextUInt32 stream)) { error 'zip: bad central directory entry' }

  versionMadeBy = (nextUInt16 stream)
  versionNeeded = (nextUInt16 stream)
  flags = (nextUInt16 stream)
  compressionMethod = (nextUInt16 stream)
  dosTime = (nextUInt32 stream)
  crc = (nextUInt32 stream)
  compressedSize = (nextUInt32 stream)
  uncompressedSize = (nextUInt32 stream)
  nameLength = (nextUInt16 stream)
  extraLength = (nextUInt16 stream)
  commentLength = (nextUInt16 stream)
  diskNum = (nextUInt16 stream)
  internalAttributes = (nextUInt16 stream)
  externalAttributes = (nextUInt32 stream)
  offset = (nextUInt32 stream)
  fileName = (nextString stream nameLength)
  extra = (nextData stream extraLength)
  comment = (nextString stream commentLength)

  ignore versionMadeBy versionNeeded flags diskNum internalAttributes externalAttributes extra comment

  add entries fileName dosTime offset compressionMethod uncompressedSize compressedSize crc
}
to assert v1 v2 message {
  if (isNil message) { message = '' }
  if (v1 == v2) {
     print 'ok'
     return true
  } else {
     print message v2 'expected, but got' v1
     return false
  }
}

to assertNotEqual v1 v2 message {
  if (isNil message) { message = '' }
  if (not (v1 == v2)) {
     print 'ok'
     return true
  } else {
     print message v2 'not expected'
     return false
  }
}
to base64Encode data {
  digits = (letters 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/')
  newline = (newline)
  result = (list)
  last = ((byteCount data) - 2)
  i = 1
  while (i <= last) {
	n = (+ ((byteAt data i) << 16) ((byteAt data (i + 1)) << 8) (byteAt data (i + 2)))
	add result (at digits (((n >> 18) & 63) + 1))
	add result (at digits (((n >> 12) & 63) + 1))
	add result (at digits (((n >> 6) & 63) + 1))
	add result (at digits ((n & 63) + 1))
	i += 3
	if (((i - 1) % 60) == 0) { add result newline }
  }
  extra = ((byteCount data) % 3)
  if (2 == extra) {
	n = (+ ((byteAt data i) << 16) ((byteAt data (i + 1)) << 8))
	add result (at digits (((n >> 18) & 63) + 1))
	add result (at digits (((n >> 12) & 63) + 1))
	add result (at digits (((n >> 6) & 63) + 1))
	add result '='
  } (1 == extra) {
	n = ((byteAt data i) << 16)
	add result (at digits (((n >> 18) & 63) + 1))
	add result (at digits (((n >> 12) & 63) + 1))
	add result '=='
  }
  return (joinStrings result)
}

to base64Decode aString {
  stream = (dataStream (newBinaryData (byteCount aString)))
  buf = 0
  bufCount = 0
  for ch (letters aString) {
	if (and ('A' <= ch) (ch <= 'Z')) {
	  sixBits = ((byteAt ch 1) - 65)
	} (and ('a' <= ch) (ch <= 'z')) {
	  sixBits = (((byteAt ch 1) - 97) + 26)
	} (and ('0' <= ch) (ch <= '9')) {
	  sixBits = (((byteAt ch 1) - 48) + 52)
	} ('+' == ch) {
	  sixBits = 62
	} ('/' == ch) {
	  sixBits = 63
	} else {
	  sixBits = nil
	}
	if (notNil sixBits) {
	  buf = ((buf << 6) + sixBits)
	  bufCount += 1
	}
	if (bufCount == 4) {
	  putUInt8 stream ((buf >> 16) & 255)
	  putUInt8 stream ((buf >> 8) & 255)
	  putUInt8 stream (buf & 255)
	  buf = 0
	  bufCount = 0
	}
  }
  if (bufCount > 0) { // write partial buffer (bufCount = 2 or 3)
	buf = (buf << ((4 - bufCount) * 6)) // zero-pad on right
	putUInt8 stream ((buf >> 16) & 255)
	if (bufCount > 2) { putUInt8 stream ((buf >> 8) & 255) }
  }
  return (contents stream)
}
to whenBroadcastReceived msg data {
  // Defines a broadcast responder for msg (a String). A class
  // can have zero, one, or many responders for any given message.
  // The body of the responder can use the argument 'data' to
  // access the message data, if any was provided.
}

// The following stub allows old projects containing monitors to
// be opened so that obsolete monitors can be replaced.
to callImplicitSelfReporter { return 'replace this monitor!' }

to send msgName dstMorphs msgData {
  // The send block is the new way to broadcast to specific receiver(s).
  // The receiver or receiver list is the second argument with msgData (if any) last.
  broadcast msgName msgData dstMorphs
}

to broadcast msgName msgData dstMorphs {
  // Broadcast a message to the given morphs and return the resulting list of tasks.

  page = (global 'page')
  if (isNil page) { return }
  tasks = (list)
  uninterruptedly {
	for m (broadcastDestinations dstMorphs) {
	  for pair (respondersForBroadcast (handler m) msgName) {
		rcvr = (first pair)
		func = (last pair)
		task = (launch page (newReporter 'call' func (handler m) msgData) rcvr)
		setTopBlock task (cmdList func)
		add tasks task
	  }
	}
  }
  return tasks
}

to broadcastAndWait msgName msgData dstMorphs {
  // obsolete
  gather msgName dstMorphs msgData
}

to gather msgName dstMorphs msgData {
  tasks = (broadcast msgName msgData dstMorphs)
  if (isEmpty tasks) { return tasks }
  while (someTaskInProgress tasks) {
	waitForNextFrame
  }
  result = (list)
  for t tasks {
	if (notNil (result t)) { add result (result t) }
  }
  return (toArray result)
}

to someTaskInProgress taskList {
  // Return true if any task in the given list is still running.
  for t taskList {
	if (not (isTerminated t)) { return true }
  }
  return false
}

to broadcastDestinationsNEW dstList { // not currently used!
  // Return a list of morphs for the given destination list,
  // including both the destination morph and its parts.
  // If dstList is nil, use the owner of the implicit receiver.

  if (isNil dstList) { // no dstList; use implicit receiver's owner
	rcvr = (implicitReceiver)
	if (and (hasField rcvr 'morph') (notNil (owner (getField rcvr 'morph')))) {
	  dstList = (array (owner (getField rcvr 'morph')))
	} else {
	  dstList = (array (self_stageMorph))
	}
  } (not (isAnyClass dstList 'List' 'Array')) { // convert singleton to array
	dstList = (array dstList)
  }
  result = (list)
  for m dstList {
	if (hasField m 'morph') {
	  m = (getField m 'morph')
	}
	if (isClass m 'Morph') {
	  add result m
	  addAll result (parts m)
	}
  }
  return (toArray result)
}

to broadcastDestinations dstList {
  if (isNil dstList) { // broadcast to all morphs
	dstList = (allMorphs (self_stageMorph) true)
  } (not (isAnyClass dstList 'List' 'Array')) { // convert singleton to array
	dstList = (array dstList)
  }
  result = (list)
  for dst dstList { // replace handlers in result, if any, with their morphs
	if (and (not (isClass dst 'Morph')) (hasField dst 'morph')) {
	  add result (getField dst 'morph')
	}
	if (implements dst 'handler') { // destinations must implement 'handler' (as morphs do)
	  add result dst
	}
  }
  return result
}

to respondersForBroadcast handler msgName {
  scripts = (scripts (classOf handler))
  if (isNil scripts) { return (array) }

  result = (list)
  for entry scripts { // a script is an array: (x, y, cmd)
	cmd = (at entry 3)
	if (and (isAnyClass cmd 'Command' 'Reporter') ('whenBroadcastReceived' == (primName cmd))) {
	  args = (argList cmd)
	  if ((first args) == msgName) {
		// Create a function to run in the context of the handler
		// with the message data as the second argument.
		paramName = 'data'
		if ((count args) > 1) { paramName = (at args 2) }
		func = (functionFor handler paramName cmd)
		setField func 'functionName' (join 'broadcast: ' msgName)
		add result (array handler func)
	  }
	}
  }
  return result
}

// event hat block stubs

to whenClicked {}
to whenDropped {}
to whenKeyPressed {}
to whenPageResized {}
to whenScrolled scrollX scrollY {}
to whenTracking {}

// event dispatching

to dispatchEvent targetObj evtName evtArg1 evtArg2 {
  // Dispatch an event to the given handler. Return true if
  // at least one event hat was found, false otherwise.
  // The arguments evtArg1 evtArg2 are optional.

  page = (global 'page')
  evtHandled = false
  uninterruptedly {
	for pair (respondersForEvent targetObj evtName evtArg1) {
	  evtHandled = true
	  rcvr = (first pair)
	  func = (last pair)
	  task = (launch page (newCommand 'call' func rcvr evtArg1 evtArg2) rcvr)
	  setTopBlock task (cmdList func)
	}
  }
  return evtHandled
}

to dispatchKeyPressedEvent targetObj keyName {
  // Dispatch a whenKeyPressed event to all morphs. Return true
  // if at least one event hat was found, false otherwise.
  // The arguments evtArg1 evtArg2 are optional.

  page = (global 'page')
  uninterruptedly {
    for m (allMorphs (morph targetObj) true) {
      for pair (respondersForEvent (handler m) 'whenKeyPressed' keyName) {
		rcvr = (first pair)
		func = (last pair)
		task = (launch page (newCommand 'call' func rcvr keyName) rcvr)
		setTopBlock task (cmdList func)
	  }
	}
  }
}

to respondersForEvent targetObj evtName keyName {
  result = (list)
  scripts = (scripts (classOf targetObj))
  if (isNil scripts) { return result }

  for entry scripts { // a script is an array: (x, y, cmd)
	cmd = (at entry 3)
	if (and (isAnyClass cmd 'Command' 'Reporter') ((primName cmd) == evtName)) {
	  func = nil
	  args = (argList cmd)
	  if (isOneOf evtName 'whenScrolled' 'whenTracking') {
		func = (functionFor targetObj (at args 1) (at args 2) cmd)
	  } ('whenKeyPressed' == evtName) {
		hatKey = (first (argList cmd))
		paramName = 'key'
		if ((count args) > 1) { paramName = (at args 2) }
		if (or ('any' == hatKey) (keyName == hatKey)) {
		  func = (functionFor targetObj paramName cmd)
		}
	  } else {
		func = (functionFor targetObj cmd)
	  }
	  if (notNil func) {
		setField func 'functionName' (join 'event: ' evtName)
		add result (array targetObj func)
	  }
	}
  }
  return result
}
// explore GP objects

defineClass ExplorerNode name value parent

to exploreNode name value parent {return (new 'ExplorerNode' name value parent)}

method name ExplorerNode {return name}
method value ExplorerNode {return value}
method setValue ExplorerNode newValue {value = newValue}
method parent ExplorerNode {return parent}

method fields ExplorerNode {
  ans = (list)
  if (isAnyClass value 'String' 'Float' 'ExternalReference' 'BinaryData') {
    return ans
  }
  if (isClass value 'Dictionary') {
	for k (sorted (keys value)) {
	  add ans (exploreNode k (at value k) this)
	}
  } (isClass value 'List') {
	for i (min 1000 (count value)) {
	  add ans (exploreNode i (at value i) this)
	}
  } else {
	fieldNames = (fieldNames (classOf value))
	for i (min 1000 (objWords value)) {
	  if (i <= (count fieldNames)) {
		slot = (at fieldNames i)
	  } else {
		slot = i
	  }
	  add ans (exploreNode slot (getField value slot) this)
	}
  }
  return ans
}

method path ExplorerNode {
  ans = (list)
  cur = this
  while (notNil (name cur)) {
    add ans (name cur)
    cur = (parent cur)
  }
  add ans (value cur)
  return (reversed (toArray ans))
}

defineClass Explorer morph window contents listBox listFrame tabs tabsFrame readouts fieldFrame evalBox evalFrame resizer

method initialize Explorer {
  scale = (global 'scale')
  window = (window (labelName this))
  stayWithin (getField window 'resizer') (action 'windowConstraint' this)
  clr = (clientColor window)
  border = (border window)
  morph = (morph window)
  setHandler morph this
  setMinExtent morph (scale * 130) (scale * 100)
  setFPS morph 3

  listBox = (treeBox
    nil
    (exploreNode nil contents)
    'name'
    'fields'
    (action 'selectField' this)
    clr
    (action 'exploreField' this)
    nil
    true
  )

  listFrame = (scrollFrame listBox clr)
  setExtent (morph listFrame) (* scale 80)
  resizer = (resizeHandle listFrame 'horizontal')
  clearCostumes (getField resizer 'trigger')
  stayWithin resizer (action 'listFrameConstraint' this)
  addPart morph (morph listFrame)

  tabs = (tabBar (array 'basic') nil (action 'tab' this))
  tabsFrame = (newMorph)
  setClipping tabsFrame true true
  addPart tabsFrame (morph tabs)
  addPart morph tabsFrame
  hide tabsFrame

  basicReadout = (newText)
  setBorders basicReadout border border true
  setEditRule basicReadout 'code'
  setCodeContext basicReadout contents
  setGrabRule (morph basicReadout) 'ignore'

  readouts = (dictionary)
  atPut readouts 'basic' basicReadout

  fieldFrame = (scrollFrame basicReadout clr)
  addPart morph (morph fieldFrame)

  evalBox = (newText)
  setBorders evalBox border border true
  setEditRule evalBox 'code'
  setCodeContext evalBox contents
  setGrabRule (morph evalBox) 'ignore'
  evalFrame = (scrollFrame evalBox clr)
  addPart morph (morph evalFrame)

  setExtent morph (scale * 500) (scale * 300)
  setPosition morph 5 57

  setFramePadding (alignment tabs) (4 * scale)
  fixLayout (alignment tabs)
  select tabs 'basic'
}

method fixLayout Explorer {
  fixLayout window
  clientArea = (clientArea window)
  border = (border window)

  setPosition (morph listFrame) (left clientArea) (top clientArea)
  setExtent (morph listFrame) nil (height clientArea)

  setBounds (morph resizer) (rect (right (morph listFrame)) (top clientArea) border (height clientArea))

  tp = (top clientArea)
  w = (- (- (width clientArea) (width (morph listFrame))) border)
  h = 0
  if (isVisible tabsFrame) {
    h = (height (morph tabs))
    setPosition tabsFrame (+ (right (morph listFrame)) border) tp
    setExtent tabsFrame w h
    tp = (bottom tabsFrame)
  }

  setPosition (morph fieldFrame) (+ (right (morph listFrame)) border) tp
  setExtent (morph fieldFrame) w ((((height clientArea) / 3) * 2) - h)

  setPosition (morph evalFrame) (left (morph fieldFrame)) (+ (bottom (morph fieldFrame)) border)
  setExtent (morph evalFrame) w ((bottom clientArea) - (+ border (bottom (morph fieldFrame))))
  addPart morph (morph resizer) // bring to front
}

method redraw Explorer {
  redraw window
  fixLayout this
}

method listFrameConstraint Explorer {return (insetBy (clientArea window) ((global 'scale') * 20))}

method windowConstraint Explorer {
  c = (resizingConstraint morph)
  l =  (+ (border window) (right (morph listBox)))
  t = (top (clientArea window))
  return (array (max l (first c)) (max t (last c)))
}

method selectField Explorer aNode {
  basicReadout = (at readouts 'basic')
  readouts = (dictionary)
  atPut readouts 'basic' basicReadout

  if (shiftKeyDown (keyboard (handler (root morph)))) {
    unselect listBox
    setText (at readouts 'basic') ''
    select tabs 'basic'
    return
  }

  val = (selectedValue this)
  setText (at readouts 'basic') (printString val)

  info = (fieldInfo (value (parent aNode)) (name aNode))
  if (notNil info) {
    atPut readouts (at info 'type') (readoutFor this info)
  }

  if (isClass val 'Boolean') {
    atPut readouts 'switch' (switchReadout this)
    setCollection tabs (keys readouts)
  } else {
    setCollection tabs (keys readouts)
  }
  if (2 > (count (keys readouts))) {
    hide tabsFrame
  } else {
    show tabsFrame
  }
  select tabs (last (keys readouts))
  fixLayout this
}

method labelName Explorer {
  if (contains (array 65 97 69 101 73 105 79 111 85 117) (byteAt (className (classOf contents)) 1)) {
    pref = 'an '
  } else {
    pref = 'a '
  }
  if (or (isNil contents) (true === contents) (false === contents)
		 (isClass contents 'Integer') (isClass contents 'Float')
		 (isClass contents 'String') (isClass contents 'ExternalReferences')) {
	cts = (join ': ' (printString contents))
  } else {
    cts = ''
  }
  return (join pref (className (classOf contents)) cts)
}

method tab Explorer tabName {
  padding = (border window)
  if (tabName == 'basic') {padding = 0}
  setContents fieldFrame (at readouts tabName) padding
}

method exploreField Explorer {
  page = (handler (root morph))
  ins = (explorerOn (selectedValue this))
  setPosition (morph ins) (x (hand page)) (y (hand page))
  addPart (morph page) (morph ins)
}

method textChanged Explorer origin {if (origin === (at readouts 'basic')) {pushCurrentField this}}

method pushCurrentField Explorer {
  sel = (selection listBox)
  if (isNil sel) {return}
  node = (data sel)
  result = (eval (join '(id ' (text (at readouts 'basic')) ')') contents)
  setNodeValue this node result
  select sel
}

method setNodeValue Explorer node value {
  parentObj = (value (parent node))
  if (isAnyClass parentObj 'Dictionary' 'List') {
	atPut parentObj (name node) value
  } else {
	setField parentObj (name node) value
  }
  setValue node value
}

method step Explorer {
  // update window label
  lbl = (labelName this)
  if (!= lbl (labelString window)) {
    setLabelString window lbl
  }

  // update fieldNames - tbd

  // update readout
  if (isNil (selection listBox)) {return}
  basicReadout = (at readouts 'basic')
  if (notNil (owner (morph basicReadout))) {
    result = (printString (selectedValue this))
    if (or (notNil (caret basicReadout)) (result == (text basicReadout))) {return}
    setText basicReadout result
  } else {
    update (at readouts (selection tabs))
  }
}

to explorerOn anObject {
  ins = (new 'Explorer' nil nil anObject)
  initialize ins
  return ins
}

to openExplorer obj {
  page = (global 'page')
  if (isNil page) {
    explore obj
	return
  }
  addPart page (explorerOn obj)
}

// context menus

method rightClicked Explorer hand {
  popUpAtHand (contextMenu this) (page hand)
  return true
}

method handleContextRequest Explorer item {
  aTreeBox = (handler (morph item))
  if (isClass aTreeBox 'TreeBox') {
	popUpAtHand (fieldContextMenu this aTreeBox) (global 'page')
  }
}

method contextMenu Explorer {
  menu = (menu nil this)
  addItem menu 'basic inspect' (action 'openInspector' contents)
  addLine menu
  addItem menu (join 'browse class: ' (className (classOf contents))) (action 'browseClass' this (classOf contents))
  return menu
}

method fieldContextMenu Explorer aTreeBox {
  node = (data aTreeBox)
  cls = (classOf (value node))
  menu = (menu (name node) this)
  addItem menu 'explore' (action 'openExplorer' (value node))
  addItem menu 'basic inspect' (action 'openExplorer' (value node))
  if (isClass (value node) 'String') {
	addItem menu 'show text' (action 'showText' (joinStrings (wordWrapped (value node) 300) (newline)))
  }
  addLine menu
  addItem menu (join 'browse class: ' (className cls)) (action 'browseClass' this cls)
  return menu
}

method browseClass Explorer aClass {
  page = (page morph)
  brs = (newClassBrowser)
  setPosition (morph brs) (x (hand page)) (y (hand page))
  addPart page brs
  browse brs aClass
}

// readouts

to fieldInfo fieldName {return nil}

method selectedValue Explorer {
  if (isNil (selection listBox)) {return nil}
  path = (path (data (selection listBox)))
  result = (first path)
  for i (range 2 (count path)) {
	thisPart = (at path i)
	if (isAnyClass result 'Dictionary' 'List') {
	  result = (at result thisPart)
	} else {
	  result = (getField result thisPart)
	}
  }
  return result
}

method switchReadout Explorer {
  scale = (global 'scale')
  toggle = (toggleButton (action 'toggleField' this) (action 'selectedValue' this) (scale * 20) (scale * 13) (scale * 5) (max 1 (scale / 2)) false)
  return (readout 'switch' (value (parent (data (selection listBox)))) (name (data (selection listBox))) toggle 'refresh')
}

method toggleField Explorer {
  sel = (selection listBox)
  node = (data sel)
  result = (not (value node))
  setNodeValue this node result
  select sel
}

method readoutFor Explorer info {
  node = (data (selection listBox))
  if ('options' == (at info 'type')) {
    options = (listBox (at info 'options') 'id' (action 'setNodeValue' this node))
    return (readout 'options' (value (parent node)) (name node) options 'select')
  }
  error 'unsupported info type' (at info 'type')
}

method currentSelection Explorer {
  // answer the value of the currently selected field, if any
  sel = (selection listBox)
  if (isNil sel) {return nil}
  return (value (data sel))
}

method currentHighlight Explorer {
  // answer the value of the currently highlighted field, if any
  hl = (highlighted listBox)
  if (isNil hl) {return nil}
  return (value (data (handler (morph hl))))
}

method connectors Explorer {
  tp = (top (morph listFrame))
  bt = (bottom (morph listFrame))
  x = (hCenter (bounds (morph listFrame)))
  result = (list)
  for node (allVisibleNodes listBox) {
    dta = (value (data node))
    y = (min bt (max tp (vCenter (bounds (morph node)))))
    add result (array dta (array x y))
  }
  return result
}
defineClass Bitmap width height pixelData name

method width Bitmap { return width }
method height Bitmap { return height }
method pixelData Bitmap { return pixelData }
method name Bitmap { return name }
method setName Bitmap s { name = s }

to newBitmap width height color {
  gcIfNeededFor (width * height)
  width = (max 0 (ceiling width))
  height = (max 0 (ceiling height))
  pixelData = (newBinaryData (4 * (width * height)))
  bm = (new 'Bitmap' width height pixelData)
  if (notNil color) { fill bm color }
  setField bm 'name' ''
  return bm
}

to gcIfNeededFor words {
  buffer = 1000000
  stats = (memStats)
  bytesFree = ((at stats 2) - (at stats 1))
  if (((words + buffer) * 4) > bytesFree) {
	print 'gc needed to allocate bitmap;' (gc) 'freed'
  }
}

method fill Bitmap color {
  comment '
	Fill this bitmap with the given color (including alpha).'

  fillPixelsRGBA pixelData (red color) (green color) (blue color) (alpha color)
}

method fillAlpha Bitmap alpha {
  comment '
	Fill the alpha channel of this bitmap without changing the RGB channel.'

  if (isNil alpha) { alpha = 255 }
  for i (count pixelData) {
    rgb = (getPixelRGB pixelData i)
	setPixelRGBA pixelData i ((rgb >> 16) & 255) ((rgb >> 8) & 255) (rgb & 255) alpha
  }
}

method copy Bitmap {
  dup = (newBitmap width height)
  drawBitmap dup this
  if (notNil name) {
	if (endsWith name ' copy') {
	  setName dup name
	} else {
	  setName dup (join '' name ' copy')
	}
  }
  return dup
}

method getPixel Bitmap x y {
  comment '
	Return the color of the given pixel. x and y are zero-based offsets from the top-left corner.'

  if (or (x < 0) (x >= width) (y < 0) (y >= height)) { error 'bad pixel coordinate' }
  i = (toInteger (((y * width) + x) + 1))
  alpha = (getPixelAlpha pixelData i)
  rgb = (getPixelRGB pixelData i)
  return (color ((rgb >> 16) & 255) ((rgb >> 8) & 255) (rgb & 255) alpha)
}

method getAlpha Bitmap x y {
  comment '
	Return the alpha of the given pixel. x and y are zero-based offsets from the top-left corner.'

  if (or (x < 0) (x >= width) (y < 0) (y >= height)) { error 'bad pixel coordinate' }
  i = (toInteger (((y * width) + x) + 1))
  return (getPixelAlpha pixelData i)
}

method setPixel Bitmap x y color {
  comment '
	Set the color of the given pixel. x and y are zero-based offsets from the top-left corner.'

  if (or (x < 0) (x >= width) (y < 0) (y >= height)) { error 'bad pixel coordinate' }
  i = (toInteger (((y * width) + x) + 1))
  setPixelRGBA pixelData i (red color) (green color) (blue color) (alpha color)
}

method setRGBA Bitmap x y r g b a {
  comment '
	Set the color of the given pixel. x and y are zero-based offsets from the top-left corner.'

  if (0 == a) { // fully transparent pixel; set RGB to 0 (consistent with premultiplied alpha)
	r = 0
	g = 0
	b = 0
  }
  setPixelRGBA pixelData (toInteger (((y * width) + x) + 1)) r g b a
}

// transformations

method thumbnail Bitmap w h {
  // Create a thumbnail of this bitmap with given width and height.
  w = (max 0 (floor w))
  h = (max 0 (floor h))
  result = (newBitmap w h)
  if (or (width == 0) (height == 0)) { return result }

  scale = (min ((toFloat w) / width) ((toFloat h) / height))
  warpBitmap result this (w / 2) (h / 2) scale scale
  return result
}

method scaleAndRotate Bitmap xScale yScale rotationDegrees dstBitmap {
  // Return a copy of this bitmap scaled and rotated.
  // Rotation goes counter-clockwise as the angle increases.
  // If dstBitmap is provide and is the right size, recycle it.

  if (isNil yScale) { yScale = xScale }
  if (isNil rotationDegrees) { rotationDegrees = 0 }
  if (or (xScale <= 0) (yScale <= 0)) { error 'Scale must be greater than zero' }
  xOffset = 0
  yOffset = 0
  newW = (xScale * width)
  newH = (yScale * height)
  if (rotationDegrees != 0) {
	diagonal = (max 1 (sqrt ((newW * newW) + (newH * newH))))
	xOffset = (half (diagonal - newW))
	yOffset = (half (diagonal - newH))
	newW = diagonal
	newH = diagonal
  }
  result = (newBitmap (max 1 newW) (max 1 newH))
  warpBitmap result this (half newW) (half newH) xScale yScale rotationDegrees
  return result
}

method guessTransparentColor Bitmap {
  r = (width - 1)
  b = (height - 1)
  c = (getPixel this 0 0)
  if ((alpha c) == 0) { return c }
  c = (getPixel this r 0)
  if ((alpha c) == 0) { return c }
  c = (getPixel this 0 b)
  if ((alpha c) == 0) { return c }
  c = (getPixel this r b)
  if ((alpha c) == 0) { return c }
  setAlpha c 0
  return c
}

method cropTransparent Bitmap {
  // Return a bitmap cropped to remove any transparent borders around the image,
  // or the original bitmap if it can't be cropped any more.

  top = nil
  bottom = nil
  left = nil
  right = nil

  y = 0
  while (isNil top) {
    i = ((y * width) + 1)
	repeat width {
	  if ((getPixelAlpha pixelData i) > 0) { top = y }
	  i += 1
    }
	y += 1
	if (y >= height) { return (newBitmap 0 0) } // all pixels are transparent
  }

  y = (height - 1)
  while (isNil bottom) {
    i = ((y * width) + 1)
	repeat width {
	  if ((getPixelAlpha pixelData i) > 0) { bottom = y }
	  i += 1
    }
	y += -1
  }

  x = 0
  while (isNil left) {
	y = top
	while (y <= bottom) {
	  i = (((y * width) + x) + 1)
	  if ((getPixelAlpha pixelData i) > 0) { left = x }
	  y += 1
    }
	x += 1
  }

  x = (width - 1)
  while (isNil right) {
	y = top
	while (y <= bottom) {
	  i = (((y * width) + x) + 1)
	  if ((getPixelAlpha pixelData i) > 0) { right = x }
	  y += 1
    }
	x += -1
  }

  result = (newBitmap ((right - left) + 1) ((bottom - top) + 1))
  drawBitmap result this (0 - left) (0 - top) 255 0 // copy mode
  return result
}

method floodFillAt Bitmap startX startY newColor threshold {
  startX = (round startX)
  startY = (round startY)
  if (isNil threshold) { threshold = 0 }
  threshold = (clamp (truncate threshold) 0 7)
  mask = ((255 << threshold) & 255)
  mask = (((mask << 16) | (mask << 8)) | mask)

  w = (width this)
  h = (height this)
  pixels = pixelData
  seedIndex = (toInteger (((startY * w) + startX) + 1))
  if (or (seedIndex < 1) (seedIndex > (count pixels))) { return }
  unprocessed = (newArray (count pixels) true)
  matchRGB = (getPixelRGB pixels seedIndex)
  matchRGB = (matchRGB & mask)

  newR = (red newColor)
  newG = (green newColor)
  newB = (blue newColor)
  newA = (alpha newColor)

  todo = (list (array startX startY))
  while (notEmpty todo) {
    p = (removeLast todo)
	y = (at p 2)
	lineStart = ((w * y) + 1)
	lineEnd = ((lineStart + w) - 1)
	left = (lineStart + (at p 1))
	right = left
	while (and (left > lineStart) (((getPixelRGB pixels (left - 1)) & mask) == matchRGB)) { left += -1 }
	while (and (right < lineEnd) (((getPixelRGB pixels (right + 1)) & mask) == matchRGB)) { right += 1 }
	i = left
	while (i <= right) {
	  setPixelRGBA pixels i newR newG newB newA
	  atPut unprocessed i false
	  i += 1
	}

	// propagate fill to matching pixels in adjacent lines
	for offset (array -1 1) {
	  adjacentY = (y + offset)
	  if (and (adjacentY >= 0) (adjacentY < h)) { // if adjacentY is in range
		lineStart = ((w * adjacentY) + 1)
		run = false
		for i (range (left + (w * offset)) (right + (w * offset))) {
		  if (and (at unprocessed i) (((getPixelRGB pixels i) & mask) == matchRGB)) {
			if (not run) {
			  // only add one todo list entry for each run
			  x = (i - lineStart)
			  add todo (array x adjacentY)
			  run = true
			}
		  } else {
			run = false
		  }
		  atPut unprocessed i false
		}
	  }
	}
  }
}

// alpha channel masking

method extractAlphaChannel Bitmap {
  // Return the alpha channel data for this bitmap.

  result = (newBinaryData (width * height))
  for i (byteCount result) {
	byteAtPut result i (getPixelAlpha pixelData i)
  }
  return result
}

method applyAlphaChannel Bitmap alphaChannel color {
  // Fill this bitmap with the given color masked by
  // the given alpha channel.

  if (isNil color) { color = (color) }
  r = (red color)
  g = (green color)
  b = (blue color)
  fillPixelsRGBA pixelData 0 0 0 0
  count = (min (byteCount alphaChannel) (width * height))
  for i count {
	a = (byteAt alphaChannel i)
	if (a > 0) {
	  setPixelRGBA pixelData i r g b a
	}
  }
  return this
}

method toString Bitmap {
  return (join '<Bitmap ' width 'x' height '>')
}

// font utility

to fontHeight { return ((fontAscent) + (fontDescent)) }

// Textures (deprecated after Morphic rewrite)

defineClass Texture width height ref

method width Texture { return width }
method height Texture { return height }

to newTexture width height color {
  ref = (createTexture width height color)
  return (new 'Texture' width height ref)
}

method fill Texture color {
  comment '
	Fill this texture with the given color (including alpha).'

	fillRect this color 0 0 width height 0
}

method copyTexture Texture {
  result = (newTexture width height)
  showTexture result this 0 0 255 1 1 0 false 0
  return result
}

method destroyTexture Texture {
  comment '
	Destroy this texture. This frees the texture memory on the GPU.'

  destroyTexture ref
  ref = nil
}

method toBitmap Texture {
  result = (newBitmap width height)
  readTexture result this
  return result
}

method toTexture Bitmap {
  comment '
	Return a new texture with the contents of this bitmap.'

  if (or (width < 1) (height < 1)) { return (newTexture 1 1) }
  result = (newTexture width height)
  updateTexture result this
  return result
}

method toString Texture {
  return (join '<Texture ' width 'x' height '>')
}
// operations that call functions on arrays and lists

to map func values {
  comment '
	Return an array with the result of calling
	the given function on each element of values.'

  if (isClass func 'String') {
	func = (moduleFunctionOrOp func (module (caller (currentTask))))
  }
  result = (newArray (count values))
  for i (count values) {
    atPut result i (call func (at values i))
  }
  return (toList result)
}

to filter func values {
  comment '
	Return an array or list containing only those elements
	of values for which the function returns true.'

  if (isClass func 'String') {
	func = (moduleFunctionOrOp func (module (caller (currentTask))))
  }
  result = (list)
  for i (count values) {
    v = (at values i)
    if (call func v) { add result v }
  }
  return result
}

to detect func values valueIfNotFound {
  comment '
	Return the first element for which the function returns true.
	Otherwise, return valueIfNotFound.'

  if (isClass func 'String') {
	func = (moduleFunctionOrOp func (module (caller (currentTask))))
  }
  for i (count values) {
    v = (at values i)
    if (call func v) { return v }
  }
  return valueIfNotFound
}

to reduce func values valueIfEmpty {
  comment '
	Combime all elements with a two-argument function.
	If values is empty, return valueIfEmpty.'

  if (isClass func 'String') {
	func = (moduleFunctionOrOp func (module (caller (currentTask))))
  }
  if ((count values) == 0) { return valueIfEmpty }
  for i (count values) {
    if (i == 1) {
      result = (at values i)
    } else {
      result = (call func result (at values i))
    }
  }
  return result
}

to moduleFunctionOrOp opName module {
  // If a function with the given name is defined in module, return it.
  // Otherwise, return opName.

  for f (functions module) {
    if (opName == (functionName f)) { return f }
  }
  return opName
}
// json.gp - Parse and generate JSON

to jsonFormat s {
  // Return a formatted version of the given JSON string.

  return (jsonStringify (jsonParse s) true)
}

to jsonParse s {
  // Return the result of parsing the given JSON string.

  return (readValue (initialize (new 'JSONReader') s))
}

to jsonStringify obj formatFlag {
  // Encode the given JSON-encodable object as a JSON string. A JSON-encodable object
  // can be nil, a boolean/string/number, or an Array or Dictionary containing
  // JSON-encodable objects. If formatFlag is true, the result will be formatted with
  // space, tabs, and newlines to make it more readable by humans.

  return (stringify (initialize (new 'JSONWriter')) obj formatFlag)
}

// *** JSONReader ***

defineClass JSONReader src srcCount index

method initialize JSONReader s {
  src = (letters s)
  srcCount = (count src)
  index = 1
  return this
}

method notAtEnd JSONReader n {
  return (index <= srcCount)
}

method peek JSONReader {
  if (index > srcCount) { return nil }
  return (at src index)
}

method next JSONReader n {
  if (index > srcCount) { return nil }
  if (isNil n) { // return next character
	result = (at src index)
	index += 1
	return result
  }
  last = (min ((index + n) - 1) srcCount)
  result = (joinStrings (copyFromTo src index last))
  index += n
  return result
}

method skip JSONReader { index += 1 }

method skipWhiteSpace JSONReader n {
  while (and (index <= srcCount) ((byteAt (at src index) 1) <= 32)) {
	index += 1
  }
}

method readValue JSONReader {
  skipWhiteSpace this
  ch = (peek this)
  if (or (and ('0' <= ch) (ch <= '9')) ('-' == ch)) {
	return (readNumber this)
  } ('"' == ch) {
	return (readString this)
  } ('[' == ch) {
	return (readArray this)
  } ('{' == ch) {
	return (readObject this)
  } ('t' == ch) {
	if ('true' == (next this 4)) { return true }
	error 'Expected "true"'
  } ('f' == ch) {
	if ('false' == (next this 5)) { return false }
	error 'Expected "false"'
  } ('n' == ch) {
	if ('null' == (next this 4)) { return nil }
	error 'Expected "null"'
  } (isNil ch) {
	error 'Incomplete JSON data'
  } else {
	error 'Bad JSON character' ch
  }
}

method readNumber JSONReader {
  numStr = ''
  isFloat = false
  if ('-' == (peek this)) {
	skip this
	numStr = (join '-' (readDigits this))
	if ((count numStr) < 2) {
	  error 'At least one digit expected'
	}
  } else {
	numStr = (readDigits this)
  }
  if ('.' == (peek this)) {
	isFloat = true
	skip this
	numStr = (join numStr '.' (readDigits this))
  }
  ch = (peek this)
  if (or ('e' == ch) ('E' == ch)) {
	skip this
	isFloat = true
	numStr = (join numStr 'E')
	ch = (peek this)
	if ('+' == ch) {
	  skip this
	} ('-' == ch) {
	  skip this
	  numStr = (join numStr '-')
	}
	numStr = (join numStr (readDigits this))
  }
  if isFloat {
	num = (toNumber numStr)
  } else {
	num = (toNumber (join numStr '.0')) // parse as a Float to handle a larger range
	if (and (-1073741824.0 <= num) (num <= 1073741823.0)) {
	  num = (toInteger num)
	}
  }
  return num
}

method readDigits JSONReader {
  result = (list)
  while true {
	ch = (peek this)
	if (and ('0' <= ch) (ch <= '9')) {
	  add result ch
	  index += 1
	} else {
	  return (joinStrings result)
	}
  }
}

method readString JSONReader {
  result = (list)
  skip this // opening quote
  while (notAtEnd this) {
	ch = (next this)
	if ('"' == ch) {
	  return (joinStrings result)
	} ('\' == ch) {
	  add result (readEscapedChar this)
	} else {
	  add result ch
	}
  }
  error 'Incomplete string'
}

method readEscapedChar JSONReader {
  ch = (next this)
  if ('b' == ch) {
	return (string 8)
  } ('f' == ch) {
	return (string 12)
  } ('n' == ch) {
	return (string 10)
  } ('r' == ch) {
	return (string 13)
  } ('t' == ch) {
	return (string 9)
  } ('u' == ch) {
	return (stringFromCodePoints (array (hex (next this 4))))
  } else {
	return ch // handles back slash, forward slash (solidus), double-quote
  }
}

method readArray JSONReader {
  result = (list)
  skip this // opening '['
  done = false
  while (notAtEnd this) {
	skipWhiteSpace this
	if (']' == (peek this)) {
	  skip this
	  return result
	}
	add result (readValue this)
	skipWhiteSpace this
	ch = (peek this)
	if (',' == ch) {
	  skip this
	} (']' != ch) {
	  error 'Missing comma in array'
	}
  }
  error 'Incomplete array'
}

method readObject JSONReader {
  result = (dictionary)
  skip this // opening '{'
  done = false
  while (notAtEnd this) {
	skipWhiteSpace this
	if ('}' == (peek this)) {
	  skip this
	  return result
	}
	if ('"' != (peek this)) { error 'Bad object syntax: keys must be strings' }
	key = (readString this)
	skipWhiteSpace this
	if (':' == (peek this)) {
	  skip this
	} else {
	  error 'Bad object syntax: missing colon'
	}
	skipWhiteSpace this
	value = (readValue this)
	atPut result key value

	skipWhiteSpace this
	if (',' == (peek this)) {
	  skip this
	} ('}' != (peek this))  {
	  error 'Missing comma in object'
	}
  }
  error 'Incomplete object'
}

// *** JSONWriter ***

defineClass JSONWriter buf tabs needsComma doFormatting

method initialize JSONWriter s {
  buf = (list)
  tabs = ''
  needsComma = false
  doFormatting = false
  return this
}

method stringify JSONWriter obj formatFlag {
  if (isNil formatFlag) { formatFlag = false }
  doFormatting = formatFlag
  writeObject this obj
  return (joinStrings buf)
}

method writeObject JSONWriter obj {
  if (isAnyClass obj 'Integer' 'Float' 'Boolean' 'Nil') {
	add buf (toString obj)
	return
  } (isClass obj 'String') {
	writeString this obj
  } (isClass obj 'Array') {
	writeArray this obj
  } (isClass obj 'Dictionary') {
	writeDictionary this obj
  } (isClass obj 'List') {
	writeArray this (toArray obj)
  } else {
	error (join 'JSON cannot represent objects of class ' (className (classOf obj)))
  }
}

method writeArray JSONWriter array {
  add buf '['
  count = (count array)
  for i count {
	writeObject this (at array i)
	if (i < count) { add buf ', ' }
  }
  add buf ']'
}

method writeDictionary JSONWriter dictionary {
  indent this
  lineStart = (join (newline) tabs)
  add buf '{'
  keys = (sorted (keys dictionary))
  count = (count keys)
  for i count {
	key = (at keys i)
	if doFormatting { add buf lineStart }
	writeString this key
	add buf ': '
	writeObject this (at dictionary key)
	if (i < count) { add buf ', ' }
  }
  outdent this
  if doFormatting { add buf (join (newline) tabs) }
  add buf '}'
}

method indent JSONWriter {
  tabs = (join tabs (string 9))
}

method outdent JSONWriter {
  if ((count tabs) > 0) {
	tabs = (substring tabs 1 ((count tabs) - 1))
  }
}

method writeString JSONWriter s {
  letters = (letters s)
  if (needsEscapes this letters) { s = (escape this letters) }
  add buf (join '"' s '"')
}

method needsEscapes JSONWriter letters {
  for ch letters {
	if (or (ch == '"') (ch == '\') ((byteAt ch 1) < 32)) {
	  return true
	}
  }
  return false
}

method escape JSONWriter letters {
  result = (list)
  for ch letters {
	ascii = (byteAt ch 1)
	if (or (ch == '"') (ch == '\')) {
	  add result '\'
	  add result ch
	} (ascii < 32) {
	  add result '\'
	  if (8 == ascii) {
		add result 'b'
	  } (9 == ascii) {
		add result 't'
	  } (10 == ascii) {
		add result 'n'
	  } (12 == ascii) {
		add result 'f'
	  } (13 == ascii) {
		add result 'r'
	  } else {
		hex = (toStringBase16 ascii)
		while ((count hex) < 4) {
		  hex = (join '0' hex)
		}
		add result 'u'
		add result hex
	  }
	} else {
		add result ch
	}
  }
  return (joinStrings result)
}
to basicHTTPGet host path port {
	// Return the body of the HTTP response as a string. Return empty string if request fails.

	return (toString (basicHTTPGetBinary host path port))
}

to basicHTTPGetBinary host path port {
	// Return the body of the HTTP response as binary data or empty BinaryData if request fails.

	response = (basicHTTPGetResponse host path port)
	i = (basicHTTPHeaderStart response)
	if (i > 0) { return (copyFromTo response (i + 4)) } // copy without headers
	return response // no header break found, so assume headers already removed
}

to basicHTTPGetHeaders host path port {
	// Return the headers of the HTTP response as a string or empty string if not found.

	response = (basicHTTPGetResponse host path port)
	i = (basicHTTPHeaderStart response)
	if (i < 1) { return '' }
	return (toString (copyFromTo response 1 i))
}

to basicHTTPHeaderStart data {
	for i (byteCount data) {
		// find the end of the header (byte sequence: 13 10 13 10)
		if (and
			(13 == (byteAt data i))
			(10 == (byteAt data (i + 1)))
			(13 == (byteAt data (i + 2)))
			(10 == (byteAt data (i + 3)))
		) {
			return i
		}
	}
	return -1
}

to basicHTTPGetResponse host path port {
	// Return the entire HTTP response, including headers, as binary data.

	if (isNil path) { path = '/' }
	if (isNil port) { port = 80 }
	if ('Browser' == (platform)) {
		url = (join 'http://' host path)
		if (80 != port) { url = (join url ':' port) }
		return (httpGetInBrowser url)
	}
	socket = (openClientSocket host port)
	if (isNil socket) { return (newBinaryData) }
	nl = (string 13 10)
	request = (join
		'GET ' path ' HTTP/1.1' nl
		'Host: ' host nl
		'Accept:' 'application/octet-stream' nl nl)
	writeSocket socket request
	waitMSecs 1000 // wait a bit
	response = (newBinaryData)
	count = 1 // start loop
	while (count > 0) {
		chunk = (readSocket socket true)
		count = (byteCount chunk)
		if (count == 0) {
			waitMSecs 600
			chunk = (readSocket socket true)
			count = (byteCount chunk)
		}
		if (count > 0) {
			response = (join response chunk)
			waitMSecs 50
		}
	}
	closeSocket socket
	return response
}

to httpGetInBrowser url timeout {
	if (isNil timeout) { timeout = 1000 }
	if (and (beginsWith (browserURL) 'https:') (beginsWith url 'http:')) { // switch to 'https'
		url = (join 'https://' (substring url 8))
	}
	requestID = (startFetch url)
	start = (msecsSinceStart)
	while (((msecsSinceStart) - start) < timeout) {
		result = (fetchResult requestID)
		if (false == result) { return '' } // request failed
		if (notNil result) { return result } // request completed
		waitMSecs 20
	}
	return ''
}
// useful global functions

// constants

to pi { return 3.14159265358979323846 }
to e { return 2.71828182845904523536 }

to maxInt { return 1073741823 }
to minInt { return -1073741824 }

to 'true' { return true }
to 'false' { return false }
to 'nil' { return nil }

// negation and decrease

to negate n { return (0 - n) }

// equality (in terms of ==)

to '!=' a b { return (not (a == b)) }

// comparision (in terms of < and ==)
// note: adding these slows down number comparison

// to '<=' a b { return (or (a < b) (a == b)) }
// to '>' a b { return (and (not (a < b)) (not (a == b))) }
// to '>=' a b { return (not (a < b))}

// min, max, and sum

to max args... {
  // Return the maximum argument. Must have at least one argument.
  // If the first argument is an array or list, return its maximum element.

  if (and ((argCount) == 1) (isAnyClass (arg 1) 'Array' 'List')) {
	return (callWith 'max' (toArray (arg 1)))
  }
  count = (argCount)
  if (count == 0) { return nil }
  result = (arg 1)
  for i count {
    n = (arg i)
    if (n > result) { result = n }
  }
  return result
}

to min args... {
  // Return the minimum argument. Must have at least one argument.
  // If the first argument is an array or list, return its minimum element.

  if (and ((argCount) == 1) (isAnyClass (arg 1) 'Array' 'List')) {
	return (callWith 'min' (toArray (arg 1)))
  }
  count = (argCount)
  if (count == 0) { return nil }
  result = (arg 1)
  for i count {
    n = (arg i)
    if (n < result) { result = n }
  }
  return result
}

to sum list {
  result = 0.0
  for n list { result += n }
  return result
}

// clamp and range

to clamp n min max {
  // Return the closest value to n in the given range.
  if (n < min) { n = min }
  if (n > max) { n = max }
  return n
}

to range start stop delta {
  comment '
	Return an array of integers over the given range (inclusive of start and stop).'

  if (isNil delta) { delta = 1 }
  if (isNil stop) {
    stop = start
	start = 1
  }
  if (delta == 0) { error 'Delta cannot be zero' }
  delta = (abs delta)
  result = (list start)
  if (start < stop) {
	steps = (floor ((stop - start) / delta))
	for i steps {
	  add result (start + (i * delta))
	}
  } else {
	steps = (floor ((start - stop) / delta))
	for i steps {
	  add result (start - (i * delta))
	}
  }
  return (toArray result)
}

to isBetween n start stop {
  // Return true if n is between start and stop, inclusive.

  return (and (start <= n) (n <= stop))
}

// misc operations

to half n {
  // Return half the argument truncated.

  return (truncate (n / 2))
}

to interpolate n1 n2 fraction {
  // Return the number that is fraction of the way from n1 to n2.
  // fraction should be in the range [0..1].

  return (n1 + (fraction * (n2 - n1)))
}

to sign n { if (n < 0) { return -1 } else { return 1 } }

// angles and vectors

to toRadians n { return ((n * (pi)) / 180) }
to toDegrees n { return ((n * 180) / (pi)) }

to distanceFromTo x1 y1 x2 y2 {
  dx = (x2 - x1)
  dy = (y2 - y1)
  return (sqrt ((dx * dx) + (dy * dy)))
}

to directionFromTo x1 y1 x2 y2 {
  dx = (x2 - x1)
  dy = (y2 - y1)
  return (atan dy dx)
}

// logarithms

to logBase n base {
  if (isNil base) { base = 10 }
  if (n <= 0) { error 'You cannot take the logarithm of a number less than or equal to zero' }
  if (base <= 0) { error 'The logarithm base must be greater than zero' }
  return ((ln n) / (ln base))
}

to raise base n {
  if (-1 == base) { // special case
	if (and (n == (truncate n)) (n > 0)) {
	  if (0 == (n % 2)) {
		return 1
	  } else {
	    return -1
	  }
	}
  }
  if (base <= 0) { error 'The first argument of raise (the base) must be greater than zero' }
  return (exp (n * (ln base)))
}

// hexadecimal numbers

to hex s {
  // Convert the given hexadecimal string to an integer.

  if ((substring s 1 2) == '0x') {
    s = (substring s 3)
  }
  n = 0
  letters = (letters s)
  for i (count letters) {
    digit = (hexDigitValue (at letters i))
	if (digit < 0) { error 'bad hex digit' }
	n = ((16 * n) + digit)
  }
  return n
}

to hexDigitValue ch {
  if (and ('0' <= ch) (ch <= '9')) {
    return ((byteAt ch 1) - (byteAt '0' 1))
  }
  if (and ('A' <= ch) (ch <= 'F')) {
    return (10 + ((byteAt ch 1) - (byteAt 'A' 1)))
  }
  if (and ('a' <= ch) (ch <= 'f')) {
    return (10 + ((byteAt ch 1) - (byteAt 'a' 1)))
  }
  return -1
}

// binary numbers

to binary s {
  // Convert the given binary string to an integer.

  result = 0
  for digit (letters s) {
	if ('0' == digit) {
	  result = (result << 1)
	} ('1' == digit) {
	  result = ((result << 1) + 1)
	} true {
	  error 'binary numbers can only contain "0" or "1"'
	}
  }
  return result
}
// messageServer.gp - A message-based server framework.

// A MessageServer listens for connections on a given port, manages connections,
// and invokes the client-supplied msgAction on each message it receives;

defineClass MessageServer msgAction port startSecs requestCount serverSocket connections

method msgAction MessageServer { return msgAction }
method port MessageServer { return port }
method startSecs MessageServer { return startSecs }
method connectionCount MessageServer { return (count connections) }
method requestCount MessageServer { return requestCount }

to newMessageServer msgAction port {
  result = (initialize (new 'MessageServer'))
  if (notNil msgAction) { setField result 'msgAction' msgAction }
  if (notNil port) { setField result 'port' port }
  return result
}

method initialize MessageServer {
  msgAction = 'print'
  port = 1234
  startSecs = 0
  requestCount = 0
  serverSocket = nil
  connections = (list)
  return this
}

method startServer MessageServer {
  stopServer this
  gc
  startSecs = (first (time))
  serverLoop this
}

method stopServer MessageServer {
  // Close the serverSocket and all connections.

  if (notNil serverSocket) { closeSocket serverSocket }
  serverSocket = nil
  for c connections { closeConnection c }
  connections = (list)
  gc
}

method serverLoop MessageServer {
  serverSocket = (openServerSocket port)
  print (dateString) 'Message server listening on port' port
  while true {
	clientSock = (acceptConnection serverSocket)
	if (notNil clientSock) {
//	  print (dateString) 'Connection from' (remoteAddress clientSock)
	  add connections (newMessageConnection clientSock)
	}
	connectionWasClosed = false
	for c connections {
	  msg = (nextMessage c)
	  if (notNil msg) {
		requestCount += 1
		call msgAction msg c this
	  }
	  if (not (isOpen c)) { connectionWasClosed = true }
	}
	if connectionWasClosed {
	  connections = (filter 'isOpen' connections)
	  gcIfNeeded
	}
	if ((count connections) > 0) {
	  gcIfNeeded
	  waitMSecs 5
	} else {
	  waitMSecs 50
	}
  }
}

// A MessageConnection transmits and receives RemoteMessages over a
// TCP/IP socket. The connectTo method creates a connection to a server.
// Messages are sent with sendMessage and received with nextMessage.
// The actual data transfer is done by processConnection, which is called
// by sendMessage and nextMessage. One of these three methods periodically
// to ensure that data gets transfered. (In most cases, the client will
// call nextMessage to poll for new messages, which will ensure that data
// gets transfered).

defineClass MessageConnection sock inBuf outBuf done

method socket MessageConnection { return sock }

to newMessageConnection sock {
  result = (initialize (new 'MessageConnection'))
  setField result 'sock' sock
  return result
}

method initialize MessageConnection {
  inBuf = (newBinaryData 0)
  outBuf = (newBinaryData 0)
  done = false
  return this
}

method connectTo MessageConnection host port {
  // Connect to a message server on the given host and port.

  if (notNil sock) { closeSocket sock }
  sock = (openClientSocket host port)
  initialize this
  return this
}

method closeConnection MessageConnection {
  if (notNil sock) { closeSocket sock }
  sock = nil
}

method isOpen MessageConnection {
  return (notNil sock)
}

method nextMessage MessageConnection {
  // Return the next incoming message, or nil if there isn't one.

  processConnection this
  if ((byteCount inBuf) == 0) { return nil }
  newline = 10
  strm = (dataStream inBuf)
  parts = (words (nextStringUpTo strm newline))
  if (and ((count parts) == 2) ('MSG' == (first parts))) {
	byteCount = (toInteger (at parts 2))
	if (((position strm) + byteCount) <= (byteCount inBuf)) {
		msg = (fromData (new 'RemoteMessage') (nextData strm byteCount))
		inBuf = (copyFromTo inBuf ((position strm) + 1))
		return msg
	}
  }
  return nil
}

method sendFinalMessage MessageConnection msg {
  // Queue the given RemoteMessage for sending.
  // Close the connection after all messages have been sent.

  done = true
  sendMessage this msg
}

method sendMessage MessageConnection msg {
  // Queue the given RemoteMessage for sending.

  body = (toBinaryData msg)
  header = (join 'MSG ' (toString (byteCount body)) (newline))

  buf = (newBinaryData (+ (byteCount outBuf) (byteCount header) (byteCount body)))
  strm = (dataStream buf)
  nextPutAll strm outBuf
  nextPutAll strm header
  nextPutAll strm body
  outBuf = (contents strm)
  processConnection this
}

method processConnection MessageConnection {
  // This is where data is actually received and transmited.

  if (isNil sock) { return }

  data = (readSocket sock true)
  if ((byteCount data) > 0) {
	inBuf = (join inBuf data)
  }
  if ((byteCount outBuf) > 0) {
	n = (writeSocket sock outBuf)
	if (n < 0) { // connection closed by other end
	  closeConnection this
	} (n > 0) {
	  outBuf = (copyFromTo outBuf (n + 1))
	}
  } (isNil (socketStatus sock)) {
	closeConnection this // connection closed by other end
  } else {
	if done { closeConnection this } // final message has been sent
  }
  gcIfNeeded
}

// A RemoteMessage is a serializable message used for network communications.
// It consists of a command, zero or more arguments, and zero or more 'blobs'.
// Arguments can be numbers, strings, booleans, or nil. Blobs can contain string
// or binary data. The format of a message is:
//
//		command [arguments] <newline>
//		[blobs]
//
// The ASCII newline character is the single byte 10.
// Each blob is:
//
//		bytecount <newline>
//		<bytecount bytes of data> <newline>
//		<terminator> <newline>
//
// The bytecount is a human-readable string representing decimal number.
// The terminator is the 10-byte string: '----------' (i.e. 10 hyphens).
//
// This format allows messages to be viewed in a text editor for debugging
// (one can easily read bytecounts or search for terminators), yet it supports
// efficient inclusion of arbitrary binary data (no need to encode as Base64).

defineClass RemoteMessage command args blobs

method command RemoteMessage { return command }
method args RemoteMessage { return args }
method blobs RemoteMessage { return blobs }

to newRemoteMessage cmd args... {
  result = (initialize (new 'RemoteMessage'))
  setField result 'command' cmd
  for i (argCount) {
	if (i > 1) {
	  add (args result) (arg i)
	}
  }
  return result
}

method initialize RemoteMessage {
  command = ''
  args = (list)
  blobs = (list)
  return this
}

method callServer RemoteMessage host port {
  // Send this message to the given server and wait for a reply.

  connection = (connectTo (newMessageConnection) host port)
  sendMessage connection this
  gc
  while (isOpen connection) {
	reply = (nextMessage connection)
	if (notNil reply) {
	  if ('ok' == (command reply)) {
		closeConnection connection
		return reply
	  } else {
		print (dateString) 'server error:' (command reply)
		closeConnection connection
		return nil
	  }
	} else {
	  waitMSecs 2
	}
  }
  closeConnection connection
  return nil
}

method fromData RemoteMessage data {
  newline = 10
  strm = (dataStream data)

  cmd = (first (parse (nextStringUpTo strm newline)))
  command = (primName cmd)
  args = (argList cmd)

  blobs = (list)
  while (not (atEnd strm)) {
	blobLength = (toInteger (nextStringUpTo strm newline))
	add blobs (nextData strm blobLength)
	nextUInt8 strm // skip newline
	separator = (nextStringUpTo strm newline)
	if (separator != '----------') {
	  error 'Bad separator'
	}
  }
  return this
}

method toBinaryData RemoteMessage {
  newline = 10
  parts = (list command)
  for a args { add parts (printString a) }
  strm = (dataStream (newBinaryData 10000))
  nextPutAll strm (joinStrings parts ' ')
  putUInt8 strm newline
  for b blobs {
	nextPutAll strm (toString (byteCount b))
	putUInt8 strm newline
	nextPutAll strm b
	putUInt8 strm newline
	nextPutAll strm '----------'
	putUInt8 strm newline
  }
  return (contents strm)
}
// Morphic Core Framework

// global settings and event hooks
// define these as methods of your own handlers
// to override the default behavior

to step aHandler { noop }
to redraw aHandler aContext { noop }

to duplicate aHandler {
  error (join (className (classOf aHandler)) 'cannot be duplicated')
  return nil
}

to handMoveOver aHandler { noop }
to handDragOver aHandler aHand aDraggedHandler { noop }
to handEnter aHandler { noop }
to handLeave aHandler { noop }

to handDownOn aHandler hand {
  result = false
  if (dispatchEvent aHandler 'whenClicked') { result = true }
  if (dispatchEvent aHandler 'whenTracking' (self_mouseX) (self_mouseY)) {
    focusOn hand aHandler
    result = true
  }
  return result
}
to handMoveFocus aHandler { dispatchEvent aHandler 'whenTracking' (self_mouseX) (self_mouseY) }
to handUpOn aHandler {return false}

to clicked aHandler {return false}

to rightClicked aHandler {
  page = (global 'page')
  if (not (shiftKeyDown (keyboard page))) {
    devMenu (hand page) aHandler
    return true
  }
  return false
}

to swipe aHandler scrollX scrollY { return (dispatchEvent aHandler 'whenScrolled' scrollX scrollY) }
to pageResized aHandler { dispatchEvent aHandler 'whenPageResized' }
to scaleChanged aHandler { noop }
to changed aHandler { changed (morph aHandler) }
to okayToBeDestroyedByUser aHandler {return true}
to destroyedMorph aHandler { noop }

to acceptsEvents aHandler { return (and (notNil aHandler) (acceptsEvents (morph aHandler))) }
to isSelectable aHandler {return false}
to setMorph aHandler aMorph {setField aHandler 'morph' aMorph}
to doubleClicked aHandler {return false}

to aboutToBeGrabbed aHandler { noop }
to justGrabbedPart aHandler part { noop }
to justDropped aHandler { dispatchEvent aHandler 'whenDropped' }

to wantsDropOf dropReceiver aHandler {
  if (hasField dropReceiver 'morph') {
    return ('draggableParts' == (grabRule (getField dropReceiver 'morph')))
  }
  return false
}

to justReceivedDrop dropReceiver aHandler {
  if (and
    (hasField dropReceiver 'morph')
    (hasField aHandler 'morph')
    ('draggableParts' == (grabRule (getField dropReceiver 'morph'))) ) {
      setGrabRule (getField aHandler 'morph') 'defer'
  }
}

to morph aHandler {
  if (isNil aHandler) {return nil}
  return (getField aHandler 'morph')
}

to findMorph handlerClassName {
	page = (global 'page')
	if (notNil page) {
		for m (parts (morph page)) {
			if (isClass (handler m) handlerClassName) {
				return m
			}
		}
	}
	return nil
}

// stubs for handler pre- and post-serialization

to preSerialize aHandler {}
to postSerialize aHandler {}

// Hand

defineClass Hand morph page isDown x y currentMorphs lastTouched lastClicked lastClickTime lastTouchTime oldOwner oldX oldY focus morphicMenuDisabled

to newHand {
  hand = (new 'Hand' nil nil false 0 0 (list) nil nil (newTimer) nil nil nil)
  morph = (newMorph hand)
  setMorph hand morph
  return hand
}

method page Hand {return page}
method setPage Hand aPage {page = aPage}
method isDown Hand {return isDown}
method x Hand {return x}
method y Hand {return y}
method focus Hand {return focus}
method focusOn Hand aHandler {focus = aHandler}

method objectAt Hand pixelPerfect {
  // Answer the topmost morph under the hand.

  if (isNil pixelPerfect) { pixelPerfect = false }
  for m (reversed (morphsAt (morph page) x y)) {
    hdl = (handler m)
    if (and (notNil hdl) (not (isClass hdl 'Caret')) (not (isClass hdl 'ShadowEffect'))) {
      if (and (isVisible m) (containsPoint (visibleBounds m) x y)) {
        if (or (noticesTransparentTouch m) (not pixelPerfect)) {return hdl}
        if (not (isTransparentAt m x y)) {return hdl}
      }
    }
  }
  return page
}

method isBusy Hand {
  if (or (notNil focus) (notEmpty (parts morph))) { return true }
  if (hasActiveMenu page) { return true }
  return false
}

// drawing

method drawOn Hand aContext { } // noop

// grabbing and dropping

method grabbedObject Hand {
  if ((count (parts morph)) > 0) {return (handler (last (parts morph)))}
  return nil
}

method grab Hand handler {
  if (notNil (owner (morph handler))) {parent = (handler (owner (morph handler)))}
  aboutToBeGrabbed handler
  oldOwner = parent
  oldX = (left (morph handler))
  oldY = (top (morph handler))
  fb = (fullBounds (morph handler))
  if (not (containsPoint fb x y)) {
    // avoid "trailing behind" the mouse cursor
    setPosition (morph handler) (x - 5) (y - 5)
  }
  removeAllParts morph
  if ('Browser' == (platform)) {
	addPart morph (morph (newCachedTexture handler))
  } else {
	addPart morph (shadow (morph handler) 50 (7 * (global 'scale')))
	addPart morph (cachedCostumeFor this handler)
  }
  hide (morph handler)
  addPart morph (morph handler)
  justGrabbedPart parent handler
  changed morph
}

method cachedCostumeFor Hand handler {
  result = (newMorph)
  bm = (fullCostume (morph handler))
//  fixCachedCostume this bm // less necessary now that we are not calling unmultiplyAlpha
  setCostume result bm
  bnds = (bounds (morph handler))
  setPosition result (left bnds) (top bnds)
  return result
}

method fixCachedCostume Hand aBitmap {
  // This hack improves rendering anti-aliased shapes such as blocks into a cached bitmap and
  // then rendering that with SDL2 while dragging. While I don't fully understand the issue,
  // it involves the interaction between Cairo's pre-multiplied alpha and SDL's blend mode.
  // There is a detailed explanation here:
  //   https://stackoverflow.com/questions/45781683/how-to-get-correct-sourceover-alpha-compositing-in-sdl-with-opengl
  // Without this adjustment, some edge pixels become nearly white when a script is picked up,
  // which is visually jarring, especially when blocks are scaled up.
  // This fix is neither needed nor used when running in the browser.

  pixelData = (pixelData aBitmap)
  for i (count pixelData) {
	a = (getPixelAlpha pixelData i)
    if (and (a > 110) (a < 250)) {
	  setPixelRGBA pixelData i 100 100 100 a
	}
  }
}

method rootForGrab Hand handler {
  result = handler
  while (notNil result) {
    rule = (grabRule (morph result))
    if (rule == 'ignore') {return nil}
    if (rule == 'handle') {return result}
    if (rule == 'draggableParts') {return result}
    if (rule == 'template') {return (duplicate result)}
    parent = (owner (morph result))
    if (isNil parent) {return nil}
    if ('draggableParts' == (grabRule parent)) {
      setGrabRule (morph result) 'handle'
      return result
    }
    result = (handler parent)
  }
  return nil
}

method drop Hand {
  src = (grabbedObject this)
  if (isNil src) {return}
  trg = (objectAt this)
  if (isNil trg) {trg = page}
  while (not (wantsDropOf trg src)) {
    parent = (owner (morph trg))
    if (isNil parent) {return}
    trg = (handler parent)
  }
  if (isClass src 'Monitor') {
	// adjust a Monitor's scale when dropped
	if (isClass trg 'Stage') { // scale to stage
	  setScale (morph src) ((scale (morph trg)) / (global 'scale'))
	} else { // normal scale
	  setScale (morph src) 1
	}
  }
  changed morph
  removeAllParts morph
  show (morph src)
  addPart (morph trg) (morph src)
  justDropped src this
  justReceivedDrop trg src
}

method oldOwner Hand { return oldOwner }

method returnGrabbedObjectToOldPosition Hand aHandler {
  if (and (notNil aHandler) (notNil oldX) (notNil oldY)) {
    setPosition (morph aHandler) oldX oldY
  }
}

method animateBackToOldOwner Hand aMorph finalAction {
  doneAction = (action
	(function oldOwner m finallyDo {
	  if (isNil oldOwner) {
		removeFromOwner m
		return
	  }
	  if (isClass (handler m) 'Block') {
		if (isClass (expression (handler m)) 'Reporter') {
		  scriptEditor = (ownerThatIsA oldOwner 'ScriptEditor')
		  if (notNil scriptEditor) {
			addPart scriptEditor m
			raise scriptEditor 'scriptChanged'
		  }
		} (isClass (handler oldOwner) 'Block') {
		  setNext (handler oldOwner) (handler m)
		} (isClass (handler oldOwner) 'CommandSlot') {
		  setNested (handler oldOwner) (handler m)
		} else {
		  addPart oldOwner m
		}
	  } else {
		addPart oldOwner m
	  }
	  if (notNil finallyDo) {
		  call finallyDo
	  }
	}
	)
	(morph oldOwner) aMorph finalAction)
  addPart (morph page) aMorph // move in front of everything else during the animation
  animateTo aMorph oldX oldY doneAction
}

// stepping

method step Hand {
  // generate touch-hold events
  if (notNil lastTouchTime) {
    if ((msecs lastTouchTime) > 300) {processTouchHold this (currentObject this)}
  }
}

method processEvent Hand evt {
  type  = (at evt 'type')
  if (type == 'mousewheel') {
	// Windows and Linux only report +/- 1 for mousewheel events so scale them up
	wheelScale = (60 * (global 'scale'))
	if ('Browser' == (platform)) { wheelScale = (1 * (global 'scale')) }
	if ('Mac' == (platform)) { wheelScale = (10 * (global 'scale')) }
    processSwipe this (wheelScale * (at evt 'x')) (wheelScale * (at evt 'y'))
    return
  }
  x = (at evt 'x')
  y = (at evt 'y')
  setPosition morph x y
  if (type == 'mouseMove') {
	processMove this
  } (type == 'mouseDown') {
    isDown = true
	if (notNil (at evt 'modifierKeys')) { updateModifiedKeys (keyboard page) (at evt 'modifierKeys') }
    processDown this (at evt 'button')
  } (type == 'mouseUp') {
    isDown = false
	if (notNil (at evt 'modifierKeys')) { updateModifiedKeys (keyboard page) (at evt 'modifierKeys') }
    processUp this
	// Workaround for keyboard popping up on every mouse up on mobile Chrome:
	if (isNil (focus (keyboard page))) { showKeyboard false }
  }
}

method currentObject Hand {
  if (notNil focus) {return focus}
  return (objectAt this)
}

method processMove Hand {
  if (notNil focus) {
	handMoveFocus focus this
	return
  }
  oldMorphs = currentMorphs
  currentMorphs = (list)
  m = (morph (currentObject this))
  stopped = false
  while (and (not stopped) (notNil m)) {
    add currentMorphs m
    if (acceptsEvents m) {
      h = (handler m)
      if isDown {
        dragged = (grabbedObject this)
        if (isNil dragged) {
          handMoveOver h this
          if (notNil lastTouched) {
            toBeGrabbed = (rootForGrab this lastTouched)
            if (notNil toBeGrabbed) {
              closeUnclickedMenu page toBeGrabbed
              grab this toBeGrabbed
              lastTouched = nil
              lastTouchTime = nil
            }
          }
        } else {
          handDragOver h this dragged
        }
      }
      if (not (contains oldMorphs m)) {handEnter h this}
    }
    stopped = (isSelectable h this)
    m = (owner m)
  }
  for oldM oldMorphs {if (and (acceptsEvents oldM) (not (contains currentMorphs oldM))) {handLeave (handler oldM) this}}
}

method processSwipe Hand xDelta yDelta {
  trg = (currentObject this)
  while (not (and (acceptsEvents trg) (swipe trg xDelta yDelta this))) {trg = (parentHandler (morph trg))}
}

method processDown Hand button {
  currentObj = (objectAt this true)
  if (isNil (ownerThatIsA (morph currentObj) 'Menu')) {
	// stop editing unless this is a menu selection (it could a text edit menu command)
	stopEditingUnfocusedText this currentObj
  }
  if (or (button == 3) (commandKeyDown (keyboard page))) {
    closeUnclickedMenu page currentObj
    processRightClicked this currentObj
    return
  }
  closeUnclickedMenu page currentObj
  lastTouched = currentObj
  lastTouchTime = (newTimer)
  if (and (optionKeyDown (keyboard page)) (notNil currentObj)) {
	showInScripter currentObj
	lastTouched = nil
	lastTouchTime = nil
	return
  }
  trg = currentObj
  while (notNil trg) {
	if (and (acceptsEvents trg) (handDownOn trg this)) { return }
	trg = (parentHandler (morph trg))
  }
}

method processUp Hand {
  if (notNil focus) {
    handUpOn focus this
    focus = nil
    return
  }
  if (notNil (grabbedObject this)) {
	drop this
	return
  }
  current = (objectAt this)
  trg = current
  while (not (and (acceptsEvents trg) (handUpOn trg this))) {trg = (parentHandler (morph trg))}
  if (current === lastTouched) {
    trg = current
    while (or (not (acceptsEvents trg)) (false == (clicked trg this))) {trg = (parentHandler (morph trg))}
    if (current === lastClicked) {
      if ((msecs lastClickTime) < 500) {
        trg = current
        while (not (and (acceptsEvents trg) (doubleClicked trg this))) {trg = (parentHandler (morph trg))}
      }
    }
    lastClicked = current
    reset lastClickTime
  }
  lastTouched = nil
  lastTouchTime = nil
}

method processTouchHold Hand currentObj {
  lastTouchTime = nil
  isMobile = (or
  	('iOS' == (platform))
	(and ('Browser' == (platform)) (browserIsMobile)))
  if isMobile {
	// on mobile devices, make map touchHold gestures to rightClicked
	processRightClicked this currentObj
	lastTouched = nil
  }
}

method processRightClicked Hand currentObj {
  if (shiftKeyDown (keyboard page)) {
    devMenu this currentObj
    return
  }
  trg = currentObj
  while (not (and (acceptsEvents trg) (rightClicked trg this))) {
	if (isNil (owner (morph trg))) { return } // uncommon, but can happen
    trg = (handler (owner (morph trg)))
    if (or (trg == page) (isClass trg 'Stage')) { return } // don't propagate rightClicked through an object to the page or stage
  }
  lastTouched = nil
  lastTouchTime = nil
}

method stopEditingUnfocusedText Hand currentObj {
  caret = (focus (keyboard page))
  if (isClass caret 'ScriptFocus') {
    // cancel caret
    return
  }
  if (or (not (isClass caret 'Caret')) (currentObj == (target caret))) { return }
  if (not (isClass currentObj 'Trigger')) {
    if ((editRule (target caret)) == 'code') {
      if (notNil (ownerThatIsA (morph (target caret)) 'Synopsis')) {
        cancel caret
      } else {
        accept caret
      }
    } else {
      accept caret
    }
  } ((editRule (target caret)) != 'code') {
      if (isClass (handler (owner (morph (target caret)))) 'ScriptFocus') {
        return
      }
      accept caret
  }
}

// menus

method toggleMorphicMenu Hand flag { morphicMenuDisabled = (not flag) }

method devMenu Hand currentObj {
  if morphicMenuDisabled { return }

  if (isNil currentObj) {currentObj = (currentObject this)}
  se = (ownerThatIsA (morph currentObj) 'ScriptEditor')
  if (notNil se) {
    stopEditing (handler se)
  }
  if (not (devMode)) {
    if (isNil (ownerThatIsA (morph currentObj) 'Stage')) { return } // do nothing for objects in a Stage
    if (isClass currentObj 'Stage') { return } // do nothing if currentObj is a Stage
//	if (isNil (scripts (classOf currentObj))) { return } // do nothing for non-user-created objects
  }
  if (isTopLevel (morph currentObj)) {
    if (not (and (devMode) (shiftKeyDown (keyboard page)))) {
	  // if not in devMode with shift key pressed, skip the parts menu
	  popUpAtHand (contextMenu (morph currentObj)) page
	  return
	}
  }
  // display the parts menu
  scale = (global 'scale')
  menu = (menu nil this)
  for each (allOwners (morph currentObj)) {
    if (or (devMode) (not (isAnyClass (handler each) 'Page' 'Stage' 'ProjectEditor'))) {
      if (isNil (costumeData each)) {
        thm = (newBitmap (* scale 18) (* scale 18))
      } else {
        thm = (thumbnail (costumeData each) (* scale 18) (* scale 18))
      }
      addItem menu (join (toString (handler each)) '...') (action 'popUpAtHand' (contextMenu each) page) nil thm
    }
  }
  popUpAtHand menu page
}

method explore Hand anObject {
    ins = (explorerOn anObject)
    setPosition (morph ins) x y
    addPart page ins
}

// convenience methods to access hand state

to handX { return (x (hand (global 'page'))) }
to handY { return (y (hand (global 'page'))) }
to handIsDown { return (isDown (hand (global 'page'))) }
to keyIsDown key { return (keyDown (global 'page') key) }

// Keyboard

defineClass Keyboard page focus currentKeys

method page Keyboard {return page}
method setPage Keyboard aPage {page = aPage}
method focus Keyboard {return focus}
method focusOn Keyboard aHandler {focus = aHandler}

method processEvent Keyboard evt {
  type = (at evt 'type')
  key = (at evt 'keycode')
  if (or (key == 91) (key == 93)) { key = nil } // numpad fix for keys 3 and 5
  if (and ('textinput' == type) ('Browser' == (platform)) ('	' == (at evt 'text'))) {
    // skip textinput events for tab characters (sent by browsers but not SDL2)
    return
  }
  if (and ('textinput' == type) (or (controlKeyDown this) (commandKeyDown this))) {
    return // ignore textinput events with modifier keys
  }
  if (and ('Browser' != (platform)) (74 <= key) (key <= 78)) {
	// Map SDL key codes to browser key codes
	if (74 === key) { key = 36 // home
	} (75 === key) { key = 33 // page up
	} (77 === key) {  key = 35 // end
	} (78 === key) { key = 34 // page down
	}
  }
  updateModifiedKeys this (at evt 'modifierKeys')
  if (and (1 <= key) (key <= 255)) {
	if (type == 'keyUp') {
	  atPut currentKeys key false
	} (type == 'keyDown') {
	  // Arrow key navigation in scrollable morph under mouse pointer
	  if (and (key >= 33) (key <= 40) (isNil focus)) {
		morph = (ownerThatIsA (morph (objectAt (hand (global 'page')))) 'ScrollFrame')
		if (notNil morph) {
			scrollFrame = (handler morph)
			if (33 === key) { // page up
				scrollPage scrollFrame -1
			} (34 === key) { // page down
				scrollPage scrollFrame 1
			} (35 === key) { // end
				scrollEnd scrollFrame
			} (36 === key) { // home
				scrollHome scrollFrame
			} (37 === key) { // left arrow
				arrowKey scrollFrame 1 0
			} (38 === key) { // up arrow
				arrowKey scrollFrame 0 1
			} (39 === key) { // right arrow
				arrowKey scrollFrame -1 0
			} (40 === key) { // down arrow
				arrowKey scrollFrame 0 -1
			}
		}
	  }

	  if (and (at currentKeys key) (8 != key)) { return } // suppress duplicated keyDown events on Gnome and some other Linux desktops
	  atPut currentKeys key true

	  if (isNil focus) {
		if (27 == key) { // escape key
			if (notNil (flasher (smallRuntime))) {
				confirmRemoveFlasher (smallRuntime)
			} (not (decompilerDone (smallRuntime))) {
				stopDecompilation (smallRuntime)
			} (notNil (findMorph 'MicroBlocksFilePicker')) {
				destroy (findMorph 'MicroBlocksFilePicker')
			} (notNil (findMorph 'MicroBlocksSpinner')) {
				destroy (handler (findMorph 'MicroBlocksSpinner'))
			} (notNil (findMorph 'Prompter')) {
				cancel (handler (findMorph 'Prompter'))
			} else {
				stopAndSyncScripts (smallRuntime)
			}
		} (13 == key) { // enter key
			if (notNil (findMorph 'Prompter')) {
				accept (handler (findMorph 'Prompter'))
			}
			for morphName (array 'FilePicker' 'MicroBlocksFilePicker' 'MicroBlocksLibraryImportDialog') {
				if (isNil filePicker) { filePicker = (findMorph morphName) }
			}
			if (notNil filePicker) {
				okay (handler filePicker)
			}
		}
		if (and (111 == (at evt 'char')) (or (controlKeyDown this) (commandKeyDown this))) {
			// cmd-O or ctrl-O - open file dialog
			(openProjectMenu (findProjectEditor))
		}
		if (and (115 == (at evt 'char')) (or (controlKeyDown this) (commandKeyDown this))) {
			// cmd-S or ctrl-S - save file dialog
			(saveProjectToFile (findProjectEditor))
		}
		if (and (122 == (at evt 'char'))
			(or (controlKeyDown this) (commandKeyDown this))
			(isNil (grabbedObject (hand (global 'page'))))) {
				// cmd-Z or ctrl-Z - undo last drop
				pe = (findProjectEditor)
				if (notNil pe) { undrop (scriptEditor (scripter pe)) }
		}
	  }
	}
  }
  if (notNil focus) {
	call type focus evt this
  }
}

method isInPresentationMode Keyboard {
  for m (parts (morph (global 'page'))) {
	if (isClass (handler m) 'Stage') { return true }
  }
  return false
}

method edit Keyboard aText slot keepFocus {
  if (isNil keepFocus) {keepFocus = false}
  if (not keepFocus) {stopEditing this}
  focus = (new 'Caret')
  initialize focus aText slot
}

method stopEditing Keyboard {
  if (isAnyClass focus 'Caret' 'ScriptFocus') {destroy focus}
  focus = nil
}

method shiftKeyDown Keyboard { return (at currentKeys 16) }
method controlKeyDown Keyboard { return (at currentKeys 17) }
method optionKeyDown Keyboard { return (at currentKeys 18) }
method commandKeyDown Keyboard { return (or (at currentKeys 91) (at currentKeys 93)) }

method keyDown Keyboard keyName {
  if ((byteCount keyName) == 1) {
    key = (byteAt keyName 1)
	if (isLowerCase keyName) { key += -32 }
	return (at currentKeys key)
  }
  if ('delete' == keyName) { return (at currentKeys 8) }
  if ('space' == keyName) { return (at currentKeys 32) }
  if ('right arrow' == keyName) { return (at currentKeys 39) }
  if ('left arrow' == keyName) { return (at currentKeys 37) }
  if ('down arrow' == keyName) { return (at currentKeys 40) }
  if ('up arrow' == keyName) { return (at currentKeys 38) }
  if ('shift' == keyName) { return (at currentKeys 16) }
  return false
}

method keyToEventName Keyboard key {
  // Convert a key number to a key event name.
  if (8 == key) { return 'delete' }
  if (16 == key) { return 'shift' }
  if (32 == key) { return 'space' }
  if (39 == key) { return 'right arrow' }
  if (37 == key) { return 'left arrow' }
  if (40 == key) { return 'down arrow' }
  if (38 == key) { return 'up arrow' }
  if (key < 128) { return (string key) }
  return ''
}

method updateModifiedKeys Keyboard modifierKeys {
  if (isNil modifierKeys) { return }
  shiftDown = ((modifierKeys & 1) != 0)
  ctrlDown = ((modifierKeys & 2) != 0)
  optDown = ((modifierKeys & 4) != 0)
  cmdDown = ((modifierKeys & 8) != 0)
  atPut currentKeys 16 shiftDown
  atPut currentKeys 17 ctrlDown
  atPut currentKeys 18 optDown
  atPut currentKeys 91 cmdDown
  atPut currentKeys 93 cmdDown
}

// Page

defineClass Page morph hand keyboard taskMaster soundMixer schedules activeMenu isChanged color activeHint activeTooltip isShowingConnectors foreground devMode profileTimer droppedFiles droppedTexts damages redrawAll

to go tryRetina {
  // Run 'go' at command prompt to open or restart.
  if (and (isNil (global 'page')) (notNil (shared 'page' (topLevelModule)))) {
	// copy page and other state from topLevelModule
	pageVars = (array 'authoringSpecs' 'page' 'scale')
	for varName pageVars {
	  // Move page state from topLevelModule to sessionModule
	  value = (shared varName (topLevelModule))
	  if (notNil value) { setGlobal varName value }
	  deleteVar (topLevelModule) varName
	}
	// set default values if necessary
	if (isNil (global 'scale')) { setGlobal 'scale' 1 }
  } else {
	if (isNil (global 'page')) { openPage tryRetina }
  }
  page = (global 'page')
  if (isEmpty (parts (morph page))) {
	// for testing: add a Box when first created
	box = (newBox)
	setGrabRule (morph box) 'handle'
	addPart page (morph box)
  }
  startSteppingSafely (global 'page')
}

to openPage tryRetina {
  if (isNil tryRetina) {tryRetina = true}
  page = (newPage 1040 650) // make one dimension > 1024 for best iOS retina detection
  setGlobal 'page' page
  open page tryRetina
}

to newPage width height color {
  if (isNil width) { width = 500 }
  if (isNil height) { height = 500 }
  if (isNil color) {color = (color 250 250 250)}
  page = (new 'Page' nil nil nil (newTaskMaster) (newSoundMixer) (list) nil false color nil nil false nil true nil)
  morph = (newMorph page)
  setTransparentTouch morph true
  setWidth (bounds morph) width
  setHeight (bounds morph) height
  setMorph page morph
  setCostume morph color
  hand = (newHand)
  setPage hand page
  setHand page hand
  keyboard = (new 'Keyboard' page nil (newArray 255 false))
  setKeyboard page keyboard
  setField page 'droppedFiles' (list)
  setField page 'droppedTexts' (list)
  setField page 'damages' (list)
  setField page 'redrawAll' false
  return page
}

method open Page tryRetina title {
  setGlobal 'page' this
  setGlobal 'scale' 1
  setClipping morph true

  // Morphic Rework:
  // The renderToBitmap flag makes SDL screen be a bitmap vs. a texture,
  // allowing direct rendering (including vectors and text) to SDL's display.
  renderToBitmap = (not ('Browser' == (platform)))

  openWindow (width morph) (height morph) tryRetina title renderToBitmap
  winSize = (windowSize)
  setExtent morph (at winSize 3) (at winSize 4) // actual extent
  if ((at winSize 3) > (at winSize 1)) {
	ratio = ((at winSize 3) / (at winSize 1))
	if (2 == ratio) {
	  setGlobal 'scale' 2 // retina display
	} else {
	  // revert to non-retina mode if scale != 2 (some iPhones have non-integer scales)
	  closeWindow
	  openWindow (width morph) (height morph) false title renderToBitmap
	}
  }
  redrawAll this
}

method hand Page {return hand}
method setHand Page aHand {hand = aHand}
method keyboard Page {return keyboard}
method setKeyboard Page aKeyboard {keyboard = aKeyboard}
method keyDown Page keyName { return (keyDown keyboard keyName) }
method soundMixer Page {return soundMixer}
method soundPlayer Page {return soundMixer} // backward compatibility for Mark's samples extension
method setColor Page newColor { color = newColor }
method width Page { return (width morph) }
method height Page { return (height morph) }

method addPart Page obj {
  if (isClass obj 'Morph') {
    addPart morph obj
  } else {
    addPart morph (morph obj)
  }
}

method removePart Page obj {
  if (isClass obj 'Morph') {
    removePart morph obj
  } else {
    removePart morph (morph obj)
  }
}

// developer mode

method setDevMode Page flag { devMode = flag }

method enterDeveloperMode Page {
  msg = 'With great power comes great responsibility.
Enter developer mode?'
  if (confirm this nil msg) {
	devMode = true
	editor = (findProjectEditor)
	if (notNil editor) {developerModeChanged editor}
  }
}

method exitDeveloperMode Page {
  devMode = false
  editor = (findProjectEditor)
  if (notNil editor) {developerModeChanged editor}
}

to devMode {
  page = (global 'page')
  if (isNil page) { return true }
  return (getField page 'devMode')
}

to debugPrintTime t label {
	time = (msecSplit t)
	if (time > 15) {
		print label ':' time
	}
}

// stepping

method doOneCycle Page {
  // Note: 'step soundMixer' is called at multiple places to decrease the
  // chances of dropping a buffer. This allows the mixer to use a smaller
  // sound output buffer, thus decreasing the latency for starting a sound.

  t = (newTimer)
  step soundMixer
  gcIfNeeded
  processEvents this
  step hand
  step morph
  stepSchedules this
  wakeUpDisplayTasks taskMaster
  stepTasks taskMaster 75
  // ToDo: revisit drawing links and foreground
//   if isChanged {
//     step soundMixer
//     clearBuffer color
//     draw morph nil 0 0 1 1 nil
//     draw (morph hand)
//     drawLinks this
//     drawForeground this
//     step soundMixer
//     flipBuffer
//     isChanged = false
//   }
  if (or redrawAll (notEmpty damages)) { fixDamages this }

  step soundMixer
  // sleep for any extra time, but always sleep a little to ensure that
  // we get events (and to return control to the browser)
  sleepTime = (max 1 (15 - (msecs t)))
  waitMSecs sleepTime
}

method updateDisplay Page {
  if (or redrawAll (notEmpty damages)) { fixDamages this }
  waitMSecs 1 // needed for browser?
}

// damage recording and redrawing

method redrawAll Page { redrawAll = true }

method addDamage Page newRect {
  // Add the given damage rectangle to the damage list.

  if (isNil damages) { damages = (list) }

  maxDamageEntries = 10
  if ((count damages) >= maxDamageEntries) { redrawAll = true }
  if redrawAll { return }

  newRect = (roundToIntegers newRect)
  if ((area newRect) <= 0) { return } // do nothing if newRect is empty

  if (isEmpty damages) { // new rectangle is the first damage; just add it
	add damages (copy newRect)
	return
  }

  // try to merge with an existing damage rectangle
  for i (count damages) {
	r = (at damages i)
	if (intersects newRect r) {
      atPut damages i (mergedWith newRect r) // merge!
      return
    }
  }

  // newRect doesn't overlap any existing damage rectangle, so add it
  add damages (copy newRect)
}

method fixDamages Page forBenchmark {
  // Redraw morphs that overlap the damage rectangles and reset the damage list.

  // make debug true to show damage handling
  debug = false
  if debug {
	totalArea = 0
	for r damages { totalArea += (area r) }
	if redrawAll {
	  print '*** redraw all ***'
	} else {
	  print '*** redraw count' (count damages) 'area' totalArea '***'
	}
  }
  t = (newTimer)

  if redrawAll {
	damages = (list (rect 0 0 (width morph) (height morph)))
  }

  for rect damages {
    if ((area rect) > 0) {
	  // make flashDamage true to flash damage rectangle before redrawing
	  flashDamage = false
	  if flashDamage {
		fillRect nil (color 200 0 200) (left rect) (top rect) (width rect) (height rect)
		flipBuffer
	  }
	  ctx = (newGraphicContextOnScreen rect)
      fullDrawOn morph ctx
      fullDrawOn (morph hand) ctx
    }
  }

  // make debug2 true to show damage handling
  debug2 = false
  if (and debug2 ((msecs t) > 2)) { print 'fixDamages' (msecs t) 'msecs' }
  if (true != forBenchmark) { flipBuffer }
  damages = (list)
  redrawAll = false
}

// drawing

method drawOn Page aContext {
  fillRect aContext color 0 0 (width morph) (height morph)
}

// events

method processEvents Page {
  evt = (getNextEvent)
  while (notNil evt) {
    nxt = (getNextEvent)
    type = (at evt 'type')
    if (or (type == 'mouseMove') (type == 'mouseDown') (type == 'mouseUp')) {
      // optimization: out of consecutive mouseMove events only handle the last one
      if (not (and (type == 'mouseMove') (notNil nxt) ((at nxt 'type') == 'mouseMove'))) {
        processEvent hand evt
      }
    } (type == 'mousewheel') {
      // optimization: skip all but the final mousewheel event in a burst of mousewheel events
      if (not (and (type == 'mousewheel') (notNil nxt) ((at nxt 'type') == 'mousewheel'))) {
        processEvent hand evt
      }
    } (or (type == 'keyDown') (type == 'keyUp') (type == 'textinput')) {
      processEvent keyboard evt
    } (type == 'window') {
      processWindowEvent this evt
	} (type == 'dropFile') {
	  add droppedFiles evt
	} (type == 'dropText') {
	  add droppedTexts evt
	} (type == 'quit') {
      confirmToQuit this
    }
    evt = nxt
  }
}

to getNextEvent {
  // filter out "touch" type events for now
  evt = (nextEvent)
  if (isNil evt) {return nil}
  type = (at evt 'type')
  if (or (type == 'touch') (isClass type 'Integer')) {return (getNextEvent)}
  return evt
}

to readClipboard {
  // Return the contents of the clipboard.

  if ('Browser' == (platform)) {
	// On browsers, read the clipboard twice, with a short wait in between.
	getClipboard
	waitMSecs 1
  }
  return (getClipboard)
}

method updateScale Page {
  winSize = (windowSize)
  ratio = ((at winSize 3) / (at winSize 1))
  if (ratio > 1) {
	setGlobal 'scale' 2 // retina display
  } else {
	setGlobal 'scale' 1 // non-retina display
  }
}

method processWindowEvent Page evt {
  id = (at evt 'eventID')
  if (6 == id) {
	oldScale = (global 'scale')
	updateScale this
	scale = (global 'scale')

	// note: things can break if w or h is less than 1
	w = (scale * (max 1 (at evt 'data1')))
	h = (scale * (max 1 (at evt 'data2')))

	clearBuffer color
	flipBuffer
	setPosition morph 0 0
	setExtent morph w h
	for each (parts morph) { pageResized (handler each) w h this }
	if (scale != oldScale) {
	  for m (allMorphs morph) { scaleChanged (handler m) }
	}
  } (isOneOf id 1 3 8 9) {
	redrawAll this
	changed morph
	for each (parts morph) {pageResized (handler each) w h this}
  }
}

method setWindowSize Page w h {
  scale = (global 'scale')
  tryRetina = (scale > 1)
  openWindow w h tryRetina
  clearBuffer color
  flipBuffer
  setPosition morph 0 0
  setExtent morph (w * scale) (h * scale)
  for m (parts morph) {
	pageResized (handler m) w h this
  }
}

method startStepping Page startFlag {
  if (isNil startFlag) { startFlag = false }
  stopAll this
  if startFlag { broadcastGo this }
  redrawAll this
  interactionLoop this
}

method stepForSeconds Page secs {
  // Useful when including running morphic unit tests.
  stopAll this
  timer = (newTimer)
  while ((secs timer) < secs) { doOneCycle this }
}

method startSteppingSafely Page startFlag {
  // Run the step loop as a subtask and restart it if an error is encountered.
  emergencyMemory = (newBinaryData 10000)
  if (isNil startFlag) { startFlag = false }
  stopAll this
  if startFlag { broadcastGo this }
  redrawAll this
  task = (newStepTask this)
  while true {
	resume task
	if ('timer' == (waitReason task)) {
	  msecsToWait = ((wakeMSecs task) - (msecsSinceStart))
	  if (msecsToWait > 0) { waitMSecs msecsToWait }
	} ('error' == (waitReason task)) {
	  stopAll this
	  emergencyMemory = nil
	  openDebugger task
	  task = (newStepTask this) // create a new task
	}
  }
}

method newStepTask Page {
  task = (newTask (newCommand 'interactionLoop' this))
  setField task 'tickLimit' 1000000
  setField task 'taskToResume' (currentTask)
  return task
}

method interactionLoop Page {
  while true { doOneCycle this }
}

// scheduling

method addSchedule Page aSchedule {add schedules aSchedule}

method stepSchedules Page {
  if (isEmpty schedules) {return}
  done = (list)
  for each schedules {
    step each
    if (isDone each) {add done each}
  }
  removeAll schedules done
}

method removeSchedulesFor Page op aMorph {
  if (isEmpty schedules) {return}
  newSchedules = (list)
  for each schedules {
    if (op == (op each)) {
      if (isClass aMorph 'Morph') {
        match = (aMorph == (first (args each)))
      } else {
        match = true
      }
    } else {
      match = false
    }
    if (not match) {add newSchedules each}
    // if (op != (op each)) {add newSchedules each}
  }
  schedules = newSchedules
}

// tasks

method launch Page cmdList targetObj doneAction {
  task = (newTask cmdList targetObj doneAction)
  addTask taskMaster task
  return task
}

method stopAll Page {
  stopEditing keyboard
  stopAllSounds soundMixer
  taskMaster = (newTaskMaster)
  return nil
}

method exitPresentationMode Page {
  for m (copy (parts morph)) {
	if (isClass (handler m) 'ScripterMenuBar') { exitPresentation (handler m) }
	if (isClass (handler m) 'ProjectEditor') { exitPresentation (handler m) }
  }
}

method isRunning Page cmdList rcvr { return (isRunning taskMaster cmdList rcvr) }
method stopRunning Page cmdList rcvr { stopRunning taskMaster cmdList rcvr }
method stopTasksFor Page rcvr { stopTasksFor taskMaster rcvr }

// menu

method showMenu Page aMenu x y {
  if (isNil x) {x = (half ((width morph) - (width (morph aMenu))))}
  if (isNil y) {y = (half ((height morph) - (height (morph aMenu))))}
  if (notNil activeMenu) {destroy (morph activeMenu)}
  removeTooltip this
  setPosition (morph aMenu) x y
  keepWithin (morph aMenu) (insetBy (bounds morph) 50)
  addPart morph (morph aMenu)
  activeMenu = aMenu
}

to inform details title yesLabel nonBlocking {
	return (inform (global 'page') details title yesLabel nonBlocking)
}

method closeUnclickedMenu Page aHandler {
  setCursor 'default'
  removeTooltip this
  removeAllHints this
  if (isNil activeMenu) {return}
  if (contains (allOwners (morph aHandler)) (morph activeMenu)) {return}
  if (and (isClass activeMenu 'Menu') (contains (triggers activeMenu) aHandler)) {return}
  destroy (morph activeMenu)
  activeMenu = nil
}

method hasActiveMenu Page { return (notNil activeMenu) }
method clearActiveMenu Page { activeMenu = nil }

// hint

method showHint Page aSpeechBubble isHint {
  removeHint this
  inset = 3
  if ('Browser' == (platform)) { inset = 2 }
  keepWithin (morph aSpeechBubble) (insetBy (bounds morph) (inset * (global 'scale')))
  addPart this aSpeechBubble
  step aSpeechBubble
  if isHint { activeHint = aSpeechBubble }
}

method removeHint Page {
  if (notNil activeHint) {
    destroy (morph activeHint)
    activeHint = nil
  }
}

method removeHintForMorph Page aMorph {
  for m (copy (parts morph)) {
    if (and (isClass (handler m) 'SpeechBubble') (aMorph == (clientMorph (handler m)))) {
      removeFromOwner m
    }
  }
}

method removeAllHints Page {
  for m (copy (parts morph)) {
    if (isClass (handler m) 'SpeechBubble') {
      removeFromOwner m
    }
  }
  activeHint = nil
}

// tooltips

method showTooltip Page aTooltip {
  removeTooltip this
  inset = 3
  if ('Browser' == (platform)) { inset = 2 }
  keepWithin (morph aTooltip) (insetBy (bounds morph) (inset * (global 'scale')))
  addPart this aTooltip
  activeTooltip = aTooltip
}

method removeTooltip Page {
  if (notNil activeTooltip) {
    destroy (morph activeTooltip)
    activeTooltip = nil
  }
}

// prompting and confirming

method clearPrompters Page {
    // Clear any existing prompters.

    p = (findMorph 'Prompter')
    while (notNil p) {
        destroy p
        p = (findMorph 'Prompter')
    }
}

method freshPrompt Page question default editRule callback details {
    clearPrompters this
    return (prompt this question default editRule callback details)
}

method prompt Page question default editRule callback details {
  // prompt can be used either as a reporter or as a command
  // if a callback is passed prompt is used as a command, when
  // the user accepts the prompter, the callback is called with
  // the user's answer
  // if no callback is given, this method eclipses the page's
  // main loop until the user terminates the prompter.
  // the reporter version is much nicer to user in scripts,
  // but it doesn't handle multiple prompters gracefully, unless
  // the user "backtracks" the prompters in the reverse order
  // of having opened them.
  // the callback version, otoh, handles any number and
  // sequence of prompters gracefully, but is more cumbersome
  // to use in scripts
  if (isNil editRule) { editRule = 'line' }
  p = (new 'Prompter')
  initialize p (localized question) (localized default) editRule callback details
  fixLayout p
  setPosition (morph p) (half ((width morph) - (width (morph p)))) (40 * (global 'scale'))
  addPart morph (morph p)
  edit (textBox p) hand
  selectAll (textBox p)
  if (isNil callback) {
    setField hand 'lastTouchTime' nil
    while (not (isDone p)) {doOneCycle this}
    destroy (morph p)
    return (answer p)
  }
}

method confirm Page title question yesLabel noLabel callback {
  // see comment for ::prompt
  p = (new 'Prompter')
  initializeForConfirm p title question yesLabel noLabel callback
  setPosition (morph p) (half ((width morph) - (width (morph p)))) (40 * (global 'scale'))
  addPart morph (morph p)
  if (isNil callback) {
    setField hand 'lastTouchTime' nil
    while (not (isDone p)) {doOneCycle this}
    destroy (morph p)
    return (answer p)
  }
}

method inform Page details title yesLabel nonBlocking {
  p = (new 'Prompter')
  initializeForInform p title details yesLabel
  setPosition (morph p) (half ((width morph) - (width (morph p)))) (40 * (global 'scale'))
  addPart morph (morph p)
  setField hand 'lastTouchTime' nil
  if (nonBlocking == true) { return true }
  while (not (isDone p)) {doOneCycle this}
  destroy (morph p)
  return (answer p)
}

// events

method handDownOn Page {return true}
method handUpOn Page {return true}
method clicked Page {return true}
method doubleClicked Page {return true}
method swipe Page {return true}

method wantsDropOf Page aHandler {
  return (or
    (devMode)
    (isClass aHandler 'ColorPicker')
    (and
      (hasField aHandler 'window')
      (isClass (getField aHandler 'window') 'Window')
    )
  )
}

method rightClicked Page {
  popUpAtHand (contextMenu this) this
  return true
}

// context menu

method contextMenu Page {
  menu = (menu 'GP' this)
  addItem menu 'GP version...' 'showGPVersion'
  addLine menu
  addItem menu 'show all' 'showAll' 'move any offscreen objects back into view'
  if (devMode) {
	addLine menu
	addItem menu 'broadcast "go"' 'broadcastGo'
	addItem menu 'stop all' 'stopAll' 'halt all currently running threads'
	addLine menu
	addItem menu 'enter project editor' (action 'startProjectEditorFromMorphic') 'enter the project editor'
	addItem menu 'workspace...' (action 'openWorkspace' this) 'open a window for interacting with text code'
	addItem menu 'trash can...' (action 'openTrashCan' this) 'open a window for deleting graphical elements'
	addItem menu 'notes...' (action 'openPresentation' this) 'open a window for presenting text headlines'
	addItem menu 'turtle...' 'addTurtle' 'create a new scriptable robot'
	addItem menu 'block editor...' (action 'openBlockEditor' this) 'open a window for assembling blocks code'
	addItem menu 'file list...' (action 'openFileList') 'open a list of files'
	addItem menu 'benchmark...' (action 'runBenchmarks') 'run some simple compute-speed benchmarks'
	addLine menu
	addItem menu 'exit developer mode' (action 'exitDeveloperMode' this) 'exit developer mode'
	if isShowingConnectors {
	  addItem menu 'hide connectors' 'toggleConnectors'
	} (notNil (detect (function each {return (isAnyClass (handler each) 'Inspector' 'Scripter' 'Explorer')}) (parts morph) nil)) {
	  addItem menu 'show connectors' 'toggleConnectors' 'connect Inspector widgets with inspected data'
	}
  } else {
	addItem menu 'notes...' (action 'openPresentation' this) 'open a window to add notes to this project'
  }
  addLine menu
  addItem menu 'quit' 'confirmToQuit'
  return menu
}

method showGPVersion Page {
  inform this (join 'GP Version ' (libraryVersion) (newline) (at (version) 1))
}

method broadcastGo Page { stopAll this; broadcast 'go' }
method runBenchmarks Page { inform this (tinyBenchmarks) }

method showAll Page {
  for m (parts morph) {
    keepWithin m (bounds morph)
    setAlpha m 255
	show m
  }
}

method addTurtle Page {
  t = (newTurtle)
  setField t 'x' (x hand)
  setField t 'y' (y hand)
  setPosition (morph t) (x hand) (y hand)
  addPart this t
}

method confirmToQuit Page {confirm this nil (join 'Are you sure' (newline) 'you want to quit GP?') nil nil 'exit'}

// foreground layer

method foreground Page {return foreground}
method createForeground Page {foreground = (newBitmap (width morph) (height morph))}
method deleteForeground Page {foreground = nil}

method drawForeground Page {
  if (notNil foreground) {drawBitmap nil foreground}
}

method resizeForeground Page {
  if (notNil foreground) {
    bm = (newBitmap (width this) (height this))
    drawBitmap bm foreground
    foreground = bm
  }
}

method requireForeground Page {
  if (or
	(isNil foreground)
	((width foreground) != (width morph))
	((height foreground) != (height morph))) {
		createForeground this
  } else {
    fill foreground (color 0 0 0 0)
  }
  return foreground
}

// display connectors

method isShowingConnectors Page { return isShowingConnectors }

method setIsShowingConnectors Page bool {
  isShowingConnectors = bool
  deleteForeground this
  changed this
}

method toggleConnectors Page {
  setIsShowingConnectors this (not isShowingConnectors)
}

method drawLinks Page {
  scale = (global 'scale')
  quickArrows = true
  if quickArrows {
	deleteForeground this
	pen = (newPen nil) // draw directly to the display buffer
  } else {
	pen = (newPen (requireForeground this))
  }
  projectEditor = (detect
    (function each {return (isClass (handler each) 'ProjectEditor')})
    (parts morph)
  )
  if (notNil projectEditor) {
    scripter = (morph (scripter (handler projectEditor)))
    sprites = (parts (morph (stage (handler projectEditor))))
  } else {
    sprites = (list)
  }

  // Draw links for any active MorphRefIcons
  if (notNil scripter) { drawMorphRefLinks (handler scripter) pen }
  if (not isShowingConnectors) { return } // don't show other links

  // draw connection of scripter to target object
  if (isNil scripter) {
    scripter = (detect
      (function each {return (isClass (handler each) 'Scripter')})
      (join (parts morph) (parts (morph hand)))
    )
  }
  if (and (notNil scripter) (isVisible scripter) (notNil (owner scripter)) (notNil (targetObj (handler scripter)))) {
    h = (targetObj (handler scripter))
    coll = (array)
    if (hasField h 'morph') {
      exemplar = (morph (targetObj (handler scripter)))
      coll = (intersectionsWithLineSegment (bounds scripter) (hCenter (bounds scripter)) (vCenter (bounds scripter)) (hCenter (bounds exemplar)) (vCenter (bounds exemplar)))
    }
    if (notEmpty coll) {
      pt = (first coll)
      ecx = (hCenter (bounds exemplar))
      ecy = (vCenter (bounds exemplar))
	  drawCircle pen (first pt) (last pt) (scale * 4) (gray 100) 1 (gray 255)
      if (containsPoint (bounds morph) ecx ecy) {
        drawArrow pen (first pt) (last pt) ecx ecy (gray 100)
      } else {
        coll = (intersectionsWithLineSegment (bounds morph) (first pt) (last pt) ecx ecy)
        if (notEmpty coll) {
          pt2 = (first coll)
          drawArrow pen (first pt) (last pt) (first pt2) (last pt2) (gray 100) true // no arrowhead
        }
      }
    }
  }

  // draw connection of the hand to its focus object (if any), confine to scrubbed texts
  if (isClass (focus hand) 'Text') {
    focus = (morph (focus hand))
    if (notNil focus) {
      coll = (intersectionsWithLineSegment (bounds focus) (hCenter (bounds focus)) (vCenter (bounds focus)) (x hand) (y hand))
      if (notEmpty coll) {
        pt = (first coll)
		drawCircle pen (first pt) (last pt) (scale * 4) (gray 120) 1 (gray 255)
		drawArrow pen (x hand) (y hand) (first pt) (last pt) (gray 120)
      }
    }
  }

  // draw connections involving inspectors, explorers and monitors
  inspectors = (filter
    (function each {return (isAnyClass (handler each) 'Inspector' 'Explorer' 'Monitor')})
    (join sprites (parts morph) (parts (morph hand)))
  )
  morphs = (join (allMorphs morph) (allMorphs (morph hand)))
  for each inspectors {
    if (isClass (handler each) 'Monitor') {
	  a = (getField (handler each) 'getAction')
	  if (and (notNil a) (notEmpty (arguments a))) {
		if ('eval' == (function a)) {
		  obj = (at (arguments a) 2)
		} else {
		  obj = (first (arguments a))
		}
	  }
    } else {
      obj = (getField (handler each) 'contents')
    }
    for other morphs {
      hdl = (handler other)
      if (isAnyClass (handler other) 'Inspector' 'Explorer') {
        sel = (currentSelection (handler other))
        ctr = (connectors (handler other))
        hlt = (currentHighlight (handler other))
      } else {
        sel = nil
        ctr = nil
        hlt = nil
      }
      if (and (notNil obj) (=== hdl obj)) {
        pt2 = (rotationCenter other)
        coll = (intersectionsWithLineSegment (bounds each) (hCenter (bounds each)) (vCenter (bounds each)) (first pt2) (last pt2))
        if (notEmpty coll) {
          pt = (first coll)
		  c = (gray 100)
          if (isClass (handler each) 'Monitor') { c = (bgColor (handler each)) }
		  drawCircle pen (first pt) (last pt) (scale * 4) c 1 (gray 255)
		  drawArrow pen (first pt) (last pt) (first pt2) (last pt2) c
        }
      }
      if (notNil ctr) {
        for connector ctr {
          if (=== obj (first connector)) {
            pt = (last connector)
            coll = (intersectionsWithLineSegment (bounds each) (hCenter (bounds each)) (vCenter (bounds each)) (first pt) (last pt))
            if (notEmpty coll) {
              cp = (first coll)
			  drawCircle pen (first pt) (last pt) (scale * 7) (color 0 120 30 120)
              drawArrow pen (first pt) (last pt) (first cp) (last cp) (color 0 120 30)
            }
          }
        }
      }
      if (and (notNil obj) (=== sel obj)) {
        lb = (getField (handler other) 'listBox')
        bds = (bounds (owner (morph lb)))
        cpx = (hCenter bds)
        cpy = (min (max (top bds) (vCenter (bounds (selectedMorph lb)))) (bottom bds))
        coll = (intersectionsWithLineSegment (bounds each) (hCenter (bounds each)) (vCenter (bounds each)) cpx cpy)
        if (notEmpty coll) {
          pt = (first coll)
          setColor pen (color 0 120 30)
          setLineWidth pen 1 // scale
          drawArrow pen cpx cpy (first pt) (last pt) (color 0 120 30)
        }
      }
      if (and (notNil obj) (=== hlt obj)) {
        lb = (getField (handler other) 'listBox')
        bds = (bounds (owner (morph lb)))
        cpx = (hCenter bds)
        cpy = (min (max (top bds) (vCenter (bounds (morph (highlighted lb))))) (bottom bds))
        setLineWidth pen (* scale 10)
        setColor pen (color 152 190 230 100)
        drawLine pen (hCenter (bounds each)) (vCenter (bounds each)) cpx cpy
        if (notNil (canvas pen)) {
		  fillRoundedRect (newShapeMaker (canvas pen)) (expandBy (bounds each) (scale * 2)) (scale * 5) (color 152 190 230 100)
		}
      }
    }
  }
}

// Dropped files (in Mac OS, file dropping only works when GP is packaged as an app)

method droppedFiles Page {
  // Return a list of dropFile events and clear droppedFiles.

  if (isEmpty droppedFiles) { return droppedFiles }
  result = droppedFiles
  droppedFiles = (list)
  return result
}

method droppedTexts Page {
  // Return a list of dropText events and clear droppedTexts.

  if (isEmpty droppedTexts) { return droppedTexts }
  result = droppedTexts
  droppedTexts = (list)
  return result
}

// Profiling

method startProfiling Page {
  clearProfileState this
  gc
  setField (currentTask) 'profileIndex' 1
  setField (currentTask) 'profileArray' (newArray 10000000)
  profileTimer = (newTimer)
  startProfileClock
}

method endProfiling Page {
  // Stop the profiler and return the profile.

  stopProfileClock
  if (notNil profileTimer) {
	msecs = (msecs profileTimer)
	profileTimer = nil
  }
  profileArray = (getField (currentTask) 'profileArray')
  profileIndex = (getField (currentTask) 'profileIndex')
  if (or (isNil profileArray) (isNil profileIndex)) {
	clearProfileState this
	return
  }
  gc
  data = (copyArray profileArray (profileIndex - 1))
  clearProfileState this
  gc
  result = (new 'Profile' data msecs)
  setGlobal 'lastProfile' result
  exploreProfile result
}

method clearProfileState Page {
  stopProfileClock
  setField (currentTask) 'profileIndex' nil
  setField (currentTask) 'profileArray' nil
  gc
}
// notePlayer.gp - Support for sampled instruments and drums.
//
// A NotePlayer generates one note. It supports pitch-shifting, optional looping (for sustaining
// the note), optional decay while sustaining, and smooth cut-offs.
//
// A SampledInstrument is a collection of sampled notes to cover different pitch ranges
// or different drums/percussion instruments.

defineClass NotePlayer samples sampledKey loopEnd loopLength decayStart decayRate totalSamples samplesPlayed incr index env startDelay

method play NotePlayer {
  // For testing. Example:
  //   p = (newSampledInstrument 'clarinet')
  //   for k (range 60 72) { play (notePlayer p k 170) }
  mixer = (getMixer)
  addSound mixer this
  while (not (isDone this)) {
	step mixer
	waitMSecs 5
  }
}

method setStartDelay NotePlayer n { startDelay = n }

method setPitchDurLoudness NotePlayer midiKey msecs loudness {
  // Follows MIDI conventions: midiKey is the key number, where 60 is middle-C. Fractional
  // key values are allowed to get pitches not in the equal-tempered scale.
  // Loudness range is 1-127. Internally, this range maps to an exponential curve.
  if (isNil loudness) { loudness = 80 }
  totalSamples  = (ceiling (msecs * 22.05))
  samplesPlayed = 0
  if (loopEnd == -1) {
	loopEnd = ((count samples) - 1)
	totalSamples = loopEnd
  }
  pitch = (keyToPitch this midiKey)
  originalPitch = (keyToPitch this sampledKey)
  incr = (pitch / originalPitch)
  index = 1
  env = ((raise 50 (loudness / 180)) / 50)
  startDelay = 0 // may be changed by score player
}

method keyToPitch NotePlayer midiKey {
  midiKey = (clamp midiKey 0 127)
  return (440 * (raise 2 ((midiKey - 69) / 12))) // midi key 69 is 440 Hz (A above middle C)
}

// sample generation (mixer API)

method sound NotePlayer { return this }
method isDone NotePlayer { return (samplesPlayed >= totalSamples) }

method mixIntoBuffer NotePlayer buffer {
  if true { // make false to disable the primitive
	generateNoteSamples this buffer
	return
  }
  bufferSize = (count buffer)
  if (startDelay >= bufferSize) {
	startDelay = (startDelay - bufferSize)
	return
  }
  for i (range (startDelay + 1) bufferSize) {
	if (samplesPlayed >= totalSamples) { return }
	intPart = (truncate index)
	frac = (index - intPart)
	s0 = (at samples intPart)
	s1 = (at samples (intPart + 1))
	interpolated = (s0 + (truncate (frac * (s1 - s0))))

	// mix in the interpolated sample scaled by the envelope
	mixed = ((at buffer i) + (truncate (env * interpolated)))
	if (mixed > 32767) { mixed = 32767; clip = true }
	if (mixed < -32768) { mixed = -32768; clip = true }
	atPut buffer i mixed

	// update source index
	index += incr
	if (index > loopEnd) {
	  if (loopLength == 0) { // unlooped sound; stop playing
		samplesPlayed = totalSamples
		return
	  }
	  index = (index - loopLength)
	}

	// update the envelope
	if ((totalSamples - samplesPlayed) < 100) { // note cutoff ("release")
	  env = (0.9 * env) // decay to silence in 100 samples (about 4.5 msecs)
	} (samplesPlayed > decayStart) { // decay while note is playing
	  env = (decayRate * env)
	}
	samplesPlayed += 1
  }
  startDelay = 0
}

defineClass SampledInstrument instrumentName sampleSet

method instrumentName SampledInstrument { return instrumentName }

to newSampledInstrument instName {
  if (isClass instName 'Array') { // allow using sample array as an instrument
	return (sampledInstrumentFromSamples instName)
  }
  return (init (new 'SampledInstrument') instName)
}

to sampledInstrumentFromSamples samples midiKey instrName {
  if (isNil midiKey) { midiKey = 72 }
  if (isNil instrName) { instrName = 'samples' }
  instrument = instrName
  sampleSet = (list
	(list 128 samples midiKey -1 -1 0 0)) // unlooped, no decay
  return (new 'SampledInstrument' instrName sampleSet)
}

to instrumentNames {
  return (list
	'bass' 'bassoon' 'brass' 'clarinet' 'drums' 'electric piano' 'guitar'
	'marimba' 'organ' 'piano' 'pizz' 'sax' 'steel drum' 'strings' 'vibraphone'
  )
}

method init SampledInstrument instName {
  instrumentName = instName
  loadSamples this instName
  if (isEmpty sampleSet) {
	error 'Could not load instrument' instName
  }
  return this
}

method notePlayer SampledInstrument midiKey msecs loudness {
  // Return a NotePlayer for a note with the given parameters.
  // Spec format for non-drum instruments:
  //   <key> <samples> <sampled key> <loop start> <loop end> <decay start> <decay>

  if ('drums' == instrumentName) {
	return (drumPlayer this midiKey msecs loudness)
  }
  spec = (specForKey this midiKey)
  samples = (at spec 2)
  sampledKey = (at spec 3)
  loopEnd = (at spec 5)
  loopLength = (loopEnd - (at spec 4))
  decayStart = (truncate (22.050 * (at spec 6)))
  if ((at spec 7) == 0) {
	decayRate = 1 // no decay
  } else {
	decayRate = (raise 33000 (-1 / (22050 * (at spec 7))))
  }
  note = (new 'NotePlayer' samples sampledKey loopEnd loopLength decayStart decayRate)
  setPitchDurLoudness note midiKey msecs loudness
  return note
}

method specForKey SampledInstrument midiKey {
  for spec sampleSet {
	if ((first spec) >= midiKey) { return spec }
  }
  return (last sampleSet)
}

method drumPlayer SampledInstrument midiKey msecs loudness {
  // Return a NotePlayer for drum with the given parameters.
  // Spec format for drums:
  //   <key> <sample file> <pitch shift in semitones> [<loop start> <loop end> [<decay>]]

  midiKey = (toInteger midiKey)
  if (or (midiKey < 35) (midiKey > 81)) {
	midiKey = 75 // placeholder for keys outside the drum range
  }
  spec = (at sampleSet (midiKey - 34)) // drum spec
  samples = (at spec 2)
  sampledKey = (midiKey - (at spec 3)) // adjusted by pitch shift
  loopEnd = -1
  loopLength = 0
  decayStart = 0
  decayRate = 1 // no decay
  if ((count spec) > 3) {
	loopEnd = (at spec 5)
	loopLength = (loopEnd - (at spec 4))
  }
  if ((count spec) > 5) {
	decayRate = (raise 33000 (-1 / (22050 * (at spec 6))))
  }
  note = (new 'NotePlayer' samples sampledKey loopEnd loopLength decayStart decayRate)
  setPitchDurLoudness note midiKey msecs loudness
  return note
}

method loadSamples SampledInstrument instName {
  if ('bass' == instName) { specs = (bassSamples this)
  } ('bassoon' == instName) { specs = (bassoonSamples this)
  } ('brass' == instName) { specs = (brassSamples this)
  } ('clarinet' == instName) { specs = (clarinetSamples this)
  } ('drums' == instName) { specs = (drumSamples this)
  } ('electric piano' == instName) { specs = (electricPianoSamples this)
  } ('guitar' == instName) { specs = (guitarSamples this)
  } ('marimba' == instName) { specs = (marimbaSamples this)
  } ('organ' == instName) { specs = (organSamples this)
  } ('piano' == instName) { specs = (pianoSamples this)
  } ('pizz' == instName) { specs = (pizzSamples this)
  } ('sax' == instName) { specs = (saxSamples this)
  } ('steel drum' == instName) { specs = (steelDrumSamples this)
  } ('strings' == instName) { specs = (stringSamples this)
  } ('vibraphone' == instName) { specs = (vibraphoneSamples this)
  } else {
	print 'No' instName '-- using "piano"'
  	specs = (pianoSamples this)
  }
  sampleSet = (list)
  for spec specs {
	data = (loadSampleFile this (at spec 2))
	if (notNil data) {
	  atPut spec 2 data
	  add sampleSet spec
	}
  }
}

method loadSampleFile SampledInstrument baseName {
  // Load a sample file (WAV file) with the given base name.
  // Sample data is cached so there is only one copy of each in memory.

  instrumentData = (global 'instrumentData')
  if (isNil instrumentData) {
	instrumentData = (dictionary)
	setGlobal 'instrumentData' instrumentData
  }
  if (contains instrumentData baseName) {
	return (at instrumentData baseName)
  }
  fName = (join (runtimeFolder 'instruments/') baseName '.wav')
  if ('drums' == instrumentName) {
	fName = (join (runtimeFolder 'instruments/drums/') baseName '.wav')
  }
  snd = (readWAVFile fName)
  if (notNil snd) {
	if (and (22050 == (samplingRate snd)) (false == (isStereo snd))) {
	  samples = (samples snd)
	  atPut instrumentData baseName samples
	  return samples
	} else {
	  print fName 'is not the right format for a SampledInstrument (mono 22050 samples/second)'
	}
  }
  return nil
}

method bassSamples SampledInstrument {
  return (list
	(list 34 'ElectricBass_G1' 31 41912 42363 0 17)
	(list 48 'ElectricBass_G1' 31 41912 42363 0 14)
	(list 64 'ElectricBass_G1' 31 41912 42363 0 12)
	(list 128 'ElectricBass_G1' 31 41912 42363 0 10))
}

method bassoonSamples SampledInstrument {
  return (list
	(list 57 'Bassoon_C3' 48 2428 4284 0 0)
	(list 67 'Bassoon_C3' 48 2428 4284 0 0)		// [40 0 0)) used slower attack [40 0 0))
	(list 76 'Bassoon_C3' 48 2428 4284 0 0)		// [80 0 0)) used slower attack [80 0 0))
	(list 84 'EnglishHorn_F3' 53 7538 8930 0 0)	// [40 0 0)) used slower attack [40 0 0))
	(list 128 'EnglishHorn_D4' 62 4857 5231 0 0))
}

method brassSamples SampledInstrument {
  return (list
	(list 30 'BassTrombone_A2_3' 45 1357 2360 0 0)
	(list 40 'BassTrombone_A2_2' 45 1893 2896 0 0)
	(list 55 'Trombone_B3' 59 2646 3897 0 0)
	(list 88 'Trombone_B3' 59 2646 3897 0 0)	// [50 0 0)) used slower attack
	(list 128 'Trumpet_E5' 76 2884 3152 0 0))
}

method clarinetSamples SampledInstrument {
  return (list
	(list 128 'Clarinet_C4' 60 14540 15468 0 0))
}

method electricPianoSamples SampledInstrument {
  return (list
	(list 48 'ElectricPiano_C2' 36 15338 17360 80 10)
	(list 74 'ElectricPiano_C4' 60 11426 12016 40 8)
	(list 128 'ElectricPiano_C4' 60 11426 12016 0 6))
}

method guitarSamples SampledInstrument {
  return (list
	(list 40 'AcousticGuitar_F3' 53 36665 36791 0 15)
	(list 56 'AcousticGuitar_F3' 53 36665 36791 0 13.5)
	(list 60 'AcousticGuitar_F3' 53 36665 36791 0 12)
	(list 67 'AcousticGuitar_F3' 53 36665 36791 0 8.5)
	(list 72 'AcousticGuitar_F3' 53 36665 36791 0 7)
	(list 83 'AcousticGuitar_F3' 53 36665 36791 0 5.5)
	(list 128 'AcousticGuitar_F3' 53 36665 36791 0 4.5))
}

method marimbaSamples SampledInstrument {
  return (list
	(list 128 'Marimba_C4' 60 -1 -1 0 0)) // unlooped
}

method organSamples SampledInstrument {
  return (list
	(list 128 'Organ_G2' 43 1306 3330 0 0)) // no decay
}

method pianoSamples SampledInstrument {
  return (list
	(list 38 'AcousticPiano_As3' 58 10266 17053 100 22)
	(list 44 'AcousticPiano_C4' 60 13968 18975 100 20)
	(list 51 'AcousticPiano_G4' 67 12200 12370 80 18)
	(list 62 'AcousticPiano_C6' 84 13042 13276 80 16)
	(list 70 'AcousticPiano_F5' 77 12425 12965 40 14)
	(list 77 'AcousticPiano_Ds6' 87 12368 12869 20 10)
	(list 85 'AcousticPiano_Ds6' 87 12368 12869 0 8)
	(list 90 'AcousticPiano_Ds6' 87 12368 12869 0 6)
	(list 96 'AcousticPiano_D7' 98 7454 7606 0 3)
	(list 128 'AcousticPiano_D7' 98 7454 7606 0 2))
}

method pizzSamples SampledInstrument {
  return (list
	(list 38 'Pizz_G2' 43 8554 8782 0 5)
	(list 45 'Pizz_G2' 43 8554 8782 12 4)
	(list 56 'Pizz_A3' 57 11460 11659 0 4)
	(list 64 'Pizz_A3' 57 11460 11659 0 3.2)
	(list 72 'Pizz_E4' 64 17525 17592 0 2.8)
	(list 80 'Pizz_E4' 64 17525 17592 0 2.2)
	(list 128 'Pizz_E4' 64 17525 17592 0 1.5))
}

method saxSamples SampledInstrument {
  return (list
	(list 40 'TenorSax_C3' 48 8939 10794 0 0)
	(list 50 'TenorSax_C3' 48 8939 10794 0 0)	// [20 0 0)) used slower attack
	(list 59 'TenorSax_C3' 48 8939 10794 0 0)	// [40 0 0)) used slower attack
	(list 67 'AltoSax_A3' 57 8546 9049 0 0)
	(list 75 'AltoSax_A3' 57 8546 9049 0 0)		// [20 0 0)) used slower attack
	(list 80 'AltoSax_A3' 57 8546 9049 0 0)		// [20 0 0)) used slower attack
	(list 128 'AltoSax_C6' 84 1258 1848 0 0))
}

method steelDrumSamples SampledInstrument {
  return (list
	(list 128 'SteelDrum_D5' 74.4 -1 -1 0 2)) // unlooped
}

method stringSamples SampledInstrument { // too much bow chiff; slow attacks on low range
  return (list
	(list 41 'Cello_C2' 36 8548 8885 0 0)
	(list 52 'Cello_As2' 46 7465 7845 0 0)
	(list 62 'Violin_D4' 62 10608 11360 0 0)
	(list 75 'Violin_A4' 69 3111 3314 0 0)		// [70 0 0)) used slower attack
	(list 128 'Violin_E5' 76 2383 2484 0 0))
}

method vibraphoneSamples SampledInstrument {
  return (list
	(list 38 'Vibraphone_C3' 48 6202 6370 100 8)
	(list 48 'Vibraphone_C3' 48 6202 6370 100 7.5)
	(list 59 'Vibraphone_C3' 48 6202 6370 60 7)
	(list 70 'Vibraphone_C3' 48 6202 6370 40 6)
	(list 78 'Vibraphone_C3' 48 6202 6370 20 5)
	(list 86 'Vibraphone_C3' 48 6202 6370 0 3)
	(list 128 'Vibraphone_C3' 48 6202 6370 0 2))
}

method drumSamples SampledInstrument {
  // Return an array of drum specs that spans the MIDI key range 35-81.
  // Spec format for drums:
  //   <key> <sample file> <pitch shift in semitones> <loop start> <loop end> <decay>
  // Loop start/stop and decay are optional.

  return (array
	(list 35 'BassDrum' -9)
	(list 36 'BassDrum' 0)
	(list 37 'SideStick' 0)
	(list 38 'SnareDrum' 0)
	(list 39 'Clap' 0)
	(list 40 'SnareDrum' 2)
	(list 41 'Tom' -9 7260 7483 4)
	(list 42 'HiHatClosed' 0)
	(list 43 'Tom' -5 7260 7483 3.2)
	(list 44 'HiHatPedal' 0)
	(list 45 'Tom' 0 7260 7483 3)
	(list 46 'HiHatOpen' -8)
	(list 47 'Tom' 2 7260 7483 3)
	(list 48 'Tom' 7 7260 7483 2.7)
	(list 49 'Crash' -8)
	(list 50 'Tom' 10 7260 7483 2.7)
	(list 51 'HiHatOpen' -2) // ride cymbal 1
	(list 52 'Crash' -11) // chinese cymbal
	(list 53 'HiHatOpen' 2) // ride bell
	(list 54 'Tambourine' 0)
	(list 55 'Crash' 0 -1 -1 3.5) // splash cymbal
	(list 56 'Cowbell' 0)
	(list 57 'Crash' -8 -1 -1 3.5) // unlooped
	(list 58 'Vibraslap' -6)
	(list 59 'HiHatOpen' 2) // ride cymbal 2
	(list 60 'Bongo' 0)
	(list 61 'Bongo' 2)
	(list 62 'Conga' -5 4247 4499 0.2)
	(list 63 'Conga' -5 4247 4499 2)
	(list 64 'Conga' -12 4247 4499 6)
	(list 65 'Bongo' 15) // high timbale
	(list 66 'Bongo' 8) // low timbale
	(list 67 'Cowbell' 19) // high agogo
	(list 68 'Cowbell' 12) // low agogo
	(list 69 'Cabasa' 0)
	(list 70 'Maracas' 0)
	(list 71 'Cuica' 12) // short whistle
	(list 72 'Cuica' 5) // long whistle
	(list 73 'GuiroShort' 0)
	(list 74 'GuiroLong' 0)
	(list 75 'Claves' 0)
	(list 76 'WoodBlock' 0)
	(list 77 'WoodBlock' -4)
	(list 78 'Cuica' -5)
	(list 79 'Cuica' 0)
	(list 80 'Triangle' -6 16843 17255 0.4) // (mute triangle)
	(list 81 'Triangle' -6 16843 17255 6))
}
// Bitmap pixel access as single list of pixels
// Mark Guzdial, August 2015
// Subset of Mark's original version integrated into GP by John Maloney

to self_getPixels bm {
  m = (morph (implicitReceiver))
  if (isNil bm) {
	bm = (costumeData m)
  } else {
	if (isClass bm 'String') {
	  bm = (imageNamed bm m)
	}
	if (not (isClass bm 'Bitmap')) { return (array) }
	m = nil // don't update morph when setting pixels
  }
  allpixels = (list)
  pixels = (pixelData bm)
  for i (count pixels) {
	add allpixels (new 'Pixel' pixels i m)
  }
  return allpixels
}

to self_getPixelXY x y bm {
  // Return the pixel at x,y in the given bitmap or the current costume.
  m = (morph (implicitReceiver))
  if (isNil bm) {
	bm = (costumeData m)
  } else {
	if (isClass bm 'String') {
	  bm = (imageNamed bm m)
	}
	if (not (isClass bm 'Bitmap')) { error 'No image with that name' }
	m = nil // don't update morph when setting pixels
  }
  pixels = (pixelData bm)
  x = (round x)
  y = (round y)
  if (or (x < 1) (x > (width bm))) { error (join 'x must be between 1 and ' (width bm)) }
  if (or (y < 1) (y > (height bm))) { error (join 'y must be between 1 and ' (height bm)) }
  i = (((y - 1) * (width bm)) + x)
  return (new 'Pixel' pixels i m)
}

to self_copycostume name {
  m = (morph (implicitReceiver))
  self_setCostume name
  setCostume m (copy (costumeData m))
  costumeChanged m
}

// Let pixel getters work with both pixels and color objects:

to getRed obj { return (red obj) }
to getGreen obj { return (green obj) }
to getBlue obj { return (blue obj) }

// Pixel Class

defineClass Pixel pixels index targetMorph

method red Pixel { return (((getPixelRGB pixels index) >> 16) & 255) }
method green Pixel { return (((getPixelRGB pixels index) >> 8) & 255) }
method blue Pixel { return ((getPixelRGB pixels index) & 255) }

method setRed Pixel newRed {
  alpha = (getPixelAlpha pixels index)
  rgb = (getPixelRGB pixels index)
  red = (clamp (round newRed) 0 255)
  green = ((rgb >> 8) & 255)
  blue = (rgb & 255)
  setPixelRGBA pixels index red green blue alpha
  if (notNil targetMorph) { costumeChanged targetMorph }
}

method setGreen Pixel newGreen {
  alpha = (getPixelAlpha pixels index)
  rgb = (getPixelRGB pixels index)
  red = ((rgb >> 16) & 255)
  green = (clamp (round newGreen) 0 255)
  blue = (rgb & 255)
  setPixelRGBA pixels index red green blue alpha
  if (notNil targetMorph) { costumeChanged targetMorph }
}

method setBlue Pixel newBlue {
  alpha = (getPixelAlpha pixels index)
  rgb = (getPixelRGB pixels index)
  red = ((rgb >> 16) & 255)
  green = ((rgb >> 8) & 255)
  blue = (clamp (round newBlue) 0 255)
  setPixelRGBA pixels index red green blue alpha
  if (notNil targetMorph) { costumeChanged targetMorph }
}

method setColor Pixel color {
  alpha = (getPixelAlpha pixels index)
  setPixelRGBA pixels index (red color) (green color) (blue color) alpha
  if (notNil targetMorph) { costumeChanged targetMorph }
}

method getColor Pixel {
  alpha = (getPixelAlpha pixels index)
  rgb = (getPixelRGB pixels index)
  red = ((rgb >> 16) & 255)
  green = ((rgb >> 8) & 255)
  blue = (rgb & 255)
  return (color red green blue alpha)
}

method setGray Pixel grayLevel {
  alpha = (getPixelAlpha pixels index)
  rgb = (getPixelRGB pixels index)
  gray = (clamp (round grayLevel) 0 255)
  setPixelRGBA pixels index gray gray gray alpha
  if (notNil targetMorph) { costumeChanged targetMorph }
}

method getX Pixel {
  bm = (costumeData targetMorph)
  if (index < 1) { return 1 }
  i = (toInteger ((index - 1) % (width bm)))
  return (i + 1)
}

method getY Pixel {
  bm = (costumeData targetMorph)
  i = (toInteger ((index - 1) / (width bm)))
  if (i >= (height bm)) { return (height bm) }
  return (i + 1)
}
// code statistics

to codeStats {
  comment '
	Print statistics about the number classes and functions.'

  classNames = (list)
  methodCount = 0
  classes = (classes)
  for i (count classes) {
    c = (at classes i)
	add classNames (className c)
    methodCount += (count (methods c))
  }
  print (count classNames) 'classes,' methodCount 'methods,' (count (functions)) 'generic functions,' (count (primitives)) 'primitives'
  classNames = (sorted (toArray classNames))
  for i (count classNames) {
    cName = (at classNames i)
    print '  ' cName '--' (count (methods (class cName))) 'methods'
  }
}

// class documentation

to documentationFor className {
  comment '
	Return a string containing a commented list of methods for the given clas.
	If className is omitted, return documentation for the generic functions.'
  if (notNil className) {
    functionList = (methods (class className))
  } else {
    functionList = (functions)
  }
  result = (list)
  for i (count functionList) {
    f = (at functionList i)
	comment = (firstComment f)
	add result (functionName f)
	if (notNil comment) { add result comment }
	add result (newline)
	add result (newline)
  }
  return (joinStringArray (toArray result))
}

to firstComment func {
  comment '
	If the first command of the given function is a comment command,
	return its argument (typically a string). Otherwise, return nil.'

  firstCmd = (cmdList func)
  if (isClass firstCmd 'Command') {
    args = (argList firstCmd)
    if (and ('comment' == (primName firstCmd)) ((count args) > 0)) {
	  result = (at args 1)
	  if (isClass result 'String') { return result }
	}
  }
  return nil
}

// cache clearing

to clearMethodCaches {
  // Clear inline caches and global method cache.

  for cmd (allInstances 'Command') { clearCache cmd }
  for r (allInstances 'Reporter') { clearCache r }
  clearMethodCache
}

// primitive check

to hasPrimitive primName {
  return (not (beginsWith (call 'help' primName) 'Unknown'))
}

to primitiveHelpString primName {
  // Return the primitive help string.
  setFont 'Arial' (12 * (global 'scale'))
  return (joinStrings (wordWrapped (call 'help' primName) 300) (newline))
}

// callers and implementors

to containsCall script calleeName {
  // Returns true if the given script includes a call to callee.

	for cmdOrReporter (allBlocks script) {
		blockSpec = (specForOp (authoringSpecs) (primName cmdOrReporter))
		if (notNil blockSpec) {
			for spec (specs blockSpec) {
				if ((find (letters spec) (letters calleeName)) != 0) {
					return true
				}
			}
		}
	}
	return false
}

to callers calleeName {
  comment '
	Return a list of functions (methods) that call the given function.'

  results = (list)
  classes = (classes)
  for i (count classes) {
    c = (at classes i)
	for j (count (methods c)) {
	  m = (at (methods c) j)
	  if (contains (allCalls m) calleeName) {
	    add results (array (className c) (functionName m))
	  }
    }
  }
  for i (count (functions)) {
    f = (at (functions) i)
	if (contains (allCalls f) calleeName) {
      add results (array '<generic>' (functionName f))
    }
  }
  return (toArray results)
}

to implementors funcName {
  comment '
	Return a list of classes that implement the given function.'

  results = (list)
  classes = (classes)
  for i (count classes) {
    c = (at classes i)
	for j (count (methods c)) {
	  m = (at (methods c) j)
	  if ((functionName m) == funcName) {
	    add results (className c)
	  }
    }
  }
  for i (count (functions)) {
    f = (at (functions) i)
	if ((functionName f) == funcName) {
      add results '<generic>'
    }
  }
  if (contains (primitives) funcName) { addFirst results '<primitive>' }
  return (toArray results)
}

to uncalledAndUnimplemented {
  // Print lists of functions that are not called and
  // functions that are called but not implemented.

  allCalled = (dictionary)
  allImplemented = (dictionary)
  addAll allImplemented (primitives)
  classes = (classes)
  for i (count classes) {
    c = (at classes i)
	for j (count (methods c)) {
	  m = (at (methods c) j)
	  addAll allCalled (keys (allCalls m))
	  add allImplemented (functionName m)
    }
  }
  for i (count (functions)) {
    f = (at (functions) i)
	addAll allCalled (keys (allCalls f))
	add allImplemented (functionName f)
  }

  uncalled = (dictionary)
  names = (keys allImplemented)
  for i (count names) {
    n = (at names i)
	if (not (contains allCalled n)) {
	  add uncalled n
	}
  }
  removeAll uncalled (primitives)

  unimplemented = (dictionary)
  names = (keys allCalled)
  for i (count names) {
    n = (at names i)
	if (not (contains allImplemented n)) {
      add unimplemented n
    }
  }

  print (count uncalled) 'uncalled functions: ' (toString (keys uncalled) 10000)
  print (count unimplemented) 'unimplemented functions: ' (toString (keys unimplemented) 10000)
}

// deep copy

to deepCopy anObject ignore copyDict {
  if (isNil ignore) { ignore = (array) }
  if (isNil copyDict) { copyDict = (dictionary) }
  if (contains ignore anObject) { return nil }
  if (isAnyClass anObject 'Boolean' 'ExternalReference' 'Float' 'Integer' 'Nil' 'String') {
	return anObject
  }
  if (contains copyDict anObject) { return (at copyDict anObject) }
  dup = (clone anObject)
  if (isClass anObject 'Texture') { dup = (copyTexture anObject) }
  atPut copyDict anObject dup
  if (isClass dup 'BinaryData') { return dup }
  for i (objWords dup) {
	setField dup i (deepCopy (getField dup i) ignore copyDict)
  }
  return dup
}
// sound.gp - Sampled sounds and sound mixer using SDL2 sound output

defineClass Sound samples samplingRate isStereo name

method samples Sound { return samples }
method samplingRate Sound { return samplingRate }
method isStereo Sound { return isStereo }
method name Sound { return name }
method setName Sound s { name = s }

to newSound samples samplingRate isStereo name {
  if (isNil samples) { samples = (array) }
  if (isNil samplingRate) { samplingRate = 22050 }
  if (isNil isStereo) { isStereo = false }
  if (isNil name) { name = '' }
  return (new 'Sound' samples samplingRate isStereo name)
}

method shrinkSound Sound {
  // Reduce to a single channel with a sampling rate of under 32k.

  skip = 1
  if (samplingRate > 32000) {
	skip = (max 1 (truncate (samplingRate / 16000)))
	newSamplingRate = (samplingRate / skip)
  }
  if isStereo {
	skip = (2 * skip)
  }
  if (skip < 2) { return this }
  newSampleCount = (truncate ((count samples) / skip))
  newSamples = (newArray newSampleCount)
  src = 1
  if isStereo {
	for dst newSampleCount {
		s = ((at samples src) + (at samples (src + 1)))
		atPut newSamples dst (s >> 1) // average (use shift for integer divide by 2)
		src += skip
	}
  } else { // mono
	for dst newSampleCount {
		atPut newSamples dst (at samples src)
		src += skip
	}
  }
  return (newSound newSamples newSamplingRate false name)
}

method play Sound { play (newSamplePlayer this) }

defineClass SamplePlayer sound incr index

to newSamplePlayer snd { return (initialize (new 'SamplePlayer') snd) }

method initialize SamplePlayer snd {
  sound = snd
  incr = ((samplingRate snd) / 22050)
  index = 1
  return this
}

// sample generation (mixer API)

method sound SamplePlayer { return sound }
method isDone SamplePlayer { return (index >= (count (samples sound))) }

method mixIntoBuffer SamplePlayer buffer {
  samples = (samples sound)
  srcChannels = 1
  end = (count samples)
  if (isStereo sound) {
	srcChannels = 2
	end = (end - 1)
  }
  for i (count buffer) {
	srcIndex = ((truncate index) * srcChannels)
	if (srcIndex >= end) { return }
	sample = (at samples srcIndex)
	if (not (isNumber sample)) {
	  index = (count samples)
	  return
	}
	frac = (index - (truncate index))
	if (frac != 0) { // interpolate between samples
	  nextIndex = (srcIndex + srcChannels)
	  sample += (truncate (frac * ((at samples nextIndex) - sample)))
	}
	// mix this sample into buffer
	out = ((at buffer i) + sample)
	if (out > 32767) { out = 32767 }
	if (out < -32768) { out = -32768 }
	atPut buffer i out
	index += incr
  }
}

method play SamplePlayer {
  // Useful for testing from command line.
  mixer = (getMixer)
  addSound mixer this
  while (not (isDone this)) {
	step mixer
	waitMSecs 5
  }
}


defineClass SoundMixer players buffer msecs lastMixMSecs speechPIDs

method hasPlayingSounds SoundMixer { return ((count players) > 0) }
method msecs SoundMixer { return (round msecs) }
method nextMSecs SoundMixer = { return (round (msecs + ((count buffer) / 22.050))) }

method estimatedMSecs SoundMixer {
  return (msecs + ((msecsSinceStart) - lastMixMSecs))
}

to newSoundMixer { return (reset (new 'SoundMixer')) }

to getMixer {
  // Get an existing sound mixer if there is one. Create one and
  // remember it if there isn't. Works in the prompt and in Morphic.
  mixer = (global 'mixer')
  if (notNil mixer) { return mixer }
  page = (global 'page')
  if (notNil page) { return (soundMixer page) }
  mixer = (newSoundMixer)
  setGlobal 'mixer' mixer
  return mixer
}

method reset SoundMixer {
  stopSpeaking this
  closeAudio
  players = (list)
  buffer = nil
  msecs = 0
  lastMixMSecs = (msecsSinceStart)
  return this
}


method stopAllSounds SoundMixer {
  stopSpeaking this
  stopAudioInput
  players = (list)
}

method isPlaying SoundMixer snd {
  for p players {
	if ((sound p) == snd) { return true }
  }
  return false
}

method addSound SoundMixer snd {
  if (isClass snd 'Sound') {
	add players (newSamplePlayer snd)
  } else {
	add players snd
  }
}

method removeSound SoundMixer snd {
  newPlayers = (list)
  for p players {
	if ((sound p) != snd) { add newPlayers p }
  }
  players = newPlayers
}

method step SoundMixer {
  // Mix and output samples for all sound players.

  if (isEmpty players) { return }

  // bufferSize is a tradeoff between low latency (starting sounds quickly) and avoiding skipping. A size
  // of 1024 works on a Mac Powerbook, but some browsers (e.g. Safari) need more.
  bufferSize = 2048
  if ('Browser' == (platform)) { bufferSize = 8192 }
  if (isNil buffer) {
    openAudio bufferSize
    if ((samplesNeeded) > 0) { bufferSize = (samplesNeeded) } // buffer may be smaller than requested
	buffer = (newArray bufferSize)
	msecs = 0
  }
  if ((samplesNeeded) == 0) { return }
  lastMixMSecs = (msecsSinceStart)

  finished = (list)
  fillArray buffer 0
  for p (copy players) {
	mixIntoBuffer p buffer
	if (isDone p) { add finished p }
  }
  writeSamples buffer
  if ((count finished) > 0) { removeAll players finished }
  msecs += ((count buffer) / 22.050)
  gcIfNeeded
}

method speak SoundMixer text voice rate {
  if (isNil voice) { voice = 'Alex' }
  if (isNil rate) { rate = 150 }
  pid = (startSpeech text voice rate)
  add speechPIDs pid
}

method stopSpeaking SoundMixer {
  if (isNil speechPIDs) { speechPIDs = (list) }
  for pid speechPIDs { stopSpeech pid }
  speechPIDs = (list)
}

to soundInput {
  // Wait for sound input and return an array of signed, 16-bit integer samples.
  startAudioInput 1024 22050
  while true {
	buf = (readAudioInput)
	if (notNil buf) { return buf }
	waitMSecs 1
  }
}
// classes for viewing the contents of a Table

defineClass TableCell morph data isLabel isRowCount

method initialize TableCell cellData width height labelFlag rowCountFlag {
  if (isNil labelFlag) {labelFlag = false}
  if (isNil rowCountFlag) {rowCountFlag = false}
  morph = (newMorph this)
  data = cellData
  isLabel = labelFlag
  isRowCount = rowCountFlag
  setExtent morph width height
  return this
}

method setData TableCell cellData {
  data = cellData
  redrawData this
}

method redraw TableCell {
  bm = (newBitmap (width morph) (height morph))
  setCostume morph bm
  redrawData this
}

method redrawData TableCell {
  bm = (costumeData morph)
  txt = (toString data)

  if (isNil data) {return}
  if isLabel {
    fillPixelsRGBA (pixelData bm) 220 220 220 255
    if isRowCount {
      setFont 'Arial Italic' (* 10 (global 'scale'))
    } else {
      setFont 'Arial Bold' (* 12 (global 'scale'))
    }
  } else {
    fillPixelsRGBA (pixelData bm) 255 255 255 255
    setFont 'Arial' (* 12 (global 'scale'))
  }
  w = (stringWidth txt)
  h = (fontHeight)
  wd = ((width bm) - w)
  x = (max 0 (wd / 2))
  hd = ((height bm) - h)
  y = (max 0 (hd / 2))
  drawString bm txt nil (truncate x) (truncate y) // avoid creating a Color object
  // note: don't propagate the "changed" flag, let the tabe view handle this for all
}


method blankOut TableCell {
  fillPixelsRGBA (pixelData (costumeData morph)) 0 0 0 0
}

defineClass TableView morph data lastChangeCount startCol startRow cellWidth cellHeight padding cols rows rowLabelWidth

method initialize TableView aTable startC startR cellW cellH pad w h {
  if (isNil aTable) {aTable = (table)}
  if (isNil startC) {startC = 1}
  if (isNil startR) {startR = 1}
  if (isNil cellW) {cellW = (100 * (global 'scale'))}
  if (isNil cellH) {cellH = (20 * (global 'scale'))}
  if (isNil pad) {pad = (global 'scale')}
  if (isNil w) {w = (250 * (global 'scale'))}
  if (isNil h) {h = (150 * (global 'scale'))}
  data = aTable
  startCol = startC
  startRow = startR
  cellWidth = cellW
  cellHeight = cellH
  padding = pad
  rowLabelWidth = (rowLabelWidth this)
  morph = (newMorph this)
  setClipping morph true
  setExtent morph w h
  setFPS morph 5
  return this
}

method setData TableView aTable startC startR cellW cellH {
  if (isNil aTable) {aTable = data}
  if (isNil startC) {startC = startCol}
  if (isNil startR) {startR = startRow}
  if (isNil cellW) {cellW = cellWidth}
  if (isNil cellH) {cellH = cellHeight}
  data = aTable
  startCol = startC
  startRow = startR
  cellWidth = cellW
  cellHeight = cellH
  rowLabelWidth = (rowLabelWidth this)
  redraw this true
}

method rowLabelWidth TableView {
  pad = (10 * (global 'scale'))
  setFont 'Arial Bold' (* 12 (global 'scale'))
  return (+ pad (stringWidth (toString (rowCount data))))
}

method vSlider TableView {
  for each (parts morph) {
    hdl = (handler each)
    if (and (isClass hdl 'Slider') ('vertical' == (orientation hdl))) {
      return hdl
    }
  }
  return nil
}

method hSlider TableView {
  for each (parts morph) {
    hdl = (handler each)
    if (and (isClass hdl 'Slider') ('horizontal' == (orientation hdl))) {
      return hdl
    }
  }
  return nil
}

method cells TableView {
  cells = (list)
  for each (parts morph) {
    hdl = (handler each)
    if (isClass hdl 'TableCell') {
      add cells hdl
    }
  }
  return cells
}

method redraw TableView anyway {
  if (isNil anyway) {anyway = false}
  allCols = ((columnCount data) + 1)
  allRows = ((rowCount data) + 1)
  c = (min allCols (ceiling ((+ (width morph) padding (cellWidth - rowLabelWidth)) / (padding + cellWidth))))
  r = (min allRows (ceiling ((height morph) / (padding + cellHeight))))
  if (and (not anyway) (c == cols) (r == rows)) {
    updateSliders this
    return
  }
  cols = c
  rows = r
  startCol = (max 1 (min startCol (allCols - (cols - 2))))
  startRow = (max 1 (min startRow (allRows - (rows - 2))))
  buildMorphs this
}

method redrawData TableView {
  allCols = (columnCount data)
  allRows = (rowCount data)
  if (startCol >= allCols) { startCol = 1 }
  if (startRow >= allRows) { startRow = (max 1 (allRows - 50)) }

  if ((width morph) > (+ rowLabelWidth (allCols * cellWidth))) {startCol = 1}
  if ((height morph) > ((allRows + 1) * cellHeight)) {startRow = 1}
  pidx = 0
  for row rows {
    for col cols {
      pidx += 1
      dataRowIdx = ((startRow + row) - 2)
      dataColIdx = ((col + startCol) - 2)
      cell = (at (parts morph) pidx)
      if (row == 1) {
        if (pidx > 1) {
          if (dataColIdx > allCols) {
            blankOut (handler cell)
          } else {
            setData (handler cell) (at (columnNames data) dataColIdx)
          }
        }
      } (col == 1) {
        if (dataRowIdx > allRows) {
          blankOut (handler cell)
        } else {
          setData (handler cell) dataRowIdx
        }
      } else {
        if (dataColIdx > allCols) {
          blankOut (handler cell)
        } (dataRowIdx > allRows) {
          blankOut (handler cell)
        } else {
          setData (handler cell) (cellAt data dataRowIdx dataColIdx)
        }
      }
    }
  }
  costumeChanged morph
}

method show TableView newCol newRow {
  if (isNil newRow) {newRow = startRow}
  if (isNil newCol) {newCol = startCol}
  if (and (newRow == startRow) (newCol == startCol)) {return}
  startRow = newRow
  startCol = newCol
  redrawData this
}

method buildMorphs TableView {
  sliderTransparency = 180
  hSlider = (hSlider this)
  vSlider = (vSlider this)
  removeAllParts morph
  for row rows {
    for col cols {
      if (col == 1) {
        addPart morph (morph (initialize (new 'TableCell') (rowCount data) rowLabelWidth cellHeight true (row == 1)))
      } else {
        addPart morph (morph (initialize (new 'TableCell') nil cellWidth cellHeight (row == 1) false))
      }
    }
  }
  if (isNil hSlider) {
    hSlider = (slider 'horizontal')
    setAlpha (morph hSlider) sliderTransparency
    setAction hSlider  (action 'scrollToCol' this)
  }
  addPart morph (morph hSlider)
  if (isNil vSlider) {
    vSlider = (slider 'vertical')
    setAlpha (morph vSlider) sliderTransparency
    setAction vSlider  (action 'scrollToRow' this)
  }
  addPart morph (morph vSlider)
  fixLayout this
  redrawData this
}

method fixLayout TableView {
  pidx = 0
  l = (left morph)
  t = (top morph)
  y = padding
  for row rows {
    x = padding
    for col cols {
      pidx += 1
      cell = (at (parts morph) pidx)
      setPosition cell (l + x) (t + y)
      x += padding
      if (col == 1) {
        x += rowLabelWidth
      } else {
        x += cellWidth
      }
    }
    y += cellHeight
    y += padding
  }
  updateSliders this
}

method updateSliders TableView {
  hSlider = (hSlider this)
  vSlider = (vSlider this)

  if (notNil vSlider) {
    if ((height morph) > (((rowCount data) + 1) * cellHeight)) {
      hide (morph vSlider)
    } else {
      show (morph vSlider)
      setRight (morph vSlider) (right morph)
      setTop (morph vSlider) (top morph)
      setHeight (bounds (morph vSlider)) (- (height morph) (height (morph hSlider)))
      redraw vSlider
      ceil = ((rowCount data) - (rows - 3))
      size = (min rows ((ceil - 1) / 2))
      update vSlider 1 ceil startRow size
    }
  }
  if (notNil hSlider) {
    if ((width morph) > (+ rowLabelWidth ((columnCount data) * cellWidth))) {
      hide (morph hSlider)
    } else {
      show (morph hSlider)
      setLeft (morph hSlider) (left morph)
      setBottom (morph hSlider) (bottom morph)
      setWidth (bounds (morph hSlider)) (- (width morph) (width (morph vSlider)))
      redraw hSlider
      ceil = ((columnCount data) - (cols - 3))
      size = (min cols ((ceil - 1) / 2))
      update hSlider 1 ceil startCol size
    }
  }
}

method scrollToCol TableView newCol {
  show this newCol
}

method scrollToRow TableView newRow {
  show this nil newRow
}

method step TableView {
  if (or (isNil data) ((changeCount data) == lastChangeCount)) { return }
  redraw this true
  lastChangeCount = (changeCount data)
}

// events

method swipe TableView x y {
  show this (min ((columnCount data) - (cols - 3)) (max 1 (startCol - x))) (min ((rowCount data) - (rows - 3)) (max 1 (startRow - y)))
  updateSliders this
  return true
}


defineClass TableViewer morph window spreadSheet

method initialize TableViewer contents label cellWidth cellHeight windowWidth windowHeight {
  scale = (global 'scale')
  if (not (isClass contents 'Table')) {contents = (table)}
  if (isNil label) {label = 'Table'}
  if (isNil windowWidth) {windowWidth = (scale * 300)}
  if (isNil windowHeight) {windowHeight = (scale * 200)}
  window = (window label)
  morph = (morph window)
  setHandler morph this
  setMinExtent morph  (scale * 50)
  spreadSheet = (initialize (new 'TableView') contents 1 1 cellWidth cellHeight)
  addPart morph (morph spreadSheet)
  setExtent morph windowWidth windowHeight
}

method fixLayout TableViewer {
  fixLayout window
  clientArea = (clientArea window)
  setPosition (morph spreadSheet) (left clientArea) (top clientArea)
  setExtent (morph spreadSheet) (width clientArea) (height clientArea)
}

method redraw TableViewer {
  redraw window
  fixLayout this
}

method setData TableViewer aTable label startColumn startRow cellWidth cellHeight {
  if (notNil label) {setLabelString window label}
  setData spreadSheet aTable startColumn startRow cellWidth cellHeight
}

to viewTable aTable label cellWidth cellHeight windowWidth windowHeight {
  page = (global 'page')
  tw = (new 'TableViewer')
  initialize tw aTable label cellWidth cellHeight windowWidth windowHeight
//  setPosition (morph tw) (x (hand page)) (y (hand page))
  setPosition (morph tw) 900 50
  addPart page tw
  return tw
}

to testTable {
  persons = (table 'First Name' 'Last Name' 'City' 'Project' 'Other')
  addAll persons (list 'Jens' 'MÃ¶nig' 'GÃ¤ufelden' 'GP' 'Snap')
  addAll persons (list 'John' 'Maloney' 'Cambridge' 'GP' 'Scratch')
  addAll persons (list 'Yoshiki' 'Ohshima' 'Los Angeles' 'GP' 'Squeak')
  addAll persons (list 'Evelyn' 'Eastmond' 'Cambridge' 'Art' 'Scratch')
  addAll persons (list 'Eric' 'Rosenbaum' 'New York' 'Beetleblocks' 'Scratch')
  addAll persons (list 'Bernat' 'Romagosa' 'Barcelona' 'Beetleblocks' 'Snap4Arduino')
  addAll persons (list 'Duks' 'Koschitz' 'New York' 'Beetleblocks' 'Design')
  addAll persons (list 'Brian' 'Harvey' 'Berkeley' 'Snap' 'Logo')
  addAll persons (list 'Paul' 'Goldenberg' 'Newton' 'BJC' 'Logo')
  addAll persons (list 'Michael' 'Ball' 'Berkeley' 'Snap' 'BJC')
  addAll persons (list 'Dan' 'Garcia' 'Berkeley' 'BJC' 'AP CSP')
  return persons
}

to manyRows {
  tab = (table 'class' 'index' 'field' 'function' 'scripts')
  repeat 2500 {
    for cls (classes) {
      if (isNil (scripts cls)) {
        scr = 0
      } else {
        scr = (count (scripts cls))
      }
      add tab (className cls) (classIndex cls) '' '' scr
      for fld (fieldNames cls) {
        add tab (className cls) (classIndex cls) fld '' scr
      }
      for mth (methods cls) {
        add tab (className cls) (classIndex cls) '' (functionName mth) scr
      }
    }
    for fn (functions) {
      add tab '<generic>' '' '' (functionName fn) 0
    }
  }
  return tab
}
// Tasks and Scheduler

defineClass Task stack sp fp mp currentBlock nextBlock result tickLimit taskToResume waitReason wakeMSecs profileArray profileIndex errorReason topBlock doneAction receiver

classComment Task '
A task ("thread" or "process") represents the suspended execution state of a
GP program in a form that can be examined, manipulated, or resumed. If a set
of tasks takes turns running, then it appears that are all running at once,
even though only one of them is running at any given moment. A TaskMaster
object manages such a set of "concurrent" tasks. Another use of tasks is
debugging: the debugger allows you to examine, step, or resume a task
that encounters an error or halt.

Sometime a task must to wait for something to happen. A task can wait
for either the next display update (useful for animation) or for time
to elapse. Tasks that need to wait for other conditions, for example for
some data to be returned by a hardware device or server, can do so by
repeatedly testing for the desired condition, then waiting for a short
time before testing again. This is sometimes called "polling". Polling
in a loop without a wait would waste processor cycles, but since the
condition test is quick, waiting just a few milliseconds between tests
allows other tasks to run and wastes very few processor cycles.

Key primitives for working with tasks include:

  yield - yield control, allowing other tasks to run
  resume task - resume the given task
  currentTask - return the currently running task
  debugeeTask - the task that most recently encountered an error or halt
'

method stack Task { return stack }
method waitReason Task { return waitReason }
method setWaitReason Task reason { waitReason = reason }
method errorReason Task { return errorReason }

method wakeMSecs Task { return wakeMSecs }
method doneAction Task { return doneAction }
method result Task { return result }
method topBlock Task { return topBlock }
method setTopBlock Task cmd { topBlock = cmd }
method receiver Task { return receiver }

to newTask cmdList targetObj doneAction {
  // Return a new task to run the given command list. The optional doneAction will
  // be called when this task completes, passing the value the task returned, if any.

  topBlock = cmdList

  if (isClass cmdList 'Reporter') {
    cmdList = (newCommand 'return' cmdList)
  }
  if (not (isClass cmdList 'Command')) { // cmdList is function or action
    cmdList = (newCommand 'call' cmdList)
  }

  if (notNil targetObj) {
	func = (functionFor targetObj cmdList)
    cmdList = (newReporter 'call' func targetObj)
  }

  task = (new 'Task')
  stack = (newArray 200)
  atPut stack 1 nil // push nil
  atPut stack 2 100 // push "STOP"
  setField task 'stack' stack
  setField task 'sp' 3
  setField task 'fp' 3
  setField task 'mp' 0
  setField task 'currentBlock' true // must be non-nil
  setField task 'nextBlock' cmdList
  setField task 'topBlock' topBlock
  setField task 'doneAction' doneAction
  setField task 'receiver' targetObj
  return task
}

method runTask Task {
  // For testing. Tasks are usually run only by the task manager.
  taskToResume = (currentTask)
  tickLimit = 1000000
  resume this
  return result
}

method terminate Task { waitReason = 'terminated' }

method isTerminated Task {
  return (or (isNil currentBlock) ('terminated' == waitReason) ('error' == waitReason))
}

method isRunning Task aBlock rcvr {
  if (or (isNil rcvr) (receiver == rcvr)) {
	if (topBlock == aBlock) { return true }
  }
  return false
}

method caller Task {
  // Return the function that called the current function (or nil).

  lastMP = mp
  if (lastMP > 1) {
	lastMP = (at stack (lastMP + 2))
	return (at stack (lastMP + 1))
  }
  return nil
}

method openDebugger Task {
  page = (global 'page')
  if (isNil page) { return }
  stopAll page
  gc
  stats = (memStats)
  freeMBytes = (((at stats 2) - (at stats 1)) / 1000000) // megabytes
  if (freeMBytes < 15) {
	stack = nil // free my stack
	gc
	inform page (join 'Error: Low memory')
	return
  }
  if ('step' == (lastMethodOrFunction this)) {
	// if an error occurs in the step method for a handler, disable stepping of its morph
	h = (lastReceiver this)
	if (hasField h 'morph') {
	  disableStepping (getField h 'morph')
	}
  }
  result = (safelyRun (action 'addPart' page (new 'Debugger' this)) (action 'id' 'failed'))
  if ('failed' == result) {
	stack = nil // free my stack
	gc
	inform page (join 'Error: ' errorReason)
  }
}

method lastMethodOrFunction Task  {
  // Return the name of the current method or function, or nil if there are no calls on stack.

  if (mp <= 1) { return nil }
  return (functionName (at stack (mp + 1)))
}

method lastReceiver Task {
  // Return the first argument of the most recent call or nil.

  if (mp <= 1) { return nil }
  func = (at stack (mp + 1))
  thisCallFP = (at stack (mp - 1))
  argCount = (((mp - thisCallFP) - 1) - (count (localNames func)))
  if (argCount < 1) { return nil }
  return (at stack thisCallFP)
}

method hasDebugger Task {
  // Return true if this task contains a call with Debugger as the receiver.
  // Used to detect recursive attempts to open a debugger.

  if (isNil stack) { return false }
  thisMP = mp
  while (thisMP > 1) {
    func = (at stack (thisMP + 1))
	if (and (notNil func) (isMethod func)) {
	  fp = (at stack (thisMP - 1))
	  rcvr = (at stack fp)
	  if (isClass rcvr 'Debugger') { return true }
	}
    thisMP = (at stack (thisMP + 2))
  }
  return false
}

to stopTask {
  // Stop the caller's task.
  setField (currentTask) 'waitReason' 'terminated'
  yield // will stop execution, even if not in scheduler
}

method checkTimer Task {
  // Stop waiting if my time has come.
  if (waitReason != 'timer') { return }
  if ((msecsSinceStart) >= wakeMSecs) {
    waitReason = nil // stop waiting
  }
}

to waitSecs secs {
  if (isNil secs) { secs = 0 }
  waitMSecs (1000 * secs)
}

to waitMSecs msecs {
  // Wait for the given number of milliseconds.

  msecs = (truncate msecs)
  if (msecs <= 0) {
	waitForNextFrame
	return
  }

  task = (currentTask)
  if (isNil (getField task 'tickLimit')) { // not in scheduler
    sleep msecs
	return
  }

  now = (msecsSinceStart)
  wakeTime = (now + msecs)
  if (wakeTime < 0) { // clock wrap
    wakeTime = (msecs - ((maxInt) - now))
  }
  setField task 'waitReason' 'timer'
  setField task 'wakeMSecs' wakeTime
  yield
}

to waitForNextFrame {
  // Wait for the next display frame. (Useful for animation.)

  if (isNil (getField (currentTask) 'tickLimit')) {
	return // not in scheduler
  }
  setWaitReason (currentTask) 'display'
  yield
}

defineClass TaskMaster taskList emergencyMemory

to newTaskMaster { return (new 'TaskMaster' (list)) }

method isRunning TaskMaster aBlock rcvr {
  for task taskList {
	if (isRunning task aBlock rcvr) { return true }
  }
  return false
}

method numberOfTasksRunning TaskMaster aBlock rcvr {
  count = 0
  for task taskList {
    if (isRunning task aBlock rcvr) { count += 1 }
  }
  return count
}

method stopRunning TaskMaster aBlock rcvr {
  for task taskList {
	if (isRunning task aBlock rcvr) {
	  setWaitReason task 'terminated'
	}
  }
}

method stopTasksFor TaskMaster rcvr {
  // Stop all tasks for the given receiver.
  if (isNil rcvr) { return }
  for task (copy taskList) {
	if (rcvr == (receiver task)) {
	  setWaitReason task 'terminated'
	}
  }
}

method addTask TaskMaster task { addFirst taskList task }

method wakeUpDisplayTasks TaskMaster {
  // Called once per display cycle loop to wake all tasks waiting on next display frame.

  for task taskList {
    if ('display' == (waitReason task)) { setWaitReason task nil }
  }
}

method stepTasks TaskMaster msecsToStep {
  timer = (newTimer)
  while ((msecs timer) < msecsToStep) {
	ranTask = (stepTasksOnce this timer)
	if (not ranTask) { return }
  }
}

method stepTasksOnce TaskMaster timer {
  // Step all tasks that are not waiting or terminated and remove
  // any terminated tasks from tht task list.
  // Note: Since running a task can spawn new tasks, this method
  // make a copy of the current task list. Any newly launched
  // tasks will get handled by the next call.

  if (isNil emergencyMemory) { emergencyMemory = (newBinaryData 10000) }
  taskListCopy = taskList
  taskList = (list)
  ranTask = false
  for task taskListCopy {
	if ((msecs timer) > 1000) { return ranTask } // emergency stop
    if ('timer' == (waitReason task)) { checkTimer task }
    if (isNil (waitReason task)) { // found runnable task
	  ranTask = true
	  setField task 'taskToResume' (currentTask)
	  setField task 'tickLimit' 1000
	  resume task
 	}
	if (isTerminated task) {
	  if ('error' == (waitReason task)) {
	  emergencyMemory = nil
		openDebugger task
		return true
	  } (notNil (doneAction task)) {
        call (doneAction task) (result task)
	    setField task 'currentBlock' nil
	  }
	} else {
      add taskList task // still active
    }
  }
  return ranTask
}

method stepAllTasksUntilDone TaskMaster {
  // Useful for testing. Step tasks until all tasks have terminated.
  while ((count taskList) > 0) {
    stepTasksOnce this (newTimer)
  }
}

to safelyRun funcOrAction errorFuncOrAction {
  task = (newTask (newReporter 'call' funcOrAction))
  setField task 'tickLimit' 1000000
  setField task 'taskToResume' (currentTask)
  while true {
	resume task
	if ('error' == (waitReason task)) {
	  gcIfNeeded
	  if (notNil errorFuncOrAction) {
		return (call errorFuncOrAction task)
	  }
	  return task
	} (isTerminated task) {
	  return (result task)
	} ('timer' == (waitReason task)) {
	  msecsToWait = ((wakeMSecs task) - (msecsSinceStart))
	  if (msecsToWait > 0) { waitMSecs msecsToWait }
	  setField task 'waitReason' nil
	}
  }
}
// useful global functions

// print and inspect

to print args... {
  result = (list)
  for i (argCount) {
    add result (toString (arg i))
    if (i != (argCount)) {add result ' '}
  }
  log (joinStringArray (toArray result))
}

to inspect obj {
  class = (classOf obj)
  className = (getField class 'className')
  if (or (isNil obj) (true === obj) (false === obj)
		 (isClass obj 'Integer') (isClass obj 'Float')
		 (isClass obj 'String') (isClass obj 'ExternalReference')) {
	print className (printString obj)
  } (isClass obj 'BinaryData') {
    print className (join '(' (byteCount obj) ' bytes)')
	printBytes obj
  } else {
    n = (min 100 (objWords obj))
	fieldNames = (getField class 'fieldNames')
    print className '{'
	for i n {
	  if (i <= (count fieldNames)) {
	    slotName = (join '  ' (at fieldNames i) ':')
	  } else {
	    slotName = (join '  ' i ':')
	  }
	  print slotName (printString (getField obj i))
	}
	extra = ((objWords obj) - n)
	if (extra > 0) {
	  print '  ...' extra 'more ...'
	}
	print '}'
  }
}

to printBytes binaryData {
  byteCount = (byteCount binaryData)
  i = 1
  repeat 10 {
    line = (list)
    for col 20 {
      if (i > byteCount) {
	    print (joinStringArray (toArray line))
        return
	  }
      add line (toString (byteAt binaryData i))
	  add line ' '
	  if ((col % 5) == 0) { add line '  ' }
	  i += 1
	}
	print (joinStringArray (toArray line))
  }
  print '...' (byteCount - (i - 1)) 'more bytes ...'
}

to printString obj {
  return (toString obj)
}

// time and date

to dateString {
  now = (localDateAndTime)
  amPm = 'am'
  hours = (at now 4)
  if (hours >= 12) { amPm = 'pm' }
  if (hours > 12) { hours += -12 }
  min = (toString (at now 5))
  if ((count min) < 2) { min = (join '0' min) }
  secs = (toString (at now 6))
  if ((count secs) < 2) { secs = (join '0' secs) }
  return (join '' (at now 1) '-' (at now 2) '-' (at now 3) ' ' hours ':' min ':' secs amPm)
}

to localDateAndTime {
  // Return an array with the local date and time.

  time = (time)
  localOffset = (at time 3)
  if (at time 4) { localOffset += -3600 } // adjust for daylight savings time
  return (secondsToDateAndTime ((at time 1) - localOffset))
}

to secondsToDateAndTime secs {
  // Convert the given second count (seconds since midnight Jan 1, 2000)
  // to an array of integers: year month day hour minute second

  secsPerDay = (* 24 60 60)
  year = 2000 // start of gp epoch
  while (secs >= (secondsInYear year)) {
    secs = (secs - (secondsInYear year))
    year += 1
  }
  isLeap = (and ((year % 4) == 0) (or ((year % 100) != 0) ((year % 400) == 0)))
  daysPerMonth = (array 31 28 31 30 31 30 31 31 30 31 30 31)
  if isLeap { atPut daysPerMonth 2 29 }
  day = (ceiling ((toFloat secs) / secsPerDay))
  month = 1
  while (day > (at daysPerMonth month)) {
    day = (day - (at daysPerMonth month))
    month += 1
  }
  minutesSinceMidnight = (truncate ((secs % secsPerDay) / 60))
  hour = (truncate (minutesSinceMidnight / 60))
  minute = (minutesSinceMidnight % 60)
  second = (secs % 60)
  return (array year month day hour minute second)
}

to secondsInYear year {
  isLeap = (and ((year % 4) == 0) (or ((year % 100) != 0) ((year % 400) == 0)))
  if isLeap {
    return (* 366 24 60 60)
  }
  return (* 365 24 60 60)
}

to timeSince startSecs {
  // Return a string like '3 hours, 42 seconds' or '2 years, three months'
  // that represents the elapsed time since the given starting time.

  secsPerHour = (60 * 60)
  secsPerDay = (24 * secsPerHour)
  secs = (truncate ((first (time)) - startSecs)) // seconds
  if (secs < 0) { secs = 0 }
  if (secs < 60) { return (join '' secs ' seconds') }
  if (secs < 3600) { return (join '' (truncate (secs / 60)) ' minutes ' (secs % 60) ' seconds') }
  if (secs < secsPerDay) {
	return (join 'about ' (truncate (secs / secsPerHour)) ' hours ' (truncate ((secs % secsPerHour) / 60)) ' minutes') }

  days = (truncate (secs / secsPerDay))
  if (days < 31) {
	hours = (truncate ((secs - (days * secsPerDay)) / secsPerHour))
	return (join 'about ' days ' days ' hours ' hours') }

  // approximate months as 31 days for under a year
  if (days <= 365) {
	months = (truncate (days / 31))
	return (join 'about ' months ' months ' (days - (months * 31)) ' days') }

  // approximate months/days using average year and month lengths
  secsPerYear = (truncate (365.25 * secsPerDay))
  secsPerMonth = (truncate (secsPerYear / 12))
  years = (truncate (secs / secsPerYear))
  months = (truncate ((secs - (years * secsPerYear)) / secsPerMonth))
  if (months == 0) { return (join 'about ' years ' years') }
  return (join 'about ' years ' years ' months ' months')
}

to timestamp {
  // Return the current time in RFC3339 Internet Timestamp format.

  rawTime = (time)
  now = (secondsToDateAndTime (at rawTime 1))

  year = (at now 1)
  month = (leftPadded (toString (at now 2)) 2 '0')
  day = (leftPadded (toString (at now 3)) 2 '0')
  hour = (leftPadded (toString (at now 4)) 2 '0')
  min = (leftPadded (toString (at now 5)) 2 '0')
  sec = (leftPadded (toString (at now 6)) 2 '0')
  usec = (leftPadded (toString (at rawTime 2)) 6 '0')
  return (join '' year '-' month '-' day 'T' hour ':' min ':' sec '.' usec 'Z' )
}

// memory

to mem {
  // Return a string describing current memory useage.
  stats = (memStats)
  used = (truncate ((at stats 1) / 1000))
  total = (truncate ((at stats 2) / 1000))
  percent = (toString ((100.0 * used) / total) 3)
  free = (truncate (((at stats 2) - (at stats 1)) / 1000))
  return (join 'used ' used 'k (' percent '%' ' of ' total 'k); ' free 'k free')
}

to gcIfNeeded {
  // Garbage collect periodically.
  // Current policy: GC when under 10 mbyte free or every 50 mbytes of allocations

return // xxx garbage collection should now be automatic; remove calls to gcIfNeeded after more testing

  stats = (memStats)
  mbytesFree = (((at stats 2) - (at stats 1)) / 1000000)
  mbytesAllocated = ((at stats 4) / 1000000)

  if (or (mbytesFree < 10) (mbytesAllocated > 50) ) {
	t = (newTimer)
	kbytesReclaimed = (truncate ((gc) / 1000))
	kbytesFree = (((at stats 2) - (at stats 1)) / 1000)
//	print 'reclaimed' kbytesReclaimed 'kbytes in' (msecs t) 'msecs;' kbytesFree 'kbytes available'
	stats = (memStats)
	mbytesFree = (((at stats 2) - (at stats 1)) / 1000000)
	if (mbytesFree < 2) { error 'GC could not reclaim enough space' }
  }
}

// object stats

to objectStats onlyCountGarbage {
  // Return statistics about the number of instances and words used by objects
  // by class. If onlyCountGarbage is true, then count only garbage objects.

  countAll = true
  if onlyCountGarbage {
    findGarbage
    countAll = false
  }
  stats = (table 'class' 'instances' 'words')
  add stats 'totals' 0 0
  totalsRow = (row stats 1)
  end = (array 'end') // marker for last object
  obj = (objectAfter nil)
  while (not (obj === end)) {
    if (or countAll (isGarbage obj)) {
	  instWords = (objWords obj)
	  className = (className (classOf obj))
	  i = (find stats 'class' className)
	  if (i == 0) {
	    add stats className 1 instWords
	  } else {
	    row = (row stats i)
		atPut row 2 ((at row 2) + 1)
		atPut row 3 ((at row 3) + instWords)
	  }
	  atPut totalsRow 2 ((at totalsRow 2) + 1)
	  atPut totalsRow 3 ((at totalsRow 3) + instWords)
	}
	obj = (objectAfter obj)
  }
  return (sorted stats 'words' '>')
}

to allInstances classOrClassName {
  // Return all instances of the given class.
  // If className is omitted, return all objects.
  if (isClass classOrClassName 'String') {
	cl = (class classOrClassName) // top-level module
	if (isNil cl) {
	  classesWithName = (classesWithName classOrClassName)
	  if ((count classesWithName) > 0) {
		cl = (first classesWithName)
	  }
	}
	if (isNil cl) { error (join 'No class named ' classOrClassName) }
	classID = (classIndex cl)
  } (isClass classOrClassName 'Class') {
	classID = (classIndex classOrClassName)
  } else {
	classID = classOrClassName
  }
  result = (list)
  obj = (objectAfter nil classID)
  while (notNil obj) {
    add result obj
    obj = (objectAfter obj classID)
  }
  return result
}

to classesWithName name {
  // Return a list of classes with the given name, independent of which module they are in.
  result = (list)
  for cl (classes) {
	if ((className cl) == name) { add result cl }
  }
  return result
}

// useful object queries

to hasField obj fieldName {
  fields = (getField (classOf obj) 'fieldNames')
  for fn fields {
    if (fn == fieldName) { return true }
  }
  return false
}

to getFieldOrNil obj fieldName {
  if (hasField obj fieldName) {
	return (getField obj fieldName)
  } else {
    return nil
  }
}

to implements obj opName {
  // Return true if the class of the given object implements the given method.
  methods = (getField (classOf obj) 'methods')
  for m methods {
    if (opName == (getField m 'functionName')) { return true }
  }
  return false
}

to findPathFromTo startObj finalObj {
  // Return an array of field names/field indexs that defines a chain of references from
  // startObj to finalObj, or nil if no path is found.

  if (not (containsReferences startObj)) { return nil }
  visited = (dictionary)
  todo = (list (array startObj (array)))
  while (notEmpty todo) {
	pair = (removeFirst todo)
	obj = (first pair)
	path = (last pair)
	if (isClass obj 'Array') {
	  for i (count obj) {
		nextObj = (at obj i)
		if (nextObj === finalObj) { return (copyWith path i) }
		if (and (containsReferences nextObj) (not (contains visited nextObj))) {
		  add visited nextObj
		  add todo (array nextObj (copyWith path i))
		}
	  }
	} else {
	  for f (fieldNames (classOf obj)) {
		nextObj = (getField obj f)
		if (nextObj === finalObj) { return (copyWith path f) }
		if (and (containsReferences nextObj) (not (contains visited nextObj))) {
		  add visited nextObj
		  add todo (array nextObj (copyWith path f))
		}
	  }
	}
  }
  return nil
}

to rootPathsTo anObject {
  // Return an list of paths from the root modules to the given object.
  // A path is an array of field names/field indexs that defines a chain
  // of references from a root (e.g. (sessionModule) to the given object.

  seen = (dictionary)
  result = (list)
  todo = (list (array anObject (array)))
  while (notEmpty todo) {
	pair = (removeFirst todo)
	obj = (first pair)
	path = (last pair)
	gc
	for ref (objectReferences obj) {
	  if (or (ref === pair) (ref === (stack (currentTask)))) {
		// ignore
	  } (or (ref === (sessionModule)) (ref === (topLevelModule))) {
		path = (reversed (join path (array (fieldNameOrIndexFor ref obj) ref)))
		add result path
		add seen path
	  } (not (contains seen ref)) {
		path = (copyWith path (fieldNameOrIndexFor ref obj))
		add seen path
		add seen ref
		add todo (array ref path)
	  } else {
		// already seen
	  }
	}
  }
  return result
}

to fieldNameOrIndexFor srcObj referencedObj {
  fieldNames = (fieldNames (classOf srcObj))
  for i (objWords srcObj) {
	if ((getField srcObj i) === referencedObj) {
	  if (i <= (count fieldNames)) { return (at fieldNames i) }
	  return i
	}
  }
  error 'No reference found'
}

to containsReferences obj {
  if (and (isClass obj 'Array') ((count obj) > 0)) { return true }
  return ((count (fieldNames (classOf obj))) > 0)
}

// tests

to isNumber obj {
  if (isClass obj 'Integer') { return true }
  if (isClass obj 'Float') { return true }
  if (isClass obj 'LargeInteger') { return true }
  return false
}

to isAnyClass obj classNames... {
  // Return true if obj is an instance of one of the given classes.

  for i ((argCount) - 1) {
    if (isClass obj (arg (i + 1))) { return true }
  }
  return false
}

to isOneOf obj items... {
  // Return true if obj is equal to any of the remaining arguments.

  for i ((argCount) - 1) {
    if (obj == (arg (i + 1))) { return true }
  }
  return false
}

// runtime folder

to runtimeFolder subfolder {
  path = 'runtime/'
  if ('iOS' == (platform)) { path = '/runtime/' } // use internal file system
  if (notNil subfolder) { path = (join path subfolder) }
  return path
}

// file loading

to reload fileName {
  // Reload a top level module file. The 'lib/' prefix and '.gp'
  // suffix can be omitted. Example: "reload 'List'"

  if (not (contains (letters fileName) '/')) { fileName = (join (runtimeFolder 'lib/') fileName) }
  if (not (endsWith fileName '.gp')) { fileName = (join fileName '.gp') }
  return (load fileName (topLevelModule))
}

to load fileName module {
  str = (readFile fileName)
  if (isNil str) { error 'Could not read file' fileName }
  return (eval str nil module)
}

// unique names (for files and other things)

to uniqueNameNotIn nameList baseName ext {
  if (isNil ext) { ext = '' }
  if (and (ext != '') (not (beginsWith ext '.'))) { ext = (join '.' ext) }
  i = 2
  result = (join baseName ext)
  while true {
	if (not (contains nameList result)) { return result }
	result = (join baseName i ext)
	i += 1
  }
}

// simple file chooser

to chooseFile fileAction dir extensions x y {
  // Use a sequence popup menus to select a file.
  // Extensions may be either nil (all files), a string, or a list of strings.
  page = (global 'page')
  if (isNil dir) { dir = '.' }
  if (isNil extensions) { extensions = '' }
  if (isNil x) { x = (x (hand page)) }
  if (isNil y) { y = (y (hand page)) }
  dir = (absolutePath dir)
  menu = (menu dir)
  addItem menu 'Parent Folder' (action 'chooseFile' fileAction (parentDir dir) extensions x y)
  addLine menu
  prefix = dir
  if ('/' != prefix) { prefix = (join prefix '/') }
  for subdir (sorted (listDirectories dir)) {
	addItem menu (join 'â¢ ' subdir) (action 'chooseFile' fileAction (join prefix subdir) extensions x y)
  }
  addLine menu
  for fn (sorted (listFiles dir)) {
	if (and (fn != '.DS_Store') (hasExtension fn extensions)) {
	  addItem menu fn (action fileAction (join prefix fn))
	}
  }
  addLine menu

  conf = (gpServerConfiguration)
  if (notNil conf) {
    user = (at conf 'username')
    serverDirectory = (at conf 'serverDirectory')
    account = (at conf 'account')
    accountPassword = (at conf 'accountPassword')
  }
  if (and (notNil user) (notNil serverDirectory)) {
    addItem menu 'Server...' (action 'chooseServerFile' fileAction page (join serverDirectory user '/') extensions account accountPassword x y)
  }
  addLine menu
  addItem menu 'cancel' 'ignore'
  popUp menu page x y
}

to gpServerConfiguration {
  // Return a dictionary with the GP server settings or nil if there is no server configuration file

  file = (readFile 'server.conf')
  if (isNil file) { return nil }
  return (jsonParse file)
}

to chooseServerFile fileAction page dir extensions account accountPassword x y {
  menu = (menu dir)
  m = (loadModule 'modules/DAVDirectory.gpm')
  u = (url (initialize (new (at m 'URIParser')) dir))
  c = (new (at m 'DAVClient'))
  setUser c account
  setPassword c accountPassword
  list = (listFiles c u)

  if (notNil list) {
    for fn (toArray list) {
      if (hasExtension fn extensions) {
        addItem menu fn (action fileAction (join dir '/' fn))
      }
    }
  }
  addLine menu
  addItem menu 'cancel' 'ignore'
  popUp menu page x y
}

to hasExtension filename extensions {
	if (isClass extensions 'String') { extensions = (list extensions) }
	for ext extensions {
		if (endsWith filename ext) { return true }
	}
	return false
}

// detecting media file types

to isJPEG data {
	byteCount = (byteCount data)
	if (byteCount < 4) { return false }
	return (and
		(255 == (byteAt data 1))
		(216 == (byteAt data 2))
		(255 == (byteAt data (byteCount - 1)))
		(217 == (byteAt data byteCount)))
}

to isPNG data {
	if ((byteCount data) < 4) { return false }
	return (and
		(137 == (byteAt data 1))
		(80 == (byteAt data 2))
		(78 == (byteAt data 3))
		(71 == (byteAt data 4)))
}

// directory searches

to allFiles rootDir suffix result {
  if (isNil rootDir) { rootDir = '.' }
  if (isNil result) { result = (list) }
  for fileName (listFiles rootDir) {
	if (or (isNil suffix) (endsWith fileName suffix)) {
	  add result (join rootDir '/' fileName)
	}
  }
  for dirName (listDirectories rootDir) {
	allFiles (join rootDir '/' dirName) suffix result
  }
  return result
}

to findProjectsWithString s rootDir {
  for fileName (allFiles rootDir '.gpp') {
	if (projectScriptsIncludesString fileName s) {
	  print fileName
	}
  }
}

to projectScriptsIncludesString projectFileName s {
  proj = (read (new 'ZipFile') (readFile projectFileName true))
  scripts = (toString (extractFile proj 'scripts.txt'))
  return ((find (letters scripts) s) > 0)
}

// benchmarks

to primeSieve flags {
  primeCount = 0
  fillArray flags true
  i = 2
  repeat 8188 {
    if (at flags i) {
      primeCount += 1 // found a prime
      j = (2 * i)
      while (j < 8190) { // mark multiples of i as non-prime
		atPut flags j false
		j += i
      }
    }
    i += 1
  }
  return primeCount
}

to benchFib n {
  if (n < 2) { return 1 }
  return (+ (benchFib (n - 1)) (benchFib (n - 2)) 1)
}

to tinyBenchmarks {
  result = (list)
  flags = (newArray 8190)
  n = 1
  msecs = 0
  while (msecs < 500) {
	timer = (newTimer)
	repeat n { primeSieve flags }
	msecs = (msecs timer)
	n = (2 * n)
  }
  add result (join '' n ' prime sieves in ' msecs ' msecs -- about ' (round ((1000.0 * n) / msecs)) ' sieves/sec')
  add result (join '  (equivalent to ' (round ((n * 500) / msecs) 0.1) ' million Squeak bytcodes per second)')

  n = 20
  msecs = 0
  while (msecs < 500) {
	timer = (newTimer)
	calls = (benchFib n)
	msecs = (msecs timer)
	n += 1
  }
  add result (join '' calls ' calls in ' msecs ' msecs -- ' (round (calls / (1000 * msecs)) 0.2) ' million calls/sec')
  return (joinStrings result (newline))
}

// no-ops

to nop { noop }
to ignore args... { noop }
to id obj { return obj }
to libraryVersion { return 'v084' }
// webBrowserRuntime.gp -- runtime support when GP is running in a web browser
// John Maloney, December 2016

// *** Project Fetching at Startup ***

to fetchProject {
  // Called from browser startup.gp to fetch a project encoded in the URL, if any.
  // Project URL for testing: http://gpblocks.org/projects/1-Intro/Effects.gpp

  setGlobal 'initialProject' nil
  projURL = (extractProjectArg (browserURL))
  if (isNil projURL) { return }
  print 'fetching' projURL
  request = (startFetch projURL)
  if (isNil request) { return }
  while true {
	result = (fetchResult request)
	if (isNil result) {
	  waitMSecs 20
	} else {
	  if (isClass result 'BinaryData') {
		print 'got project' projURL (byteCount result) 'bytes'
		setGlobal 'initialProject' (list result projURL)
	  } else { print 'failed' }
	  return
	}
  }
}

to extractProjectArg url {
  i = (indexOf (letters url) '#')
  if (isNil i) { i = (indexOf (letters url) '?') }
  if (isNil i) { return nil }
  result = (substring url (i + 1))
  if (not (or (beginsWith result 'http://') (beginsWith result 'http://'))) {
	if (beginsWith url 'https:') {
	  prefix = 'https:'
	} else {
	  prefix = 'http:'
	}
	result = (join prefix '//' result)
  }
  return result
}

to extractCommand url {
  end = (indexOf (letters url) '#')
  if (isNil end) { end = ((count url) + 1) }
  start = (lastIndexOf (letters url) '/' end)
  if (isNil start) { start = 1 }
  return (substring url (start + 1) (end - 1))
}

// usage logging

to logSessionStart sessionID projName {
  logEntry = (join
	'/usage/log.php?id=' sessionID
	'&type=S&secs=' 0)
  if ('' != projName) {
	if (beginsWith projName 'http://') { projName = (substring projName 8) }
	if (beginsWith projName 'https://') { projName = (substring projName 9) }
	logEntry = (join logEntry '&proj=' projName) }
  startFetch (join (httpPrefx) logEntry)
}

to logSessionActivity sessionID sessionSecs editCount {
  logEntry = (join
	'/usage/log.php?id=' sessionID
	'&type=A&secs=' sessionSecs
	'&edits=' editCount)
  startFetch (join (httpPrefx) logEntry)
}

to httpPrefx {
  if (and (notNil (browserURL)) (beginsWith (browserURL) 'https:')) {
	return 'https://gpblocks.org'
  } else {
	return 'http://gpblocks.org'
  }
}

// fetch primitive tests

to clearRequests {
  setGlobal 'requests' (list)
}

to fetch1 {
  if (isNil (global 'requests')) { setGlobal 'requests' (list) }
  requests = (global 'requests')
  projects = (list 'AnimatedTree.gpp' 'Engine.gpp' 'FerrisWheel.gpp' 'Jabberwocky.gpp' 'SpiroGraph.gpp' )
  for p projects {
    r = (startFetch (join 'http://gpblocks.org/projects/2-Animation/' p))
    if (isNil r) {
	  print 'could not start request for:' p
	} else {
	  add requests r
	}
  }
}

to fetch2 {
  for r (global 'requests') {
    result = (fetchResult r)
    if (isClass result 'BinaryData') {
		print r 'got' (byteCount result) 'bytes'
	} (false == result) {
		print r 'failed'
	} (isNil result) {
		print r 'still in progress'
	} else {
		print r 'unexpected' result
	}
  }
}
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Copyright 2019 John Maloney, Bernat Romagosa, and Jens MÃ¶nig

// MicroBlocksPatches.gp - This file patches/replaces methods in GP's normal class library
// with versions that support MicroBlocks (possibly making them no longer work correctly in
// the normal GP IDE.
//
// This file must be processed *after* the normal GP library has been read with a command like:
//
//	./gp runtime/lib/* microBlocks/GP-IDE/* -
//
// John Maloney, January, 2018

method allVarsMenu InputSlot {
  menu = (menu)

  // shared vars
  scripter = (ownerThatIsA morph 'MicroBlocksScripter')
  pe = (findProjectEditor)
  if (notNil scripter) {
	varNames = (allVariableNames (project (handler scripter)))
	for varName varNames {
          // hide vars that start with underscore, used for libraries
          if (or ((at varName 1) != '_') (showHiddenBlocksEnabled pe)) {
            addItemNonlocalized menu varName (action 'setContents' this varName)
          }
	}
	if ((count varNames) > 0) { addLine menu }
  }

  // local vars
  myBlock = (handler (ownerThatIsA morph 'Block'))
  localVars = (collectLocals (expression (topBlock myBlock)))

  // if inside function, add the function arg names
  topExpr = (expression (topBlock myBlock))
  if (and ('to' == (primName topExpr)) (notNil scripter)) {
    fName = (first (argList topExpr))
    func = (functionNamed (project (handler scripter)) fName)
    if (notNil func) {
      for argName (argNames func) {
        if (not (contains localVars argName)) { add localVars argName }
      }
    }
  }

  remove localVars ''
  for v varNames { remove localVars v }
  if (notEmpty localVars) {
	localVars = (sorted (keys localVars))
	for varName localVars {
	  addItemNonlocalized menu varName (action 'setContents' this varName)
	}
	addLine menu
  }

  addItem menu (localized 'Add a variable') (action 'createVariable' (handler scripter) this)
  scripter = (scripter (findProjectEditor))
  return menu
}

// Input slot menu options

method clicked InputSlot aHand {
  if (notNil menuSelector) {
    if (or ((x aHand) >= ((right morph) - (fontSize text))) isStatic) {
	  if (contains (methodNames (class 'InputSlot')) menuSelector) {
		menu = (call menuSelector this)
		if (notNil menu) {
		  popUpAtHand menu (page aHand)
		}
	  } else {
		project = (project (findProjectEditor))
		choices = (choicesFor project menuSelector)
		if (notNil choices) {
		  menu = (menu nil (action 'setContents' this) true)
		  for choice choices {
		    labelAndValue = (splitWith choice ':')
		    if ((count labelAndValue) == 2) {
		      if (representsAnInteger (at labelAndValue 2)) {
		        atPut labelAndValue 2 (toNumber (at labelAndValue 2))
		      }
		      addItem menu (at labelAndValue 1) (at labelAndValue 2)
		    } else {
			  addItem menu choice
			}
		  }
		  popUpAtHand menu (page aHand)
		}
	  }
    }
	return true
  }
  return false
}

method typesMenu InputSlot {
  menu = (menu nil (action 'setContents' this) true)
  addItem menu 'boolean'
  addItem menu 'number'
  addItem menu 'string'
  addItem menu 'list'
  addItem menu 'byte array'
  return menu
}

method buttonMenu InputSlot {
  menu = (menu nil (action 'setContents' this) true)
  addItem menu 'A'
  addItem menu 'B'
  addItem menu 'A+B'
  return menu
}

method AtoDMenu InputSlot {
  menu = (menu nil (action 'setContents' this) true)
  addItem menu 'A'
  addItem menu 'B'
  addItem menu 'C'
  addItem menu 'D'
  return menu
}

// List Menus

method itemOfMenu InputSlot {
  menu = (menu nil (action 'setContents' this) true)
  addItem menu 1
  addItem menu 'last'
  addItem menu 'random'
  return menu
}

method replaceItemMenu InputSlot {
  menu = (menu nil (action 'setContents' this) true)
  addItem menu 1
  addItem menu 'last'
  addItem menu 'all'
  return menu
}

method functionNameMenu InputSlot {
  menu = (menu nil (action 'setContents' this) true)
  scripterM = (ownerThatIsA morph 'MicroBlocksScripter')
  if (notNil scripterM) {
    project = (project (handler scripterM))
    specs = (blockSpecs project)
    for func (functions (main project)) {
	  addItem menu (functionName func)
    }
  }
  return menu
}

// Disallow reporter blocks in hat block input slots
// (does apply to BooleanSlots in "when <boolean>" hat blocks)

method isReplaceableByReporter InputSlot {
	owner = (handler (owner morph))
	if (and (isClass owner 'Block') ('hat' == (type owner))) {
		// Don't allow dropping reporters into hat block input slots.
		return false
	}
	return (not isStatic)
}

method confirmToQuit Page {
	confirm this nil (join 'Quit MicroBlocks?') nil nil 'exit'
}

to findProjectEditor {
  m = (findMorph 'MicroBlocksEditor')
  if (notNil m) { return (handler m) }
  return nil
}

to gpFolder {
  if ('iOS' == (platform)) { return '.' }
  path = (userHomePath)

  hidden = (global 'hideFolderShortcuts')
  if (and (notNil hidden) (contains hidden 'Projects')) { return '/' } // if GP hidden, use computer

  // Look for <home>/Documents
  if (contains (listDirectories path) 'Documents') {
	path = (join path '/Documents')
  }
  if (not (contains (listDirectories path) 'MicroBlocks')) {
	if (contains (listDirectories path) 'MicroBlocks Projects') {
		// if it exists, rename old 'MicroBlocks Projects' folder to 'MicroBlocks'
		renameFile (join path '/MicroBlocks Projects') (join path '/MicroBlocks')
	} else {
		// create the MicroBlocks folder if it does not already exist
		makeDirectory (join path '/MicroBlocks')
	}
  }
  if (contains (listDirectories path) 'MicroBlocks') {
    // create the Libraries subfolder, if it does not already exist
	if (not (contains (listDirectories (join path '/MicroBlocks') 'Libraries'))) {
		makeDirectory (join path '/MicroBlocks/Libraries')
	}
	path = (join path '/MicroBlocks')
  }
  return path
}

// Broadcast menu

method broadcastMenu InputSlot {
  menu = (menu)

  scripter = (ownerThatIsA morph 'MicroBlocksScripter')
  if (notNil scripter) {
    saveScripts (handler scripter)
    msgList = (allBroadcasts (project (handler scripter)))

    // special case for default broadcast string
    defaultBroadcast = 'go!'
    remove msgList defaultBroadcast
    addItemNonlocalized menu (localized defaultBroadcast) (action 'setContents' this defaultBroadcast)
    addLine menu

	for s msgList {
      addItemNonlocalized menu s (action 'setContents' this s)
	}
  }
  return menu
}

// Block additions

method clicked Block hand {
  cancelSelection
  if (and (contains (array 'template' 'defer') (grabRule morph)) (isRenamableVar this)) {
    userRenameVariable this
    return
  } (isPrototype this) {
    def = (blockDefinition this)
    if (notNil def) {
      return (clicked def hand)
    }
    return true
  } (isPrototypeHat this) {
    prot = (editedPrototype this)
    if (notNil prot) {
      return (clicked prot hand)
    }
  } (isClass (handler (owner morph)) 'BlockOp') {
    return
  }

  topBlock = (topBlock this)
  if (isPrototypeHat topBlock) { return }
  runtime = (smallRuntime)
  if (isRunning runtime topBlock) {
	stopRunningChunk runtime (lookupChunkID runtime topBlock)
  } else {
	evalOnBoard runtime topBlock
  }
}

method aboutToBeGrabbed Block {
  if (isNil (owner morph)) {return}
  tb = (topBlock this)
  se = (ownerThatIsA (morph tb) 'ScriptEditor')
  if (notNil se) {
    stopEditing (handler se)
  }
  removeSignalPart (morph tb)
  removeStackPart (morph tb)
  removeHighlight (morph tb)


  // show trashcan icon
  if (isPrototypeHat this) {
	  showTrashcan (findMicroBlocksEditor) 'hide'
  } else {
	  showTrashcan (findMicroBlocksEditor) 'delete'
  }

  if (or
		(commandKeyDown (keyboard (global 'page')))
		(controlKeyDown (keyboard (global 'page')))
  ) {
	// duplicate all with control + grab
	dup = (duplicate this)
	owner = (handler (owner morph))
	if (shiftKeyDown (keyboard (global 'page'))) {
		// duplicate block with control + shift + grab
		if (notNil (next dup)) {setNext dup nil}
	}
	if (notNil owner) {
		if (isClass owner 'CommandSlot') {
			setNested owner dup
		} (isClass owner 'Block') {
			if ((type dup) == 'reporter') {
				replaceInput owner this dup
			} else {
				setNext owner dup
			}
		} (isClass owner 'ScriptEditor') {
			addPart (morph owner) (morph dup)
		}
	}
  }

  // extract block with shift + grab
  if (and
		(shiftKeyDown (keyboard (global 'page')))
		(notNil (next this))
  ) {
    extractBlock this true
	return
  }

  parent = (handler (owner morph))
  if (isClass parent 'Block') {
    if (type == 'reporter') {
      revertToDefaultInput parent this
    } else {
      setNext parent nil
    }
  } (isClass parent 'CommandSlot') {
    setNested parent nil
  }

}

method justDropped Block hand {
  cancelSelection
  snap this (x hand) (y hand)
  hideTrashcan (findMicroBlocksEditor)
}

method alternateOperators Block {
  if (contains (array 'v' '=' '+=') (primName expression)) {
	// if it's a variable, return a group with all existing variables
	return (array '')
  } else {
	opGroups = (array
		(array 'analogReadOp' 'digitalReadOp')
		(array 'analogWriteOp' 'digitalWriteOp')
		(array 'analogPins' 'digitalPins')
		(array 'and' 'or')
		(array '+' '-' '*' '/' '%')
		(array 'buttonA' 'buttonB')
		(array '<' '<=' '==' '!=' '>=' '>')
		(array 'maximum' 'minimum')
		(array 'millisOp' 'microsOp')
		(array '=' '+=')
		(array '&' '|' '^' '<<' '>>')
	)
	op = (primName expression)
	for group opGroups {
		if (contains group op) { return group }
	}
  }
  return nil
}

method changeOperator Block newOp {
  cancelSelection
  setField expression 'primName' newOp
  scripter = (scripter (findProjectEditor))
  updateScriptAfterOperatorChange scripter this
}

method changeVar Block varName {
  cancelSelection
  newVarReporter = (newReporter 'v' varName)
  blockOwner = (handler (owner morph))
  if (isClass blockOwner 'Block') {
    owningExpr = (expression blockOwner)
    args = (argList owningExpr)
    for i (count args) {
      if ((at args i) == (expression this)) {
        setArg owningExpr i newVarReporter
      }
    }
  } else { // top level var reporter
    expression = newVarReporter
  }
  scripter = (scripter (findProjectEditor))
  updateScriptAfterOperatorChange scripter this
}

method contextMenu Block {
  if (isPrototype this) {return nil}
  menu = (menu nil this)
  pe = (findProjectEditor)
  scripter = (scripter pe)
  selection = (selection scripter)
  if (and (notNil selection) (notEmpty selection)) {
  	return (contextMenu selection)
  }

  isInPalette = ('template' == (grabRule morph))
  if (and isInPalette (isRenamableVar this)) {
    addItem menu 'rename...' 'userRenameVariable'
    addLine menu
  }
  addItem menu 'duplicate' 'grabDuplicate' 'duplicate this block'
  if (and ('reporter' != type) (notNil (next this))) {
    addItem menu 'duplicate all' 'grabDuplicateAll' 'duplicate this block and all blocks below it'
  }
  addLine menu
  if (and (not isInPalette) ('reporter' != type)) {
    addItem menu 'extract block' 'extractBlock' 'pull out this block'
  }
  addLine menu
  if (hasHelpEntryFor pe this) {
    addItem menu 'help' (action 'openHelp' pe this) 'show help for this block in a browser'
    addLine menu
  }
  addItem menu 'copy to clipboard' (action 'copyToClipboard' (topBlock this)) 'copy these blocks to the clipboard'
  addItem menu 'copy to clipboard as URL' (action 'copyToClipboardAsURL' (topBlock this)) 'copy these blocks to the clipboard as a URL'
  addLine menu
  addItem menu 'save picture of script' 'exportAsImage' 'save a picture of these blocks as a PNG file'
  if (not (isPrototypeHat (topBlock this))) {
	if (or ('reporter' == (type (topBlock this))) (devMode)) {
	  addItem menu 'save picture of script with result' 'exportAsImageWithResult' 'save a picture of these blocks and their result as a PNG file'
	}
  }
  if (devMode) {
	addLine menu
    addItem menu 'show instructions' (action 'showInstructions' (smallRuntime) this)
    addItem menu 'show compiled bytes' (action 'showCompiledBytes' (smallRuntime) this)
    if (and isInPalette (notNil (functionNamed (project pe) (primName expression)))) {
	  addItem menu 'show call tree' (action 'showCallTree' (smallRuntime) this)
    }

	// xxx internal testing only; remove later!:
	if (contains (commandLine) '--allowMorphMenu') {
		addItem menu 'test decompiler' (action 'testDecompiler' (smallRuntime) this) // xxx
	}
  }
  addLine menu

  if (contains (array 'v' '=' '+=') (primName expression)) {
	  addItem menu 'find variable accessors' 'findVarAccessors' 'find scripts or block definitions where this variable is being read'
	  addItem menu 'find variable modifiers' 'findVarModifiers' 'find scripts or block definitions where this variable is being set or changed'
  } else {
	  addItem menu 'find uses of this block' 'findBlockUsers' 'find scripts or block definitions using this block'
  }
  if (notNil (functionNamed (project pe) (primName expression))) {
    addItem menu 'show block definition...' 'showDefinition' 'show the definition of this block'
	if isInPalette {
	  addLine menu
	  addItem menu 'delete block definition...' 'deleteBlockDefinition' 'delete the definition of this block'
	}
  } (and (notNil blockSpec) (beginsWith (at (specs blockSpec) 1) 'obsolete')) {
	  addLine menu
	  addItem menu 'delete obsolete block...' 'deleteObsolete' 'delete this obsolete block from the project'
  }
  if ((primName expression) == 'v') {
	varNames = (allVariableNames (project scripter))
	if (and (not isInPalette) ((count varNames) > 1)) {
		for varName varNames {
			if (and (varName != (first (argList expression))) ((at varName 1) != '_') (not (showHiddenBlocksEnabled pe))) {
				b = (toBlock (newReporter 'v' varName))
				fixLayout b
				addItem menu (fullCostume (morph b)) (action 'changeVar' this varName)
			}
		}
	}
  } else {
	alternativeOps = (alternateOperators this)
	if (and (not isInPalette) (notNil alternativeOps)) {
		addLine menu
		myOp = (primName expression)
		for op alternativeOps {
		  // create and display block morph (with translated spec)
		  spec = (specForOp (authoringSpecs) op)
		  if (and (notNil spec) (op != myOp)) {
			b = (blockForSpec spec)
			fixLayout b
			addItem menu (fullCostume (morph b)) (action 'changeOperator' this op)
		  }
		}
	}
  }
  if (not isInPalette) {
	addLine menu
	addItem menu 'delete block' 'delete' 'delete this block'
  }
  return menu
}

method extractBlock Block whileGrabbing {
  cancelSelection
  whileGrabbing = (whileGrabbing == true)
  if ('reporter' != type) { // hat or command
    nxt = (next this)
    if (and (notNil nxt) (notNil (owner morph))) {
      prev = (ownerThatIsA (owner morph) 'Block')
      cslot = (ownerThatIsA (owner morph) 'CommandSlot')
      scripts = (ownerThatIsA (owner morph) 'ScriptEditor')
      if (and (notNil prev) (=== this (next (handler prev)))) {
        setNext this nil
		if whileGrabbing {
			// needed while grabbing or we end up in an infinite recursion
			setNext (handler prev) nil
		}
		setNext (handler prev) nxt
      } (and (notNil cslot) (=== this (nested (handler cslot)))) {
        setNext this nil
		if whileGrabbing {
			// needed while grabbing or we end up in an infinite recursion
			setNested (handler cslot) nil
		}
        setNested (handler cslot) nxt
      } (notNil scripts) {
        addPart scripts (morph nxt)
        fixBlockColor nxt
      }
      setNext this nil
    }
  }
  if (not whileGrabbing) { grabTopLeft morph }
}

method exportAsImage Block { exportAsImageScaled (topBlock this) }
method exportAsImageWithResult Block { exportScriptImageWithResult (smallRuntime) this }

method exportAsImage BlockDefinition {
	exportAsImageScaled (handler (ownerThatIsA morph 'Block'))
}

method copyToClipboard Block {
  setClipboard (scriptText this)
}

method copyToClipboardAsURL Block {
  setClipboard (join
    'https://microblocks.fun/run/microblocks.html#scripts='
	(urlEncode (scriptText this) true)
  )
}

method scriptText Block useSemicolons {
  // Note: scriptText is also called by exportAsImageScaled when saving PNG files.

  mbScripter = (handler (ownerThatIsA morph 'MicroBlocksScripter'))
  return (scriptStringFor mbScripter this)
}

method delete Block {
  if ('reporter' != type) { // hat or command
    nxt = (next this)
    if (and (notNil nxt) (notNil (owner morph))) {
      prev = (ownerThatIsA (owner morph) 'Block')
      cslot = (ownerThatIsA (owner morph) 'CommandSlot')
      scripts = (ownerThatIsA (owner morph) 'ScriptEditor')
      if (and (notNil prev) (=== this (next (handler prev)))) {
        setNext this nil
        setNext (handler prev) nxt
      } (and (notNil cslot) (=== this (nested (handler cslot)))) {
        setNext this nil
        setNested (handler cslot) nxt
      } (notNil scripts) {
        addPart scripts (morph nxt)
      }
    }
  }
  aboutToBeGrabbed this
  removeFromOwner morph
  hideTrashcan (findMicroBlocksEditor)
}

// Inspection operations

method findBlockUsers Block {
	pe = (findProjectEditor)
	findBlockUsers (project pe) this
}

method findVarAccessors Block {
	pe = (findProjectEditor)
	findVarAccessors (project pe) this
}

method findVarModifiers Block {
	pe = (findProjectEditor)
	findVarModifiers (project pe) this
}


// Block definition operations

method showDefinition Block {
  pe = (findProjectEditor)
  if (isNil pe) { return }
  showDefinition (scripter pe) (primName expression)
}

method deleteObsolete Block {
  pe = (findProjectEditor)
  if (isNil pe) { return }

  // find out whether block is being used in the project
  finder = (initialize (new 'BlockFinder') (project (scripter pe)) this)
  find finder 'users'
  if (notEmpty (allEntries finder)) {
    if (not
      (confirm
	    (global 'page')
	    nil
        (join
          'This block is still being used in '
          (count (allEntries finder))
          ' scripts or functions.'
          (newline)
          (newline)
          'Are you sure you want to remove this obsolete block definition?'
        )
	  )
	) { return }
  }

  remove (blockSpecs (project (scripter pe))) (primName expression)
  updateBlocks (scripter pe)
}

method deleteBlockDefinition Block {
  pe = (findProjectEditor)
  if (isNil pe) { return }

  confirmation = 'Are you sure you want to remove this block definition?'

  // find out whether block is being used in the project
  finder = (initialize (new 'BlockFinder') (project (scripter pe)) this)
  find finder 'users'
  if (notEmpty (allEntries finder)) {
    confirmation = (join
      'This block is still being used in '
      (count (allEntries finder))
      ' scripts or functions.'
	  (newline)
	  (newline)
	  confirmation
	)
  }

  if (not (confirm (global 'page') nil confirmation)) { return }

  deleteFunction (scripter pe) (primName expression)
}

method deleteBlockDefinition BlockDefinition {
  if (not (confirm (global 'page') nil
  	'Are you sure you want to remove this block definition?')) {
		return
  }
  pe = (findProjectEditor)
  if (isNil pe) { return }
  deleteFunction (scripter pe) op
}

method hideDefinition BlockDefinition {
  // Remove this method/function definition from the scripting area.

  pe = (findProjectEditor)
  if (isNil pe) { return }
  hideDefinition (scripter pe) op
}

method wantsDropOf BlocksPalette aHandler {
  return (isAnyClass aHandler 'Block' 'Monitor' 'MicroBlocksSelectionContents')
}

method justReceivedDrop BlocksPalette aHandler {
  // Hide a block definition when it is is dropped on the palette.
  pe = (findProjectEditor)
  if (isClass aHandler 'Block') { stopRunningBlock (smallRuntime) aHandler }
  if (and (isClass aHandler 'Block') (isPrototypeHat aHandler)) {
	proto = (editedPrototype aHandler)
	if (and (notNil pe) (notNil proto) (notNil (function proto))) {
		hideDefinition (scripter pe) op
		removeFromOwner (morph aHandler)
		return
	}
  }
  if (and (isClass aHandler 'Block') (notNil pe)) {
	recordDrop (scriptEditor (scripter pe)) aHandler
	deleteChunkFor (smallRuntime) aHandler
  }
  if (isClass aHandler 'MicroBlocksSelectionContents') {
	for part (parts (morph aHandler)) {
		justReceivedDrop this (handler part)
	}
  }
  removeFromOwner (morph aHandler)
}

method wantsDropOf CategorySelector aHandler {
	// only accept definition hat blocks
	scripter = (scripter (findProjectEditor))
	return (and
		(isClass aHandler 'Block')
		(isNil (blockSpec aHandler))
		((type aHandler) == 'hat')
	)
}

// Allow adding blocks to libraries by dropping their definitions into the
// library selector
method justReceivedDrop CategorySelector aHandler {
	pe = (findProjectEditor)
	scripter = (scripter pe)
	mainModule = (main (project pe))
	intoLibrary = (and
		((getField scripter 'libSelector') == this)
		(notNil (categoryUnderHand this)))
	intoMyBlocks = (and
		((getField scripter 'categorySelector') == this)
		((categoryUnderHand this) == 'My Blocks'))

	// accept it if dropping onto the library list or onto the category list,
	// but only if it's onto My Blocks
	if (or intoLibrary intoMyBlocks){
		block = (handler (at (parts (morph aHandler)) 2))
		function = (function block)
		for lib (values (libraries (project scripter))) {
			if (contains (functions lib) function) {
				// Block already in a library, let's remove it from there first
				removeFunction lib function
				remove (blockList lib) (functionName function)
				remove (blockSpecs lib) (blockSpecFor function)
			}
		}
		if intoLibrary {
			library = (at (libraries (project scripter)) (categoryUnderHand this))
		} else {
			library = mainModule
		}
		if (not (contains (functions library) function)) {
			globalsUsed = (globalVarsUsed function)
			if (contains (functions mainModule) function) {
				// Block is in My Blocks, let's remove it from there first
				removeFunction mainModule function
				remove (blockList mainModule) (functionName function)
				remove (blockSpecs mainModule) (blockSpecFor function)
				for var globalsUsed {
					deleteVariable mainModule var
				}
			}
			addFunction library function
			add (blockList library) (functionName function)
			add (blockSpecs library) (blockSpecFor function)
			for var globalsUsed {
				addVariable library var
			}
		}
		select this (categoryUnderHand this)
	}
	animateBackToOldOwner (hand (global 'page')) (morph aHandler) (action 'languageChanged' scripter)
}

// Input slots

method inputIndex Block anInput {
  idx = 0
  items = (flattened labelParts)

  // Note: removed special case for variable assignments

  for each items {
    if (isAnyClass each 'InputSlot' 'BooleanSlot' 'ColorSlot' 'CommandSlot' 'Block' 'MicroBitDisplaySlot') {
      idx += 1
      if (each === anInput) {return idx}
    }
  }
  return nil
}

method representsANumber String {
	// MicroBlocks only supports integers.
	if ('' == String) { return true }
	isFirst = true
	for c (letters this) {
		if ('-' == c) {
			if (not isFirst) { return false }
		} (not (isDigit c)) {
			return false
		}
		isFirst = false
	}
	return true
}

method contextMenu BlockDefinition {
  menu = (menu nil this)
  addItem menu 'hide block definition' 'hideDefinition'
  addLine menu
  addItem menu 'copy to clipboard' (action 'copyToClipboard' (handler (ownerThatIsA morph 'Block'))) 'copy these blocks to the clipboard'
  addItem menu 'copy to clipboard as URL' (action 'copyToClipboardAsURL' (handler (ownerThatIsA morph 'Block'))) 'copy these blocks to the clipboard as a URL'
  addLine menu
  addItem menu 'save picture of script' 'exportAsImage' 'save a picture of this block definition as a PNG file'
  if (devMode) {
    addLine menu
    addItem menu 'show instructions' (action 'showInstructions' this)
    addItem menu 'show compiled bytes' (action 'showCompiledBytes' this)
    addItem menu 'show call tree' (action 'showCallTree' this)
  }
  addLine menu
  addItem menu 'delete block definition...' 'deleteBlockDefinition'
  popUp menu (global 'page') (left morph) (bottom morph)
}

method showInstructions BlockDefinition {
  showInstructions (smallRuntime) (handler (owner (owner morph)))
}

method showCompiledBytes BlockDefinition {
  showCompiledBytes (smallRuntime) (handler (owner (owner morph)))
}

method showCallTree BlockDefinition {
  showCallTree (smallRuntime) (handler (owner (owner morph)))
}

method initializeRepeater BlockDefinition aBlockSpec {
  if (isNil aBlockSpec) {
    isRepeating = false
  } else {
    isRepeating = (repeatLastSpec aBlockSpec)
  }
  drawer = (newBlockDrawer this nil 'vertical')
  repeater = (newAlignment 'centered-line' 0 'bounds')
  setMorph repeater (newMorph repeater)
  if isShort {
    hide (morph repeater)
  }
  setPadding repeater (5 * (global 'scale'))
return // xxx suppress the ability to make variadic user-defined blocks

  addPart (morph repeater) (morph drawer)

  scale = (global 'scale')
  labelColor = (global 'blockTextColor')
  if (isNil labelColor) { labelColor = (gray 255) }
  txt = (newText 'repeat last section:' 'Arial' (10 * scale) labelColor)
  addPart (morph repeater) (morph txt)

  corner = 5
  toggle = (toggleButton (action 'toggleRepeat' this) (action 'isRepeating' this) (scale * 20) (scale * 13) (scale * corner) (max 1 (scale / 2)) false false)
  addPart (morph repeater) (morph toggle)
}

// additions to Hand for script selection

method oldX Hand { return oldX }
method oldY Hand { return oldY }
method savePosition Hand {
	oldX = x
	oldY = y
}

// additions to Block for script selection

method select Block {
	if (isNil originalColor) {
		originalColor = color
		color = (mixed color 50 (color 0 255 0))
		pathCache = nil
		changed morph
		if (notNil (next this)) {
			select (next this)
		}
		for i (inputs this) {
			if (isClass i 'Block') {
				select i
			} (and
				(isClass i 'CommandSlot')
				(notNil (nested i))
			) {
				select (nested i)
			}
		}
	}
}

method unselect Block {
	if (notNil originalColor) {
		color = originalColor
		originalColor = nil
		pathCache = nil
		changed morph
	}
}

// support for script selection

method handDownOn ScriptEditor aHand {
	if (notNil (grabbedObject aHand)) { return false } // hand is not empty
	scripter = (handler (ownerThatIsA morph 'MicroBlocksScripter'))
	pe = (findProjectEditor)
	selection = (selection (scripter pe))
	if (and (notNil selection) (notEmpty selection)) {
		grabbed = (ownerThatIsA (morph (objectAt aHand)) 'Block')
		if (and (notNil grabbed) (contains selection (handler grabbed))) {
			dragBlocks selection
			return true
		}
	}
	if (isClass (objectAt aHand) 'ScriptEditor') {
		startSelecting scripter aHand
	}
	return true
}

method wantsDropOf ScriptEditor aHandler {
  return (or
    (isAnyClass aHandler 'Block' 'CommandSlot' 'MicroBlocksSelectionContents')
    (and
      (devMode)
      (isClass aHandler 'Text')
      (== 'code' (editRule aHandler))))
}

method contextMenu ScriptEditor {
  menu = (menu nil this)
  addItem menu 'set block size...' 'setBlockSize' 'make blocks bigger or smaller'
  addLine menu
  if (notNil lastDrop) {
    addItem menu 'undrop (ctrl-Z)' 'undrop' 'undo the last block drop'
  }
  addItem menu 'clean up' 'cleanUp' 'arrange scripts'
  addLine menu
  addItem menu 'copy all scripts to clipboard' 'copyScriptsToClipboard'
  addItem menu 'copy all scripts to clipboard as URL' 'copyScriptsToClipboardAsURL'
  addLine menu
  clip = (readClipboard)
  if (beginsWith clip 'GP Scripts') {
	addItem menu 'paste all scripts from clipboard' 'pasteScripts'
  } (beginsWith clip 'GP Script') {
	addItem menu 'paste script from clipboard' 'pasteScripts'
  }
  addLine menu
  addItem menu 'save a picture of all visible scripts' 'saveScriptsImage'
  if (devMode) {
    addItem menu 'set exported script scale' 'setExportedScriptScale'
  }
  return menu
}

method copyScriptsToClipboard ScriptEditor {
  scripter = (ownerThatIsA morph 'MicroBlocksScripter')
  if (isNil scripter) { return }
  setClipboard (allScriptsString (handler scripter))
}

method copyScriptsToClipboardAsURL ScriptEditor {
  scripter = (ownerThatIsA morph 'MicroBlocksScripter')
  if (isNil scripter) { return }
  scriptsString = (allScriptsString (handler scripter))
  setClipboard (join
      'https://microblocks.fun/run/microblocks.html#scripts='
	  (urlEncode scriptsString true))
}

// Color picker tweak

method addTransparentButton ColorPicker x y { } // don't add a transparent button

// Block colors

method blockColorForOp AuthoringSpecs op {
  if ('comment' == op) { return (colorHSV 55 0.6 0.93) }
  pe = (findProjectEditor)
  if (notNil pe) {
	cat = (categoryForOp (project pe) op) // get category from project, if possible
  }
  if (isNil cat) { cat = (at opCategory op) } // get category of a built-in block
  return (blockColorForCategory this cat)
}

method blockColorForCategory AuthoringSpecs cat {
  if (and (notNil cat) (endsWith cat '-Advanced')) {
  	cat = (substring cat 1 ((count cat) - 9))
  }
  pe = (findProjectEditor)
  if (notNil pe) {
	lib = (libraryNamed (project pe) cat) // is cat the name of a library?
	if (and (notNil lib) (notNil (moduleCategory lib))) { // if so, use that library's category
		cat = (moduleCategory lib)
	}
  }
  // old Comm color: (colorHSV 195 0.50 0.60)
  // old default color: (colorHSV 200 0.98 0.86)
  defaultColor = (colorHSV 205 0.83 0.87)
  if ('Output' == cat) { return (colorHSV 235 0.62 0.75)
  } ('Input' == cat) { return (colorHSV 296 0.60 0.65)
  } ('Pins' == cat) { return (colorHSV 195 0.45 0.60)
  } ('Comm' == cat) {  return (colorHSV 14 0.75 0.80)
  } ('Control' == cat) { return (colorHSV 36 0.70 0.87)
  } ('Operators' == cat) { return (colorHSV 100 0.75 0.65)
  } ('Variables' == cat) { return (colorHSV 26 0.80 0.83)
  } ('Data' == cat) { return (colorHSV 345 0.60 0.77)
  } ('Advanced' == cat) { return (colorHSV 30 0.70 0.70)
  } ('My Blocks' == cat) { return (colorHSV 205 0.83 0.90)
  } ('Library' == cat) {  return (colorHSV 165 0.80 0.60)
  } ('Obsolete' == cat) { return (colorHSV 4.6 1.0 0.77)
  }
  return defaultColor
}

// Scratch		1.0					2.0
// Motion	(color 102 124 236)	(color 76 111 209)
// Looks	(color 147 84 235)	(color 36 139 216)
// Sound	(color 217 43 225)	(color 185 72 193)
// Pen		(color 35 165 124)	(color 29 153 109)
// Control	(color 227 154 43)	(color 224 168 48)
// Sensing	(color 39 149 230)	(color 53 166 223) like default color
// Operators (color 99 196 44)	(color 95 181 39)
// Variables (color 226 95 27)	(color 236 125 42) variables is like 2.0
// Events						(color 199 130 57)
// More Blocks					(color 98 50 151)))

// ListBox: Support for colored blocks categories

method setOpCategory AuthoringSpecs op category {
  atPut opCategory op category
}

method normalCostume ListBox data accessor {
  scale = (global 'scale')
  if (isNil accessor) {accessor = getEntry}
  dta = (call accessor data)
  if (isClass dta 'Array') {
    return (stringImage (at dta 1) fontName fontSize txtClrNormal nil nil nil nil paddingX paddingY)
  } (isClass dta 'String') {
	// Colored categories:
	if (and (isClass onSelect 'Action') (isOneOf (function onSelect) 'categorySelected' 'librarySelected')) {
	  // add color swatch for category
	  c = (blockColorForCategory (authoringSpecs) dta)
	  stringBM = (stringImage (localized dta) fontName fontSize (gray 50))
	  bm = (newBitmap ((width stringBM) + (50 * scale)) (21 * scale))
	  fillRect bm c (4 * scale) (1 * scale) (10 * scale) ((height bm) - (4 * scale))
	  drawBitmap bm stringBM (19 * scale) (1 * scale)
	  return bm
	}
	return (stringImage dta fontName fontSize txtClrNormal nil nil nil nil paddingX paddingY)
  } (isClass dta 'Bitmap') {
    bm = (newBitmap (+ (* 2 paddingX) (width dta)) (+ (height dta) (* 2 paddingY)) bgClrNormal)
    drawBitmap bm dta paddingX paddingY normalAlpha
    return bm
  }
  return (itemCostume this dta txtClrNormal nil normalAlpha 'id')
}

method itemCostume ListBox data foregroundColor backgroundColor alpha accessor {
  scale = (global 'scale')
  if (isNil accessor) {accessor = getEntry}
  dta = (call accessor data)
  if (isClass dta 'Bitmap') {
    bm = (newBitmap (max (+ (* 2 paddingX) (width dta)) (width morph)) (+ (height dta) (* 2 paddingY)) backgroundColor)
    drawBitmap bm dta paddingX paddingY alpha
    return bm
  } (isClass dta 'Morph') {
    return (itemCostume this (fullCostume dta) foregroundColor backgroundColor alpha 'id')
  } (hasField dta 'morph') {
    return (itemCostume this (fullCostume (getField dta 'morph')) foregroundColor backgroundColor alpha 'id')
  } (isAnyClass dta 'Command' 'Reporter') {
    return (itemCostume this (fullCostume (morph (toBlock dta))) foregroundColor backgroundColor alpha 'id')
  } (isClass dta 'String') {
	// Colored categories:
	if (and (isClass onSelect 'Action') (isOneOf (function onSelect) 'categorySelected' 'librarySelected')) {
	  c = (blockColorForCategory (authoringSpecs) dta)
	  isMouseOver = (bgClrReady == backgroundColor)
	  if isMouseOver { c = (lighter c 40) }
	  bm = (newBitmap (width morph) (21 * scale))
	  fillRect bm c 0 0 (width bm) ((height bm) - (2 * scale))
	  stringBM = (stringImage (localized dta) fontName fontSize (gray 255))
	  drawBitmap bm stringBM (19 * scale) (1 * scale)
	  return bm
	}
    return (itemCostume this (stringImage dta fontName fontSize foregroundColor) foregroundColor backgroundColor alpha 'id')
  } else {
    return (itemCostume this (toString dta) foregroundColor backgroundColor alpha 'id')
  }
}
// MicroBlocks startup function is in MicroBlocksEditor.gp
IDE 1.2.46
VM 210
# MicroBlocks translation file
# Last updated: March 14 2023

#########################
# Blocks and categories #
#########################

Output
Salida

set user LED _
enciende LED integrado _

say _
di _

graph _
aÃ±ade al grÃ¡fico _

Input
Entrada

button A
botÃ³n A

button B
botÃ³n B

timer
cronÃ³metro

reset timer
reinicia cronÃ³metro

microseconds
microsegundos

milliseconds
milisegundos

board type
tipo de placa

Pins
Pines

read digital pin _
lectura digital _

read analog pin _
lectura analÃ³gica _

pullup _
con resistencia interna _

set digital pin _ to _
pon pin digital _ a _

set pin _ to _
pon pin _ a _

analog pins
pines analÃ³gicos

digital pins
pines digitales

Control
Control

when started
al empezar

when button _ pressed
cuando se pulse el botÃ³n _

forever _
por siempre _

repeat _ _
repite _ veces _

wait _ millisecs
espera _ milisegundos

if _ _
si _ _

if _ _ else _
si _ _ si no _

else if _ _
si no, si _ _

else
si no

when _
cuando _

wait until _
espera hasta que _

wait _ microsecs
espera _ microsegundos

return _
retorna _

when _ received
al recibir _

go!
--MISSING--

broadcast _
envÃ­a _

comment _
comentario _

How this works...
--MISSING--

for _ in _ _
por cada _ en _ _

repeat until _ _
repite hasta que _ _

stop this task
detÃ©n esta tarea

stop other tasks
detÃ©n las otras tareas

stop all
detenlo todo

last message
Ãºltimo mensaje

call _
llama _

function name
--MISSING--

parameter list
--MISSING--

with _
con parÃ¡metro(s) _

Operators
Operadores

_ mod _
_ mÃ³dulo _

abs _
valor absoluto de _

min _ _
mÃ­nimo entre _ y _

max _ _
mÃ¡nimo entre _ y _

random _ to _
nÃºmero al azar entre _ y _

not _
no _

_ and _
_ y _

and _
y _

_ or _
_ o _

or _
o _

_ is a _
_ es un _

convert _ to _
convertir _ a _

boolean
booleano

number
nÃºmero

string
texto

list
listas

byte array
lista de bytes

Advanced:
Avanzado:

rescale _ from ( _ , _ ) to ( _ , _ )
reescalar _ de ( _ , _ ) a ( _ , _ )


hex _
hexadecimal _

Variables
Variables

# Buttons on top of "Variables" category

Add a variable
Crea una variable

Delete a variable
Elimina una variable

# New variable dialog

New variable name?
Â¿Nombre de la variable?

set _ to _
asigna _ a _

change _ by _
aumenta _ en _

initialize local _ to _
inicializa variable local _ a _

Data
Datos

list
listas

cat
--MISSING--

dog
--MISSING--

bird
--MISSING--

fish
--MISSING--

length of _
tamaÃ±o de _

item _ of _
elemento _ de _

replace item _ of list _ with _
sustituye elemento _ de lista _ por _

delete item _ of list _
elimina elemento _ de lista _

add _ to list _
aÃ±ade _ a lista _

join _ _
une _ _

copy _ from _
copia _ desde _

smiles
--MISSING--

to _
hasta _

find _ in _
busca _ en _

starting at _
empezando desde _

join items of list _
une elementos de la lista _

separator _
usando separador _

unicode _ of _
unicode _ de _

string from unicode _
carÃ¡cter con unicode _

new list length _
nueva lista de tamaÃ±o _

new byte array _
nueva lista de bytes de tamaÃ±o _

as byte array _
lista de bytes a partir de _

aByteListOrString
--MISSING--

with all _
llena de _

free memory
memoria libre

all
todos

last
Ãºltimo

random
cualquiera

split _ by _
divide _ por _

My Blocks
Mis bloques

Generic
GenÃ©rico

# Buttons on top of "My Blocks" category

Add a command block
Crea un bloque comando

Add a reporter block
Crea un bloque reportador

# Make a block dialog

Enter function name:
Nombre de la funciÃ³n:

Comm
Comunicaciones

i2c get device _ register _
lee del dispositivo i2c _ el registro _

i2c set device _ register _ to _
escribe al dispositivo i2c _ el registro _ con _

i2c device _ read list _
lee el dispositivo i2c _ a la lista

i2c device _ write list _
escribe al dispositivo i2c _ el contenido de la lista _

spi send _
spi envÃ­a _

spi receive
spi lee

spi setup speed _
velocidad de spi _

mode _
modo _

rpi channel _
canal de rpi _

spi exchange bytes _
bytes de intercambio de spi _

aByteArray
--MISSING--

serial open _ baud
abre puerto serie a _ baudios

serial close
cierra puerto serie

serial read
lee puerto serie

serial write _
escribe _ al puerto serie

serial write _ starting at _
escribe _ al puerto serie empezando por _

aByteStringOrByteArray
--MISSING--

soft serial write byte _ pin _ baud _
--MISSING--

print _
escribe _

no op
no op

ignore
ignora

##############
# Primitives #
##############

# These are all mostly hidden from end users

draw shape _ at x _ y _
dibuja forma _ en x _ y _

shape for letter _
forma para letra _

send NeoPixel rgb _
envÃ­a RGB _ al NeoPÃ­xel

has tone support
tiene soporte para tonos

play tone pin _ frequency _
toca un tono en el pin _ con frecuencia _

has WiFi support
tiene soporte para WiFi

start WiFi _ password _
inicia WiFi _ con contraseÃ±a _

stop WiFi
detÃ©n WiFi

WiFi status
estado de la WiFi

my IP address
mi direcciÃ³n IP

radio send number _
envÃ­a nÃºmero _ por radio

radio send string _
envÃ­a texto _ por radio

Hello!
--MISSING--

radio send pair _ = _
envÃ­a associaciÃ³n _ = _ por radio

light
--MISSING--

radio message received?
Â¿mensaje de radio recibido?

radio last number
Ãºltimo nÃºmero recibido por radio

radio last string
Ãºltimo texto recibido por radio

radio last message type
tipo del Ãºltimo mensaje recibido por radio

radio set group _ (0-255)
fija el grupo de radio a (0-255) _

radio set channel (0-83) _
fija el canal de radio a (0-83) _

radio set power (0-7) _
fija potencia de radio a (0-7) _

radio last signal strength
intensidad de la Ãºltima seÃ±al de radio

radio receive packet _
recibe paquete por radio _

radio send packet _
envÃ­a paquete por radio _

disable radio
inhabilita radio

#############
# Libraries #
#############

Basic Sensors
Sensores bÃ¡sicos

tilt x
inclinaciÃ³n x

tilt y
inclinaciÃ³n y

tilt z
inclinaciÃ³n z

acceleration
acceleraciÃ³n

light level
nivel de luz

temperature (Â°C)
temperatura (Â°C)

magnetic field
campo magnÃ©tico

set acceleration range _ g = 100
fija el rango de aceleraciÃ³n en _ g = 100

####
# NeoPixel library

NeoPixel
NeoPÃ­xeles

set NeoPixels _ _ _ _ _ _ _ _ _ _
pon NeoPÃ­xeles _ _ _ _ _ _ _ _ _ _

clear NeoPixels
apaga NeoPÃ­xeles

set NeoPixel _ color _
pon NeoPÃ­xel _ de color _

set all NeoPixels color _
pon todos los NeoPÃ­xeles de color _

rotate NeoPixels by _
rota NeoPÃ­xeles en _

brighten NeoPixel _ by _
aclarar NeoPixel _ en _

brighten all NeoPixels by _
aclarar todos los NeoPixels en _

color r _ g _ b _ (0-255)
color r _ v _ a _ (0-255)

random color
color al azar

attach _ LED NeoPixel strip to pin _
inicializa tira de _ NeoPÃ­xeles en el pin _

has white _
con blanco _

PIR
Sensor de movimiento

PIR at pin _ detected movement
Movimiento detectado por PIR en pin _

#### NeoPanel library

NeoPanel
NeoPanel

attach NeoPixel panel width _ height _ at pin _
inicializa panel de NeoPÃ­xels ancho _ alto _ en el pin _

NeoPanel set x _ y _ color _
pinta pÃ­xel x _ y _ de color _ en el NeoPanel

NeoPanel fill column _ color _
pinta columna _ color _ en el NeoPanel

NeoPanel fill row _ color _
pinta fila _ color _ en el NeoPanel

NeoPanel fill rectangle x _ y _ width _ height _ color _
pinta rectÃ¡ngulo x _ y _ ancho _ alto _ color _ en el NeoPanel

NeoPanel draw text _ at x _ y _ color _
escribe _ en x _ y _ color _ en el NeoPanel

NeoPanel draw BMP file _ at x _ y _
muestra imagen BMP _ x _ y _ en el NeoPanel

####
# Microphone library

Microphone
MicrÃ³fono

microphone
micrÃ³fono

turn on microphone
activa micrÃ³fono

loudness
volumen

clap count
recuento de palmadas

set clap threshold _
fija el umbral de palmada en _

estimate clap threshold
detecta el umbral de palmada

####
# Citilab ED1 board libraries

ED1 Stepper Motor
Motores ED1

move motor _ _ steps _
mueve motor _ _ pasos _

move motor 1 _ and motor 2 _ _ steps
mueve motor 1 en _ y motor 2 en _ _ pasos

move motor _ angle _ Â°
mueve motor _ Ã¡ngulo _ Â°

move motor _ _ complete turns
mueve motor _ _ vueltas completas

stop steppers
detÃ©n motores

clockwise
sentido horario

counter-clockwise
sentido antihorario

ED1 Buttons
Botones ED1

button OK
botÃ³n OK

button X
botÃ³n X

button up
botÃ³n arriba

button down
botÃ³n abajo

button left
botÃ³n izquierda

button right
botÃ³n derecha

capacitive sensor _
sensor capacitivo _

set capacitive threshold to _
fija umbral capacitivo en _

####
# BirdBrain Technologies libraries

Hummingbird LED _ _ %
Hummingbird LED _ _ %

Hummingbird Tri-LED _ R _ % G _ % B _ %
Hummingbird LED tricolor _ R _ % G _ % B _ %

Hummingbird Position Servo _ _ Â°
Hummingbird Servo Posicional _ _ Â°

Hummingbird Rotation Servo _ _ %
Hummingbird Servo de rotacion _ _ %

Hummingbird _ _
Hummingbird _ _

Hummingbird Battery (mV)
Hummingbird Bateria (mV)

Light
Luz

Distance (cm)
Distancia (cm)

Dial
Dial

Sound
Sonido

Other
Otro

Finch Beak Red _ Green _ Blue _
Enciende el pico de color R _ % V _ % A _ %

Finch Tail _ Red _ Green _ Blue _
Enciende la cola de color R _ % V _ % A _ %

Finch Move _ _ cm at _ %
Mueve hacia _ _ cm  a velocidad _ %

Finch Turn _ _ Â° at _ %
Gira hacia la _ _ Â° a velocidad _ %

Finch Wheels L _ % R _ %
Pon las ruedas a velocidad I _ % D _ %

Finch Stop
DetÃ©n el Finch

Finch Distance (cm)
Distancia (cm)

Finch _ Light
Luz _

Finch _ Line
LÃ­nea _

Finch Reset Encoders
Reinicializa los contadores de vueltas

Finch _ Encoder
Recuento de vueltas _

Finch Accelerometer _
AcelerÃ³metro

Finch Battery
Nivel de baterÃ­a

All
Todos

Forward
Adelante

Backward
AtrÃ¡s

Right
Derecha

Left
Izquierda

Beak Up
Pico hacia arriba

Beak Down
Pico hacia abajo

Tilt Left
Inclinado haciaa la izquierda

Tilt Right
Inclinado hacia la derecha

Level
Plano

Upside Down
Cabeza abajo

x
x

y
y

z
z

strength
potencia

####
# Ultrasound distance library

distance (cm) trigger _ echo _
distancia (cm) trigger _ echo _

####
# Infrared remote library

IR Remote
Infrarrojos

receive IR code
recibe cÃ³digo IR

receive IR code from device _
recibe cÃ³digo IR del dispositivo _

test IR
prueba IR

attach IR receiver to pin _
inicializa receptor IR en el pin _

IR transmit device _ command _
envÃ­a al dispositivo IR _ el comando _

####
# Keyboard and Mouse

Keyboard and Mouse
--MISSING--

press key _ : while holding _
--MISSING--

hold key _
--MISSING--

release key _
--MISSING--

release all keys
--MISSING--

_ mouse click
--MISSING--

move mouse pointer by _ , _
--MISSING--

scroll mouse by _
--MISSING--

hold _ mouse button
--MISSING--

release mouse buttons
--MISSING--

####
# Radio comm library
# Allows micro:bit boards to exchange messages
# All of its blocks are primitive (see "Primitives" section)

Radio
Radio

####
# Text scrolling library
# Scrolls text on 5x5 LED displays and simulated ones

Scrolling
Texto animado

scroll text _
anima el texto _

HELLO ROSA!
--MISSING--

scroll number _
anima el nÃºmero _

pausing _ ms
pausando _ ms

stop scrolling
detÃ©n la animaciÃ³n

####
# Servo motor library

Servo
Servomotores

set servo _ to _ degrees (-90 to 90)
pon el servo _ a _ grados (-90 a 90)

set servo _ to speed _ (-100 to 100)
haz girar el servo _ a velocidad _ (-100 a 100)

stop servo _
detÃ©n servo _

####
# 5x5 LED display library
# Supports the micro:bit display, but also simulated 5x5 displays on boards
# with differently sized LED arrays, NeoPixel arrays or TFT displays

LED Display
Pantalla LED

display _
pantalla _

clear display
limpia pantalla

set display color _
fija el color de la pantalla a _

plot x _ y _
enciende x _ y _

unplot x _ y _
apaga x _ y _

display character _
muestra carÃ¡cter _

####
# OLED Graphics library

initialize i2c _ address(hex) _ reset pin# _ flip _
--MISSING--

initialize spi _ d/c pin# _ reset pin# _ flip _
--MISSING--

write _ at x _ y _ inverse _
--MISSING--

show display buffer
--MISSING--

clear
--MISSING--

set contrast (1-4) _
--MISSING--

draw circle at x _ y _ radius _ erase _
--MISSING--

draw image _ at x _ y _
--MISSING--

draw line from x _ y _ to x _ y _ erase _
--MISSING--

draw rectangle x _ y _ w _ h _ erase _ rounding(3-15) _
--MISSING--

fill rectangle x _ y _ w _ h _ erase _
--MISSING--

_flip display top _
--MISSING--

make image _
--MISSING--

set pixel x _ y _ erase _
--MISSING--

set video _
--MISSING--

cursor location
--MISSING--

defer display updates
--MISSING--

####
# TFT display library

enable TFT _
activa TFT _

TFT width
ancho de la pantalla TFT

TFT height
alto de la pantalla TFT

set TFT pixel x _ y _ to _
pinta el pÃ­xel x _ y _ de color _

draw line on TFT from x _ y _ to x _ y _ color _
dibuja lÃ­nea de x _ y _ a x _ y _ color _

draw rectangle on TFT at x _ y _ width _ height _ color _
dibuja rectÃ¡ngulo en x _ y _ ancho _ alto _ color _

draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _
dibuja rectÃ¡ngulo redondeado en x _ y _ ancho _ alto _ radio _ color _

draw circle on TFT at x _ y _ radius _ color _
dibuja cÃ­rculo en x _ y _ radio _ color _

draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _
dibuja triÃ¡ngulo en x _ y _ , x _ y _ , x _ y _ color _

filled _
lleno _

write _ on TFT at x _ y _ color _
escribe _ en x _ y _ color _

Hello World!
--MISSING--

scale _ wrap _
escala _ con saltos de lÃ­nea _

####
# BMP library
# Can display BMP image files on a TFT display

display BMP file _ at x _ y _
muestra archivo BMP _ en x _ y _

image.bmp
--MISSING--

####
# HSV color library

HSV Colors
Colores HSV

RGB of hue _ saturation _ brightness _ (0-100)
RGB del tono _ saturaciÃ³n _ brillo _ (0-100)

####
# Fractions library

Fractions
Fracciones

fract _ / _


fract _ + _
frac _ + _

fract _ - _
frac _ - _

fract _ Ã _
frac _ Ã _

fract _ = _
frac _ = _

fract _ < _
frac _ < _

fract _ > _
frac _ > _

simplify fraction _
simplifica fracciÃ³n _

integer part of fraction _
parte entera de fracciÃ³n _

numerator of fraction _
numerador de fracciÃ³n _

denominator of fraction _
denominador de fracciÃ³n _

gcd _ _
mcd de _ y _

lcm _ _
mcm de _ y _

####
# Tone library
# Generates music tones on buzzers

Tone
Tonos

attach buzzer to pin _
inicializa zumbador en el pin _

play note _ octave _ for _ ms
toca la nota _ en la octava _ durante _ ms

play frequency _ for _ ms
toca la frecuencia _ durante _ ms

play midi key _ for _ ms
toca la tecla MIDI _ durante _ ms

start tone _ Hz
toca la frecuencia _ Hz

stop tone
detÃ©n el sonido

c
do

c#
do#

d
re

d#
re#

e
mi

f
fa

f#
fa#

g
sol

g#
sol#

a
la

a#
la#

b
si

####
# Ringtone library
# Can play Nokring-formatted music. Also known as RTTTL.

Ringtone
Politonos

play ringtone _
toca el politono _

current song name
tÃ­tulo de la canciÃ³n actual

####
# Pluck
# Generate music with plucked-string resembling sounds

Pluck
Cuerda taÃ±ida

pluck note _ octave _ for _ ms
taÃ±e la nota _ en la octava _ durante _ ms

pluck MIDI key _ for _ msecs
taÃ±e la nota MIDI _ durante _ ms

set pluck pin _
fija el pin de cuerda taÃ±ida a _

####
# WAV
# Play WAV sound files

play WAV file _
reproduce el archivo WAV _

filename
--MISSING--

####
# Turtle geometry library

Turtle
Tortuga

home
vuelve a casa

move _
muÃ©vete _ pasos

turn _ degrees
gira _ grados

turn _ / _ of circle
gira _ / _ de vuelta

pen down
baja el lÃ¡piz

pen up
sube el lÃ¡piz

set pen color to _
fija el color del lÃ¡piz a _

set pen to random color
fija un color al azar para el lÃ¡piz

fill display with _
llena la pantalla de color _

go to x _ y _
ve a x _ y _

point in direction _
apunta en direcciÃ³n _

####
# File system library

Files
Archivos

open file _
abre archivo _

close file _
cierra archivo _

delete file _
borra archivo _

append line _ to file _
aÃ±ade lÃ­nea _ al archivo _

append bytes _ to file _
aÃ±ade bytes _ al archivo _

end of file _
fin del archivo _

next line of file _
siguiente lÃ­nea del archivo _

next _ bytes of file _
siguientes _ bytes del archivo _

read into _ from file _
--MISSING--

a ByteArray
--MISSING--

starting at _
empezando desde _

file names
nombres de archivos

in directory _
--MISSING--

size of file _
tamaÃ±o del archivo _

file system info
detalles del sistema de archivos

####
# Strings
# string (text) processing functions

Strings
Texto

_ is a digit
_ es un dÃ­gito

_ is lowercase
_ estÃ¡ en minÃºscula

_ is uppercase
_ estÃ¡ en mayÃºscula

_ begins with _
_ empieza por _

prefix
--MISSING--

pre
--MISSING--

_ ends with _
_ acaba en _

suffix
--MISSING--

fix
--MISSING--

_ contains _
_ contiene _

lowercase _
_ en minÃºscula

THIS is a String! :)
--MISSING--

uppercase _
_ en mayÃºscula

Hello, world!
--MISSING--

_ without white space
_ sin espacios en blanco

join string list _ separator _
une la lista de textos _ con separador _

unicodes _
unicodes de _

aString
--MISSING--

string from unicodes _
texto a partir de los unicodes _

aList
--MISSING--

num2str _
nÃºmero _ a texto

str2num _
texto _ a nÃºmero

####
# WiFi library

WiFi
WiFi

wifi connect to _ password _
conÃ©ctate a la wifi _ con contraseÃ±a _

Network_Name
--MISSING--

IP _ gateway _ subnet _
IP _ pasarela _ subred _

wifi create hotspot _ password _
crea punto de acceso wifi _ con contraseÃ±a _

Network_Password
--MISSING--

IP address
direcciÃ³n IP

MAC address
direcciÃ³n MAC

####
# Motion library
# Counts steps and detects motion via the internal accelerometer

Motion
Movimiento

motion
movimiento

start step counter
empieza a contar pasos

step count
recuento de pasos

clear step count
borra recuento de pasos

set step threshold _ (0-50)
fija el umbral del paso en _ (0-50)

####
# Button Events library

Button Events
Eventos de botÃ³n

button _ double pressed
doble pulsaciÃ³n en botÃ³n _

button _ long pressed
pulsaciÃ³n larga en botÃ³n _

button _ pressed
pulsaciÃ³n corta en botÃ³n _

####
# Calliope board library

Calliope set LED red _ green _ blue _
pon el LED de la Calliope a rojo _ verde _ azul _

Calliope set speaker _
pon el altavoz de la Calliope a _

Calliope loudness
nivel de ruido de la Calliope

####
# Circuit Playground Express board library

Circuit Playground set speaker _
pon el altavoz de la Circuit Playground a _

Circuit Playground slide switch
interruptor de la Circuit Playground

####
# DotStar LED library

attach _ DotStar LEDs to data pin _ clock pin _
inicializa tira de _ LEDs DotStar al pin de datos _ y pin de reloj _

set all DotStar LEDs to r _ g _ b _
pon todos los LEDs DotStar a rojo _ verde _ azul _

set DotStar LED _ to r _ g _ b _
pon el LED DotStar _ a rojo _ verde _ azul _

set DotStar brightness _
fija el brillo de DotStar a _

####
# BME280 environmental sensor

bme280 connected
bme280 conectado

bmp280 connected
bmp280 conectado

bmx280 temperature
temperatura del bmx280

bmx280 pressure
presiÃ³n del bmx280

bme280 humidity
humedad del bme280

bmx280 set base altitude _ meters
--MISSING--

bmx280 altitude (cm)
--MISSING--

bmx280 altitude (feet)
--MISSING--

####
# TCS34725 color sensor

TCS34725 connected
TCS34725 conectado

TCS34725 rgb
color RGB del TCS34725

color _ name
nombre del color _

####
# DHT11 environmental sensor

temperature (Celsius) DHT11 pin _
temperatura (ÂºC) del DHT11 en pin _

humidity DHT11 pin _
humedad del DHT11 en pin _

temperature (Celsius) DHT22 pin _
temperatura (ÂºC) del DHT22 en pin _

humidity DHT22 pin _
humedad del DHT22 en pin _

####
# PN532 RFID reader

read PN532 RFID
lee RFID PN532

RFID _ = _
RFID _ = _

get PN532 firmware version
versiÃ³n del firmware del PN532

####
# Touch Screen

Touch Screen
Pantalla tÃ¡ctil

TFT touched
TFT tocada

TFT touch X position
posiciÃ³n X del toque a la TFT

TFT touch Y position
posiciÃ³n Y del toque a la TFT

TFT touch pressure
pressiÃ³n del toque a la TFT

####
# HTTP Client

HTTP client
Cliente HTTP

_ data _ to httpÜ// _
peticiÃ³n _ con contenido _ a httpÜ// _

MicroBlocks is fun
--MISSING--

port _
puerto _

####
# HTTP Server

HTTP server
Servidor HTTP

start HTTP server
inicia el servidor HTTP

HTTP server request
peticiÃ³n HTTP al servidor

respond _ to HTTP request
responde _ a la peticiÃ³n HTTP

with body _
con contenido _

Welcome to the MicroBlocks HTTP server
--MISSING--

and headers _
y cabeceras _

body of request _
cuerpo de la peticiÃ³n _

path of request _
ruta de la peticiÃ³n _

headers of request _
cabeceras de la peticiÃ³n _

method of request _
mÃ©todo de la peticiÃ³n _

content length of request _
tamaÃ±o del contenido de la peticiÃ³n _

####
# WebSocket server

WebSocket server
Servidor de WebSocket

start WebSocket server
inicia el servidor de WebSocket

last WebSocket event
Ãºltimo evento de WebSocket

client ID for WebSocket event _
ID de cliente del evento de WebSocket _

payload for WebSocket event _
carga del evento de WebSocket _

type of WebSocket event _
tipo del evento de WebSocket _

send _ to WebSocket client _
envÃ­a _ al cliente WebSocket _

Hello, Client!
--MISSING--

####
# Web Things library

Web Thing
Web Thing

set thing name to _
fija el nombre de la cosa a _

set thing capability to _
fija la capacidad de la cosa a _

set boolean property _ title _ @Type _
pon a la propiedad booleana _ el tÃ­tulo _ y @Type _

set string property _ title _ @Type _
pon a la propiedad textual _ el tÃ­tulo _ y @Type _

set number property _ title _ @Type _
pon a la propiedad numÃ©rica _ el tÃ­tulo _ y @Type _

set number property _ title _ min _ max _ @Type _
pon a la propiedad numÃ©rica _ el tÃ­tulo _ mÃ­nimo _ mÃ¡ximo _ y @Type _

read only _
sÃ³lo lectura _

register event _ type _
registra el evento _ de tipo _

start WebThing server
inicia el servidor de WebThings

trigger event _
dispara evento _

thing description JSON
JSON de la cosa

properties JSON
JSON de las propiedades

event definitions JSON
JSON de las definiciones de eventos

events JSON
JSON de los eventos

####
# MiKe Robot library

MiKe front obstacle (cm)
MiKe obstÃ¡culo frontal (cm)

MiKe _ obstacle ?
MiKe obstÃ¡culo _ ?

MiKe black line on _ ?
MiKe lÃ­nea negra a la _ ?

MiKe back light
MiKe luz trasera

MiKe IR
MiKe IR

MiKe digital D8 sensor
MiKe sensor digital D8

MiKe stop motors
Mike para motores

MiKe Robot go _ at _ %
MiKe Robot ir _ a _ %

MiKe Robot speed _ %
MiKe Robot velocidad _ %

MiKe Robot direction _
MiKe Robot direcciÃ³n _

MiKe turn _ motor _
MiKe mueve motor _ en _

MiKe speed _ motor at _ %
MiKe velocidad de motor _ a _ %

MiKe front lights off
MiKe apaga luces delanteras

MiKe front lights to _
MiKe luces delanteras a _

MiKe circle lights off
MiKe apaga cÃ­rculo de luces

MiKe circle ligths to _
MiKe cÃ­rculo de luces a _

MiKe circle light _ (1-18) to _
MiKe luz _ del cÃ­rculo(1-18) a _

MiKe rotate lights by _
MiKe gira luces en _

MiKe digital D8 to _
Mike fija actuador D8 a _

####
# DrawBot Library
# A CoreXY plotter library that supports turtle geometry

plotter move X _ Y _
mueve plotter en X _ e Y _

plotter move _ steps
mueve plotter _ pasos

plotter turn _ degrees
rota rumbo del plotter en _ Â°

plotter turn _ / _ of circle
rota rumbo del plotter en _ / _ de vuelta

plotter point in direction _
fija rumbo del plotter a _ Â°

plotter pen down
baja lÃ¡piz del plotter

plotter pen up
sube lÃ¡piz del plotter

plotter stop
detÃ©n plotter

set plotter speed to _ %
fija velocidad del plotter a _ %

####
# Innova Didactic libraries

red
rojo

yellow
amarillo

green
verde

forward
adelante

backward
atrÃ¡s

turn right
gira a la derecha

turn left
gira a la izquierda

stop
detÃ©n

right sensor
sensor derecho

left sensor
sensor izquierdo

both sensors
ambos sensores

TdR test buzzer
TdR prueba el zumbador

TdR set blue LED _
TdR pon el LED azul a _

TdR set red LED _
TdR pon el LED rojo a _

TdR set RGB LED _
TdR pon el LED RGB a _

TdR clear RGB LED
TdR apaga el LED RGB

TdR LM35 temperature ÂºC
--MISSING--

TdR DHT11 temperature ÂºC
--MISSING--

TdR DHT11 humidity
TdR DHT11 humedad

TdR rotation
TdR rotaciÃ³n

TdR light level
TdR nivell de luz

TdR button 1
TdR botÃ³n 1

TdR button 2
TdR botÃ³n 2

TdR receive IR code
TdR cÃ³digo IR recibido

Imagina set _ led to _
Imagina pon el led _ a _

Imagina play _ octave _ for _ ms
Imagina toca la nota _ a la octava _ durante _ ms

Imagina temperature (Â°C)
Imagina temperatura (Â°C)

Imagina light
Imagina luz

Imagina distance (cm)
Imagina distancia (cm)

Imagina button (D2) pressed?
Imagina botÃ³n (D2) pulsado?

Imagina digital reading _
Imagina lectura digital _

Imagina analog reading A1
Imagina lectura analÃ³gica A1

Imagina set digital pin _ to _
Imagina pon el pin digital _ a _

Imagina stop servo _
Imagina detÃ©n el servo _

Imagina set servo _ to _ degrees (-90 to 90)
Imagina posiciona el servo _ a _ grados (-90 to 90)

Imagina set servo _ to speed _ (-100 to 100)
Imagina pon el servo _ a velocidad _ (-100 to 100)

Imagina set _ speed to _ %
Imagina pon la velocidad del _ al _ %

Imagina set _ to _
Imagina movimiento del _ : _

Imagina IR reading
Imagina lectura IR

Imagina IR transmit device _ command _
Imagina IR envÃ­a al dispositivo _ el valor _

_ steps
_ pasos

at _ % speed
al _ % de la velocidad

3dBot set speed at _ %
3dBot pon la velocidad al _ %

3dBot obstacle < _ cm?
3dBot obstaculo < _ cm?

3dBot line on _ ?
3dBot _ en la lÃ­nea?

####
# MQTT

MQTT connect to broker _
conÃ©ctate al broker HTTP _

buffer sizes _ client id _
medida del buffer _ id del cliente _

username _ password _
usuario _ contraseÃ±a _

MQTT connected
MQTT conectado

MQTT disconnect
MQTT desconectado

MQTT sub _
suscrÃ­bete al tema de MQTT _

testTopic
--MISSING--

MQTT unsub _
abandona el tema de MQTT _

MQTT pub topic _ payload _
publica al tema de MQTT _ el contenido _

Hello!
--MISSING--

retain _ QoS _
con retenciÃ³n _ y calidad del servicio _

MQTT event
evento MQTT

binary _
binario _

topic for MQTT event _
tema del evento MQTT

payload for MQTT event _
contenido del evento MQTT

MQTT set will topic _ payload _
--MISSING--

testWill
--MISSING--

Last will!
--MISSING--

buffer sizes _
--MISSING--

####
# UDP

UDP start port _
inicia UDP en el puerto _

UDP stop
detÃ©n UDP

UDP send packet _ to ip _ port _
envÃ­a paquete UDP _ a la IP _ y puerto _

UDP receive packet
recibe paquete UDP

binary data _
datos binarios _

UDP remote IP address
direcciÃ³n IP remota de UDP

UDP remote port
puerto remoto de UDP

####
# WiFi Radio

wifi send number _
--MISSING--

wifi send string _
--MISSING--

wifi send pair _ = _
--MISSING--

wifi message received?
--MISSING--

wifi last number
--MISSING--

wifi last string
--MISSING--

wifi set group _ (0-255)
--MISSING--

####
# Cutebot

Cutebot
Cutebot

Cutebot set wheel left _ right _ (-100 to 100)
Pon la rueda izquierda a _ y la derecha a _ (-100 a 100)

Cutebot stop wheels
DetÃ©n las ruedas

Cutebot set servo _ to _ degrees (-90 to 90)
Pon el servo a _ grados (-90 a 90)

Cutebot set servo _ to speed _ (-100 to 100)
Fija la velocidad del servo _ a _ (-100 a 100)

Cutebot set headlight _ to _
Pon el faro _ a _

Cutebot set NeoPixel _ to _
Pon el NeoPÃ­xel _ del Cutebot a _

Cutebot _ line sensor
Valor del sensor de lÃ­nea _

Cutebot sees line on left _ right _
El Cutebot ve la lÃ­nea a su izquierda _ y su derecha _

Cutebot distance (cm)
Distancia frontal (cm)

left
izquierdo

right
derecho

both
ambos

# Wukong

Wukong
Wukong

Wukong set motor _ to _ (-100 to 100)
Pon el motor _ a _ (-100 a 100)

Wukong stop motor _
DetÃ©n el motor _

Wukong stop all
DetÃ©n todos los motores

Wukong set servo _ to _ degrees (-90 to 90)
Pon el servo _ a _ grados (-90 a 90)

Wukong set servo _ to speed _ (-100 to 100)
Pon el servo _ a velocidad _ (-100 a 100)

Wukong set NeoPixels _ _ _ _
Pon los NeoPÃ­xeles del Wukong a _ _ _ _

Wukong set LED brightness to _
Fija el brillo del LED a _

####
# Sphero-RVR

wake
despierta

sleep
duÃ©rmete

reset the yaw
reinicializa rotaciÃ³n

drive with speed _ and heading _
avanza a velocidad _ y direcciÃ³n _

set raw motors with left mode _ left speed _ right mode _ right speed _
mueve el motor izquierdo _ a velocidad _ y el derecho _ a velocidad _

stop with heading _
detente con direcciÃ³n _

set RGB LED _ to red _ green _ blue _
pon el LED RGB a rojo _ verde _ azul _

set all LEDs to red _ green _ blue _
pon todos los LEDs RGB a rojo _ verde _ azul _

####
# Joystick:bit

button _ is pressed
boton _ pulsado

rocker value of _
inclinaciÃ³n _ de la palanca

motor vibrate for _ ms
haz vibrar el motor durante _ ms

####
# NeZha

NeZha
NeZha

NeZha set motor _ speed to _ %
pon el motor _ a velocidad _ %

NeZha stop motor _
detÃ©n el motor _

NeZha stop all motors
detÃ©n todos los motores

NeZha set _ servo _ angle to _
pon el motor de _ grados nÃºmero _ a Ã¡ngulo _

NeZha set continuous rotation servo _ speed to _ %
pon el servo de rotaciÃ³n contÃ­nua _ a velocidad _ %

####
# WuKong2040

WuKong2040
--MISSING--

WuKong2040 rainbowLED _ color to _
--MISSING--

WuKong2040 rainbowLED _ R _ G _ B _ (0~255)
--MISSING--

WuKong2040 clear all rainbowLED
--MISSING--

WuKong2040 motor _ speed to _ (-100~100)
--MISSING--

WuKong2040 stop motor _
--MISSING--

WuKong2040 stop all motors
--MISSING--

WuKong2040 buzzer beep _ ms
--MISSING--

####
# Octopus

Octopus
--MISSING--

Octopus LED pin _ toggle to _
--MISSING--

Octopus LED pin _ brightness _ %
--MISSING--

Octopus motor fan pin _ speed to _ %
--MISSING--

Octopus 180Â° servo pin _ angle to _ Â° (0~180)
--MISSING--

Octopus sonar trig _ echo _ distance (cm)
--MISSING--

Octopus value of light intensity (Lux) at pin _
--MISSING--

Octopus value of DHT11 temperature (Â°C) at pin _
--MISSING--

Octopus value of DHT11 humidity (0~100) at pin _
--MISSING--

Octopus value of water level (0~40mm) at pin _
--MISSING--

Octopus value of trimpot (0~1023) at pin _
--MISSING--

Octopus value of noise (dB) at pin _
--MISSING--

Octopus OLED show _ at x _ y _
--MISSING--

Octopus OLED clear
--MISSING--

Octopus OLED draw pixel x _ y _
--MISSING--

Octopus OLED draw line from x _ y _ to x _ y _
--MISSING--

Octopus OLED draw rectangle x _ y _ w _ h _ rounding _ (3~15)
--MISSING--

Octopus OLED fill rectangle x _ y _ w _ h _
--MISSING--

Octopus OLED draw circle x _ y _ radius _
--MISSING--

Octopus OLED fill circle x _ y _ radius _
--MISSING--


####
# OctoStudio

Octo start
--MISSING--

Octo beam to phones _
--MISSING--

duration _ ms
--MISSING--

Octo receive beam
--MISSING--

Octo stop
--MISSING--

####
# Shield:bit

sêb LEDs off
sêb apaga los LED

sêb LEDs to _
sêb LEDs a _

sêb LED _ (1-4) to _
sêb LED _ (1-4) a _

sêb audio output to shield _
sêb salida de audio por la shield:bit _

sêb stop _ motors
sêb para los _ motores

sêb turn 180 servo S- _ (1-8) to angle _
sêb gira el servo 180 S- _ (1-8) al Ã¡ngulo _

sêb turn 360 servo S- _ (1-8) _ at _ %
sêb gira el servo 360 S- _ (1-8) _ a _ %

sêb turn DC M- _ (1-4) motor _ at _ %
sêb gira el motor CC M- _ (1-4) _ a _ %

sêb turn Stepper- _ (1-2) motor _ for _ _
sêb gira el motor PaP- _ (1-2) _ per _ _

sêb set pin S- _ (1-8) to _ %
sêb pon el pin S- _ (1-8) a _ %

DC/Steppers
CC/PaP

turns
vueltas

degrees
grados

##################
# MicroBlocks UI #
##################

# buttons, error & info messages, dialog boxes, etc

New
Nuevo

Open
Abre

Open from board
Recupera proyecto de la placa

Copy project URL to clipboard
Copia URL del proyecto al portapapeles

Information
InformaciÃ³n

Plug in the board.
Conecta la placa.

Plug in the board and click the USB icon to connect.
Conecta la placa y haz clic en el icono USB para conectar.

Reading project from board...
Leyendo proyecto de la placa...

Loading project...
Cargando proyecto...

Found a newer version of
Se ha encontrado una nueva versiÃ³n de

Do you want me to update the one in the project?
Â¿Quieres actualizar a esta nueva versiÃ³n en el proyecto?

Save
Guarda

Connect
Conecta

connect
conecta

open Boardie
conÃ©ctate a Boardie

disconnect
desconecta

Serial port:
Puerto serie:

Connect board and try again
Conectar la placa e intetar de nuevo

other...
otro...

none
ninguno

Port name?
Â¿Nombre del puerto?

Board type:
Tipo de placa:

Select board:
Selecciona la placa:

Could not read:
No se ha podido leer:

by
por

Created with GP
Creado con GP

More info at http://microblocks.fun
MÃ¡s informaciÃ³n en http://microblocks.fun

Function "
La funciÃ³n "

" is too large to send to board.
" es demasiado grande para mandarlo a la placa.

Script is too large to send to board.
El programa es demasiado grande para mandarlo a la placa.

Use "Connect" button to connect to a MicroBlocks device.
Utiliza el botÃ³n "Conecta" para conectarte a un dispositivo MicroBlocks.

No boards found; is your board plugged in?
No se ha encontrado ninguna placa; Â¿has conectado tu placa?

For AdaFruit boards, double-click reset button and try again.
En placas AdaFruit, pulsa el botÃ³n de reseteo dos veces rÃ¡pidamente y vuelve a probar.

Only recent Chrome and Edge browsers support WebSerial.
WebSerial solo estÃ¡ suportado por las Ãºltimas versiones de Chrome y Edge.

The board is not responding.
La placa no responde.

Try to Install MicroBlocks on the board?
Â¿Quieres intentar instalar MicroBlocks en la placa?

The MicroBlocks in your board is not current
El MicroBlocks instalado en tu placa no estÃ¡ actualizado

Try to update MicroBlocks on the board?
Â¿Quieres intentar actualizarlo?

MicroBlocks
MicroBlocks

Stop
DetÃ©n

Start
Inicia

Quit MicroBlocks?
Â¿Salir de MicroBlocks?

Discard current project?
Â¿Quieres descartar el proyecto actual?

# Scripting area right-click context menu

set block size...
tamaÃ±o de los bloques...

make blocks bigger or smaller
aumentar o reducir el tamaÃ±o de los bloques

clean up
limpia

arrange scripts
organiza programas

undrop (ctrl-Z)
deshaz el Ãºltimo movimiento (ctrl-Z)

undo the last block drop
extrae el Ãºltimo bloque colocado

copy all scripts to clipboard
copia todos los programas al portapapeles

copy all scripts to clipboard as URL
copia todos los programas al portapapeles como URL

paste all scripts
pega tocos los programas

paste script
pega el programa

paste script from clipboard
pega el programa del portapapeles

save a picture of all visible scripts
guarda una imagen de todos los programas visibles

set exported script scale
fija la escala de la imagen a exportar

small (50%)
pequeÃ±o (50%)

normal (65%)
normal (65%)

large (100%)
grande (100%)

printable (200%)
para impresiÃ³n (200%)

about...
sobre...

About MicroBlocks
Acerca de MicroBlocks

virtual machine version
versiÃ³n de la mÃ¡quina virtual

update firmware on board
actualiza firmware de la placa

show data graph
muestra el grÃ¡fico de datos

set serial delay
ajusta la latencia del puerto serie

firmware version
versiÃ³n del firmware

start WebThing server
inicia el servidor de WebThings

stop WebThing server
detÃ©n el servidor de WebThings

HTTP Server
Servidor HTTP

MicroBlocks HTTP Server listening on port 6473
El servidor HTTP de MicroBlocks estÃ¡ activo en el puerto 6473

disable autoloading board libraries
desactivar autocarga de librerÃ­as de placa

enable autoloading board libraries
activar autocarga de librerÃ­as de placa

enable PlugShare when project empty
activar PlugShare en proyecto en blanco

disable PlugShare when project empty
desactivar PlugShare en proyecto en blanco

hide implementation blocks
ocultar los bloques de implementaciÃ³n

do not show blocks and variables that are internal to libraries (i.e. those whose name begins with underscore)
ocultar los bloques y variables internos de las librerias (aquellos cuyo nombre comienza con guiÃ³n bajo) 

show implementation blocks
mostrar los bloques de implementaciÃ³n

show blocks and variables that are internal to libraries (i.e. those whose name begins with underscore)
mostrar los bloques y variables internos de las librerias (aquellos cuyo nombre comienza con guiÃ³n bajo) 

when plugging a board, do not automatically read its contents into the IDE even if the current project is empty
al conectar una placa, no leas automÃ¡ticamente sus contenidos aunque el proyecto actual estÃ© en blanco

when plugging a board, automatically read its contents into the IDE if the current project is empty
al conectar una placa, lee automÃ¡ticamente sus contenidos si el proyecto actual estÃ¡ en blanco

erase flash and update firmware on ESP board
borra y reparticiona el firmware en placa ESP

install ESP firmware from URL
instalar firmwre ESP desde la URL

Use board type
Â¿La placa conectada es de tipo

Firmware Installed
Firmware instalado

Reconnect to the board by clicking the "Connect" button (USB icon).
ReconÃ©ctate a la placa clicando sobre el botÃ³n de conexiÃ³n (icono USB).

Connect USB cable while holding down the white BOOTSEL button before proceeding.
Antes de continuar, conecta el cable USB mientras mantienes el botÃ³n BOOTSEL pulsado.

You will be asked to save the firmware file.
Se te pedirÃ¡ que guardes el fichero de firmware.

Select
Selecciona

as the destination drive, then click Save.
como unidad de desinaciÃ³n y haz clic en Guarda.

Installing firmware...
Instalando firmware...

Plug in the board.
Conecta la placa.

Board not connected
Placa no conectada

Wiping board...
Borrando placa...

(press ESC to cancel)
(pulsa ESC para cancelar)

Done!
Â¡Hecho!

download and install latest VM
descarga e instala la Ãºltima mÃ¡quina virtual

Select board type:
Selecciona tu placa:

Uploading MicroBlocks to board...
Instalando MicroBlocks en la placa...

copy data to clipboard
copia los datos al portapapeles

clear data
limpia dades

clear memory and variables
limpia memoria y variables

show advanced blocks
muestra los bloques avanzados

export functions as library
exporta funciones como librerÃ­a

hide advanced blocks
oculta los bloques avanzados

put file on board
subir archivo a la placa

get file from board
bajar archivo de la placa

uploaded
subido

downloaded
bajado

Data Graph
GrÃ¡fico de datos

Graph
GrÃ¡fico

clear graph
limpiar grÃ¡fico

zero at bottom
cero abajo

zero in middle
cero en el medio

export data to CSV file
exportar datos a archivo CSV

import data from CSV file
importar datos de archivo CSV

copy graph data to clipboard
copiar datos del grÃ¡fico al portapapeles

show instructions
muestra instrucciones

show compiled bytes
muestra los bytes compilados

expand
expande

collapse
pliega

rename...
renombra...

find variable accessors
busca accesos a la variable

find scripts or block definitions where this variable is being read
busca programas o definiciones de bloque en quÃ© se estÃ© leyendo esta variable

find variable modifiers
busca modificadores de la variable

find scripts or block definitions where this variable is being set or changed
busca programas o definiciones de bloque en quÃ© se estÃ© fijando o modificando el valor de esta variable

find uses of this block
busca usos de este bloque

find scripts or block definitions using this block
busca programas o definiciones de bloque en quÃ© se estÃ© usando este bloque

show block definition...
muestra la definiciÃ³n del bloque...

show the definition of this block
muestra la definiciÃ³n de este bloque

delete block definition...
elimina la definiciÃ³n del bloque...

delete the definition of this block
borra la definiciÃ³n de este bloque

duplicate
duplica

help
ayuda

duplicate this block
duplica este bloc

delete block
elimina bloque

delete this block
elimina este bloque

just this one block
solo este bloque

copy to clipboard
copia al portapapeles

copy to clipboard as URL
copia al portapapeles como URL

copy these blocks to the clipboard as a URL
copia estos bloques al portapapeles como URL

copy these blocks to the clipboard
copia estos bloques al portapapeles

duplicate all
duplica hasta abajo

duplicate these blocks
duplica este bloque y todos los que le siguen

extract block
extrae bloque

pull out this block
agarra este bloque

show help for this block in a browser
muestra ayuda para este bloque en tu navegador

save picture of script
guarda la imagen del programa

save picture of script with result
guarda la imagen del programa con su resultado

save a picture of this block definition as a PNG file
guarda una imagen de la definiciÃ³n de este bloque en formato PNG

save a picture of these blocks as a PNG file
guarda una imagen de estos bloques en formato PNG

save a picture of these blocks and their result as a PNG file
guarda una imagen de estos bloques y su resultado en formato PNG

copy script
copia el programa

delete
elimina

Input type:
Tipo de casilla:

string only
solo texto

string or number
texto o nÃºmero

number only
solo nÃºmero

stop editing
detÃ©n la ediciÃ³n

cut
corta

copy
copia

paste
pega

accept
acepta

revert
revierte

select all
selecciona todo

define
define

number/string
nÃºmero/texto

editable number or string
nÃºmero o texto editable

label
etiqueta

input
casilla

hide block definition
oculta la definiciÃ³n de este bloque

Are you sure you want to remove this block definition?
Â¿Seguro que quieres borrar la definiciÃ³n de este bloque?

Language
Idioma

Custom...
Archivo...

Obsolete
Obsoleto

OK
De acuerdo

Ok
De acuerdo

Yes
SÃ­

No
No

Cancel
Cancela

Okay
De acuerdo

Confirm
ConfirmaciÃ³n

# Library folders

Libraries
LibrerÃ­as

AI
Inteligencia Artificial

Graphics and Displays
GrÃ¡ficos y pantallas

Kits and Boards
Kits y placas

Network
Red

Other
Otro

Robots
Robots

Sensing
Sensores

Sound
Sonido

System
Sistema

# File picker and library dialogs

New library name?
Â¿Nombre de la nueva librerÃ­a?

show all block definitions
muestra las definiciones de todos los bloques

hide all block definitions
oculta las definiciones de todos los bloques

export this library
exporta esta librerÃ­a

delete library
elimina esta librerÃ­a

Examples
Ejemplos

Desktop
Escritorio

Computer
Ordenador

Cloud
Nube

File
Fichero

File Open
Abre fichero

File Save
Guarda fichero

File name:
Nombre del fichero:

New Folder
Nueva carpeta

by
por

Depends:
Depende de:

Tags:
Etiquetas:

Path, name or URL for library?
Â¿Ruta, nombre o URL de la librerÃ­a?

Invalid URL
URL invÃ¡lida

Could not fetch library.
No se pudo obtener la librerÃ­a.

Host does not exist or is currently down.
El servidor no existe o estÃ¡ fuera de servicio.

File not found in server.
No se ha encontrado el archivo en el servidor.

Server expects HTTPS, and MicroBlocks doesn't currently support it.
El servidor requiere HTTPS, y MicroBlocks no lo soporta.

library information
informaciÃ³n de la librerÃ­a

built-in library
librerÃ­a integrada

Dependency path, name or URL?
Â¿Ruta, nombre o URL de la dependencia?

If you are adding a library that's built into MicroBlocks, you can just enter its name.
Si quieres aÃ±adir una librerÃ­a interna de MicroBlocks, simplemente introduce su nombre.

If your library is in the Libraries folder in your local MicroBlocks project folder, you need to prefix it with a slash (/).
Si tu librerÃ­a estÃ¡ en la carpeta "Libraries" de tu carpeta local de MicroBlocks, deberÃ¡s prefijarla con una barra (/).

If the library is hosted online, please input its full URL.
Si la librerÃ­a estÃ¡ hospedada en Internet, introduce su URL completa.

Tag name?
Â¿Nombre de la etiqueta?

user library
librerÃ­a de usuario

Add Library
AÃ±adir librerÃ­a

seconds remaining
segundos restantes

Decrease block size
Reduce el tamaÃ±o de los bloques

Restore block size to 100%
Restaura el tamaÃ±o de los bloques al 100%

Increase block size
Aumenta el tamaÃ±o de los bloques

############
# Tips Bar #
############

Button
BotÃ³n

Boolean Input
Casilla booleana

[l] toggle value, or drop a reporter into it.
[l] conmuta su valor, o arrastra un reportador encima.

Color Input
Casilla de color

[l] change the color, or drop a reporter into it.
[l] canvia su color, o arrastra un reportador encima.

Input
Entrada

[l] edit its value, or drop a reporter into it.
[l] edita su valor, o arrastra un reportador encima.

Block Extension
Flecha de expansiÃ³n

[l] right arrow to show optional inputs, left arrow to hide.
[l] sobre la flecha que apunta hacia la derecha para mostrar casillas adicionales, y sobre la que apunta hacia la izquierda para ocultar-las.

Command Block
Bloque de comando

[l] to run, or drag to build scripts. [r] menu.
[l] para ejecutarlo, o arrÃ¡stralo para construir programas. [r] menÃº.

Hat Block
Bloque de sombrero

[l] to run, or drag to build scripts. [r] menu.
[l] para ejecutarlo, o arrÃ¡stralo para construir programas. [r] menÃº.

Reporter Block
Bloque reportador

[l] to see value, or drop into an input slot. [r] menu.
[l] para consultar su valor, o arrÃ¡stralo sobre una casilla. [r] menÃº.

Script
Programa

[l] to run. [r] menu.
[l] para ejecutarlo. [r] menÃº.

Pane Divider
Divisor de Ã¡rea

Drag to change pane width.
ArrÃ¡stralo para modificar la anchura del Ã¡rea.

Library
LibrerÃ­a

[l] to show the blocks in this library. [r] menu.
[l] para mostrar los bloques de esta librerÃ­a. [r] menÃº.

Block Category
CategorÃ­a de bloques

[l] to show the blocks in this category.
[l] para mostrar los bloques de esta categorÃ­a.

Palette
Paleta

Drag blocks from here to build scripts. Drop scripts here to delete them.
Arrastra bloques des de aquÃ­ hasta la zona de programaciÃ³n para construir programas. Arrastra programas hasta aquÃ­ para eliminarlos.

Scripts Pane
Ãrea de programas

Drag blocks here to build scripts. [r] menu.
Arrastra bloques hasta aquÃ­ para construir programas. [r] menÃº.

#################################
# Block Descriptions for TipBar #
#################################

Turn the user LED on or off.
Enciende o apaga el LED de usuario.

Display a bubble showing the value.
Muestra una burbuja con el valor.

Graph the value.
AÃ±ade el valor al grÃ¡fico.

Report the state of button A ( (-o) or (o-) ).
Reporta el estado del botÃ³n A ( (-o) o (o-) ).

Report the state of button B ( (-o) or (o-) ).
Reporta el estado del botÃ³n B ( (-o) o (o-) ).

Report the milliseconds since the timer was last reset.
Reporta los milisegundos des de la Ãºltima inicializaciÃ³n del temporizador.

Reset the timer.
Reinicializa el temporizador.

Report the milliseconds since power up.
Reporta los milisegundos des de que se encendiÃ³ la placa.

Report the microseconds since power up.
Reporta los microsegundos des de que se encendiÃ³ la placa.

Report the board type.
Reporta el tipo de placa.

Report the electrical logic level on a digital pin ( (-o) or (o-) ).
Reporta el nivel lÃ³gico elÃ©ctrico en un pin digital ( (-o) o (o-) ).

Report a number proportional to the voltage on an analog pin (0 = ground, 1023 = supply voltage).
Reporta un nÃºmero proporcional al voltaje en un pin analÃ³gico (0 = tierra, 1023 = voltaje suministrado).

Turn a pin on or off ( (-o) or (o-) ).
Activa o desactiva un pin digital ( (-o) o (o-) ).

Pulse width modulate (PWM) a pin with the given duty cycle (0 - 1023).
Modula por amplitud de pulsos (PWM) un pin con un ciclo de trabajo determinado (0 - 1023).

Report number of analog pins on this device.
Reporta el nÃºmero de pines analÃ³gicos en este dispositivo.

Report number of digital pins on this device.
Reporta el nÃºmero de pines digitales en este dispositivo.

Report the value of a register (0-255) of an I2C device (0-127).
Reporta el valor de un registro (0-255) de un dispositivo I2C (0-127).

Set an I2C device and register to given value (0-255).
Fija un dispositivy y registro I2C a un valor determinado (0-255).

Receive multiple bytes from an I2C device.
Recibe mÃºltiples bytes de un dispositivo I2C.

Send multiple bytes to an I2C device.
EnvÃ­a mÃºltiples bytes a un dispositivo I2C.

Send a byte (0-255) to an SPI device.
EnvÃ­a un byte (0-255) a un dispositivo SPI.

Read a byte from an SPI device while sending a zero byte. Report the byte received.
Lee un byte de un dispositivo SPI, y envÃ­a un byte cero. Reporta el byte recibido.

Set the SPI clock speed and mode.
Fija la velocidad del reloj y el modo del SPI.

Send a byte array via SPI, replacing its contents with the bytes received.
EnvÃ­a una lista de bytes por SPI, sustituyendo sus contenidos por los bytes recibidos.

Open the serial port at the given baud rate.
Abre el puerto serie a la velocidad en baudios especificada.

Close the serial port.
Cierra el puerto serie.

Report data received from the serial port (a byte array).
Reporta los datos recibidos por el puerto serie (una lista de bytes).

Send a byte array to the serial port.
EnvÃ­a una lista de bytes por el puerto serie.

Run when the board powers up or when the IDE start button is clicked.
Ejecuta cuando la placa se encienda o al hacer click sobre el botÃ³n de inicio.

Run when buttons A, B, or A+B are pressed.
Ejecuta cuando se pulsen los botones A, B, o ambos a la vez.

Repeat the enclosed blocks indefinitely.
Repite la ejecuciÃ³n de los bloques que contiene, contÃ­nuamente.

Repeat the enclosed blocks the given number of times.
Repite la ejecuciÃ³n de los bloques que contiene, el nÃºmero de vece especificado.

Wait the given number of milliseconds.
Espera el nÃºmero de milisegundos especificado.

Run the first set of blocks whose test condition is (-o) .
Ejecuta el primer grupo de bloques para los cuales la condiciÃ³n sea (-o) .

Run when the condition becomes (-o) .
Ejecuta cuando la condiciÃ³n sea (-o) .

Wait until the condition becomes (-o) .
Espera hasta que la condiciÃ³n sea (-o) .

Return (report) the given value from a function or script.
Retorna (reporta) el valor especificado des de una funciÃ³n o programa.

Run when the given message is broadcast.
Ejecuta cuando se emita el mensaje especificado.

Broadcast the given message.
Emite el mensaje especificado.

Do nothing. Used to add notes and documentation.
No hagas nada. Se usa para aÃ±adir notas y documentaciÃ³n.

Repeat the enclosed blocks with the variable set to the current iteration number or item.
Repite la ejecuciÃ³n de los bloques que contiene, fijando la variable al elemento o nÃºmero del intervalo correspondiente a cada iteraciÃ³n.

Repeat the enclosed blocks until the condition becomes (-o) .
Repite la ejecuciÃ³n de los bloques que contiene, hasta que la condiciÃ³n sea (-o) .

Stop this task.
DetÃ©n esta tarea.

Stop all tasks except this one.
DetÃ©n todas las tareas excepto esta.

Wait the given number of microseconds.
Espera el numero de microsegundos especificado.

Report the last broadcast message received.
Reporta el Ãºltimo mensaje emitido y recibido.

Call the function with the given name and optional parameter list.
Ejecuta la funciÃ³n con el nombre especificado con la lista de parÃ¡metros opcional proporcionada.

Call the function with the given name and optional parameter list and report its return value.
Llama la funciÃ³n con el nombre especificado con la lista de parÃ¡metros opcional proporcionada, y reporta su valor de retorno.

Report the sum of the given numbers.
Reporta la suma de los nÃºmeros especificados.

Report the first number minus the second.
Reporta la resta entre el primer y el segundo nÃºmero.

Report the product of the given numbers.
Reporta el producto de los nÃºmeros especificados.

Report the first number divided by the second.
Reporta el resultado de dividir el primer nÃºmero entre el segundo.

Report the remainder of dividing the first number by the second.
Reporta el residuo de dividir el primer nÃºmero entre el segundo.

Report the absolute value of the given number (always >= 0).
Reporta el valor absoluto del nÃºmero especificado (siempre >= 0).

Report the minimum of the values.
Reporta el menor de los valores especificados.

Report the maximum of the values.
Reporta el mayor de los valores especificados.

Report a randomly chosen number in the given range.
Reporta un nÃºmero al azar dentro del rango especificado.

Report (-o) if the first value is less than the second one.
Reporta (-o) si el primer valor es menor que el segundo.

Report (-o) if the first value is less than or equal to the second one.
Reporta (-o) si el primer valor es menor o igual que el segundo.

Report (-o) if the two values are equal.
Reporta (-o) si los dos valores son iguales.

Report (-o) if the two values are not equal.
Reporta (-o) si los dos valores son distintos.

Report (-o) if the first value is greater than or equal to the second one.
Reporta (-o) si el primer valor es mayor o igual que el segundo.

Report (-o) if the first value is greater than the second one.
Reporta (-o) si el primer valor es mayor que el segundo.

Boolean constant ( (-o) or (o-) ).
Constante booleana ( (-o) o (o-) ).

Report the logical inverse of a Boolean ( (-o) or (o-) ) value.
Reporta la inversa de un valor booleano ( (-o) o (o-) ).

Report (-o) if both values are (-o)
Reporta (-o) si ambos valores son (-o).

Report (-o) if either value is (-o)
Reporta (-o) si alguno de los valores es (-o).

Report (-o) if first input is a value of the given data type.
Reporta (-o) si la primera casilla tiene un valor del tipo especificado.

Report the numerical value of a hexadecimal string (range: -0x1FFFFFFF to 0x1FFFFFFF)
Reporta el valor numÃ©rico decimal de una cadena de texto hexadecimal (rango: -0x1FFFFFFF a 0x1FFFFFFF)

Report bitwise AND of two numbers.
Reporta la operaciÃ³n bit a bit "y" (AND) entre dos nÃºmeros.

Report bitwise OR of two numbers.
Reporta la operaciÃ³n bit a bit "o" (OR) entre dos nÃºmeros.

Report bitwise XOR (exclusive OR) of two numbers.
Reporta la operaciÃ³n bit a bit "o exclusiva" (XOR) entre dos nÃºmeros.

Report bitwise inverse of the given number.
Reporta la inversa bit a bit del nÃºmero especificado.

Report the given number shifted left by the given number of bits.
Reporta el nÃºmero especificado desplazado aritmÃ©ticamente hacia la izquierda el nÃºmero de bits especificado.

Report the given number shifted right by the given number of bits (arithmetic shift; sign is maintained).
Reporta el nÃºmero especificado desplazado aritmÃ©ticamente hacia la derecha el nÃºmero de bits especificado.

Set a variable to the given value.
Fija una variable al valor especificado.

Change a variable by the given amount.
Cambia el valor de una variable en la cantidad especificada.

Create a variable local to the containing script with the given initial value.
Crea una variable local al programa que la contenga, y asÃ­gnale el valor inicial especificado.

Report the Nth item of a list, string, or byte array.
Reporta el elemento en la posiciÃ³n especificada de una lista, cadena de texto o lista de bytes.

Report the number of items in a list, string, or byte array.
Reporta el nÃºmero de elementos de una lista, cadena de texto o lista de bytes.

Join (concatenate) the given lists, strings, or byte arrays and report the result.
Reporta la uniÃ³n (concatenaciÃ³n) de las listas, cadenas de texto o listes de bytes especificadas.

Create and report a short list containing the given items. Length limited by available stack space.
Crea y reporta una lista con los elementos especificados. La largada de la lista esta limitada al espacio disponible en la pila.

Add an item to the end of a list.
AÃ±ade un elemento al final de una lista.

Replace the Nth item (or all items) of a list or byte array with the given value.
Sustituye el elemento en la posiciÃ³n especificada (o todos los elementos) de una lista o lista de bytes por el nuevo valor especificado.

Delete the Nth item (or all items) of a list.
Elimina el elemento en la posiciÃ³n especificada (o todos los elementos) de una lista.

Find and report the index of an item in a list or a substring within a string. Report -1 if not found.
Busca y reporta la posiciÃ³n de un elemento en una lista, o una cadena de texto dentro de otra. Reporta -1 si no se encuentra.

Report a copy from the given index through the end (or optional stop index) of the given list, string, or byte array.
Reporta una copia de una lista, cadena de texto o lista de bytes a partir de la posiciÃ³n de inicio especificada y hasta el final (o hasta la posiciÃ³n final opcional especificada).

Split the given string with the given delimiter and report the result (a list of strings).
Retorna la cadena de texto especificada dividida por los delimitadores especificados (una lista de cadenas de texto).

Combine the items of a list into a string, optionally separated by a delimiter (e.g. comma).
Combina los elementos de una lista en una cadena de texto, opcionalmente separados por un delimitador (por ejemplo, una coma).

Report the Unicode value ("code point") of the Nth character of the given string.
Reporta el valor Unicode del carÃ¡cter en la posiciÃ³n especificada de una cadena de texto.

Report a string containing the given Unicode value ("code point") or list of values.
Reporta una cadena de texto formada por el valor o lista de valores Unicode especificados.

Report a new list of the given length filled with zero or the optional value.
Reporta una nueva lista del tamaÃ±o especificado que contenga ceros (o el valor opcional especificado) en todas sus posiciones.

Report a new byte array of the given length filled with zero or the optional value.
Reporta una nueva lista de bytes del tamaÃ±o especificado que contenga ceros (o el valor opcional especificado) en todas sus posiciones.

Report a byte array containing the UTF-8 bytes of the given string.
Reporta una lista de bytes que contenga los bytes UTF-8 de la cadena de texto especificada.

Report the number of words of memory available. Stop button frees up memory.
Reporta el nÃºmero de palabras (grupos de 32 bits, o 4 bytes) de memoria disponibles.


# MicroBlocks translation file
# Last updated: March 14 2023

#########################
# Blocks and categories #
#########################

Output
Sortida

set user LED _
encÃ©n LED integrat _

say _
digues _

graph _
afegeix a la grÃ fica _

Input
Entrada

button A
botÃ³ A

button B
botÃ³ B

timer
cronÃ²metre

reset timer
reinicia el cronÃ²metre

microseconds
microsegons

milliseconds
milÂ·lisegons

board type
tipus de placa

Pins
Pins

read digital pin _
lectura digital _

read analog pin _
lectura analÃ²gica _

pullup _
amb resistÃ¨ncia interna _

set digital pin _ to _
posa el pin digital _ a _

set pin _ to _
posa el pin _ a _

analog pins
pins analÃ²gics

digital pins
pins digitals

Control
Control

when started
en comenÃ§ar

when button _ pressed
quan es premi el botÃ³ _

forever _
per sempre _

repeat _ _
repeteix _ vegades _

wait _ millisecs
espera _ milÂ·lisegons

if _ _
si _ _

if _ _ else _
si _ _ si no _

else if _ _
si no, si _ _

else
si no

when _
quan _

wait until _
espera fins que _

wait _ microsecs
espera _ microsegons

return _
retorna _

when _ received
quan rebi _

go!
endavant!

broadcast _
envia _

comment _
comentari _

How this works...
AixÃ­ funciona...

for _ in _ _
per cada _ en _ _

repeat until _ _
repeteix fins que _ _

stop this task
atura aquesta tasca

stop other tasks
atura les altres tasques

stop all
atura-ho tot

last message
Ãºltim missatge

call _
crida _

function name
nom de la funciÃ³

parameter list
llista de parÃ metres

with _
amb parÃ metre(s) _

Operators
Operadors

_ mod _
_ mÃ²dul _

abs _
valor absolut de _

min _ _
mÃ­nim entre _ i _

max _ _
mÃ xim entre _ i _

random _ to _
nombre a l'atzar entre _ i _

not _
no _

_ and _
_ i _

and _
i _

_ or _
_ o _

or _
o _

_ is a _
_ Ã©s un _

convert _ to _
convertir _ a _

boolean
booleÃ 

number
nombre

string
text

list
llista

byte array
llista de bytes

Advanced:
AvanÃ§at:

rescale _ from ( _ , _ ) to ( _ , _ )
reescala _ de ( _ , _ ) a ( _ , _ )

hex _
hexadecimal _

Variables
Variables

# Buttons on top of "Variables" category

Add a variable
Crea una variable

Delete a variable
Elimina una variable

# New variable dialog

New variable name?
Nom de la variable?

set _ to _
assigna _ a _

change _ by _
augmenta _ en _

initialize local _ to _
inicialitza variable local _ a _

Data
Dades

list
llista

cat
gat

dog
gos

bird
ocell

fish
peix

length of _
llargada de _

item _ of _
element _ de _

replace item _ of list _ with _
canvia l'element _ de la llista _ per _

delete item _ of list _
elimina l'element _ de la llista _

add _ to list _
afegeix _ a la llista _

join _ _
uneix _ _

copy _ from _
copia _ a partir de _

smiles
foca

to _
fins a _

find _ in _
busca _ en _

starting at _
comenÃ§ant des de _

join items of list _
uneix elements de la llista _

separator _
amb separador _

unicode _ of _
unicode _ de _

string from unicode _
carÃ cter amb unicode _

new list length _
nova llista de llargada _

new byte array _
nova llista de bytes de llargada _

as byte array _
llista de bytes a partir de _

aByteListOrString
llistaDeBytesOCadenaDeText

with all _
plena amb _

free memory
memÃ²ria disponible

all
tots

last
Ãºltim

random
qualsevol

split _ by _
divideix _ per _

My Blocks
Els meus blocs

Generic
GenÃ¨ric

# Buttons on top of "My Blocks" category

Add a command block
Crea un bloc comanda

Add a reporter block
Crea un bloc reportador

# Make a block dialog

Enter function name:
Nom de la funciÃ³:

Comm
Comunicacions

i2c get device _ register _
llegeix del dispositiu I2C _ el registre _

i2c set device _ register _ to _
escriu al dispositiu I2C _ el registre _ amb _

i2c device _ read list _
llegeix del dispositiu I2C _ a llista _

i2c device _ write list _
escriu al dispositiu I2C _ el contingut de la llista _

spi send _
envia _ per SPI

spi receive
llegeix SPI

spi setup speed _
fixa la velocitat SPI a _

mode _
mode _

rpi channel _
canal RPI _

spi exchange bytes _
intercanvi a bytes _ per SPI

aByteArray
llistaDeBytes

serial open _ baud
obre port sÃ¨rie a _ bauds

serial close
tanca port sÃ¨rie

serial read
llegeix port sÃ¨rie

serial write _
escriu _ al port sÃ¨rie

serial write _ starting at _
escriu _ al port sÃ¨rie comenÃ§ant per _

aByteStringOrByteArray
cadenaDeTextOLlistaDeBytes

soft serial write byte _ pin _ baud _
escriu byte _ al port sÃ¨rie virtual al pin _ a _ bauds

print _
escriu _

no op
no op

ignore
ignora

##############
# Primitives #
##############

# These are all mostly hidden from end users

draw shape _ at x _ y _
dibuixa forma _ a x _ y _

shape for letter _
forma de la lletra _

send NeoPixel rgb _
envia RGB _ al NeoPÃ­xel

has tone support
tÃ© suport per a tons

play tone pin _ frequency _
toca un to al pin _ de freqÃ¼Ã¨ncia _

has WiFi support
tÃ© suport per a WiFi

start WiFi _ password _
inicia WiFi _ amb contrasenya _

stop WiFi
atura WiFi

WiFi status
estat de la WiFi

my IP address
la meva adreÃ§a IP

radio send number _
envia nombre _ per rÃ dio

radio send string _
envia text _ per rÃ dio

Hello!
Hola!

radio send pair _ = _
envia associaciÃ³ _ = _ per rÃ dio

light
llum

radio message received?
missatge de rÃ dio rebut?

radio last number
Ãºltim nombre rebut per rÃ dio

radio last string
Ãºltim text rebut per rÃ dio

radio last message type
tipus de l'Ãºltim missatge rebut per rÃ dio

radio set group _ (0-255)
fixa el grup de rÃ dio a _ (0-255)

radio set channel (0-83) _
fixa el canal de rÃ dio a (0-83) _

radio set power (0-7) _
fixa potÃ¨ncia de rÃ dio a (0-7) _

radio last signal strength
intensitat de l'Ãºltima senyal de rÃ dio

radio receive packet _
rep paquet per rÃ dio _

radio send packet _
envia paquet per rÃ dio _

disable radio
inhabilita rÃ dio

#############
# Libraries #
#############

Basic Sensors
Sensors bÃ sics

tilt x
inclinaciÃ³ x

tilt y
inclinaciÃ³ y

tilt z
inclinaciÃ³ z

acceleration
acceleraciÃ³

light level
nivell de llum

temperature (Â°C)
temperatura (Â°C)

magnetic field
camp magnÃ¨tic

set acceleration range _ g = 100
fixa l'escala d'acceleraciÃ³ en _ g = 100

####
# NeoPixel library

NeoPixel
NeoPÃ­xels

set NeoPixels _ _ _ _ _ _ _ _ _ _
posa NeoPÃ­xels _ _ _ _ _ _ _ _ _ _

clear NeoPixels
apaga NeoPÃ­xels

set NeoPixel _ color _
posa NeoPÃ­xel _ de color _

set all NeoPixels color _
posa tots els NeoPÃ­xels de color _

rotate NeoPixels by _
rota NeoPÃ­xels en _

brighten NeoPixel _ by _
ilÂ·luminar NeoPÃ­xel _ en _ 

brighten all NeoPixels by _
ilÂ·luminar tots els NeoPÃ­xels en _

color r _ g _ b _ (0-255)
color vermell _ verd _ blau _ (0-255)

random color
color a l'atzar

attach _ LED NeoPixel strip to pin _
inicialitza tira de _ NeoPÃ­xels al pin _

has white _
amb blanc _

PIR
Sensor de presÃ¨ncia

PIR at pin _ detected movement
Moviment detectat pel PIR al pin _

#### NeoPanel library

NeoPanel
NeoPanell

attach NeoPixel panel width _ height _ at pin _
inicialitza panell de NeoPÃ­xels amplada _ alÃ§ada _ al pin _

NeoPanel set x _ y _ color _
pinta pÃ­xel x _ y _ de color _ al NeoPanell

NeoPanel fill column _ color _
pinta columna _ color _ al NeoPanell

NeoPanel fill row _ color _
pinta fila _ color _ al NeoPanell

NeoPanel fill rectangle x _ y _ width _ height _ color _
pinta rectangle a x _ y _ amplada _ alÃ§ada _ color _ al NeoPanell

NeoPanel draw text _ at x _ y _ color _
escriu _ a x _ y _ color _ al NeoPanell

NeoPanel draw BMP file _ at x _ y _
mostra imagen BMP _ x _ y _ al NeoPanell

####
# Microphone library

Microphone
MicrÃ²fon

microphone
micrÃ²fon

turn on microphone
activa el micrÃ²fon

loudness
volum

clap count
recompte d'aplaudiments

set clap threshold _
fixa el llindar d'aplaudiment a _

estimate clap threshold
detecta el llindar d'aplaudiment

####
# Citilab ED1 board libraries

ED1 Stepper Motor
Motors ED1

move motor _ _ steps _
mou motor _ _ passos _

move motor 1 _ and motor 2 _ _ steps
mou motor 1 en _ i motor 2 en _ _ passos

move motor _ angle _ Â°
mou motor _ angle _ Â°

move motor _ _ complete turns
mou motor _ _ voltes completes

stop steppers
atura motors

clockwise
sentit horari

counter-clockwise
sentit antihorari

ED1 Buttons
Botons ED1

button OK
botÃ³ OK

button X
botÃ³ X

button up
botÃ³ amunt

button down
botÃ³ avall

button left
botÃ³ esquerra

button right
botÃ³ dreta

capacitive sensor _
sensor capacitiu _

set capacitive threshold to _
fixa llindar capacitiu a _

####
# BirdBrain Technologies libraries

Hummingbird LED _ _ %
Hummingbird LED _ _ %

Hummingbird Tri-LED _ R _ % G _ % B _ %
Hummingbird Tri-LED _ Vermell _ % Verd _ % Blau _ %

Hummingbird Position Servo _ _ Â°
Hummingbird Servo Posicional _ _ Â°

Hummingbird Rotation Servo _ _ %
Hummingbird Servo Rotacional _ _ %

Hummingbird _ _
Hummingbird _ _

Hummingbird Battery (mV)
Hummingbird Bateria (mV)

Light
Llum

Distance (cm)
DistÃ ncia (cm)

Dial
Rodeta

Sound
So

Other
Altres

Finch Beak Red _ Green _ Blue _
EncÃ©n el bec de color R _ % G _ % B _ %

Finch Tail _ Red _ Green _ Blue _
EncÃ©n la cua de color R _ % G _ % B _ %

Finch Move _ _ cm at _ %
Mou-te cap _ _ cm a velocitat _ %

Finch Turn _ _ Â° at _ %
Gira cap a la _ _ Â° a velocitat _ %

Finch Wheels L _ % R _ %
Posa les rodes a velocitat E _ % D _ %

Finch Stop
Atura el Finch

Finch Distance (cm)
DistÃ ncia (cm)

Finch _ Light
Llum _

Finch _ Line
LÃ­nia _

Finch Reset Encoders
Reinicialitza els comptadors de voltes

Finch _ Encoder
Recompte de voltes _

Finch Accelerometer _
AccelerÃ²metre _

Finch Battery
Nivell de bateria

All
Tots

Forward
Endavant

Backward
Enrere

Right
Dreta

Left
Esquerra

Beak Up
Bec cap amunt

Beak Down
Bec cap avall

Tilt Left
Inclinat a l'esquerra

Tilt Right
Inclinat a la dreta

Level
Pla

Upside Down
Cap per avall

x
x

y
y

z
z

strength
potÃ¨ncia

####
# Ultrasound distance library

distance (cm) trigger _ echo _
distÃ ncia (cm) trigger _ echo _

####
# Infrared remote library

IR Remote
Infraroigs

receive IR code
rep codi IR

receive IR code from device _
rep codi IR del dispositiu _

test IR
prova IR

attach IR receiver to pin _
inicialitza receptor IR al pin _

IR transmit device _ command _
envia al dispositiu IR _ la comanda _

####
# Keyboard and Mouse

Keyboard and Mouse
--MISSING--

press key _ : while holding _
--MISSING--

hold key _
--MISSING--

release key _
--MISSING--

release all keys
--MISSING--

_ mouse click
--MISSING--

move mouse pointer by _ , _
--MISSING--

scroll mouse by _
--MISSING--

hold _ mouse button
--MISSING--

release mouse buttons
--MISSING--

####
# Radio comm library
# Allows micro:bit boards to exchange messages
# All of its blocks are primitive (see "Primitives" section)

Radio
RÃ dio

####
# Text scrolling library
# Scrolls text on 5x5 LED displays and simulated ones

Scrolling
Text animat

scroll text _
anima el text _

HELLO ROSA!
HOLA, ROSA!

scroll number _
anima el nombre _

pausing _ ms
pausant _ ms

stop scrolling
atura l'animaciÃ³

####
# Servo motor library

Servo
Servomotors

set servo _ to _ degrees (-90 to 90)
posa el servo _ a _ graus (-90 a 90)

set servo _ to speed _ (-100 to 100)
fes girar el servo _ a velocitat _ (-100 a 100)

stop servo _
atura servo _

####
# 5x5 LED display library
# Supports the micro:bit display, but also simulated 5x5 displays on boards
# with differently sized LED arrays, NeoPixel arrays or TFT displays

LED Display
Pantalla LED

display _
pantalla _

clear display
neteja pantalla

set display color _
fixa el color de la pantalla a _

plot x _ y _
encÃ©n x _ y _

unplot x _ y _
apaga x _ y _

display character _
mostra carÃ cter _

####
# OLED Graphics library

initialize i2c _ address(hex) _ reset pin# _ flip _
--MISSING--

initialize spi _ d/c pin# _ reset pin# _ flip _
--MISSING--

write _ at x _ y _ inverse _
--MISSING--

show display buffer
--MISSING--

clear
--MISSING--

set contrast (1-4) _
--MISSING--

draw circle at x _ y _ radius _ erase _
--MISSING--

draw image _ at x _ y _
--MISSING--

draw line from x _ y _ to x _ y _ erase _
--MISSING--

draw rectangle x _ y _ w _ h _ erase _ rounding(3-15) _
--MISSING--

fill rectangle x _ y _ w _ h _ erase _
--MISSING--

_flip display top _
--MISSING--

make image _
--MISSING--

set pixel x _ y _ erase _
--MISSING--

set video _
--MISSING--

cursor location
--MISSING--

defer display updates
--MISSING--

####
# TFT display library

enable TFT _
activa TFT _

TFT width
amplada de la pantalla TFT

TFT height
alÃ§ada de la pantalla TFT

set TFT pixel x _ y _ to _
pinta el pÃ­xel x _ y _ de color _

draw line on TFT from x _ y _ to x _ y _ color _
dibuixa lÃ­nia de x _ y _ a x _ y _ color _

draw rectangle on TFT at x _ y _ width _ height _ color _
dibuixa rectangle a x _ y _ amplada _ alÃ§ada _ color _

draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _
dibuixa rectangle arrodonit a x _ y _ amplada _ alÃ§ada _ radi _ color _

draw circle on TFT at x _ y _ radius _ color _
dibuixa cercle a x _ y _ radi _ color _

draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _
dibuixa triangle a x _ y _ , x _ y _ , x _ y _ color _

filled _
ple _

write _ on TFT at x _ y _ color _
escriu _ a x _ y _ color _

Hello World!
Hola, mÃ³n!

scale _ wrap _
escala _ amb salts de lÃ­nia _

####
# BMP library
# Can display BMP image files on a TFT display

display BMP file _ at x _ y _
mostra imatge BMP _ a x _ y _

image.bmp
imatge.bmp

####
# HSV color library

HSV Colors
Colors HSV

RGB of hue _ saturation _ brightness _ (0-100)
RGB amb to _ saturaciÃ³ _ brillantor _ (0-100)

####
# Fractions library

Fractions
Fraccions

fract _ / _
frac _ / _

fract _ + _
frac _ + _

fract _ - _
frac _ - _

fract _ Ã _
frac _ Ã _

fract _ = _
frac _ = _

fract _ < _
frac _ < _

fract _ > _
frac _ > _

simplify fraction _
simplifica fracciÃ³ _

integer part of fraction _
part entera de fracciÃ³ _

numerator of fraction _
numerador de fracciÃ³ _

denominator of fraction _
denominador de fracciÃ³ _

gcd _ _
mcd de _ i _

lcm _ _
mcm de _ i _

####
# Tone library
# Generates music tones on buzzers

Tone
Tons

attach buzzer to pin _
inicialitza brunzidor al pin _

play note _ octave _ for _ ms
toca la nota _ a l'octava _ durant _ ms

play frequency _ for _ ms
toca la freqÃ¼Ã¨ncia _ durant _ ms

play midi key _ for _ ms
toca la tecla MIDI _ durant _ ms

start tone _ Hz
comenÃ§a a tocar la freqÃ¼Ã¨ncia _ Hz

stop tone
atura el so

c
do

c#
do#

d
re

d#
re#

e
mi

f
fa

f#
fa#

g
sol

g#
sol#

a
la

a#
la#

b
si

####
# Ringtone library
# Can play Nokring-formatted music. Also known as RTTTL.

Ringtone
Politons

play ringtone _
toca el politÃ² _

current song name
tÃ­tol de la canÃ§Ã³ actual

####
# Pluck
# Generate music with plucked-string resembling sounds

Pluck
Guitarra

pluck note _ octave _ for _ ms
punteja la nota _ a l'octava _ durant _ ms

pluck MIDI key _ for _ msecs
punteja la nota MIDI _ durant _ ms

set pluck pin _
fixa el pin de puntejat a _

####
# WAV
# Play WAV sound files

play WAV file _
reprodueix arxiu WAV _

filename
nom d'arxiu

####
# Turtle geometry library

Turtle
Tortuga

home
torna a casa

move _
mou-te _ passes

turn _ degrees
gira _ graus

turn _ / _ of circle
gira _ / _ de volta

pen down
abaixa el llapis

pen up
apuja el llapis

set pen color to _
fixa el color del llapis a _

set pen to random color
tria un color a l'atzar per al llapis

fill display with _
omple la pantalla de color _

go to x _ y _
ves a x _ y _

point in direction _
apunta en direcciÃ³ _

####
# File system library

Files
Arxius

open file _
obre l'arxiu _

close file _
tanca l'arxiu _

delete file _
elimina l'arxiu _

append line _ to file _
afegeix lÃ­nia _ a l'arxiu _

append bytes _ to file _
afegeix bytes _ a l'arxiu _

end of file _
final de l'arxiu _

next line of file _
segÃ¼ent lÃ­nia de l'arxiu _

next _ bytes of file _
segÃ¼ents _ bytes de l'arxiu _

read into _ from file _
llegeix a _ des de l'arxiu _

a ByteArray
una LlistaDeBytes

starting at _
comenÃ§ant des de _

file names
noms d'arxius

in directory _
al directori _

size of file _
mida de l'arxiu _

file system info
dades del sistema de fitxers

####
# Strings
# string (text) processing functions

Strings
Text

_ is a digit
_ Ã©s un dÃ­git

_ is lowercase
_ Ã©s en minÃºscules

_ is uppercase
_ Ã©s en majÃºscules

_ begins with _
_ comenÃ§a per _

prefix
prefix

pre
pre

_ ends with _
_ acaba en _

suffix
sufix

fix
fix

_ contains _
_ contÃ© _

lowercase _
_ en minÃºscules

THIS is a String! :)
AIXÃ Ã©s un Text! :)

uppercase _
_ en majÃºscules

Hello, world!
Hola, mÃ³n!

_ without white space
_ sense espais en blanc

join string list _ separator _
uneix llista de texts _ amb separador _

unicodes _
unicodes de _

aString
unText

string from unicodes _
text a partir dels unicodes _

aList
unaLlista

num2str _
nombre _ a text

str2num _
text _ a nombre

####
# WiFi library

WiFi
WiFi

wifi connect to _ password _
connecta't a la wifi _ amb contrasenya _

Network_Name
Nom_De_Xarxa

IP _ gateway _ subnet _
IP _ passarelÂ·la _ subxarxa _

wifi create hotspot _ password _
crea punt d'accÃ©s wifi _ amb contrasenya _

Network_Password
Contrasenya_De_Xarxa

IP address
adreÃ§a IP

MAC address
adreÃ§a MAC

####
# Motion library
# Counts steps and detects motion via the internal accelerometer

Motion
Moviment

motion
moviment

start step counter
comenÃ§a a comptar passes

step count
passes

clear step count
esborra el recompte de passes

set step threshold _ (0-50)
fixa el llindar de les passes a _ (0-50)

####
# Button Events library

Button Events
Esdeveniments de botÃ³

button _ double pressed
doble toc al botÃ³ _

button _ long pressed
toc llarg al botÃ³ _

button _ pressed
toc curt al botÃ³ _

####
# Calliope board library

Calliope set LED red _ green _ blue _
posa el LED de la Calliope a vermell _ verd _ blau _

Calliope set speaker _
posa l'altaveu de la Calliope a _

Calliope loudness
nivell de soroll de la Calliope

####
# Circuit Playground Express board library

Circuit Playground set speaker _
posa l'altaveu de la Circuit Playground a _

Circuit Playground slide switch
interruptor de la Circuit Playground

####
# DotStar LED library

attach _ DotStar LEDs to data pin _ clock pin _
inicialitza tira de _ LEDs DotStar al pin de dades _ i pin de rellotge _

set all DotStar LEDs to r _ g _ b _
posa tots els LEDs DotStar a vermell _ verd _ blau _

set DotStar LED _ to r _ g _ b _
posa el LEDs DotStar _ a vermell _ verd _ blau _

set DotStar brightness _
fixa la brillantor dels DotStar a _

####
# BME280 environmental sensor

bme280 connected
bme280 connectat

bmp280 connected
bmp280 connectat

bmx280 temperature
temperatura del bmx280

bmx280 pressure
pressiÃ³ del bmx280

bme280 humidity
humitat del bme280

bmx280 set base altitude _ meters
--MISSING--

bmx280 altitude (cm)
--MISSING--

bmx280 altitude (feet)
--MISSING--

####
# TCS34725 color sensor

TCS34725 connected
TCS34725 connectat

TCS34725 rgb
color RGB del TCS34725

color _ name
nom del color _

####
# DHT11 environmental sensor

temperature (Celsius) DHT11 pin _
temperatura (Â°C) del DHT11 al pin _

humidity DHT11 pin _
humitat del DHT11 al pin _

temperature (Celsius) DHT22 pin _
temperatura (Â°C) del DHT22 al pin _

humidity DHT22 pin _
humitat del DHT22 al pin _

####
# PN532 RFID reader

read PN532 RFID
llegeix RFID PN532

RFID _ = _
RFID _ = _

get PN532 firmware version
versiÃ³ del firmware del PN532

####
# Touch Screen

Touch Screen
Pantalla tÃ ctil

TFT touched
TFT tocada

TFT touch X position
posiciÃ³ X del toc a la TFT

TFT touch Y position
posiciÃ³ Y del toc a la TFT

TFT touch pressure
pressiÃ³ del toc a la TFT

####
# HTTP Client

HTTP client
Client HTTP

_ data _ to httpÜ// _
--MISSING--

MicroBlocks is fun
MicroBlocks Ã©s divertit

port _
port _

####
# HTTP Server

HTTP server
Servidor HTTP

start HTTP server
inicia el servidor HTTP

HTTP server request
solÂ·licitud HTTP al servidor

respond _ to HTTP request
respon _ a la solÂ·licitud HTTP

with body _
amb contingut _

Welcome to the MicroBlocks HTTP server
Benvinguts al servidor HTTP de MicroBlocks

and headers _
i capÃ§aleres _

body of request _
cos de la solÂ·licitud _

path of request _
camÃ­ de la solÂ·licitud _

headers of request _
capÃ§aleres de la solÂ·licitud _

method of request _
mÃ¨tode de la solÂ·licitud _

content length of request _
mida del contingut de la solÂ·licitud _

####
# WebSocket server

WebSocket server
Servidor de WebSocket

start WebSocket server
inicia el servidor de WebSocket

last WebSocket event
Ãºltim esdeveniment de WebSocket

client ID for WebSocket event _
ID del client de l'esdeveniment de WebSocket _

payload for WebSocket event _
cÃ rrega Ãºtil de l'esdeveniment de WebSocket _

type of WebSocket event _
tipus de l'esdeveniment de WebSocket _

send _ to WebSocket client _
envia _ al client de WebSocket _

Hello, Client!
Hola, client!

####
# Web Things library

Web Thing
Web Thing

set thing name to _
fixa el nom de la cosa a _

set thing capability to _
fixa la capacitat de la cosa a _

set boolean property _ title _ @Type _
posa a la propietat booleana _ el tÃ­tol _ i @Type _

set string property _ title _ @Type _
posa a la propietat textual _ el tÃ­tol _ i @Type _

set number property _ title _ @Type _
posa a la propietat numÃ¨rica _ el tÃ­tol _ i @Type _

set number property _ title _ min _ max _ @Type _
posa a la propietat numÃ¨rica _ el tÃ­tol _ mÃ xim _ mÃ­nim _ i @Type _

read only _
nomÃ©s lectura _

register event _ type _
registra l'esdeveniment _ de tipus _

start WebThing server
inicia el servidor de WebThings

trigger event _
dispara esdeveniment _

thing description JSON
JSON de la cosa

properties JSON
JSON de les propietats

event definitions JSON
JSON de la definiciÃ³ d'esdeveniments

events JSON
JSON dels esdeveniments

####
# MiKe Robot library

MiKe front obstacle (cm)
MiKe obstacle frontal (cm)

MiKe _ obstacle ?
MiKe obstacle a la _ ?

MiKe black line on _ ?
MiKe lÃ­nia negra a la _ ?

MiKe back light
MiKe llum al darrera

MiKe IR
MiKe IR

MiKe digital D8 sensor
MiKe sensor digital D8

MiKe stop motors
Mike atura els motors

MiKe Robot go _ at _ %
MiKe Robot vÃ©s a _ a _ %

MiKe Robot speed _ %
MiKe Robot fixa la velocitat a _ %

MiKe Robot direction _
MiKe Robot fixa la direcciÃ³ a _

MiKe turn _ motor _
MiKe mou el motor _ en _

MiKe speed _ motor at _ %
MiKe fixa la velocitat del motor _ a _ %

MiKe front lights off
MiKe apaga les llums del davant

MiKe front lights to _
MiKe llums del davant a _

MiKe circle lights off
MiKe apaga el cercle de llums

MiKe circle ligths to _
MiKe cercle de llums a _

MiKe circle light _ (1-18) to _
MiKe llum _ del cercle(1-18) a _

MiKe rotate lights by _
MiKe gira les llums en _

MiKe digital D8 to _
Mike fixa l'actuador D8 a _

####
# DrawBot Library
# A CoreXY plotter library that supports turtle geometry

plotter move X _ Y _
mou plotter en X _ i Y _

plotter move _ steps
mou plotter _ passes

plotter turn _ degrees
gira rumb del plotter en _ Â°

plotter turn _ / _ of circle
gira rumb del plotter en _ / _ de volta

plotter point in direction _
fixa rumb del plotter a _ Â°

plotter pen down
abaixa el llapis del plotter

plotter pen up
apuja el llapis del plotter

plotter stop
atura el plotter

set plotter speed to _ %
fixa velocitat del plotter a _ %

####
# Innova Didactic libraries

red
vermell

yellow
groc

green
verd

forward
endavant

backward
enrera

turn right
gira a la dreta

turn left
gira a l'esquerra

stop
atura

right sensor
sensor dret

left sensor
sensor esquerra

both sensors
amdÃ³s sensors

TdR test buzzer
TdR prova el brunzidor

TdR set blue LED _
TdR posa el led blau a _

TdR set red LED _
TdR posa el led vermell a _

TdR set RGB LED _
TdR posa el led RGB a _

TdR clear RGB LED
TdR apaga el led RGB

TdR LM35 temperature ÂºC
--MISSING--

TdR DHT11 temperature ÂºC
--MISSING--

TdR DHT11 humidity
TdR DHT11 humitat

TdR rotation
TdR rotaciÃ³

TdR light level
TdR nivell de llum

TdR button 1
TdR botÃ³ 1

TdR button 2
TdR botÃ³ 2

TdR receive IR code
TdR codi IR rebut

Imagina set _ led to _
Imagina posa el led _ a _

Imagina play _ octave _ for _ ms
Imagina toca la nota _ a l'octava _ durant _ ms

Imagina temperature (Â°C)
Imagina temperatura (Â°C)

Imagina light
Imagina llum

Imagina distance (cm)
Imagina distÃ ncia (cm)

Imagina button (D2) pressed?
Imagina botÃ³ (D2) premut?

Imagina digital reading _
Imagina lectura digital _

Imagina analog reading A1
Imagina lectura analÃ²gica d'A1

Imagina set digital pin _ to _
Imagina posa el pin digital _ a _

Imagina stop servo _
Imagina atura el servo _

Imagina set servo _ to _ degrees (-90 to 90)
Imagina posa el servo _ a _ graus (-90 to 90)

Imagina set servo _ to speed _ (-100 to 100)
Imagina posa el servo _ a la velocitat _ (-100 to 100)

Imagina set _ speed to _ %
Imagina posa la velocitat del _ al _ %

Imagina set _ to _
Imagina moviment del _ : _

Imagina IR reading
Imagina lectura IR

Imagina IR transmit device _ command _
Imagina IR envia al dispositiu _ la comanda _

_ steps
_ passes

at _ % speed
al _ % de la velocitat

3dBot set speed at _ %
3dBot fixa la velocitat a _ %

3dBot obstacle < _ cm?
3dBot obstacle < _ cm?

3dBot line on _ ?
3dBot _ en la lÃ­nia?

####
# MQTT

MQTT connect to broker _
connecta al broker HTTP _

buffer sizes _ client id _
mida del buffer _ id del client _

username _ password _
usuari _ contrasenya _

MQTT connected
MQTT connectat

MQTT disconnect
desconnecta MQTT

MQTT sub _
subscriu-te al tema d'MQTT _

testTopic
temaDeProva

MQTT unsub _
abandona el tema d'MQTT _

MQTT pub topic _ payload _
publica al tema d'MQTT _ el contingut _

Hello!
Hola!

retain _ QoS _
amb retenciÃ³ _ i qualitat del servei _

MQTT event
esdeveniment MQTT

binary _
binari _

topic for MQTT event _
tema de l'esdeveniment MQTT _

payload for MQTT event _
contingut de l'esdeveniment MQTT _

MQTT set will topic _ payload _
--MISSING--

testWill
--MISSING--

Last will!
--MISSING--

buffer sizes _
--MISSING--

####
# UDP

UDP start port _
inicia UDP al port _

UDP stop
atura UDP

UDP send packet _ to ip _ port _
envia paquet UDP _ a la IP _ i port _

UDP receive packet
rep paquet UDP

binary data _
dades binÃ ries _

UDP remote IP address
adreÃ§a IP remota UDP

UDP remote port
port remot UDP

####
# WiFi Radio

wifi send number _
--MISSING--

wifi send string _
--MISSING--

wifi send pair _ = _
--MISSING--

wifi message received?
--MISSING--

wifi last number
--MISSING--

wifi last string
--MISSING--

wifi set group _ (0-255)
--MISSING--

####
# Cutebot

Cutebot
Cutebot

Cutebot set wheel left _ right _ (-100 to 100)
Posa la roda esquerra a _ i la dreta a _ (-100 a 100)

Cutebot stop wheels
Atura les rodes

Cutebot set servo _ to _ degrees (-90 to 90)
Posa el servo _ a _ graus (-90 a 90)

Cutebot set servo _ to speed _ (-100 to 100)
Fixa la velocitat del servo _ a _ (-100 a 100)

Cutebot set headlight _ to _
Posa el far _ a _

Cutebot set NeoPixel _ to _
Posa el NeoPÃ­xel _ del Cutebot a _

Cutebot _ line sensor
Valor del sensor de lÃ­nia _

Cutebot sees line on left _ right _
El Cutebot veu la lÃ­nia a l'esquerra _ i la dreta _

Cutebot distance (cm)
DistÃ ncia frontal (cm)

left
esquerre

right
dret

both
ambdÃ³s

# Wukong

Wukong
Wukong

Wukong set motor _ to _ (-100 to 100)
Posa el motor _ a _ (-100 a 100)

Wukong stop motor _
Atura el motor _

Wukong stop all
Atura tots els motors

Wukong set servo _ to _ degrees (-90 to 90)
Posa el servo _ a _ graus (-90 a 90)

Wukong set servo _ to speed _ (-100 to 100)
Posa el servo _ a velocitat _ (-100 a 100)

Wukong set NeoPixels _ _ _ _
Posa els NeoPÃ­xels del Wukong a _ _ _ _

Wukong set LED brightness to _
Fixa la brillantor del LED a _

####
# Sphero-RVR

wake
desperta't

sleep
dorm

reset the yaw
reinicialitza rotaciÃ³

drive with speed _ and heading _
avanÃ§a a velocitat _ i direcciÃ³ _

set raw motors with left mode _ left speed _ right mode _ right speed _
mou el motor esquerre _ a velocitat _ i el dret _ a velocitat _

stop with heading _
atura't amb direcciÃ³ _

set RGB LED _ to red _ green _ blue _
posa el LED RGB _ a vermell _ verd _ blau _

set all LEDs to red _ green _ blue _
posa tots els LEDs RGB _ a vermell _ verd _ blau _

####
# Joystick:bit

button _ is pressed
botÃ³ _ premut

rocker value of _
inclinaciÃ³ _ de la palanca

motor vibrate for _ ms
fes vibrar el motor durant _ ms

####
# NeZha

NeZha
NeZha

NeZha set motor _ speed to _ %
posa el motor _ a velocitat _ %

NeZha stop motor _
atura el motor _

NeZha stop all motors
atura tots els motors

NeZha set _ servo _ angle to _
posa el motor de _ graus nÃºmero _ a angle _

NeZha set continuous rotation servo _ speed to _ %
posa el servo de rotaciÃ³ contÃ­nua _ a velocitat _ %

####
# WuKong2040

WuKong2040
--MISSING--

WuKong2040 rainbowLED _ color to _
--MISSING--

WuKong2040 rainbowLED _ R _ G _ B _ (0~255)
--MISSING--

WuKong2040 clear all rainbowLED
--MISSING--

WuKong2040 motor _ speed to _ (-100~100)
--MISSING--

WuKong2040 stop motor _
--MISSING--

WuKong2040 stop all motors
--MISSING--

WuKong2040 buzzer beep _ ms
--MISSING--

####
# Octopus

Octopus
--MISSING--

Octopus LED pin _ toggle to _
--MISSING--

Octopus LED pin _ brightness _ %
--MISSING--

Octopus motor fan pin _ speed to _ %
--MISSING--

Octopus 180Â° servo pin _ angle to _ Â° (0~180)
--MISSING--

Octopus sonar trig _ echo _ distance (cm)
--MISSING--

Octopus value of light intensity (Lux) at pin _
--MISSING--

Octopus value of DHT11 temperature (Â°C) at pin _
--MISSING--

Octopus value of DHT11 humidity (0~100) at pin _
--MISSING--

Octopus value of water level (0~40mm) at pin _
--MISSING--

Octopus value of trimpot (0~1023) at pin _
--MISSING--

Octopus value of noise (dB) at pin _
--MISSING--

Octopus OLED show _ at x _ y _
--MISSING--

Octopus OLED clear
--MISSING--

Octopus OLED draw pixel x _ y _
--MISSING--

Octopus OLED draw line from x _ y _ to x _ y _
--MISSING--

Octopus OLED draw rectangle x _ y _ w _ h _ rounding _ (3~15)
--MISSING--

Octopus OLED fill rectangle x _ y _ w _ h _
--MISSING--

Octopus OLED draw circle x _ y _ radius _
--MISSING--

Octopus OLED fill circle x _ y _ radius _
--MISSING--


####
# OctoStudio

Octo start
--MISSING--

Octo beam to phones _
--MISSING--

duration _ ms
--MISSING--

Octo receive beam
--MISSING--

Octo stop
--MISSING--

####
# Shield:bit

sêb LEDs off
sêb apaga els LED

sêb LEDs to _
sêb LEDs a _

sêb LED _ (1-4) to _
sêb LED _ (1-4) a _

sêb audio output to shield _
sêb sortida d'audio per la shield:bit _

sêb stop _ motors
sêb atura els _ motors

sêb turn 180 servo S- _ (1-8) to angle _
sêb gira el servo 180 S- _ (1-8) a l'angle _

sêb turn 360 servo S- _ (1-8) _ at _ %
sêb gira el servo 360 S- _ (1-8) _ a _ %

sêb turn DC M- _ (1-4) motor _ at _ %
sêb gira el motor CC M- _ (1-4) _ a _ %

sêb turn Stepper- _ (1-2) motor _ for _ _
sêb gira el motor PaP- _ (1-2) _ per _ _

sêb set pin S- _ (1-8) to _ %
sêb posa el pin S- _ (1-8) a _ %

DC/Steppers
CC/PasP

turns
voltes

degrees
graus

##################
# MicroBlocks UI #
##################

# buttons, error & info messages, dialog boxes, etc

New
Nou

Open
Obre

Open from board
Recupera projecte de la placa

Copy project URL to clipboard
Copia URL del projecte al porta-retalls

Information
InformaciÃ³

Plug in the board.
Connecta la placa.

Plug in the board and click the USB icon to connect.
Connecta la placa i clica la icona USB per connectar-te.

Reading project from board...
Llegint projecte de la placa...

Loading project...
Carregant projecte...

Found a newer version of
S'ha trobat una nova versiÃ³ de 

Do you want me to update the one in the project?
Vols actualitzar el projecte amb aquesta nova versiÃ³?

Save
Desa

Connect
Connecta

connect
connecta

open Boardie
connecta't al Boardie

disconnect
desconnecta

Serial port:
Port sÃ¨rie:

Connect board and try again
Connecta la placa i prova de nou

other...
un altre...

none
cap

Port name?
Nom del port?

Board type:
Tipus de placa:

Select board:
Selecciona la placa:

Could not read:
No s'ha pogut llegir:

by
per

Created with GP
Creat amb GP

More info at http://microblocks.fun
MÃ©s informaciÃ³ a http://microblocks.fun

Function "
La funciÃ³ "

" is too large to send to board.
" Ã©s massa gran per enviar-se a la placa.

Script is too large to send to board.
El programa Ã©s massa gran per enviar-se a la placa.

Use "Connect" button to connect to a MicroBlocks device.
Utilitza el botÃ³ "Connecta" per connectar-te a un dispositiu MicroBlocks.

No boards found; is your board plugged in?
No s'ha trobat cap placa; has connectat la teva placa?

For AdaFruit boards, double-click reset button and try again.
En plaques AdaFruit, prem el botÃ³ de reinici dues vegades rÃ pidament i torna-ho a provar.

Only recent Chrome and Edge browsers support WebSerial.
WebSerial nomÃ©s estÃ  suportat per les Ãºltimes versions de Chrome i Edge.

The board is not responding.
La placa no respon.

Try to Install MicroBlocks on the board?
Vols provar d'instalÂ·lar-hi MicroBlocks?

The MicroBlocks in your board is not current
El MicroBlocks instalÂ·lat a la teva placa no estÃ  actualitzat

Try to update MicroBlocks on the board?
Vols provar d'actualitzar-lo?

MicroBlocks
MicroBlocks

Stop
Atura

Start
Inicia

Quit MicroBlocks?
Sortir de MicroBlocks?

Discard current project?
Vols descartar el projecte actual?

# Scripting area right-click context menu

set block size...
mida dels blocs...

make blocks bigger or smaller
augmenta o redueix la mida dels blocs

clean up
neteja

arrange scripts
organitza programes

undrop (ctrl-Z)
desfes l'Ãºltim moviment (ctrl-Z)

undo the last block drop
extreu l'Ãºltim bloc colÂ·locat

copy all scripts to clipboard
copia tots els programes al porta-retalls

copy all scripts to clipboard as URL
copia tots els programes al porta-retalls com a URL

paste all scripts
enganxa tots els programes

paste script
enganxa el programa

paste script from clipboard
enganxa el programa del porta-retalls

save a picture of all visible scripts
desa una imatge de tots els programes visibles

set exported script scale
fixa l'escala de la imatge a exportar

small (50%)
petita (50%)

normal (65%)
normal (65%)

large (100%)
gran (100%)

printable (200%)
per a impressiÃ³ (200%)

about...
sobre...

About MicroBlocks
Sobre MicroBlocks

virtual machine version
versiÃ³ de la mÃ quina virtual

update firmware on board
actualitza firmware a la placa

show data graph
mostra la grÃ fica de dades

set serial delay
ajusta la latÃ¨ncia del port sÃ¨rie

firmware version
versiÃ³ del firmware

start WebThing server
inicia el servidor de WebThings

stop WebThing server
atura el servidor de WebThings

HTTP Server
Servidor HTTP

MicroBlocks HTTP Server listening on port 6473
El servidor HTTP de MicroBlocks estÃ  actiu al port 6473

disable autoloading board libraries
no carreguis llibreries de placa automÃ ticament

enable autoloading board libraries
carrega llibreries de placa automÃ ticament

enable PlugShare when project empty
activa PlugShare en projectes en blanc

disable PlugShare when project empty
desactiva PlugShare en projectes en blanc

hide implementation blocks
amaga els blocs d'implementaciÃ³

do not show blocks and variables that are internal to libraries (i.e. those whose name begins with underscore)
no mostris blocs i variables que siguin interns a les llibreries (aquells que el seu nom comenÃ§a amb guiÃ³ baix)


show implementation blocks
mostra els blocs d'implementaciÃ³

show blocks and variables that are internal to libraries (i.e. those whose name begins with underscore)
mostra els blocs i variables que siguin interns a les llibreries (aquells que el nom comenÃ§a amb guiÃ³ baix)

when plugging a board, do not automatically read its contents into the IDE even if the current project is empty
en connectar una placa, no en llegeixis els continguts automÃ ticament encara que el projecte actual estigui en blanc

when plugging a board, automatically read its contents into the IDE if the current project is empty
en connectar una placa, llegeix-ne els continguts automÃ ticament si el projecte actual estÃ  en blanc

erase flash and update firmware on ESP board
esborra i reparticiona el firmware en placa ESP

install ESP firmware from URL
instalÂ·lar firmware ESP des de l'URL 

Use board type
La placa connectada Ã©s de tipus

Firmware Installed
Firmware instalÂ·lat

Reconnect to the board by clicking the "Connect" button (USB icon).
Torna a connectar-te a la placa clicant el botÃ³ de connexiÃ³ (icona USB).

Connect USB cable while holding down the white BOOTSEL button before proceeding.
Abans de continuar, connecta el cable USB mentre prems el botÃ³ blanc "BOOTSEL".

You will be asked to save the firmware file.
Se't demenarÃ  que desis l'arxiu de firmware.

Select
Selecciona

as the destination drive, then click Save.
com a unitat de destinaciÃ³ i clica Desa.

Installing firmware...
InstalÂ·lant firmware...

Plug in the board.
Connecta la placa.

Board not connected
Placa no connectada

Wiping board...
Esborrant placa...

(press ESC to cancel)
(prem ESC per cancelÂ·lar)

Done!
Fet!

download and install latest VM
descarrega i instalÂ·la l'Ãºltima mÃ quina virtual

Select board type:
Selecciona la teva placa:

Uploading MicroBlocks to board...
InstalÂ·lant MicroBlocks a la placa...

copy data to clipboard
copia les dades al porta-retalls

clear data
neteja dades

clear memory and variables
neteja memÃ²ria i variables

show advanced blocks
mostra els blocs avanÃ§ats

export functions as library
exporta funcions com a llibreria

hide advanced blocks
amaga els blocs avanÃ§ats

put file on board
carrega arxiu a la placa

get file from board
descarrega arxiu de la placa

uploaded
carregat

downloaded
descarregat

Data Graph
GrÃ fica de dades

Graph
GrÃ fica

clear graph
neteja grÃ fica

zero at bottom
zero a baix

zero in middle
zero al mig

export data to CSV file
exporta dades a arxiu CSV

import data from CSV file
importa dades d'arxiu CSV

copy graph data to clipboard
copia dades de la grÃ fica al porta-retalls

show instructions
mostra instruccions

show compiled bytes
mostra els bytes compilats

expand
expandeix

collapse
replega

rename...
reanomena...

find variable accessors
cerca accessos a la variable

find scripts or block definitions where this variable is being read
cerca programes o definicions de blocs on s'estigui llegint aquesta variable

find variable modifiers
cerca modificadors de la variable

find scripts or block definitions where this variable is being set or changed
cerca programes o definicions de blocs on s'estigui fixant o modificant el valor d'aquesta variable

find uses of this block
cerca usos d'aquest bloc

find scripts or block definitions using this block
cerca programes o definicions de blocs on s'estigui utilitzant aquest bloc

show block definition...
mostra la definiciÃ³ del bloc...

show the definition of this block
mostra la definiciÃ³ d'aquest bloc

delete block definition...
elimina la definiciÃ³ del bloc...

delete the definition of this block
esborra la definiciÃ³ d'aquest bloc

duplicate
duplica

help
ajuda

duplicate this block
duplica aquest bloc

delete block
elimina bloc

delete this block
elimina aquest bloc

just this one block
nomÃ©s aquest bloc

copy to clipboard
copia al porta-retalls

copy to clipboard as URL
copia al porta-retalls com a URL

copy these blocks to the clipboard as a URL
copia aquests blocs al porta-retalls com a URL

copy these blocks to the clipboard
copia aquests blocs al porta-retalls

duplicate all
duplica fins a baix

duplicate these blocks
duplica aquest bloc i tots els que el segueixen

extract block
extrau bloc

pull out this block
agafa aquest bloc

show help for this block in a browser
mostra ajuda per a aquest bloc al teu navegador

save picture of script
desa la imatge del programa

save picture of script with result
desa la imatge del programa amb el resultat

save a picture of this block definition as a PNG file
desa una imatge de la definiciÃ³ d'aquest bloc en format PNG

save a picture of these blocks as a PNG file
desa una imatge d'aquests blocs en format PNG

save a picture of these blocks and their result as a PNG file
desa una imatge d'aquests blocs i el seu resultat en format PNG

copy script
copia el programa

delete
elimina

Input type:
Tipus de casella:

string only
nomÃ©s text

string or number
text o nombre

number only
nomÃ©s nombre

stop editing
deixa d'editar

cut
retalla

copy
copia

paste
enganxa

accept
accepta

revert
reverteix

select all
selecciona-ho tot

define
defineix

number/string
nombre/text

editable number or string
nombre o text editable

label
etiqueta

input
casella

hide block definition
amaga la definiciÃ³ d'aquest bloc

Are you sure you want to remove this block definition?
Segur que vols esborrar la definiciÃ³ d'aquest bloc?

Language
Idioma

Custom...
Arxiu...

Obsolete
Obsolet

OK
D'acord

Ok
D'acord

Yes
SÃ­

No
No

Cancel
CancelÂ·la

Okay
D'acord

Confirm
ConfirmaciÃ³

# Library folders

Libraries
Llibreries

AI
IntelÂ·ligÃ¨ncia artificial

Graphics and Displays
GrÃ fics i pantalles

Kits and Boards
Kits i plaques

Network
Xarxa

Other
Altres

Robots
Robots

Sensing
Sensors

Sound
So

System
Sistema

# File picker and library dialogs

New library name?
Nom de la nova llibreria?

show all block definitions
mostra les definicions de tots els blocs

hide all block definitions
amaga les definicions de tots els blocs

export this library
exporta aquesta llibreria

delete library
elimina aquesta llibreria

Examples
Exemples

Desktop
Escriptori

Computer
Ordinador

Cloud
NÃºvol

File
Arxiu

File Open
Obre arxiu

File Save
Desa arxiu

File name:
Nom d'arxiu:

New Folder
Nou directori

by
per

Depends:
DepÃ¨n de:

Tags:
Etiquetes:

Path, name or URL for library?
CamÃ­, nom o URL de la llibreria?

Invalid URL
URL invÃ lida

Could not fetch library.
No s'ha pogut obtenir la llibreria.

Host does not exist or is currently down.
El servidor no existeix, o estÃ  fora de servei.

File not found in server.
No s'ha trobat l'arxiu al servidor.

Server expects HTTPS, and MicroBlocks doesn't currently support it.
El servidor requereix HTTPS, perÃ² MicroBlocks no en suporta.

library information
informaciÃ³ de la llibreria

built-in library
llibreria integrada

Dependency path, name or URL?
CamÃ­, nom o URL de la dependÃ¨ncia?

If you are adding a library that's built into MicroBlocks, you can just enter its name.
Si vols afegir una llibreria interna de MicroBlocks, nomÃ©s cal que n'escriguis el nom.

If your library is in the Libraries folder in your local MicroBlocks project folder, you need to prefix it with a slash (/).
Si la teva llibreria estÃ  al directori "Libraries" del teu directori local de projectes de MicroBlocks, l'has de prefixar amb una barra (/).

If the library is hosted online, please input its full URL.
Si la llibreria estÃ  hostatjada a Internet, introdueix la seva URL completa.

Tag name?
Nom de l'etiqueta?

user library
llibreria d'usuari

Add Library
Afegir llibreria

seconds remaining
segons restants

Decrease block size
Redueix mida dels blocs

Restore block size to 100%
Restaura mida dels blocs al 100%

Increase block size
Augmenta mida dels blocs

############
# Tips Bar #
############

Button
BotÃ³

Boolean Input
Casella booleana

[l] toggle value, or drop a reporter into it.
[l] commuta'n el valor, o deixa-hi caure un reportador.

Color Input
Casella de color

[l] change the color, or drop a reporter into it.
[l] canvia'n el color, o deixa-hi caure un reportador.

Input
Entrada

[l] edit its value, or drop a reporter into it.
[l] edita'n el valor, o deixa-hi caure un reportador.

Block Extension
Fletxa d'ampliaciÃ³

[l] right arrow to show optional inputs, left arrow to hide.
[l] sobre la fletxa que apunta a la dreta per mostrar caselles opcionals, i sobre la que apunta a l'esquerra per amagar-les.

Command Block
Bloc comanda

[l] to run, or drag to build scripts. [r] menu.
[l] per execuitar-lo, o arrosega'l per construir programes. [r] menÃº.

Hat Block
Bloc de barret

[l] to run, or drag to build scripts. [r] menu.
[l] per execuitar-lo, o arrosega'l per construir programes. [r] menÃº.

Reporter Block
Bloc reportador

[l] to see value, or drop into an input slot. [r] menu.
[l] per consultar-ne el valor, o deixa'l caure dins d'una casella. [r] menÃº.

Script
Programa

[l] to run. [r] menu.
[l] per executar-lo. [r] menÃº.

Pane Divider
Divisor d'Ã rea

Drag to change pane width.
Arrossega'l per canviar l'amplada de l'Ã rea.

Library
Llibreria

[l] to show the blocks in this library. [r] menu.
[l] per mostrar els blocs d'aquesta llibreria. [r] menÃº.

Block Category
Categoria de blocs

[l] to show the blocks in this category.
[l] per mostrar els blocs d'aquesta categoria.

Palette
Paleta

Drag blocks from here to build scripts. Drop scripts here to delete them.
Arrossega blocs des d'aquÃ­ fins a la zona de programaciÃ³ per construir programes. Deixa-hi caure programes per eliminar-los.

Scripts Pane
Ãrea de programes

Drag blocks here to build scripts. [r] menu.
ColÂ·loca-hi blocs per construir programes. [r] menÃº.

#################################
# Block Descriptions for TipBar #
#################################

Turn the user LED on or off.
EncÃ©n o apaga del LED d'usuari.

Display a bubble showing the value.
Mostra una bafarada amb el valor.

Graph the value.
Afegeix el valor a la grÃ fica.

Report the state of button A ( (-o) or (o-) ).
Reporta l'estat del botÃ³ A ( (-o) o (o-) ).

Report the state of button B ( (-o) or (o-) ).
Reporta l'estat del botÃ³ B ( (-o) o (o-) ).

Report the milliseconds since the timer was last reset.
Reporta els milÂ·lisegons des de l'Ãºltima inicialitzaciÃ³ del temporitzador.

Reset the timer.
Inicialitza el temporitzador.

Report the milliseconds since power up.
Reporta els milÂ·lisegons des que la placa s'ha engegat.

Report the microseconds since power up.
Reporta els microsegons des que la placa s'ha engegat.

Report the board type.
Reporta el tipus de placa.

Report the electrical logic level on a digital pin ( (-o) or (o-) ).
Reporta el nivell lÃ²gic elÃ¨ctric en un pin digital ( (-o) o (o-) ).

Report a number proportional to the voltage on an analog pin (0 = ground, 1023 = supply voltage).
Reporta un nombre proporcional al voltatge en un pin analÃ²gic (0 = terra, 1023 = voltatge subministrat).

Turn a pin on or off ( (-o) or (o-) ).
Activa o desactiva un pin digital ( (-o) o (o-) ).

Pulse width modulate (PWM) a pin with the given duty cycle (0 - 1023).
Modula per amplada de polsos (PWM) un pin amb un cicle de treball determinat (0 - 1023).

Report number of analog pins on this device.
Reporta el nÃºmero de pins analÃ²gics en aquest dispositiu.

Report number of digital pins on this device.
Reporta el nÃºmero de pins digitals en aquest dispositiu.

Report the value of a register (0-255) of an I2C device (0-127).
Reporta el valor d'un registre (0-255) d'un dispositiu I2C (0-127).

Set an I2C device and register to given value (0-255).
Fixa un dispositiu i registre I2C a un valor determinat (0-255).

Receive multiple bytes from an I2C device.
Rep mÃºltiples bytes d'un dispositiu I2C.

Send multiple bytes to an I2C device.
Envia mÃºltiples bytes a un dispositiu I2C.

Send a byte (0-255) to an SPI device.
Envia un byte (0-255) a un dispositiu SPI.

Read a byte from an SPI device while sending a zero byte. Report the byte received.
Llegeix un byte d'un dispositiu SPI, i envia un byte zero. Reporta el byte rebut.

Set the SPI clock speed and mode.
Fixa la velocitat del rellotge i el mode de l'SPI.

Send a byte array via SPI, replacing its contents with the bytes received.
Envia una llista de bytes per SPI, substituint els seus continguts pels bytes rebuts.

Open the serial port at the given baud rate.
Obre el port sÃ¨rie a la velocitat en bauds especificada.

Close the serial port.
Tanca el port sÃ¨rie.

Report data received from the serial port (a byte array).
Reporta les dades rebudes pel port sÃ¨rie (una llista de bytes).

Send a byte array to the serial port.
Envia una llista de bytes pel port sÃ¨rie.

Run when the board powers up or when the IDE start button is clicked.
Executa quan la placa s'engegui o en clicar al botÃ³ d'inici de l'editor.

Run when buttons A, B, or A+B are pressed.
Executa quan es premin els botons A, B, o tots dos alhora.

Repeat the enclosed blocks indefinitely.
Repeteix l'execuciÃ³ dels blocs que contÃ©, contÃ­nuament.

Repeat the enclosed blocks the given number of times.
Repeteix l'execuciÃ³ dels blocs que contÃ©, el nombre de vegades especificat.

Wait the given number of milliseconds.
Espera el nombre de milÂ·lisegons especificat.

Run the first set of blocks whose test condition is (-o) .
Executa el primer grup de blocs pels quals la condiciÃ³ sigui (-o) .

Run when the condition becomes (-o) .
Executa quan la condiciÃ³ esdevingui (-o) .

Wait until the condition becomes (-o) .
Espera fins que la condiciÃ³ sigui (-o) .

Return (report) the given value from a function or script.
Retorna (reporta) el valor especificat des d'una funciÃ³ o programa.

Run when the given message is broadcast.
Executa quan s'emeti el missatge especificat.

Broadcast the given message.
Emet el missatge especificat.

Do nothing. Used to add notes and documentation.
No fa res. S'utilitza per afegir notes i documentaciÃ³.

Repeat the enclosed blocks with the variable set to the current iteration number or item.
Repeteix l'execuciÃ³ dels blocs que contÃ©, fixant la variable a l'element o nÃºmero de l'interval corresponent en cada iteraciÃ³.

Repeat the enclosed blocks until the condition becomes (-o) .
Repeteix l'execuciÃ³ dels blocs que contÃ©, fins que la condiciÃ³ esdevingui (-o) .

Stop this task.
Atura aquesta tasca.

Stop all tasks except this one.
Atura totes les tasques excepte aquesta.

Wait the given number of microseconds.
Espera el nombre de microsegons especificat.

Report the last broadcast message received.
Reporta l'Ãºltim missatge emÃ¨s i rebut.

Call the function with the given name and optional parameter list.
Executa la funciÃ³ amb el nom especificat amb la llista de parÃ metres opcional proporcionada.

Call the function with the given name and optional parameter list and report its return value.
Crida la funciÃ³ amb el nom especificat amb la llista de parÃ metres opcional proporcionada, i reporta'n el valor de retorn.

Report the sum of the given numbers.
Reporta la suma dels nombres especificats.

Report the first number minus the second.
Reporta la resta entre el primer i el segon nombre.

Report the product of the given numbers.
Reporta el producte dels nÃºmeros especificats.

Report the first number divided by the second.
Reporta el resultat de dividir el primer nombre entre el segon.

Report the remainder of dividing the first number by the second.
Reporta el residu de dividir el primer nombre entre el segon.

Report the absolute value of the given number (always >= 0).
Reporta el valor absolut del nombre especificat (sempre >= 0).

Report the minimum of the values.
Reporta el mÃ©s petit dels valors especificats.

Report the maximum of the values.
Reporta el mÃ©s gran dels valors especificats.

Report a randomly chosen number in the given range.
Reporta un nombre a l'atzar dins el rang especificat.

Report (-o) if the first value is less than the second one.
Reporta (-o) si el primer valor Ã©s menor que el segon.

Report (-o) if the first value is less than or equal to the second one.
Reporta (-o) si el primer valor Ã©s menor o igual que el segon.

Report (-o) if the two values are equal.
Reporta (-o) si els dos valors sÃ³n iguals.

Report (-o) if the two values are not equal.
Reporta (-o) si els dos valors sÃ³n diferents.

Report (-o) if the first value is greater than or equal to the second one.
Reporta (-o) si el primer valor Ã©s major o igual que el segon.

Report (-o) if the first value is greater than the second one.
Reporta (-o) si el primer valor Ã©s major que el segon.

Boolean constant ( (-o) or (o-) ).
Constant booleana ( (-o) o (o-) ).

Report the logical inverse of a Boolean ( (-o) or (o-) ) value.
Reporta la inversa d'un valor booleÃ  ( (-o) o (o-) ).

Report (-o) if both values are (-o)
Reporta (-o) si els dos valors sÃ³n (-o).

Report (-o) if either value is (-o)
Reporta (-o) si algun dels dos valors Ã©s (-o).

Report (-o) if first input is a value of the given data type.
Reporta (-o) si la primera casella tÃ© un valor del tipus especificat.

Report the numerical value of a hexadecimal string (range: -0x1FFFFFFF to 0x1FFFFFFF)
Retorna el valor numÃ¨ric decimal d'una cadena de text hexadecimal (rang: -0x1FFFFFFF a 0x1FFFFFFF)

Report bitwise AND of two numbers.
Reporta l'operaciÃ³ bit a bit "i" (AND) entre dos nombres.

Report bitwise OR of two numbers.
Reporta l'operaciÃ³ bit a bit "o inclusiva" (OR) entre dos nombres.

Report bitwise XOR (exclusive OR) of two numbers.
Reporta l'operaciÃ³ bit a bit "o exclusiva" (XOR) entre dos nombres.

Report bitwise inverse of the given number.
Reporta l'inversa bit a bit del nombre especificat.

Report the given number shifted left by the given number of bits.
Reporta el nombre especificat desplaÃ§at aritmÃ¨ticament cap a l'esquerra el nombre de bits especificat.

Report the given number shifted right by the given number of bits (arithmetic shift; sign is maintained).
Reporta el nombre especificat desplaÃ§at aritmÃ¨ticament cap a la dreta el nombre de bits especificat.

Set a variable to the given value.
Posa el valor especificat a una variable.

Change a variable by the given amount.
Canvia el valor d'una variable en la quantitat especificada.

Create a variable local to the containing script with the given initial value.
Crea una variable local al programa que la contingui i assigna-li un valor inicial.

Report the Nth item of a list, string, or byte array.
Reporta l'element en la posiciÃ³ especificada d'una llista, cadena de text o llista de bytes.

Report the number of items in a list, string, or byte array.
Reporta el nombre d'elements d'una llista, cadena de text o llista de bytes.

Join (concatenate) the given lists, strings, or byte arrays and report the result.
Reporta la uniÃ³ (concatenaciÃ³) de les llistes, cadenes de text o llistes de bytes especificades.

Create and report a short list containing the given items. Length limited by available stack space.
Crea i reporta una llista amb els elements especificats. La llargada de la llista estÃ  limitada a l'espai disponible a la pila.

Add an item to the end of a list.
Afegeix un element al final d'una llista.

Replace the Nth item (or all items) of a list or byte array with the given value.
Substitueix l'element en la posiciÃ³ especificada (o tots els elements) d'una llista o llista de bytes pel nou valor especificat.

Delete the Nth item (or all items) of a list.
Elimina l'element en la posiciÃ³ especificada (o tots els elements) d'una llista.

Find and report the index of an item in a list or a substring within a string. Report -1 if not found.
Cerca i reporta la posiciÃ³ d'un element en una llista, o una cadena de text dins d'una altra. Reporta -1 si no s'hi troba.

Report a copy from the given index through the end (or optional stop index) of the given list, string, or byte array.
Reporta una cÃ²pia d'una llista, cadena de text o llista de bytes a partir de la posiciÃ³ d'inici especificada i fins al final (o fins la posiciÃ³ final opcional especificada).

Split the given string with the given delimiter and report the result (a list of strings).
Retorna la cadena de text especificada dividida pels delimitadors especificats (una llista de cadenes de text).

Combine the items of a list into a string, optionally separated by a delimiter (e.g. comma).
Combina els elements d'una llista en una cadena de text, opcionalment separats per un delimitador (com ara una coma).

Report the Unicode value ("code point") of the Nth character of the given string.
Reporta el valor Unicode del carÃ cter en la posiciÃ³ especificada d'una cadena de text.

Report a string containing the given Unicode value ("code point") or list of values.
Reporta una cadena de text formada pel valor o llista de valors Unicode especificats.

Report a new list of the given length filled with zero or the optional value.
Reporta una nova llista de la mida especificada que contingui zeros (o el valor opcional especificat) en totes les seves posicions.

Report a new byte array of the given length filled with zero or the optional value.
Reporta una nova llista de bytes de la llargada especificada que contingui zeros (o el valor opcional especificat) en totes les seves posicions.

Report a byte array containing the UTF-8 bytes of the given string.
Reporta una llista de bytes que contingui els bytes UTF-8 de la cadena de text especificada.

Report the number of words of memory available. Stop button frees up memory.
Reporta el nÃºmero de paraules (grups de 32 bits, o 4 bytes) de memÃ²ria disponibles.

# MicroBlocks translation file
# Last updated: July 07 2020

#########################
# Blocks and categories #
#########################

Output
Ausgabe

set user LED _
setze Nutzer-LED _

say _
sage _

graph _
Diagramm _

Input
Eingabe

button A
Knopf A

button B
Knopf B

timer
Stoppuhr

reset timer
Stoppuhr zurÃ¼cksetzen

microseconds
Mikrosekunden

milliseconds
Millisekunden

board type
Board-Typ

Pins
Pins

read digital pin _
lies digitalen Pin _

read analog pin _
lies analogen Pin _

set digital pin _ to _
setze digitalen Pin _ auf _

set pin _ to _
setze Pin _ auf _

analog pins
analoge Pins

digital pins
digitale Pins

Control
Steuerung

when started
Wenn gestartet

when button _ pressed
Wenn Knopf _ gedrÃ¼ckt

forever _
fortlaufend _

repeat _ _
wiederhole _ mal _

wait _ millisecs
warte _ Millisekunden

if _ _
falls _ _

else if _ _
sonst falls _ _

if _ _ else _
falls _ _ sonst _

else
sonst

when _
Wenn _

wait until _
warte bis _

wait _ microsecs
warte _ Mikrosekunden

return _
berichte _

when _ received
Wenn _ empfangen

broadcast _
sende _

comment _
Kommentar _

for _ in _ _
fÃ¼r _ in _ _

repeat until _ _
wiederhole bis _ _

stop this task
stoppe dieses Skript

stop other tasks
stoppe andere Skripte

stop all
stoppe alles

last message
letzte Nachricht

Operators
Operatoren

_ mod _
_ modulo _

abs _
abs _

random _ to _
Zufallszahl von _ bis _

not _
nicht _

_ and _
_ und _

and _
und _

_ or _
_ oder _

or _
oder _

_ is a _
_ ist ein(e) _

boolean
Boole

number
Zahl

string
Zeichenkette

list
Liste

Advanced:
Fortgeschrittene BlÃ¶cke:

hex _
hex _

Variables
Variablen

# Buttons on top of "Variables" category

Add a variable
Variable hinzufÃ¼gen

Delete a variable
Variable lÃ¶schen

# New variable dialog

New variable name?
Neuer Variablenname?

set _ to _
setze _ auf _

change _ by _
Ã¤ndere _ um _

initialize local _ to _
initialisiere lokale _ mit _

Data
Daten

list
Liste

length of _
LÃ¤nge von _

item _ of _
Element _ von _

replace item _ of list _ with _
ersetze Element _ in Liste _ durch _

delete item _ of list _
entferne Element aus Liste _

add _ to list _
fÃ¼ge _ zu Liste _ hinzu

join _ _
verbinde _ _

copy _ from _
kopiere _ beginnend bei _

to _
bis _

find _ in _
finde _ in _

split _ by _
trenne _ nach _

starting at _
beginnend bei _

join items of list _
verbinde Elemente von Liste _

separator _
Separator _

unicode _ of _
Unicode _ von _

string from unicode _
Zeichenkette aus Unicode _

new list length _
neue Liste LÃ¤nge _

new byte array _
neues Byte-Array _

free memory
freier Speicher

My Blocks
Meine BlÃ¶cke

# Buttons on top of "My Blocks" category

Add a command block
FÃ¼ge Befehlsblock hinzu

Add a reporter block
FÃ¼ge Reporterblock hinzu

# Make a block dialog

Enter function name:
Gib einen Namen fÃ¼r die Funktion ein:

Comm
Kommunikation

i2c get device _ register _
i2c lies GerÃ¤t _ an Register _

i2c set device _ register _ to _
i2c setze GerÃ¤t _ an Register _ auf _

i2c device _ read list _
i2c GerÃ¤t _ lies list _

i2c device _ write list _
i2c GerÃ¤t _ schreibe list _

spi send _
sende mit SPI _

spi receive
empfange mit SPI

print _
drucke _

no op
no op

ignore
ignoriere

##############
# Primitives #
##############

# These are all mostly hidden from end users

draw shape _ at x _ y _
zeichne Form _ bei x _ y _

shape for letter _
Form fÃ¼r Buchstabe _

send NeoPixel rgb _
sende NeoPixel RGB _

has tone support
unterstÃ¼tzt KlÃ¤nge

play tone pin _ frequency _
spiele Ton Pin _ Frequenz _

has WiFi support
unterstÃ¼tzt WiFi

start WiFi _ password _
starte WiFi _ Passwort _

stop WiFi
stoppe WiFi

WiFi status
WiFi status

my IP address
meine IP Adresse

radio send number _
Radio sende Zahl _

radio send string _
Radio sende Zeichenkette _

radio send pair _ = _
Radio sende Paar _ = _

radio message received?
Radio Nachricht erhalten?

radio last number
Radio letzte Zahl

radio last string
Radio letzte Zeichenkette

radio last message type
Radio Typ der letzten Nachricht

radio set group _
Radio setze Gruppe _

radio set channel (0-83) _
Radio setze Kanal (0-83) _

radio set power (0-7) _
Radio setze StÃ¤rke (0-7) _

radio last signal strength
Radio letzte SignalstÃ¤rke

radio receive packet _
Radio empfange Paket _

radio send packet _
Radio sende Paket _

disable radio
deaktiviere Radio

#############
# Libraries #
#############

Basic Sensors
Einfache Sensoren

tilt x
Neigung x

tilt y
Neigung y

tilt z
Neigung z

acceleration
Beschleunigung

light level
LichtstÃ¤rke

temperature (Â°C)
Temperatur (Â°C)

####
# NeoPixel library

NeoPixel
NeoPixel

set NeoPixels _ _ _ _ _ _ _ _ _ _
setze NeoPixel _ _ _ _ _ _ _ _ _ _

clear NeoPixels
lÃ¶sche NeoPixel

set NeoPixel _ color _
setze NeoPixel _ Farbe _

set all NeoPixels color _
setze alle NeoPixel auf Farbe _

rotate NeoPixels by _
rotiere NeoPixel um _

color r _ g _ b _ (0-255)
Farbe R _ G _ B _ (0-255)

random color
zufÃ¤llige Farbe

attach _ LED NeoPixel strip to pin _
verbinde _ LED NeoPixel Streifen mit Pin _

has white _
mit WeiÃ _

PIR
PIR

PIR at pin _ detected movement
PIR an PIN _ erkennt Bewegung

####
# Citilab ED1 board libraries

ED1 Stepper Motor
ED1 Schrittmotor

move motor _ _ steps _
bewege Motor _ _ Schritte _

move motor 1 _ and motor 2 _ _ steps
bewege Motor 1 _ und Motor 2 _ _ Schritte

move motor _ angle _ Â°
bewege Motor _ Winkel _ Â°

move motor _ _ complete turns
bewege Motor _ _ komplette Runden

stop steppers
stoppe Schrittmotoren

clockwise
im Uhrzeigersinn

counter-clockwise
gegen Uhrzeigersinn

ED1 Buttons
ED1 KnÃ¶pfe

button OK
Knopf OK

button X
Knopf X

button up
Knopf Pfeil nach oben

button down
Knopf Pfeil nach unten

button left
Knopf Pfeil nach links

button right
Knopf Pfeil nach rechts

capacitive sensor _
kapazitiver Sensor _

set capacitive threshold to _
setze kapazitiven Schwellenwert auf _

####
# BirdBrain Technologies libraries

Hummingbird LED _ _ %
Hummingbird LED _ _ %

Hummingbird Tri-LED _ R _ % G _ % B _ %
Hummingbird Dreifarben-LED _ R _ % G _ % B _ %

Hummingbird Position Servo _ _ Â°
Hummingbird Position Servo _ _ Â°

Hummingbird Rotation Servo _ _ %
Hummingbird Drehung Servo _ _ %

Hummingbird _ _
Hummingbird _ _

Hummingbird Battery (mV)
Hummingbird Batterie (mV)

Light
Licht

Distance (cm)
Entfernung (cm)

Dial
Drehknopf

Sound
Klang

Other
Sonstige

Finch Beak Red _ Green _ Blue _
Finch Schnabel Rot _ GrÃ¼n _ Blau _

Finch Tail _ Red _ Green _ Blue _
Finch Schwanz _ Rot _ GrÃ¼n _ Blau _ 

Finch Move _ _ cm at _ %
Finch Gehe _ _ cm mit _ %

Finch Turn _ _ Â° at _ %
Finch Drehe _ _ Â° mit _ %

Finch Wheels L _ % R _ %
Finch RÃ¤der L _ % R _ %

Finch Stop
Finch Stoppen

Finch Distance (cm)
Finch Entfernung (cm)

Finch _ Light
Finch _ Licht

Finch _ Line
Finch _ Linie

Finch Reset Encoders
Finch Kodierer ZurÃ¼cksetzen

Finch _ Encoder
Finch _ Kodierer

Finch Accelerometer _
Finch Beschleunigungssensor _

Finch Battery
Finch Batterie

All
Alle

Forward
VorwÃ¤rts

Backward
RÃ¼ckwÃ¤rts

Right
Rechts

Left
Links

Beak Up
Schnabel oben

Beak Down
Schnabel unten

Tilt Left
Neigung Links

Tilt Right
Neigung Rechts

Level
Eben

Upside Down
Umgedreht

x
x

y
y

z
z

strength
StÃ¤rke

####
# Ultrasound distance library

distance (cm) trigger _ echo _
Entfernung (cm) AuslÃ¶ser _ Echo _

####
# Infrared remote library

IR Remote
IR Fernzugriff

receive IR code
empfange IR Code

receive IR code from device _
empfange IR Code von GerÃ¤t _

test IR
teste IR

attach IR receiver to pin _
schlieÃe IR EmpfÃ¤nger an Pin _ an

####
# Radio comm library
# Allows micro:bit boards to exchange messages
# All of its blocks are primitive (see "Primitives" section)

Radio
Radio

####
# Text scrolling library
# Scrolls text on 5x5 LED displays and simulated ones

Scrolling
Scrollen

scroll text _
scrolle Text _

scroll number _
scrolle Zahl _

pausing _ ms
pausiere _ ms

stop scrolling
stoppe Scrollen

####
# Servo motor library

Servo
Servo

set servo _ to _ degrees (-90 to 90)
setze Servo _ auf _ Grad (-90 bis 90)

set servo _ to speed _ (-100 to 100)
setze Servo _ auf _ Geschwindigkeit (-100 bis 100)

stop servo _
Stoppe Servo

####
# 5x5 LED display library
# Supports the micro:bit display, but also simulated 5x5 displays on boards
# with differently sized LED arrays, NeoPixel arrays or TFT displays

LED Display
LED Anzeige

display _
Display _

clear display
lÃ¶sche Display

plot x _ y _
plotte x _ y _

unplot x _ y _
lÃ¶sche x _ y _

display character _
zeige Buchstaben _

####
# TFT display library

enable TFT _
aktiviere TFT

TFT width
TFT Breite

TFT height
TFT HÃ¶he

set TFT pixel x _ y _ to _
setze TFT-Pixel x _ y _ auf _

draw line on TFT from x _ y _ to x _ y _ color _
zeichne Linie auf TFT von x _ y _ nach x _ y _ Farbe _

draw rectangle on TFT at x _ y _ width _ height _ color _
zeichne Rechteck auf TFT bei x _ y _ Breite _ HÃ¶he _ Farbe _

draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _
zeichne abgerundetes Rechteck auf TFT bei x _ y _ Breite _ HÃ¶he _ Radius _ Farbe _

draw circle on TFT at x _ y _ radius _ color _
zeichne Kreis auf TFT bei x _ y _ Radius _ Farbe _

draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _
zeichne Dreieck auf TFT bei x _ y_ , x _ y, x _ y _ Farbe _

filled _
ausgefÃ¼llt _

write _ on TFT at x _ y _ color _
Schreibe _ auf TFT bei x _ y _ Farbe _

scale _ wrap _
GrÃ¶Ãe _ Zeilenumbruch _

####
# Tone library
# Generates music tones on buzzers

Tone
Klang

attach buzzer to pin _
verbinde Summer mit Pin _

play note _ octave _ for _ ms
spiele Note _ Oktave _ fÃ¼r _ ms

play frequency _ for _ ms
spiele Frequenz _ fÃ¼r _ Millisekunden

play midi key _ for _ ms
spiele MIDI Note _ fÃ¼r _ Millisekunden

####
# Turtle geometry library

Turtle
Turtle

home
Ursprung

move _
gehe _

turn _ degrees
drehe _ Grad

turn _ / _ of circle
drehe _/ _ eines Kreises

pen down
Stift runter

pen up
Stift hoch

set pen color to _
setze Stiftfarbe auf _

set pen to random color
setze zufÃ¤llige Stiftfarbe

fill display with _
fÃ¼lle Display mit _

go to x _ y _
gehe zu x _ y _

point in direction _
zeige Richtung _

####
# File system library

Files
Dateien

open file _
Datei Ã¶ffnen

close file _
Datei schlieÃen

delete file _
Datei lÃ¶schen

append line _ to file _
fÃ¼ge Zeile _ zu Datei _ hinzu

append bytes _ to file _
fÃ¼ge Bytes _ zu Datei _ hinzu

end of file _
Ende von Datei _

next line of file _
nÃ¤chste Zeile von Datei _

next _ bytes of file _
nÃ¤chste _ Bytes von Datei _

starting at _
beginnend bei _

file names
Dateiname

size of file _
DateigrÃ¶Ãe

file system info
Dateisystem-Information

####
# WiFi library

WiFi
WiFi

wifi connect to _ password _ try _ times
WiFi verbinde mit _ Passwort _ Versuche _

wifi create hotspot _ password _
WiFi Ã¶ffne Hotspot _ Passwort _

IP address
IP Addresse

####
# Motion library
# Counts steps and detects motion via the internal accelerometer

Motion
Bewegung

motion
Bewegung

start step counter
Starte SchrittzÃ¤hler

step count
Schrittzahl

clear step count
lÃ¶sche Schrittzahl

set step threshold _ (0-50)
setze Schritt-Schwellenwert _ (0-50)

####
# Button Events library

Button Events
Knopf Ereignisse

button _ double pressed
Knopf _ doppelt gedrÃ¼ckt

button _ long pressed
Knopf _ lange gedrÃ¼ckt

button _ pressed
Knopf _ gedrÃ¼ckt

####
# Calliope board library

Calliope set LED red _ green _ blue _
Calliope setze LED rot _ grÃ¼n _ blau _

Calliope set speaker _
Calliope setze Lautsprecher _

Calliope loudness
Calliope LautstÃ¤rke

####
# Circuit Playground Express board library

Circuit Playground set speaker _
Circuit Playground setze Lautsprecher _

Circuit Playground slide switch
Circuit Playground Schiebeschalter

####
# DotStar LED library

attach _ DotStar LEDs to data pin _ clock pin _
schlieÃe _ DotStar LEDs an Daten-Pin _ Uhr-Pin _ an

set all DotStar LEDs to r _ g _ b _
setze alle DotStar LEDs auf r _ g _ b _

set DotStar LED _ to r _ g _ b _
setze DotStar LED _ auf r _ g _ b _

set DotStar brightness _
setze DotStar Helligkeit _

####
# BME280 environmental sensor

bme280 connected
bme280 verbunden

bmp280 connected
bmp280 verbunden

bmx280 temperature
bmx280 Temperatur

bmx280 pressure
bmx280 Luftdruck

bme280 humidity
bme280 Luftfeuchtigkeit

####
# TCS34725 color sensor

TCS34725 connected
TCS34725 verbunden

TCS34725 rgb
TCS34725 RGB

color _ name
Farbe _ Name

####
# DHT11 environmental sensor

temperature (Celsius) DHT11 pin _
Temperatur (Celsius) DHT11 Pin _

humidity DHT11 pin _
Luftfeuchtigkeit DHT11 Pin _

temperature (Celsius) DHT22 pin _
Temperatur (Celsius) DHT22 Pin _

humidity DHT22 pin _
Luftfeuchtigkeit DHT22 Pin _

####
# PN532 RFID reader

read PN532 RFID
lies PN532 RFID

RFID _ = _
RFID _ = _

get PN532 firmware version
PN532 firmware version

####
# HTTP libraries

HTTP client
HTTP Client

_ data _ to httpÜ// _
_ Daten _ URL http:// _

HTTP server
HTTP Server

start HTTP server
starte HTTP Server

HTTP server request
HTTP Server Anfrage

respond _ to HTTP request
antworte _ auf HTTP Anfrage

with body _
mit Body _

and headers _
und Header _

body of request _
Body der Anfrage _

path of request _
Pfad der Anfrage _

method of request _
Methode der Anfrage _

####
# Web Things library

Web Thing
Web Thing

set thing name to _
setze Thing Namen auf _

set thing capability to _
setze Thing FÃ¤higkeit auf _

set boolean property _ title _ @Type _
setze Boole Eigenschaft _ Name _ @Typ _

set string property _ title _ @Type _
setze Zeichenkette Eigenschaft _ Name _ @Typ _

set number property _ title _ @Type _
setze Zahl Eigenschaft _ Name _ @Typ _

set number property _ title _ min _ max _ @Type _
setze Zahl Eigenschaft _ Name _ Min _ Max _ @Typ _

read only _
schreibgeschÃ¼tzt

register event _ type _
registriere Ereignis _ Typ _

start WebThing server
starte WebThing Server starten

trigger event _
lÃ¶se Ereignis _ aus

thing description JSON
Thing Beschreibung JSON

properties JSON
Eigenschaften JSON

event definitions JSON
Ereignis-Definitionen JSON

events JSON
Ereignisse JSON

##################
# MicroBlocks UI #
##################

# buttons, error & info messages, dialog boxes, etc

New
Neu

Open
Ãffnen

Open from board
Vom Board Ã¶ffnen

Information
Information

Plug in the board.
SchlieÃe das Board an.

Reading project from board...
Projekt wird vom Board gelesen...

Loading project...
Projekt wird geladen...

Found a newer version of
Neuere Version gefunden von

Do you want me to update the one in the project?
MÃ¶chtest du sie im Projekt updaten?

Save
Speichern

Connect
Verbinden

disconnect
trennen

Serial port:
Serieller Anschluss:

other...
sonstige...

none
kein Anschluss

Port name?
Anschluss-Name?

Board type:
Board-Typ:

Select board:
Board auswÃ¤hlen:

Could not read:
Lesen nicht mÃ¶glich:

by
von

Created with GP
Mit GP erstellt

More info at http://microblocks.fun
Mehr Informationen unter http://microblocks.fun

Function "
Funktion "

" is too large to send to board.
" ist zu groÃ, um an das Board gesendet zu werden.

Script is too large to send to board.
Skript ist zu groÃ, um an das Board gesendet zu werden.

Use "Connect" button to connect to a MicroBlocks device.
DrÃ¼cke "Verbinden", um dein MicroBlocks-GerÃ¤t zu verbinden.

No boards found; is your board plugged in?
Kein Board gefunden; ist dein Board eingesteckt?

For AdaFruit boards, double-click reset button and try again.
FÃ¼r AdaFruit Boards den Reset Knopf drÃ¼cken und erneut versuchen

The board is not responding.
Das Board reagiert nicht.

Try to Install MicroBlocks on the board?
MicroBlocks auf dem Board installieren?

The MicroBlocks in your board is not current
Die MicroBlocks-Version auf deinem Board ist nicht aktuell

Try to update MicroBlocks on the board?
MicroBlocks auf dem Board updaten?

Stop
Stop

Start
Start

Quit MicroBlocks?
MicroBlocks beenden?

Discard current project?
Aktuelles Projekt verwerfen

clean up
aufrÃ¤umen

arrange scripts
Skripte in einer Reihe anordnen

undrop (ctrl-Z)
zurÃ¼cknehmen (Strg-Z)

copy all scripts to clipboard
alle Skripte in die Zwischenablage kopieren

paste all scripts
alle Skripte einfÃ¼gen

paste script
Skript einfÃ¼gen

save a picture of all scripts
Bild aller Skripte speichern

about...
Ã¼ber...

virtual machine version
Virtual Machine Version

update firmware on board
Firmware auf dem Board updaten

show data graph
Daten als Diagramm anzeigen

set serial delay
setze serielle VerzÃ¶gerung

firmware version
Firmware Version

start WebThing server
starte WebThing Server starten

stop WebThing server
stoppe WebThing Server

HTTP Server
HTTP Server

MicroBlocks HTTP Server listening on port 6473
MicroBlocks HTTP Server lauscht an Port 6473

disable autoloading board libraries
deaktiviere automatisches Laden von Board-Modulen

enable autoloading board libraries
aktiviere automatisches Laden von Board-Modulen

enable PlugShare when project empty
aktiviere PlugShare, wenn Projekt leer ist

disable PlugShare when project empty
deaktiviere PlugShare, wenn Projekt leer ist

erase flash and update firmware on ESP board
lÃ¶sche und repartitioniere ESP

Use board type
Verwende Board-Typ

Wiping board...
Board lÃ¶schen...

(press ESC to cancel)
(DrÃ¼cke ESC um abzubrechen)

Done!
Fertig!

download and install latest VM
aktuelle VM herunterladen und installieren

Select board type:
Board-Typ auswÃ¤hlen:

Uploading MicroBlocks to board...
MicroBlocks wird auf das Board geladen...

copy data to clipboard
Daten in der Ablage speichern

clear data
Daten lÃ¶schen

clear memory and variables
Variablen und Speicher zurÃ¼cksetzen

show advanced blocks
Fortgeschrittene BlÃ¶cke anzeigen

export functions as library
Funktionen als Modul exportieren

hide advanced blocks
Fortgeschrittene BlÃ¶cke ausblenden

Data Graph
Daten-Graph

show instructions
Op-Code anzeigen

show compiled bytes
Byte-Code anzeigen

expand
ausklappen

collapse
einklappen

rename...
umbenennen...

show block definition...
Blockdefinition anzeigen...

show the definition of this block
Blockdefinition fÃ¼r diesen Block anzeigen

delete block definition...
Blockdefinition lÃ¶schen...

delete the definition of this block
Blockdefinition fÃ¼r diesen Block lÃ¶schen

duplicate
duplizieren

duplicate this block
Diesen Block duplizieren

delete block
Block lÃ¶schen

delete this block
diesen Block lÃ¶schen

just this one block
nur diesen Block

copy to clipboard
in Zwischenablage kopieren

copy these blocks to the clipboard
diese BlÃ¶cke in die Zwischenablage kopieren

duplicate all
alles duplizieren

duplicate these blocks
diese BlÃ¶cke duplizieren

extract block
Block extrahieren

pull out this block
diesen Block herausziehen

save picture of script
Skriptbild speichern

save a picture of this block definition as a PNG file
Bild dieser Blockdefinition als PNG-Datei speichern

save a picture of these blocks as a PNG file
Bild dieser BlÃ¶cke als PNG-Datei speichern

copy script
Skript duplizieren

delete
lÃ¶schen

Input type:
Eingabetyp:

string only
nur Zeichenketten

string or number
Zeichenkette oder Zahl

number only
nur Zahlen

define
definiere

number/string
Zahl/Zeichenkette

editable number or string
editierbare Zahl oder Zeichenkette

label
Beschriftung

input
Eingabe

hide block definition
Blockdefinition verstecken

Are you sure you want to remove this block definition?
Bist du sicher, dass du diese Blockdefinition lÃ¶schen mÃ¶chtest?

Language
Sprache

Custom...
Benutzerdefiniert...

Obsolete
obsolet

OK
OK

Ok
Ok

Yes
Ja

No
Nein

Cancel
Abbrechen

Okay
Okay

Confirm
BestÃ¤tigen

# File picker and library dialogs

Libraries
Module

Examples
Beispiele

Desktop
Desktop

Computer
Computer

Cloud
Cloud

File
Datei

File Open
Datei Ã¶ffnen

File Save
Datei speichern

File name:
Dateiname:

New Folder
Neuer Ordner

by
von

Depends:
AbhÃ¤ngig von:

Tags:
Schlagworte:

Path, name or URL for library?
Pfad, Name oder URL des Moduls?

Invalid URL
UngÃ¼ltige URL

Could not fetch library.
Modul konnte nicht geladen werden.

Host does not exist or is currently down.
Host existiert nicht oder ist momentan nicht erreichbar.

File not found in server.
Datei konnte auf dem Server nicht gefunden werden.

Server expects HTTPS, and MicroBlocks doesn't currently support it.
Server erwartet HTTPS, was von MicroBlocks momentan nicht unterstÃ¼tzt wird.

library information
Modulinformation

built-in library
Integriertes Modul

Dependency path, name or URL?
AbhÃ¤ngigkeit Pfad, Name oder URL?

Tag name?
Schlagwort?

# MicroBlocks translation file
# Last updated: July 07 2020

#########################
# Blocks and categories #
#########################

Output
--MISSING--

set user LED _
allumer la LED _

say _
dire _

graph _
--MISSING--

Input
--MISSING--

button A
bouton A

button B
bouton B

microseconds
microsecondes

milliseconds
millisecondes

board type
--MISSING--

Pins
--MISSING--

read digital pin _
lire la broche numÃ©rique _

read analog pin _
lire la broche analogique _

set digital pin _ to _
mettre la broche numÃ©rique _ Ã  _

set pin _ to _
mettre la broche _ Ã  _

analog pins
broches analogiques

digital pins
broches numÃ©riques

Control
--MISSING--

when started
au dÃ©but

when button _ pressed
quand le bouton _ est pressÃ©

forever _
rÃ©pÃ©ter indÃ©finiment _

repeat _ _
rÃ©pÃ©ter _ fois _

wait _ millisecs
attendre _ millisecondes

if _ _
si _ _

else if _ _
sinon, si _ _

if _ _ else _
si _ _ sinon _

else
sinon

when _
quand _

wait until _
attendre jusqu'Ã  _

wait _ microsecs
attendre _ microsecondes

return _
renvoyer _

when _ received
quand _ est reÃ§u

broadcast _
envoyer Ã  tous _

comment _
commentaire _

for _ in _ _
pour chaque _ de _ _

repeat until _ _
rÃ©pÃ©ter jusqu'Ã  _ _

stop this task
arrÃªter cette tÃ¢che

stop other tasks
--MISSING--

stop all
stopper tout

last message
--MISSING--

Operators
--MISSING--

_ mod _
_ modulo _

abs _
valeur absolue de _

random _ to _
nombre alÃ©atoire entre _ et _

not _
non _

_ and _
_ et _

and _
et _

_ or _
_ ou _

or _
ou _

_ is a _
--MISSING--

boolean
--MISSING--

number
--MISSING--

string
--MISSING--

list
--MISSING--

Advanced:
--MISSING--

hex _
hexadÃ©cimal _

Variables
--MISSING--

# Buttons on top of "Variables" category

Add a variable
--MISSING--

Delete a variable
--MISSING--

# New variable dialog

New variable name?
--MISSING--

set _ to _
mettre _ Ã  _

change _ by _
changer _ de _

initialize local _ to _
--MISSING--

Data
--MISSING--

list
--MISSING--

length of _
longueur de _

item _ of _
--MISSING--

replace item _ of list _ with _
--MISSING--

delete item _ of list _
--MISSING--

add _ to list _
--MISSING--

join _ _
--MISSING--

copy _ from _
--MISSING--

to _
--MISSING--

find _ in _
--MISSING--

starting at _
--MISSING--

join items of list _
--MISSING--

separator _
--MISSING--

unicode _ of _
--MISSING--

string from unicode _
--MISSING--

new list length _
--MISSING--

new byte array _
--MISSING--

free memory
--MISSING--

My Blocks
--MISSING--

# Buttons on top of "My Blocks" category

Add a command block
--MISSING--

Add a reporter block
--MISSING--

# Make a block dialog

Enter function name:
--MISSING--

Comm
--MISSING--

i2c get device _ register _
i2c lire le pÃ©riphÃ©rique _ au registre _

i2c set device _ register _ to _
i2c mettre le pÃ©riphÃ©rique _ au registre _ Ã  _

i2c device _ read list _
--MISSING--

i2c device _ write list _
--MISSING--

spi send _
spi envoyer _

spi receive
spi lire

print _
afficher _

no op
no op

ignore
ignorer

##############
# Primitives #
##############

# These are all mostly hidden from end users

draw shape _ at x _ y _
dessiner la forme _ Ã  x _ y _

shape for letter _
forme pour la lettre _

send NeoPixel rgb _
envoyer RGB _ au NeoPixel

has tone support
--MISSING--

play tone pin _ frequency _
--MISSING--

has WiFi support
--MISSING--

start WiFi _ password _
--MISSING--

stop WiFi
--MISSING--

WiFi status
--MISSING--

my IP address
--MISSING--

radio send number _
--MISSING--

radio send string _
--MISSING--

radio send pair _ = _
--MISSING--

radio message received?
--MISSING--

radio last number
--MISSING--

radio last string
--MISSING--

radio last message type
--MISSING--

radio set group _
--MISSING--

radio set channel (0-83) _
--MISSING--

radio set power (0-7) _
--MISSING--

radio last signal strength
--MISSING--

radio receive packet _
--MISSING--

radio send packet _
--MISSING--

disable radio
--MISSING--

#############
# Libraries #
#############

Basic Sensors
--MISSING--

tilt x
inclinaison x

tilt y
inclinaison y

tilt z
inclinaison z

acceleration
--MISSING--

light level
--MISSING--

temperature (Â°C)
tempÃ©rature (Â°C)

####
# NeoPixel library

NeoPixel
--MISSING--

set NeoPixels _ _ _ _ _ _ _ _ _ _
--MISSING--

clear NeoPixels
--MISSING--

set NeoPixel _ color _
--MISSING--

set all NeoPixels color _
--MISSING--

rotate NeoPixels by _
--MISSING--

color r _ g _ b _ (0-255)
--MISSING--

random color
--MISSING--

attach _ LED NeoPixel strip to pin _
--MISSING--

has white _
--MISSING--

PIR
--MISSING--

PIR at pin _ detected movement
--MISSING--

####
# Citilab ED1 board libraries

ED1 Stepper Motor
--MISSING--

move motor _ _ steps _
--MISSING--

move motor 1 _ and motor 2 _ _ steps
--MISSING--

move motor _ angle _ Â°
--MISSING--

move motor _ _ complete turns
--MISSING--

stop steppers
--MISSING--

clockwise
--MISSING--

counter-clockwise
--MISSING--

ED1 Buttons
--MISSING--

button OK
--MISSING--

button X
--MISSING--

button up
--MISSING--

button down
--MISSING--

button left
--MISSING--

button right
--MISSING--

capacitive sensor _
--MISSING--

set capacitive threshold to _
--MISSING--

####
# BirdBrain Technologies libraries

Hummingbird LED _ _ %
Hummingbird LED _ _ %

Hummingbird Tri-LED _ R _ % G _ % B _ %
Hummingbird Tri-LED _ R _ % G _ % B _ %

Hummingbird Position Servo _ _ Â°
--MISSING--

Hummingbird Rotation Servo _ _ %
Hummingbird Rotation Servo _ _ %

Hummingbird _ _
Hummingbird _ _

Hummingbird Battery (mV)
Hummingbird Batterie (mV)

Light
LumiÃre

Distance (cm)
Distance (cm)

Dial
Cadran

Sound
Son

Other
Autre

Finch Beak Red _ Green _ Blue _
--MISSING--

Finch Tail _ Red _ Green _ Blue _
--MISSING--

Finch Move _ _ cm at _ %
--MISSING--

Finch Turn _ _ Â° at _ %
--MISSING--

Finch Wheels L _ % R _ %
--MISSING--

Finch Stop
--MISSING--

Finch Distance (cm)
--MISSING--

Finch _ Light
--MISSING--

Finch _ Line
--MISSING--

Finch Reset Encoders
--MISSING--

Finch _ Encoder
--MISSING--

Finch Accelerometer _
--MISSING--

Finch Battery
--MISSING--

All
--MISSING--

Forward
--MISSING--

Backward
--MISSING--

Right
--MISSING--

Left
--MISSING--

Beak Up
--MISSING--

Beak Down
--MISSING--

Tilt Left
--MISSING--

Tilt Right
--MISSING--

Level
--MISSING--

Upside Down
--MISSING--

x
--MISSING--

y
--MISSING--

z
--MISSING--

strength
--MISSING--

####
# Ultrasound distance library

distance (cm) trigger _ echo _
--MISSING--

####
# Infrared remote library

IR Remote
--MISSING--

receive IR code
--MISSING--

receive IR code from device _
--MISSING--

test IR
--MISSING--

attach IR receiver to pin _
--MISSING--

####
# Radio comm library
# Allows micro:bit boards to exchange messages
# All of its blocks are primitive (see "Primitives" section)

Radio
--MISSING--

####
# Text scrolling library
# Scrolls text on 5x5 LED displays and simulated ones

Scrolling
--MISSING--

scroll text _
--MISSING--

scroll number _
--MISSING--

pausing _ ms
--MISSING--

stop scrolling
--MISSING--

####
# Servo motor library

Servo
--MISSING--

set servo _ to _ degrees (-90 to 90)
--MISSING--

set servo _ to speed _ (-100 to 100)
--MISSING--

stop servo _
--MISSING--

####
# 5x5 LED display library
# Supports the micro:bit display, but also simulated 5x5 displays on boards
# with differently sized LED arrays, NeoPixel arrays or TFT displays

LED Display
--MISSING--

display _
Ã©cran _

clear display
effacer l'Ã©cran

plot x _ y _
allumer x _ y _

unplot x _ y _
Ã©teindre x _ y _

display character _
--MISSING--

####
# TFT display library

enable TFT _
--MISSING--

TFT width
--MISSING--

TFT height
--MISSING--

set TFT pixel x _ y _ to _
--MISSING--

draw line on TFT from x _ y _ to x _ y _ color _
--MISSING--

draw rectangle on TFT at x _ y _ width _ height _ color _
--MISSING--

draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _
--MISSING--

draw circle on TFT at x _ y _ radius _ color _
--MISSING--

draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _
--MISSING--

filled _
--MISSING--

write _ on TFT at x _ y _ color _
--MISSING--

scale _ wrap _
--MISSING--

####
# Tone library
# Generates music tones on buzzers

Tone
--MISSING--

attach buzzer to pin _
--MISSING--

play note _ octave _ for _ ms
--MISSING--

play frequency _ for _ ms
--MISSING--

play midi key _ for _ ms
--MISSING--

####
# Turtle geometry library

Turtle
--MISSING--

home
--MISSING--

move _
--MISSING--

turn _ degrees
--MISSING--

turn _ / _ of circle
--MISSING--

pen down
--MISSING--

pen up
--MISSING--

set pen color to _
--MISSING--

set pen to random color
--MISSING--

fill display with _
--MISSING--

go to x _ y _
--MISSING--

point in direction _
--MISSING--

####
# File system library

Files
--MISSING--

open file _
--MISSING--

close file _
--MISSING--

delete file _
--MISSING--

append line _ to file _
--MISSING--

append bytes _ to file _
--MISSING--

end of file _
--MISSING--

next line of file _
--MISSING--

next _ bytes of file _
--MISSING--

starting at _
--MISSING--

file names
--MISSING--

size of file _
--MISSING--

file system info
--MISSING--

####
# WiFi library

WiFi
--MISSING--

wifi connect to _ password _ try _ times
--MISSING--

wifi create hotspot _ password _
--MISSING--

IP address
--MISSING--

####
# Motion library
# Counts steps and detects motion via the internal accelerometer

Motion
--MISSING--

motion
--MISSING--

start step counter
--MISSING--

step count
--MISSING--

clear step count
--MISSING--

set step threshold _ (0-50)
--MISSING--

####
# Button Events library

Button Events
--MISSING--

button _ double pressed
--MISSING--

button _ long pressed
--MISSING--

button _ pressed
--MISSING--

####
# Calliope board library

Calliope set LED red _ green _ blue _
--MISSING--

Calliope set speaker _
--MISSING--

Calliope loudness
--MISSING--

####
# Circuit Playground Express board library

Circuit Playground set speaker _
--MISSING--

Circuit Playground slide switch
--MISSING--

####
# DotStar LED library

attach _ DotStar LEDs to data pin _ clock pin _
--MISSING--

set all DotStar LEDs to r _ g _ b _
--MISSING--

set DotStar LED _ to r _ g _ b _
--MISSING--

set DotStar brightness _
--MISSING--

####
# BME280 environmental sensor

bme280 connected
--MISSING--

bmp280 connected
--MISSING--

bmx280 temperature
--MISSING--

bmx280 pressure
--MISSING--

bme280 humidity
--MISSING--

####
# TCS34725 color sensor

TCS34725 connected
--MISSING--

TCS34725 rgb
--MISSING--

color _ name
--MISSING--

####
# DHT11 environmental sensor

temperature (Celsius) DHT11 pin _
--MISSING--

humidity DHT11 pin _
--MISSING--

temperature (Celsius) DHT22 pin _
--MISSING--

humidity DHT22 pin _
--MISSING--

####
# PN532 RFID reader

read PN532 RFID
--MISSING--

RFID _ = _
--MISSING--

get PN532 firmware version
--MISSING--

####
# HTTP libraries

HTTP client
--MISSING--

_ data _ to httpÜ// _
--MISSING--

HTTP server
--MISSING--

start HTTP server
--MISSING--

HTTP server request
--MISSING--

respond _ to HTTP request
--MISSING--

with body _
--MISSING--

and headers _
--MISSING--

body of request _
--MISSING--

path of request _
--MISSING--

method of request _
--MISSING--

####
# Web Things library

Web Thing
--MISSING--

set thing name to _
--MISSING--

set thing capability to _
--MISSING--

set boolean property _ title _ @Type _
--MISSING--

set string property _ title _ @Type _
--MISSING--

set number property _ title _ @Type _
--MISSING--

set number property _ title _ min _ max _ @Type _
--MISSING--

read only _
--MISSING--

register event _ type _
--MISSING--

start WebThing server
--MISSING--

trigger event _
--MISSING--

thing description JSON
--MISSING--

properties JSON
--MISSING--

event definitions JSON
--MISSING--

events JSON
--MISSING--

##################
# MicroBlocks UI #
##################

# buttons, error & info messages, dialog boxes, etc

New
--MISSING--

Open
--MISSING--

Open from board
--MISSING--

Information
--MISSING--

Plug in the board.
--MISSING--

Reading project from board...
--MISSING--

Loading project...
--MISSING--

Found a newer version of
--MISSING--

Do you want me to update the one in the project?
--MISSING--

Save
--MISSING--

Connect
--MISSING--

disconnect
--MISSING--

Serial port:
--MISSING--

other...
--MISSING--

none
--MISSING--

Port name?
--MISSING--

Board type:
--MISSING--

Select board:
--MISSING--

Could not read:
--MISSING--

by
--MISSING--

Created with GP
--MISSING--

More info at http://microblocks.fun
--MISSING--

Function "
--MISSING--

" is too large to send to board.
--MISSING--

Script is too large to send to board.
--MISSING--

Use "Connect" button to connect to a MicroBlocks device.
--MISSING--

No boards found; is your board plugged in?
--MISSING--

For AdaFruit boards, double-click reset button and try again.
--MISSING--

The board is not responding.
--MISSING--

Try to Install MicroBlocks on the board?
--MISSING--

The MicroBlocks in your board is not current
--MISSING--

Try to update MicroBlocks on the board?
--MISSING--

Stop
--MISSING--

Start
--MISSING--

Quit MicroBlocks?
--MISSING--

Discard current project?
--MISSING--

clean up
--MISSING--

arrange scripts
--MISSING--

undrop (ctrl-Z)
--MISSING--

copy all scripts to clipboard
--MISSING--

paste all scripts
--MISSING--

paste script
--MISSING--

save a picture of all scripts
--MISSING--

about...
--MISSING--

virtual machine version
--MISSING--

update firmware on board
--MISSING--

show data graph
--MISSING--

set serial delay
--MISSING--

firmware version
--MISSING--

start WebThing server
--MISSING--

stop WebThing server
--MISSING--

HTTP Server
--MISSING--

MicroBlocks HTTP Server listening on port 6473
--MISSING--

disable autoloading board libraries
--MISSING--

enable autoloading board libraries
--MISSING--

enable PlugShare when project empty
--MISSING--

disable PlugShare when project empty
--MISSING--

erase flash and update firmware on ESP board
--MISSING--

Use board type
--MISSING--

Wiping board...
--MISSING--

(press ESC to cancel)
--MISSING--

Done!
--MISSING--

download and install latest VM
--MISSING--

Select board type:
--MISSING--

Uploading MicroBlocks to board...
--MISSING--

copy data to clipboard
--MISSING--

clear data
--MISSING--

clear memory and variables
--MISSING--

show advanced blocks
--MISSING--

export functions as library
--MISSING--

hide advanced blocks
--MISSING--

Data Graph
--MISSING--

show instructions
--MISSING--

show compiled bytes
--MISSING--

expand
--MISSING--

collapse
--MISSING--

rename...
--MISSING--

show block definition...
--MISSING--

show the definition of this block
--MISSING--

delete block definition...
--MISSING--

delete the definition of this block
--MISSING--

duplicate
--MISSING--

duplicate this block
--MISSING--

delete block
--MISSING--

delete this block
--MISSING--

just this one block
--MISSING--

copy to clipboard
--MISSING--

copy these blocks to the clipboard
--MISSING--

duplicate all
--MISSING--

duplicate these blocks
--MISSING--

extract block
--MISSING--

pull out this block
--MISSING--

save picture of script
--MISSING--

save a picture of this block definition as a PNG file
--MISSING--

save a picture of these blocks as a PNG file
--MISSING--

copy script
--MISSING--

delete
--MISSING--

Input type:
--MISSING--

string only
--MISSING--

string or number
--MISSING--

number only
--MISSING--

define
--MISSING--

number/string
--MISSING--

editable number or string
--MISSING--

label
--MISSING--

input
--MISSING--

hide block definition
--MISSING--

Are you sure you want to remove this block definition?
--MISSING--

Language
--MISSING--

Custom...
--MISSING--

Obsolete
--MISSING--

OK
--MISSING--

Ok
--MISSING--

Yes
--MISSING--

No
--MISSING--

Cancel
--MISSING--

Okay
--MISSING--

Confirm
--MISSING--

# File picker and library dialogs

Libraries
--MISSING--

Examples
--MISSING--

Desktop
--MISSING--

Computer
--MISSING--

Cloud
--MISSING--

File
--MISSING--

File Open
--MISSING--

File Save
--MISSING--

File name:
--MISSING--

New Folder
--MISSING--

by
--MISSING--

Depends:
--MISSING--

Tags:
--MISSING--

Path, name or URL for library?
--MISSING--

Invalid URL
--MISSING--

Could not fetch library.
--MISSING--

Host does not exist or is currently down.
--MISSING--

File not found in server.
--MISSING--

Server expects HTTPS, and MicroBlocks doesn't currently support it.
--MISSING--

library information
--MISSING--

built-in library
--MISSING--

Dependency path, name or URL?
--MISSING--

Tag name?
--MISSING--

# MicroBlocks translation file
# Last updated: July 07 2020

#########################
# Blocks and categories #
#########################

Output
SaÃ­da

set user LED _
acender LED integrado _

say _
dicir _

graph _
engadir Ã¡ grÃ¡fica _

Input
Entrada

button A
botÃ³n A

button B
botÃ³n B

microseconds
microsegundos

milliseconds
milisegundos

board type
tipo de placa

Pins
Pins

read digital pin _
lectura dixital _

read analog pin _
lectura analÃ³xica _

set digital pin _ to _
poÃ±er o pin dixital _ a _

set pin _ to _
poÃ±er o pin _ a _

analog pins
pins analÃ³xicos

digital pins
pins dixitais

Control
Control

when started
ao comezar

when button _ pressed
cando se preme o botÃ³n _

forever _
por sempre _

repeat _ _
repetir _ veces _

wait _ millisecs
agardar _ milisegundos

if _ _
se _ _

else if _ _
se non, se _ _

if _ _ else _
se _ _ se non _

else
se non

when _
cando _

wait until _
agardar ata que _

wait _ microsecs
agardar _ microsegundos

return _
retornar _

when _ received
ao recibir _

broadcast _
difundir _

comment _
comentario _

for _ in _ _
por cada _ en _ _

repeat until _ _
repetir ata que _ _

stop this task
deter esta tarefa

stop other tasks
--MISSING--

stop all
detelo todo

last message
--MISSING--

Operators
--MISSING--

_ mod _
_ mÃ³dulo _

abs _
valor absoluto de _

random _ to _
nÃºmero ao chou entre _ e _

not _
non _

_ and _
_ e _

and _
e _

_ or _
_ ou _

or _
ou _

_ is a _
--MISSING--

boolean
--MISSING--

number
--MISSING--

string
--MISSING--

list
--MISSING--

Advanced:
--MISSING--

hex _
hexadecimal _

Variables
VariÃ¡beis

# Buttons on top of "Variables" category

Add a variable
Crear unha variÃ¡bel

Delete a variable
Eliminar unha variÃ¡bel

# New variable dialog

New variable name?
Novo nome da variÃ¡bel?

set _ to _
asignar _ a _

change _ by _
aumentar _ en _

initialize local _ to _
--MISSING--

Data
--MISSING--

list
--MISSING--

length of _
largo de _

item _ of _
elemento _ de _

replace item _ of list _ with _
--MISSING--

delete item _ of list _
--MISSING--

add _ to list _
--MISSING--

join _ _
--MISSING--

copy _ from _
--MISSING--

to _
--MISSING--

find _ in _
--MISSING--

starting at _
--MISSING--

join items of list _
--MISSING--

separator _
--MISSING--

unicode _ of _
--MISSING--

string from unicode _
--MISSING--

new list length _
nova lonxitude da lista _

new byte array _
--MISSING--

free memory
--MISSING--

My Blocks
Os meus bloques

# Buttons on top of "My Blocks" category

Add a command block
Engadir un bloque de ordes

Add a reporter block
Engadir un bloque de reportes

# Make a block dialog

Enter function name:
Nome da funciÃ³n:

Comm
ComunicaciÃ³ns

i2c get device _ register _
--MISSING--

i2c set device _ register _ to _
i2c escribir no dispositivo _ o rexistro _ con _

i2c device _ read list _
--MISSING--

i2c device _ write list _
--MISSING--

spi send _
spi enviar _

spi receive
spi ler

print _
escribir _

no op
no op

ignore
ignorar

##############
# Primitives #
##############

# These are all mostly hidden from end users

draw shape _ at x _ y _
debuxar a forma _ en x _ y _

shape for letter _
forma para a letra _

send NeoPixel rgb _
enviar RGB _ ao NeoPixel

has tone support
admite tons

play tone pin _ frequency _
toca un ton no pin _ na frecuencia _

has WiFi support
admite WiFi

start WiFi _ password _
iniciar a WiFi _ co contrasinal _

stop WiFi
deter a WiFi

WiFi status
estado da WiFi

my IP address
o meu enderezo IP

radio send number _
enviar nÃºmero _ por radio

radio send string _
enviar texto _ por radio

radio send pair _ = _
enviar asociaciÃ³n _ = _ por radio

radio message received?
mensaxe de radio recibida?

radio last number
Ãºltimo nÃºmero recibido por radio

radio last string
Ãºltimo texto recibido por radio

radio last message type
tipo da Ãºltima mensaxe recibido por radio

radio set group _
pon o grupo de radio a _

radio set channel (0-83) _
pon a canle de rÃ¡dio a (0-83) _

radio set power (0-7) _
pon a potencia da radio a (0-7) _

radio last signal strength
intensidade da Ãºltima seÃ±al de radio

radio receive packet _
recepciÃ³n de paquetes por radio _

radio send packet _
enviar paquetes por radio _

disable radio
desactivar a radio

#############
# Libraries #
#############

Basic Sensors
Sensores bÃ¡sicos

tilt x
inclinaciÃ³n x

tilt y
inclinaciÃ³n y

tilt z
inclinaciÃ³n z

acceleration
--MISSING--

light level
nivel de luz

temperature (Â°C)
temperatura (Â°C)

####
# NeoPixel library

NeoPixel
--MISSING--

set NeoPixels _ _ _ _ _ _ _ _ _ _
poÃ±er NeoPixeis _ _ _ _ _ _ _ _ _ _

clear NeoPixels
apagar NeoPixeis

set NeoPixel _ color _
poÃ±er NeoPixel _ de cor _

set all NeoPixels color _
poÃ±er todos os NeoPixeis de cor _

rotate NeoPixels by _
rotar NeoPixeis en _

color r _ g _ b _ (0-255)
--MISSING--

random color
--MISSING--

attach _ LED NeoPixel strip to pin _
--MISSING--

has white _
--MISSING--

PIR
--MISSING--

PIR at pin _ detected movement
--MISSING--

####
# Citilab ED1 board libraries

ED1 Stepper Motor
Motores ED1

move motor _ _ steps _
--MISSING--

move motor 1 _ and motor 2 _ _ steps
mover o motor 1 en _ e o motor 2 en _ _ pasos

move motor _ angle _ Â°
--MISSING--

move motor _ _ complete turns
--MISSING--

stop steppers
deter motores

clockwise
sentido horario

counter-clockwise
sentido antihorario

ED1 Buttons
BotÃ³ns ED1

button OK
botÃ³n Aceptar

button X
botÃ³n X

button up
botÃ³n arriba

button down
botÃ³n abaixo

button left
botÃ³n esquerda

button right
botÃ³n dereita

capacitive sensor _
sensor capacitivo _

set capacitive threshold to _
poÃ±er o limiar capacitivo a _

####
# BirdBrain Technologies libraries

Hummingbird LED _ _ %
Hummingbird LED _ _ %

Hummingbird Tri-LED _ R _ % G _ % B _ %
Hummingbird Tri-LED _ Vermello _ % Verde _ % Azul _ %

Hummingbird Position Servo _ _ Â°
--MISSING--

Hummingbird Rotation Servo _ _ %
Hummingbird Servo Rotacional _ _ %

Hummingbird _ _
Hummingbird _ _

Hummingbird Battery (mV)
Hummingbird BaterÃ­a (mV)

Light
Luz

Distance (cm)
Distancia (cm)

Dial
Dial

Sound
Son

Other
Outros

Finch Beak Red _ Green _ Blue _
--MISSING--

Finch Tail _ Red _ Green _ Blue _
--MISSING--

Finch Move _ _ cm at _ %
--MISSING--

Finch Turn _ _ Â° at _ %
--MISSING--

Finch Wheels L _ % R _ %
--MISSING--

Finch Stop
--MISSING--

Finch Distance (cm)
--MISSING--

Finch _ Light
--MISSING--

Finch _ Line
--MISSING--

Finch Reset Encoders
--MISSING--

Finch _ Encoder
--MISSING--

Finch Accelerometer _
--MISSING--

Finch Battery
--MISSING--

All
--MISSING--

Forward
--MISSING--

Backward
--MISSING--

Right
--MISSING--

Left
--MISSING--

Beak Up
--MISSING--

Beak Down
--MISSING--

Tilt Left
--MISSING--

Tilt Right
--MISSING--

Level
--MISSING--

Upside Down
--MISSING--

x
--MISSING--

y
--MISSING--

z
--MISSING--

strength
--MISSING--

####
# Ultrasound distance library

distance (cm) trigger _ echo _
distancia (cm) disparador _ eco _

####
# Infrared remote library

IR Remote
Infravermellos

receive IR code
recibir cÃ³digo IR dende

receive IR code from device _
recibir cÃ³digo IR dende o dispositivo _

test IR
probar IR

attach IR receiver to pin _
inicializar o receptor IR no pin _

####
# Radio comm library
# Allows micro:bit boards to exchange messages
# All of its blocks are primitive (see "Primitives" section)

Radio
Radio

####
# Text scrolling library
# Scrolls text on 5x5 LED displays and simulated ones

Scrolling
Texto animado

scroll text _
animar o texto _

scroll number _
animar o nÃºmero _

pausing _ ms
--MISSING--

stop scrolling
deter a animaciÃ³n

####
# Servo motor library

Servo
Servomotores

set servo _ to _ degrees (-90 to 90)
--MISSING--

set servo _ to speed _ (-100 to 100)
--MISSING--

stop servo _
--MISSING--

####
# 5x5 LED display library
# Supports the micro:bit display, but also simulated 5x5 displays on boards
# with differently sized LED arrays, NeoPixel arrays or TFT displays

LED Display
Pantalla LED

display _
pantalla _

clear display
limpar pantalla

plot x _ y _
acender x _ y _

unplot x _ y _
apagar x _ y _

display character _
amosar carÃ¡cter _

####
# TFT display library

enable TFT _
activar TFT _

TFT width
--MISSING--

TFT height
--MISSING--

set TFT pixel x _ y _ to _
poÃ±er o pÃ­xel x _ y _ da cor _

draw line on TFT from x _ y _ to x _ y _ color _
debuxar liÃ±a de x _ y _ a x _ y _ cor _

draw rectangle on TFT at x _ y _ width _ height _ color _
--MISSING--

draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _
--MISSING--

draw circle on TFT at x _ y _ radius _ color _
--MISSING--

draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _
--MISSING--

filled _
--MISSING--

write _ on TFT at x _ y _ color _
--MISSING--

scale _ wrap _
--MISSING--

####
# Tone library
# Generates music tones on buzzers

Tone
Tons

attach buzzer to pin _
inicializar zunidor no pin _

play note _ octave _ for _ ms
tocar a nota _ na oitava _ durante _ ms

play frequency _ for _ ms
tocar a frecuencia _ durante _ ms

play midi key _ for _ ms
tocar a tecla MIDI _ durante _ ms

####
# Turtle geometry library

Turtle
--MISSING--

home
--MISSING--

move _
--MISSING--

turn _ degrees
--MISSING--

turn _ / _ of circle
--MISSING--

pen down
--MISSING--

pen up
--MISSING--

set pen color to _
--MISSING--

set pen to random color
--MISSING--

fill display with _
--MISSING--

go to x _ y _
--MISSING--

point in direction _
--MISSING--

####
# File system library

Files
--MISSING--

open file _
--MISSING--

close file _
--MISSING--

delete file _
--MISSING--

append line _ to file _
--MISSING--

append bytes _ to file _
--MISSING--

end of file _
--MISSING--

next line of file _
--MISSING--

next _ bytes of file _
--MISSING--

starting at _
--MISSING--

file names
--MISSING--

size of file _
--MISSING--

file system info
--MISSING--

####
# WiFi library

WiFi
--MISSING--

wifi connect to _ password _ try _ times
conectar Ã¡ WiFi _ co contrasinal _ con _ intentos

wifi create hotspot _ password _
crear punto de acceso WiFi _ co contrasinal _

IP address
enderezo IP

####
# Motion library
# Counts steps and detects motion via the internal accelerometer

Motion
--MISSING--

motion
--MISSING--

start step counter
--MISSING--

step count
--MISSING--

clear step count
--MISSING--

set step threshold _ (0-50)
--MISSING--

####
# Button Events library

Button Events
--MISSING--

button _ double pressed
--MISSING--

button _ long pressed
--MISSING--

button _ pressed
--MISSING--

####
# Calliope board library

Calliope set LED red _ green _ blue _
--MISSING--

Calliope set speaker _
--MISSING--

Calliope loudness
--MISSING--

####
# Circuit Playground Express board library

Circuit Playground set speaker _
--MISSING--

Circuit Playground slide switch
--MISSING--

####
# DotStar LED library

attach _ DotStar LEDs to data pin _ clock pin _
--MISSING--

set all DotStar LEDs to r _ g _ b _
--MISSING--

set DotStar LED _ to r _ g _ b _
--MISSING--

set DotStar brightness _
--MISSING--

####
# BME280 environmental sensor

bme280 connected
--MISSING--

bmp280 connected
--MISSING--

bmx280 temperature
--MISSING--

bmx280 pressure
--MISSING--

bme280 humidity
--MISSING--

####
# TCS34725 color sensor

TCS34725 connected
--MISSING--

TCS34725 rgb
--MISSING--

color _ name
--MISSING--

####
# DHT11 environmental sensor

temperature (Celsius) DHT11 pin _
--MISSING--

humidity DHT11 pin _
--MISSING--

temperature (Celsius) DHT22 pin _
--MISSING--

humidity DHT22 pin _
--MISSING--

####
# PN532 RFID reader

read PN532 RFID
--MISSING--

RFID _ = _
--MISSING--

get PN532 firmware version
--MISSING--

####
# HTTP libraries

HTTP client
--MISSING--

_ data _ to httpÜ// _
--MISSING--

HTTP server
--MISSING--

start HTTP server
--MISSING--

HTTP server request
--MISSING--

respond _ to HTTP request
--MISSING--

with body _
--MISSING--

and headers _
--MISSING--

body of request _
--MISSING--

path of request _
--MISSING--

method of request _
--MISSING--

####
# Web Things library

Web Thing
--MISSING--

set thing name to _
--MISSING--

set thing capability to _
--MISSING--

set boolean property _ title _ @Type _
--MISSING--

set string property _ title _ @Type _
--MISSING--

set number property _ title _ @Type _
--MISSING--

set number property _ title _ min _ max _ @Type _
--MISSING--

read only _
--MISSING--

register event _ type _
rexistrar o evento _ do tipo _

start WebThing server
iniciar o servidor de WebThings

trigger event _
--MISSING--

thing description JSON
--MISSING--

properties JSON
--MISSING--

event definitions JSON
--MISSING--

events JSON
--MISSING--

##################
# MicroBlocks UI #
##################

# buttons, error & info messages, dialog boxes, etc

New
Novo

Open
Abrir

Open from board
--MISSING--

Information
--MISSING--

Plug in the board.
--MISSING--

Reading project from board...
--MISSING--

Loading project...
--MISSING--

Found a newer version of
--MISSING--

Do you want me to update the one in the project?
--MISSING--

Save
Gardar

Connect
Conectar

disconnect
desconectar

Serial port:
Porto serie:

other...
outro...

none
ningÃºn

Port name?
Nome do porto?

Board type:
Tipo de placa:

Select board:
Seleccionar a placa:

Could not read:
Non foi posÃ­bel ler:

by
por

Created with GP
--MISSING--

More info at http://microblocks.fun
MÃ¡is informaciÃ³n en http://microblocks.fun

Function "
A funciÃ³n Â«

" is too large to send to board.
Â» Ã© grande de mÃ¡is para enviala Ã¡ placa.

Script is too large to send to board.
O programa Ã© grande de mÃ¡is para envialo Ã¡ placa..

Use "Connect" button to connect to a MicroBlocks device.
Utilice o botÃ³n Â«ConectarÂ» para conectarse a un dispositivo MicroBlocks.

No boards found; is your board plugged in?
Non se atopou ningunha placa; ten conectada a sÃºa placa?

For AdaFruit boards, double-click reset button and try again.
--MISSING--

The board is not responding.
A placa non responde.

Try to Install MicroBlocks on the board?
Tentar instalar MicroBlocks na placa?

The MicroBlocks in your board is not current
--MISSING--

Try to update MicroBlocks on the board?
--MISSING--

Stop
Deter

Start
Iniciar

Quit MicroBlocks?
SaÃ­r de MicroBlocks?

Discard current project?
Quere desbotar o proxecto actual?

clean up
limpeza

arrange scripts
organizar programas

undrop (ctrl-Z)
--MISSING--

copy all scripts to clipboard
copiar todos os programas no portappeis

paste all scripts
pegar todos os programas

paste script
pegar o programa

save a picture of all scripts
gardar a imaxe de todos os programas

about...
sobre...

virtual machine version
versiÃ³n da mÃ¡quina virtual

update firmware on board
actualizar o firmware da placa

show data graph
amosar a grÃ¡fica de datos

set serial delay
axustar a latencia do porto serie

firmware version
versiÃ³n do firmware

start WebThing server
iniciar o servidor de WebThings

stop WebThing server
deter o servidor de WebThings

HTTP Server
--MISSING--

MicroBlocks HTTP Server listening on port 6473
o servidor HTTP de MicroBlocks esta activo no porto 6473

disable autoloading board libraries
--MISSING--

enable autoloading board libraries
--MISSING--

enable PlugShare when project empty
--MISSING--

disable PlugShare when project empty
--MISSING--

erase flash and update firmware on ESP board
--MISSING--

Use board type
--MISSING--

Wiping board...
--MISSING--

(press ESC to cancel)
--MISSING--

Done!
--MISSING--

download and install latest VM
--MISSING--

Select board type:
--MISSING--

Uploading MicroBlocks to board...
--MISSING--

copy data to clipboard
copiar os datos no portapapeis

clear data
limpar os datos

clear memory and variables
limpar a memoria e as variÃ¡beis

show advanced blocks
amosar os bloques avanzados

export functions as library
exportar as funciÃ³ns como unha biblioteca

hide advanced blocks
agochar os bloques avanzados

Data Graph
GrÃ¡fico de datos

show instructions
amosar as instruciÃ³ns

show compiled bytes
amosar os bytes compilados

expand
expandir

collapse
contraer

rename...
renomear...

show block definition...
amosar a definiciÃ³n do bloque...

show the definition of this block
amosa a definiciÃ³n deste bloque

delete block definition...
eliminar a definiciÃ³n do bloque...

delete the definition of this block
elimina a definiciÃ³n deste bloque

duplicate
duplicar

duplicate this block
duplicar este bloque

delete block
eliminar bloque

delete this block
eliminar este bloque

just this one block
sÃ³ este bloque

copy to clipboard
copiar no portapapeis

copy these blocks to the clipboard
copia estes bloques no portapapeis

duplicate all
duplicar ata abaixo

duplicate these blocks
duplica este bloque e todos os que lle seguen

extract block
extraer bloque

pull out this block
sacar este bloque

save picture of script
gardar a imaxe do programa

save a picture of this block definition as a PNG file
gardar unha imaxe da definiciÃ³n deste bloque en formato PNG

save a picture of these blocks as a PNG file
garda unha imaxe destes bloques como un ficheiro PNG

copy script
copia el programa

delete
eliminar

Input type:
Tipo de entrada:

string only
sÃ³ texto

string or number
texto ou nÃºmero

number only
sÃ³ nÃºmero

define
definir

number/string
nÃºmero/texto

editable number or string
nÃºmero ou texto editÃ¡bel

label
etiqueta

input
entrada

hide block definition
agochar a definiciÃ³n do bloque

Are you sure you want to remove this block definition?
Confirma que quere retirar a definiciÃ³n deste bloque?

Language
Idioma

Custom...
Personalizado...

Obsolete
Obsoleto

OK
Aceptar

Ok
Aceptar

Yes
Si

No
Non

Cancel
Cancelar

Okay
Aceptar

Confirm
Confirmar

# File picker and library dialogs

Libraries
Bibliotecas

Examples
--MISSING--

Desktop
--MISSING--

Computer
--MISSING--

Cloud
--MISSING--

File
Ficheiro

File Open
Abrir ficheiro

File Save
Gardar ficheiro

File name:
Nome de ficheiro:

New Folder
--MISSING--

by
por

Depends:
--MISSING--

Tags:
--MISSING--

Path, name or URL for library?
--MISSING--

Invalid URL
--MISSING--

Could not fetch library.
--MISSING--

Host does not exist or is currently down.
--MISSING--

File not found in server.
--MISSING--

Server expects HTTPS, and MicroBlocks doesn't currently support it.
--MISSING--

library information
--MISSING--

built-in library
--MISSING--

Dependency path, name or URL?
--MISSING--

Tag name?
--MISSING--

# MicroBlocks translation file
# Last updated: April 14 2023

#########################
# Blocks and categories #
#########################

Output
Output

set user LED _
maak gebruiker LED _

say _
zeg _

graph _
grafiek _

Input
Input

button A
knop A

button B
knop B

timer
timer

reset timer
timer resetten

microseconds
microseconden

milliseconds
milliseconden

board type
board type

Pins
Pinnen

read digital pin _
lees digitale pin _

read analog pin _
lees analoge pin _

pullup _
pullup _

set digital pin _ to _
maak digitale pin _  _

set pin _ to _
maak pin _  _

analog pins
analoge pinnen

digital pins
digitale pinnen

Control
Besturen

when started
wanneer gestart

when button _ pressed
wanneer knop _ wordt ingedrukt

forever _
herhaal _

repeat _ _
herhaal _ _

wait _ millisecs
wacht _ millisec.

if _ _
als _ _

if _ _ else _
als _ dan _ anders _

else if _ _
anders als _ dan _

else
anders

when _
wanneer _

wait until _
wacht tot _

wait _ microsecs
wacht _ microsec.

return _
terug _

when _ received
wanneer _ ontvangen

go!
start!

broadcast _
zend _

comment _
commentaar _

How this works...
Hoe dit werkt...

for _ in _ _
voor _ in _ _

repeat until _ _
herhaal tot _ _

stop this task
stop deze taak

stop other tasks
stop andere taken

stop all
stop alles

last message
laatste bericht

call _
roep _ aan

function name
functienaam

parameter list
parameterlijst

with _
met _

Operators
Functies

_ mod _
_ modulo _

abs _
absolute waarde van _

min _ _
min _ _

max _ _
max _ _

random _ to _
willekeurig getal tussen _ en _

not _
niet _

_ and _
_ en _

and _
en _

_ or _
_ of _

or _
of _

_ is a _
_ is een _

boolean
booleaans

number
getal

string
tekst

list
lijst

byte array
byte array

Advanced:
Gevorderd

rescale _ from ( _ , _ ) to ( _ , _ )
herschaal _ van ( _ , _ ) naar ( _ , _ )

hex _
hex _

Variables
Variabelen

# Buttons on top of "Variables" category

Add a variable
Voeg een variabele toe

Delete a variable
Verwijder een variabele

# New variable dialog

New variable name?
Nieuwe variabele naam?

set _ to _
maak _  _

change _ by _
verander _ met _

initialize local _ to _
initialiseer lokaal _ naar _

Data
Data

list
lijst

cat
kat

dog
hond

bird
vogel

fish
vis

length of _
lengte van _

item _ of _
item _ van _

replace item _ of list _ with _
vervang item _ van lijst _ door _

delete item _ of list _
verwijder item _ van lijst _

add _ to list _
voeg _ toe aan lijst _

join _ _
voeg _ _ samen

copy _ from _
kopieer _ van _

smiles
lachen

to _
naar _

find _ in _
vind _ in _

starting at _
start op _

join items of list _
voeg items van lijst _ samen

separator _
scheidingsteken _

unicode _ of _
unicode _ van _

string from unicode _
tekst van unicode _

new list length _
nieuwe lijst lengte _

new byte array _
nieuwe byte array _

as byte array _
als byte array _

aByteListOrString
eenByteLijstOfReeks

with all _
met alles als _

free memory
vrij geheugen

all
alles

last
laatste

random
willekeurig

split _ by _
splits _ door _

My Blocks
Mijn blokken

Generic
Algemeen

# Buttons on top of "My Blocks" category

Add a command block
Voeg een commando blok toe

Add a reporter block
Voeg een reporter blok toe

# Make a block dialog

Enter function name:
Geef functie naam:

Comm
Comm

i2c get device _ register _
i2c verkrijg device _ register _

i2c set device _ register _ to _
i2c maak device _ register _ naar _

i2c device _ read list _
i2c device _ lees lijst _

i2c device _ write list _
i2c device _ schrijf lijst _

spi send _
spi zend _

spi receive
spi ontvang

spi setup speed _
spi setup snelheid _

mode _
mode _

rpi channel _
rpi kanaal _

spi exchange bytes _
spi uitgewisselde bytes _

aByteArray
eenByteArray

serial open _ baud
serieel open _ baud

serial close
serieel sluiten

serial read
serieel lezen

serial write _
serieel schrijven _

serial write _ starting at _
serieel schrijven _ startend bij _

aByteStringOrByteArray
eenByteReeksOfByteArray

soft serial write byte _ pin _ baud _
soft seriele schrijf byte _ pin _ baud _

print _
schrijf _

no op
doe niets

ignore
negeer

##############
# Primitives #
##############

# These are all mostly hidden from end users

draw shape _ at x _ y _
teken vorm _ op x _ y _

shape for letter _
vorm voor letter _

send NeoPixel rgb _
zend NeoPixel rgb _

has tone support
heeft toonondersteuning

play tone pin _ frequency _
speel toon pin _ frequentie _

has WiFi support
heeft WiFi ondersteuning

start WiFi _ password _
start WiFi _ wachtwoord _

stop WiFi
stop WiFi

WiFi status
WiFi status

my IP address
mijn IP adres

radio send number _
radio zend nummer _

radio send string _
radio zend tekst _

Hello!
Hallo!

radio send pair _ = _
radio zend paar _ = _

light
licht

radio message received?
radio boodschap ontvangen?

radio last number
radio laatste nummer

radio last string
radio laatste tekst

radio last message type
radio laatste type boodschap

radio set group _ (0-255)
radio stel groep in _ (0-255)

radio set channel (0-83) _
radio instellen kanaal (0-83) _

radio set power (0-7) _
radio instellen vermogen (0-7) _

radio last signal strength
radio laatste signaal sterkte

radio receive packet _
radio ontvang pakket _

radio send packet _
radio zend pakket _

disable radio
zet radio uit

#############
# Libraries #
#############

Basic Sensors
Basis Sensoren

tilt x
kantel x

tilt y
kantel y

tilt z
kantel z

acceleration
versnelling

light level
lichtsterkte

temperature (Â°C)
temperatuur (Â°C)

magnetic field
magnetisch veld

set acceleration range _ g = 100
stel versnellingsbereik in _ g = 100

####
# NeoPixel library

NeoPixel
NeoPixel

set NeoPixels _ _ _ _ _ _ _ _ _ _
maak NeoPixels _ _ _ _ _ _ _ _ _ _

clear NeoPixels
wis NeoPixels

set NeoPixel _ color _
maak NeoPixel _ kleur _

set all NeoPixels color _
maak alle NeoPixels kleur _

rotate NeoPixels by _
draai NeoPixels met _

color r _ g _ b _ (0-255)
kleur r _ g _ b _ (0-255)

random color
willekeurige kleur

attach _ LED NeoPixel strip to pin _
verbind _ LED NeoPixel strip aan pin _

has white _
heeft wit _

PIR
PIR

PIR at pin _ detected movement
PIR op pin _ detecteerde beweging

####
# Microphone library

Microphone
Microfoon

microphone
microfoon

turn on microphone
microfoon aanzetten

loudness
geluidssterkte

clap count
klap tellen

set clap threshold _
maak klap drempelwaarde _

estimate clap threshold
klap drempelwaarde schatten

####
# Citilab ED1 board libraries

ED1 Stepper Motor
ED1 Stappenmotor

move motor _ _ steps _
beweeg motor _ _ stappen _

move motor 1 _ and motor 2 _ _ steps
beweeg motor 1 _ and motor 2 _ _ stappen

move motor _ angle _ Â°
beweeg motor _ hoek _ Â°

move motor _ _ complete turns
beweeg motor _ _ volledige omwentelingen

stop steppers
stop stappenmotoren

clockwise
met de klok mee

counter-clockwise
tegen de klok in

ED1 Buttons
ED1 knoppen

button OK
knop OK

button X
knop X

button up
knop omhoog

button down
knop omlaag

button left
knop links

button right
knop rechts

capacitive sensor _
capacitieve sensor _

set capacitive threshold to _
maak capacitieve drempelwaarde _

####
# BirdBrain Technologies libraries

Hummingbird LED _ _ %
Hummingbird LED _ _ %

Hummingbird Tri-LED _ R _ % G _ % B _ %
Hummingbird Tri-LED _ R _ % G _ % B _ %

Hummingbird Position Servo _ _ Â°
Hummingbird Positie-Servo _ _ Â°

Hummingbird Rotation Servo _ _ %
Hummingbird Draai-Servo _ _ %

Hummingbird _ _
Hummingbird _ _

Hummingbird Battery (mV)
Hummingbird Batterij (mV)

Light
Licht

Distance (cm)
Afstand (cm)

Dial
Draaiknop

Sound
Geluid

Other
Ander

Finch Beak Red _ Green _ Blue _
Finch Snavel Rood _ Groen _ Blauw _

Finch Tail _ Red _ Green _ Blue _
Finch Staart _ Rood _ Groen _ Blauw _

Finch Move _ _ cm at _ %
Finch Beweeg _ _ cm op _ %

Finch Turn _ _ Â° at _ %
Finch Draai _ _ Â° op _ %

Finch Wheels L _ % R _ %
Finch Wielen L _ % R _ %

Finch Stop
Finch Stop

Finch Distance (cm)
Finch Afstand (cm)

Finch _ Light
Finch _ Licht

Finch _ Line
Finch _ Lijn

Finch Reset Encoders
Finch Reset Encoders

Finch _ Encoder
Finch _ Encoder

Finch Accelerometer _
Finch Versnellingsmeter _

Finch Battery
Finch Batterij

All
Alle

Forward
Vooruit

Backward
Achteruit

Right
Rechtsaf

Left
Linksaf

Beak Up
Snavel omhoog

Beak Down
Snavel omlaag

Tilt Left
Kantel links

Tilt Right
Kantel rechts

Level
Level

Upside Down
Ondersteboven

x
x

y
y

z
z

strength
sterkte

####
# Ultrasound distance library

distance (cm) trigger _ echo _
afstand (cm) trigger _ echo _

####
# Infrared remote library

IR Remote
IR afstandsbediening

receive IR code
ontvang IR code

receive IR code from device _
ontvang IR code van device _

test IR
test IR

attach IR receiver to pin _
verbind IR ontvanger aan pin _

IR transmit device _ command _
IR zend device _ command _

####
# Radio comm library
# Allows micro:bit boards to exchange messages
# All of its blocks are primitive (see "Primitives" section)

Radio
Radio

####
# Text scrolling library
# Scrolls text on 5x5 LED displays and simulated ones

Scrolling
Scrollen

scroll text _
scroll tekst _

HELLO ROSA!
HALLO ROSA!

scroll number _
scroll nummer _

pausing _ ms
pauzeer _ ms

stop scrolling
stop met scrollen

####
# Servo motor library

Servo
Servo

set servo _ to _ degrees (-90 to 90)
maak servo _  _ graden (-90 to 90)

set servo _ to speed _ (-100 to 100)
maak servo _ snelheid _ (-100 to 100)

stop servo _
stop servo _

####
# 5x5 LED display library
# Supports the micro:bit display, but also simulated 5x5 displays on boards
# with differently sized LED arrays, NeoPixel arrays or TFT displays

LED Display
LED scherm

display _
scherm _

clear display
wis scherm

set display color _
zet scherm kleur als _

plot x _ y _
teken x _ y _

unplot x _ y _
wis x _ y _

display character _
toon teken _

####
# TFT display library

enable TFT _
activeer TFT _

TFT width
TFT breedte

TFT height
TFT hoogte

set TFT pixel x _ y _ to _
maak TFT pixel x _ y _ op _

draw line on TFT from x _ y _ to x _ y _ color _
teken lijn op TFT van x _ y _ naar x _ y _ kleur _

draw rectangle on TFT at x _ y _ width _ height _ color _
teken rechthoek op TFT op x _ y _ breed _ hoog _ kleur _

draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _
teken afgeronde rechthoek op TFT op x _ y _ breed _ hoog _ radius _ kleur _

draw circle on TFT at x _ y _ radius _ color _
teken cirkel op TFT op x _ y _ radius _ kleur _

draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _
teken driehoek op TFT op x _ y _ , x _ y _ , x _ y _ kleur _

filled _
gevuld _

write _ on TFT at x _ y _ color _
schrijf _ op TFT op x _ y _ kleur _

Hello World!
Hallo Wereld!

scale _ wrap _
schaal _ wrap _

####
# BMP library
# Can display BMP image files on a TFT display

display BMP file _ at x _ y _
laat BMP bestand _ zien op x _ y _

image.bmp
afbeelding.bmp

####
# HSV color library

HSV Colors
HSV kleuren

RGB of hue _ saturation _ brightness _ (0-100)
RGB van tint _ verzadiging _ helderheid _ (0-100)

####
# Fractions library

Fractions
Breuken

fract _ / _
breuk _ / _

fract _ + _
breuk _ + _

fract _ - _
breuk _ - _

fract _ Ã _
breuk _ Ã _

fract _ = _
breuk _ = _

fract _ < _
breuk _ < _

fract _ > _
breuk _ > _

simplify fraction _
breuk vereenvoudigen _

integer part of fraction _
gehele getal van de breuk _

numerator of fraction _
teller van de breuk _

denominator of fraction _
noemer van de breuk _

gcd _ _
ggd _ _

lcm _ _
kgv _ _

####
# Tone library
# Generates music tones on buzzers

Tone
Toon

attach buzzer to pin _
verbind buzzer aan pin _

play note _ octave _ for _ ms
speel noot _ octaaf  _ gedurende _ ms

play frequency _ for _ ms
speel frequentie _ gedurende _ ms

play midi key _ for _ ms
speel midi toon _ gedurende _ ms

start tone _ Hz
start toon _ Hz

stop tone
stop toon

c
c

c#
c#

d
d

d#
d#

e
e

f
f

f#
f#

g
g

g#
g#

a
a

a#
a#

b
b

####
# Ringtone library
# Can play Nokring-formatted music. Also known as RTTTL.

Ringtone
Ringtone

play ringtone _
ringtone _ afspelen

current song name
huidig lied naam

####
# Pluck
# Generate music with plucked-string resembling sounds

Pluck
Pluck

pluck note _ octave _ for _ ms
pluck noot _ octaaf _ gedurende _ milliseconden

pluck MIDI key _ for _ msecs
pluck MIDI key _ gedurende _ milliseconden

set pluck pin _
maak pluck pin _

####
# WAV
# Play WAV sound files

play WAV file _
WAV bestand _ afspelen

filename
bestandsnaam

####
# Turtle geometry library

Turtle
Turtle

home
home

move _
ga vooruit _

turn _ degrees
draai _ graden

turn _ / _ of circle
draai _ / _ van cirkel

pen down
pen neer

pen up
pen op

set pen color to _
maak penkleur _

set pen to random color
maak penkleur willekeurig

fill display with _
vul scherm met _

go to x _ y _
ga naar x _ y _

point in direction _
wijs naar richting _

####
# File system library

Files
Bestanden

open file _
bestand _ openen

close file _
bestand _ sluiten

delete file _
bestand _ verwijderen

append line _ to file _
regel _ toevoegen aan bestand _

append bytes _ to file _
bytes _ toevoegen aan bestand _

end of file _
einde van bestand _

next line of file _
volgende regel van bestand _

next _ bytes of file _
volgende _ bytes van bestand _

read into _ from file _
lees naar _ vanuit bestand _

a ByteArray
een ByteArray

starting at _
start op _

file names
bestandsnamen

in directory _
in map _

size of file _
grootte van bestand _

file system info
bestandssysteem info

####
# Strings
# string (text) processing functions

Strings
Strings

_ is a digit
_ is een cijfer

_ is lowercase
_ is een kleine letter

_ is uppercase
_ is een grote letter

_ begins with _
_ begint met _

prefix
voorvoegsel

pre
voor

_ ends with _
_ eindigt met _

suffix
achtervoegsel

fix
voegsel

_ contains _
_ bevat _

lowercase _
maak _ in kleine letters

THIS is a String! :)
DIT is een string! :)

uppercase _
maak _ in hoofdletters

Hello, world!
Hallo, wereld!

_ without white space
_ zonder extra spaties

join string list _ separator _
voeg string lijst _ samen met scheidingsteken _

unicodes _
unicodes _

aString
eenString

string from unicodes _
string van unicodes _

aList
eenLijst

num2str _
num2str

str2num _
str2num _

####
# WiFi library

WiFi
WiFi

wifi connect to _ password _
verbind wifi met _ wachtwoord _

Network_Name
Netwerk_Naam

IP _ gateway _ subnet _
IP _ gateway _ subnet _

wifi create hotspot _ password _
wifi maak hotspot _ wachtwoord _

Network_Password
Netwerk_Wachtwoord

IP address
IP adres

MAC address
MAC adres

####
# Motion library
# Counts steps and detects motion via the internal accelerometer

Motion
Beweging

motion
beweging

start step counter
start stappenteller

step count
aantal stappen

clear step count
wis aantal stappen

set step threshold _ (0-50)
maak stappen drempel _ (0-50)

####
# Button Events library

Button Events
Knop Gebeurtenissen

button _ double pressed
knop _ dubbel ingedrukt

button _ long pressed
knop _ lang ingedrukt

button _ pressed
knop _ ingedrukt

####
# Calliope board library

Calliope set LED red _ green _ blue _
Calliope maak LED op rood _ groen _ blauw _

Calliope set speaker _
Calliope maak luidspreker _

Calliope loudness
Calliope volume

####
# Circuit Playground Express board library

Circuit Playground set speaker _
Circuit Playground maak luidspreker _

Circuit Playground slide switch
Circuit Playground schuifschakelaar

####
# DotStar LED library

attach _ DotStar LEDs to data pin _ clock pin _
verbind _ DotStar LEDs aan data pin _ klok pin _

set all DotStar LEDs to r _ g _ b _
maak alle DotStar LEDs op r _ g _ b _

set DotStar LED _ to r _ g _ b _
maak DotStar LED _ op r _ g _ b _

set DotStar brightness _
maak DotStar helderheid _

####
# BME280 environmental sensor

bme280 connected
bme280 verbonden

bmp280 connected
bmp280 verbonden

bmx280 temperature
bmx280 temperatuur

bmx280 pressure
bmx280 luchtdruk

bme280 humidity
bme280 vochtigheid

####
# TCS34725 color sensor

TCS34725 connected
TCS34725 verbonden

TCS34725 rgb
TCS34725 rgb

color _ name
kleur _ naam

####
# DHT11 environmental sensor

temperature (Celsius) DHT11 pin _
temperatuur (Celsius) DHT11 pin _

humidity DHT11 pin _
vochtigheid DHT11 pin _

temperature (Celsius) DHT22 pin _
temperatuur (Celsius) DHT22 pin _

humidity DHT22 pin _
vochtigheid DHT22 pin _

####
# PN532 RFID reader

read PN532 RFID
lees PN532 RFID

RFID _ = _
RFID _ = _

get PN532 firmware version
lees PN532 firmware versie

####
# Touch Screen

Touch Screen
Touchscreen

TFT touched
TFT aangeraakt

TFT touch X position
TFT aanraak X positie

TFT touch Y position
TFT aanraak Y positie

TFT touch pressure
TFT aanraak druk

####
# HTTP Client

HTTP client
HTTP-client

_ data _ to httpÜ// _
_ data _ naar httpÜ// _

MicroBlocks is fun
MicroBlocks is leuk

port _
poort _

####
# HTTP Server

HTTP server
HTTP-server

start HTTP server
HTTP-server opstarten

HTTP server request
HTTP-server verzoek

respond _ to HTTP request
antwoord _ op HTTP verzoek

with body _
met body _

Welcome to the MicroBlocks HTTP server
Welkom op de MicroBlocks HTTP server

and headers _
en headers _

body of request _
verzoek-body _

path of request _
verzoek-pad _

headers of request _
headers van verzoek _

method of request _
methode van verzoek _

content length of request _
inhoud lengte van verzoek _

####
# WebSocket server

WebSocket server
WebSocket server

start WebSocket server
start WebSocket server

last WebSocket event
laatste WebSocket gebeurtenis

client ID for WebSocket event _
client ID voor WebSocket event _

payload for WebSocket event _
payload voor WebSocket gebeurtenis _

type of WebSocket event _
type WebSocket gebeurtenis _

send _ to WebSocket client _
stuur _ naar WebSocket client _

Hello, Client!
Hallo, client!

####
# Web Things library

Web Thing
WebThing

set thing name to _
maak thing naam _

set thing capability to _
maak WebThing vermogen _

set boolean property _ title _ @Type _
maak booleaans eigenschap _ titel _ @Type _

set string property _ title _ @Type _
maak tekst eigenschap _ titel _ @Type _

set number property _ title _ @Type _
maak getal eigenschap _ titel _ @Type _

set number property _ title _ min _ max _ @Type _
maak getal eigenschap _ titel _ min _ max _ @Type _

read only _
alleen lezen _

register event _ type _
registreer gebeurtenis _ type _

start WebThing server
start WebThing server

trigger event _
trigger gebeurtenis _

thing description JSON
WebThing beschrijving JSON

properties JSON
eigenschappen JSON

event definitions JSON
gebeurtenis definities JSON

events JSON
gebeurtenissen

####
# MiKe Robot library

MiKe front obstacle (cm)
MiKe obstakel voor (cm)

MiKe _ obstacle ?
Mike _ obstakel ?

MiKe black line on _ ?
MiKe zwarte lijn op _ ?

MiKe back light
MiKe achterlicht

MiKe IR
Mike IR

MiKe digital D8 sensor
MiKe digitale D8 sensor

MiKe stop motors
MiKe stop motors

MiKe Robot go _ at _ %
MiKe Robot ga _ met _ %

MiKe Robot speed _ %
MiKe Robot snelheid _ %

MiKe Robot direction _
MiKe Robot richting _

MiKe turn _ motor _
MiKe draai _ motor _

MiKe speed _ motor at _ %
MiKe snelheid _ motor met _ %

MiKe front lights off
MiKe koplampen uit

MiKe front lights to _
MiKe koplampen naar _

MiKe circle lights off
MiKe cirkel lichten uit

MiKe circle ligths to _
MiKe cirkel lichten naar _

MiKe circle light _ (1-18) to _
MiKe cirkel licht _ (1-18) naar _

MiKe rotate lights by _
MiKe draai lichten met _

MiKe digital D8 to _
MiKe digitale D8 naar _

####
# DrawBot Library
# A CoreXY plotter library that supports turtle geometry

plotter move X _ Y _
plotter verplaats X _ Y _

plotter move _ steps
plotter neem _ stappen

plotter turn _ degrees
plotter draai _ graden

plotter turn _ / _ of circle
plotter draai _ / _ van een cirkel

plotter point in direction _
plotter wijs naar richting _

plotter pen down
plotter pen neer

plotter pen up
plotter pen omhoog

plotter stop
plotter stop

set plotter speed to _ %
maak plotter snelheid naar _ %

####
# MQTT

MQTT connect to broker _
MQTT verbinden met broker _

buffer sizes _ client id _
buffer grootte _ client id _

username _ password _
gebruikersnaam _ wachtwoord _

MQTT connected
MQTT verbonden

MQTT disconnect
MQTT verbroken

MQTT sub _
MQTT sub _

testTopic
testOnderwerp

MQTT unsub _
MQTT unsub _

MQTT pub topic _ payload _
MQTT pub onderwerp _ payload _

Hello!
Hallo!

retain _ QoS _
behoud _ QoS _

MQTT event
MQTT gebeurtenis

binary _
binair _

topic for MQTT event _
onderwerp voor MQTT-gebeurtenis _

payload for MQTT event _
payload voor MQTT-gebeurtenis _

MQTT set will topic _ payload _ retain _ QoS _
MQTT zet will topic _ payload _ retain _ QoS _

testWill
testWill

Last will!
Laatste wil!

buffer sizes _
buffer groottes _

####
# UDP

UDP start port _
UDP start poort _

UDP stop
UDP stop

UDP send packet _ to ip _ port _
UDP zend pakket _ naar ip _ poort _

UDP receive packet
UDP pakket ontvangen

binary data _
binaire data _

UDP remote IP address
UDP IP-adres op afstand

UDP remote port
UDP IP-adres op afstand

####
# Cutebot

Cutebot
Cutebot

Cutebot set wheel left _ right _ (-100 to 100)
Cutebot maak wiel links _ rechts _ (-100 tot 100)

Cutebot stop wheels
Cutebot stop wielen

Cutebot set servo _ to _ degrees (-90 to 90)
Cutebot maak servo _ naar _ graden (-90 tot 90)

Cutebot set servo _ to speed _ (-100 to 100)
Cutebot maak servo _ naar snelheid _ (-100 tot 100)

Cutebot set headlight _ to _
Cutebot maak koplamp _ naar _

Cutebot set NeoPixel _ to _
Cutebot maak NeoPixel _ naar _

Cutebot _ line sensor
Cutebot _ lijnsensor

Cutebot sees line on left _ right _
Cutebot zie lijn op links _ rechts _

Cutebot distance (cm)
Cutbot afstand (cm)

left
links

right
rechts

both
beide

# Wukong

Wukong
Wukong

Wukong set motor _ to _ (-100 to 100)
Wukong maak motor _ naar _ (-100 tot 100)

Wukong stop motor _
Wukong stop motor _

Wukong stop all
Wukong stop alles

Wukong set servo _ to _ degrees (-90 to 90)
Wukong maak servo _ naar _ graden (-90 tot 90)

Wukong set servo _ to speed _ (-100 to 100)
Wukong maak servo _ naar snelheid _ (-100 tot 100)

Wukong set NeoPixels _ _ _ _
Wukong maak NeoPixels _ _ _ _

Wukong set LED brightness to _
Wukong maak LED helderheid naar _

####
# Sphero-RVR

wake
wakker worden

sleep
slapen

reset the yaw
reset het gieren

drive with speed _ and heading _
rijd met snelheid _ en richting _

set raw motors with left mode _ left speed _ right mode _ right speed _
maak raw-motoren met linkermodus _ linkersnelheid _ rechtermodus _ rechtersnelheid _

stop with heading _
stop met richting _

set RGB LED _ to red _ green _ blue _
maak het RGB LED _ op rood _ groen _ blauw _

set all LEDs to red _ green _ blue _
maak alle LEDs op rood _ groen _ blauw _

####
# Joystick:bit

button _ is pressed
knop _ is ingedrukt

rocker value of _
knuppel waarde van _

motor vibrate for _ ms
motor vibreert voor _ ms

####
# NeZha

NeZha
NeZha

NeZha set motor _ speed to _ %
NeZha maak motor _ snelheid naar _ %

NeZha stop motor _
NeZha stop motor _

NeZha stop all motors
NeZha stop alle motors

NeZha set _ servo _ angle to _
NeZha maak _ servo _ hoek naar _

NeZha set continuous rotation servo _ speed to _ %
NeZha maak continue rotatie servo _ snelheid naar _ %

##################
# MicroBlocks UI #
##################

# buttons, error & info messages, dialog boxes, etc

New
Nieuw

Open
Open

Open from board
Open vanaf board

Copy project URL to clipboard
Kopieer project URL naar klembord

Information
Informatie

Plug in the board.
Sluit het board aan

Plug in the board and click the USB icon to connect.
Sluit het board aan klik op het USB icoon om te verbinden.

Reading project from board...
Project lezen van het bord...

Loading project...
Project laden

Found a newer version of
Een nieuwere versie gevonden van

Do you want me to update the one in the project?
Wil je dat ik die ene in het project update?

Save
Bewaar

Connect
Verbind

connect
verbind

open Boardie
open Boardie

disconnect
verbreek verbinding

Serial port:
SeriÃ«le poort:

other...
ander...

none
geen

Port name?
Poort naam?

Board type:
Board type:

Select board:
Selecteer board:

Could not read:
Kon niet lezen:

by
door

Created with GP
Gemaakt met GP

More info at http://microblocks.fun
Meer info op http://microblocks.fun

Function "
Functie "

" is too large to send to board.
" is te groot om naar board te zenden.

Script is too large to send to board.
Script is te groot om naar board te zenden.

Use "Connect" button to connect to a MicroBlocks device.
Gebruik "Verbind" knop om te verbinden met een MicroBlocks device.

No boards found; is your board plugged in?
Geen boards gevonden; is je board aangesloten?

For AdaFruit boards, double-click reset button and try again.
Voor AdaFruit boards, dubbelklik op de reset knop en probeer het opnieuw.

Only recent Chrome and Edge browsers support WebSerial.
Alleen recente Chrome en Edge browsers ondersteunen WebSerial.

The board is not responding.
Het board reageert niet.

Try to Install MicroBlocks on the board?
Proberen om MicroBlocks op het board te installeren?

The MicroBlocks in your board is not current
De MicroBlocks op je board is niet actueel.

Try to update MicroBlocks on the board?
Proberen om MicroBlocks op het board te updaten?

MicroBlocks
MicroBlocks

Stop
Stop

Start
Start

Quit MicroBlocks?
MicroBlocks verlaten?

Discard current project?
Huidig project weggooien?

# Scripting area right-click context menu

set block size...
maak blokgrootte ...

make blocks bigger or smaller
maak blokken groter of kleiner

clean up
opruimen

arrange scripts
arrangeer scripts

undrop (ctrl-Z)
ongedaan (ctrl-Z)

undo the last block drop
maak het laatste plaatsen van blokken ongedaan

copy all scripts to clipboard
kopieer alle scripts naar klembord

copy all scripts to clipboard as URL
kopieer alle scripts naar het klembord als URL

paste all scripts
plak alle scripts

paste script
plak script

paste script from clipboard
plak script vanuit het klembord

save a picture of all visible scripts
bewaar een afbeelding van alle zichtbare scripts

set exported script scale
maak geÃ«xporteerde script grootte

small (50%)
klein (50%)

normal (65%)
normaal (65%)

large (100%)
groot (100%)

printable (200%)
afdrukbaar (200%)

about...
over...

About MicroBlocks
Over MicroBlocks

virtual machine version
virtuele machine versie

update firmware on board
update firmware op board

show data graph
toon data grafiek

set serial delay
maak seriÃ«le vertraging

firmware version
firmware versie

start WebThing server
start WebThing server

stop WebThing server
stop WebThing server

HTTP Server
HTTP Server

MicroBlocks HTTP Server listening on port 6473
MicroBlocks HTTP Server luistert op poort 6473

disable autoloading board libraries
schakel autoloading board bibliotheken uit

enable autoloading board libraries
schakel autoloading board bibliotheken in

enable PlugShare when project empty
PlugShare inschakelen als project leeg is

disable PlugShare when project empty
PlugShare uitschakelen als project leeg is

when plugging a board, do not automatically read its contents into the IDE even if the current project is empty
wanneer je een board verbindt, zet dan niet automatisch de inhoud in de IDE, zelfs als het huidige project leeg is

when plugging a board, automatically read its contents into the IDE if the current project is empty
wanneer je een board verbindt, zet dan automatisch de inhoud in de IDE als het huidige project leeg is

erase flash and update firmware on ESP board
flash wissen en firmware op ESP-bord updaten

Use board type
Gebruik board type

Firmware Installed
Firmware geÃ¯nstalleerd

Reconnect to the board by clicking the "Connect" button (USB icon).
Opnieuw verbinden met het board door op de "Verbind" knop the klikken. (USB icoon).

Connect USB cable while holding down the white BOOTSEL button before proceeding.
Verbind de USB kabel terwijl je de witte BOOTSEL knop ingedrukt houd voordat je verder gaat.

You will be asked to save the firmware file.
Je zult worden gevraagd om het firmware bestand op te slaan.

Select
Selecteer

as the destination drive, then click Save.
als de bestemmings schijf, klik daarna op Bewaar.

Installing firmware...
Installeer firmware...

Plug in the board.
Sluit het board aan

Wiping board...
Board wissen ...

(press ESC to cancel)
(druk ESC om te annuleren)

Done!
Klaar!

download and install latest VM
download en installeer de nieuwste VM

Select board type:
Selecteer board type:

Uploading MicroBlocks to board...
MicroBlocks opladen naar board...

copy data to clipboard
kopieer data naar klembord

clear data
wis data

clear memory and variables
wis geheugen en variabelen

show advanced blocks
toon geavanceerde blokken

export functions as library
exporteer functies als bibliotheek

hide advanced blocks
verberg geavanceerde blokken

put file on board
zet het bestand op het board

get file from board
haal het bestand van het board

uploaded
geÃ¼pload

downloaded
gedownload

Data Graph
Data Grafiek

Graph
Grafiek

clear graph
wis grafiek

zero at bottom
nul aan de onderkant

zero in middle
nul in het midden

export data to CSV file
exporteer de data naar een CSV bestand

import data from CSV file
importeer data van een CSV bestand

copy graph data to clipboard
kopieer de grafiek data naar het klembord

show instructions
toon instructies

show compiled bytes
toon gecompileerde bytes

expand
uitklappen

collapse
inklappen

rename...
hernoem...

find variable accessors
vind variabele toegangspunten

find scripts or block definitions where this variable is being read
vind scripts of blok definities waar deze variable word uitgelezen

find variable modifiers
vind variabele aanpassingen

find scripts or block definitions where this variable is being set or changed
vind scripts of blok definities waar deze variabele wordt ingesteld of veranderd

find uses of this block
vind plekken waar dit blok word toegepast

find scripts or block definitions using this block
vind scripts of blok definities die dit blok gebruiken

show block definition...
toon blok definitie...

show the definition of this block
toon de definitie van dit blok

delete block definition...
verwijder blok definitie...

delete the definition of this block
verwijder de definitie van dit blok

duplicate
dupliceer

help
help

duplicate this block
dupliceer dit blok

delete block
verwijder blok

delete this block
verwijder dit blok

just this one block
alleen dit ene blok

copy to clipboard
kopieer naar klembord

copy to clipboard as URL
kopieer naar klembord als URL

copy these blocks to the clipboard as a URL
kopieer deze blokken naar het klembord als een URL

copy these blocks to the clipboard
kopieer deze blokken naar het klembord

duplicate all
dupliceer alles

duplicate these blocks
dupliceer deze blokken

extract block
extract blok

pull out this block
trek dit blok er uit

show help for this block in a browser
laat hulp zien voor dit blok in een browser

save picture of script
bewaar een afbeelding van het script

save picture of script with result
bewaar een afbeelding van het script met een resultaat

save a picture of this block definition as a PNG file
bewaar een afbeelding van deze blok definitie als een PNG bestand

save a picture of these blocks as a PNG file
bewaar een afbeelding van deze blokken als een PNG bestand

save a picture of these blocks and their result as a PNG file
bewaar een afbeelding van deze blokken en hun resultaat als een PNG bestand

copy script
kopieer script

delete
verwijder

Input type:
Input type:

string only
alleen tekst

string or number
tekst of nummer

number only
alleen nummer

stop editing
stop bewerken

cut
knip

copy
kopie

paste
plakken

accept
accepteren

revert
terugdraaien

select all
alles selecteren

define
definieer

number/string
nummer/tekst

editable number or string
bewerkbaar nummer of tekst

label
label

input
input

hide block definition
verberg blok definitie

Are you sure you want to remove this block definition?
Weet je zeker dat je deze blok definitie wil verwijderen?

Language
Taal

Custom...
Aangepast...

Obsolete
Verouderd

OK
OK

Ok
Ok

Yes
Ja

No
Nee

Cancel
Annuleren

Okay
OkÃ©

Confirm
Bevestig

# Library folders

Libraries
Bibliotheken

AI
AI

Graphics and Displays
Graphics en schermen

Kits and Boards
Kits en Boards

Network
Netwerk

Other
Ander

Robots
Robots

Sensing
Sensoren

Sound
Geluid

System
Systeem

# File picker and library dialogs

New library name?
Naam nieuwe bibliotheek?

show all block definitions
toon alle blok definities

hide all block definitions
verberg alle blok definities

export this library
exporteer deze bibliotheek

delete library
verwijder bibliotheek

Examples
Voorbeelden

Desktop
Bureaublad

Computer
Computer

Cloud
Cloud

File
Bestand

File Open
Bestand openen

File Save
Bestand opslaan

File name:
Bestandsnaam:

New Folder
Nieuwe Map

by
door

Depends:
Vereist:

Tags:
Tags:

Path, name or URL for library?
Pad, naam of URL voor bibliotheek?

Invalid URL
Ongeldige URL

Could not fetch library.
Kon bibliotheek niet ophalen.

Host does not exist or is currently down.
Host bestaat niet of is momenteel niet beschikbaar.

File not found in server.
Bestand niet gevonden op server.

Server expects HTTPS, and MicroBlocks doesn't currently support it.
Server verwacht HTTPS, en MicroBlocks ondersteunt HTTPS niet.

library information
bibliotheekinformatie

built-in library
ingebouwde bibliotheek

Dependency path, name or URL?
Afhankelijkheid pad, naam, of URL

If you are adding a library that's built into MicroBlocks, you can just enter its name.
Als je een bibliotheek toe wil voegen die ingebouwd is in MicroBlocks dan hoef je enkel de naam in te voeren.

If your library is in the Libraries folder in your local MicroBlocks project folder, you need to prefix it with a slash (/).
Als je bibliotheek zich in de Bibliotheek map van je lokale MicroBlocks project map bevindt, dan moet je het laten vooraf gaan door een slash (/).

If the library is hosted online, please input its full URL.
Als de bibliotheek online staat, geef dan de hele URL op.

Tag name?
Tag naam?

user library
gebruikers bibliotheek

Add Library
Bibliotheek toevoegen

seconds remaining
resterende seconden

Decrease block size
Maak de blokgrootte kleiner

Restore block size to 100%
Herstel de blokgrootte naar 100%

Increase block size
Maak de blokgrootte groter

############
# Tips Bar #
############

Button
Knop

Boolean Input
Booleaanse input

[l] toggle value, or drop a reporter into it.
[l] wissel de waarde of zet er een reporter blok in.

Color Input
Kleur input

[l] change the color, or drop a reporter into it.
[l] verander de kleur of zet er een reporter blok in.

Input
Input

[l] edit its value, or drop a reporter into it.
[l] bewerk de waarde of zet er een reporter blok in.

Block Extension
Blok uitbreiden

[l] right arrow to show optional inputs, left arrow to hide.
[l] rechter pijl om extra inputs te laten zien, linker pijl of ze te verbergen.

Command Block
Commando blok

[l] to run, or drag to build scripts. [r] menu.
[l] om uit te voeren of te slepen om scripts te bouwen. [r] menu.

Hat Block
Hat blok

[l] to run, or drag to build scripts. [r] menu.
[l] om uit te voeren of te slepen om scripts te bouwen. [r] menu.

Reporter Block
Reporter blok

[l] to see value, or drop into an input slot. [r] menu.
[l[ om de waarde te zien of neer te zetten in een input opening. [r] menu.

Script
Script

[l] to run. [r] menu.
[l] om uit te voeren. [r] menu.

Pane Divider
Paneel verdeler

Drag to change pane width.
Sleep om paneel breedte te veranderen.

Library
Bibliotheek

[l] to show the blocks in this library. [r] menu.
[l] om de blokken in deze bibliotheek te laten zien. [r] menu.

Block Category
Blok categorie

[l] to show the blocks in this category.
[l] om de blokken in deze categorie te laten zien.

Palette
Palet

Drag blocks from here to build scripts. Drop scripts here to delete them.
Sleep blokken vanuit hier om scripts te maken. Zet scripts hier neer om ze te verwijderen.

Scripts Pane
Script paneel

Drag blocks here to build scripts. [r] menu.
Sleep blokken naar hier om scripts te maken. [r] menu.

#################################
# Block Descriptions for TipBar #
#################################

Turn the user LED on or off.
Zet de gebruikers LED aan of uit.

Display a bubble showing the value.
Laat een textballon met de waarde zien.

Graph the value.
Maak een grafiek van de waarde.

Report the state of button A ( (-o) or (o-) ).
Laat de status van knop A zien ( (-o) or (o-) ).

Report the state of button B ( (-o) or (o-) ).
Laat de status van knop B zien ( (-o) or (o-) ).

Report the milliseconds since the timer was last reset.
Laat de milliseconden zien vanaf de laatste keer dat de timer was gereset.

Reset the timer.
Reset de timer.

Report the milliseconds since power up.
Laat het aantal milliseconden zien sinds het opstarten.

Report the microseconds since power up.
Geef het aantal microseconden sinds het opstarten.

Report the board type.
Geef het board type.

Report the electrical logic level on a digital pin ( (-o) or (o-) ).
Geef het elektrische logische niveau op een digitale pin ( (-o) of (o-) ).

Report a number proportional to the voltage on an analog pin (0 = ground, 1023 = supply voltage).
Geef een getal dat evenredig is met de spanning op een analoge pin (0 = aarde, 1023 = toevoerspanning).

Turn a pin on or off ( (-o) or (o-) ).
Zet een pin aan of uit ( (-o) or (o-) ).

Pulse width modulate (PWM) a pin with the given duty cycle (0 - 1023).
Pulsbreedte moduleren (PWM) van een pin met de opgegeven inschakelduur (0 - 1023).

Report number of analog pins on this device.
Geef het aantal analoge pinnen op dit apparaat.

Report number of digital pins on this device.
Geef het aantal digitale pinnen  op dit apparaat.

Report the value of a register (0-255) of an I2C device (0-127).
Geef de waarde van een register (0-255) van een I2C-apparaat (0-127).

Set an I2C device and register to given value (0-255).
Maak een I2C-apparaat en -register een gegeven waarde (0-255).

Receive multiple bytes from an I2C device.
Ontvang meerdere bytes van een I2C apparaat

Send multiple bytes to an I2C device.
Stuur meerdere bytes naar een I2C apparaat.

Send a byte (0-255) to an SPI device.
Stuur een byte (0-255) naar een SPI apparaat.

Read a byte from an SPI device while sending a zero byte. Report the byte received.
Lees een byte van een SPI apparaat terwijl je een nul byte verstuurt. Geef de ontvangen byte.

Set the SPI clock speed and mode.
Stel de SPI kloksnelheid en modus in.

Send a byte array via SPI, replacing its contents with the bytes received.
Zend een byte-array via SPI, waarbij de inhoud wordt vervangen door de ontvangen bytes.

Open the serial port at the given baud rate.
Open de seriÃ«le poort met de opgegeven baudrate.

Close the serial port.
Sluit de seriÃ«le poort.

Report data received from the serial port (a byte array).
Geef de gegevens ontvangen van de seriÃ«le poort  (een byte-array).

Send a byte array to the serial port.
Zend een byte-array naar de seriÃ«le poort.

Run when the board powers up or when the IDE start button is clicked.
Uitvoeren wanneer het bord wordt ingeschakeld of wanneer op de IDE-startknop wordt geklikt.

Run when buttons A, B, or A+B are pressed.
Uitvoeren wanneer knoppen A, B of A+B worden ingedrukt.

Repeat the enclosed blocks indefinitely.
Herhaal de ingesloten blokken voor altijd.

Repeat the enclosed blocks the given number of times.
Herhaal de ingesloten blokken het opgegeven aantal keer.

Wait the given number of milliseconds.
Wacht het aantal opgegeven milliseconden.

Run the first set of blocks whose test condition is (-o) .
Uitvoeren van de eerste reeks blokken met als testvoorwaarde (-o) .

Run when the condition becomes (-o) .
Uitvoeren wanneer de conditie (-o) wordt.

Wait until the condition becomes (-o) .
Wacht totdat de conditie (-o) wordt.

Return (report) the given value from a function or script.
Meld de gegeven waarde uit een functie of script.

Run when the given message is broadcast.
Uitvoeren als het opgegeven bericht is verstuurd.

Broadcast the given message.
Verstuur het opgegeven bericht.

Do nothing. Used to add notes and documentation.
Doe niks. Wordt gebruikt om opmerkingen en documentatie toe te voegen.

Repeat the enclosed blocks with the variable set to the current iteration number or item.
Herhaal de ingesloten blokken met de variabele ingesteld op het huidige iteratienummer of item.

Repeat the enclosed blocks until the condition becomes (-o) .
Herhaald de ingesloten blokken totdat de conditie (-o) wordt.

Stop this task.
Stop deze taak.

Stop all tasks except this one.
Stop alle taken behalve deze.

Wait the given number of microseconds.
Wacht het opgegeven aantal microseconden.

Report the last broadcast message received.
Geef het laatst ontvangen bericht.

Call the function with the given name and optional parameter list.
Roep de functie aan met de gegeven naam en optionele parameterlijst.

Call the function with the given name and optional parameter list and report its return value.
Roep de functie met de gegeven naam en optionele parameterlijst aan en geefde retourwaarde.

Report the sum of the given numbers.
Geef de som van de gegeven nummers.

Report the first number minus the second.
Geef het resultaat van het eerste nummer min het tweede.

Report the product of the given numbers.
Geef het resultaat van de gegeven nummers.

Report the first number divided by the second.
Geef het resultaat van het eerste nummer gedeeld door het tweede.

Report the remainder of dividing the first number by the second.
Geef de rest van het delen van het eerste getal door het tweede.

Report the absolute value of the given number (always >= 0).
Geef de absolute waarde van het gegeven getal (altijd >= 0).

Report the minimum of the values.
Geef de laagste waarde zien.

Report the maximum of the values.
Geef de grootste waarde.

Report a randomly chosen number in the given range.
Geef een willekeurig gekozen nummer binnen het opgegeven bereik.

Report (-o) if the first value is less than the second one.
Geef (-o) als de eerste waarde kleiner is dan de tweede.

Report (-o) if the first value is less than or equal to the second one.
Geef (-o) als de eerste waarde kleiner of gelijk is aan de tweede.

Report (-o) if the two values are equal.
Geef (-o) als de twee waarden gelijk zijn.

Report (-o) if the two values are not equal.
Geef (-o) als de twee waarden niet gelijk zijn.

Report (-o) if the first value is greater than or equal to the second one.
Geef (-o) als de eerste waarde groter of gelijk is aan de tweede.

Report (-o) if the first value is greater than the second one.
Geef (-o) als de eerste waarde groter is dan de tweede.

Boolean constant ( (-o) or (o-) ).
Booleaanse constante ( (-o) or (o-) ).

Report the logical inverse of a Boolean ( (-o) or (o-) ) value.
Geef de logische tegenpool van een Booleaanse ( (-o) of (o-) ) waarde.

Report (-o) if both values are (-o)
Geef (-o) als beide waren (-o) zijn

Report (-o) if either value is (-o)
Geef (-o) als een van de waardes (-o) is

Report (-o) if first input is a value of the given data type.
Geef (-o) als de eerste invoer een waarde is van het gegevenstype.

Report the numerical value of a hexadecimal string (range: -0x1FFFFFFF to 0x1FFFFFFF)
Geef de numerieke waarde van een hexadecimale string (bereik: -0x1FFFFFFF tot 0x1FFFFFFF)

Report bitwise AND of two numbers.
Geef de bitgewijze AND van twee nummers.

Report bitwise OR of two numbers.
Geef de bitgewijze OR van twee nummers.

Report bitwise XOR (exclusive OR) of two numbers.
Geef de bitgewijze XOR (exclusive OR) van twee nummers.

Report bitwise inverse of the given number.
Geef de bitgewijze inverse van het gegeven getal.

Report the given number shifted left by the given number of bits.
Geef het gegeven getal links verschoven met het gegeven aantal bits.

Report the given number shifted right by the given number of bits (arithmetic shift; sign is maintained).
Geef het gegeven getal rechts verschoven met het gegeven aantal bits (rekenkundige verschuiving; teken blijft behouden)

Set a variable to the given value.
Geef een variabele de opgegeven waarde.

Change a variable by the given amount.
Verander een variabele met de gegeven waarde.

Create a variable local to the containing script with the given initial value.
Maak een lokale variabele in het script met de opgegeven beginwaarde.

Report the Nth item of a list, string, or byte array.
Geef het N-de item van een lijst, tekenreeks of een byte-array.

Report the number of items in a list, string, or byte array.
Geef het aantal items in een lijst, tekenreeks of byte array.

Join (concatenate) the given lists, strings, or byte arrays and report the result.
Voeg de opgegeven lijsten, tekenreeksen of byte arrays samen en geef het resultaat.

Create and report a short list containing the given items. Length limited by available stack space.
Maak en geef een korte lijst met de gegeven items. Lengte beperkt door beschikbare stapelruimte.

Add an item to the end of a list.
Voeg een item toe aan het einde van een lijst.

Replace the Nth item (or all items) of a list or byte array with the given value.
Vervang het N-de item (of alle items) van een lijst of byte-array door de gegeven waarde.

Delete the Nth item (or all items) of a list.
Verwijder het N-de item (of alle items) van een lijst.

Find and report the index of an item in a list or a substring within a string. Report -1 if not found.
Vind en geef de index van een item in een lijst of een substring in een string. Geef -1 indien niet gevonden.

Report a copy from the given index through the end (or optional stop index) of the given list, string, or byte array.
Geef een kopie vanaf de opgegeven index tot het einde (of optionele stopindex) van de opgegeven lijst, tekenreeks of byte-array.

Split the given string with the given delimiter and report the result (a list of strings).
Splits de gegeven tekenreeks met het gegeven scheidingsteken en geef het resultaat (een lijst van tekenreeksen).

Combine the items of a list into a string, optionally separated by a delimiter (e.g. comma).
Combineer de items van een lijst in een tekenreeks, optioneel gescheiden door een scheidingsteken (bv. komma).

Report the Unicode value ("code point") of the Nth character of the given string.
Geef de Unicode-waarde ("codepunt") van het N-de teken van de gegeven string.

Report a string containing the given Unicode value ("code point") or list of values.
Geef een tekenreeks door, die de gegeven Unicode-waarde ("codepunt") of lijst van waarden bevat.

Report a new list of the given length filled with zero or the optional value.
Geef een nieuwe lijst van de gegeven lengte, gevuld met nul of de optionele waarde.

Report a new byte array of the given length filled with zero or the optional value.
Geef een nieuwe byte-array van de gegeven lengte, gevuld met nul of de optionele waarde.

Report a byte array containing the UTF-8 bytes of the given string.
Geef een byte-array met de UTF-8 bytes van de gegeven string.

Report the number of words of memory available. Stop button frees up memory.
Geef het aantal beschikbare woorden geheugen aan. Stoptoets maakt geheugen vrij.
# MicroBlocks translation file
# Last updated: February 05 2021

#########################
# Blocks and categories #
#########################

Output
SaÃ­da

set user LED _
coloque o LED integrado em _

say _
mostre _

graph _
mostre no grÃ¡fico _

Input
Entrada

button A
botÃ£o A

button B
botÃ£o B

microseconds
microsegundos

milliseconds
milisegundos

board type
tipo de placa

Pins
Pinos

read digital pin _
leitura digital _

read analog pin _
leitura analÃ³gica _

set digital pin _ to _
coloque pino digital _ em _

set pin _ to _
mude o valor do pino _ para _

analog pins
pinos analÃ³gicos

digital pins
pinos digitais

Control
Controle

when started
quando iniciar

when button _ pressed
quando pressionar o botÃ£o _

forever _
para sempre _

repeat _ _
repita _ vezes _

wait _ millisecs
espere _ milisegundos

if _ _
se _ _

else if _ _
entÃ£o, se _ _

if _ _ else _
se _ _ entÃ£o _

else
entÃ£o

when _
quando _

wait until _
espere atÃ© que _

wait _ microsecs
espere _ microsegundos

return _
retorne _

when _ received
ao receber _

broadcast _
envie _

comment _
comentÃ¡rio _

for _ in _ _
para cada _ em _ _

repeat until _ _
repita atÃ© que _ _

stop this task
pare esta tarefa

stop other tasks
pare as outras tarefas

stop all
pare tudo

last message
Ãºltima mensagem

Operators
Operadores

_ mod _
_ mÃ³dulo _

abs _
valor absoluto de _

random _ to _
nÃºmero aleatÃ³rio entre _ e _

not _
nÃ£o _

_ and _
_ e _

and _
e _

_ or _
_ ou _

or _
ou _

_ is a _
_ Ã© um _

boolean
booleano

number
nÃºmero

string
texto

list
lista

Advanced:
AvanÃ§ado:

hex _
hexadecimal _

Variables
VariÃ¡veis

# Buttons on top of "Variables" category

Add a variable
Criar uma variÃ¡vel

Delete a variable
Apagar uma variÃ¡vel

# New variable dialog

New variable name?
Nome da variÃ¡vel?

set _ to _
mude _ para _

change _ by _
altere _ em _

initialize local _ to _
inicialize variÃ¡vel local _ em _

Data
Dados

list
lista

length of _
tamanho de _

item _ of _
elemento _ de _

replace item _ of list _ with _
substitua elemento _ da lista _ por _

delete item _ of list _
apague elemento _ da lista _

add _ to list _
adicione _ Ã  lista _

join _ _
una _ _

copy _ from _
copie _ desde _

to _
atÃ© _

find _ in _
encontre _ em _

starting at _
comece a partir de _

join items of list _
una elementos da lista _

separator _
usando separador _

unicode _ of _
unicode _ de _

string from unicode _
texto com unicode _

new list length _
nova lista de tamanho _

new byte array _
novo vetor de bytes _

free memory
memÃ³ria livre

My Blocks
Meus blocos

# Buttons on top of "My Blocks" category

Add a command block
Criar um bloco de comandos

Add a reporter block
Criar um bloco repÃ³rter

# Make a block dialog

Enter function name:
Nome da funÃ§Ã£o:

Comm
ComunicaÃ§Ãµes

i2c get device _ register _
leia do dispositivo i2c _ o registrador _

i2c set device _ register _ to _
escreva no dispositivo i2c _ o registrador _ com _

i2c device _ read list _
leia o dispositivo i2c _ para a lista _

i2c device _ write list _
escreva no dispositivo i2c _ o conteÃºdo da lista _

spi send _
spi a enviar _

spi receive
spi a receber

print _
escreva _

no op
nÃ£o op

ignore
ignore

##############
# Primitives #
##############

# These are all mostly hidden from end users

draw shape _ at x _ y _
desenhe forma _ em x _ y _

shape for letter _
forma para letra _

send NeoPixel rgb _
envie RGB _ ao NeoPixel

has tone support
tem suporte para tons

play tone pin _ frequency _
toque um tom no pino _ com a frequÃªncia _

has WiFi support
tem suporte para WiFi

start WiFi _ password _
inicie WiFi _ com a senha _

stop WiFi
termine WiFi

WiFi status
estado do WiFi

my IP address
meu endereÃ§o IP

radio send number _
envie nÃºmero _ por rÃ¡dio

radio send string _
envie texto _ por rÃ¡dio

radio send pair _ = _
envie associaÃ§Ã£o _ = _ por rÃ¡dio

radio message received?
mensagem de rÃ¡dio recebida?

radio last number
Ãºltimo nÃºmero recebido por rÃ¡dio

radio last string
Ãºltimo texto recebido por rÃ¡dio

radio last message type
tipo da Ãºltima mensagem recebida por rÃ¡dio

radio set group _
fixe grupo de rÃ¡dio a _

radio set channel (0-83) _
fixe canal de rÃ¡dio a (0-83) _

radio set power (0-7) _
fixe potÃªncia de rÃ¡dio a (0-7) _

radio last signal strength
intensidade do Ãºltimo sinal de rÃ¡dio

radio receive packet _
receba pacote por rÃ¡dio _

radio send packet _
envie pacote por radio _

disable radio
desabilite rÃ¡dio

#############
# Libraries #
#############

Basic Sensors
Sensores bÃ¡sicos

tilt x
inclinaÃ§Ã£o x

tilt y
inclinaÃ§Ã£o y

tilt z
inclinaÃ§Ã£o z

acceleration
aceleraÃ§Ã£o

light level
nÃ­vel de luz

temperature (Â°C)
temperatura (Â°C)

####
# NeoPixel library

NeoPixel
NeoPixel

set NeoPixels _ _ _ _ _ _ _ _ _ _
defina NeoPixels _ _ _ _ _ _ _ _ _ _

clear NeoPixels
apague NeoPixels

set NeoPixel _ color _
defina NeoPixel _ de cor _

set all NeoPixels color _
defina todos os NeoPixels de cor _

rotate NeoPixels by _
gire NeoPixels em _

color r _ g _ b _ (0-255)
cor r _ g _ b _ (0-255)

random color
cor aleatÃ³ria

attach _ LED NeoPixel strip to pin _
inicialize a fita _ de NeoPixel no pino _

has white _
com branco _

PIR
Sensor de movimento

PIR at pin _ detected movement
Movimento detectado por PIR no pino _

####
# Citilab ED1 board libraries

ED1 Stepper Motor
Motores ED1

move motor _ _ steps _
mova motor _ _ passos _

move motor 1 _ and motor 2 _ _ steps
mova motor 1 _ e motor 2 _ _ passos

move motor _ angle _ Â°
mova motor _ Ã¢ngulo _ Â°

move motor _ _ complete turns
mova motor _ _ voltas completas

stop steppers
pare os motores

clockwise
sentido horÃ¡rio

counter-clockwise
sentido anti-horÃ¡rio

ED1 Buttons
BotÃµes ED1

button OK
botÃ£o OK

button X
botÃ£o X

button up
botÃ£o cima

button down
botÃ£o baixo

button left
botÃ£o esquerda

button right
botÃ£o direita

capacitive sensor _
sensor capacitivo _

set capacitive threshold to _
fixe limite capacitivo em _

####
# BirdBrain Technologies libraries

Hummingbird LED _ _ %
Hummingbird LED _ _ %

Hummingbird Tri-LED _ R _ % G _ % B _ %
Hummingbird LED tricolor _ R _ % G _ % B _ %

Hummingbird Position Servo _ _ Â°
Hummingbird Servo Posicional _ _ Â°

Hummingbird Rotation Servo _ _ %
Hummingbird Servo de RotaÃ§Ã£o _ _ %

Hummingbird _ _
Hummingbird _ _

Hummingbird Battery (mV)
Hummingbird Bateria (mV)

Light
Luz

Distance (cm)
DistÃ¢ncia (cm)

Dial
Dial

Sound
Som

Other
Outro

Finch Beak Red _ Green _ Blue _
Cor do Bico do Finch R _ % G _ % B _ %

Finch Tail _ Red _ Green _ Blue _
Cor da Cauda do Finch R _ % G _ % B _ %

Finch Move _ _ cm at _ %
Mover o Finch _ _ cm  Ã  velocidade de _ %

Finch Turn _ _ Â° at _ %
Girar o Finch _ _ Â° Ã  velocidade de _ %

Finch Wheels L _ % R _ %
Rodas do Finch Ã  velocidade E _ % D _ %

Finch Stop
Para o Finch

Finch Distance (cm)
DistÃ¢ncia do Finch (cm)

Finch _ Light
Luz _ do Finch

Finch _ Line
Linha _  do Finch

Finch Reset Encoders
Reinicia os contadores de voltas do Finch

Finch _ Encoder
Contador de voltas _

Finch Accelerometer _
AcelerÃ´metro do Finch _

Finch Battery
NÃ­vel de bateria do Finch

All
Todos

Forward
Frente

Backward
AtrÃ¡s

Right
Direita

Left
Esquerda

Beak Up
Bico para cima

Beak Down
Bico para baixo

Tilt Left
InclinaÃ§Ã£o Ã  esquerda

Tilt Right
InclinaÃ§Ã£o Ã  direita

Level
Plano

Upside Down
CabeÃ§a para baixo

x
x

y
y

z
z

strength
potÃªncia

####
# Ultrasound distance library

distance (cm) trigger _ echo _
distÃ¢ncia (cm) trigger _ echo _

####
# Infrared remote library

IR Remote
Infravermelho

receive IR code
receba cÃ³digo IR

receive IR code from device _
receba cÃ³digo IR do dispositivo _

test IR
teste IR

attach IR receiver to pin _
inicializa receptor IR no pin _

####
# Radio comm library
# Allows micro:bit boards to exchange messages
# All of its blocks are primitive (see "Primitives" section)

Radio
RÃ¡dio

####
# Text scrolling library
# Scrolls text on 5x5 LED displays and simulated ones

Scrolling
Texto animado

scroll text _
anime o texto _

scroll number _
anime o nÃºmero _

pausing _ ms
pause por _ ms

stop scrolling
pare a animaÃ§Ã£o

####
# Servo motor library

Servo
Servomotores

set servo _ to _ degrees (-90 to 90)
fixe o servo _ a _ graus (-90 a 90)

set servo _ to speed _ (-100 to 100)
gire o servo _ Ã  velocidade de _ (-100 a 100)

stop servo _
pare o servo _

####
# 5x5 LED display library
# Supports the micro:bit display, but also simulated 5x5 displays on boards
# with differently sized LED arrays, NeoPixel arrays or TFT displays

LED Display
Display LED

display _
display _

clear display
apague display

plot x _ y _
acenda x _ y _

unplot x _ y _
apague x _ y _

display character _
mostre caractere _

####
# TFT display library

enable TFT _
ative TFT _

TFT width
largura do TFT

TFT height
altura do TFT

set TFT pixel x _ y _ to _
pinte o pÃ­xel x _ y _ com a cor _

draw line on TFT from x _ y _ to x _ y _ color _
desenhe linha de x _ y _ a x _ y _ com cor _

draw rectangle on TFT at x _ y _ width _ height _ color _
desenhe retÃ¢ngulo em x _ y _ largura _ altura _ com cor _

draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _
desenhe retÃ¢ngulo arredondado em x _ y _ largura _ altura _ raio _ com cor _

draw circle on TFT at x _ y _ radius _ color _
desenhe cÃ­rculo em x _ y _ raio _ com cor _

draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _
desenhe triÃ¢ngulo em x _ y _ , x _ y _ , x _ y _ com cor _

filled _
preenchido _

write _ on TFT at x _ y _ color _
escreva _ em x _ y _ com cor _

scale _ wrap _
escale _ com saltos de linha _

####
# Tone library
# Generates music tones on buzzers

Tone
Tons

attach buzzer to pin _
inicialize campainha no pino _

play note _ octave _ for _ ms
toque a nota _ na oitava _ por _ ms

play frequency _ for _ ms
toque a frequÃªncia _ por _ ms

play midi key _ for _ ms
toque a tecla MIDI _ por _ ms

####
# Turtle geometry library

Turtle
Tartaruga

home
volte para casa

move _
mova _ passos

turn _ degrees
gire _ graus

turn _ / _ of circle
gire _ / _ de volta

pen down
baixe o lÃ¡pis

pen up
suba o lÃ¡pis

set pen color to _
fixe a color do lÃ¡pis em _

set pen to random color
fixe uma cor aleatÃ³ria para o lÃ¡pis

fill display with _
preencha a tela com a cor _

go to x _ y _
vÃ¡ para x _ y _

point in direction _
aponte na direÃ§Ã£o _

####
# File system library

Files
Arquivos

open file _
abra arquivo _

close file _
feche arquivo _

delete file _
apague arquivo _

append line _ to file _
adicione linha _ no arquivo _

append bytes _ to file _
adicione bytes _ no arquivo _

end of file _
fim do arquivo _

next line of file _
linha seguinte do arquivo _

next _ bytes of file _
prÃ³ximos _ bytes do arquivo _

starting at _
comece a partir de _

file names
nomes de arquivos

size of file _
tamanho do arquivo _

file system info
detalhes do sistema de arquivos

####
# WiFi library

WiFi
WiFi

wifi connect to _ password _ try _ times
ligue Ã  rede wifi _ com a senha _ em _ tentativas

wifi create hotspot _ password _
crie um ponto de acesso wifi _ com a senha _

IP address
endereÃ§o IP

####
# Motion library
# Counts steps and detects motion via the internal accelerometer

Motion
Movimento

motion
movimento

start step counter
comece a contar passos

step count
contagem de passos

clear step count
apague contagem de passos

set step threshold _ (0-50)
fixe o limite de passos em _ (0-50)

####
# Button Events library

Button Events
Eventos de botÃ£o

button _ double pressed
duplo clique no botÃ£o _

button _ long pressed
clique longo no botÃ£o _

button _ pressed
clique no botÃ£o  _

####
# Calliope board library

Calliope set LED red _ green _ blue _
fixe o LED do Calliope em vermelho _ verde _ azul _

Calliope set speaker _
fixe o alto-falante do Calliope em _

Calliope loudness
Volume sonoro do Calliope

####
# Circuit Playground Express board library

Circuit Playground set speaker _
fixe o alto-falante do Circuit Playground em _

Circuit Playground slide switch
interruptor do Circuit Playground

####
# DotStar LED library

attach _ DotStar LEDs to data pin _ clock pin _
inicialize fita de _ LEDs DotStar no pino de dados _ e pino de relÃ³gio _

set all DotStar LEDs to r _ g _ b _
fixe todos os LEDs DotStar em vermelho _ verde _ azul _

set DotStar LED _ to r _ g _ b _
fixe o LED DotStar _ em vermelho _ verde _ azul _

set DotStar brightness _
fixe o brilho do DotStar a _

####
# BME280 environmental sensor

bme280 connected
bme280 conectado

bmp280 connected
bmp280 conectado

bmx280 temperature
temperatura do bmx280

bmx280 pressure
pressÃ£o do bmx280

bme280 humidity
umidade do bme280

####
# TCS34725 color sensor

TCS34725 connected
TCS34725 conectado

TCS34725 rgb
cor RGB do TCS34725

color _ name
nome da cor _

####
# DHT11 environmental sensor

temperature (Celsius) DHT11 pin _
temperatura (Â°C) do DHT11 no pino _

humidity DHT11 pin _
umidade do DHT11 no pino _

temperature (Celsius) DHT22 pin _
temperatura (Â°C) do DHT22 no pino _

humidity DHT22 pin _
umidade do DHT22 no pino _

####
# PN532 RFID reader

read PN532 RFID
leia RFID PN532

RFID _ = _
RFID _ = _

get PN532 firmware version
versÃ£o de firmware do PN532

####
# HTTP libraries

HTTP client
Cliente HTTP

_ data _ to httpÜ// _
pedido _ com o conteÃºdo _ a http:// _

HTTP server
Servidor HTTP

start HTTP server
inicie o servidor HTTP

HTTP server request
pedido HTTP ao servidor

respond _ to HTTP request
responda _ ao pedido HTTP

with body _
com o conteÃºdo _

and headers _
e cabeÃ§alho _

body of request _
corpo do pedido _

path of request _
caminho do pedido _

method of request _
mÃ©todo do pedido _

####
# Web Things library

Web Thing
Web Thing

set thing name to _
fixe o nome da coisa em _

set thing capability to _
fixe a aptidÃ£o da coisa em  _

set boolean property _ title _ @Type _
fixe a propriedade booleana _ com o tÃ­tulo _ e @Type _

set string property _ title _ @Type _
fixe a propriedade texto _ com o tÃ­tulo _ e @Type _

set number property _ title _ @Type _
fixe a propriedade numÃ©rica _ com o tÃ­tulo _ e @Type _

set number property _ title _ min _ max _ @Type _
fixe a propriedade numÃ©rica _ com o tÃ­tulo _ mÃ­nimo _ mÃ¡ximo _ e @Type _

read only _
somente leitura _

register event _ type _
registre o evento _ do tipo _

start WebThing server
inicie o servidor WebThings

trigger event _
dispare evento _

thing description JSON
descriÃ§Ã£o JSON da coisa

properties JSON
propriedades JSON

event definitions JSON
JSON das definiÃ§Ãµes de eventos

events JSON
JSON dos eventos

##################
# MicroBlocks UI #
##################

# buttons, error & info messages, dialog boxes, etc

New
Novo

Open
Abrir

Open from board
Abrir da placa

Information
InformaÃ§Ã£o

Plug in the board.
Conecta a placa. 

Reading project from board...
Lendo projeto da placa...

Loading project...
Carregando projeto...

Found a newer version of
Encontrada uma versÃ£o mais nova de

Do you want me to update the one in the project?
VocÃª quer que eu atualize no projeto?

Save
Salvar

Connect
Conectar

disconnect
desconecta

Serial port:
Porta serial:

other...
outro...

none
nenhum

Port name?
Nome da porta?

Board type:
Tipo de placa:

Select board:
Seleciona a placa:

Could not read:
NÃ£o Ã© possÃ­vel ler:

by
por

Created with GP
Criado com GP

More info at http://microblocks.fun
Mais informaÃ§Ãµes em http://microblocks.fun

Function "
FunÃ§Ã£o "

" is too large to send to board.
" Ã© muito grande para enviar para a placa.

Script is too large to send to board.
O programa Ã© muito grande para enviar para a placa.

Use "Connect" button to connect to a MicroBlocks device.
Use o botÃ£o "Conectar" para conectar a um dispositivo MicroBlocks.

No boards found; is your board plugged in?
Nenhuma placa encontrada, sua placa estÃ¡ conectada?

For AdaFruit boards, double-click reset button and try again.
Nas placas AdaFruit, aperta o botÃ£o de reset duas vezes rapidamente e tente de novo.

The board is not responding.
A placa nÃ£o responde.

Try to Install MicroBlocks on the board?
Tentar instalar o MicroBlocks na placa?

The MicroBlocks in your board is not current
O MicroBlocks instalado na placa nÃ£o estÃ¡ atualizado

Try to update MicroBlocks on the board?
Tentar atualizar o MicroBlocks na placa?

Stop
Para

Start
Inicia

Quit MicroBlocks?
Sair do MicroBlocks?

Discard current project?
Descartar o projeto atual?

clean up
limpa

arrange scripts
organiza programas

undrop (ctrl-Z)
desfaz o Ãºltimo movimento (ctrl-Z)

copy all scripts to clipboard
copia todos os programas para a Ã¡rea de transferÃªncia

paste all scripts
cola todos os programas

paste script
cola o programa

save a picture of all scripts
guarda uma imagem de todos os programas

about...
sobre...

virtual machine version
versÃ£o da mÃ¡quina virtual

update firmware on board
atualiza o firmware da placa

show data graph
mostra o grÃ¡fico de dados

set serial delay
ajusta a latÃªncia da porta serial

firmware version
versÃ£o de firmware

start WebThing server
inicia o servidor WebThings

stop WebThing server
para o servidor WebThings

HTTP Server
Servidor HTTP

MicroBlocks HTTP Server listening on port 6473
O servidor HTTP do MicroBlocks estÃ¡ ativo na porta 6473

disable autoloading board libraries
desativa o autocarregamento das bibliotecas de placas

enable autoloading board libraries
ativa o autocarregamento das bibliotecas de placas

enable PlugShare when project empty
ativa PlugShare quando o projeto estÃ¡ vazio

disable PlugShare when project empty
desativa PlugShare quando o projeto estÃ¡ vazio

erase flash and update firmware on ESP board
apaga a flash e atualiza firmware na placa ESP

Use board type
Define o tipo de placa

Wiping board...
Apagando a placa...

(press ESC to cancel)
(pressione ESC para cancelar)

Done!
Feito!

download and install latest VM
baixa e instala a Ãºltima mÃ¡quina virtual

Select board type:
Seleciona o tipo de placa:

Uploading MicroBlocks to board...
Instalando MicroBlocks na placa...

copy data to clipboard
copia os dados para a Ã¡rea de transferÃªncia

clear data
apaga os dados

clear memory and variables
limpa a memÃ³ria e variÃ¡veis

show advanced blocks
mostra os blocos avanÃ§ados

export functions as library
exporta funÃ§Ãµes como biblioteca

hide advanced blocks
oculta os blocos avanÃ§ados

Data Graph
GrÃ¡fico de dados

show instructions
mostra instruÃ§Ãµes

show compiled bytes
mostra os bytes compilados

expand
expandir

collapse
colapsar

rename...
renomear...

show block definition...
mostra a definiÃ§Ã£o do bloco...

show the definition of this block
mostra a definiÃ§Ã£o deste bloco

delete block definition...
apaga a definiÃ§Ã£o do bloco...

delete the definition of this block
apaga a definiÃ§Ã£o deste bloco

duplicate
duplica

duplicate this block
duplica este bloco

delete block
elimina o bloco

delete this block
elimina este bloco

just this one block
apenas este bloco

copy to clipboard
copia para a Ã¡rea de transferÃªncia

copy these blocks to the clipboard
copia estes blocos para a Ã¡rea de transferÃªncia

duplicate all
duplica tudo

duplicate these blocks
duplica este bloco e todos os que se seguem

extract block
extrai bloco

pull out this block
retira este bloco

save picture of script
guarda uma imagem do programa

save a picture of this block definition as a PNG file
guarda uma imagem da definiÃ§Ã£o deste bloco em formato PNG

save a picture of these blocks as a PNG file
guarda uma imagem destes blocos em formato PNG

copy script
copia o programa

delete
apaga

Input type:
Tipo de entrada:

string only
somente texto

string or number
texto ou nÃºmero

number only
somente nÃºmero

define
define

number/string
nÃºmero/texto

editable number or string
nÃºmero ou texto editÃ¡vel

label
etiqueta

input
entrada

hide block definition
oculta a definiÃ§Ã£o deste bloco

Are you sure you want to remove this block definition?
Tem certeza que quer remover a definiÃ§Ã£o deste bloco?

Language
Idioma

Custom...
Personalizado...

Obsolete
Obsoleto

OK
OK

Ok
Ok

Yes
Sim

No
NÃ£o

Cancel
Cancelar

Okay
De acordo

Confirm
ConfirmaÃ§Ã£o

# File picker and library dialogs

Libraries
Bibliotecas

Examples
Exemplos

Desktop
Desktop

Computer
Computador

Cloud
Nuvem

File
Arquivo

File Open
Abrir arquivo

File Save
Salvar arquivo

File name:
Nome do arquivo:

New Folder
Nova Pasta

by
por

Depends:
Depende de:

Tags:
Etiquetas:

Path, name or URL for library?
Caminho, nome ou URL da biblioteca?

Invalid URL
URL invÃ¡lido

Could not fetch library.
NÃ£o Ã© possÃ­vel obter a biblioteca.

Host does not exist or is currently down.
O servidor nÃ£o existe ou nÃ£o estÃ¡ funcionando.

File not found in server.
NÃ£o foi encontrado o arquivo no servidor.

Server expects HTTPS, and MicroBlocks doesn't currently support it.
O servidor requer HTTPS, que nÃ£o Ã© suportado atualmente pelo MicroBlocks.

library information
detalhes da biblioteca

built-in library
biblioteca integrada

Dependency path, name or URL?
Caminho, nome ou URL da dependÃªncia?

Tag name?
Nome da etiqueta?

# MicroBlocks translation file
# Last updated: July 07 2020

#########################
# Blocks and categories #
#########################

Output
SaÃ­da

set user LED _
acender LED integrado _

say _
mostrar _

graph _
grÃ¡fico _

Input
Entrada

button A
botÃ£o A

button B
botÃ£o B

microseconds
microsegundos

milliseconds
milisegundos

board type
tipo de placa

Pins
Pins

read digital pin _
leitura digital _

read analog pin _
leitura analÃ³gica _

set digital pin _ to _
colocar pin digital _ a _

set pin _ to _
colocar pin _ a _

analog pins
pins analÃ³gicos

digital pins
pins digitais

Control
Control

when started
no arranque

when button _ pressed
quando se prime o botÃ£o _

forever _
para sempre _

repeat _ _
repetir _ vezes _

wait _ millisecs
esperar _ milisegundos

if _ _
se _ _

else if _ _
entÃ£o, se _ _

if _ _ else _
se _ _ entÃ£o _

else
entÃ£o

when _
quando _

wait until _
esperar atÃ© que _

wait _ microsecs
esperar _ microsegundos

return _
retornar _

when _ received
ao receber _

broadcast _
enviar _

comment _
comentÃ¡rio _

for _ in _ _
por cada _ em _ _

repeat until _ _
repetir atÃ© que _ _

stop this task
parar esta tarefa

stop other tasks
parar as outras tarefas

stop all
parar tudo

last message
Ãºltima mensagem

Operators
Operadores

_ mod _
_ mÃ³dulo _

abs _
valor absoluto de _

random _ to _
nÃºmero aleatÃ³rio entre _ e _

not _
nÃ£o _

_ and _
_ e _

and _
e _

_ or _
_ ou _

or _
ou _

_ is a _
_ Ã© um _

boolean
boleano

number
nÃºmero

string
texto

list
lista

Advanced:
--MISSING--

hex _
hexadecimal _

Variables
VariÃ¡veis

# Buttons on top of "Variables" category

Add a variable
Cria uma variÃ¡vel

Delete a variable
Apaga uma variÃ¡vel

# New variable dialog

New variable name?
Nome da variÃ¡vel?

set _ to _
coloca _ em _

change _ by _
altera _ em _

initialize local _ to _
--MISSING--

Data
Dados

list
lista

length of _
tamanho de _

item _ of _
elemento _ de _

replace item _ of list _ with _
substitui elemento _ da lista _ por _

delete item _ of list _
apaga elemento _ da lista _

add _ to list _
adiciona _ Ã  lista _

join _ _
une _ _

copy _ from _
copia _ desde _

to _
atÃ© _

find _ in _
encontra _ em _

starting at _
comeÃ§ar desde _

join items of list _
une elementos da lista _

separator _
usando separador _

unicode _ of _
unicode _ de _

string from unicode _
texto com unicode _

new list length _
nova lista de tamanho _

new byte array _
nova matriz de bytes _

free memory
memÃ³ria livre

My Blocks
Meus blocos

# Buttons on top of "My Blocks" category

Add a command block
Cria um bloco de comandos

Add a reporter block
Cria um bloco repÃ³rter

# Make a block dialog

Enter function name:
Nome da funÃ§Ã£o:

Comm
ComunicaÃ§Ãµes

i2c get device _ register _
ler do dispositivo i2c _ o registo _

i2c set device _ register _ to _
escreve no dispositivo i2c _ o registo _ com _

i2c device _ read list _
ler o dispositivo i2c _ para a lista _

i2c device _ write list _
escreve no dispositivo i2c _ o conteÃºdo da lista _

spi send _
spi a envÃ­ar _

spi receive
spi a receber

print _
escrever _

no op
nÃ£o op

ignore
ignorar

##############
# Primitives #
##############

# These are all mostly hidden from end users

draw shape _ at x _ y _
desenhar forma _ em x _ y _

shape for letter _
forma para letra _

send NeoPixel rgb _
envÃ­ar RGB _ ao NeoPixel

has tone support
tem suporte para tons

play tone pin _ frequency _
toca um tom no pin _ com a frequÃªncia _

has WiFi support
tem suporte para WiFi

start WiFi _ password _
inicia WiFi _ com a password _

stop WiFi
terminar WiFi

WiFi status
estado do WiFi

my IP address
meu endereÃ§o IP

radio send number _
envÃ­a nÃºmero _ por rÃ¡dio

radio send string _
envÃ­a texto _ por rÃ¡dio

radio send pair _ = _
envÃ­a associaÃ§Ã£o _ = _ por rÃ¡dio

radio message received?
mensagem de rÃ¡dio recebida?

radio last number
Ãºltimo nÃºmero recebido por rÃ¡dio

radio last string
Ãºltimo texto recebido por rÃ¡dio

radio last message type
tipo da Ãºltima mensagem recebida por rÃ¡dio

radio set group _
fixar grupo de rÃ¡dio a _

radio set channel (0-83) _
fixar canal de rÃ¡dio a (0-83) _

radio set power (0-7) _
fixar potÃªncia de rÃ¡dio a (0-7) _

radio last signal strength
intensidade do Ãºltimo sinal de rÃ¡dio

radio receive packet _
recebe pacote por rÃ¡dio _

radio send packet _
envÃ­a pacote por radio _

disable radio
desabilita rÃ¡dio

#############
# Libraries #
#############

Basic Sensors
Sensores bÃ¡sicos

tilt x
inclinaÃ§Ã£o x

tilt y
inclinaÃ§Ã£o y

tilt z
inclinaÃ§Ã£o z

acceleration
acelaraÃ§Ã£o

light level
nÃ­vel de luz

temperature (Â°C)
temperatura (Â°C)

####
# NeoPixel library

NeoPixel
NeoPixel

set NeoPixels _ _ _ _ _ _ _ _ _ _
define NeoPixels _ _ _ _ _ _ _ _ _ _

clear NeoPixels
apaga NeoPixels

set NeoPixel _ color _
define NeoPÃ­xel _ de cor _

set all NeoPixels color _
define todos os NeoPixels de color _

rotate NeoPixels by _
roda NeoPixels em _

color r _ g _ b _ (0-255)
cor r _ g _ b _ (0-255)

random color
cor aleatÃ³ria

attach _ LED NeoPixel strip to pin _
inicializa a tira de _ NeoPixel no pin _

has white _
com branco _

PIR
Sensor de movimento

PIR at pin _ detected movement
Movimento detectado por PIR no pin _

####
# Citilab ED1 board libraries

ED1 Stepper Motor
Motores ED1

move motor _ _ steps _
move motor _ _ passos _

move motor 1 _ and motor 2 _ _ steps
move motor 1 _ e motor 2 _ _ passos

move motor _ angle _ Â°
move motor _ Ã¢ngulo _ Â°

move motor _ _ complete turns
move motor _ _ voltas completas

stop steppers
pÃ¡ra os motores

clockwise
sentido horÃ¡rio

counter-clockwise
sentido anti-horÃ¡rio

ED1 Buttons
BotÃµes ED1

button OK
botÃ£o OK

button X
botÃ£o X

button up
botÃ£o cima

button down
botÃ£o baixo

button left
botÃ£o esquerda

button right
botÃ£o direita

capacitive sensor _
sensor capacitivo _

set capacitive threshold to _
fixa limite capacitivo em _

####
# BirdBrain Technologies libraries

Hummingbird LED _ _ %
Hummingbird LED _ _ %

Hummingbird Tri-LED _ R _ % G _ % B _ %
Hummingbird LED tricolor _ R _ % G _ % B _ %

Hummingbird Position Servo _ _ Â°
Hummingbird Servo Posicional _ _ Â°

Hummingbird Rotation Servo _ _ %
Hummingbird Servo de RotaÃ§Ã£o _ _ %

Hummingbird _ _
Hummingbird _ _

Hummingbird Battery (mV)
Hummingbird Bateria (mV)

Light
Luz

Distance (cm)
DistÃ¢ncia (cm)

Dial
Dial

Sound
Som

Other
Outro

Finch Beak Red _ Green _ Blue _
Pico de color do Finch R _ % G _ % B _ %

Finch Tail _ Red _ Green _ Blue _
Cauda de color do Finch R _ % G _ % B _ %

Finch Move _ _ cm at _ %
Mover  o Finch _ _ cm  Ã  velocidade _ %

Finch Turn _ _ Â° at _ %
Girar o Finch _ _ Â° Ã  velocidade _ %

Finch Wheels L _ % R _ %
Rodas do Finch Ã  velocidad E _ % D _ %

Finch Stop
Para o Finch

Finch Distance (cm)
Distancia do Finch (cm)

Finch _ Light
Luz _ do Finch

Finch _ Line
LÃ­nha _  do Finch

Finch Reset Encoders
Reinicializar os contadores de voltas do Finch

Finch _ Encoder
Contador de voltas _

Finch Accelerometer _
AcelerÃ³metro do Finch _

Finch Battery
NÃ­vel de baterÃ­a do Finch

All
Todos

Forward
Frente

Backward
AtrÃ¡s

Right
Direita

Left
Esquerda

Beak Up
Pico atÃ© cima

Beak Down
Pico atÃ© a baixo

Tilt Left
InclinaÃ§Ã£o Ã  esquerda

Tilt Right
InclinaÃ§Ã£o Ã  direita

Level
Plano

Upside Down
CabeÃ§a para baixo

x
x

y
y

z
z

strength
potÃªncia

####
# Ultrasound distance library

distance (cm) trigger _ echo _
distÃ¢ncia (cm) trigger _ echo _

####
# Infrared remote library

IR Remote
Infravermelhos

receive IR code
recebe cÃ³digo IR

receive IR code from device _
recebe cÃ³digo IR do dispositivo _

test IR
teste IR

attach IR receiver to pin _
inicializa receptor IR no pin _

####
# Radio comm library
# Allows micro:bit boards to exchange messages
# All of its blocks are primitive (see "Primitives" section)

Radio
RÃ¡dio

####
# Text scrolling library
# Scrolls text on 5x5 LED displays and simulated ones

Scrolling
Texto animado

scroll text _
anima o texto _

scroll number _
anima o nÃºmero _

pausing _ ms
pausar _ ms

stop scrolling
para a animaÃ§Ã£o

####
# Servo motor library

Servo
Servomotores

set servo _ to _ degrees (-90 to 90)
fixa o servo _ a _ graus (-90 a 90)

set servo _ to speed _ (-100 to 100)
faz girar o servo _ Ã  velocidade _ (-100 a 100)

stop servo _
para o servo _

####
# 5x5 LED display library
# Supports the micro:bit display, but also simulated 5x5 displays on boards
# with differently sized LED arrays, NeoPixel arrays or TFT displays

LED Display
Display LED

display _
display _

clear display
limpar display

plot x _ y _
ligar x _ y _

unplot x _ y _
apagar x _ y _

display character _
mostra caracter _

####
# TFT display library

enable TFT _
activa TFT _

TFT width
largura do TFT

TFT height
altura do TFT

set TFT pixel x _ y _ to _
pinta o pÃ­xel x _ y _ de color _

draw line on TFT from x _ y _ to x _ y _ color _
desenha lÃ­nha de x _ y _ a x _ y _ cor _

draw rectangle on TFT at x _ y _ width _ height _ color _
desenha retÃ¢ngulo em x _ y _ largura _ altura _ cor _

draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _
desenha retÃ¢ngulo arredondado em x _ y _ largura _ altura _ raio _ cor _

draw circle on TFT at x _ y _ radius _ color _
desenha cÃ­rculo em x _ y _ raio _ cor _

draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _
desenha triÃ¢ngulo em x _ y _ , x _ y _ , x _ y _ cor _

filled _
preenchido _

write _ on TFT at x _ y _ color _
escreve _ em x _ y _ cor _

scale _ wrap _
escala _ com saltos de lÃ­nha _

####
# Tone library
# Generates music tones on buzzers

Tone
Tons

attach buzzer to pin _
inicializa campainha no pin _

play note _ octave _ for _ ms
toca a nota _ na oitava _ durante _ ms

play frequency _ for _ ms
toca a frequÃªncia _ durante _ ms

play midi key _ for _ ms
toca a tecla MIDI _ durante _ ms

####
# Turtle geometry library

Turtle
Tartaruga

home
volta para casa

move _
move _ pasos

turn _ degrees
gira _ graus

turn _ / _ of circle
gira _ / _ de volta

pen down
baixa o lÃ¡pis

pen up
sobe o lÃ¡pis

set pen color to _
fixa a color do lÃ¡pis a _

set pen to random color
fixa uma cor aleatÃ³ria para o lÃ¡pis

fill display with _
preenche o ecran com a cor _

go to x _ y _
ir para x _ y _

point in direction _
aponta na direÃ§Ã£o _

####
# File system library

Files
Arquivos

open file _
abre arquivo _

close file _
fecha arquivo _

delete file _
apaga arquivo _

append line _ to file _
adiciona linha _ no arquivo _

append bytes _ to file _
adiciona bytes _ no arquivo _

end of file _
fim do arquivo _

next line of file _
linha seguinte do arquivo _

next _ bytes of file _
seguintes _ bytes do arquivo _

starting at _
comeÃ§ar desde _

file names
nomes de arquivo

size of file _
tamanho do arquivo _

file system info
detalhes do sistema de arquivo

####
# WiFi library

WiFi
WiFi

wifi connect to _ password _ try _ times
ligar Ã  rede wifi _ com a senha _ em _ tentativas

wifi create hotspot _ password _
criar um ponto de acesso wifi _ com a senha _

IP address
endereÃ§o IP

####
# Motion library
# Counts steps and detects motion via the internal accelerometer

Motion
Moviemento

motion
movimento

start step counter
comeÃ§ar a contar passos

step count
contagem de passos

clear step count
apanha contagem de passos

set step threshold _ (0-50)
fixa o limite de passos em _ (0-50)

####
# Button Events library

Button Events
Eventos de botÃ£o

button _ double pressed
duplo click no botÃ£o _

button _ long pressed
longo click no botÃ£o _

button _ pressed
click no botÃ£o  _

####
# Calliope board library

Calliope set LED red _ green _ blue _
fixa o LED do Calliope a vermelho _ verde _ azul _

Calliope set speaker _
fixa o alto falante do Calliope em _

Calliope loudness
Volume sonoro do Calliope

####
# Circuit Playground Express board library

Circuit Playground set speaker _
fixa o alto falante do Circuit Playground em _

Circuit Playground slide switch
interruptor do Circuit Playground

####
# DotStar LED library

attach _ DotStar LEDs to data pin _ clock pin _
inicializa tira de _ LEDs DotStar no pin de dados _ e pin de relÃ³gio _

set all DotStar LEDs to r _ g _ b _
fixa todos os LEDs DotStar a vermelho _ verde _ azul _

set DotStar LED _ to r _ g _ b _
fixa o LED DotStar _ a vermelho _ verde _ azul _

set DotStar brightness _
fixa o brilho do DotStar a _

####
# BME280 environmental sensor

bme280 connected
bme280 conectado

bmp280 connected
bmp280 conectado

bmx280 temperature
temperatura do bmx280

bmx280 pressure
pressÃ£o do bmx280

bme280 humidity
humidade do bme280

####
# TCS34725 color sensor

TCS34725 connected
TCS34725 conectado

TCS34725 rgb
cor RGB do TCS34725

color _ name
nome da cor _

####
# DHT11 environmental sensor

temperature (Celsius) DHT11 pin _
temperatura (ÂºC) do DHT11 no pin _

humidity DHT11 pin _
humidade do DHT11 no pin _

temperature (Celsius) DHT22 pin _
temperatura (ÂºC) do DHT22 no pin _

humidity DHT22 pin _
humidade do DHT22 no pin _

####
# PN532 RFID reader

read PN532 RFID
ler RFID PN532

RFID _ = _
RFID _ = _

get PN532 firmware version
versÃ£o de firmware do PN532

####
# HTTP libraries

HTTP client
Cliente HTTP

_ data _ to httpÜ// _
pedido _ com o conteÃºdo _ a http:// _

HTTP server
Servidor HTTP

start HTTP server
inicia o servidor HTTP

HTTP server request
pedido HTTP ao servidor

respond _ to HTTP request
responde _ ao pedido HTTP

with body _
com o conteÃºdo _

and headers _
e cabeÃ§alho _

body of request _
corpo do pedido _

path of request _
caminho do pedido _

method of request _
mÃ©todo do pedido _

####
# Web Things library

Web Thing
Web Thing

set thing name to _
fixa o nome da coisa em _

set thing capability to _
fixa a aptidÃ£o da coisa em  _

set boolean property _ title _ @Type _
fixa a propriedade booleana _ com o tÃ­tulo _ e @Type _

set string property _ title _ @Type _
fixa a propriedade texto _ com o tÃ­tulo _ e @Type _

set number property _ title _ @Type _
fixa a propriedade numÃ©rica _ com o tÃ­tulo _ e @Type _

set number property _ title _ min _ max _ @Type _
fixa a propriedade numÃ©rica _ com o tÃ­tulo _ mÃ­nimo _ mÃ¡ximo _ e @Type _

read only _
apenas leitura _

register event _ type _
registra o evento _ do tipo _

start WebThing server
inicia o servidor de WebThings

trigger event _
dispara evento _

thing description JSON
descriÃ§Ã£o JSON da coisa

properties JSON
propriedades JSON

event definitions JSON
JSON das definiÃ§Ãµes de eventos

events JSON
JSON dos eventos

##################
# MicroBlocks UI #
##################

# buttons, error & info messages, dialog boxes, etc

New
Novo

Open
Abrir

Open from board
--MISSING--

Information
--MISSING--

Plug in the board.
--MISSING--

Reading project from board...
--MISSING--

Loading project...
--MISSING--

Found a newer version of
--MISSING--

Do you want me to update the one in the project?
--MISSING--

Save
Guardar

Connect
Conecta

disconnect
desconecta

Serial port:
Porta serie:

other...
outro...

none
nenhum

Port name?
Nome do porto?

Board type:
Tipo de placa:

Select board:
Seleciona a placa:

Could not read:
NÃ£o Ã© possÃ­vel ler:

by
por

Created with GP
Criado com GP

More info at http://microblocks.fun
Mais informaÃ§Ãµes em http://microblocks.fun

Function "
FunÃ§Ã£o "

" is too large to send to board.
" Ã© demasiado grande para enviar para a placa.

Script is too large to send to board.
O programa Ã© demasiado grande para enviar para a placa.

Use "Connect" button to connect to a MicroBlocks device.
Use o botÃ£o "Conectar" para conectar a um dispositivo MicroBlocks.

No boards found; is your board plugged in?
Nenhuma placa encontrada, ligaste a tua placa?

For AdaFruit boards, double-click reset button and try again.
Nas placas AdaFruit, aperta o botÃ£o de reset duas vezes rapidamente e volta a tentar.

The board is not responding.
A placa nÃ£o estÃ¡ a responder.

Try to Install MicroBlocks on the board?
Tenta instalar o MicroBlocks na placa?

The MicroBlocks in your board is not current
O MicroBlocks instalado na placa nÃ£o estÃ¡ actualizado

Try to update MicroBlocks on the board?
Tenta actualizar o MicroBlocks na placa?

Stop
Para

Start
Inicia

Quit MicroBlocks?
Sair do MicroBlocks?

Discard current project?
Queres descartar o projecto actual?

clean up
limpa

arrange scripts
organiza programas

undrop (ctrl-Z)
desfaz o Ãºltimo movimento (ctrl-Z)

copy all scripts to clipboard
copia todos os programas para o clipboard

paste all scripts
cola todos os programas

paste script
cola o programa

save a picture of all scripts
guarda uma imagem de todos os programas

about...
sobre...

virtual machine version
versÃ£o da mÃ¡quina virtual

update firmware on board
atualiza o firmware da placa

show data graph
mostra o grÃ¡fico de dados

set serial delay
ajusta a latÃªncia da porta sÃ©rie

firmware version
versÃ£o de firmware

start WebThing server
inicia o servidor de WebThings

stop WebThing server
para o servidor de WebThings

HTTP Server
--MISSING--

MicroBlocks HTTP Server listening on port 6473
O servidor HTTP de MicroBlocks estÃ¡ activo no porto 6473

disable autoloading board libraries
desativar o auto carregamento das bibliotecas de placas

enable autoloading board libraries
activar o auto carregamento das bibliotecas de placas

enable PlugShare when project empty
--MISSING--

disable PlugShare when project empty
--MISSING--

erase flash and update firmware on ESP board
apaga e reparticiona esp

Use board type
Define o tipo de placa

Wiping board...
Apagando a placa...

(press ESC to cancel)
(carrega em ESC para cancelar)

Done!
Feito!

download and install latest VM
descarga e instala a Ãºltima mÃ¡quina virtual

Select board type:
Selecciona a tua placa:

Uploading MicroBlocks to board...
Instalando MicroBlocks na placa...

copy data to clipboard
copia os dados para o clipboard

clear data
apagar os dados

clear memory and variables
limpar a memÃ³ria e variÃ¡veis

show advanced blocks
mostra os blocos avanÃ§ados

export functions as library
exporta funÃ§Ãµes como biblioteca

hide advanced blocks
oculta os blocos avanÃ§ados

Data Graph
GrÃ¡fico de dados

show instructions
mostra instruÃ§Ãµes

show compiled bytes
mostra os bytes compilados

expand
expandir

collapse
colapsar

rename...
renomear...

show block definition...
mostra a definiÃ§Ã£o do bloco...

show the definition of this block
muestra a definiÃ§Ã£o deste bloco

delete block definition...
apaga a definiÃ§Ã£o do bloco...

delete the definition of this block
apaga a definiÃ§Ã£o deste bloco

duplicate
duplica

duplicate this block
duplica este bloco

delete block
elimina o bloco

delete this block
elimina este bloco

just this one block
apenas este bloco

copy to clipboard
copia para o clipboard

copy these blocks to the clipboard
copia estes blocos para o clipboard

duplicate all
duplica tudo abaixo

duplicate these blocks
duplica este bloco e todos os que se seguem

extract block
extrair bloco

pull out this block
retirar este bloco

save picture of script
guarda a imagem do programa

save a picture of this block definition as a PNG file
guarda uma imagem da definiciÃ³n deste bloco em formato PNG

save a picture of these blocks as a PNG file
guarda uma imagem destes blocos em formato PNG

copy script
copia ol programa

delete
elimina

Input type:
Tipo de entrada:

string only
apenas texto

string or number
texto ou nÃºmero

number only
apenas nÃºmero

define
define

number/string
nÃºmero/texto

editable number or string
nÃºmero ou texto editÃ¡vel

label
etiqueta

input
entrada

hide block definition
oculta a definiÃ§Ã£o deste bloco

Are you sure you want to remove this block definition?
Confirmas que queres eliminar a definiÃ§Ã£o deste bloco?

Language
Idioma

Custom...
Personalizado...

Obsolete
Obsoleto

OK
OK

Ok
Ok

Yes
Sim

No
NÃ£o

Cancel
Cancelar

Okay
De acordo

Confirm
ConfirmaÃ§Ã£o

# File picker and library dialogs

Libraries
Bibliotecas

Examples
Exemplos

Desktop
Desktop

Computer
Computador

Cloud
Nuvem

File
Arquivo

File Open
Abrir arquivo

File Save
Guardar arquivo

File name:
Nome do arquivo:

New Folder
Nova Pasta

by
por

Depends:
Depende de:

Tags:
Etiquetas:

Path, name or URL for library?
Caminho, nome ou URL da biblioteca?

Invalid URL
URL invÃ¡lido

Could not fetch library.
NÃ£o Ã© possÃ­vel obter a biblioteca.

Host does not exist or is currently down.
O servidor nÃ£o existe ou estÃ¡ fora de serviÃ§o.

File not found in server.
NÃ£o foi encontrado o arquivo no servidor.

Server expects HTTPS, and MicroBlocks doesn't currently support it.
O servidor requer HTTPS, que nÃ£o Ã© suportado atualmente pelo MicroBlocks.

library information
detalhes da biblioteca

built-in library
biblioteca integrada

Dependency path, name or URL?
Caminho, nome ou URL da dependÃªncia?

Tag name?
Nome da etiqueta?

# MicroBlocks translation file
# Last updated: March 18 2023

#########################
# Blocks and categories #
#########################

Output
ÃÄ±ktÄ±

set user LED _
kullanÄ±cÄ± LED i _ yap

say _
sÃ¶yle _

graph _
grafiÄini Ã§iz _

Input
Girdi

button A
buton A

button B
buton B

microseconds
mikrosaniye

milliseconds
milisaniye

board type
kart tipi

connected to IDE
IDE ye baÄlÄ±

Pins
Pinler

read digital pin _
dijital pin oku _

read analog pin _
analog pin oku _

pullup _
Ã§ekme direnÃ§ _

set digital pin _ to _
dijital pin _ ayarÄ±nÄ± _ yap

set pin _ to _
pin _ ayarÄ±nÄ± _ yap

analog pins
analog pinler

digital pins
dijital pinler

Control
Kontrol

when started
baÅladÄ±ÄÄ±nda

when button _ pressed
buton _ basÄ±ldÄ±ÄÄ±nda

forever _
devamlÄ± tekrarla _

repeat _ _
tekrarla _ kere _

wait _ millisecs
bekle _ milisaniye

if _ _
eÄer _ yap _

else if _ _
yoksa eÄer _ _

if _ _ else _
eÄer _ yap _ deÄilse _

else
yoksa

when _
_ olunca

wait until _
_ olana kadar bekle

wait _ microsecs
bekle _ mikrosaniye

return _
dÃ¶ndÃ¼r _

when _ received
_ mesajÄ± geldiÄinde

broadcast _
_ gÃ¶nder

range _ to _
aralÄ±k _ den _ kadar

by _
her _

comment _
yorum _

for _ in _ _
her _ iÃ§in _ _ kapsamÄ±nda

repeat until _ _
_ _ olana kadar tekrarla

stop this task
bu betiÄi durdur

stop other tasks
Ã¶teki betikleri durdur

stop all
tÃ¼m betikleri durdur

last message
son mesaj

call _ 
Ã§aÄÄ±r _ 

with _
parametreler _

Operators
Ä°Ålemler

_ mod _
_ mod _

abs _
mutlak deÄer _

random _ to _
rastgele _ ve _ arasÄ±

not _
_ deÄil

_ and _
_ ve _

and _
ve _

_ or _
_ veya _

or _
veya _

_ is a _
_ bir _

boolean
boole

number
numara

string
dizgi

list
liste

byte array
bayt dizisi

rescale _ from _ _ to _ _
Ã¶lÃ§eklendir _ bundan _ _ buna _ _

Advanced:
GeliÅmiÅ:

hex _
hex _

Variables
DeÄiÅkenler

# Buttons on top of "Variables" category

Add a variable
DeÄiÅken ekle

Delete a variable
DeÄiÅken sil

# New variable dialog

New variable name?
Yeni deÄiÅkenin adÄ±?

set _ to _
_ deÄiÅkenini _ yap

change _ by _
_ deÄiÅkenini _ deÄiÅtir

initialize local _ to _
_ yerel deÄiÅkeni _ yap

Data
Veri

list
liste

length of _
_ uzunluÄu

item _ of _
Ã¶Äe#: _ liste/dizgi: _

replace item _ of list _ with _
listede deÄiÅtir Ã¶Äe#: _ liste: _ yeni deÄer _

delete item _ of list _
listeden sil Ã¶Äe#: _ liste: _

add _ to list _
listeye ekle deÄer: _ liste: _

join _ _
birleÅtir _ _

copy _ from _
kopyala _ baÅla _

to _
bitir _

find _ in _
_ bul _ iÃ§inde

starting at _
baÅla _

split _ by _
_ dizisini her _ ayÄ±r

join items of list _
_ listesinin Ã¶Äelerini birleÅtir

separator _
ayÄ±rÄ±cÄ± _

unicode _ of _
unicode harf# _ dizginin: _

string from unicode _
unicode dan harfe _

new list length _
_ Ã¶Äeli yeni liste yarat

wÄ±th all _
her Ã¶Äeyi _ yap

new byte array _
yeni bayt dizisi

as byte array _
bayt dizisine Ã§evir _

free memory
boÅ bellek

My Blocks
Benim BloklarÄ±m

# Buttons on top of "My Blocks" category

Add a command block
kumanda bloÄu ekle

Add a reporter block
Bildiren bloÄu ekle

# Make a block dialog

Enter function name:
Ä°Ålev adÄ±nÄ± gir

Comm
Ä°letiÅim

i2c get device _ register _
i2c oku modÃ¼l _ yazmaÃ§ _

i2c set device _ register _ to _
i2c yaz modÃ¼l _ yazmaÃ§ _ deÄer _

i2c device _ read list _
i2c araÃ§ _ liste oku _

i2c device _ write list _
i2c araÃ§ _ liste yaz _

spi send _
spi gÃ¶nder _

spi receive
spi oku

spi setup speed _
spi hÄ±zÄ± _

mode _
mod _

rpi channel _
rpi kanal _

spi exchange bytes _
spi baytlarÄ± takasla _

serial open _ baud
seri portu baÅlat _ baud 

serial close
seri portu kapat

serial read
seri oku

serial write _
seri yaz _

serial write _ starting at _
seri yaz _  bayt _ baÅlayarak

soft serial write byte _ pin _ baud _
soft seri yaz bayt _ pin _ baud _

print _
yaz _

no op
iÅlem yok

ignore
yoksay

##############
# Primitives #
##############

# These are all mostly hidden from end users

draw shape _ at x _ y _
_ Åeklini Ã§iz x _ y _

shape for letter _
_ harfinin Åekli

send NeoPixel rgb _
NeoPixel rgb _ gÃ¶nder

has tone support
ton desteÄi var

play tone pin _ frequency _
ton Ã§al pin _ frekans _

has WiFi support
WIFI desteÄi var

start WiFi _ password _
WIFI baÅlat SSID _ Åifre _

stop WiFi
WIFI durdur

WiFi status
WIFI durumu

my IP address
IP adresim

radio send number _
radyo sayÄ± yolla _

radio send string _
radyo dizgi yolla _

radio send pair _ = _
radyo deÄer yolla _ = _

radio message received?
radyo mesajÄ± alÄ±ndÄ± mÄ±?

radio last number
radyo son sayÄ±

radio last string
radyo son dizgi

radio last message type
radyo son mesaj tipi

radio set group _
radyo grubunu ayarla _

radio set channel (0-83) _
radyo kanal ayarla (0-83) _

radio set power (0-7) _
radyo gÃ¼Ã§ ayarla (0-7) _

radio last signal strength
radyo son sinyal gÃ¼cÃ¼

radio receive packet _
radyo paket al _

radio send packet _
radyo paket yolla _

disable radio
radyoyu etkisizleÅtir

#############
# Libraries #
#############

Basic Sensors
Temel SensÃ¶rler

tilt x
eÄilim x

tilt y
eÄilim y

tilt z
eÄilim z

acceleration
ivme

light level
Ä±ÅÄ±k seviyesi

temperature (Â°C)
Ä±sÄ± (Â°C)

####
# NeoPixel library

NeoPixel
Neopiksel

set NeoPixels _ _ _ _ _ _ _ _ _ _
NeoPixel leri _ _ _ _ _ _ _ _ _ _ yap

clear NeoPixels
NeoPixelleri sÃ¶ndÃ¼r

set NeoPixel _ color _
NeoPixel _ renk _ yap

set all NeoPixels color _
TÃ¼m NeoPixel renklerini _ yap

rotate NeoPixels by _
NeoPixelleri _ dÃ¶ndÃ¼r

color r _ g _ b _ (0-255)
renk r _ g _ b _ (0-255)

random color
rastgele renk

attach _ LED NeoPixel strip to pin _
_ LED Neopiksel Åeridini pin _ baÄla

has white _
beyaz var _

PIR
PIR

PIR at pin _ detected movement
_ pinine baÄlÄ± PIR hareket algÄ±ladÄ±

####
# Citilab ED1 board libraries

ED1 Stepper Motor
ED1 Step Motoru

move motor _ _ steps _
_ motorunu _ adÄ±m yÃ¼rÃ¼t _

move motor 1 _ and motor 2 _ _ steps
motor 1 _ ve motor 2 _ _ adÄ±m yÃ¼rÃ¼t

move motor _ angle _ Â°
_ motorunu  _ Â° dÃ¶ndÃ¼r

move motor _ _ complete turns
_ motorunu _ kere tam dÃ¶ndÃ¼r

stop steppers
step motorlarÄ± durdur

clockwise
saat yÃ¶nÃ¼nde

counter-clockwise
saat yÃ¶nÃ¼ne ters

ED1 Buttons
ED1 ButonlarÄ±

button OK
buton OK

button X
buton X

button up
buton yukarÄ±

button down
buton aÅaÄÄ±

button left
buton sol

button right
buton saÄ

capacitive sensor _
kapasitif sensÃ¶r _

set capacitive threshold to _
kapasitif eÅik deÄerini _ yap

####
# BirdBrain Technologies libraries

Hummingbird LED _ _ %
Hummingbird LED _ _ %

Hummingbird Tri-LED _ R _ % G _ % B _ %
Hummingbird 3renkli-LED _ R _ % G _ % B _ %

Hummingbird Position Servo _ _ Â°
Hummingbird _ Servosunu _ Â° yap

Hummingbird Rotation Servo _ _ %
Hummingbird _ Servosunu _ % dÃ¶ndÃ¼r

Hummingbird _ _
Hummingbird _ _

Hummingbird Battery (mV)
Hummingbird Pil (mV)

Light
IÅÄ±k

Distance (cm)
Mesafe (cm)

Dial
Kadran

Sound
Ses

Other
DiÄer

Finch Beak Red _ Green _ Blue _
Finch Gaga KÄ±rmÄ±zÄ± _ YeÅil _ Mavi _

Finch Tail _ Red _ Green _ Blue _
Finch Kuyruk KÄ±rmÄ±zÄ± _ YeÅil _ Mavi _

Finch Move _ _ cm at _ %
Finch Hareket _ _ cm at _ %

Finch Turn _ _ Â° at _ %
Finch DÃ¶n _ _ Â° at _ %

Finch Wheels L _ % R _ %
Finch Tekerlekler Sol _ % SaÄ _ %

Finch Stop
Finch Dur

Finch Distance (cm)
Finch Mesafe (cm)

Finch _ Light
Finch _ IÅÄ±k

Finch _ Line
Finch _ Ãizgi

Finch Reset Encoders
Finch EnkoderlarÄ± resetle

Finch _ Encoder
Finch _ Enkoder

Finch Accelerometer _
Finch ivmeÃ¶lÃ§er _

Finch Battery
Finch Pil

All
TÃ¼m

Forward
Ä°leri

Backward
Geri

Right
SaÄ

Left
Sol

Beak Up
Gaga YukarÄ±

Beak Down
Gaga AÅaÄÄ±

Tilt Left
Sola Yat

Tilt Right
SaÄa Yat

Level
DÃ¼z

Upside Down
Ters

x
x

y
y

z
z

strength
gÃ¼Ã§

####
# Ultrasound distance library

distance (cm) trigger _ echo _
mesafe (cm) tetik _ eko _

####
# Infrared remote library

IR Remote
IR Uzaktan Kumanda

receive IR code
IR kod oku

receive IR code from device _
_ aygÄ±tÄ±ndan IR kod oku

test IR
IR testi

attach IR receiver to pin _
IR alÄ±cÄ±sÄ±nÄ± _ pinine baÄla

####
# Radio comm library
# Allows micro:bit boards to exchange messages
# All of its blocks are primitive (see "Primitives" section)

Radio
Radyo

####
# Text scrolling library
# Scrolls text on 5x5 LED displays and simulated ones

Scrolling
KaydÄ±rma

scroll text _
_ metnini kaydÄ±r

scroll number _
_ sayÄ±sÄ±nÄ± kaydÄ±r

pausing _ ms
_ ms duraklatma

stop scrolling
kaydÄ±rmayÄ± durdur

####
# Servo motor library

Servo
Servo

set servo _ to _ degrees (-90 to 90)
_ servosunu _ dereceye ayarla (-90 to 90)

set servo _ to speed _ (-100 to 100)
_ servosunun hÄ±zÄ±nÄ± _ yap (-100 to 100)

stop servo _
servoyu durdur

####
# 5x5 LED display library
# Supports the micro:bit display, but also simulated 5x5 displays on boards
# with differently sized LED arrays, NeoPixel arrays or TFT displays

LED Display
LED Ekran

display _
LED ekran _

clear display
ekranÄ± sil

plot x _ y _
yak x _ y _

unplot x _ y _
sÃ¶ndÃ¼r x _ y _

display character _
_ harfini gÃ¶ster

####
# TFT display library

enable TFT _
TFT yi etkinleÅtir _

TFT width
TFT geniÅliÄi

TFT height
TFT yÃ¼ksekliÄi

set TFT pixel x _ y _ to _
TFT x _ y _ pikselini _ yap

draw line on TFT from x _ y _ to x _ y _ color _
TFT Ã§izgi baÅla x _ y _ son x _ y _ renk _

draw rectangle on TFT at x _ y _ width _ height _ color _
TFT dikdÃ¶rtgen baÅla x _ y _ geniÅlik _ yÃ¼kseklik _ renk _

draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _
TFT yuvarlatÄ±lmÄ±Å dikdÃ¶rtgen baÅla x _ y _ geniÅlik _ yÃ¼kseklik _ Ã§ap _ renk _

draw circle on TFT at x _ y _ radius _ color _
TFT daire merkez x _ y _ Ã§ap _ renk _

draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _
TFT Ã¼Ã§gen x _ y _ , x _ y _ , x _ y _ renk _

filled _
dolu _

write _ on TFT at x _ y _ color _
TFT _ yaz konum x _ y _ renk _

scale _ wrap _
Ã¶lÃ§ek _ baÅa sar _

####
# Tone library
# Generates music tones on buzzers

Tone
Ton

attach buzzer to pin _
sesli uyarÄ±cÄ±yÄ± _ pinine baÄla

play note _ octave _ for _ ms
_ notasÄ±nÄ± _ oktavda _ milisaniye Ã§al

play frequency _ for _ ms
_ frekansÄ±nÄ± _ milisaniye Ã§al

play midi key _ for _ ms
mÄ±dÄ± Ã§al nota _ sÃ¼re _ milisaniye

####
# Turtle geometry library

Turtle
KaplumbaÄa

home
baÅlangÄ±Ã§

move _
git _

turn _ degrees
_ derece dÃ¶n

turn _ / _ of circle
dairenin _ / _ kadar dÃ¶n

pen down
kalemi bastÄ±r

pen up
kalemi kaldÄ±r

set pen color to _
kalem rengini _ yap

set pen to random color
kalem rengini rastgele yap

fill display with _
ekranÄ± _ ile doldur

go to x _ y _
x _ y _ konumuna git

point in direction _
_ yÃ¶nÃ¼ne dÃ¶n

####
# File system library

Files
Dosyalar

open file _
_ dosyasÄ±nÄ± aÃ§

close file _
_ dosyasÄ±nÄ± kapat

delete file _
_ dosyasÄ±nÄ± sil

append line _ to file _
_ satÄ±rÄ±  _ dosyasÄ±na ekle

append bytes _ to file _
_ baytlarÄ± _ dosyasÄ±na ekle

end of file _
_ dosya sonu

next line of file _
_ dosyasÄ±nÄ±n sonraki satÄ±rÄ±

next _ bytes of file _
sonraki _ baytlar _ dosyasÄ±nÄ±n

starting at _
baÅla _

file names
dosya adlarÄ±

size of file _
_ dosyasÄ±nÄ±n ebadÄ±

file system info
dosya sistemi bilgisi

####
# WiFi library

WiFi
WiFi

wifi connect to _ password _ try _ times
wifi _ SSIDye baÄlan Åifre _ _ kere dene

wifi create hotspot _ password _
wifi eriÅim noktasÄ± oluÅtur SSID _ Åifre _

IP address
IP adresi

####
# Motion library
# Counts steps and detects motion via the internal accelerometer

Motion
Hareket

motion
hareket

start step counter
adÄ±m sayÄ±cÄ±yÄ± baÅlat

step count
adÄ±m sayÄ±sÄ±

clear step count
adÄ±m sayÄ±sÄ±nÄ± sil

set step threshold _ (0-50)
adÄ±m eÅiÄini _ (0-50) yap

####
# Button Events library

Button Events
Buton OlaylarÄ±

button _ double pressed
buton _ Ã§ift basÄ±ldÄ±

button _ long pressed
buton _ uzun basÄ±ldÄ±

button _ pressed
buton _ basÄ±ldÄ±

####
# Calliope board library

Calliope set LED red _ green _ blue _
Calliope LED ayarla kÄ±rmÄ±zÄ± _ yeÅil _ mavi _

Calliope set speaker _
Calliope hoparlÃ¶rÃ¼ _ yap

Calliope loudness
Calliope ses yÃ¼ksekliÄi

####
# Circuit Playground Express board library

Circuit Playground set speaker _
Circuit Playground hoparlÃ¶rÃ¼ _ yap

Circuit Playground slide switch
Circuit Playground sÃ¼rgÃ¼lÃ¼ anahtar

####
# DotStar LED library

attach _ DotStar LEDs to data pin _ clock pin _
_ DotStar LED"lerini veri pin _ saat pin _ baÄla

set all DotStar LEDs to r _ g _ b _
TÃ¼m DotStar LED"lerini k _ y _ m _ yap

set DotStar LED _ to r _ g _ b _
DotStar LED _ yi k _ y _ m _ yap

set DotStar brightness _
DotStar parlaklÄ±ÄÄ±nÄ± _ yap

####
# BME280 environmental sensor

bme280 connected
bme280 baÄlandÄ±

bmp280 connected
bmp280 baÄlandÄ±

bmx280 temperature
bmx280 Ä±sÄ±sÄ±

bmx280 pressure
bmx280 basÄ±nÃ§

bme280 humidity
bme280 nemi

####
# TCS34725 color sensor

TCS34725 connected
TCS34725 baÄlandÄ±

TCS34725 rgb
TCS34725 kym

color _ name
_ renginin adÄ±

####
# DHT11 environmental sensor

temperature (Celsius) DHT11 pin _
Ä±sÄ±(Celsius) DHT11 pin _

humidity DHT11 pin _
nem DHT11 pin _

temperature (Celsius) DHT22 pin _
Ä±sÄ±(Celsius) DHT22 pin _

humidity DHT22 pin _
nem DHT22 pin _

####
# PN532 RFID reader

read PN532 RFID
PN532 RFID oku

RFID _ = _
RFID _ = _

get PN532 firmware version
PN532 bellenim sÃ¼rÃ¼mÃ¼

####
# HTTP libraries

HTTP client
HTTP istemcisi

_ data _ to httpÜ// _
_ veri _ httpÜ// _

HTTP server
HTTP sunucusu

start HTTP server
HTTP sunucusunu baÅlat

HTTP server request
HTTP sunucu isteÄi

respond _ to HTTP request
HTTP isteÄini _ yanÄ±tla

with body _
gÃ¶vde _

and headers _
ve Ã¼stbilgiler _

body of request _
istek gÃ¶vdesi _

path of request _
istek yolu _

method of request _
istek metodu _

####
# Web Things library

Web Thing
Web Nesneleri

set thing name to _
nesne adÄ±nÄ± _ yap

set thing capability to _
nesne yeteneÄini _ yap

set boolean property _ title _ @Type _
boole Ã¶zellik _ ad _ @Tip _

set string property _ title _ @Type _
dizgi Ã¶zellik _ ad _ @Tip _

set number property _ title _ @Type _
numara Ã¶zellik _ ad _ @Tip _

set number property _ title _ min _ max _ @Type _
numara Ã¶zellik _ ad _ min _ max _ @Tip _

read only _
salt okunur _

register event _ type _
kaydet olay _ tip _

start WebThing server
WebThing sunucusunu baÅlat

trigger event _
_ olayÄ±nÄ± tetikle

thing description JSON
nesnenin tanÄ±mÄ± JSON

properties JSON
Ã¶zellikler JSON

event definitions JSON
olaylarÄ±n tanÄ±mÄ± JSON

events JSON
olaylar JSON

##################
# MicroBlocks UI #
##################

# buttons, error & info messages, dialog boxes, etc

New
Yeni

Open
AÃ§

Open from board
Karttan aÃ§

Information
Ä°nformasyon

Plug in the board.
KartÄ± baÄla

Reading project from board...
Proje karttan okunuyor...

Loading project...
Proje yÃ¼kleniyor...

Found a newer version of
Yeni versiyonu bulundu

Do you want me to update the one in the project?
Dosyadakinin gÃ¼ncellenmesini istermisiniz?

Save
Kaydet

Connect
BaÄlan

disconnect
ayrÄ±l

Serial port:
Seri port:

other...
diÄer...

none
hiÃ§biri

Port name?
Port adÄ±?

Board type:
Kart tipi:

Select board:
Kart seÃ§:

Could not read:
OkuyamadÄ±k:

by
tarafÄ±ndan

Created with GP
GP ile yaratÄ±ldÄ±

More info at http://microblocks.fun
Daha fazla bilgi iÃ§in: http://microblocks.fun

Function "
Fonksiyon "

" is too large to send to board.
" karta yÃ¼klemek iÃ§in Ã§ok bÃ¼yÃ¼k.

Script is too large to send to board.
Betik karta yÃ¼klemek iÃ§in Ã§ok bÃ¼yÃ¼k.

Use "Connect" button to connect to a MicroBlocks device.
MicroBlocks cihazÄ±na balanmak iÃ§in "BaÄlan" dÃ¼Ämesini kullan.

No boards found; is your board plugged in?
Kart algÄ±lanmadÄ±; kardÄ±nÄ±z baÄlÄ± mÄ±?

For AdaFruit boards, double-click reset button and try again.
AdaFruit kartlarÄ± iÃ§in sÄ±fÄ±rlama dÃ¼Ämesini Ã§ift tÄ±klayÄ±n ve tekrar deneyin.

The board is not responding.
Kart cevap vermiyor.

Try to Install MicroBlocks on the board?
Karta Microblocks kurulsun mu?

The MicroBlocks in your board is not current
Karttaki MicroBlocks gÃ¼ncel deÄil

Try to update MicroBlocks on the board?
Karttaki MicroBlocks gÃ¼ncellensin mi?

Stop
Dur

Start
BaÅla

Quit MicroBlocks?
MicroBlocks'dan Ã§Ä±kmak istermisiniz?

Discard current project?
Projenizi iptal etmek istermisiniz?

clean up
temizle

arrange scripts
betikleri dÃ¼zenle

undrop (ctrl-Z)
geri al

copy all scripts to clipboard
tÃ¼m betikleri panoya kopyala

paste all scripts
tÃ¼m betikleri yapÄ±ÅtÄ±r

paste script
betik yapÄ±ÅtÄ±r

save a picture of all scripts
tÃ¼m betiklerin resimlerini kaydet

about...
hakkÄ±nda...

virtual machine version
sanal makine sÃ¼rÃ¼mÃ¼

update firmware on board
yerleÅik bellenimi gÃ¼ncelle

show data graph
veri grafiÄini gÃ¶ster

set serial delay
seri gecikmeyi ayarla

firmware version
yerleÅik bellenim sÃ¼rÃ¼mÃ¼

start WebThing server
WebThing sunucusunu baÅlat

stop WebThing server
WebThing sunucusunu durdur

HTTP Server
--MISSING--

MicroBlocks HTTP Server listening on port 6473
MicroBlocks HTTP Sunucusu 6473 numaralÄ± baÄlantÄ± noktasÄ±nda dinliyor

disable autoloading board libraries
kitaplÄ±klarÄ±nÄ±n otomatik yÃ¼klemesini devre dÄ±ÅÄ± bÄ±rak

enable autoloading board libraries
kitaplÄ±klarÄ±nÄ±n otomatik yÃ¼klemesini etkinleÅtir

enable PlugShare when project empty
yeni proje iÃ§in Plugshare etkinleÅtir

disable PlugShare when project empty
yeni proje iÃ§in Plugshare etkinleÅtirme

erase flash and update firmware on ESP board
esp yi silme ve yeniden bÃ¶lÃ¼mleme

Use board type
kart tipini kullan

Wiping board...
kart siliniyor...

(press ESC to cancel)
(iptal etmek iÃ§in ESC tuÅuna basÄ±n)

Done!
Bitti!

download and install latest VM
en son VM'yi indirin ve yÃ¼kleyin

Select board type:
Kart tipini seÃ§:

Uploading MicroBlocks to board...
MicroBlocks karta yÃ¼kleniyor...

copy data to clipboard
verileri panoya kopyala

clear data
verileri sil

clear memory and variables
bellek ve deÄiÅkenleri sil

show advanced blocks
geliÅmiÅ bloklarÄ± gÃ¶ster

export functions as library
fonksiyonlarÄ± kitaplÄ±k olarak dÄ±ÅarÄ± aktar

hide advanced blocks
geliÅmiÅ bloklarÄ± gizle

Data Graph
Veri GrafiÄi

show instructions
yÃ¶nergeleri gÃ¶ster

show compiled bytes
derlenmiÅ baytlarÄ± gÃ¶ster

expand
aÃ§Ä±ndÄ±r

collapse
daralt

rename...
adÄ±nÄ± deÄiÅtir...

show block definition...
blok tanÄ±mÄ±nÄ± gÃ¶ster...

show the definition of this block
bu bloÄun tanÄ±mÄ±nÄ± gÃ¶ster

delete block definition...
blok tanÄ±mÄ±nÄ± sil...

delete the definition of this block
bu bloÄun tanÄ±mÄ±nÄ± sil

duplicate
Ã§oÄalt

duplicate this block
bu bloÄu Ã§oÄalt

delete block
bloÄu sil

delete this block
bu bloÄu sil

just this one block
yalnÄ±z bu blok

copy to clipboard
panoya kopyala

copy these blocks to the clipboard
bu bloklarÄ± panoya kopyala

duplicate all
tÃ¼mÃ¼nÃ¼ Ã§oÄalt

duplicate these blocks
bu bloklarÄ± Ã§oÄalt

extract block
bloÄu ayÄ±rt

pull out this block
bu bloÄu ayÄ±rt

save picture of script
betiÄin resmini kaydet

save a picture of this block definition as a PNG file
bu blok tanÄ±mÄ±nÄ±n resmini PNG dosyasÄ± olarak kaydet

save a picture of these blocks as a PNG file
bu bloklarÄ±n resimlerini PNG dosyasÄ± olarak kaydet

copy script
betiÄi kopyala

delete
sil

Input type:
Girdi tipi:

string only
yalnÄ±z dizgi

string or number
dizgi veya sayÄ±

number only
yalnÄ±z sayÄ±

define
tanÄ±mla

number/string
sayÄ±/dizgi

editable number or string
dÃ¼zenlenebilir sayÄ± veya dizgi

label
etiket

input
girdi

hide block definition
blok tanÄ±mÄ±nÄ± gizle

Are you sure you want to remove this block definition?
Bu bloÄun tanÄ±mÄ±nÄ± sileceÄinden emin misin?

Language
Dil

Custom...
Ãzel...

Obsolete
GeÃ§ersiz

OK
Tamam

Ok
Tamam

Yes
Evet

No
HayÄ±r

Cancel
Ä°ptal

Okay
Tamam

Confirm
Onayla

# File picker and library dialogs

Libraries
KitaplÄ±klar

Examples
Ãrnekler

Desktop
MasaÃ¼stÃ¼

Computer
Bilgisayar

Cloud
Bulut

File
Dosya

File Open
Dosya AÃ§

File Save
Dosya Kaydet

File name:
Dosya adÄ±:

New Folder
Yeni KlasÃ¶r

by
tarafÄ±ndan

Depends:
BaÄlÄ±:

Tags:
Tegler:

Path, name or URL for library?
KÃ¼tÃ¼phanenin Yol, ad veya URL'si?

Invalid URL
geÃ§ersiz URL

Could not fetch library.
KitaplÄ±k getirilemedi.

Host does not exist or is currently down.
Ana makine mevcut deÄil veya Åu anda kapalÄ±.

File not found in server.
Dosya sunucuda bulunamadÄ±.

Server expects HTTPS, and MicroBlocks doesn't currently support it.
Sunucu HTTPS bekliyor ve MicroBlocks Åu anda desteklemiyor.

library information
kitaplÄ±k bilgileri

built-in library
yerleÅik kitaplÄ±k

Dependency path, name or URL?
BaÄÄ±mlÄ±lÄ±k yol, ad veya URl'si

Tag name?
Teg adÄ±?

############
# Tips Bar #
############

Boolean Input
Boole Girdisi

[l] toggle value, or drop a reporter into it.
[l] deÄeri deÄiÅtirin veya iÃ§ine bir raportÃ¶r bÄ±rakÄ±n.

Color Input
Renk Girdisi

[l] change the color, or drop a reporter into it.
[l] rengi deÄiÅtirin veya iÃ§ine bir raportÃ¶r bÄ±rakÄ±n.

Input
Girdi

[l] edit its value, or drop a reporter into it.
[l] deÄerini dÃ¼zenleyin veya iÃ§ine bir raportÃ¶r bÄ±rakÄ±n.

Block Extension
Blok UzantÄ±sÄ±

[l] right arrow to show optional inputs, left arrow to hide.
[l] isteÄe baÄlÄ± giriÅleri gÃ¶stermek iÃ§in saÄ ok, gizlemek iÃ§in sol ok.

Command Block
Komut bloÄu

[l] to run, or drag to build scripts. [r] menu.
Ã§alÄ±ÅtÄ±rmak iÃ§in [l] veya komut dosyalarÄ± oluÅturmak iÃ§in sÃ¼rÃ¼kleyin. [r] menÃ¼.

Hat Block
Åapka BloÄu

[l] to run, or drag to build scripts. [r] menu.
Ã§alÄ±ÅtÄ±rmak iÃ§in [l] veya komut dosyalarÄ± oluÅturmak iÃ§in sÃ¼rÃ¼kleyin. [r] menÃ¼.

Reporter Block
RaportÃ¶r BloÄu

[l] to see value, or drop into an input slot. [r] menu.
deÄeri gÃ¶rmek iÃ§in veya bir girdi alanÄ±na bÄ±rakmak iÃ§in [l] . [r] menÃ¼.

Script
Betik

[l] to run. [r] menu.
[l] Ã§alÄ±ÅtÄ±r. [r] menÃ¼.

Pane Divider
BÃ¶lÃ¼m ayÄ±rÄ±cÄ±sÄ±

Drag to change pane width.
BÃ¶lme geniÅliÄini deÄiÅtirmek iÃ§in sÃ¼rÃ¼kleyin.

Library
KÃ¼tÃ¼phane

[l] to show the blocks in this library. [r] menu.
[l] bu kitaplÄ±ktaki bloklarÄ± gÃ¶ster. [r] menÃ¼.

Block Category
Blok Kategorisi

[l] to show the blocks in this category.
[l] bu kategorideki bloklarÄ± gÃ¶sterÃ§

Palette
Palet

Drag blocks from here to build scripts. Drop scripts here to delete them.
Komut dosyalarÄ± oluÅturmak iÃ§in bloklarÄ± buradan sÃ¼rÃ¼kleyin. Silmek iÃ§in komut dosyalarÄ±nÄ± buraya bÄ±rakÄ±n.

Scripts Pane
Betik BÃ¶lÃ¼mÃ¼

Drag blocks here to build scripts. [r] menu.
Komut dosyalarÄ± oluÅturmak iÃ§in bloklarÄ± buraya sÃ¼rÃ¼kleyin. [r] menÃ¼.

#################################
# Block Descriptions for TipBar #
#################################

Turn the user LED on or off.
KullanÄ±cÄ± LED'ini aÃ§Ä±n veya kapatÄ±n.

Display a bubble showing the value.
DeÄeri gÃ¶steren bir balon gÃ¶rÃ¼ntÃ¼leyin.

Graph the value.
DeÄerin grafiÄini Ã§izin.

Report the state of button A ( (-o) or (o-) ).
A dÃ¼Ämesinin ( (-o) veya (o-) ) durumunu bildirin.

Report the state of button B ( (-o) or (o-) ).
B dÃ¼Ämesinin ( (-o) veya (o-) ) durumunu bildirin.

Report the milliseconds since the timer was last reset.
ZamanlayÄ±cÄ±nÄ±n en son sÄ±fÄ±rlanmasÄ±ndan bu yana geÃ§en milisaniyeleri bildirin.

Reset the timer.
ZamanlayÄ±cÄ±yÄ± sÄ±fÄ±rlayÄ±n.

Report the milliseconds since power up.
GÃ¼Ã§ aÃ§Ä±ldÄ±ktan sonraki milisaniyeleri bildirin.

Report the microseconds since power up.
GÃ¼Ã§ aÃ§Ä±ldÄ±ktan sonraki mikrosaniyeleri bildirin.

Report the board type.
Kart tipini bildirin.

Report the electrical logic level on a digital pin ( (-o) or (o-) ).
bir dijital pimdeki elektriksel mantÄ±k seviyesini ( (-o) veya (o-) ) bildirin.

Report a number proportional to the voltage on an analog pin (0 = ground, 1023 = supply voltage).
Analog pin Ã¼zerindeki voltajla orantÄ±lÄ± bir sayÄ± bildirin (0 = toprak, 1023 = besleme voltajÄ±).

Turn a pin on or off ( (-o) or (o-) ).
Bir pimi aÃ§Ä±n veya kapatÄ±n ( (-o) veya (o-) ).

Pulse width modulate (PWM) a pin with the given duty cycle (0 - 1023).
Verilen gÃ¶rev dÃ¶ngÃ¼sÃ¼ (0 - 1023) ile bir pin darbe geniÅliÄi modÃ¼lasyonu (PWM).

Report number of analog pins on this device.
Bu cihazdaki analog pin sayÄ±sÄ±nÄ± bildir.

Report number of digital pins on this device.
Bu cihazdaki dijital pin sayÄ±sÄ±nÄ± bildirin.

Report the value of a register (0-255) of an I2C device (0-127).
I2C cihazÄ±nÄ±n (0-127) sayacÄ±nÄ±n (0-255) deÄerini bildirin.

Set an I2C device and register to given value (0-255).
I2C cihazÄ±nÄ±  ve sayacÄ±nÄ± verilen deÄere (0-255) ayarlayÄ±n.

Receive multiple bytes from an I2C device.
I2C cihazÄ±ndan birden Ã§ok bayt alÄ±n.

Send multiple bytes to an I2C device.
I2C cihazÄ±na birden Ã§ok bayt gÃ¶nderin.

Send a byte (0-255) to an SPI device.
SPI cihazÄ±na bir bayt (0-255) gÃ¶nderin.

Read a byte from an SPI device while sending a zero byte. Report the byte received.
SÄ±fÄ±r bayt gÃ¶nderirken bir SPI cihazÄ±ndan bir bayt okuyun. AlÄ±nan baytÄ± bildirin.

Set the SPI clock speed and mode.
SPI saat hÄ±zÄ±nÄ± ve modunu ayarlayÄ±n.

Send a byte array via SPI, replacing its contents with the bytes received.
Ä°Ã§eriÄini alÄ±nan baytlarla deÄiÅtirerek SPI aracÄ±lÄ±ÄÄ±yla bir bayt dizisi gÃ¶nderin.

Open the serial port at the given baud rate.
Verilen baud hÄ±zÄ±nda seri baÄlantÄ± noktasÄ±nÄ± aÃ§Ä±n.

Close the serial port.
Seri baÄlantÄ± noktasÄ±nÄ± kapatÄ±n.

Report data received from the serial port (a byte array).
Seri baÄlantÄ± noktasÄ±ndan (bir bayt dizisi) alÄ±nan verileri bildirin.

Send a byte array to the serial port.
Seri baÄlantÄ± noktasÄ±na bir bayt dizisi gÃ¶nderin.

Run when the board powers up or when the IDE start button is clicked.
Kart aÃ§Ä±ldÄ±ÄÄ±nda veya IDE baÅlat dÃ¼Ämesine tÄ±klandÄ±ÄÄ±nda Ã§alÄ±ÅtÄ±rÄ±n.

Run when buttons A, B, or A+B are pressed.
A, B veya A+B dÃ¼Ämelerine basÄ±ldÄ±ÄÄ±nda Ã§alÄ±ÅtÄ±rÄ±n.

Repeat the enclosed blocks indefinitely.
Ä°Ã§erilen bloklarÄ± sÃ¼resiz olarak tekrarlayÄ±n.

Repeat the enclosed blocks the given number of times.
Ä°Ã§erilen bloklarÄ± verilen sayÄ±da tekrarlayÄ±n.

Wait the given number of milliseconds.
Verilen milisaniye kadar bekleyin.

Run the first set of blocks whose test condition is (-o) .
Test koÅulu (-o) olan ilk blok grubunu Ã§alÄ±ÅtÄ±rÄ±n.

Run when the condition becomes (-o) .
KoÅul (-o) olduÄunda Ã§alÄ±ÅtÄ±rÄ±n.

Wait until the condition becomes (-o) .
KoÅul (-o) olana kadar bekleyin.

Return (report) the given value from a function or script.
Bir iÅlevden veya betikten verilen deÄeri dÃ¶ndÃ¼rÃ¼n (bildirin).

Run when the given message is broadcast.
Verilen mesaj yayÄ±nlandÄ±ÄÄ±nda Ã§alÄ±ÅtÄ±rÄ±n.

Broadcast the given message.
Verilen mesajÄ± yayÄ±nlayÄ±n.

Do nothing. Used to add notes and documentation.
HiÃ§bir Åey yapma. Notlar ve belgeler eklemek iÃ§in kullanÄ±lÄ±r.

Repeat the enclosed blocks with the variable set to the current iteration number or item.
Ä°Ã§erilen bloklarÄ±, deÄiÅken geÃ§erli yineleme numarasÄ±na veya Ã¶Äeye ayarlanmÄ±Å olarak tekrarlayÄ±n.

Repeat the enclosed blocks until the condition becomes (-o) .
KoÅul (-o) olana kadar Ä°Ã§erilen bloklarÄ± tekrarlayÄ±n.

Stop this task.
Bu gÃ¶revi durdur.

Stop all tasks except this one.
Bunun dÄ±ÅÄ±ndaki tÃ¼m gÃ¶revleri durdurun.

Wait the given number of microseconds.
Verilen mikrosaniye kadar bekleyin.

Report the last broadcast message received.
AlÄ±nan son yayÄ±n mesajÄ±nÄ± bildirin.

Call the function with the given name and optional parameter list.
Verilen ad ve isteÄe baÄlÄ± parametre listesi ile iÅlevi Ã§aÄÄ±rÄ±n.

Call the function with the given name and optional parameter list and report its return value.
Belirtilen ad ve isteÄe baÄlÄ± parametre listesi ile iÅlevi Ã§aÄÄ±rÄ±n ve dÃ¶nÃ¼Å deÄerini bildirin.

Report the sum of the given numbers.
Verilen sayÄ±larÄ±n toplamÄ±nÄ± bildiriniz.

Report the first number minus the second.
Ä°lk sayÄ± eksi ikinci sonucunu bildirin.

Report the product of the given numbers.
Verilen sayÄ±larÄ±n Ã§arpÄ±mÄ±nÄ± bildirin.

Report the first number divided by the second.
Ä°kinci bÃ¶lÃ¼ ilk sayÄ±yÄ± bildirin.

Report the remainder of dividing the first number by the second.
Ä°lk sayÄ±yÄ± ikinciye bÃ¶lmenin kalanÄ±nÄ± bildirin.

Report the absolute value of the given number (always >= 0).
Verilen sayÄ±nÄ±n mutlak deÄerini bildirin (daima >= 0).

Report the minimum of the values.
Minimum deÄeri bildirin.

Report the maximum of the values.
Maksimum deÄeri bildirin.

Report a randomly chosen number in the given range.
Verilen aralÄ±kta rastgele seÃ§ilen bir sayÄ±yÄ± bildirin.

Report (-o) if the first value is less than the second one.
Ä°lk deÄer ikinciden kÃ¼Ã§Ã¼kse (-o) rapor edin.

Report (-o) if the first value is less than or equal to the second one.
Ä°lk deÄer ikinciden kÃ¼Ã§Ã¼k veya ona eÅit ise (-o) rapor edin .

Report (-o) if the two values are equal.
Ä°ki deÄer eÅitse (-o) rapor edin.

Report (-o) if the two values are not equal.
Ä°ki deÄer eÅit deÄilse (-o) rapor edin .

Report (-o) if the first value is greater than or equal to the second one.
Ä°lk deÄer ikinciden bÃ¼yÃ¼k veya ona eÅitse (-o) bildirin.

Report (-o) if the first value is greater than the second one.
Ä°lk deÄer ikinciden bÃ¼yÃ¼kse (-o) rapor edin.

Boolean constant ( (-o) or (o-) ).
Boole sabiti ( (-o) veya (o-) ).

Report the logical inverse of a Boolean ( (-o) or (o-) ) value.
Boolean ( (-o) veya (o-) ) deÄerinin mantÄ±ksal tersini bildirin.

Report (-o) if both values are (-o)
Her iki deÄer de (-o) ise (-o) rapor edin.

Report (-o) if either value is (-o)
Herhangi bir deÄer (-o) ise (-o) rapor edin.

Report (-o) if first input is a value of the given data type.
Rapor (-o) eÄer ilk girdi verilen veri tipiyse.

Report the numerical value of a hexadecimal string (range: -0x1FFFFFFF to 0x1FFFFFFF)
OnaltÄ±lÄ±k bir dizenin sayÄ±sal deÄerini bildirin (aralÄ±k: -0x1FFFFFFF - 0x1FFFFFFFF)

Report bitwise AND of two numbers.
Ä°ki sayÄ±nÄ±n bit dÃ¼zeyinde VE deÄerini bildirin.

Report bitwise OR of two numbers.
Ä°ki sayÄ±nÄ±n bit dÃ¼zeyinde VEYA deÄerini bildirin.

Report bitwise XOR (exclusive OR) of two numbers.
Ä°ki sayÄ±nÄ±n bit dÃ¼zeyinde XOR'unu (Ã¶zel VEYA) bildirin.

Report bitwise inverse of the given number.
Verilen sayÄ±nÄ±n bit dÃ¼zeyinde tersini bildirin.

Report the given number shifted left by the given number of bits.
Verilen sayÄ±yÄ± verilen bit sayÄ±sÄ± kadar sola kaydÄ±rÄ±n.

Report the given number shifted right by the given number of bits (arithmetic shift; sign is maintained).
Verilen sayÄ±yÄ± verilen bit sayÄ±sÄ± kadar saÄa kaydÄ±rÄ±n (arÄ±tmetik kaydÄ±rma, iÅaret korunur).

Set a variable to the given value.
Bir deÄiÅkeni verilen deÄere ayarlayÄ±n.

Change a variable by the given amount.
Bir deÄiÅkeni verilen deÄerde deÄiÅtirin.

Create a variable local to the containing script with the given initial value.
Verilen baÅlangÄ±Ã§ deÄeriyle yerel bir deÄiÅkeni iÃ§erilen komut dosyasÄ±nda  oluÅturun.

Report the Nth item of a list, string, or byte array.
Bir listenin, dizenin veya bayt dizisinin N. Ã¶Äesini bildirin.

Report the number of items in a list, string, or byte array.
Liste, dize veya bayt dizisindeki Ã¶Äelerin sayÄ±sÄ±nÄ± bildirin.

Join (concatenate) the given lists, strings, or byte arrays and report the result.
Verilen listeleri, dizeleri veya bayt dizilerini birleÅtirin ve sonucu bildirin.

Create and report a short list containing the given items. Length limited by available stack space.
Verilen Ã¶Äeleri iÃ§eren kÄ±sa bir liste oluÅturun ve rapor edin. Uzunluk, kullanÄ±labilir yÄ±ÄÄ±n alanÄ±yla sÄ±nÄ±rlÄ±dÄ±r.

Add an item to the end of a list.
Listenin sonuna bir Ã¶Äe ekleyin.

Replace the Nth item (or all items) of a list or byte array with the given value.
Bir listenin veya bayt dizisinin N. Ã¶Äesini (veya tÃ¼m Ã¶Äelerini) verilen deÄerle deÄiÅtirin.

Delete the Nth item (or all items) of a list.
Listenin N. Ã¶Äesini (veya tÃ¼m Ã¶Äelerini) silin.

Find and report the index of an item in a list or a substring within a string. Report -1 if not found.
Bir listedeki bir Ã¶Äenin dizinini veya bir dize iÃ§indeki bir alt dizeyi bulun ve bildirin. Bulunamazsa -1 rapor edin.

Report a copy from the given index through the end (or optional stop index) of the given list, string, or byte array.
Verilen listenin, dizenin veya bayt dizisinin sonuna (veya isteÄe baÄlÄ± durdurma indeksine) kadar verilen dizinden bir kopya bildirin.

Split the given string with the given delimiter and report the result (a list of strings).
Verilen dizgiyi verilen sÄ±nÄ±rlayÄ±cÄ± ile bÃ¶lÃ¼n ve sonucu rapor edin (dizelerin bir listesi).

Combine the items of a list into a string, optionally separated by a delimiter (e.g. comma).
Bir listenin Ã¶Äelerini, isteÄe baÄlÄ± olarak bir sÄ±nÄ±rlayÄ±cÄ±yla (Ã¶r. virgÃ¼l) ayÄ±rarak bir dizede birleÅtirin.

Report the Unicode value ("code point") of the Nth character of the given string.
Verilen dizenin N. karakterinin Unicode deÄerini ("kod noktasÄ±") bildirin.

Report a string containing the given Unicode value ("code point") or list of values.
Verilen Unicode deÄerini ("kod noktasÄ±") veya deÄerler listesini iÃ§eren bir dize bildirin.

Report a new list of the given length filled with zero or the optional value.
SÄ±fÄ±r veya isteÄe baÄlÄ± deÄerle doldurulmuÅ verilen uzunlukta yeni bir liste bildirin.

Report a new byte array of the given length filled with zero or the optional value.
SÄ±fÄ±r veya isteÄe baÄlÄ± deÄerle doldurulmuÅ, verilen uzunlukta yeni bir bayt dizisi bildirin.

Report a byte array containing the UTF-8 bytes of the given string.
Verilen dizenin UTF-8 baytlarÄ±nÄ± iÃ§eren bir bayt dizisini bildirin.

Report the number of words of memory available. Stop button frees up memory.
KullanÄ±labilir bellekteki sÃ¶zcÃ¼k sayÄ±sÄ±nÄ± bildirin. Durdur dÃ¼Ämesi hafÄ±zayÄ± boÅaltÄ±r.

# MicroBlocks translation file
# Last updated: July 07 2020

#########################
# Blocks and categories #
#########################

Output
Chiqarish

set user LED _
foydalanuvchi LED o'rnatish _

say _
aytmoq _

graph _
grafik _

Input
Kiritish

button A
A tugmasi

button B
B tugmasi

microseconds
mikrosoniyalar

milliseconds
millisekundlar

board type
karta turi

Pins
Pins

read digital pin _
raqamli pinni o'qish _

read analog pin _
analog pinni o'qish _

set digital pin _ to _
raqamli pinni _ ga oârnatish

set pin _ to _
pinni _ ga  o'rnatish

analog pins
pin analoglari

digital pins
raqamli pin

Control
Nazorat

when started
qachon boshlangan

when button _ pressed
_ tugmasini bosganingizda

forever _
doimiy _

repeat _ _
takrorlash _ _

wait _ millisecs
_ millisekundlar kutish

if _ _
agar _ _

else if _ _
yana boshqa, agar _ _

if _ _ else _
agar _ _ yana boshqa _

else
yana boshqa

when _
qachon _

wait until _
_ gacha kutish

wait _ microsecs
_ microsekundlar kutish

return _
qaytish _

when _ received
qachon _ qabul qilinganda

broadcast _
broadcast _

comment _
izoh _

for _ in _ _
uchun _ da _ _

repeat until _ _
_ _ gacha takrorlash

stop this task
bu vazifani to'xtatish

stop other tasks
boshqa vazifalarni to'xtatish

stop all
hammasini to'xtatish

last message
oxirgi xabar

Operators
Operatorlar

_ mod _
_ rejim _

abs _
abs _

random _ to _
tasodifiy _ ga _

not _
yo'q _

_ and _
_ va _

and _
va _

_ or _
_ yoki _

or _
yoki _

_ is a _
_ - bu _

boolean
mantiqiy

number
raqam

string
qator

list
ro'yxat

Advanced:
--MISSING--

hex _
hex _

Variables
O'zgaruvchan

# Buttons on top of "Variables" category

Add a variable
O'zgaruvchini qo'shing

Delete a variable
O'zgaruvchini o'chirish

# New variable dialog

New variable name?
Yangi o'zgaruvchi nom?

set _ to _
_ ga _ o'rnatish

change _ by _
_ tomonidan _ o'zgartirish

initialize local _ to _
--MISSING--

Data
Ma'lumotlar

list
ro'yxat

length of _
uzunligi _

item _ of _
element _ ning _

replace item _ of list _ with _
_ ro'yxatidagi _ bandini _ bilan almashtiring

delete item _ of list _
_ ro'yxatidan _ elementini o'chirish

add _ to list _
_ ro'yxatiga _ qo'shish

join _ _
bog'lamoq

copy _ from _
_ dan _ nusxalash

to _
uchun _

find _ in _
_ ichidan topish

starting at _
_ dan boshlab

join items of list _
_ ro'yxat elementlariga qo'shilish

separator _
ajratuvchi _

unicode _ of _
_unikodi

string from unicode _
unikoddan olingan satr _

new list length _
yangi ro'yxatning uzunligi _

new byte array _
--MISSING--

free memory
bo'sh xotira

My Blocks
Mening Bloklarim

# Buttons on top of "My Blocks" category

Add a command block
Buyruq blokini qo'shing

Add a reporter block
Uzatuvchi blokni qo'shish

# Make a block dialog

Enter function name:
Funksiya nomini kiriting:

Comm
Aloqa

i2c get device _ register _
i2c qurilmani _ ro'yxatiga olish

i2c set device _ register _ to _
i2c qurilmasini _ ga _ ro'yxatiga olish

i2c device _ read list _
i2c qurilmasi _ o'qish ro'yxati _

i2c device _ write list _
i2c qurilmasi _ yozish ro'yxati _

spi send _
spi yuboring _

spi receive
spi olish

print _
chop etish _

no op
op yo'q

ignore
e'tibor bermaslik

##############
# Primitives #
##############

# These are all mostly hidden from end users

draw shape _ at x _ y _
_shaklini _ x _ y _ ga chizish

shape for letter _
xatning shakli _

send NeoPixel rgb _
NeoPixel rgb ni yuborish

has tone support
ohangni qo'llab-quvvatlaydi

play tone pin _ frequency _
ohang tezligini _ ijro etish _

has WiFi support
Wi-Fi bor

start WiFi _ password _
Wi-Fi ni _ parol bilan ishga tushirish

stop WiFi
Wi-Fi-ni to'xtatish

WiFi status
Wi-Fi holati

my IP address
mening IP manzilim

radio send number _
radio raqamini yuborish _

radio send string _
radio yuborish satr _

radio send pair _ = _
radio juftligini _ = _ yuborish

radio message received?
radio xabar olinganmi?

radio last number
radio oxirgi raqami

radio last string
radio oxirgi satr

radio last message type
radio so'nggi xabar turi

radio set group _
radio seti guruhi _

radio set channel (0-83) _
radio kanali kanal (0-83) _

radio set power (0-7) _
radio rostlagich kuchi (0-7) _

radio last signal strength
radio oxirgi signal kuchi

radio receive packet _
radio qabul qilish paketi _

radio send packet _
radio paketini jo'natish _

disable radio
radioni o'chirib qo'yish

#############
# Libraries #
#############

Basic Sensors
Asosiy sensorlar

tilt x
burilish x

tilt y
burilish y

tilt z
burilish z

acceleration
tezlashtirish

light level
yorug'lik darajasi

temperature (Â°C)
harorat (Â°C)

####
# NeoPixel library

NeoPixel
NeoPixel

set NeoPixels _ _ _ _ _ _ _ _ _ _
o'rnatish NeoPixels _ _ _ _ _ _ _ _ _ _

clear NeoPixels
NeoPixelsni tozalash

set NeoPixel _ color _
NeoPixel _ rangga _ belgilash

set all NeoPixels color _
barcha NeoPixels ranglarini sozlash _

rotate NeoPixels by _
NeoPixels ni _ bilan almashtirish

color r _ g _ b _ (0-255)
rang r _ g _ b _ (0-255)

random color
tasodifiy rang

attach _ LED NeoPixel strip to pin _
_ LED NeoPixel chizig'ini piniga bog'lash _

has white _
oq _

PIR
PIR

PIR at pin _ detected movement
PIR da aniqlangan harakat

####
# Citilab ED1 board libraries

ED1 Stepper Motor
ED1 Stepper Motori

move motor _ _ steps _
harakatlanuvchi motor _ _ qadamlar _

move motor 1 _ and motor 2 _ _ steps
motor 1 _ va motor 2 _ _ qadamlarini harakatlantiring

move motor _ angle _ Â°
dvigatelni _ gradusga _ Â° harakatga keltirish

move motor _ _ complete turns
motorli mdvigatel _ to'liq buriladi

stop steppers
qadamlarni to'xtating

clockwise
soat yo'nalishi bo'yicha

counter-clockwise
soat yo'nalishi bo'yicha-hisoblash

ED1 Buttons
ED1 tugmachalari

button OK
OK tugmasi

button X
X tugmasi

button up
tepaga tugmasi

button down
pastga tugmasi

button left
chapga tugmasi

button right
o'ngga tugmasi

capacitive sensor _
sig'imi sensor _

set capacitive threshold to _
threshold sig'imini o'rnatish _

####
# BirdBrain Technologies libraries

Hummingbird LED _ _ %
Hummingbird LED _ _%

Hummingbird Tri-LED _ R _ % G _ % B _ %
Hummingbird Tri-LED _ R _ % G _ % B _ %

Hummingbird Position Servo _ _ Â°
Hummingbird joylashuvi Servo _ _ Â°

Hummingbird Rotation Servo _ _ %
Hummingbird aylantirish servo _ _%

Hummingbird _ _
Hummingbird _ _

Hummingbird Battery (mV)
Hummingbird batareyasi (mV)

Light
Yorug'lik

Distance (cm)
Masofa (sm)

Dial
Nomer termoq

Sound
Ovoz

Other
Boshqalar

Finch Beak Red _ Green _ Blue _
--MISSING--

Finch Tail _ Red _ Green _ Blue _
--MISSING--

Finch Move _ _ cm at _ %
--MISSING--

Finch Turn _ _ Â° at _ %
--MISSING--

Finch Wheels L _ % R _ %
--MISSING--

Finch Stop
--MISSING--

Finch Distance (cm)
--MISSING--

Finch _ Light
--MISSING--

Finch _ Line
--MISSING--

Finch Reset Encoders
--MISSING--

Finch _ Encoder
--MISSING--

Finch Accelerometer _
--MISSING--

Finch Battery
--MISSING--

All
--MISSING--

Forward
--MISSING--

Backward
--MISSING--

Right
--MISSING--

Left
--MISSING--

Beak Up
--MISSING--

Beak Down
--MISSING--

Tilt Left
--MISSING--

Tilt Right
--MISSING--

Level
--MISSING--

Upside Down
--MISSING--

x
--MISSING--

y
--MISSING--

z
--MISSING--

strength
--MISSING--

####
# Ultrasound distance library

distance (cm) trigger _ echo _
masofa (sm) trigger _ echo _

####
# Infrared remote library

IR Remote
IR masofadan boshqarish pulti

receive IR code
qurilmadan IR kodni qabul qilish

receive IR code from device _
qurilmadan IR kodni olish _

test IR
IR ni sinash

attach IR receiver to pin _
IR qabul qilgichini _ pinga ulang-

####
# Radio comm library
# Allows micro:bit boards to exchange messages
# All of its blocks are primitive (see "Primitives" section)

Radio
Radio

####
# Text scrolling library
# Scrolls text on 5x5 LED displays and simulated ones

Scrolling
Aylantirish

scroll text _
matnni aylantirish _

scroll number _
_ raqamni aylantirish

pausing _ ms
ps pauza qilmoq

stop scrolling
o'tishni to'xtatish

####
# Servo motor library

Servo
Servo

set servo _ to _ degrees (-90 to 90)
servo -ni _ darajasiga o'rnatish (-90 dan 90 gacha)

set servo _ to speed _ (-100 to 100)
servo _ tezligini _ ga sozlang (-100 dan 100 gacha)

stop servo _
servoni to'xtatish _

####
# 5x5 LED display library
# Supports the micro:bit display, but also simulated 5x5 displays on boards
# with differently sized LED arrays, NeoPixel arrays or TFT displays

LED Display
LED displey

display _
namoyish qilish (displey) _

clear display
displeyni olib tashlash

plot x _ y _
qurish x _ y _

unplot x _ y _
chiqarish x _ y _

display character _
belgini ko'rsatish _

####
# TFT display library

enable TFT _
yoqish TFT _

TFT width
TFT kengligi

TFT height
TFT balandligi

set TFT pixel x _ y _ to _
x _ y _ ga _ TFT piksel o'rnatish

draw line on TFT from x _ y _ to x _ y _ color _
TFT ga x _ y _ dan x _ y _ color _gacha  chiziq chizish

draw rectangle on TFT at x _ y _ width _ height _ color _
Toârtburchakni TFT ga x _ y _ kenglik _ balandlik _ rangda chizing

draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _
Yumaloq toârtburchakni TFT ga x_ y_ kenglik _ balandlik _ radius _ rangda chizing

draw circle on TFT at x _ y _ radius _ color _
doirani TFT ga _ radiusda _ rangda chizish

draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _
uchburchakni TFT ustiga x _ y _, x _ y _, x _ y _ rangda chizish

filled _
to'ldirilgan _

write _ on TFT at x _ y _ color _
TFT ustiga _ x _ y rangida _ yozish

scale _ wrap _
o'lchov _

####
# Tone library
# Generates music tones on buzzers

Tone
Ohang

attach buzzer to pin _
qoângâiroqni pinga biriktirish

play note _ octave _ for _ ms
eslatmani _ octave _ ms davomida ijro etish

play frequency _ for _ ms
chastotasini _ ms davomida ijro etish

play midi key _ for _ ms
midi tugmachasini _ ms ijro etish

####
# Turtle geometry library

Turtle
Toshbaqa

home
uy

move _
ko'chirish _

turn _ degrees
_ darajaga burish

turn _ / _ of circle
aylanadan _ / _ buriling

pen down
qalam pastga

pen up
qalam yuqoriga

set pen color to _
qalam rangini _ ga belgilash

set pen to random color
qalamni tasodifiy rangga qo'ying

fill display with _
displeyni _ bilan to'ldiring

go to x _ y _
x _ y _ ga o'tish

point in direction _
yo'nalish bo'yicha nuqta _

####
# File system library

Files
Fayllar

open file _
faylni ochish

close file _
faylni yopish

delete file _
faylni o'chirish _

append line _ to file _
_ fayliga _ qatorini qo'shish

append bytes _ to file _
_ fayliga baytni qo'shish

end of file _
faylning oxiri _

next line of file _
faylning keyingi qatori _

next _ bytes of file _
keyingi _ bayt fayl _

starting at _
_ dan boshlab

file names
fayl nomlari

size of file _
fayl hajmi _

file system info
fayl tizimi haqida ma'lumot

####
# WiFi library

WiFi
WiFi

wifi connect to _ password _ try _ times
wifi parolini _ uslash _ marta harak qildi

wifi create hotspot _ password _
wifi hotspot yaratish _ parol _

IP address
IP address

####
# Motion library
# Counts steps and detects motion via the internal accelerometer

Motion
Harakat

motion
harakat

start step counter
qadamlar sonini hisoblagich

step count
qadamlar soni

clear step count
qadamlar sonini o'chirish

set step threshold _ (0-50)
qadam chegarasini belgilash _ (0-50)

####
# Button Events library

Button Events
Tugma hodisalr

button _ double pressed
_ tugmasi ikki marta bosildi

button _ long pressed
_ tugmasi uzoq bosildi

button _ pressed
 _ tugmasi bosildi

####
# Calliope board library

Calliope set LED red _ green _ blue _
Calliope diodli qizil _ yashil _ ko'k _ belgilash

Calliope set speaker _
Calliope karnayni _ belgilash

Calliope loudness
Kalliopa balandligi

####
# Circuit Playground Express board library

Circuit Playground set speaker _
Circuit Playground dinamikni o'rnatish _

Circuit Playground slide switch
Circuit Playground slaydni almashtirish

####
# DotStar LED library

attach _ DotStar LEDs to data pin _ clock pin _
_ DotStar diodlarini LED-ga ulang

set all DotStar LEDs to r _ g _ b _
barcha DotStar LEDlarni r _ g _ b _ ga belgilash

set DotStar LED _ to r _ g _ b _
DotStar LED _ r _ g _ b _ ga belgilash

set DotStar brightness _
DotStar yorqinligini o'rnatish _

####
# BME280 environmental sensor

bme280 connected
bme280 ulangan

bmp280 connected
bmp280 ulangan

bmx280 temperature
bmx280 harorati

bmx280 pressure
bmx280 bosimi

bme280 humidity
bme280 namlik

####
# TCS34725 color sensor

TCS34725 connected
TCS34725 ulangan

TCS34725 rgb
TCS34725 rgb

color _ name
rang _ nomi

####
# DHT11 environmental sensor

temperature (Celsius) DHT11 pin _
harorat (C) DHT11 pin _

humidity DHT11 pin _
namlik DHT11 pin _

temperature (Celsius) DHT22 pin _
harorat (C) DHT22 pin _

humidity DHT22 pin _
namlik DHT22 pin _

####
# PN532 RFID reader

read PN532 RFID
PN532 RFID o'qish

RFID _ = _
RFID _ = _

get PN532 firmware version
PN532 mikrodastur versiyasini olish

####
# HTTP libraries

HTTP client
HTTP mijoz

_ data _ to httpÜ// _
--MISSING--

HTTP server
HTTP server

start HTTP server
HTTP serverni ishga tushirish

HTTP server request
HTTP server so'rovi

respond _ to HTTP request
_ HTTP so'roviga javob berish

with body _
tana bilan _

and headers _
va sarlavhalar _

body of request _
talabnoma qismi _

path of request _
so'rov yo'li _

method of request _
so'rov usuli _

####
# Web Things library

Web Thing
Web Thing

set thing name to _
narsa nomini _ ga sozlash

set thing capability to _
narsa imkoniyatini _ belgilash

set boolean property _ title _ @Type _
boolean xususiyatini o'rnatish _ sarlavha _ @Turi _

set string property _ title _ @Type _
satr xususiyatini belgilash _ sarlavha _ @Turi _

set number property _ title _ @Type _
raqam xususiyatini _ belgilash _ @Turi

set number property _ title _ min _ max _ @Type _
raqam xususiyatini belgilash _ sarlavha _ min _ maksimal _ @Turi _

read only _
faqat o'qish _

register event _ type _
voqeani ro'yxatdan o'tkazish _ turi _

start WebThing server
WebThing serverini ishga tushiring

trigger event _
voqeani boshlash

thing description JSON
narsa tavsifi JSON

properties JSON
JSON xususiyatlari

event definitions JSON
voqea ta'riflari JSON

events JSON
voqealar JSON

##################
# MicroBlocks UI #
##################

# buttons, error & info messages, dialog boxes, etc

New
Yangi

Open
Ochiq

Open from board
--MISSING--

Information
--MISSING--

Plug in the board.
--MISSING--

Reading project from board...
--MISSING--

Loading project...
--MISSING--

Found a newer version of
--MISSING--

Do you want me to update the one in the project?
--MISSING--

Save
Saqlash

Connect
Ulanish

disconnect
ajratish

Serial port:
Ketma-ket port:

other...
boshqa...

none
hech qaysi

Port name?
Port nomi?

Board type:
Kengash turi:

Select board:
Kengashni tanlang:

Could not read:
Oâqib boâlmadi:

by
tomonidan

Created with GP
GP bilan yaratilgan

More info at http://microblocks.fun
Qo'shimcha ma'lumot: http://microblocks.fun

Function "
Funksiya "

" is too large to send to board.
" plataga yuborishga juda katta hajm.

Script is too large to send to board.
Skript buyurtma berish uchun juda katta.

Use "Connect" button to connect to a MicroBlocks device.
MicroBlocks qurilmasiga ulanish uchun "Connect" tugmasini bosing.

No boards found; is your board plugged in?
Hech qanday platalar topilmadi; sizning platangiz ulanganmi?

For AdaFruit boards, double-click reset button and try again.
AdaFruit platalari uchun tiklash tugmachasini ikki marta bosing va qaytadan urinib ko'ring.

The board is not responding.
Plata javob bermayapti.

Try to Install MicroBlocks on the board?
Plataga MicroBlockni o'rnatishga harakat qilib ko'ring.

The MicroBlocks in your board is not current
Platangizdagi MickroBlocks versiyasi oxirgisi emas

Try to update MicroBlocks on the board?
MicroBlocksni yangilab ko'rdingizmi?

Stop
To'xtatish

Start
Boshlang

Quit MicroBlocks?
MicroBlocks dan chiqasizmi?

Discard current project?
Joriy loyiha bekor qilinsinmi?

clean up
tozalamoq

arrange scripts
skriptlarni tashkil qilish

undrop (ctrl-Z)
o'chirish (ctrl-Z)

copy all scripts to clipboard
barcha skriptlarni clipboardga nusxalash

paste all scripts
barcha skriptlarni joylashtirish

paste script
skriptni joylashtirish

save a picture of all scripts
barcha skriptlarning rasmini saqlash

about...
haqida...

virtual machine version
virtual mashina versiyasi

update firmware on board
plata mikrodastur yangilash

show data graph
ma'lumotlar grafigini ko'rsatish

set serial delay
ketma-ket kechikishni o'rnating

firmware version
mikrodastur versiyasi

start WebThing server
WebThing serverini ishga tushiring

stop WebThing server
WebThing serverini to'xtatish

HTTP Server
--MISSING--

MicroBlocks HTTP Server listening on port 6473
6473 portida MicroBlocks HTTP Serverni tinglayapti

disable autoloading board libraries
plata kutibxonalarini avtomatik yuklashni o'chirib qo'yish

enable autoloading board libraries
avtomatik yuklash paneli kutubxonalarini yoqish

enable PlugShare when project empty
--MISSING--

disable PlugShare when project empty
--MISSING--

erase flash and update firmware on ESP board
esp tozalash va qaytarish

Use board type
Plata turi

Wiping board...
Platani tozalash...

(press ESC to cancel)
(bekor qilish uchun ESC tugmasini bosing)

Done!
Bajarildi!

download and install latest VM
so'nggi VM-ni yuklab oling va o'rnating

Select board type:
Plata turini tanlang:

Uploading MicroBlocks to board...
MicroBlocks yuklanmoqda ...

copy data to clipboard
ma'lumotni clipboardga ko'chirish

clear data
ma'lumotlarni tozalash

clear memory and variables
xotirani va o'zgaruvchini tozalash

show advanced blocks
yetakchi bloklarni ko'rsatish

export functions as library
funktsiyalarni kutubxona sifatida eksport qilish

hide advanced blocks
rivojlangan bloklarni yashirish

Data Graph
Ma'lumotlar grafigi

show instructions
yo'riqnomalarni ko'rsatish

show compiled bytes
olingan baytlarni ko'rsatish

expand
kengaytirish

collapse
qulash

rename...
qayta nomlash ...

show block definition...
blok ta'rifini ko'rsatish ...

show the definition of this block
ushbu blokning ta'rifini ko'rsating

delete block definition...
blok ta'rifini o'chirish ...

delete the definition of this block
ushbu blokning ta'rifini o'chirib tashlang

duplicate
nusxa ko'chirish

duplicate this block
ushbu blokni nusxalash

delete block
blokni o'chirish

delete this block
ushbu blokni o'chirish

just this one block
faqat shu bitta blok

copy to clipboard
clipboardga nusxalash

copy these blocks to the clipboard
ushbu bloklarni clipboardga nusxalash

duplicate all
hammasini nusxalash

duplicate these blocks
ushbu bloklarni nusxalash

extract block
blokni tortib olish

pull out this block
bu blokni tortib oling

save picture of script
skript rasmini saqlash

save a picture of this block definition as a PNG file
ushbu blok ta'rifining rasmini PNG fayli sifatida saqlang

save a picture of these blocks as a PNG file
ushbu bloklarning rasmini PNG fayli sifatida saqlang

copy script
skriptdan nusxa olish

delete
o'chirish

Input type:
Kiritish turi:

string only
faqat satr

string or number
satr yoki raqam

number only
faqat raqam

define
belgilang

number/string
raqam / satr

editable number or string
tahrirlanadigan raqam yoki satr

label
belgi

input
kiritish

hide block definition
blok ta'rifini yashirish

Are you sure you want to remove this block definition?
Ushbu blok ta'rifini olib tashlashga ishonchingiz komilmi?

Language
Til

Custom...
Boshqa ...

Obsolete
iste'moldan chiqqan

OK
OK

Ok
ok

Yes
Ha

No
Yo'q

Cancel
bekor qilish

Okay
Ok

Confirm
Tasdiqlash

# File picker and library dialogs

Libraries
Kutubxonalar

Examples
Namunalar

Desktop
Ish stoli

Computer
Kompyuter

Cloud
Cloud

File
Fayl

File Open
Faylni ochish

File Save
Faylni saqlash

File name:
Fayl nomi:

New Folder
Yangi papka

by
tomonidan

Depends:
Bogâliq:

Tags:
Teglar:

Path, name or URL for library?
Kutubxona adresi, nomi yoki URL manzili?

Invalid URL
Notoâgâri URL

Could not fetch library.
Kutubxonani tortib olib bo'lmadi.

Host does not exist or is currently down.
Xost mavjud emas yoki hozirda ishlamayapti.

File not found in server.
Fayl serverda topilmadi.

Server expects HTTPS, and MicroBlocks doesn't currently support it.
Server HTTPS talab qiladi va MicroBlocks hozirda uni qo'llab-quvvatlamaydi.

library information
kutubxona haqida ma'lumot

built-in library
o'rnatilgan kutubxona

Dependency path, name or URL?
Bogâlanish yoâli, nomi yoki URL manzili?

Tag name?
Teg nomi?

# MicroBlocks translation file
# Last updated: Jan  09  2023
#########################
# Blocks and categories #
#########################

Output
ÎÎ¾ÏÎ´Î¿Î¹

set user LED _
ÏÏÎ¹ÏÎµ ÏÎ¿ LED ÏÏÎ®ÏÏÎ· _

say _
ÏÎµÏ _

graph _
ÏÏÎµÎ´Î¯Î±ÏÎµ _

Input
ÎÎ¹ÏÏÎ´Î¿Î¹

button A
ÎºÎ¿ÏÎ¼ÏÎ¯ Î

button B
ÎºÎ¿ÏÎ¼ÏÎ¯ Î

microseconds
ÎµÎºÎ±ÏÎ¿Î¼Î¼ÏÏÎ¹Î¿ÏÏÎ¬ Î´ÎµÏÏÎµÏÎ¿Î»Î­ÏÏÎ¿Ï

milliseconds
ÏÎ¹Î»Î¹Î¿ÏÏÎ¬ Î´ÎµÏÏÎµÏÎ¿Î»Î­ÏÏÎ¿Ï

board type
ÎµÎ¯Î´Î¿Ï ÎºÎ¬ÏÏÎ±Ï

Pins
ÎÎºÏÎ¿Î´Î­ÎºÏÎµÏ

read digital pin _
Î´Î¹Î¬Î²Î±ÏÎµ ÏÎ¿ ÏÎ·ÏÎ¹Î±ÎºÏ Î±ÎºÏÎ¿Î´Î­ÎºÏÎ· _

read analog pin _
Î´Î¹Î¬Î²Î±ÏÎµ ÏÎ¿Î½ Î±Î½Î±Î»Î¿Î³Î¹ÎºÏ Î±ÎºÏÎ¿Î´Î­ÎºÏÎ· _

set digital pin _ to _
ÏÏÎ¹ÏÎµ ÏÎ¿ ÏÎ·ÏÎ¹Î±ÎºÏ Î±ÎºÏÎ¿Î´Î­ÎºÏÎ· _ ÏÎµ _

set pin _ to _
ÏÏÎ¹ÏÎµ ÏÎ¿Î½ Î±ÎºÏÎ¿Î´Î­ÎºÏÎ· _ ÏÎµ _

analog pins
Î±Î½Î±Î»Î¿Î³Î¹ÎºÎ¿Î¯ Î±ÎºÏÎ¿Î´Î­ÎºÏÎµÏ

digital pins
ÏÎ·ÏÎ¹Î±ÎºÎ¿Î¯ Î±ÎºÏÎ¿Î´Î­ÎºÏÎµÏ 

Control
ÎÎ»ÎµÎ³ÏÎ¿Ï Î¡Î¿Î®Ï

when started
ÏÏÎ±Î½ Î¾ÎµÎºÎ¹Î½Î¬

when button _ pressed
ÏÏÎ±Î½ ÏÎ¿ ÎºÎ¿ÏÎ¼ÏÎ¯ _ ÏÎ±ÏÎ·Î¸ÎµÎ¯

forever _
ÎÎ¹Î± ÏÎ¬Î½ÏÎ± ÎµÏÎ±Î½Î¬Î»Î±Î²Îµ _

repeat _ _
ÎµÏÎ±Î½Î¬Î»Î±Î²Îµ _ _

wait _ millisecs
ÏÎµÏÎ¯Î¼ÎµÎ½Îµ, _ ÏÎ¹Î»Î¹Î¿ÏÏÎ¬ Î´ÎµÏÏÎµÏÎ¿Î»Î­ÏÏÎ¿Ï

if _ _
ÎÎ½ _ _

else if _ _
Î´Î¹Î±ÏÎ¿ÏÎµÏÎ¹ÎºÎ¬ Î±Î½ _ _

if _ _ else _
Î±Î½ _ _ Î´Î¹Î±ÏÎ¿ÏÎµÏÎ¹ÎºÎ¬ _

else
Î´Î¹Î±ÏÎ¿ÏÎµÏÎ¹ÎºÎ¬

when _
ÏÏÎ±Î½ _

wait until _
ÏÎµÏÎ¯Î¼ÎµÎ½Îµ Î¼Î­ÏÏÎ¹ _

wait _ microsecs
ÏÎµÏÎ¯Î¼ÎµÎ½Îµ _ ÎµÎºÎ±ÏÎ¿Î¼Î¼ÏÏÎ¹Î¿ÏÏÎ¬ Î´ÎµÏÏÎµÏÎ¿Î»Î­ÏÏÎ¿Ï

return _
ÎµÏÎ¹ÏÏÏÎ¿ÏÎ® _

when _ received
ÏÏÎ±Î½ _ Î»Î·ÏÎ¸ÎµÎ¯

broadcast _
Î¼ÎµÏÎ¬Î´ÏÏÎµ _

comment _
ÏÏÏÎ»Î¹Î¿ _

for _ in _ _
Î³Î¹Î± _ Î¼Î­ÏÎ± ÏÎµ _ _

repeat until _ _
ÎµÏÎ±Î½Î¬Î»Î±Î²Îµ Î¼Î­ÏÏÎ¹ _ _

stop this task
ÏÏÎ±Î¼Î¬ÏÎ± Î±ÏÏÏ ÏÎ¿ ÏÎµÎ½Î¬ÏÎ¹Î¿

stop other tasks
ÏÏÎ±Î¼Î¬ÏÎ± ÏÎ± Î¬Î»Î»Î± ÏÎµÎ½Î¬ÏÎ¹Î±

stop all
ÏÏÎ±Î¼Î¬ÏÎ± ÏÎ»Î± ÏÎ± ÏÎµÎ½Î¬ÏÎ¹Î±

last message
ÏÎµÎ»ÎµÏÏÎ±Î¯Î¿ Î¼Î®Î½ÏÎ¼Î±

Operators
Î¤ÎµÎ»ÎµÏÏÎ­Ï

_ mod _
_ Î±ÎºÎ­ÏÎ±Î¹Î¿ ÏÏÏÎ»Î¿Î¹ÏÎ¿ _

abs _
Î±ÏÏÎ»ÏÏÎ¿ _

random _ to _
ÏÏÏÎ±Î¯Î¿ _ ÏÏ _

not _
Î±Î½ÏÎ¯Î¸ÎµÏÎ¿ _

_ and _
_ ÎºÎ±Î¹ _

and _
ÎºÎ±Î¹ _

_ or _
_ Î® _

or _
Î® _

_ is a _
_ ÎµÎ¯Î½Î±Î¹ Î­Î½Î± _

boolean
boolean

number
Î±ÏÎ¹Î¸Î¼ÏÏ

string
ÏÏÎ¼Î²Î¿Î»Î¿ÏÎµÎ¹ÏÎ¬

list
Î»Î¯ÏÏÎ±

Advanced:
Î ÏÎ¿ÏÏÏÎ·Î¼Î­Î½Î±:

hex _
Î´ÎµÎºÎ±ÎµÎ¾Î±Î´Î¹ÎºÏ _

Variables
ÎÎµÏÎ±Î²Î»Î·ÏÎ­Ï

# Buttons on top of "Variables" category

Add a variable
Î ÏÏÏÎ¸ÎµÏÎµ Î¼Î¹Î± Î¼ÎµÏÎ±Î²Î»Î·ÏÎ®

Delete a variable
ÎÎ¹Î¬Î³ÏÎ±ÏÎµ Î¼Î¹Î± Î¼ÎµÏÎ±Î²Î»Î·ÏÎ®

# New variable dialog

New variable name?
ÎÎ½Î¿Î¼Î± Î½Î­Î±Ï Î¼ÎµÏÎ±Î²Î»Î·ÏÎ®Ï?

set _ to _
ÏÏÎ¹ÏÎµ _ ÏÎµ _

change _ by _
Î¬Î»Î»Î±Î¾Îµ _ Î±Î½Î¬ _

initialize local _ to _
Î±ÏÏÎ¹ÎºÎ® ÏÎ¹Î¼Î® ÏÎ¿ÏÎ¹ÎºÎ®Ï Î¼ÎµÏÎ±Î²Î»Î·ÏÎ®Ï _ ÏÎµ _

Data
ÎÎµÎ´Î¿Î¼Î­Î½Î±

list
Î»Î¯ÏÏÎ±

length of _
Î¼Î®ÎºÎ¿Ï ÏÎ¿Ï _

item _ of _
ÏÏÎ¿Î¹ÏÎµÎ¯Î¿ _ ÏÎ¿Ï _

replace item _ of list _ with _
Î±Î½ÏÎ¹ÎºÎ±ÏÎ­ÏÏÎ·ÏÎµ ÏÏÎ¿Î¹ÏÎµÎ¯Î¿ _ ÏÎ·Ï Î»Î¯ÏÏÎ±Ï _ Î¼Îµ _

delete item _ of list _
Î´Î¹Î¬Î³ÏÎ±ÏÎµ ÏÎ¿ ÏÏÎ¿Î¹ÏÎµÎ¯Î¿ _ ÏÎ·Ï Î»Î¯ÏÏÎ±Ï _

add _ to list _
ÏÏÏÏÎ¸ÎµÏÎµ _ ÏÏÎ·Î½ Î»Î¯ÏÏÎ± _

join _ _
Î­Î½ÏÏÎµ _ _

copy _ from _
Î±Î½ÏÎ¯Î³ÏÎ±ÏÎµ _ Î±ÏÏ _

to _
ÏÏÎ¿Ï _

find _ in _
Î²ÏÎµÏ _ Î¼Î­ÏÎ± _

starting at _
Î¾ÎµÎºÎ¹Î½Î¬ Î±ÏÏ _

join items of list _
Î­Î½ÏÏÎµ ÏÎ± ÏÏÎ¿Î¹ÏÎµÎ¯Î± ÏÎ·Ï Î»Î¯ÏÏÎ±Ï _

separator _
Î´Î¹Î±ÏÏÏÎ¹ÏÏÎ¹ÎºÏ _

unicode _ of _
unicode _ ÏÎ¿Ï _

string from unicode _
ÏÏÎ¼Î²Î¿Î»Î¿ÏÎµÎ¯ÏÎ± Î±ÏÏ unicode _

new list length _
Î¼Î®ÎºÎ¿Ï Î½Î­Î¿Ï ÎºÎ±ÏÎ±Î»ÏÎ³Î¿Ï _

new byte array _
Î½Î­Î¿Ï byte ÏÎ¯Î½Î±ÎºÎ±Ï _

free memory
ÎµÎ»ÎµÏÎ¸Î­ÏÏÏÎµ Î¼Î½Î®Î¼Î·

My Blocks
Î¤Î± MÏÎ»Î¿Îº Î¼Î¿Ï

# Buttons on top of "My Blocks" category

Add a command block
Î ÏÏÏÎ¸ÎµÏÎµ Î¼ÏÎ»Î¿Îº ÎµÎ½ÏÎ¿Î»Î®Ï

Add a reporter block
Î ÏÏÏÎ¸ÎµÏÎµ Î¼ÏÎ»Î¿Îº Î±Î½Î±ÏÎ¿ÏÎ¬Ï

# Make a block dialog

Enter function name:
Î£ÏÎ¼ÏÎ»Î®ÏÏÏÎµ ÏÎ¿ ÏÎ½Î¿Î¼Î± ÏÎ·Ï Î»ÎµÎ¹ÏÎ¿ÏÏÎ³Î¯Î±Ï:

Comm
ÎÏÎ¹ÎºÎ¿Î¹Î½ÏÎ½Î¯Î± 

i2c get device _ register _
i2c ÏÎ¬ÏÎµ Î±ÏÏ ÏÏÏÎºÎµÏÎ® _ ÎºÎ±ÏÎ±ÏÏÏÎ·ÏÎ® _

i2c set device _ register _ to _
i2c ÏÏÎ¹ÏÎµ ÏÏÎ·Î½ ÏÏÏÎºÎµÏÎ® _ ÎºÎ±ÏÎ±ÏÏÏÎ·ÏÎ® _ ÏÎµ _

i2c device _ read list _
i2c ÏÏÏÎºÎµÏÎ® _ Î´Î¹Î¬Î²Î±ÏÎµ Î»Î¯ÏÏÎ± _

i2c device _ write list _
i2c ÏÏÏÎºÎµÏÎ® _ Î³ÏÎ¬ÏÎµ Î»Î¯ÏÏÎ± _

spi send _
spi ÏÏÎµÎ¯Î»Îµ _

spi receive
spi Î»Î¬Î²Îµ

print _
ÏÏÏÏÏÎµ _

no op
ÎºÎ±Î¼Î¼Î¯Î± ÎµÎ½ÏÎ¿Î»Î®

ignore
Î±Î³Î½ÏÎ·ÏÎµ 

##############
# Primitives #
##############

# These are all mostly hidden from end users

draw shape _ at x _ y _
ÏÏÎµÎ´Î¯Î±ÏÎµ ÏÏÎ®Î¼Î± _ ÏÏÎ¿ x _ y _

shape for letter _
ÏÏÎ®Î¼Î± Î³Î¹Î± Î³ÏÎ¬Î¼Î¼Î± _

send NeoPixel rgb _
ÏÏÎµÎ¯Î»Îµ ÏÏÎ¿ NeoPixel ÎºÏÎ¼ _

has tone support
Î­ÏÎµÎ¹ ÏÎ¿Î½Î¹ÎºÎ® ÏÏÎ¿ÏÏÎ®ÏÎ¹Î¾Î·

play tone pin _ frequency _
ÏÎ±Î¯Î¾Îµ ÏÏÎ½Î¿ ÏÏÎ¿Î½ Î±ÎºÏÎ¿Î´Î­ÎºÏÎ· _ ÏÏÏÎ½ÏÏÎ·ÏÎ± _

has WiFi support
Î´Î¹Î±Î¸Î­ÏÎµÎ¹ ÏÏÎ¿ÏÏÎ®ÏÎ¹Î¾Î· WIFI

start WiFi _ password _
Î¾ÎµÎºÎ¯Î½Î± WIFI _ Î¼Îµ ÎºÏÎ´Î¹ÎºÏ _

stop WiFi
ÏÏÎ±Î¼Î¬ÏÎ± WIFI

WiFi status
WIFI ÎºÎ±ÏÎ¬ÏÏÎ±ÏÎ·

my IP address
Î· IP Î´Î¹ÎµÏÎ¸ÏÎ½ÏÎ· Î¼Î¿Ï 

radio send number _
ÏÎ¬Î´Î¹Î¿ ÏÏÎµÎ¯Î»Îµ Î±ÏÎ¹Î¸Î¼Ï _ 

radio send string _
ÏÎ¬Î´Î¹Î¿ ÏÏÎµÎ¯Î»Îµ ÏÎµÎ¹ÏÎ¬ ÏÎ±ÏÎ±ÎºÏÎ®ÏÏÎ½

radio send pair _ = _
ÏÎ¬Î´Î¹Î¿ ÏÏÎµÎ¯Î»Îµ Î¶ÎµÏÎ³Î¬ÏÎ¹ _ =_

radio message received?
ÏÎ±ÏÎ±Î»Î®ÏÎ¸Î·ÎºÎµ ÏÎ¿ Î¼Î®Î½ÏÎ¼Î± ÏÎ±Î´Î¯Î¿Ï

radio last number
ÏÎ¬Î´Î¹Î¿ ÏÎµÎ»ÎµÏÏÎ±Î¯Î¿Ï Î±ÏÎ¹Î¸Î¼ÏÏ

radio last string
ÏÎ¬Î´Î¹Î¿ ÏÎµÎ»ÎµÏÏÎ±Î¯Î± ÏÎµÎ¹ÏÎ¬ ÏÎ±ÏÎ±ÎºÏÎ®ÏÏÎ½

radio last message type
ÏÎ¬Î´Î¹Î¿ ÏÏÏÎ¿Ï ÏÎµÎ»ÎµÏÏÎ±Î¯Î¿Ï Î¼Î·Î½ÏÎ¼Î±ÏÎ¿Ï

radio set group _
ÏÎ¬Î´Î¹Î¿ Î¿ÏÎ¹ÏÎ¼ÏÏ Î¿Î¼Î¬Î´Î±Ï _ 

radio set channel (0-83) _
ÏÎ¬Î´Î¹Î¿ ÏÏÎ¹ÏÎµ ÎºÎ±Î½Î¬Î»Î¹ ÏÎµ (0-83) _

radio set power (0-7) _
ÏÎ¬Î´Î¹Î¿ ÏÏÎ¹ÏÎµ Î¹ÏÏÏ ÏÎµ (0-7) _

radio last signal strength
ÏÎ¬Î´Î¹Î¿ Î´ÏÎ½Î±Î¼Î· ÏÎµÎ»ÎµÏÏÎ±Î¯Î¿Ï ÏÎ®Î¼Î±ÏÎ¿Ï

radio receive packet _
ÏÎ¬Î´Î¹Î¿ Î»Î®ÏÎ· ÏÎ±ÎºÎ­ÏÎ¿Ï _ 

radio send packet _
ÏÎ¬Î´Î¹Î¿ Î±ÏÎ¿ÏÏÎ¿Î»Î® ÏÎ±ÎºÎ­ÏÎ¿Ï _ 

disable radio
ÎÏÎµÎ½ÎµÏÎ³Î¿ÏÎ¿Î¯Î·ÏÎ· ÏÎ±Î´Î¯Î¿Ï

#############
# Libraries #
#############

Basic Sensors
ÎÎ±ÏÎ¹ÎºÎ¿Î¯ ÎÎ¹ÏÎ¸Î·ÏÎ®ÏÎµÏ

tilt x
ÎºÎ»Î¯ÏÎ· x

tilt y
ÎºÎ»Î¯ÏÎ· y

tilt z
ÎºÎ»Î¯ÏÎ· z

acceleration
ÎµÏÎ¹ÏÎ¬ÏÏÎ½ÏÎ·

light level
ÎÎ­ÏÏÎ·ÏÎ· ÏÏÏÏÏ

temperature (Â°C)
ÎÎµÏÎ¼Î¿ÎºÏÎ±ÏÎ¯Î± (Â°C)

####
# NeoPixel library

NeoPixel
--MISSING--

set NeoPixels _ _ _ _ _ _ _ _ _ _
ÏÏÎ¹ÏÎµ NeoPixels _ _ _ _ _ _ _ _ _ _

clear NeoPixels
ÎºÎ±Î¸Î¬ÏÎ¹ÏÎµ NeoPixels

set NeoPixel _ color _
ÏÏÎ¹ÏÎµ NeoPixel _ ÏÏÏÎ¼Î± _

set all NeoPixels color _
ÏÏÎ¹ÏÎµ ÏÎ»Î± ÏÎ± NeoPixels ÏÎµ ÏÏÏÎ¼Î± _

rotate NeoPixels by _
ÏÏÏÎ¯ÏÎµ ÏÎ± NeoPixels ÎºÎ±ÏÎ¬ _

color r _ g _ b _ (0-255)
ÏÏÏÎ¼Î± Îº _ Ï _ Î¼ _ (0-255)

random color
ÏÏÏÎ±Î¯Î¿ ÏÏÏÎ¼Î±

attach _ LED NeoPixel strip to pin _
ÏÏÎ½Î´ÎµÏÎµ _ LED NeoPixel strip ÏÏÎ¿Î½ Î±ÎºÏÎ¿Î´Î­ÎºÏÎ· _

has white _
Î­ÏÎµÎ¹ Î¬ÏÏÏÎ¿ _

PIR
PIR

PIR at pin _ detected movement
PIR ÏÏÎ¿Î½ Î±ÎºÏÎ¿Î´Î­ÎºÏÎ· _ Î±Î½Î¯ÏÎ½ÎµÏÏÎµ ÎºÎ¯Î½Î·ÏÎ·

####
# Citilab ED1 board libraries

ED1 Stepper Motor
ED1 ÎÏÏÎµÏ ÎÎ®Î¼Î¬ÏÎ¿Ï

move motor _ _ steps _
Î¼Î¿ÏÎµÏ  _ _ Î²Î®Î¼Î±ÏÎ± _

move motor 1 _ and motor 2 _ _ steps
Î¼Î¿ÏÎµÏ 1 ÎºÎ¹Î½Î®Î¸Î¿Ï _ ÎºÎ±Î¹ Î¼Î¿ÏÎµÏ 2 ÎºÎ¹Î½Î®Î¸Î¿Ï _ _ Î²Î®Î¼Î±ÏÎ±

move motor _ angle _ Â°
Î¼Î¿ÏÎ­Ï _ ÏÏÏÎ¯ÏÎµ Î³ÏÎ½Î¯Î± _ Â°

move motor _ _ complete turns
Î¼Î¿ÏÎ­Ï ÏÏÏÎ¯ÏÎµ _ _ ÏÏÏÎ¿ÏÎ­Ï

stop steppers
ÏÏÎ±Î¼Î¬ÏÎ± ÏÎ± Î²Î·Î¼Î±ÏÎ¹ÎºÎ¬ Î¼Î¿ÏÎ­Ï 

clockwise
Î´ÎµÎ¾Î¹ÏÏÏÏÎ¿ÏÎ±

counter-clockwise
Î±ÏÎ¹ÏÏÎµÏÏÏÏÏÎ¿ÏÎ±

ED1 Buttons
ED1 ÎÎ¿Î¼Î²Î¯Î±

button OK
 ÎºÎ¿ÏÎ¼ÏÎ¯ OK

button X
 ÎºÎ¿ÏÎ¼ÏÎ¯ X

button up
 ÎºÎ¿ÏÎ¼ÏÎ¯ ÏÎ¬Î½Ï

button down
 ÎºÎ¿ÏÎ¼ÏÎ¯ ÎºÎ¬ÏÏ

button left
 ÎºÎ¿ÏÎ¼ÏÎ¯ Î±ÏÎ¹ÏÏÎµÏÎ¬

button right
 ÎºÎ¿ÏÎ¼ÏÎ¯ Î´ÎµÎ¾Î¹Î¬

capacitive sensor _
ÏÏÏÎ·ÏÎ¹ÎºÏÏ Î±Î¹ÏÎ¸Î·ÏÎ®ÏÎ±Ï _

set capacitive threshold to _
Î¿ÏÎ¯ÏÎµ ÏÏÎ¹Î¿ ÏÎ¿Ï ÏÏÏÎ·ÏÎ¹ÎºÎ¿Ï ÏÎµ_

####
# BirdBrain Technologies libraries

Hummingbird LED _ _ %
--MISSING--

Hummingbird Tri-LED _ R _ % G _ % B _ %
--MISSING--

Hummingbird Position Servo _ _ Â°
Hummingbird Î¸Î­ÏÎ· Servo _ _ Â°

Hummingbird Rotation Servo _ _ %
Hummingbird Î ÎµÏÎ¹ÏÏÏÎ¿ÏÎ® Servo _ _ %

Hummingbird _ _
--MISSING--

Hummingbird Battery (mV)
Hummingbird Î¼ÏÎ±ÏÎ±ÏÎ¯Î± (mV)

Light
Î¦ÏÏ

Distance (cm)
ÎÏÏÏÏÎ±ÏÎ· (ÎµÎº)

Dial
--MISSING--

Sound
ÎÏÎ¿Ï

Other
ÎÎ»Î»Î±

Finch Î¡Î¬Î¼ÏÎ¿Ï Red _ Green _ Blue _
Finch Beak ÎÏÎºÎºÎ¹Î½Î¿ _ Î ÏÎ¬ÏÎ¹Î½Î¿ _ ÎÏÎ»Î­ _

Finch Tail _ Red _ Green _ Blue _
Finch ÎÏÏÎ¬ ÎÏÎºÎºÎ¹Î½Î¿ _ Î ÏÎ¬ÏÎ¹Î½Î¿ _ ÎÏÎ»Î­ _

Finch Move _ _ cm at _ %
Finch Î ÏÎ¿ÏÏÏÎ± _ _ ÎµÎº  Î¼Îµ  _ %

Finch Turn _ _ Â° at _ %
Finch Î£ÏÏÎ¯ÏÎµ _ _ Â° Î¼Îµ _ %

Finch Wheels L _ % R _ %
Finch Î¤ÏÎ¿ÏÎ¿Î¯ Î _ % Î _ %

Finch Stop
Finch Î£ÏÎ±Î¼Î¬ÏÎ±

Finch Distance (cm)
Finch ÎÏÏÏÏÎ±ÏÎ· (ÎµÎº)

Finch _ Light
Finch _ Î¦ÏÏ

Finch _ Line
Finch _ ÎÏÏÏÏÎ±ÏÎ·

Finch Reset Encoders
Finch ÎÎ·Î´Î­Î½Î¹ÏÎµ  Encoders

Finch _ Encoder
--MISSING--

Finch Accelerometer _
Finch ÎÏÎ¹ÏÎ±ÏÏÎ½ÏÎ¹ÏÎ¼ÎµÏÏÎ¿ _

Finch Battery
Finch ÎÏÎ±ÏÎ±ÏÎ¯Î±

All
ÎÎ»Î±

Forward
ÎÏÏÎ¿ÏÏÎ¬

Backward
Î Î¯ÏÏ

Right
ÎÎµÎ¾Î¹Î¬

Left
ÎÏÎ¹ÏÏÎµÏÎ¬

Beak Up
Î¡Î¬Î¼ÏÎ¿Ï Î Î¬Î½Ï

Beak Down
Î¡Î¬Î¼ÏÎ¿Ï ÎÎ¬ÏÏ

Tilt Left
ÎÎ»Î¯Î½Îµ ÎÏÎ¹ÏÏÎµÏÎ¬

Tilt Right
ÎÎ»Î¯Î½Îµ ÎÎµÎ¾Î¹Î¬

Level
ÎÏÎ¹ÏÏÎµ

Upside Down
ÎÎ½Î¬ÏÎ¿Î´Î±

x
--MISSING--

y
--MISSING--

z
--MISSING--

strength
Î´ÏÎ½Î±Î¼Î·

####
# Ultrasound distance library

distance (cm) trigger _ echo _
Î±ÏÏÏÏÎ±ÏÎ· (ÎµÎº) ÎµÎ½ÎµÏÎ³Î¿ÏÎ¿Î¯Î·ÏÎ· _ Î·ÏÏ _

####
# Infrared remote library

IR Remote
IR Î¤Î·Î»ÎµÏÎµÎ¹ÏÎ¹ÏÏÎ®ÏÎ¹Î¿

receive IR code
Î»Î®ÏÎ· ÎºÏÎ´Î¹ÎºÎ¿Ï IR

receive IR code from device _
Î»Î®ÏÎ· ÎºÏÎ´Î¹ÎºÎ¿Ï IR Î±ÏÏ ÏÎ· ÏÏÏÎºÎµÏÎ® _

test IR
Î´Î¿ÎºÎ¹Î¼Î® IR

attach IR receiver to pin _
ÎµÏÎ¹ÏÏÎ½Î¬ÏÏÎµ Î´Î­ÎºÏÎ· IR ÏÏÎ¿Î½ Î±ÎºÏÎ¿Î´Î­ÎºÏÎ· _

####
# Radio comm library
# Allows micro:bit boards to exchange messages
# All of its blocks are primitive (see "Primitives" section)

Radio
--MISSING--

####
# Text scrolling library
# Scrolls text on 5x5 LED displays and simulated ones

Scrolling
ÎºÏÎ»Î¹ÏÎ·

scroll text _
ÎºÏÎ»Î¹ÏÎ· ÎºÎµÎ¹Î¼Î­Î½Î¿Ï _

scroll number _
ÎºÏÎ»Î¹ÏÎ· Î±ÏÎ¹Î¸Î¼Î¿Ï _ 

pausing _ ms
ÏÎ±ÏÏÎ· _ ÏÎ¹Î»Î¹Î¿ÏÏÎ¬ Î´ÎµÏÏÎµÏÎ¿Î»Î­ÏÏÎ¿Ï

stop scrolling
ÏÏÎ±Î¼Î¬ÏÎ·Î¼Î± ÎºÏÎ»Î¹ÏÎ·Ï

####
# Servo motor library

Servo
Î£Î­ÏÎ²Î¿ Î¼Î¿ÏÎ­Ï

set servo _ to _ degrees (-90 to 90)
Î¿ÏÎ¯ÏÎµ servo Î±ÏÏ _ Î­ÏÏ _ Î¼Î¿Î¯ÏÎµÏ (-90 Î­ÏÏ 90)

set servo _ to speed _ (-100 to 100)
Î¿ÏÎ¯ÏÎµ servo _ ÏÏÎ·Î½ ÏÎ±ÏÏÏÎ·ÏÎ± _ (-100 Î­ÏÏ 100)

stop servo _
ÏÏÎ±Î¼Î¬ÏÎ·ÏÎµ ÏÎ¿ ÏÎ­ÏÎ²Î¿ _

####
# 5x5 LED display library
# Supports the micro:bit display, but also simulated 5x5 displays on boards
# with differently sized LED arrays, NeoPixel arrays or TFT displays

LED Display
ÎÎ¸ÏÎ½Î· LED

display _
Î¿Î¸ÏÎ½Î· _

clear display
ÎºÎ±Î¸Î¬ÏÎ¹ÏÎ¼Î± ÎÎ¸ÏÎ½Î·Ï

plot x _ y _
ÏÏÎµÎ´Î¹Î¬ÏÎµ x _ y _

unplot x _ y _
ÎºÎ±Î¸Î¬ÏÎ¹ÏÎµ x _ y _

display character _
ÎµÎ¼ÏÎ¬Î½Î¹ÏÎµ ÏÎ±ÏÎ±ÎºÏÎ®ÏÎ± _

####
# TFT display library

enable TFT _
ÎµÎ½ÎµÏÎ³Î¿ÏÎ¿Î¯Î·ÏÎµ TFT _

TFT width
TFT ÏÎ»Î¬ÏÎ¿Ï

TFT height
TFT ÏÏÎ¿Ï

set TFT pixel x _ y _ to _
ÎÏÎ¹ÏÎµ TFT ÎµÎ¹ÎºÎ¿Î½Î¿ÎºÏÏÎ±ÏÎ¿ x _ y _ ÏÎµ _

draw line on TFT from x _ y _ to x _ y _ color _
ÏÏÎµÎ´Î¹Î¬ÏÎµ Î³ÏÎ±Î¼Î¼Î®  ÏÏÎ¿ TFT Î±ÏÏ x _ y _ ÏÏÎ¿ x _ y _ ÏÏÏÎ¼Î± _

draw rectangle on TFT at x _ y _ width _ height _ color _
ÏÏÎµÎ´Î¯Î±ÏÎµ ÏÎµÏÏÎ¬Î³ÏÎ½Î¿ ÏÏÎ¿ TFT ÏÏÎ¿ x _ y _ ÏÎ»Î¬ÏÎ¿Ï _ ÏÏÎ¿Ï _ ÏÏÏÎ¼Î± _

draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _
ÏÏÎµÎ´Î¯Î±ÏÎµ ÏÏÏÎ¿Î³Î³ÏÎ»ÎµÎ¼Î­Î½Î¿ ÏÎµÏÏÎ¬Î³ÏÎ½Î¿ ÏÏÎ¿ TFT ÏÏÎ¿ x _ y _ ÏÎ»Î¬ÏÎ¿Ï _ ÏÏÎ¿Ï _  Î±ÎºÏÎ¯Î½Î± _ ÏÏÏÎ¼Î± _

draw circle on TFT at x _ y _ radius _ color _
ÏÏÎµÎ´Î¹Î¬ÏÎµ ÎºÏÎºÎ»Î¿ ÏÏÎ¿  TFT ÏÏÎ¿ x _ y _ Î±ÎºÏÎ¯Î½Î± _ ÏÏÏÎ¼Î± _

draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _
ÏÏÎµÎ´Î¹Î¬ÏÎµ ÏÏÎ¯Î³ÏÎ½Î¿ ÏÏÎ¿ TFT ÏÏÎ¿ x _ y _ , x _ y _ , x _ y _ ÏÏÏÎ¼Î± _

filled _
ÎÎ­Î¼Î¹ÏÎ· _

write _ on TFT at x _ y _ color _
Î³ÏÎ¬ÏÎµ _ ÏÏÎ¿ TFT ÏÏÎ¿ x _ y _ ÏÏÏÎ¼Î± _

scale _ wrap _
ÎºÎ»Î¯Î¼Î±ÎºÎ± _ Î±Î½Î±Î´Î¯ÏÎ»ÏÏÎ· _

####
# Tone library
# Generates music tones on buzzers

Tone
Î¤ÏÎ½Î¿Ï

attach buzzer to pin _
ÎµÏÎ¹ÏÏÎ½Î¬ÏÎµ ÏÎ¿ Î²Î¿Î¼Î²Î·ÏÎ® ÏÏÎ¿Î½ Î±ÎºÏÎ¿Î´Î­ÎºÏÎ· _

play note _ octave _ for _ ms
ÏÎ±Î¯Î¾Îµ Î½ÏÏÎ± _ Î¿ÎºÏÎ¬Î²Î± _ Î³Î¹Î± _ ÏÎ´

play frequency _ for _ ms
ÏÎ±Î¯Î¾Îµ ÏÏÏÎ½ÏÏÎ·ÏÎ± _ Î³Î¹Î± _ ÏÎ´

play midi key _ for _ ms
ÏÎ±Î¯Î¾Îµ ÏÎ»Î®ÎºÏÏÎ¿ midi _ Î³Î¹Î± _ ms

####
# Turtle geometry library

Turtle
Î§ÎµÎ»ÏÎ½Î± 

home
Î£ÏÎ¯ÏÎ¹

move _
ÏÏÎ¿ÏÏÏÎ± _

turn _ degrees
ÏÏÏÎ¯ÏÎµ _ Î¼Î¿Î¯ÏÎµÏ

turn _ / _ of circle
ÏÏÏÎ¯ÏÎµ _ / _ ÏÎ¿Ï ÎºÏÎºÎ»Î¿Ï

pen down
ÏÎ­Î½Î½Î± ÎºÎ¬ÏÏ

pen up
ÏÎ­Î½Î½Î± ÏÎ¬Î½Ï

set pen color to _
ÏÏÎ¹ÏÎµ ÏÎ·Î½ ÏÎ­Î½Î½Î± ÏÏÎ¿ ÏÏÏÎ¼Î± _

set pen to random color
ÏÏÎ¹ÏÎµ ÏÎ·Î½ ÏÎ­Î½Î½Î± ÏÎµ ÏÏÏÎ±Î¯Î¿ ÏÏÏÎ¼Î±

fill display with _
Î³Î­Î¼Î¹ÏÎµ ÏÎ·Î½ Î¿Î¸ÏÎ½Î· Î¼Îµ _

go to x _ y _
ÏÏÎ¿ÏÏÏÎ± ÏÏÎ¿ x _ y _

point in direction _
ÏÎ·Î¼ÎµÎ¯Î¿ ÏÏÎ·Î½ ÎºÎ±ÏÎµÏÎ¸ÏÎ½ÏÎ· _

####
# File system library

Files
ÎÏÏÎµÎ¯Î±

open file _
Î¬Î½Î¿Î¹Î¾Îµ Î±ÏÏÎµÎ¯Î¿ _

close file _
ÎºÎ»ÎµÎ¯ÏÎµ Î±ÏÏÎµÎ¯Î¿ _

delete file _
Î´Î¹Î¬Î³ÏÎ±ÏÎµ Î±ÏÏÎµÎ¯Î¿ _

append line _ to file _
ÏÏÏÏÎ¸ÎµÏÎµ Î³ÏÎ±Î¼Î¼Î® _ ÏÏÎ¿ Î±ÏÏÎµÎ¯Î¿ _

append bytes _ to file _
ÏÏÏÏÎ¸ÎµÏÎµ bytes _ ÏÏÎ¿ Î±ÏÏÎµÎ¯Î¿ _

end of file _
ÏÎ­Î»Î¿Ï ÏÎ¿Ï Î±ÏÏÎµÎ¯Î¿Ï _

next line of file _
ÎµÏÏÎ¼ÎµÎ½Î· Î³ÏÎ±Î¼Î¼Î® ÏÎ¿Ï Î±ÏÏÎµÎ¯Î¿Ï _

next _ bytes of file _
ÎµÏÏÎ¼ÎµÎ½Î± _ bytes ÏÎ¿Ï Î±ÏÏÎµÎ¯Î¿Ï _

starting at _
Î¾ÎµÎºÎ¹Î½Î¬ Î±ÏÏ _

file names
ÏÎ½Î¿Î¼Î± Î±ÏÏÎµÎ¯ÏÎ½

size of file _
Î¼Î­Î³ÎµÎ¸Î¿Ï ÏÎ¿Ï Î±ÏÏÎµÎ¯Î¿Ï _

file system info
ÏÎ»Î·ÏÎ¿ÏÎ¿ÏÎ¯ÎµÏ Î³Î¹Î± Î±ÏÏÎµÎ¯Î± ÏÏÏÏÎ®Î¼Î±ÏÎ¿Ï

####
# WiFi library

WiFi
--MISSING--

wifi connect to _ password _ try _ times
wifi ÎµÎ½ÏÎ¸Î¿Ï ÏÏÎ¿ _ ÎºÏÎ´Î¹ÎºÏÏ _ ÏÏÎ¿ÏÏÎ¬Î¸Î·ÏÎµ _ ÏÎ¿ÏÎ­Ï

wifi create hotspot _ password _
wifi Î´Î·Î¼Î¹Î¿ÏÏÎ³Î·ÏÎµ hotspot _ ÎºÏÎ´Î¹ÎºÏÏ _

IP address
IP Î´Î¹ÎµÏÎ¸ÏÎ½ÏÎ·

####
# Motion library
# Counts steps and detects motion via the internal accelerometer

Motion
ÎÎ¯Î½Î·ÏÎ·

motion
ÎºÎ¯Î½Î·ÏÎ·

start step counter
Î¾ÎµÎºÎ¯Î½Î± Î¼ÎµÏÏÎ·ÏÎ® Î²Î·Î¼Î¬ÏÏÎ½

step count
Î¼Î­ÏÏÎ·ÏÎµ Î²Î®Î¼Î±ÏÎ±

clear step count
ÎÎ·Î´Î­Î½Î¹ÏÎµ ÏÏÎ½ Î¼ÎµÏÏÎ·ÏÎ® Î²Î·Î¼Î¬ÏÏÎ½

set step threshold _ (0-50)
ÏÏÎ¹ÏÎµ ÎºÎ±ÏÏÏÎ»Î¹ Î²Î·Î¼Î¬ÏÏÎ½ _ (0-50)

####
# Button Events library

Button Events
ÎºÎ¿ÏÎ¼ÏÎ¯ Î£ÏÎ¼Î²Î¬Î½ÏÎ±

button _ double pressed
ÎºÎ¿ÏÎ¼ÏÎ¯ _ Î´Î¹ÏÎ»Ï ÏÎ¬ÏÎ·Î¼Î±

button _ long pressed
ÎºÎ¿ÏÎ¼ÏÎ¯ _ Î¼Î±ÎºÏÏ ÏÎ¬ÏÎ·Î¼Î±

button _ pressed
ÎºÎ¿ÏÎ¼ÏÎ¯ _ ÏÎ±ÏÎ®Î¸Î·ÎºÎµ

####
# Calliope board library

Calliope set LED red _ green _ blue _
--MISSING--

Calliope set speaker _
--MISSING--

Calliope loudness
--MISSING--

####
# Circuit Playground Express board library

Circuit Playground set speaker _
Circuit Playground ÏÏÎ¹ÏÎµ ÏÎ¿ Î¼ÎµÎ³Î¬ÏÏÎ½Î¿ _

Circuit Playground slide switch
Circuit Playground ÎºÎ¿ÏÎ¼ÏÎ¯ ÎºÏÎ»Î¹ÏÎ·Ï 

####
# DotStar LED library

attach _ DotStar LEDs to data pin _ clock pin _
--MISSING--

set all DotStar LEDs to r _ g _ b _
--MISSING--

set DotStar LED _ to r _ g _ b _
--MISSING--

set DotStar brightness _
--MISSING--

####
# BME280 environmental sensor

bme280 connected
bme280 ÎµÎ½ÏÎ¸Î·ÎºÎµ

bmp280 connected
-bmp280 ÎµÎ½ÏÎ¸Î·ÎºÎµ

bmx280 temperature
bmx280 Î¸ÎµÏÎ¼Î¿ÎºÏÎ±ÏÎ¯Î±

bmx280 pressure
bmx280 ÏÎ¯ÎµÏÎ·

bme280 humidity
bme280 ÏÎ³ÏÎ±ÏÎ¯Î±

####
# TCS34725 color sensor

TCS34725 connected
TCS34725 ÏÏÎ½Î´Î­Î¸Î·ÎºÎµ

TCS34725 rgb
TCS34725 ÎºÏÎ¼

color _ name
ÏÏÏÎ¼Î± _ ÏÎ½Î¿Î¼Î±

####
# DHT11 environmental sensor

temperature (Celsius) DHT11 pin _
Î¸ÎµÏÎ¼Î¿ÎºÏÎ±ÏÎ¯Î± (ÎÎµÎ»ÏÎ¯Î¿Ï) DHT11 Î±ÎºÏÎ¿Î´Î­ÎºÏÎ·Ï _

humidity DHT11 pin _
ÏÎ³ÏÎ±ÏÎ¯Î± DHT11 Î±ÎºÏÎ¿Î´Î­ÎºÏÎ·Ï _ 

temperature (Celsius) DHT22 pin _
Î¸ÎµÏÎ¼Î¿ÎºÏÎ±ÏÎ¯Î± (ÎÎµÎ»ÏÎ¯Î¿Ï) DHT22 Î±ÎºÏÎ¿Î´Î­ÎºÏÎ·Ï _

humidity DHT22 pin _
ÏÎ³ÏÎ±ÏÎ¯Î± DHT22 Î±ÎºÏÎ¿Î´Î­ÎºÏÎ·Ï _ 

####
# PN532 RFID reader

read PN532 RFID
Î´Î¹Î¬Î²Î±ÏÎµ PN532 RFID

RFID _ = _
--MISSING--

get PN532 firmware version
Î´Î¹Î¬Î²Î±ÏÎµ PN532 Î­ÎºÎ´Î¿ÏÎ· firmware

####
# HTTP libraries

HTTP client
HTTP ÏÎµÎ»Î¬ÏÎ·Ï

_ data _ to http:// _
_ Î´ÎµÎ´Î¿Î¼Î­Î½Î± _ ÏÏÎ¿ http://_

HTTP server
HTTP ÎµÎ¾ÏÏÎ·ÏÎµÏÎ·ÏÎ®Ï

start HTTP server
Î¾ÎµÎºÎ¯Î½Î± ÏÎ¿Î½ HTTP ÎµÎ¾ÏÏÎ·ÏÎµÏÎ·ÏÎ®

HTTP server request
HTTP ÎµÎ¾ÏÏÎ·ÏÎµÏÎ·ÏÎ® Î±Î¯ÏÎ·ÏÎ·

respond _ to HTTP request
Î±ÏÎ¬Î½ÏÎ·ÏÎ· _ ÏÎµ HTTP Î±Î¯ÏÎ·ÏÎ·

with body _
Î¼Îµ ÏÏÎ¼Î± _

and headers _
ÎºÎ±Î¹ ÎµÏÎ¹ÎºÎµÏÎ±Î»Î¯Î´ÎµÏ _

body of request _
ÏÏÎ¼Î± ÏÎ·Ï Î±Î¯ÏÎ·ÏÎ·Ï

path of request _
Î´Î¹Î±Î´ÏÎ¿Î¼Î® Î±Î¯ÏÎ·ÏÎ·Ï _

method of request _
Î¼Î­Î¸Î¿Î´Î¿Ï ÏÎ·Ï Î±Î¯ÏÎ·ÏÎ·Ï _

####
# Web Things library

Web Thing
ÎÎ½ÏÎ¹ÎºÎµÎ¯Î¼ÎµÎ½Î¿ ÎÎ¹ÎºÏÏÎ¿Ï

set thing name to _
ÏÏÎ¹ÏÎµ ÏÎ¿ ÏÎ½Î¿Î¼Î± ÏÎ¿Ï Î±Î½ÏÎ¹ÎºÎµÎ¹Î¼Î­Î½Î¿Ï ÏÎµ _

set thing capability to _
ÏÏÎ¹ÏÎµ ÏÎ·Î½ Î¹ÎºÎ±Î½ÏÏÎ·ÏÎ± ÏÎ¿Ï Î±Î½ÏÎ¹ÎºÎµÎ¹Î¼Î­Î½Î¿Ï ÏÎµ _

set boolean property _ title _ @Type _
ÏÏÎ¹ÏÎµ Î´ÏÎ±Î´Î¹ÎºÎ® Î¹Î´Î¹ÏÏÎ·ÏÎ± _ ÏÎ¯ÏÎ»Î¿Ï _ @Î¤ÏÏÎ¿Ï

set string property _ title _ @Type _
ÏÏÎ¹ÏÎµ ÎºÎµÎ¹Î¼Î­Î½Î¿Ï Î¹Î´Î¹ÏÏÎ·ÏÎ± _ ÏÎ¯ÏÎ»Î¿Ï _ @Î¤ÏÏÎ¿Ï _

set number property _ title _ @Type _
ÏÏÎ¹ÏÎµ Î±ÏÎ¹Î¸Î¼Î·ÏÎ¹ÎºÎ® Î¹Î´Î¹ÏÏÎ·ÏÎ± _ ÏÎ¯ÏÎ»Î¿Ï _ @Î¤ÏÏÎ¿Ï _

set number property _ title _ min _ max _ @Type _
ÏÏÎ¹ÏÎµ Î±ÏÎ¹Î¸Î¼Î·ÏÎ¹ÎºÎ® Î¹Î´Î¹ÏÏÎ·ÏÎ± _ ÏÎ¯ÏÎ»Î¿Ï _ ÎµÎ»Î¬ÏÎ¹ÏÏÎ¿ _ Î¼Î­Î³Î¹ÏÏÎ¿ _ @Î¤ÏÏÎ¿Ï _

read only _
Î´Î¹Î¬Î²Î±ÏÎµ Î¼ÏÎ½Î¿ _

register event _ type _
ÎºÎ±ÏÎ±ÏÏÏÎ·ÏÎµ Î³ÎµÎ³Î¿Î½ÏÏ _ ÏÏÏÎ¿Ï _

start WebThing server
Î¾ÎµÎºÎ¯Î½Î± ÎµÎ¾ÏÏÎ·ÏÎµÏÎ·ÏÎ® WebThing

trigger event _
ÎµÎ½ÎµÏÎ³Î¿ÏÎ¿Î¯Î·ÏÎ· Î³ÎµÎ³Î¿Î½ÏÏÎ¿Ï _

thing description JSON
ÏÎµÏÎ¹Î³ÏÎ±ÏÎ® Î±Î½ÏÎ¹ÎºÎµÎ¹Î¼Î­Î½Î¿Ï JSON

properties JSON
Î¹Î´Î¹ÏÏÎ·ÏÎµÏ JSON

event definitions JSON
Î¿ÏÎ¹ÏÎ¼Î¿Î¯ Î³ÎµÎ³Î¿Î½ÏÏÏÎ½ JSON

events JSON
Î³ÎµÎ³Î¿Î½ÏÏÎ± JSON

##################
# MicroBlocks UI #
##################

# buttons, error & info messages, dialog boxes, etc

New
ÎÎ­Î¿

Open
ÎÎ½Î¿Î¹Î¾Îµ

Open from board
ÎÎ½Î¿Î¹Î¾Îµ Î±ÏÏ ÏÎ·Î½ ÎºÎ¬ÏÏÎ±

Information
Î Î»Î·ÏÎ¿ÏÎ¿ÏÎ¯Î±

Plug in the board.
Î£ÏÎ½Î´ÎµÏÎµ ÏÎ·Î½ ÎºÎ¬ÏÏÎ± 

Reading project from board...
ÎÎ¹Î±Î²Î¬Î¶ÎµÎ¹ ÏÎ¿ Î­ÏÎ³Î¿ Î±ÏÏ ÏÎ·Î½ ÎºÎ¬ÏÏÎ± â¦

Loading project...
Î¦Î¿ÏÏÏÎ½ÎµÎ¹ ÏÎ¿ Î­ÏÎ³Î¿â¦

Found a newer version of
ÎÏÎ­Î¸Î·ÎºÎµ ÏÎ¹Î¿ Î½Î­Î± Î­ÎºÎ´Î¿ÏÎ· Î±ÏÏ

Do you want me to update the one in the project?
ÎÏÎ¹Î¸ÏÎ¼ÎµÎ¯Ï Î½Î± Î±Î½Î±Î½ÎµÏÏÏ Î±ÏÏÏ ÏÎ¿Ï Î­ÏÎ³Î¿Ï;

Save
ÎÏÎ¿Î¸Î®ÎºÎµÏÏÎµ

Connect
Î£ÏÎ½Î´Î­ÏÎ¿Ï

disconnect
ÎÏÎ¿ÏÏÎ½Î´Î­ÏÎ¿Ï

Serial port:
Î£ÎµÎ¹ÏÎ¹Î±ÎºÎ® Î¸ÏÏÎ±:

other...
Î¬Î»Î»Î±â¦

none
ÎºÎ±Î½Î­Î½Î±

Port name?
ÎÎ½Î¿Î¼Î± Î¸ÏÏÎ±Ï;

Board type:
Î¤ÏÏÎ¿Ï ÎºÎ¬ÏÏÎ±Ï:

Select board:
ÎÏÎ¹Î»Î¿Î³Î® ÎºÎ¬ÏÏÎ±Ï:

Could not read:
ÎÎµÎ½ Î¼ÏÎ¿ÏÎµÎ¯ Î½Î± Î´Î¹Î±Î²Î¬ÏÎµÎ¹:

by
Î±ÏÏ

Created with GP
ÎÎ·Î¼Î¹Î¿ÏÏÎ³Î®Î¸Î·ÎºÎµ Î¼Îµ GP

More info at http://microblocks.fun
Î ÎµÏÎ¹ÏÏÏÏÎµÏÎµÏ ÏÎ»Î·ÏÎ¿ÏÎ¿ÏÎ¯ÎµÏ ÏÏÎ¿ http://microblocks.fun

Function "
ÎÎµÎ¹ÏÎ¿ÏÏÎ³Î¯Î± â

" is too large to send to board.
â ÎµÎ¯Î½Î±Î¹ ÏÎ¿Î»Ï Î¼ÎµÎ³Î¬Î»Î¿ Î³Î¹Î± Î½Î± ÏÏÎ±Î»ÎµÎ¯ ÏÏÎ·Î½ ÎºÎ¬ÏÏÎ±

Script is too large to send to board.
Î¤Î¿ ÎºÎµÎ¯Î¼ÎµÎ½Î¿ ÎµÎ¯Î½Î±Î¹ ÏÎ¿Î»Ï Î¼ÎµÎ³Î¬Î»Î¿ Î³Î¹Î± Î½Î± ÏÏÎ±Î»ÎµÎ¯ ÏÏÎ·Î½ ÎºÎ¬ÏÏÎ±

Use "Connect" button to connect to a MicroBlocks device.
Î§ÏÎ·ÏÎ¹Î¼Î¿ÏÎ¿Î¯Î·ÏÎµ âÎ£ÏÎ½Î´Î­ÏÎ¿Ïâ Î³Î¹Î± Î½Î± ÏÏÎ½Î´ÎµÎ¸ÎµÎ¯Ï ÏÏÎ· ÏÏÏÎºÎµÏÎ® MicroBlocks.

No boards found; is your board plugged in?
ÎÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎ±Î½ ÎºÎ¬ÏÏÎµÏ, ÎµÎ¯Î½Î±Î¹ ÏÏÎ½Î´ÎµÎ´ÎµÎ¼Î­Î½Î· Î· ÎºÎ¬ÏÏÎ± ÏÎ¿Ï;

For AdaFruit boards, double-click reset button and try again.
ÎÎ¹Î± ÏÎ¹Ï ÎºÎ¬ÏÏÎµÏ Adafruit, Î´Î¹ÏÎ»Ï ÎºÎ»Î¯Îº ÏÏÎ¿ ÎºÎ¿ÏÎ¼ÏÎ¯ ÎµÏÎ±Î½Î±ÏÎ¿ÏÎ¬Ï (reset)ÎºÎ±Î¹ Î´Î¿ÎºÎ¯Î¼Î±ÏÎµ Î¾Î±Î½Î¬.

The board is not responding.
Î ÎºÎ¬ÏÏÎ± Î´ÎµÎ½ Î±Î½ÏÎ±ÏÎ¿ÎºÏÎ¯Î½ÎµÏÎ±Î¹.

Try to Install MicroBlocks on the board?
ÎÎ¿ÎºÎ¯Î¼Î±ÏÎµÏ Î½Î± ÎµÎ³ÎºÎ±ÏÎ±ÏÏÎ®ÏÎµÎ¹Ï ÏÎ¿ Microblocks ÏÏÎ·Î½ ÎºÎ¬ÏÏÎ±;

The MicroBlocks in your board is not current
Î¤Î¿ Microblocks ÏÏÎ·Î½ ÎºÎ¬ÏÏÎ± ÏÎ¿Ï Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ ÏÎ¿ ÏÎµÎ»ÎµÏÏÎ±Î¯Î¿

Try to update MicroBlocks on the board?
Î ÏÎ¿ÏÏÎ¬Î¸Î·ÏÎµÏ Î½Î± ÎµÎ³ÎºÎ±ÏÎ±ÏÏÎ®ÏÎµÎ¹Ï ÏÎ¿ Microblocks ÏÏÎ·Î½ ÎºÎ¬ÏÏÎ±;

Stop
Î£ÏÎ±Î¼Î¬ÏÎ±

Start
ÎÎµÎºÎ¯Î½Î±

Quit MicroBlocks?
ÎÎ± ÏÏÎ±Î¼Î±ÏÎ®ÏÏ ÏÎ¿ MicroBlocks;

Discard current project?
ÎÎ± Î¼Î·Î½ Î±ÏÎ¿Î¸Î·ÎºÎµÏÏÏ ÏÎ¿ ÏÏÎ­ÏÏÎ½ Î­ÏÎ³Î¿;

clean up
ÎºÎ±Î¸Î±ÏÎ¹ÏÎ¼ÏÏ

arrange scripts
Î£ÏÎ³Î®ÏÎ¹ÏÎµ ÏÎ± ÎºÎµÎ¯Î¼ÎµÎ½Î±

undrop (ctrl-Z)
--MISSING--

copy all scripts to clipboard
ÎÎ½ÏÎ¯Î³ÏÎ±ÏÎµ ÏÎ»Î± ÏÎ± ÎºÎµÎ¯Î¼ÎµÎ½Î± ÏÏÎ¿ ÏÏÏÏÎµÎ¹ÏÎ¿

paste all scripts
ÎÏÎ¹ÎºÏÎ»Î·ÏÎµ ÏÎ»Î± ÏÎ± ÎºÎµÎ¯Î¼ÎµÎ½Î±

paste script
ÎÏÎ¹ÎºÏÎ»Î·ÏÎµ ÎºÎµÎ¯Î¼ÎµÎ½Î¿

save a picture of all scripts
Î±ÏÎ¿Î¸Î®ÎºÎµÏÏÎµ ÏÏÏÎ¿Î³ÏÎ±ÏÎ¯Î± ÏÎ»ÏÎ½ ÏÏÎ½ ÎºÎµÎ¹Î¼Î­Î½ÏÎ½

about...
ÏÏÎµÏÎ¹ÎºÎ¬â¦

virtual machine version
ÎµÎ¹ÎºÎ¿Î½Î¹ÎºÎ® Î¼Î·ÏÎ±Î½Î® Î­ÎºÎ´Î¿ÏÎ· 

update firmware on board
ÎµÏÎ¹ÎºÎ±Î¹ÏÎ¿ÏÎ¿Î¯Î·ÏÎµ ÏÎ¿ firmware ÏÏÎ·Î½ ÎºÎ¬ÏÏÎ±

show data graph
ÎµÎ¼ÏÎ¬Î½Î¹ÏÎµ ÏÎ·Î½ Î³ÏÎ±ÏÎ¹ÎºÎ® ÏÎ±ÏÎ¬ÏÏÎ±ÏÎ·

set serial delay
ÏÏÎ¹ÏÎµ ÏÎ·Î½ ÏÎµÎ¹ÏÎ¹Î±ÎºÎ® ÎºÎ±Î¸ÏÏÏÎ­ÏÎ·ÏÎ·

firmware version
Î­ÎºÎ´Î¿ÏÎ· firmware

start WebThing server
Î¾ÎµÎºÎ¯Î½Î± ÎµÎ¾ÏÏÎ·ÏÎµÏÎ·ÏÎ® WebThing

stop WebThing server
ÏÏÎ±Î¼Î¬ÏÎ± ÎµÎ¾ÏÏÎ·ÏÎµÏÎ·ÏÎ® WebThing

HTTP Server
HTTP ÎµÎ¾ÏÏÎ·ÏÎµÏÎ·ÏÎ®Ï

MicroBlocks HTTP Server listening on port 6473
MicroBlocks HTTP ÎµÎ¾ÏÏÎ·ÏÎµÏÎ·ÏÎ®Ï Î±ÎºÎ¿ÏÎµÎ¹ ÏÏÎ·Î½ Î¸ÏÏÎ± 6473

disable autoloading board libraries
Î±ÏÎµÎ½ÎµÏÎ³Î¿ÏÎ¿Î¯Î·ÏÎ· Î±ÏÏÏÎ¼Î±ÏÎ·Ï ÏÏÏÏÏÏÎ·Ï ÏÏÎ½ Î²Î¹Î²Î»Î¹Î¿Î¸Î·ÎºÏÎ½ ÏÎ·Ï ÎºÎ¬ÏÏÎ±Ï

enable autoloading board libraries
ÎµÎ½ÎµÏÎ³Î¿ÏÎ¿Î¯Î·ÏÎ· ÏÎ·Ï Î±ÏÏÏÎ¼Î±ÏÎ·Ï ÏÏÏÏÏÏÎ·Ï ÏÏÎ½ Î²Î¹Î²Î»Î¹Î¿Î¸Î·ÎºÏÎ½ ÏÎ·Ï ÎºÎ¬ÏÏÎ±Ï

enable PlugShare when project empty
ÎµÎ½ÎµÏÎ³Î¿ÏÎ¿Î¯Î·ÏÎ· PlugShare ÏÏÎ±Î½ ÏÎ¿ Î­ÏÎ³Î¿ ÎµÎ¯Î½Î±Î¹ Î¬Î´ÎµÎ¹Î¿

disable PlugShare when project empty
Î±ÏÎµÎ½ÎµÏÎ³Î¿ÏÎ¿Î¯Î·ÏÎ· PlugShare ÏÏÎ±Î½ ÏÎ¿ Î­ÏÎ³Î¿ ÎµÎ¯Î½Î±Î¹ Î¬Î´ÎµÎ¹Î¿

erase flash and update firmware on ESP board
--MISSING--

Use board type
Î§ÏÎ·ÏÎ¹Î¼Î¿ÏÎ¿Î¯Î·ÏÎ· ÎºÎ¬ÏÏÎ±Ï ÏÏÏÎ¿Ï

Wiping board...
ÎÎ¹Î±Î³ÏÎ¬ÏÎµÎ¹ ÏÎ·Î½ ÎºÎ¬ÏÏÎ±â¦

(press ESC to cancel)
--MISSING--

Done!
ÎÎ³Î¹Î½Îµ!

download and install latest VM
ÎºÎ±ÏÎ­Î²Î±ÏÎµ ÎºÎ±Î¹ ÎµÎ³ÎºÎ±ÏÎ¬ÏÏÎ·ÏÎµ ÏÎ¿ ÏÎµÎ»ÎµÏÏÎ±Î¯Î¿ VM

Select board type:
ÎÏÎ¹Î»Î¿Î³Î® ÏÏÏÎ¿Ï ÎºÎ¬ÏÏÎ±Ï:

Uploading MicroBlocks to board...
Î¦Î¿ÏÏÏÎ½ÎµÎ¹ MicroBlocks ÏÏÎ·Î½ ÎºÎ¬ÏÏÎ±â¦

copy data to clipboard
Î±Î½ÏÎ¯Î³ÏÎ±ÏÎµ Î´ÎµÎ´Î¿Î¼Î­Î½Î± ÏÏÎ¿ ÏÏÏÏÎµÎ¹ÏÎ¿

clear data
ÎºÎ±Î¸Î¬ÏÎ¹ÏÎµ Î´ÎµÎ´Î¿Î¼Î­Î½Î±

clear memory and variables
ÎºÎ±Î¸Î¬ÏÎ¹ÏÎµ ÏÎ·Î½ Î¼Î½Î®Î¼Î· ÎºÎ±Î¹ ÏÎ¹Ï Î¼ÎµÏÎ±Î²Î»Î·ÏÎ­Ï

show advanced blocks
Î´ÎµÎ¯Î¾Îµ ÏÏÎ¿ÏÏÏÎ·Î¼Î­Î½Î± blocks

export functions as library
ÎµÎ¾Î±Î³ÏÎ³Î® Î»ÎµÎ¹ÏÎ¿ÏÏÎ³Î¹ÏÎ½ ÏÎ±Î½ Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·

hide advanced blocks
ÎºÏÏÏÎµ ÏÏÎ¿ÏÏÏÎ·Î¼Î­Î½Î± blocks

Data Graph
ÎÏÎ±ÏÎ¹ÎºÎ® Î Î±ÏÎ¬ÏÏÎ±ÏÎ·

show instructions
Î´ÎµÎ¯Î¾Îµ ÎµÎ½ÏÎ¿Î»Î­Ï

show compiled bytes
--MISSING--

expand
ÎµÏÎ­ÎºÏÎµÎ¹Î½Îµ

collapse
ÎºÎ±ÏÎ¬ÏÏÎµÏÏÎµ

rename...
Î¼ÎµÏÎ¿Î½Î¿Î¼Î±ÏÎ¯Î±

show block definition...
Î´ÎµÎ¯Î¾Îµ ÏÎ¿Î½ Î¿ÏÎ¹ÏÎ¼Ï ÏÎ¿Ï Î¼ÏÎ»Î¿Îº

show the definition of this block
Î´ÎµÎ¯Î¾Îµ ÏÎ¿Î½ Î¿ÏÎ¹ÏÎ¼Ï Î±ÏÏÎ¿Ï ÏÎ¿Ï Î¼ÏÎ»Î¿Îº

delete block definition...
Î´Î¹Î±Î³ÏÎ±ÏÎ® Î¿ÏÎ¹ÏÎ¼Î¿Ï Î¼ÏÎ»Î¿Îº

delete the definition of this block
Î´Î¹Î±Î³ÏÎ±ÏÎ® ÏÎ¿Ï Î¿ÏÎ¹ÏÎ¼Î¿Ï Î±ÏÏÎ¿Ï ÏÎ¿Ï Î¼ÏÎ»Î¿Îº

duplicate
Î±Î½ÏÎ¯Î³ÏÎ±ÏÎµ

duplicate this block
Î±Î½ÏÎ¯Î³ÏÎ±ÏÎµ Î±ÏÏÏ ÏÎ¿ Î¼ÏÎ»Î¿Îº

delete block
Î´Î¹Î¬Î³ÏÎ±ÏÎµ ÏÎ¿ Î¼ÏÎ»Î¿Îº

delete this block
Î´Î¹Î¬Î³ÏÎ±ÏÎµ Î±ÏÏÏ ÏÎ¿ Î¼ÏÎ»Î¿Îº

just this one block
Î¼ÏÎ½Î¿ Î±ÏÏÏ ÏÎ¿ Î¼ÏÎ»Î¿Îº

copy to clipboard
Î±Î½ÏÎ¯Î³ÏÎ±ÏÎµ ÏÏÎ¿ ÏÏÏÏÎµÎ¹ÏÎ¿

copy these blocks to the clipboard
Î±Î½ÏÎ¯Î³ÏÎ±ÏÎµ Î±ÏÏÎ¬ ÏÎ± Î¼ÏÎ»Î¿Îº ÏÏÎ¿ ÏÏÏÏÎµÎ¹ÏÎ¿

duplicate all
Î±Î½ÏÎ¹Î³ÏÎ±ÏÎ® ÏÎ»ÏÎ½

duplicate these blocks
Î±Î½ÏÎ¯Î³ÏÎ±ÏÎµ Î±ÏÏÎ¬ ÏÎ± Î¼ÏÎ»Î¿Îº

extract block
--MISSING--

pull out this block
ÏÏÎ¬Î²Î·Î¾Îµ Î­Î¾Ï Î±ÏÏÏ ÏÎ¿ Î¼ÏÎ»Î¿Îº

save picture of script
Î±ÏÎ¿Î¸Î®ÎºÎµÏÏÎµ ÏÏÏÎ¿Î³ÏÎ±ÏÎ¯Î± ÏÎ¿Ï ÎºÎµÎ¹Î¼Î­Î½Î¿Ï

save a picture of this block definition as a PNG file
Î±ÏÎ¿Î¸Î®ÎºÎµÏÏÎµ ÏÎ¿Î½ Î¿ÏÎ¹ÏÎ¼Ï Î±ÏÏÎ¿Ï ÏÎ¿Ï Î¼ÏÎ»Î¿Îº ÏÎµ ÏÏÏÎ¿Î³ÏÎ±ÏÎ¯Î± ÏÎ±Î½ PNG  Î±ÏÏÎµÎ¯Î¿

save a picture of these blocks as a PNG file
Î±ÏÎ¿Î¸Î®ÎºÎµÏÏÎµ ÏÏÏÎ¿Î³ÏÎ±ÏÎ¯Î± Î±ÏÏÏÎ½ ÏÏÎ½ Î¼ÏÎ»Î¿Îº ÏÎ±Î½ PNG  Î±ÏÏÎµÎ¯Î¿

copy script
Î±Î½ÏÎ¹Î³ÏÎ±ÏÎ® ÎºÎµÎ¹Î¼Î­Î½Î¿Ï

delete
Î´Î¹Î±Î³ÏÎ±ÏÎ®

Input type:
Î¤ÏÏÎ¿Ï ÎÎ¹ÏÏÎ´Î¿Ï:

string only
Î¼ÏÎ½Î¿ ÏÏÎ¼Î²Î¿Î»Î¿ÏÎµÎ¹ÏÎ¬

string or number
ÏÏÎ¼Î²Î¿Î»Î¿ÏÎµÎ¹ÏÎ¬ Î® Î±ÏÎ¹Î¸Î¼ÏÏ

number only
Î±ÏÎ¹Î¸Î¼ÏÏ Î¼ÏÎ½Î¿

define
ÏÏÎ¹ÏÎµ

number/string
Î±ÏÎ¹Î¸Î¼ÏÏ/ÏÏÎ¼Î²Î¿Î»Î¿ÏÎµÎ¹ÏÎ¬

editable number or string
ÎµÏÎµÎ¾ÎµÏÎ³Î¬ÏÎ¹Î¼Î¿Ï Î±ÏÎ¹Î¸Î¼ÏÏ Î® ÏÏÎ¼Î²Î¿Î»Î¿ÏÎµÎ¹ÏÎ¬

label
ÎµÏÎ¹ÎºÎ­ÏÎ±

input
ÎµÎ¯ÏÎ¿Î´Î¿Ï

hide block definition
ÎºÏÏÏÎµ ÏÎ¿Î½ Î¿ÏÎ¹ÏÎ¼Ï Î¼ÏÎ»Î¿Îº

Are you sure you want to remove this block definition?
ÎÎ¯ÏÎ±Î¹ ÏÎ¯Î³Î¿ÏÏÎ¿Ï ÏÏÎ¹ ÎµÏÎ¹Î¸ÏÎ¼ÎµÎ¯Ï Î½Î± Î±ÏÎ±Î¹ÏÎ­ÏÎµÎ¹Ï ÏÎ¿Î½ Î¿ÏÎ¹ÏÎ¼Ï ÏÎ¿Ï Î¼ÏÎ»Î¿Îº;

Language
ÎÎ»ÏÏÏÎ±

Custom...
Î ÏÎ¿ÏÎ±ÏÎ¼Î¿ÏÎ¼Î­Î½Î¿â¦

Obsolete
ÎÎµÏÎµÏÎ±ÏÎ¼Î­Î½Î¿

OK
--MISSING--

Ok
--MISSING--

Yes
ÎÎ±Î¹

No
ÎÏÎ¹

Cancel
ÎÎºÏÏÏÏÎ·

Okay
--MISSING--

Confirm
ÎÏÎ¹Î²ÎµÎ²Î±Î¯ÏÏÎ·

# File picker and library dialogs

Libraries
ÎÎ¹Î²Î»Î¹Î¿Î¸Î®ÎºÎµÏ

Examples
Î Î±ÏÎ±Î´ÎµÎ¯Î³Î¼Î±ÏÎ±

Desktop
ÎÎ¸ÏÎ½Î·

Computer
Î¥ÏÎ¿Î»Î¿Î³Î¹ÏÏÎ®Ï

Cloud
ÎÎ­ÏÎ¿Ï

File
ÎÏÏÎµÎ¯Î¿

File Open
ÎÏÏÎµÎ¯Î¿ ÎÎ½Î¿Î¹Î³Î¼Î±

File Save
ÎÏÏÎµÎ¯Î¿ ÎÏÎ¿Î¸Î®ÎºÎµÏÏÎ·

File name:
ÎÏÏÎµÎ¯Î¿ ÏÎ½Î¿Î¼Î±:

New Folder
ÎÎ­Î¿Ï Î¦Î¬ÎºÎµÎ»Î¿Ï

by
Î±ÏÏ

Depends:
ÎÎ¾Î±ÏÏÎ¬ÏÎ±Î¹:

Tags:
ÎÏÎ¹ÎºÎ­ÏÎµÏ:

Path, name or URL for library?
ÎÎ¿Î½Î¿ÏÎ¬ÏÎ¹, ÏÎ½Î¿Î¼Î± Î® URL Î³Î¹Î± Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·;

Invalid URL
âAÎºÏÏÎ¿ URL

Could not fetch library.
ÎÎµÎ½ Î¼ÏÏÏÎµÏÎµ Î½Î± ÏÎ¿ÏÏÏÏÎµÎ¹ ÏÎ·Î½ Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·.

Host does not exist or is currently down.
ÎÎ¹ÎºÎ¿Î´ÎµÏÏÏÏÎ·Ï Î´ÎµÎ½ ÏÏÎ¬ÏÏÎµÎ¹ Î® Î´ÎµÎ½ Î»ÎµÎ¹ÏÎ¿ÏÏÎ³ÎµÎ¯

File not found in server.
Î¤Î¿ Î±ÏÏÎµÎ¯Î¿ Î´ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎµ ÏÏÎ¿Î½ ÎµÎ¾ÏÏÎ·ÏÎµÏÎ·ÏÎ®.

Server expects HTTPS, and MicroBlocks doesn't currently support it.
ÎÎ¾ÏÏÎ·ÏÎµÏÎ·ÏÎ®Ï  Î±Î½Î±Î¼Î­Î½ÎµÎ¹ HTTPS,  Î±Î»Î»Î¬  Î´ÎµÎ½ ÏÏÎ¿ÏÏÎ·ÏÎ¯Î¶ÎµÏÎ±Î¹ Î±ÏÏ ÏÎ¿ MicroBlocks

library information
ÏÎ»Î·ÏÎ¿ÏÎ¿ÏÎ¯Î± Î³Î¹Î± ÏÎ·Î½ Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·

built-in library
ÎµÎ½ÏÏÎ¼Î±ÏÏÎ¼Î­Î½Î· Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·

Dependency path, name or URL?
ÎÎ¾Î±ÏÏÏÎ¼Î­Î½Î· Î´Î¹Î±Î´ÏÎ¿Î¼Î®, ÏÎ½Î¿Î¼Î± Î® URL;

Tag name?
ÎÎ½Î¿Î¼Î± ÎÏÎ¹ÎºÎ­ÏÎ±Ï;

# MicroBlocks translation file
# Last updated: March 14 2023

#########################
# Blocks and categories #
#########################

Output
ÐÑÐ²Ð¾Ð´

set user LED _
Ð·Ð°Ð´Ð°ÑÑ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»ÑÑÐºÐ¸Ð¹ ÑÐ²ÐµÑÐ¾Ð´Ð¸Ð¾Ð´ _

say _
ÑÐºÐ°Ð·Ð°ÑÑ _

graph _
Ð³ÑÐ°ÑÐ¸Ðº

Input
ÐÐ²Ð¾Ð´

button A
ÐºÐ½Ð¾Ð¿ÐºÐ° A

button B
ÐºÐ½Ð¾Ð¿ÐºÐ° B

timer
ÑÐ°Ð¹Ð¼ÐµÑ

reset timer
ÑÐ±ÑÐ¾ÑÐ¸ÑÑ ÑÐ°Ð¹Ð¼ÐµÑ

microseconds
Ð¼Ð¸ÐºÑÐ¾ÑÐµÐºÑÐ½Ð´

milliseconds
Ð¼Ð¸Ð»Ð»Ð¸ÑÐµÐºÑÐ½Ð´

board type
ÑÐ¸Ð¿ Ð¿Ð»Ð°ÑÑ

Pins
ÐÐ¾Ð½ÑÐ°ÐºÑÑ

read digital pin _
ÑÐ¸ÑÐ°ÑÑ ÑÐ¸ÑÑÐ¾Ð²Ð¾Ð¹ ÐºÐ¾Ð½ÑÐ°ÐºÑ _

read analog pin _
ÑÐ¸ÑÐ°ÑÑ Ð°Ð½Ð°Ð»Ð¾Ð³Ð¾Ð²ÑÐ¹ ÐºÐ¾Ð½ÑÐ°ÐºÑ _

pullup _
Ð¿Ð¾Ð´ÑÑÐ½ÑÑÑ _

set digital pin _ to _
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÑÐ¸ÑÑÐ¾Ð²Ð¾Ð¹ ÐºÐ¾Ð½ÑÐ°ÐºÑ _ Ð½Ð° _

set pin _ to _
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÐºÐ¾Ð½ÑÐ°ÐºÑ _ Ð½Ð° _

analog pins
Ð°Ð½Ð°Ð»Ð¾Ð³Ð¾Ð²ÑÐµ ÐºÐ¾Ð½ÑÐ°ÐºÑÑ

digital pins
ÑÐ¸ÑÑÐ¾Ð²ÑÐµ ÐºÐ¾Ð½ÑÐ°ÐºÑÑ

Control
ÐÐ¾Ð½ÑÑÐ¾Ð»Ñ

when started
ÐºÐ¾Ð³Ð´Ð° Ð·Ð°Ð¿ÑÑÐµÐ½Ð¾

when button _ pressed
ÐºÐ¾Ð³Ð´Ð° ÐºÐ½Ð¾Ð¿ÐºÐ° _ Ð½Ð°Ð¶Ð°ÑÐ°

forever _
Ð²ÑÐµÐ³Ð´Ð° _

repeat _ _
Ð¿Ð¾Ð²ÑÐ¾ÑÐ¸ÑÑ _ _

wait _ millisecs
Ð¶Ð´Ð°ÑÑ _ Ð¼Ð¸Ð»Ð»Ð¸ÑÐµÐºÑÐ½Ð´

if _ _
ÐµÑÐ»Ð¸ _ _

if _ _ else _
ÐµÑÐ»Ð¸ _ _ Ð¸Ð½Ð°ÑÐµ _

else if _ _
Ð¸Ð½Ð°ÑÐµ, ÐµÑÐ»Ð¸ _ _

else
Ð¸Ð½Ð°ÑÐµ

when _
ÐºÐ¾Ð³Ð´Ð° _

wait until _
Ð¶Ð´Ð°ÑÑ Ð¿Ð¾ÐºÐ° _

wait _ microsecs
Ð¶Ð´Ð°ÑÑ _ Ð¼Ð¸ÐºÑÐ¾ÑÐµÐºÑÐ½Ð´

return _
Ð²Ð¾Ð·Ð²ÑÐ°Ñ _

when _ received
ÐºÐ¾Ð³Ð´Ð° _ Ð¿Ð¾Ð»ÑÑÐµÐ½

go!
go!

broadcast _
ÑÑÐ°Ð½ÑÐ»ÑÑÐ¸Ñ _

comment _
ÐºÐ¾Ð¼Ð¼ÐµÐ½ÑÐ°ÑÐ¸Ð¹ _

How this works...
ÐÐ°Ðº ÑÑÐ¾ ÑÐ°Ð±Ð¾ÑÐ°ÐµÑ...

for _ in _ _
Ð´Ð»Ñ _ Ð² _ _

repeat until _ _
Ð¿Ð¾Ð²ÑÐ¾ÑÑÑÑ Ð´Ð¾ _ _

stop this task
Ð¾ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÑÑÑ Ð·Ð°Ð´Ð°ÑÑ

stop other tasks
Ð¾ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð´ÑÑÐ³Ð¸Ðµ Ð·Ð°Ð´Ð°ÑÐ¸

stop all
Ð¾ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð²ÑÑ

last message
Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÐµÐµ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ðµ

call _
Ð²ÑÐ·Ð²Ð°ÑÑ _

function name
Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ ÑÑÐ½ÐºÑÐ¸Ð¸

parameter list
ÑÐ¿Ð¸ÑÐ¾Ðº Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð²

with _
Ñ _

Operators
ÐÐ¿ÐµÑÐ°ÑÐ¾ÑÑ

_ mod _
_ Ð¼Ð¾Ð´ _

abs _
Ð°Ð±Ñ _

min _ _
Ð¼Ð¸Ð½ _ _

max _ _
Ð¼Ð°ÐºÑ _ _

random _ to _
ÑÐ»ÑÑÐ°Ð¹Ð½Ð¾Ðµ Ð¾Ñ _ Ð´Ð¾ _

not _
Ð½ÐµÑ _

_ and _
_ Ð¸ _

and _
Ð¸ _

_ or _
_ Ð¸Ð»Ð¸ _

or _
Ð¸Ð»Ð¸ _

_ is a _
_ ÑÑÐ¾ _

boolean
Ð±ÑÐ»ÐµÐ²Ð¾

number
ÑÐ¸ÑÐ»Ð¾

string
ÑÑÑÐ¾ÐºÐ°

list
ÑÐ¿Ð¸ÑÐ¾Ðº

byte array
Ð¼Ð°ÑÑÐ¸Ð² Ð±Ð°Ð¹Ñ

Advanced:
ÐÑÐ¾Ð´Ð²Ð¸Ð½ÑÑÑÐ¹:

rescale _ from ( _ , _ ) to ( _ , _ )
Ð¸Ð·Ð¼ÐµÐ½Ð¸ÑÑ Ð¼Ð°ÑÑÑÐ°Ð± _ ( _ , _ ) Ð´Ð¾ ( _ , _ )

hex _
hex _

Variables
ÐÐµÑÐµÐ¼ÐµÐ½Ð½ÑÐµ

# Buttons on top of "Variables" category

Add a variable
ÐÐ¾Ð±Ð°Ð²Ð¸ÑÑ Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½ÑÑ

Delete a variable
Ð£Ð´Ð°Ð»Ð¸ÑÑ Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½ÑÑ

# New variable dialog

New variable name?
ÐÐ¾Ð²Ð¾Ðµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹?

set _ to _
Ð·Ð°Ð´Ð°ÑÑ _ Ð´Ð¾ _

change _ by _
Ð¸Ð·Ð¼ÐµÐ½Ð¸ÑÑ _ Ð½Ð° _

initialize local _ to _
Ð¸Ð½Ð¸ÑÐ¸Ð°Ð»Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°ÑÑ Ð»Ð¾ÐºÐ°Ð»ÑÐ½ÑÐ¹ _ Ð´Ð»Ñ _

Data
ÐÐ°Ð½Ð½ÑÐµ

list
ÑÐ¿Ð¸ÑÐ¾Ðº

cat
ÐºÐ¾ÑÐºÐ°

dog
ÑÐ¾Ð±Ð°ÐºÐ°

bird
Ð¿ÑÐ¸ÑÐ°

fish
ÑÑÐ±Ð°

length of _
Ð´Ð»Ð¸Ð½Ð° _

item _ of _
ÑÐ»ÐµÐ¼ÐµÐ½Ñ _ Ð¸Ð· _

replace item _ of list _ with _
Ð·Ð°Ð¼ÐµÐ½Ð¸ÑÑ ÑÐ»ÐµÐ¼ÐµÐ½Ñ _ ÑÐ¿Ð¸ÑÐºÐ° _ Ð½Ð° _

delete item _ of list _
ÑÐ´Ð°Ð»Ð¸ÑÑ ÑÐ»ÐµÐ¼ÐµÐ½Ñ _ Ð¸Ð· ÑÐ¿Ð¸ÑÐºÐ° _

add _ to list _
Ð´Ð¾Ð±Ð°Ð²Ð¸ÑÑ _ Ð² ÑÐ¿Ð¸ÑÐ¾Ðº _

join _ _
ÑÐ¾ÐµÐ´Ð¸Ð½Ð¸ÑÑ _ _

copy _ from _
ÑÐºÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°ÑÑ _ Ð¸Ð· _

smiles
ÑÐ»ÑÐ±ÐºÐ¸

to _
Ð² _

find _ in _
Ð½Ð°Ð¹ÑÐ¸ _ Ð² _

starting at _
Ð½Ð°ÑÐ¸Ð½Ð°ÐµÑÑÑ Ñ _

join items of list _
ÑÐ¾ÐµÐ´Ð¸Ð½Ð¸ÑÑ ÑÐ»ÐµÐ¼ÐµÐ½ÑÑ Ð¸Ð· ÑÐ¿Ð¸ÑÐºÐ° _

separator _
ÑÐ°Ð·Ð´ÐµÐ»Ð¸ÑÐµÐ»Ñ _

unicode _ of _
ÑÐ½Ð¸ÐºÐ¾Ð´ _ Ð¸Ð·

string from unicode _
ÑÑÑÐ¾ÐºÐ° Ð¸Ð· ÑÐ½Ð¸ÐºÐ¾Ð´Ð° _

new list length _
Ð½Ð¾Ð²Ð°Ñ Ð´Ð»Ð¸Ð½Ð° ÑÐ¿Ð¸ÑÐºÐ° _

new byte array _
Ð½Ð¾Ð²ÑÐ¹ Ð±Ð°Ð¹ÑÐ¾Ð²ÑÐ¹ Ð¼Ð°ÑÑÐ¸Ð² _ 

as byte array _
ÐºÐ°Ðº Ð¼Ð°ÑÑÐ¸Ð² Ð±Ð°Ð¹Ñ

aByteListOrString
Ð¼Ð°ÑÑÐ¸Ð²ÐÐ°Ð¹ÑÐÐ»Ð¸Ð¡ÑÑÐ¾ÐºÐ°

with all _
ÑÐ¾ Ð²ÑÐµÐ¼Ð¸ _

free memory
ÑÐ²Ð¾Ð±Ð¾Ð´Ð½Ð°Ñ Ð¿Ð°Ð¼ÑÑÑ

all
Ð²ÑÐµ

last
Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹

random
ÑÐ»ÑÑÐ°Ð¹Ð½ÑÐ¹

split _ by _
ÑÐ°Ð·Ð±Ð¸ÑÑ _ Ð¿Ð¾ _

My Blocks
ÐÐ¾Ð¸ ÐÐ»Ð¾ÐºÐ¸

Generic
ÐÐ±ÑÐ¸Ðµ

# Buttons on top of "My Blocks" category

Add a command block
ÐÐ¾Ð±Ð°Ð²Ð¸ÑÑ Ð±Ð»Ð¾Ðº ÐºÐ¾Ð¼Ð°Ð½Ð´

Add a reporter block
ÐÐ¾Ð±Ð°Ð²Ð¸ÑÑ Ð±Ð»Ð¾Ðº Ð´Ð¾ÐºÐ»Ð°Ð´ÑÐ¸Ðº

# Make a block dialog

Enter function name:
ÐÐ²ÐµÐ´Ð¸ÑÐµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ ÑÑÐ½ÐºÑÐ¸Ð¸:

Comm
Ð¡Ð²ÑÐ·Ñ

i2c get device _ register _
i2c Ð¿Ð¾Ð»ÑÑÐ¸ÑÑ ÑÑÑÑÐ¾Ð¹ÑÑÐ²Ð¾ _ Ð·Ð°ÑÐµÐ³Ð¸ÑÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑ_

i2c set device _ register _ to _
i2c Ð·Ð°Ð´Ð°ÑÑ ÑÑÑÑÐ¾Ð¹ÑÑÐ²Ð¾ _ Ð·Ð°ÑÐµÐ³Ð¸ÑÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑ _ Ð½Ð° _

i2c device _ read list _
i2c ÑÑÑÑÐ¾Ð¹ÑÑÐ²Ð¾ _ ÑÐ¿Ð¸ÑÐ¾Ðº ÑÑÐµÐ½Ð¸Ñ _

i2c device _ write list _
i2c device _ ÑÐ¿Ð¸ÑÐ¾Ðº Ð·Ð°Ð¿Ð¸ÑÐ¸ _

spi send _
Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ° spi _

spi receive
Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ðµ spi

spi setup speed _
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÑÐºÐ¾ÑÐ¾ÑÑÑ spi _

mode _
ÑÐµÐ¶Ð¸Ð¼ _

rpi channel _
ÐºÐ°Ð½Ð°Ð» rpi _

spi exchange bytes _
--MISSING--

aByteArray
--MISSING--

serial open _ baud
--MISSING--

serial close
--MISSING--

serial read
--MISSING--

serial write _
--MISSING--

serial write _ starting at _
--MISSING--

aByteStringOrByteArray
--MISSING--

soft serial write byte _ pin _ baud _
--MISSING--

print _
Ð²ÑÐ²Ð¾Ð´ _

no op
Ð½ÐµÑ ÐÐ

ignore
Ð¸Ð³Ð½Ð¾ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ

##############
# Primitives #
##############

# These are all mostly hidden from end users

draw shape _ at x _ y _
Ð½Ð°ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÐ¸Ð³ÑÑÑ _ Ð¿Ð¾ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÐ°Ð¼ x _ y _

shape for letter _
ÑÐ¾ÑÐ¼Ð° Ð´Ð»Ñ Ð±ÑÐºÐ²Ñ _

send NeoPixel rgb _
Ð¿Ð¾ÑÐ»Ð°ÑÑ NeoPixel rgb _

has tone support
Ð¸Ð¼ÐµÐµÑ Ð¿Ð¾Ð´Ð´ÐµÑÐ¶ÐºÑ ÑÐ¾Ð½Ð°

play tone pin _ frequency _
Ð²Ð¾ÑÐ¿ÑÐ¾Ð¸Ð·Ð²ÐµÑÑÐ¸ ÑÐ¾Ð½ Ð½Ð° ÐºÐ¾Ð½ÑÐ°ÐºÑÐµ _ Ñ ÑÐ°ÑÑÐ¾ÑÐ¾Ð¹ _

has WiFi support
Ð¿Ð¾Ð´Ð´ÐµÑÐ¶Ð¸Ð²Ð°ÐµÑ WiFi

start WiFi _ password _
Ð·Ð°Ð¿ÑÑÑÐ¸ÑÑ WiFi _ Ð¿Ð°ÑÐ¾Ð»Ñ_

stop WiFi
Ð¾ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ WiFi

WiFi status
ÑÑÐ°ÑÑÑ WiFi

my IP address
Ð¼Ð¾Ð¹ IP-Ð°Ð´ÑÐµÑ

radio send number _
Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ° Ð½Ð¾Ð¼ÐµÑÐ° Ð¿Ð¾ ÑÐ°Ð´Ð¸Ð¾ _

radio send string _
Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ° ÑÑÑÐ¾ÐºÐ¸ Ð¿Ð¾ ÑÐ°Ð´Ð¸Ð¾ _

Hello!
--MISSING--

radio send pair _ = _
Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ° Ð¿Ð°ÑÑ Ð¿Ð¾ ÑÐ°Ð´Ð¸Ð¾ _ = _

light
--MISSING--

radio message received?
ÑÐ°Ð´Ð¸Ð¾ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ðµ Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¾?

radio last number
Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ Ð½Ð¾Ð¼ÐµÑ ÑÐ°Ð´Ð¸Ð¾

radio last string
Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÑÑ ÑÑÑÐ¾ÐºÐ° ÑÐ°Ð´Ð¸Ð¾

radio last message type
Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ ÑÐ¸Ð¿ ÑÐ°Ð´Ð¸Ð¾-ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ

radio set group _ (0-255)
Ð·Ð°Ð´Ð°ÑÑ Ð³ÑÑÐ¿Ð¿Ñ ÑÐ°Ð´Ð¸Ð¾ _ (0-255)

radio set channel (0-83) _
Ð·Ð°Ð´Ð°ÑÑ ÐºÐ°Ð½Ð°Ð» ÑÐ°Ð´Ð¸Ð¾ (0-83) _

radio set power (0-7) _
Ð·Ð°Ð´Ð°ÑÑ Ð¼Ð¾ÑÐ½Ð¾ÑÑÑ ÑÐ°Ð´Ð¸Ð¾ (0-7) _

radio last signal strength
Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÑÑ Ð¼Ð¾ÑÐ½Ð¾ÑÑÑ ÑÐ°Ð´Ð¸Ð¾ ÑÐ¸Ð³Ð½Ð°Ð»Ð°

radio receive packet _
Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ðµ ÑÐ°Ð´Ð¸Ð¾ Ð¿Ð°ÐºÐµÑÐ° _

radio send packet _
Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ° ÑÐ°Ð´Ð¸Ð¾ Ð¿Ð°ÐºÐµÑÐ° _

disable radio
Ð¾ÑÐºÐ»ÑÑÐ¸ÑÑ ÑÐ°Ð´Ð¸Ð¾

#############
# Libraries #
#############

Basic Sensors
ÐÐ°Ð·Ð¾Ð²ÑÐµ Ð¡ÐµÐ½ÑÐ¾ÑÑ

tilt x
Ð½Ð°ÐºÐ»Ð¾Ð½ x

tilt y
Ð½Ð°ÐºÐ»Ð¾Ð½ y

tilt z
Ð½Ð°ÐºÐ»Ð¾Ð½ z

acceleration
Ð°ÐºÐºÑÐµÐ»ÐµÑÐ°ÑÐ¾Ð²

light level
ÑÑÐ¾Ð²ÐµÐ½Ñ Ð¾ÑÐ²ÐµÑÑÐ½Ð½Ð¾ÑÑÐ¸

temperature (Â°C)
ÑÐµÐ¼Ð¿ÐµÑÐ°ÑÑÑÐ° (Â°C)

magnetic field
Ð¼Ð°Ð³Ð½Ð¸ÑÐ½Ð¾Ðµ Ð¿Ð¾Ð»Ðµ

set acceleration range _ g = 100
Ð·Ð°Ð´Ð°ÑÑ Ð¸Ð½ÑÐµÑÐ²Ð°Ð» ÑÑÐºÐ¾ÑÐµÐ½Ð¸Ñ _ g = 100

####
# NeoPixel library

NeoPixel
NeoPixel

set NeoPixels _ _ _ _ _ _ _ _ _ _
Ð·Ð°Ð´Ð°ÑÑ NeoPixels _ _ _ _ _ _ _ _ _ _

clear NeoPixels
Ð¾ÑÐ¸ÑÑÐ¸ÑÑ NeoPixels

set NeoPixel _ color _
Ð·Ð°Ð´Ð°ÑÑ NeoPixel _ ÑÐ²ÐµÑ _

set all NeoPixels color _
Ð·Ð°Ð´Ð°ÑÑ ÑÐ²ÐµÑÐ° Ð²ÑÐµÐ¼ NeoPixels _

rotate NeoPixels by _
Ð¿Ð¾Ð²ÐµÑÐ½ÑÑÑ NeoPixels Ð½Ð° _

brighten NeoPixel _ by _
ÑÐ²ÐµÐ»Ð¸ÑÐ¸ÑÑ ÑÑÐºÐ¾ÑÑÑ NeoPixel _ Ð½Ð° _

brighten all NeoPixels by _
ÑÐ²ÐµÐ»Ð¸ÑÐ¸ÑÑ ÑÑÐºÐ¾ÑÑÑ Ð²ÑÐµÐ¼ NeoPixels Ð½Ð° _

color r _ g _ b _ (0-255)
ÑÐ²ÐµÑÐ° r _ g _ b _ (0-255)

random color
ÑÐ»ÑÑÐ°Ð¹Ð½ÑÐ¹ ÑÐ²ÐµÑ

attach _ LED NeoPixel strip to pin _
Ð¿ÑÐ¸ÐºÑÐµÐ¿Ð¸ÑÑ _ ÑÐ²ÐµÑÐ¾Ð´Ð¸Ð¾Ð´Ð½ÑÑ Ð¿Ð¾Ð»Ð¾ÑÑ NeoPixel Ðº ÐºÐ¾Ð½ÑÐ°ÐºÑÑ _

has white _
Ð¸Ð¼ÐµÐµÑ Ð±ÐµÐ»ÑÐ¹ _

PIR
PIR

PIR at pin _ detected movement
PIR

#### NeoPanel library

NeoPanel
--MISSING--

attach NeoPixel panel width _ height _ at pin _
--MISSING--

NeoPanel set x _ y _ color _
--MISSING--

NeoPanel fill column _ color _
--MISSING--

NeoPanel fill row _ color _
--MISSING--

NeoPanel fill rectangle x _ y _ width _ height _ color _
--MISSING--

NeoPanel draw text _ at x _ y _ color _
--MISSING--

NeoPanel draw BMP file _ at x _ y _
--MISSING--

####
# Microphone library

Microphone
ÐÐ¸ÐºÑÐ¾ÑÐ¾Ð½

microphone
Ð¼Ð¸ÐºÑÐ¾ÑÐ¾Ð½

turn on microphone
Ð²ÐºÐ»ÑÑÐ¸ÑÑ Ð¼Ð¸ÐºÑÐ¾ÑÐ¾Ð½

loudness
Ð³ÑÐ¾Ð¼ÐºÐ¾ÑÑÑ

clap count
ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ ÑÐ»Ð¾Ð¿ÐºÐ¾Ð²

set clap threshold _
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð¿ÑÐµÐ´ÐµÐ» ÑÐ»Ð¾Ð¿ÐºÐ° _

estimate clap threshold
Ð¾ÑÐµÐ½Ð¸ÑÑ Ð¿Ð¾ÑÐ¾Ð³ ÑÐ»Ð¾Ð¿ÐºÐ°

####
# Citilab ED1 board libraries

ED1 Stepper Motor
ED1 Ð¨Ð°Ð³Ð¾Ð¼ÐµÑ

move motor _ _ steps _
Ð´Ð²Ð¸Ð³Ð°ÑÑ Ð´Ð²Ð¸Ð³Ð°ÑÐµÐ»Ñ _ _ ÑÐ°Ð³Ð¸ _

move motor 1 _ and motor 2 _ _ steps
Ð´Ð²Ð¸Ð³Ð°ÑÑ Ð¼Ð¾ÑÐ¾Ñ 1 _ Ð¸ Ð¼Ð¾ÑÐ¾Ñ 2 Ð½Ð° _ _ ÑÐ°Ð³Ð¾Ð²

move motor _ angle _ Â°
Ð¡Ð´Ð²Ð¸Ð½ÑÑÑ Ð´Ð²Ð¸Ð³Ð°ÑÐµÐ»Ñ _ ÑÐ³Ð¾Ð» _ Â°

move motor _ _ complete turns
Ð¿ÐµÑÐµÐ¼ÐµÑÑÐ¸ÑÑ Ð´Ð²Ð¸Ð³Ð°ÑÐµÐ»Ñ _ _ Ð¿Ð¾Ð»Ð½ÑÑ Ð¾Ð±Ð¾ÑÐ¾ÑÐ¾Ð²

stop steppers
Ð¾ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÑÑÐµÐ¿Ð¿ÐµÑÑ

clockwise
Ð¿Ð¾ ÑÐ°ÑÐ¾Ð²Ð¾Ð¹ ÑÑÑÐµÐ»ÐºÐµ

counter-clockwise
Ð¿ÑÐ¾ÑÐ¸Ð² ÑÐ°ÑÐ¾Ð²Ð¾Ð¹ ÑÑÑÐµÐ»ÐºÐ¸

ED1 Buttons
ED1 ÐÐ½Ð¾Ð¿ÐºÐ¸

button OK
ÐºÐ½Ð¾Ð¿ÐºÐ° ÐÐ

button X
ÐºÐ½Ð¾Ð¿ÐºÐ° X

button up
ÐºÐ½Ð¾Ð¿ÐºÐ° Ð²Ð²ÐµÑÑ

button down
ÐºÐ½Ð¾Ð¿ÐºÐ° Ð²Ð½Ð¸Ð·

button left
ÐºÐ½Ð¾Ð¿ÐºÐ° Ð²Ð»ÐµÐ²Ð¾

button right
ÐºÐ½Ð¾Ð¿ÐºÐ° Ð²Ð¿ÑÐ°Ð²Ð¾

capacitive sensor _
ÑÐ¼ÐºÐ¾ÑÑÐ½ÑÐ¹ ÑÐµÐ½ÑÐ¾Ñ _

set capacitive threshold to _
Ð·Ð°Ð´Ð°ÑÑ Ð¿Ð¾ÑÐ¾Ð³ ÑÐ¼ÐºÐ¾ÑÑÐ½Ð¾Ð¹ ÑÑÐ²ÑÑÐ²Ð¸ÑÐµÐ»ÑÐ½Ð¾ÑÑÐ¸ Ð½Ð° _

####
# BirdBrain Technologies libraries

Hummingbird LED _ _ %
Hummingbird LED _ _ %

Hummingbird Tri-LED _ R _ % G _ % B _ %
Hummingbird Tri-LED _ R _ % G _ % B _ %

Hummingbird Position Servo _ _ Â°
Ð¡ÐµÑÐ²Ð¾Ð¿ÑÐ¸Ð²Ð¾Ð´ Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ ÐºÐ¾Ð»Ð¸Ð±ÑÐ¸ _ _ Â°

Hummingbird Rotation Servo _ _ %
Hummingbird Ð¿Ð¾Ð²Ð¾ÑÐ¾Ñ ÑÐµÑÐ²Ð¾Ð¿ÑÐ¸Ð²Ð¾Ð´Ð° _ _ %

Hummingbird _ _
Hummingbird _ _

Hummingbird Battery (mV)
ÐÐ°ÑÐ°ÑÐµÑ Hummingbird (Ð¼Ð)

Light
Ð¡Ð²ÐµÑ

Distance (cm)
ÐÐ¸ÑÑÐ°Ð½ÑÐ¸Ñ (cm)

Dial
ÐÐ°Ð±Ð¾Ñ

Sound
ÐÐ²ÑÐº

Other
ÐÑÐ¾ÑÐµÐµ

Finch Beak Red _ Green _ Blue _
ÐÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Finch ÐÑÐ°ÑÐ½ÑÐ¹ _ ÐÐµÐ»ÐµÐ½ÑÐ¹ _ Ð¡Ð¸Ð½Ð¸Ð¹ _ 

Finch Tail _ Red _ Green _ Blue _
Ð¥Ð²Ð¾ÑÑ Finch _ ÐÑÐ°ÑÐ½ÑÐ¹ _ ÐÐµÐ»ÐµÐ½ÑÐ¹ _ Ð¡Ð¸Ð½Ð¸Ð¹ _ 

Finch Move _ _ cm at _ %
ÐÐµÑÐ´Ð²Ð¸Ð½ÑÑÑ Finch _ _ cÐ¼ Ð½Ð° _ %

Finch Turn _ _ Â° at _ %
ÐÐ¾Ð²ÐµÑÐ½ÑÑÑ Finch _ _ Â° Ð½Ð° _ %

Finch Wheels L _ % R _ %
ÐÐ¾Ð»ÐµÑÐ° Finch Ð _ % Ð _ %

Finch Stop
ÐÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Finch

Finch Distance (cm)
ÐÐ¸ÑÑÐ°Ð½ÑÐ¸Ñ Finch (ÑÐ¼)

Finch _ Light
Ð¯ÑÐºÐ¾ÑÑÑ _ Finch

Finch _ Line
Ð¡ÑÑÐ¾ÐºÐ° _ Finch

Finch Reset Encoders
Ð¡Ð±ÑÐ¾Ñ ÐºÐ¾Ð´Ð¸ÑÐ¾Ð²ÐºÐ¸ Finch

Finch _ Encoder
ÐÐ¾Ð´Ð¸ÑÐ¾Ð²ÑÐ¸Ðº _ Finch

Finch Accelerometer _
Ð£ÑÐºÐ¾ÑÐ¸ÑÐµÐ»Ñ Finch

Finch Battery
ÐÐ°ÑÐ°ÑÐµÐ¹ÐºÐ° Finch 

All
ÐÑÐµ

Forward
ÐÐ¿ÐµÑÐµÐ´

Backward
ÐÐ°Ð·Ð°Ð´

Right
ÐÑÐ°Ð²Ð¾

Left
ÐÐ»ÐµÐ²Ð¾ 

Beak Up
ÐÐ»ÑÐ² Ð²Ð²ÐµÑÑ

Beak Down
ÐÐ»ÑÐ² Ð²Ð½Ð¸Ð·

Tilt Left
ÐÐ°ÐºÐ»Ð¾Ð½ Ð²Ð»ÐµÐ²Ð¾

Tilt Right
ÐÐ°ÐºÐ»Ð¾Ð½ Ð²Ð¿ÑÐ°Ð²Ð¾

Level
Ð£ÑÐ¾Ð²ÐµÐ½Ñ

Upside Down
ÐÐ²ÐµÑÑ Ð´Ð½Ð¾Ð¼

x
X

y
Y

z
Z

strength
ÐÐ¾ÑÐ½Ð¾ÑÑÑ

####
# Ultrasound distance library

distance (cm) trigger _ echo _
ÑÐ°ÑÑÑÐ¾ÑÐ½Ð¸Ðµ (ÑÐ¼) ÑÑÐ¸Ð³Ð³ÐµÑÐ° _ ÑÑÐ¾ _

####
# Infrared remote library

IR Remote
ÐÐ-Ð¿ÑÐ»ÑÑ

receive IR code
Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ðµ ÐÐ-ÐºÐ¾Ð´Ð°

receive IR code from device _
Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ðµ ÐÐ-ÐºÐ¾Ð´Ð° Ñ ÑÑÑÑÐ¾Ð¹ÑÑÐ²Ð° _

test IR
Ð¿ÑÐ¾Ð²ÐµÑÐºÐ° ÐÐ

attach IR receiver to pin _
Ð¿Ð¾Ð´ÐºÐ»ÑÑÐ¸ÑÐµ ÐÐ-Ð¿ÑÐ¸ÐµÐ¼Ð½Ð¸Ðº Ðº ÐºÐ¾Ð½ÑÐ°ÐºÑÑ _

IR transmit device _ command _
--MISSING--

####
# Keyboard and Mouse

Keyboard and Mouse
ÐÐ»Ð°Ð²Ð¸Ð°ÑÑÑÐ° Ð¸ Ð¼ÑÑÑ

press key _ : while holding _
--MISSING--

hold key _
--MISSING--

release key _
--MISSING--

release all keys
--MISSING--

_ mouse click
--MISSING--

move mouse pointer by _ , _
--MISSING--

scroll mouse by _
--MISSING--

hold _ mouse button
--MISSING--

release mouse buttons
--MISSING--

####
# Radio comm library
# Allows micro:bit boards to exchange messages
# All of its blocks are primitive (see "Primitives" section)

Radio
Ð Ð°Ð´Ð¸Ð¾

####
# Text scrolling library
# Scrolls text on 5x5 LED displays and simulated ones

Scrolling
Ð¡ÐºÑÐ¾Ð»Ð»Ð¸Ð½Ð³

scroll text _
Ð¿ÑÐ¾ÐºÑÑÑÐºÐ° ÑÐµÐºÑÑÐ° _

HELLO ROSA!
HELLO ROSA!

scroll number _
Ð¿ÑÐ¾ÐºÑÑÑÐºÐ° ÑÐ¸ÑÐµÐ» _

pausing _ ms
Ð¿ÑÐ¸Ð¾ÑÑÐ°Ð½Ð¾Ð²ÐºÐ° _ Ð¼Ð»Ñ

stop scrolling
Ð¾ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð¿ÑÐ¾ÐºÑÑÑÐºÑ

####
# Servo motor library

Servo
CÐµÑÐ²Ð¾Ð¿ÑÐ¸Ð²Ð¾Ð´

set servo _ to _ degrees (-90 to 90)
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÑÐµÑÐ²Ð¾ _ Ð½Ð° _ Ð³ÑÐ°Ð´ÑÑÐ¾Ð² (Ð¾Ñ -90 Ð´Ð¾ 90)

set servo _ to speed _ (-100 to 100)
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÑÐµÑÐ²Ð¾ _ Ð½Ð° ÑÐºÐ¾ÑÐ¾ÑÑÑ _ (Ð¾Ñ -100 Ð´Ð¾ 100)

stop servo _
Ð¾ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÑÐµÑÐ²Ð¾Ð¿ÑÐ¸Ð²Ð¾Ð´

####
# 5x5 LED display library
# Supports the micro:bit display, but also simulated 5x5 displays on boards
# with differently sized LED arrays, NeoPixel arrays or TFT displays

LED Display
Ð¡Ð²ÐµÑÐ¾Ð´Ð¸Ð¾Ð´Ð½ÑÐ¹ Ð´Ð¸ÑÐ¿Ð»ÐµÐ¹

display _
ÑÐºÑÐ°Ð½ _

clear display
Ð¾ÑÐ¸ÑÑÐ¸ÑÑ ÑÐºÑÐ°Ð½

set display color _
Ð·Ð°Ð´Ð°ÑÑ ÑÐ²ÐµÑ ÑÐºÑÐ°Ð½Ð° _

plot x _ y _
Ð²ÑÑÐµÑÑÐ¸ÑÑ x _ y _

unplot x _ y _
ÑÐ±ÑÐ°ÑÑ ÑÐµÑÑÐµÐ½Ð¸Ðµ x _ y _

display character _
Ð¾ÑÐ¾Ð±ÑÐ°Ð¶Ð°ÑÑ ÑÐ¸Ð¼Ð²Ð¾Ð» _

####
# OLED Graphics library

initialize i2c _ address(hex) _ reset pin# _ flip _
Ð¸Ð½Ð¸ÑÐ¸Ð°Ð»Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°ÑÑ i2c _ Ð°Ð´ÑÐµÑ(hex) _ ÐºÐ¾Ð½ÑÐ°ÐºÑ ÑÐ±ÑÐ¾ÑÐ°# _ Ð¿ÐµÑÐµÐ²ÐµÑÐ½ÑÑÑ _

initialize spi _ d/c pin# _ reset pin# _ flip _
Ð¸Ð½Ð¸ÑÐ¸Ð°Ð»Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°ÑÑ spi _ ÐºÐ¾Ð½ÑÐ°ÐºÑ Ð´Ð°Ð½Ð½ÑÑ# _ ÐºÐ¾Ð½ÑÐ°ÐºÑ ÑÐ±ÑÐ¾ÑÐ°# _ Ð¿ÐµÑÐµÐ²ÐµÑÐ½ÑÑÑ _

write _ at x _ y _ inverse _
Ð¿Ð¸ÑÐ°ÑÑ ÑÐµÐºÑÑ _ Ð² x _ y _ Ð¸Ð½Ð²ÐµÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑ _

show display buffer
Ð¿Ð¾ÐºÐ°Ð·Ð°ÑÑ Ð±ÑÑÐµÑ ÑÐºÑÐ°Ð½Ð°

clear
Ð¾ÑÐ¸ÑÑÐ¸ÑÑ

set contrast (1-4) _
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÐºÐ¾Ð½ÑÑÐ°ÑÑ (1-4) _

draw circle at x _ y _ radius _ erase _
ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÐºÑÑÐ³ Ð² x _ y _ ÑÐ°Ð´Ð¸ÑÑ _ ÑÑÐµÑÐµÑÑ _

draw image _ at x _ y _
ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ _ Ð² x _ y _

draw line from x _ y _ to x _ y _ erase _
ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð»Ð¸Ð½Ð¸Ñ Ð¾Ñ x _ y _ Ðº x _ y _ ÑÑÐµÑÐµÑÑ _

draw rectangle x _ y _ w _ h _ erase _ rounding(3-15) _
ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð¿ÑÑÐ¼Ð¾ÑÐ³Ð¾Ð»ÑÐ½Ð¸Ðº x _ y _ ÑÐ¸Ñ _ Ð²ÑÑ _ ÑÑÐµÑÐµÑÑ _ ÑÐºÑÑÐ³Ð»ÐµÐ½Ð¸Ðµ(3-15) _

fill rectangle x _ y _ w _ h _ erase _
Ð·Ð°Ð¿Ð¾Ð»Ð½Ð¸ÑÑ Ð¿ÑÑÐ¼Ð¾ÑÐ³Ð¾Ð»ÑÐ½Ð¸Ðº x _ y _ ÑÐ¸Ñ _ Ð²ÑÑ _ ÑÑÐµÑÐµÑÑ _

_flip display top _
_Ð¿ÐµÑÐµÐ²ÐµÑÐ½ÑÑÑ ÑÐºÑÐ°Ð½ _

make image _
ÑÐ¾Ð·Ð´Ð°ÑÑ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ _

set pixel x _ y _ erase _
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÑÐ¾ÑÐºÑ x _ y _ ÑÑÐµÑÐµÑÑ _

set video _
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÑÐµÐ¶Ð¸Ð¼ Ð¾ÑÐ¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ _

cursor location
Ð¿Ð¾Ð·Ð¸ÑÐ¸Ñ ÐºÑÑÑÐ¾ÑÐ°

defer display updates
Ð¾ÑÐ»Ð¾Ð¶Ð¸ÑÑ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ ÑÐºÑÐ°Ð½Ð°

####
# TFT display library

enable TFT _
Ð²ÐºÐ»ÑÑÐ¸ÑÑ TFT _

TFT width
Ð¨Ð¸ÑÐ¸Ð½Ð° TFT

TFT height
ÐÑÑÐ¾ÑÐ° TFT

set TFT pixel x _ y _ to _
Ð·Ð°Ð´Ð°ÑÑ Ð¿Ð¸ÐºÑÐµÐ»Ð¸ TFT x _ y _ Ð½Ð° _

draw line on TFT from x _ y _ to x _ y _ color _
Ð½Ð°ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð»Ð¸Ð½Ð¸Ñ Ð½Ð° TFT Ð¾Ñ x _ y _ Ð´Ð¾ x _ y _ color _

draw rectangle on TFT at x _ y _ width _ height _ color _
Ð½Ð°ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð¿ÑÑÐ¼Ð¾ÑÐ³Ð¾Ð»ÑÐ½Ð¸Ðº Ð½Ð° TFT Ð¿ÑÐ¸ x _ y _ ÑÐ¸ÑÐ¸Ð½Ð° _ Ð²ÑÑÐ¾ÑÐ° _ ÑÐ²ÐµÑ _

draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _
Ð½Ð°ÑÐ¸Ñjdfnm Ð¿ÑÑÐ¼Ð¾ÑÐ³Ð¾Ð»ÑÐ½Ð¸Ðº Ñ Ð·Ð°ÐºÑÑÐ³Ð»ÐµÐ½Ð½ÑÐ¼Ð¸ ÑÐ³Ð»Ð°Ð¼Ð¸ Ð½Ð° TFT Ð¿ÑÐ¸ x _ y _ ÑÐ¸ÑÐ¸Ð½Ð° _ Ð²ÑÑÐ¾ÑÐ° _ ÑÐ°Ð´Ð¸ÑÑ _ ÑÐ²ÐµÑ _

draw circle on TFT at x _ y _ radius _ color _
Ð½Ð°ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÐºÑÑÐ³ Ð½Ð° TFT Ð² x _ y _ ÑÐ°Ð´Ð¸ÑÑ _ ÑÐ²ÐµÑ _

draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _
Ð½Ð°ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸Ðº Ð½Ð° TFT Ð² x _ y _, x _ y _, x _ y _ color _

filled _
Ð·Ð°Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¾ _

write _ on TFT at x _ y _ color _
Ð·Ð°Ð¿Ð¸ÑÐ°ÑÑ _ Ð½Ð° TFT Ð² Ñ _ Ñ _ ÑÐ²ÐµÑ _

Hello World!
Hello World!

scale _ wrap _
Ð¼Ð°ÑÑÑÐ°Ð± _ Ð¿ÐµÑÐµÐ½ÐµÑÑÐ¸ _

####
# BMP library
# Can display BMP image files on a TFT display

display BMP file _ at x _ y _
Ð¾ÑÐ¾Ð±ÑÐ°Ð·Ð¸ÑÑ BMP-ÑÐ°Ð¹Ð» _ Ð½Ð° x _ y _

image.bmp
image.bmp

####
# HSV color library

HSV Colors
HSV Ð¦Ð²ÐµÑ

RGB of hue _ saturation _ brightness _ (0-100)
RGB Ð¸Ð· hue _ saturation _ brightness _ (0-100)

####
# Fractions library

Fractions
ÐÑÐ¾Ð±Ð¸

fract _ / _
Ð´ÑÐ¾Ð±Ñ _ / _

fract _ + _
Ð´ÑÐ¾Ð±Ñ _ + _

fract _ - _
Ð´ÑÐ¾Ð±Ñ _ - _

fract _ Ã _
Ð´ÑÐ¾Ð±Ñ _ Ã _

fract _ = _
Ð´ÑÐ¾Ð±Ñ _ = _

fract _ < _
Ð´ÑÐ¾Ð±Ñ _ < _

fract _ > _
Ð´ÑÐ¾Ð±Ñ _ > _

simplify fraction _
ÑÐ¿ÑÐ¾ÑÑÐ¸ÑÑ Ð´ÑÐ¾Ð±Ñ _

integer part of fraction _
ÑÐµÐ»Ð°Ñ ÑÐ°ÑÑÑ Ð´ÑÐ¾Ð±Ð¸ _

numerator of fraction _
ÑÐ¸ÑÐ»Ð¸ÑÐµÐ»Ñ Ð´ÑÐ¾Ð±Ð¸ _

denominator of fraction _
Ð·Ð½Ð°Ð¼ÐµÐ½Ð°ÑÐµÐ»Ñ Ð´ÑÐ¾Ð±Ð¸ _

gcd _ _
ÐÐÐ _ _

lcm _ _
ÐÐÐ _ _

####
# Tone library
# Generates music tones on buzzers

Tone
Ð¢Ð¾Ð½

attach buzzer to pin _
Ð¿Ð¾Ð´ÐºÐ»ÑÑÐ¸ÑÑ Ð·ÑÐ¼Ð¼ÐµÑ Ðº ÐºÐ¾Ð½ÑÐ°ÐºÑÑ _

play note _ octave _ for _ ms
Ð²Ð¾ÑÐ¿ÑÐ¾Ð¸Ð·Ð²ÐµÑÑÐ¸ Ð½Ð¾ÑÑ _ Ð¾ÐºÑÐ°Ð²Ñ _ Ð½Ð° Ð¿ÑÐ¾ÑÑÐ¶ÐµÐ½Ð¸Ð¸ _ Ð¼Ñ

play frequency _ for _ ms
ÑÐ°ÑÑÐ¾ÑÐ° Ð²Ð¾ÑÐ¿ÑÐ¾Ð¸Ð·Ð²ÐµÐ´ÐµÐ½Ð¸Ñ _ Ð² ÑÐµÑÐµÐ½Ð¸Ðµ _ Ð¼Ñ

play midi key _ for _ ms
Ð²Ð¾ÑÐ¿ÑÐ¾Ð¸Ð·Ð²ÐµÑÑÐ¸ ÐºÐ»Ð°Ð²Ð¸ÑÑ midi _ Ð² ÑÐµÑÐµÐ½Ð¸Ðµ _ Ð¼Ñ

start tone _ Hz
Ð½Ð°ÑÐ°ÑÑ Ð·Ð²ÑÐº Ð½Ð° ÑÐ°ÑÑÐ¾ÑÐµ _ ÐÑ

stop tone
Ð¾ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð·Ð²ÑÐº

c
Ð´Ð¾ (c)

c#
Ð´Ð¾-Ð´Ð¸ÐµÐ· (c#)

d
ÑÐµ (d)

d#
ÑÐµ-Ð´Ð¸ÐµÐ· (d#)

e
Ð¼Ð¸ (e)

f
ÑÐ° (f)

f#
ÑÐ°-Ð´Ð¸ÐµÐ· (f#)

g
ÑÐ¾Ð»Ñ (g)

g#
ÑÐ¾Ð»Ñ-Ð´Ð¸ÐµÐ· (g#)

a
Ð»Ñ (a)

a#
Ð»Ñ-Ð´Ð¸ÐµÐ· (a#)

b
ÑÐ¸ (b)

####
# Ringtone library
# Can play Nokring-formatted music. Also known as RTTTL.

Ringtone
Ð Ð¸Ð½Ð³ÑÐ¾Ð½

play ringtone _
Ð²Ð¾ÑÐ¿ÑÐ¾Ð¸Ð·Ð²ÐµÑÑÐ¸ ÑÐ¸Ð½Ð³ÑÐ¾Ð½ _

current song name
ÑÐµÐºÑÑÐµÐµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð¼Ð¿Ð¾Ð·Ð¸ÑÐ¸Ð¸

####
# Pluck
# Generate music with plucked-string resembling sounds

Pluck
--MISSING--

pluck note _ octave _ for _ ms
--MISSING--

pluck MIDI key _ for _ msecs
--MISSING--

set pluck pin _
--MISSING--

####
# WAV
# Play WAV sound files

play WAV file _
--MISSING--

filename
--MISSING--

####
# Turtle geometry library

Turtle
Ð§ÐµÑÐµÐ¿Ð°ÑÐ°

home
Ð´Ð¾Ð¼Ð°ÑÐ½ÑÑ ÑÑÑÐ°Ð½Ð¸ÑÐ°

move _
Ð´Ð²Ð¸Ð³Ð°ÑÑ

turn _ degrees
Ð¿Ð¾Ð²Ð¾ÑÐ¾Ñ _ Ð³ÑÐ°Ð´ÑÑÐ¾Ð²

turn _ / _ of circle
Ð¿Ð¾Ð²Ð¾ÑÐ¾Ñ _ / _ ÐºÑÑÐ³

pen down
Ð¿ÐµÑÐ¾ Ð¾Ð¿ÑÑÑÐ¸ÑÑ

pen up
Ð¿Ð¾Ð´Ð½ÑÑÑ Ð¿ÐµÑÐ¾

set pen color to _
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÑÐ²ÐµÑ Ð¿ÐµÑÐ° Ð½Ð° _

set pen to random color
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÑÐ²ÐµÑ Ð¿ÐµÑÐ° Ð½Ð° ÑÐ»ÑÑÐ°Ð¹Ð½ÑÐ¹

fill display with _
Ð·Ð°Ð¿Ð¾Ð»Ð½Ð¸ÑÑ Ð´Ð¸ÑÐ¿Ð»ÐµÐ¹ Ñ _

go to x _ y _
Ð¿ÐµÑÐµÐ¹ÑÐ¸ Ðº Ñ _ Ñ _

point in direction _
ÑÐºÐ°Ð·Ð°ÑÑ Ð² Ð½Ð°Ð¿ÑÐ°Ð²Ð»ÐµÐ½Ð¸Ð¸ _

####
# File system library

Files
Ð¤Ð°Ð¹Ð»Ñ

open file _
Ð¾ÑÐºÑÑÑÑ ÑÐ°Ð¹Ð» _

close file _
Ð·Ð°ÐºÑÑÑÑ ÑÐ°Ð¹Ð» _

delete file _
ÑÐ´Ð°Ð»Ð¸ÑÑ ÑÐ°Ð¹Ð» _

append line _ to file _
Ð´Ð¾Ð±Ð°Ð²Ð¸ÑÑ ÑÑÑÐ¾ÐºÑ _ Ð² ÑÐ°Ð¹Ð» _

append bytes _ to file _
Ð´Ð¾Ð±Ð°Ð²Ð¸ÑÑ Ð±Ð°Ð¹ÑÑ _ Ð² ÑÐ°Ð¹Ð» _

end of file _
ÐºÐ¾Ð½ÐµÑ ÑÐ°Ð¹Ð»Ð° _

next line of file _
ÑÐ»ÐµÐ´ÑÑÑÐ°Ñ ÑÑÑÐ¾ÐºÐ° ÑÐ°Ð¹Ð»Ð° _

next _ bytes of file _
ÑÐ»ÐµÐ´ÑÑÑÐ¸Ðµ _ Ð±Ð°Ð¹ÑÑ ÑÐ°Ð¹Ð»Ð° _

read into _ from file _
--MISSING--

a ByteArray
--MISSING--

starting at _
Ð½Ð°ÑÐ¸Ð½Ð°ÐµÑÑÑ Ñ _

file names
Ð¸Ð¼ÐµÐ½Ð° ÑÐ°Ð¹Ð»Ð¾Ð²

in directory _
--MISSING--

size of file _
ÑÐ°Ð·Ð¼ÐµÑ ÑÐ°Ð¹Ð»Ð° _

file system info
Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ Ð¾ ÑÐ°Ð¹Ð»Ð¾Ð²Ð¾Ð¹ ÑÐ¸ÑÑÐµÐ¼Ðµ

####
# Strings
# string (text) processing functions

Strings
Ð¡ÑÑÐ¾ÐºÐ¸

_ is a digit
_ ÑÐ²Ð»ÑÐµÑÑÑ ÑÐ¸ÑÑÐ¾Ð¹

_ is lowercase
_ Ð² Ð½Ð¸Ð¶Ð½ÐµÐ¼ ÑÐµÐ³Ð¸ÑÑÑÐµ

_ is uppercase
_ Ð² Ð²ÐµÑÑÐ½ÐµÐ¼ ÑÐµÐ³Ð¸ÑÑÑÐµ

_ begins with _
_ Ð½Ð°ÑÐ¸Ð½Ð°ÐµÑÑÑ ÑÐ¾ ÑÑÑÐ¾ÐºÐ¸ _

prefix
Ð¿ÑÐµÑÐ¸ÐºÑ

pre
Ð¿ÑÐµ

_ ends with _
_ Ð·Ð°ÐºÐ°Ð½ÑÐ¸Ð²Ð°ÐµÑÑÑ ÑÑÑÐ¾ÐºÐ¾Ð¹ _

suffix
ÑÑÑÑÐ¸ÐºÑ

fix
ÑÐ¸ÐºÑ

_ contains _
_ ÑÐ¾Ð´ÐµÑÐ¶Ð¸Ñ ÑÑÑÐ¾ÐºÑ _

lowercase _
Ð² Ð½Ð¸Ð¶Ð½Ð¸Ð¹ ÑÐµÐ³Ð¸ÑÑÑ _

THIS is a String! :)
--MISSING--

uppercase _
Ð² Ð²ÐµÑÑÐ½Ð¸Ð¹ ÑÐµÐ³Ð¸ÑÑÑ _

Hello, world!
--MISSING--

_ without white space
_ Ð±ÐµÐ· Ð¿ÑÐ¾Ð±ÐµÐ»Ð¾Ð²

join string list _ separator _
ÑÐ¾ÐµÐ´Ð¸Ð½Ð¸ÑÑ Ð¼Ð°ÑÑÐ¸Ð² ÑÑÑÐ¾Ðº _ ÑÐ°Ð·Ð´ÐµÐ»Ð¸ÑÐµÐ»ÐµÐ¼ _

unicodes _
--MISSING--

aString
--MISSING--

string from unicodes _
--MISSING--

aList
--MISSING--

num2str _
--MISSING--

str2num _
--MISSING--

####
# WiFi library

WiFi
WiFi

wifi connect to _ password _
--MISSING--

Network_Name
--MISSING--

IP _ gateway _ subnet _
--MISSING--

wifi create hotspot _ password _
Wi-Fi ÑÐ¾Ð·Ð´Ð°ÑÑ ÑÐ¾ÑÐºÑ Ð´Ð¾ÑÑÑÐ¿Ð° _ Ð¿Ð°ÑÐ¾Ð»Ñ _

Network_Password
--MISSING--

IP address
IP Ð°Ð´ÑÐµÑÑ

MAC address
--MISSING--

####
# Motion library
# Counts steps and detects motion via the internal accelerometer

Motion
ÐÐ²Ð¸Ð¶ÐµÐ½Ð¸Ðµ

motion
Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ðµ

start step counter
Ð·Ð°Ð¿ÑÑÐº ÑÑÐµÑÑÐ¸Ðº ÑÐ°Ð³Ð¾Ð¼ÐµÑÐ°

step count
ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ ÑÐ°Ð³Ð¾Ð²

clear step count
Ð¾ÑÐ¸ÑÑÐ¸ÑÑ ÑÑÐµÑÑÐ¸Ðº ÑÐ°Ð³Ð¾Ð²

set step threshold _ (0-50)
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð¿Ð¾ÑÐ¾Ð³Ð¾Ð²Ð¾Ðµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ ÑÐ°Ð³Ð° _ (0-50)

####
# Button Events library

Button Events
Ð¡Ð¾Ð±ÑÑÐ¸Ñ ÐºÐ½Ð¾Ð¿ÐºÐ¸

button _ double pressed
ÐºÐ½Ð¾Ð¿ÐºÐ° _ Ð´Ð²Ð°Ð¶Ð´Ñ Ð½Ð°Ð¶Ð°ÑÐ°

button _ long pressed
Ð´Ð»Ð¸Ð½Ð½Ð¾Ðµ Ð½Ð°Ð¶Ð°ÑÐ¸Ðµ ÐºÐ½Ð¾Ð¿ÐºÐ¸

button _ pressed
ÐºÐ½Ð¾Ð¿ÐºÐ° _ Ð½Ð°Ð¶Ð°ÑÐ°

####
# Calliope board library

Calliope set LED red _ green _ blue _
Ð£ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÐºÐ°Ð»Ð»Ð¸Ð¾Ð¿Ð° LED ÐºÑÐ°ÑÐ½ÑÐ¹ _ Ð·ÐµÐ»ÐµÐ½ÑÐ¹ _ ÑÐ¸Ð½Ð¸Ð¹ _

Calliope set speaker _
ÐÐ°Ð»Ð»Ð¸Ð¾Ð¿Ð°

Calliope loudness
ÐÑÐ¾Ð¼ÐºÐ¾ÑÑÑ ÐÐ°Ð»Ð»Ð¸Ð¾Ð¿Ð°

####
# Circuit Playground Express board library

Circuit Playground set speaker _
Ð¡ÑÐµÐ¼Ð° Ð¸Ð³ÑÐ¾Ð²Ð¾Ð¹ Ð¿Ð»Ð¾ÑÐ°Ð´ÐºÐ¸ ÐºÐ¾Ð¼Ð¿Ð»ÐµÐºÑ Ð´Ð¸Ð½Ð°Ð¼Ð¸ÐºÐ¾Ð² _

Circuit Playground slide switch
Ð¡Ð»Ð°Ð¹Ð´-Ð¿ÐµÑÐµÐºÐ»ÑÑÐ°ÑÐµÐ»Ñ Circuit Playground

####
# DotStar LED library

attach _ DotStar LEDs to data pin _ clock pin _
Ð¿Ð¾Ð´ÐºÐ»ÑÑÐ¸ÑÑ _ ÑÐ²ÐµÑÐ¾Ð´Ð¸Ð¾Ð´Ñ DotStar Ðº ÐºÐ¾Ð½ÑÐ°ÐºÑÑ Ð´Ð°Ð½Ð½ÑÑ _ ÐºÐ¾Ð½ÑÐ°ÐºÑÑ ÑÐ¸Ð½ÑÑÐ¾Ð½Ð¸Ð·Ð°ÑÐ¸Ð¸ _

set all DotStar LEDs to r _ g _ b _
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð²ÑÐµ ÑÐ²ÐµÑÐ¾Ð´Ð¸Ð¾Ð´Ñ DotStar Ð½Ð° r _ g _ b _

set DotStar LED _ to r _ g _ b _
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÐµ DotStar LED _ Ð½Ð° r _ g _ b _

set DotStar brightness _
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÑÑÐºÐ¾ÑÑÑ DotStar _

####
# BME280 environmental sensor

bme280 connected
bme280 Ð¿Ð¾Ð´ÐºÐ»ÑÑÐµÐ½

bmp280 connected
bmp280 Ð¿Ð¾Ð´ÐºÐ»ÑÑÐµÐ½

bmx280 temperature
bmx280 ÑÐµÐ¼Ð¿ÐµÑÐ°ÑÑÑÐ°

bmx280 pressure
Ð´Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ BMX 280

bme280 humidity
Ð²Ð»Ð°Ð¶Ð½Ð¾ÑÑÑ bme280

bmx280 set base altitude _ meters
--MISSING--

bmx280 altitude (cm)
--MISSING--

bmx280 altitude (feet)
--MISSING--

####
# TCS34725 color sensor

TCS34725 connected
TCS34725 Ð¿Ð¾Ð´ÐºÐ»ÑÑÐµÐ½

TCS34725 rgb
TCS34725 rgb

color _ name
ÑÐ²ÐµÑ _ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ

####
# DHT11 environmental sensor

temperature (Celsius) DHT11 pin _
ÑÐµÐ¼Ð¿ÐµÑÐ°ÑÑÑÐ° (Ð¡) DHT11 pin _

humidity DHT11 pin _
Ð²Ð»Ð°Ð¶Ð½Ð¾ÑÑÑ DHT11 pin _

temperature (Celsius) DHT22 pin _
ÑÐµÐ¼Ð¿ÐµÑÐ°ÑÑÑÐ° (Ð¡) DHT22 pin _

humidity DHT22 pin _
Ð²Ð»Ð°Ð¶Ð½Ð¾ÑÑÑ DHT22 pin _

####
# PN532 RFID reader

read PN532 RFID
ÑÐ¸ÑÐ°ÑÑ PN532 RFID

RFID _ = _
RFID _ = _

get PN532 firmware version
Ð¿Ð¾Ð»ÑÑÐ¸ÑÑ Ð²ÐµÑÑÐ¸Ñ Ð¿ÑÐ¾ÑÐ¸Ð²ÐºÐ¸ PN532

####
# Touch Screen

Touch Screen
--MISSING--

TFT touched
--MISSING--

TFT touch X position
--MISSING--

TFT touch Y position
--MISSING--

TFT touch pressure
--MISSING--

####
# HTTP Client

HTTP client
HTTP-ÐºÐ»Ð¸ÐµÐ½Ñ

_ data _ to httpÜ// _
--MISSING--

MicroBlocks is fun
--MISSING--

port _
--MISSING--

####
# HTTP Server

HTTP server
HTTP ÑÐµÑÐ²ÐµÑ

start HTTP server
Ð·Ð°Ð¿ÑÑÑÐ¸ÑÑ HTTP-ÑÐµÑÐ²ÐµÑ

HTTP server request
HTTP-Ð·Ð°Ð¿ÑÐ¾Ñ ÑÐµÑÐ²ÐµÑÐ°

respond _ to HTTP request
Ð¾ÑÐ²ÐµÑÐ¸ÑÑ _ Ð½Ð° Ð·Ð°Ð¿ÑÐ¾Ñ HTTP

with body _
Ñ ÑÐµÐ»Ð¾Ð¼ _

Welcome to the MicroBlocks HTTP server
--MISSING--

and headers _
Ð¸ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²ÐºÐ¸

body of request _
ÑÐµÐ»Ð¾ Ð·Ð°Ð¿ÑÐ¾ÑÐ° _

path of request _
Ð¿ÑÑÑ Ð·Ð°Ð¿ÑÐ¾ÑÐ° _

headers of request _
--MISSING--

method of request _
Ð¼ÐµÑÐ¾Ð´ Ð·Ð°Ð¿ÑÐ¾ÑÐ° _

content length of request _
--MISSING--

####
# WebSocket server

WebSocket server
--MISSING--

start WebSocket server
--MISSING--

last WebSocket event
--MISSING--

client ID for WebSocket event _
--MISSING--

payload for WebSocket event _
--MISSING--

type of WebSocket event _
--MISSING--

send _ to WebSocket client _
--MISSING--

Hello, Client!
--MISSING--

####
# Web Things library

Web Thing
Web Thing

set thing name to _
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð¸Ð¼Ñ Ð²ÐµÑÐ¸ Ð½Ð° _

set thing capability to _
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ÑÑÑ Ð²ÐµÑÐ¸ Ð½Ð° _

set boolean property _ title _ @Type _
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð»Ð¾Ð³Ð¸ÑÐµÑÐºÐ¾Ðµ ÑÐ²Ð¾Ð¹ÑÑÐ²Ð¾ _ title _ @Type _

set string property _ title _ @Type _
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÑÑÑÐ¾ÐºÐ¾Ð²Ð¾Ðµ ÑÐ²Ð¾Ð¹ÑÑÐ²Ð¾ _ title _ @Type _

set number property _ title _ @Type _
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð½Ð¾Ð¼ÐµÑ ÑÐ²Ð¾Ð¹ÑÑÐ²Ð° _ title _ @Type _

set number property _ title _ min _ max _ @Type _
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð½Ð¾Ð¼ÐµÑ ÑÐ²Ð¾Ð¹ÑÑÐ²Ð° _ title _ min _ max _ @Type _

read only _
ÑÐ¾Ð»ÑÐºÐ¾ Ð´Ð»Ñ ÑÑÐµÐ½Ð¸Ñ _

register event _ type _
Ð·Ð°ÑÐµÐ³Ð¸ÑÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÐ¾Ð±ÑÑÐ¸Ðµ _ ÑÐ¸Ð¿ _

start WebThing server
Ð·Ð°Ð¿ÑÑÑÐ¸ÑÑ ÑÐµÑÐ²ÐµÑ WebThing

trigger event _
Ð²ÑÐ·Ð²Ð°ÑÑ ÑÐ¾Ð±ÑÑÐ¸Ðµ _

thing description JSON
Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð²ÐµÑÐ¸ JSON

properties JSON
ÑÐ²Ð¾Ð¹ÑÑÐ²Ð° JSON

event definitions JSON
Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ ÑÐ¾Ð±ÑÑÐ¸Ð¹ JSON

events JSON
ÑÐ¾Ð±ÑÑÐ¸Ñ JSON

####
# MiKe Robot library

MiKe front obstacle (cm)
--MISSING--

MiKe _ obstacle ?
--MISSING--

MiKe black line on _ ?
--MISSING--

MiKe back light
--MISSING--

MiKe IR
--MISSING--

MiKe digital D8 sensor
--MISSING--

MiKe stop motors
--MISSING--

MiKe Robot go _ at _ %
--MISSING--

MiKe Robot speed _ %
--MISSING--

MiKe Robot direction _
--MISSING--

MiKe turn _ motor _
--MISSING--

MiKe speed _ motor at _ %
--MISSING--

MiKe front lights off
--MISSING--

MiKe front lights to _
--MISSING--

MiKe circle lights off
--MISSING--

MiKe circle ligths to _
--MISSING--

MiKe circle light _ (1-18) to _
--MISSING--

MiKe rotate lights by _
--MISSING--

MiKe digital D8 to _
--MISSING--

####
# DrawBot Library
# A CoreXY plotter library that supports turtle geometry

plotter move X _ Y _
--MISSING--

plotter move _ steps
--MISSING--

plotter turn _ degrees
--MISSING--

plotter turn _ / _ of circle
--MISSING--

plotter point in direction _
--MISSING--

plotter pen down
--MISSING--

plotter pen up
--MISSING--

plotter stop
--MISSING--

set plotter speed to _ %
--MISSING--

####
# Innova Didactic libraries

red
--MISSING--

yellow
--MISSING--

green
--MISSING--

forward
--MISSING--

backward
--MISSING--

turn right
--MISSING--

turn left
--MISSING--

stop
--MISSING--

right sensor
--MISSING--

left sensor
--MISSING--

both sensors
--MISSING--

TdR test buzzer
--MISSING--

TdR set blue LED _
--MISSING--

TdR set red LED _
--MISSING--

TdR set RGB LED _
--MISSING--

TdR clear RGB LED
--MISSING--

TdR LM35 temperature ÂºC
--MISSING--

TdR DHT11 temperature ÂºC
--MISSING--

TdR DHT11 humidity
--MISSING--

TdR rotation
--MISSING--

TdR light level
--MISSING--

TdR button 1
--MISSING--

TdR button 2
--MISSING--

TdR receive IR code
--MISSING--

Imagina set _ led to _
--MISSING--

Imagina play _ octave _ for _ ms
--MISSING--

Imagina temperature (Â°C)
--MISSING--

Imagina light
--MISSING--

Imagina distance (cm)
--MISSING--

Imagina button (D2) pressed?
--MISSING--

Imagina digital reading _
--MISSING--

Imagina analog reading A1
--MISSING--

Imagina set digital pin _ to _
--MISSING--

Imagina stop servo _
--MISSING--

Imagina set servo _ to _ degrees (-90 to 90)
--MISSING--

Imagina set servo _ to speed _ (-100 to 100)
--MISSING--

Imagina set _ speed to _ %
--MISSING--

Imagina set _ to _
--MISSING--

Imagina IR reading
--MISSING--

Imagina IR transmit device _ command _
--MISSING--

_ steps
--MISSING--

at _ % speed
--MISSING--

3dBot set speed at _ %
--MISSING--

3dBot obstacle < _ cm?
--MISSING--

3dBot line on _ ?
--MISSING--

####
# MQTT

MQTT connect to broker _
--MISSING--

buffer sizes _ client id _
--MISSING--

username _ password _
--MISSING--

MQTT connected
--MISSING--

MQTT disconnect
--MISSING--

MQTT sub _
--MISSING--

testTopic
--MISSING--

MQTT unsub _
--MISSING--

MQTT pub topic _ payload _
--MISSING--

Hello!
--MISSING--

retain _ QoS _
--MISSING--

MQTT event
--MISSING--

binary _
--MISSING--

topic for MQTT event _
--MISSING--

payload for MQTT event _
--MISSING--

MQTT set will topic _ payload _
--MISSING--

testWill
--MISSING--

Last will!
--MISSING--

buffer sizes _
--MISSING--

####
# UDP

UDP start port _
--MISSING--

UDP stop
--MISSING--

UDP send packet _ to ip _ port _
--MISSING--

UDP receive packet
--MISSING--

binary data _
--MISSING--

UDP remote IP address
--MISSING--

UDP remote port
--MISSING--

####
# Cutebot

Cutebot
--MISSING--

Cutebot set wheel left _ right _ (-100 to 100)
--MISSING--

Cutebot stop wheels
--MISSING--

Cutebot set servo _ to _ degrees (-90 to 90)
--MISSING--

Cutebot set servo _ to speed _ (-100 to 100)
--MISSING--

Cutebot set headlight _ to _
--MISSING--

Cutebot set NeoPixel _ to _
--MISSING--

Cutebot _ line sensor
--MISSING--

Cutebot sees line on left _ right _
--MISSING--

Cutebot distance (cm)
--MISSING--

left
--MISSING--

right
--MISSING--

both
--MISSING--

# Wukong

Wukong
--MISSING--

Wukong set motor _ to _ (-100 to 100)
--MISSING--

Wukong stop motor _
--MISSING--

Wukong stop all
--MISSING--

Wukong set servo _ to _ degrees (-90 to 90)
--MISSING--

Wukong set servo _ to speed _ (-100 to 100)
--MISSING--

Wukong set NeoPixels _ _ _ _
--MISSING--

Wukong set LED brightness to _
--MISSING--

####
# Sphero-RVR

wake
--MISSING--

sleep
--MISSING--

reset the yaw
--MISSING--

drive with speed _ and heading _
--MISSING--

set raw motors with left mode _ left speed _ right mode _ right speed _
--MISSING--

stop with heading _
--MISSING--

set RGB LED _ to red _ green _ blue _
--MISSING--

set all LEDs to red _ green _ blue _
--MISSING--

####
# Joystick:bit

button _ is pressed
--MISSING--

rocker value of _
--MISSING--

motor vibrate for _ ms
--MISSING--

####
# NeZha

NeZha
--MISSING--

NeZha set motor _ speed to _ %
--MISSING--

NeZha stop motor _
--MISSING--

NeZha stop all motors
--MISSING--

NeZha set _ servo _ angle to _
--MISSING--

NeZha set continuous rotation servo _ speed to _ %
--MISSING--

####
# WuKong2040

WuKong2040
--MISSING--

WuKong2040 rainbowLED _ color to _
--MISSING--

WuKong2040 rainbowLED _ R _ G _ B _ (0~255)
--MISSING--

WuKong2040 clear all rainbowLED
--MISSING--

WuKong2040 motor _ speed to _ (-100~100)
--MISSING--

WuKong2040 stop motor _
--MISSING--

WuKong2040 stop all motors
--MISSING--

WuKong2040 buzzer beep _ ms
--MISSING--

####
# Octopus

Octopus
--MISSING--

Octopus LED pin _ toggle to _
--MISSING--

Octopus LED pin _ brightness _ %
--MISSING--

Octopus motor fan pin _ speed to _ %
--MISSING--

Octopus 180Â° servo pin _ angle to _ Â° (0~180)
--MISSING--

Octopus sonar trig _ echo _ distance (cm)
--MISSING--

Octopus value of light intensity (Lux) at pin _
--MISSING--

Octopus value of DHT11 temperature (Â°C) at pin _
--MISSING--

Octopus value of DHT11 humidity (0~100) at pin _
--MISSING--

Octopus value of water level (0~40mm) at pin _
--MISSING--

Octopus value of trimpot (0~1023) at pin _
--MISSING--

Octopus value of noise (dB) at pin _
--MISSING--

Octopus OLED show _ at x _ y _
--MISSING--

Octopus OLED clear
--MISSING--

Octopus OLED draw pixel x _ y _
--MISSING--

Octopus OLED draw line from x _ y _ to x _ y _
--MISSING--

Octopus OLED draw rectangle x _ y _ w _ h _ rounding _ (3~15)
--MISSING--

Octopus OLED fill rectangle x _ y _ w _ h _
--MISSING--

Octopus OLED draw circle x _ y _ radius _
--MISSING--

Octopus OLED fill circle x _ y _ radius _
--MISSING--


##################
# MicroBlocks UI #
##################

# buttons, error & info messages, dialog boxes, etc

New
ÐÐ¾Ð²ÑÐ¹

Open
ÐÑÐºÑÑÑÑ

Open from board
ÐÑÐºÑÑÑÑ Ð¸Ð· Ð¿Ð»Ð°ÑÑ

Copy project URL to clipboard
--MISSING--

Information
ÐÐ½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ

Plug in the board.
ÐÐ¾Ð´ÐºÐ»ÑÑÐ¸ÑÑ Ð¿Ð»Ð°ÑÑ

Plug in the board and click the USB icon to connect.
--MISSING--

Reading project from board...
ÐÐ°Ð³ÑÑÐ·Ð¸ÑÑ Ð¿ÑÐ¾ÐµÐºÑ Ñ Ð¿Ð»Ð°ÑÑ

Loading project...
ÐÑÐ¾ÐµÐºÑ Ð·Ð°Ð³ÑÑÐ¶Ð°ÐµÑÑÑ...

Found a newer version of
--MISSING--

Do you want me to update the one in the project?
ÐÑ ÑÐ¾ÑÐ¸ÑÐµ, ÑÑÐ¾Ð±Ñ Ñ Ð¾Ð±Ð½Ð¾Ð²Ð¸Ð» ÑÑÐ¾ Ð² Ð¿ÑÐ¾ÐµÐºÑÐµ?

Save
Ð¡Ð¾ÑÑÐ°Ð½Ð¸ÑÑ

Connect
ÐÐ¾Ð´ÐºÐ»ÑÑÐ¸ÑÑ

connect
--MISSING--

open Boardie
--MISSING--

disconnect
Ð¾ÑÐºÐ»ÑÑÐ¸ÑÑ

Serial port:
Ð¡ÐµÑÐ¸Ð¹Ð½ÑÐ¹ Ð¿Ð¾ÑÑ:

other...
Ð´ÑÑÐ³Ð¸Ðµ...

none
Ð½Ð¸ÐºÐ°ÐºÐ¾Ð¹

Port name?
ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¿Ð¾ÑÑÐ°?

Board type:
Ð¢Ð¸Ð¿ Ð¿Ð»Ð°ÑÑ:

Select board:
ÐÑÐ±ÐµÑÐ¸ÑÐµ Ð¿Ð»Ð°ÑÑ:

Could not read:
ÐÐµ ÑÐ´Ð°ÑÑÑÑ Ð¿ÑÐ¾ÑÐ¸ÑÐ°ÑÑ:

by
Ð¿Ð¾

Created with GP
Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¾ Ñ Ð¿Ð¾Ð¼Ð¾ÑÑÑ GP

More info at http://microblocks.fun
ÐÐ¾Ð´ÑÐ¾Ð±Ð½ÐµÐµ: http://microblocks.fun

Function "
Ð¤ÑÐ½ÐºÑÐ¸Ñ "

" is too large to send to board.
" ÑÐ»Ð¸ÑÐºÐ¾Ð¼ Ð±Ð¾Ð»ÑÑÐ°Ñ Ð´Ð»Ñ Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ¸ Ð½Ð° Ð¿Ð»Ð°ÑÑ.

Script is too large to send to board.
Ð¡ÐºÑÐ¸Ð¿Ñ ÑÐ»Ð¸ÑÐºÐ¾Ð¼ Ð±Ð¾Ð»ÑÑÐ¾Ð¹ Ð´Ð»Ñ Ð¾ÑÐ¿ÑÐ°Ð²ÐºÐ¸ Ð½Ð° Ð¿Ð»Ð°ÑÑ.

Use "Connect" button to connect to a MicroBlocks device.
ÐÑÐ¿Ð¾Ð»ÑÐ·ÑÐ¹ÑÐµ ÐºÐ½Ð¾Ð¿ÐºÑ "ÐÐ¾Ð´ÐºÐ»ÑÑÐ¸ÑÑ" Ð´Ð»Ñ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ñ Ñ ÑÑÑÑÐ¾Ð¹ÑÑÐ²Ð¾Ð¼ MicroBlocks.

No boards found; is your board plugged in?
ÐÐ»Ð°Ñ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾. ÐÑ ÑÐ²ÐµÑÐµÐ½Ñ, ÑÑÐ¾ Ð¿Ð»Ð°ÑÐ° Ð¿Ð¾Ð´ÐºÐ»ÑÑÐµÐ½Ð°?

For AdaFruit boards, double-click reset button and try again.
ÐÐ»Ñ Ð¿Ð»Ð°Ñ AdaFruit, Ð¿Ð¾Ð¿ÑÐ¾Ð±ÑÐ¹ÑÐµ Ð´Ð²Ð°Ð¶Ð´Ñ Ð½Ð°Ð¶Ð°ÑÑ ÐºÐ½Ð¾Ð¿ÐºÑ ÑÐ±ÑÐ¾ÑÐ° Ð¸ Ð¿Ð¾Ð¿ÑÐ¾Ð±Ð¾Ð²Ð°ÑÑ ÑÐ½Ð¾Ð²Ð°.

Only recent Chrome and Edge browsers support WebSerial.
--MISSING--

The board is not responding.
ÐÐ»Ð°ÑÐ° Ð½Ðµ Ð¾ÑÐ²ÐµÑÐ°ÐµÑ.

Try to Install MicroBlocks on the board?
ÐÐ¾Ð¿ÑÐ¾Ð±ÑÐ¹ÑÐµ ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ MicroBlocks Ð½Ð° Ð¿Ð»Ð°ÑÑ.

The MicroBlocks in your board is not current
MicroBlocks Ð½Ð° Ð²Ð°ÑÐµÐ¹ Ð¿Ð»Ð°ÑÐµ ÑÑÑÐ°ÑÐµÐ²ÑÐ°Ñ

Try to update MicroBlocks on the board?
ÐÐ¾Ð¿ÑÐ¾Ð±ÑÐ¹ÑÐµ Ð¾Ð±Ð½Ð¾Ð²Ð¸ÑÑ MicroBlocks Ð½Ð° Ð¿Ð»Ð°ÑÐµ?

MicroBlocks
--MISSING--

Stop
Ð¡ÑÐ¾Ð¿

Start
Ð¡ÑÐ°ÑÑ

Quit MicroBlocks?
ÐÑÐ¹ÑÐ¸ Ð¸Ð· MicroBlocks?

Discard current project?
ÐÑÐ¼ÐµÐ½Ð¸ÑÑ ÑÑÐ¾Ñ Ð¿ÑÐ¾ÐµÐºÑ?

# Scripting area right-click context menu

set block size...
--MISSING--

make blocks bigger or smaller
--MISSING--

clean up
Ð¾ÑÐ¸ÑÑÐ¸ÑÑ

arrange scripts
ÑÐ°ÑÐ¿Ð¾Ð»Ð¾Ð¶Ð¸ÑÑ ÑÐºÑÐ¸Ð¿ÑÑ

undrop (ctrl-Z)
Ð¾ÑÐ¼ÐµÐ½Ð¸ÑÑ (Ctrl-Z)

undo the last block drop
--MISSING--

copy all scripts to clipboard
ÑÐºÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°ÑÑ Ð²ÑÐµ ÑÐºÑÐ¸Ð¿ÑÑ Ð² Ð±ÑÑÐµÑ Ð¾Ð±Ð¼ÐµÐ½Ð°

copy all scripts to clipboard as URL
--MISSING--

paste all scripts
Ð²ÑÑÐ°Ð²Ð¸ÑÑ Ð²ÑÐµ ÑÐºÑÐ¸Ð¿ÑÑ

paste script
Ð²ÑÑÐ°Ð²Ð¸ÑÑ ÑÐºÑÐ¸Ð¿Ñ

paste script from clipboard
--MISSING--

save a picture of all visible scripts
--MISSING--

set exported script scale
--MISSING--

small (50%)
--MISSING--

normal (65%)
--MISSING--

large (100%)
--MISSING--

printable (200%)
--MISSING--

about...
Ð¾...

About MicroBlocks
--MISSING--

virtual machine version
Ð²ÐµÑÑÐ¸Ñ Ð²Ð¸ÑÑÑÐ°Ð»ÑÐ½Ð¾Ð¹ Ð¼Ð°ÑÐ¸Ð½Ñ

update firmware on board
Ð¾Ð±Ð½Ð¾Ð²Ð¸ÑÑ Ð¿ÑÐ¾ÑÐ¸Ð²ÐºÑ Ð¿Ð»Ð°ÑÑ

show data graph
Ð¿Ð¾ÐºÐ°Ð·Ð°ÑÑ Ð³ÑÐ°ÑÐ¸Ðº Ð´Ð°Ð½Ð½ÑÑ

set serial delay
ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÑÐµÑÐ¸Ð¹Ð½ÑÑ Ð·Ð°Ð´ÐµÑÐ¶ÐºÑ

firmware version
Ð²ÐµÑÑÐ¸Ñ Ð¿ÑÐ¾ÑÐ¸Ð²ÐºÐ¸

start WebThing server
Ð·Ð°Ð¿ÑÑÑÐ¸ÑÑ ÑÐµÑÐ²ÐµÑ WebThing

stop WebThing server
Ð¾ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÑÐµÑÐ²ÐµÑ WebThing

HTTP Server
HTTP Ð¡ÐµÑÐ²ÐµÑ

MicroBlocks HTTP Server listening on port 6473
HTTP-ÑÐµÑÐ²ÐµÑ MicroBlocks Ð¿ÑÐ¾ÑÐ»ÑÑÐ¸Ð²Ð°ÐµÑ Ð¿Ð¾ÑÑ 6473

disable autoloading board libraries
Ð¾ÑÐºÐ»ÑÑÐ¸ÑÑ Ð°Ð²ÑÐ¾Ð·Ð°Ð³ÑÑÐ·ÐºÑ Ð±Ð¸Ð±Ð»Ð¸Ð¾ÑÐµÐº Ð¿Ð»Ð°ÑÑ

enable autoloading board libraries
Ð²ÐºÐ»ÑÑÐ¸ÑÑ Ð°Ð²ÑÐ¾Ð·Ð°Ð³ÑÑÐ·ÐºÑ Ð±Ð¸Ð±Ð»Ð¸Ð¾ÑÐµÐº Ð¿Ð»Ð°ÑÑ

enable PlugShare when project empty
Ð²ÐºÐ»ÑÑÐ¸ÑÑ PlugShare ÐºÐ¾Ð³Ð´Ð° Ð¿ÑÐ¾ÐµÐºÑ Ð¿ÑÑÑ

disable PlugShare when project empty
ÐÑÐºÐ»ÑÑÐ¸ÑÑ PlugShare ÐºÐ¾Ð³Ð´Ð° Ð¿ÑÐ¾ÐµÐºÑ Ð¿ÑÑÑ

when plugging a board, do not automatically read its contents into the IDE even if the current project is empty
--MISSING--

when plugging a board, automatically read its contents into the IDE if the current project is empty
--MISSING--

erase flash and update firmware on ESP board
ÑÑÐµÑÐµÑÑ Ð¸ Ð¿ÐµÑÐµÐ´ÐµÐ»Ð¸ÑÑ esp

Use board type
ÐÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÑÐ¸Ð¿ Ð¿Ð»Ð°ÑÑ

Firmware Installed
--MISSING--

Reconnect to the board by clicking the "Connect" button (USB icon).
--MISSING--

Connect USB cable while holding down the white BOOTSEL button before proceeding.
--MISSING--

You will be asked to save the firmware file.
--MISSING--

Select
--MISSING--

as the destination drive, then click Save.
--MISSING--

Installing firmware...
--MISSING--

Plug in the board.
ÐÐ¾Ð´ÐºÐ»ÑÑÐ¸ÑÑ Ð¿Ð»Ð°ÑÑ

Wiping board...
Ð¡ÑÐ°ÑÐ°Ð½Ð¸Ðµ Ð¿Ð»Ð°ÑÑ...

(press ESC to cancel)
(Ð½Ð°Ð¶Ð¼Ð¸ÑÐµ ESC Ð´Ð»Ñ Ð¾ÑÐ¼ÐµÐ½Ñ)

Done!
ÐÐ¾ÑÐ¾Ð²Ð¾!

download and install latest VM
ÑÐºÐ°ÑÐ°ÑÑ Ð¸ ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÑÑ Ð²ÐµÑÑÐ¸Ñ Ð²Ð¸ÑÑÑÐ°Ð»ÑÐ½Ð¾Ð¹ Ð¼Ð°ÑÐ¸Ð½Ñ

Select board type:
ÐÑÐ±ÐµÑÐ¸ÑÐµ ÑÐ¸Ð¿ Ð¿Ð»Ð°ÑÑ:

Uploading MicroBlocks to board...
MicroBlocks Ð·Ð°Ð³ÑÑÐ¶Ð°ÐµÑÑÑ Ð½Ð° Ð¿Ð»Ð°ÑÑ...

copy data to clipboard
ÐºÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°ÑÑ Ð´Ð°Ð½Ð½ÑÐµ Ð² Ð±ÑÑÐµÑ Ð¾Ð±Ð¼ÐµÐ½Ð°

clear data
Ð¾ÑÐ¸ÑÑÐ¸ÑÑ Ð´Ð°Ð½Ð½ÑÐµ

clear memory and variables
Ð¾ÑÐ¸ÑÑÐ¸ÑÑ Ð¿Ð°Ð¼ÑÑÑ Ð¸ Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½ÑÐµ

show advanced blocks
Ð¿Ð¾ÐºÐ°Ð·Ð°ÑÑ ÑÐ°ÑÑÐ¸ÑÐµÐ½Ð½ÑÐµ Ð±Ð»Ð¾ÐºÐ¸

export functions as library
ÑÐºÑÐ¿Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÑÐ½ÐºÑÐ¸Ñ ÐºÐ°Ðº Ð±Ð¸Ð±Ð»Ð¸Ð¾ÑÐµÐºÑ

hide advanced blocks
ÑÐºÑÑÑÑ ÑÐ°ÑÑÐ¸ÑÐµÐ½Ð½ÑÐµ Ð±Ð»Ð¾ÐºÐ¸

put file on board
--MISSING--

get file from board
--MISSING--

uploaded
--MISSING--

downloaded
--MISSING--

Data Graph
ÐÑÐ°ÑÐ¸Ðº Ð´Ð°Ð½Ð½ÑÑ

Graph
--MISSING--

clear graph
--MISSING--

zero at bottom
--MISSING--

zero in middle
--MISSING--

export data to CSV file
--MISSING--

import data from CSV file
--MISSING--

copy graph data to clipboard
--MISSING--

show instructions
ÐÐ¾ÐºÐ°Ð·Ð°ÑÑ Ð¸Ð½ÑÑÑÑÐºÑÐ¸Ð¸

show compiled bytes
ÐÐ¾ÐºÐ°Ð·Ð°ÑÑ ÐºÐ¾Ð¼Ð¿Ð¸Ð»Ð¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÐµ Ð±Ð°Ð¹ÑÑ

expand
ÑÐ°ÑÐºÑÑÑÑ

collapse
ÑÐºÑÑÑÑ

rename...
Ð¿ÐµÑÐµÐ¸Ð¼ÐµÐ½Ð¾Ð²Ð°ÑÑ...

find variable accessors
--MISSING--

find scripts or block definitions where this variable is being read
--MISSING--

find variable modifiers
--MISSING--

find scripts or block definitions where this variable is being set or changed
--MISSING--

find uses of this block
--MISSING--

find scripts or block definitions using this block
--MISSING--

show block definition...
Ð¿Ð¾ÐºÐ°Ð·Ð°ÑÑ Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ° ...

show the definition of this block
Ð¿Ð¾ÐºÐ°Ð·Ð°ÑÑ Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ð´Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð±Ð»Ð¾ÐºÐ°

delete block definition...
ÑÐ´Ð°Ð»Ð¸ÑÑ Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ°

delete the definition of this block
ÑÐ´Ð°Ð»Ð¸ÑÑ Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ð´Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð±Ð»Ð¾ÐºÐ°

duplicate
Ð´ÑÐ±Ð»Ð¸ÑÐ¾Ð²Ð°ÑÑ

help
--MISSING--

duplicate this block
Ð´ÑÐ±Ð»Ð¸ÑÐ¾Ð²Ð°ÑÑ Ð´Ð°Ð½Ð½ÑÐ¹ Ð±Ð»Ð¾Ðº

delete block
ÑÐ´Ð°Ð»Ð¸ÑÑ Ð±Ð»Ð¾Ðº

delete this block
ÑÐ´Ð°Ð»Ð¸ÑÑ Ð´Ð°Ð½Ð½ÑÐ¹ Ð±Ð»Ð¾Ðº

just this one block
ÑÐ¾Ð»ÑÐºÐ¾ ÑÑÐ¾Ñ Ð±Ð»Ð¾Ðº

copy to clipboard
ÑÐºÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°ÑÑ Ð² Ð±ÑÑÐµÑ Ð¾Ð±Ð¼ÐµÐ½Ð°

copy to clipboard as URL
--MISSING--

copy these blocks to the clipboard as a URL
--MISSING--

copy these blocks to the clipboard
ÑÐºÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°ÑÑ ÑÑÐ¸ Ð±Ð»Ð¾ÐºÐ¸ Ð² Ð±ÑÑÐµÑ Ð¾Ð±Ð¼ÐµÐ½Ð°

duplicate all
Ð´ÑÐ±Ð»Ð¸ÑÐ¾Ð²Ð°ÑÑ Ð²ÑÐµ

duplicate these blocks
Ð´ÑÐ±Ð»Ð¸ÑÐ¾Ð²Ð°ÑÑ ÑÑÐ¸ Ð±Ð»Ð¾ÐºÐ¸

extract block
Ð¸Ð·Ð²Ð»ÐµÑÑ Ð±Ð»Ð¾Ðº

pull out this block
pull out this block

show help for this block in a browser
--MISSING--

save picture of script
ÑÐ¾ÑÑÐ°Ð½Ð¸ÑÑ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ ÑÐºÑÐ¸Ð¿ÑÐ°

save picture of script with result
--MISSING--

save a picture of this block definition as a PNG file
ÑÐ¾ÑÑÐ°Ð½Ð¸ÑÑ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ ÑÑÐ¾Ð³Ð¾ Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ Ð±Ð»Ð¾ÐºÐ° Ð² Ð²Ð¸Ð´Ðµ ÑÐ°Ð¹Ð»Ð° PNG

save a picture of these blocks as a PNG file
ÑÐ¾ÑÑÐ°Ð½Ð¸ÑÑ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ ÑÑÐ¸Ñ Ð±Ð»Ð¾ÐºÐ¾Ð² Ð² Ð²Ð¸Ð´Ðµ ÑÐ°Ð¹Ð»Ð° PNG

save a picture of these blocks and their result as a PNG file
--MISSING--

copy script
ÐºÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°ÑÑ ÑÐºÑÐ¸Ð¿Ñ

delete
ÑÐ´Ð°Ð»Ð¸ÑÑ

Input type:
Ð¢Ð¸Ð¿ Ð²Ð²Ð¾Ð´Ð°:

string only
ÑÐ¾Ð»ÑÐºÐ¾ ÑÑÑÐ¾ÐºÐ°

string or number
ÑÑÑÐ¾ÐºÐ° Ð¸Ð»Ð¸ ÑÐ¸ÑÐ»Ð¾

number only
ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ¸ÑÐ»Ð°

stop editing
--MISSING--

cut
--MISSING--

copy
--MISSING--

paste
--MISSING--

accept
--MISSING--

revert
--MISSING--

select all
--MISSING--

define
Ð¾Ð¿ÑÐµÐ´ÐµÐ»Ð¸ÑÑ

number/string
ÑÐ¸ÑÐ»Ð¾/ÑÑÑÐ¾ÐºÐ°

editable number or string
ÑÐµÐ´Ð°ÐºÑÐ¸ÑÑÐµÐ¼ÑÐ¹ Ð½Ð¾Ð¼ÐµÑ Ð¸Ð»Ð¸ ÑÑÑÐ¾ÐºÐ°

label
Ð¼ÐµÑÐºÐ°

input
Ð²Ð²Ð¾Ð´

hide block definition
ÑÐºÑÑÑÑ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ°

Are you sure you want to remove this block definition?
ÐÑ ÑÐ²ÐµÑÐµÐ½Ñ, ÑÑÐ¾ ÑÐ¾ÑÐ¸ÑÐµ ÑÐ´Ð°Ð»Ð¸ÑÑ ÑÑÐ¾ Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ°?

Language
Ð¯Ð·ÑÐº

Custom...
ÐÐ¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»ÑÑÐºÐ¸Ðµ ...

Obsolete
Ð£ÑÑÐ°ÑÐµÐ²ÑÐ¸Ð¹

OK
ÐÐ

Ok
ÐÐ

Yes
ÐÐ°

No
ÐÐµÑ

Cancel
ÐÑÐ¼ÐµÐ½Ð°

Okay
ÐÐ

Confirm
ÐÐ¾Ð´ÑÐ²ÐµÑÐ´Ð¸ÑÑ

# Library folders

Libraries
ÐÐ¸Ð±Ð»Ð¸Ð¾ÑÐµÐºÐ¸

AI
--MISSING--

Graphics and Displays
--MISSING--

Kits and Boards
--MISSING--

Network
--MISSING--

Other
ÐÑÐ¾ÑÐµÐµ

Robots
--MISSING--

Sensing
--MISSING--

Sound
ÐÐ²ÑÐº

System
--MISSING--

# File picker and library dialogs

New library name?
--MISSING--

show all block definitions
--MISSING--

hide all block definitions
--MISSING--

export this library
--MISSING--

delete library
--MISSING--

Examples
ÐÑÐ¸Ð¼ÐµÑÑ

Desktop
Ð Ð°Ð±Ð¾ÑÐ¸Ð¹ ÑÑÐ¾Ð»

Computer
ÐÐ¾Ð¼Ð¿ÑÑÑÐµÑ

Cloud
ÐÐ±Ð»Ð°ÐºÐ¾

File
Ð¤Ð°Ð¹Ð»

File Open
ÐÑÐºÑÑÑÑ ÑÐ°Ð¹Ð»

File Save
Ð¡Ð¾ÑÑÐ°Ð½Ð¸ÑÑ ÑÐ°Ð¹Ð»

File name:
ÐÐ¼Ñ ÑÐ°Ð¹Ð»Ð°:

New Folder
ÐÐ¾Ð²Ð°Ñ ÐÐ°Ð¿ÐºÐ°

by
Ð¿Ð¾

Depends:
ÐÐ°Ð²Ð¸ÑÐ¸Ñ:

Tags:
ÐÐµÑÐºÐ¸

Path, name or URL for library?
ÐÑÑÑ, Ð¸Ð¼Ñ Ð¸Ð»Ð¸ URL Ð´Ð»Ñ Ð±Ð¸Ð±Ð»Ð¸Ð¾ÑÐµÐºÐ¸?

Invalid URL
ÐÐµÐ²ÐµÑÐ½Ð°Ñ ÑÑÑÐ»ÐºÐ°

Could not fetch library.
ÐÐµ ÑÐ´Ð°Ð»Ð¾ÑÑ Ð²ÑÐ·Ð²Ð°ÑÑ Ð±Ð¸Ð±Ð»Ð¸Ð¾ÑÐµÐºÑ.

Host does not exist or is currently down.
Ð¥Ð¾ÑÑ Ð½Ðµ ÑÑÑÐµÑÑÐ²ÑÐµÑ Ð¸Ð»Ð¸ Ð² Ð´Ð°Ð½Ð½ÑÐ¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ Ð½Ðµ ÑÐ°Ð±Ð¾ÑÐ°ÐµÑ.

File not found in server.
Ð¤Ð°Ð¹Ð» Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½ Ð½Ð° ÑÐµÑÐ²ÐµÑÐµ.

Server expects HTTPS, and MicroBlocks doesn't currently support it.
Ð¡ÐµÑÐ²ÐµÑ Ð¾Ð¶Ð¸Ð´Ð°ÐµÑ HTTPS Ð·Ð°Ð¿ÑÐ¾Ñ, Ð° MicroBlocks Ð² Ð½Ð°ÑÑÐ¾ÑÑÐµÐµ Ð²ÑÐµÐ¼Ñ Ð½Ðµ Ð¿Ð¾Ð´Ð´ÐµÑÐ¶Ð¸Ð²Ð°ÐµÑ ÐµÐ³Ð¾.

library information
Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ Ð¾ Ð±Ð¸Ð±Ð»Ð¸Ð¾ÑÐµÐºÐµ

built-in library
Ð²ÑÑÑÐ¾ÐµÐ½Ð½Ð°Ñ Ð±Ð¸Ð±Ð»Ð¸Ð¾ÑÐµÐºÐ°

Dependency path, name or URL?
ÐÑÑÑ Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑÐ¸, Ð¸Ð¼Ñ Ð¸Ð»Ð¸ URL?

If you are adding a library that's built into MicroBlocks, you can just enter its name.
--MISSING--

If your library is in the Libraries folder in your local MicroBlocks project folder, you need to prefix it with a slash (/).
--MISSING--

If the library is hosted online, please input its full URL.
--MISSING--

Tag name?
ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¼ÐµÑÐºÐ¸?

user library
--MISSING--

Add Library
--MISSING--

seconds remaining
--MISSING--

Decrease block size
--MISSING--

Restore block size to 100%
--MISSING--

Increase block size
--MISSING--

############
# Tips Bar #
############

Button
--MISSING--

Boolean Input
--MISSING--

[l] toggle value, or drop a reporter into it.
--MISSING--

Color Input
--MISSING--

[l] change the color, or drop a reporter into it.
--MISSING--

Input
ÐÐ²Ð¾Ð´

[l] edit its value, or drop a reporter into it.
--MISSING--

Block Extension
--MISSING--

[l] right arrow to show optional inputs, left arrow to hide.
--MISSING--

Command Block
--MISSING--

[l] to run, or drag to build scripts. [r] menu.
--MISSING--

Hat Block
--MISSING--

[l] to run, or drag to build scripts. [r] menu.
--MISSING--

Reporter Block
--MISSING--

[l] to see value, or drop into an input slot. [r] menu.
--MISSING--

Script
--MISSING--

[l] to run. [r] menu.
--MISSING--

Pane Divider
--MISSING--

Drag to change pane width.
--MISSING--

Library
--MISSING--

[l] to show the blocks in this library. [r] menu.
--MISSING--

Block Category
--MISSING--

[l] to show the blocks in this category.
--MISSING--

Palette
--MISSING--

Drag blocks from here to build scripts. Drop scripts here to delete them.
--MISSING--

Scripts Pane
--MISSING--

Drag blocks here to build scripts. [r] menu.
--MISSING--

#################################
# Block Descriptions for TipBar #
#################################

Turn the user LED on or off.
--MISSING--

Display a bubble showing the value.
--MISSING--

Graph the value.
--MISSING--

Report the state of button A ( (-o) or (o-) ).
--MISSING--

Report the state of button B ( (-o) or (o-) ).
--MISSING--

Report the milliseconds since the timer was last reset.
--MISSING--

Reset the timer.
--MISSING--

Report the milliseconds since power up.
--MISSING--

Report the microseconds since power up.
--MISSING--

Report the board type.
--MISSING--

Report the electrical logic level on a digital pin ( (-o) or (o-) ).
--MISSING--

Report a number proportional to the voltage on an analog pin (0 = ground, 1023 = supply voltage).
--MISSING--

Turn a pin on or off ( (-o) or (o-) ).
--MISSING--

Pulse width modulate (PWM) a pin with the given duty cycle (0 - 1023).
--MISSING--

Report number of analog pins on this device.
--MISSING--

Report number of digital pins on this device.
--MISSING--

Report the value of a register (0-255) of an I2C device (0-127).
--MISSING--

Set an I2C device and register to given value (0-255).
--MISSING--

Receive multiple bytes from an I2C device.
--MISSING--

Send multiple bytes to an I2C device.
--MISSING--

Send a byte (0-255) to an SPI device.
--MISSING--

Read a byte from an SPI device while sending a zero byte. Report the byte received.
--MISSING--

Set the SPI clock speed and mode.
--MISSING--

Send a byte array via SPI, replacing its contents with the bytes received.
--MISSING--

Open the serial port at the given baud rate.
--MISSING--

Close the serial port.
--MISSING--

Report data received from the serial port (a byte array).
--MISSING--

Send a byte array to the serial port.
--MISSING--

Run when the board powers up or when the IDE start button is clicked.
--MISSING--

Run when buttons A, B, or A+B are pressed.
--MISSING--

Repeat the enclosed blocks indefinitely.
--MISSING--

Repeat the enclosed blocks the given number of times.
--MISSING--

Wait the given number of milliseconds.
--MISSING--

Run the first set of blocks whose test condition is (-o) .
--MISSING--

Run when the condition becomes (-o) .
--MISSING--

Wait until the condition becomes (-o) .
--MISSING--

Return (report) the given value from a function or script.
--MISSING--

Run when the given message is broadcast.
--MISSING--

Broadcast the given message.
--MISSING--

Do nothing. Used to add notes and documentation.
--MISSING--

Repeat the enclosed blocks with the variable set to the current iteration number or item.
--MISSING--

Repeat the enclosed blocks until the condition becomes (-o) .
--MISSING--

Stop this task.
--MISSING--

Stop all tasks except this one.
--MISSING--

Wait the given number of microseconds.
--MISSING--

Report the last broadcast message received.
--MISSING--

Call the function with the given name and optional parameter list.
--MISSING--

Call the function with the given name and optional parameter list and report its return value.
--MISSING--

Report the sum of the given numbers.
--MISSING--

Report the first number minus the second.
--MISSING--

Report the product of the given numbers.
--MISSING--

Report the first number divided by the second.
--MISSING--

Report the remainder of dividing the first number by the second.
--MISSING--

Report the absolute value of the given number (always >= 0).
--MISSING--

Report the minimum of the values.
--MISSING--

Report the maximum of the values.
--MISSING--

Report a randomly chosen number in the given range.
--MISSING--

Report (-o) if the first value is less than the second one.
--MISSING--

Report (-o) if the first value is less than or equal to the second one.
--MISSING--

Report (-o) if the two values are equal.
--MISSING--

Report (-o) if the two values are not equal.
--MISSING--

Report (-o) if the first value is greater than or equal to the second one.
--MISSING--

Report (-o) if the first value is greater than the second one.
--MISSING--

Boolean constant ( (-o) or (o-) ).
--MISSING--

Report the logical inverse of a Boolean ( (-o) or (o-) ) value.
--MISSING--

Report (-o) if both values are (-o)
--MISSING--

Report (-o) if either value is (-o)
--MISSING--

Report (-o) if first input is a value of the given data type.
--MISSING--

Report the numerical value of a hexadecimal string (range: -0x1FFFFFFF to 0x1FFFFFFF)
--MISSING--

Report bitwise AND of two numbers.
--MISSING--

Report bitwise OR of two numbers.
--MISSING--

Report bitwise XOR (exclusive OR) of two numbers.
--MISSING--

Report bitwise inverse of the given number.
--MISSING--

Report the given number shifted left by the given number of bits.
--MISSING--

Report the given number shifted right by the given number of bits (arithmetic shift; sign is maintained).
--MISSING--

Set a variable to the given value.
--MISSING--

Change a variable by the given amount.
--MISSING--

Create a variable local to the containing script with the given initial value.
--MISSING--

Report the Nth item of a list, string, or byte array.
--MISSING--

Report the number of items in a list, string, or byte array.
--MISSING--

Join (concatenate) the given lists, strings, or byte arrays and report the result.
--MISSING--

Create and report a short list containing the given items. Length limited by available stack space.
--MISSING--

Add an item to the end of a list.
--MISSING--

Replace the Nth item (or all items) of a list or byte array with the given value.
--MISSING--

Delete the Nth item (or all items) of a list.
--MISSING--

Find and report the index of an item in a list or a substring within a string. Report -1 if not found.
--MISSING--

Report a copy from the given index through the end (or optional stop index) of the given list, string, or byte array.
--MISSING--

Split the given string with the given delimiter and report the result (a list of strings).
--MISSING--

Combine the items of a list into a string, optionally separated by a delimiter (e.g. comma).
--MISSING--

Report the Unicode value ("code point") of the Nth character of the given string.
--MISSING--

Report a string containing the given Unicode value ("code point") or list of values.
--MISSING--

Report a new list of the given length filled with zero or the optional value.
--MISSING--

Report a new byte array of the given length filled with zero or the optional value.
--MISSING--

Report a byte array containing the UTF-8 bytes of the given string.
--MISSING--

Report the number of words of memory available. Stop button frees up memory.
--MISSING--


RTL
true

# MicroBlocks translation file
# Last updated: July 07 2020

#########################
# Blocks and categories #
#########################

Output
Ø§ÙÙØ®Ø±Ø¬Ø§Øª

set user LED _
Ø¶Ø¨Ø· Ø§ÙØµÙØ§Ù Ø§ÙØ«ÙØ§Ø¦Ù ÙÙÙØ³ØªØ®Ø¯Ù _

say _
ÙÙ _

graph _
--MISSING--

Input
Ø§ÙÙØ¯Ø®ÙØ§Øª

button A
Ø²Ø± Ø£

button B
Ø²Ø± Ø¨

microseconds
ÙÙÙØ±ÙØ«Ø§ÙÙØ©

milliseconds
ÙÙÙÙ Ø«Ø§ÙÙØ©

board type
ÙÙØ¹ Ø§ÙÙÙØ­Ø©

Pins
Ø§ÙÙÙØ§ÙØ°

read digital pin _
ÙØ±Ø§Ø¡Ø© Ø§ÙÙÙÙØ° Ø§ÙØ±ÙÙÙ _

read analog pin _
ÙØ±Ø§Ø¡Ø© Ø§ÙÙÙÙØ° Ø§ÙØªÙØ§Ø¸Ø±Ù _

set digital pin _ to _
Ø¬Ø¹Ù Ø§ÙÙÙÙØ° Ø§ÙØ±ÙÙÙ _ ÙØ³Ø§ÙÙ _

set pin _ to _
Ø¬Ø¹Ù Ø§ÙÙÙÙØ° _ ÙØ³Ø§ÙÙ _

analog pins
Ø§ÙÙÙØ§ÙØ° Ø§ÙØªÙØ§Ø¸Ø±ÙØ©

digital pins
Ø§ÙÙÙØ§ÙØ° Ø§ÙØ±ÙÙÙØ©

Control
ÙØ±Ø§ÙØ¨Ø©

when started
Ø¹ÙØ¯ Ø§ÙØ¨Ø¯Ø§ÙØ©

when button _ pressed
Ø¹ÙØ¯ Ø§ÙØ¶ØºØ· Ø¹ÙÙ Ø²Ø± _

forever _
Ø¨Ø§Ø³ØªÙØ±Ø§Ø± _

repeat _ _
ØªÙØ±Ø§Ø± _ _

wait _ millisecs
Ø§ÙØªØ¸Ø± _ ÙÙÙÙ Ø«Ø§ÙÙØ©

if _ _
Ø¥Ø°Ø§ _ _

else if _ _
Ø¢Ø®Ø± Ø¥Ø°Ø§ _ _

if _ _ else _
Ø¥Ø°Ø§ _ _ Ø¢Ø®Ø± _

else
Ø¢Ø®Ø±

when _
Ø¹ÙØ¯ÙØ§ _

wait until _
Ø§ÙØªØ¸Ø± Ø­ØªÙ _

wait _ microsecs
Ø§ÙØªØ¸Ø± _ ÙÙÙØ±ÙØ«Ø§ÙÙØ©

return _
Ø±Ø¬Ø¹ _

when _ received
Ø¹ÙØ¯ ØªÙÙÙ _

broadcast _
ÙØ´Ø± _

comment _
ØªØ¹ÙÙÙ _

for _ in _ _
Ù _ ÙÙ _ _

repeat until _ _
ÙØ±Ø± Ø­ØªÙ _ _

stop this task
ÙÙÙ ÙØ°Ù Ø§ÙÙÙÙØ©

stop other tasks
--MISSING--

stop all
ØªÙÙÙÙ ÙÙ Ø´ÙØ¡

last message
--MISSING--

Operators
--MISSING--

_ mod _
_ mod _

abs _
ÙÙÙÙ ÙØ·ÙÙÙ _

random _ to _
Ø±ÙÙ Ø¹Ø´ÙØ§Ø¦Ù ÙÙ _ Ø¥ÙÙ _

not _
ÙÙØ³ _

_ and _
_ Ù _

and _
Ù _

_ or _
_ Ø£Ù _

or _
Ø£Ù _

_ is a _
--MISSING--

boolean
--MISSING--

number
--MISSING--

string
--MISSING--

list
--MISSING--

Advanced:
--MISSING--

hex _
hex _

Variables
Ø§ÙÙØªØºÙØ±Ø§Øª

# Buttons on top of "Variables" category

Add a variable
Ø¥Ø¶Ø§ÙØ© ÙØªØºÙØ±

Delete a variable
Ø­Ø°Ù ÙØªØºÙØ±

# New variable dialog

New variable name?
--MISSING--

set _ to _
Ø¥Ø¬Ø¹Ù _ Ø¨ÙÙÙØ© _

change _ by _
ØºÙØ± _ Ø¨ _

initialize local _ to _
--MISSING--

Data
--MISSING--

list
--MISSING--

length of _
Ø·ÙÙ _

item _ of _
ØºØ±Ø¶ _ ÙÙ _

replace item _ of list _ with _
--MISSING--

delete item _ of list _
--MISSING--

add _ to list _
--MISSING--

join _ _
--MISSING--

copy _ from _
--MISSING--

to _
--MISSING--

find _ in _
--MISSING--

starting at _
--MISSING--

join items of list _
--MISSING--

separator _
--MISSING--

unicode _ of _
--MISSING--

string from unicode _
--MISSING--

new list length _
ÙØ§Ø¦ÙØ© Ø¬Ø¯ÙØ¯Ø© Ø·ÙÙ _

new byte array _
--MISSING--

free memory
--MISSING--

My Blocks
--MISSING--

# Buttons on top of "My Blocks" category

Add a command block
--MISSING--

Add a reporter block
--MISSING--

# Make a block dialog

Enter function name:
--MISSING--

Comm
--MISSING--

i2c get device _ register _
Ø§ÙØ­ØµÙÙ Ø¹ÙÙ Ø¬ÙØ§Ø² _ Ø³Ø¬Ù _ i2c

i2c set device _ register _ to _
Ø¶Ø¨Ø· Ø¬ÙØ§Ø² _ Ø³Ø¬Ù _ Ø¥ÙÙ _ i2c

i2c device _ read list _
--MISSING--

i2c device _ write list _
--MISSING--

spi send _
spi Ø¨Ø¹Ø« _

spi receive
spi Ø¥Ø³ØªÙÙ

print _
Ø·Ø¨Ø¹ _

no op
ÙØ§ Ø¹ÙÙÙØ©

ignore
ØªØ¬Ø§ÙÙ

##############
# Primitives #
##############

# These are all mostly hidden from end users

draw shape _ at x _ y _
Ø±Ø³Ù Ø´ÙÙ _ ÙÙ Ø³ _ Øµ _

shape for letter _
Ø´ÙÙ Ø§ÙØ­Ø±Ù _

send NeoPixel rgb _
send NeoPixel rgb _

has tone support
ÙØ¯ÙÙ Ø¯Ø¹Ù ÙØºÙØ©

play tone pin _ frequency _
ÙØ¹Ø¨ ÙØºÙØ© ÙÙÙØ° _ ÙÙØ¬Ø© ØªØ±Ø¯Ø¯ _

has WiFi support
ÙØ¯ÙÙ Ø¯Ø¹Ù ÙØ§Ù ÙØ§Ù

start WiFi _ password _
Ø§Ø¨Ø¯Ø£ ÙØ§Ù ÙØ§Ù _ ÙÙÙØ© Ø§ÙÙØ±ÙØ± _

stop WiFi
ÙÙÙ ÙØ§Ù ÙØ§Ù

WiFi status
Ø­Ø§ÙØ© ÙØ§Ù ÙØ§Ù

my IP address
Ø¹ÙÙØ§Ù IP Ø§ÙØ®Ø§Øµ Ø¨Ù

radio send number _
Ø£Ø±Ø³Ù Ø¹Ø¨Ø± Ø§ÙØ±Ø§Ø¯ÙÙ Ø±ÙÙ _

radio send string _
Ø£Ø±Ø³Ù Ø¹Ø¨Ø± Ø§ÙØ±Ø§Ø¯ÙÙ Ø³ÙØ³ÙØ© _

radio send pair _ = _
Ø£Ø±Ø³Ù Ø¹Ø¨Ø± Ø§ÙØ±Ø§Ø¯ÙÙ Ø²ÙØ¬ _ = _

radio message received?
ÙØµÙØª Ø§ÙØ±Ø³Ø§ÙØ© Ø¹Ø¨Ø± Ø§ÙØ±Ø§Ø¯ÙÙØ

radio last number
Ø±Ø§Ø¯ÙÙ Ø¢Ø®Ø± Ø±ÙÙ

radio last string
Ø±Ø§Ø¯ÙÙ Ø£Ø®Ø± Ø³ÙØ³ÙØ©

radio last message type
Ø±Ø§Ø¯ÙÙ ÙÙØ¹ Ø§ÙØ±Ø³Ø§ÙØ© Ø§ÙÙØ§Ø¶ÙØ©

radio set group _
Ø±Ø§Ø¯ÙÙ Ø¶Ø¨Ø· ÙØ¬ÙÙØ¹Ø© _

radio set channel (0-83) _
Ø±Ø§Ø¯ÙÙ Ø¶Ø¨Ø· ÙÙØ§Ø© (0-83) _

radio set power (0-7) _
Ø±Ø§Ø¯ÙÙ Ø¶Ø¨Ø· Ø·Ø§ÙØ© (0-7) _

radio last signal strength
Ø±Ø§Ø¯ÙÙ ÙÙØ© Ø§ÙØ¥Ø´Ø§Ø±Ø© Ø§ÙØ£Ø®ÙØ±Ø©

radio receive packet _
radio receive packet _

radio send packet _
radio send packet _

disable radio
ØªØ¹Ø·ÙÙ Ø§ÙØ±Ø§Ø¯ÙÙ

#############
# Libraries #
#############

Basic Sensors
--MISSING--

tilt x
Ø§ÙÙÙÙ Ø³

tilt y
Ø§ÙÙÙÙ Øµ

tilt z
Ø§ÙÙÙÙ Ø¶

acceleration
--MISSING--

light level
ÙØ³ØªÙÙ Ø§ÙØ¶ÙØ¡

temperature (Â°C)
Ø¯Ø±Ø¬Ø© Ø§ÙØ­Ø±Ø§Ø±Ø© (Ø¯Ø±Ø¬Ø© ÙØ¦ÙÙØ©)

####
# NeoPixel library

NeoPixel
--MISSING--

set NeoPixels _ _ _ _ _ _ _ _ _ _
Set NeoPixels _ _ _ _ _ _ _ _ _ _

clear NeoPixels
Clear NeoPixels

set NeoPixel _ color _
set NeoPixel _ color _

set all NeoPixels color _
set all NeoPixels color _

rotate NeoPixels by _
rotate NeoPixels by _

color r _ g _ b _ (0-255)
Ø§ÙÙÙÙ Ø£Ø­ÙØ± _ Ø£Ø®Ø¶Ø± _ Ø£Ø²Ø±Ù _

random color
--MISSING--

attach _ LED NeoPixel strip to pin _
--MISSING--

has white _
--MISSING--

PIR
--MISSING--

PIR at pin _ detected movement
--MISSING--

####
# Citilab ED1 board libraries

ED1 Stepper Motor
--MISSING--

move motor _ _ steps _
--MISSING--

move motor 1 _ and motor 2 _ _ steps
ØªØ­Ø±Ù Ø§ÙÙØ­Ø±Ù 1 _ ÙØ§ÙÙØ­Ø±Ù 2 _ _ Ø§ÙØ®Ø·ÙØ§Øª

move motor _ angle _ Â°
--MISSING--

move motor _ _ complete turns
--MISSING--

stop steppers
ÙÙÙ Ø§ÙØ³Ø§Ø¦Ø±

clockwise
Ø¨Ø¥ØªØ¬Ø§Ù Ø¹ÙØ§Ø±Ø¨ Ø§ÙØ³Ø§Ø¹Ø©

counter-clockwise
Ø¹ÙØ³ Ø¹ÙØ§Ø±Ø¨ Ø§ÙØ³Ø§Ø¹Ù

ED1 Buttons
--MISSING--

button OK
Ø²Ø± ÙÙØ§ÙÙ

button X
Ø²Ø± X

button up
Ø²Ø± ÙÙÙ

button down
Ø²Ø± ØªØ­Øª

button left
Ø²Ø± ÙØ³Ø§Ø±

button right
Ø²Ø± ÙÙÙÙ

capacitive sensor _
ÙØ³ØªØ´Ø¹Ø± Ø³Ø¹ÙÙ âª_â¬

set capacitive threshold to _
Ø¶Ø¨Ø· Ø¹ØªØ¨Ø© Ø³Ø¹ÙÙØ© Ø¥ÙÙ _

####
# BirdBrain Technologies libraries

Hummingbird LED _ _ %
--MISSING--

Hummingbird Tri-LED _ R _ % G _ % B _ %
--MISSING--

Hummingbird Position Servo _ _ Â°
--MISSING--

Hummingbird Rotation Servo _ _ %
--MISSING--

Hummingbird _ _
--MISSING--

Hummingbird Battery (mV)
--MISSING--

Light
--MISSING--

Distance (cm)
--MISSING--

Dial
--MISSING--

Sound
--MISSING--

Other
--MISSING--

Finch Beak Red _ Green _ Blue _
--MISSING--

Finch Tail _ Red _ Green _ Blue _
--MISSING--

Finch Move _ _ cm at _ %
--MISSING--

Finch Turn _ _ Â° at _ %
--MISSING--

Finch Wheels L _ % R _ %
--MISSING--

Finch Stop
--MISSING--

Finch Distance (cm)
--MISSING--

Finch _ Light
--MISSING--

Finch _ Line
--MISSING--

Finch Reset Encoders
--MISSING--

Finch _ Encoder
--MISSING--

Finch Accelerometer _
--MISSING--

Finch Battery
--MISSING--

All
--MISSING--

Forward
--MISSING--

Backward
--MISSING--

Right
--MISSING--

Left
--MISSING--

Beak Up
--MISSING--

Beak Down
--MISSING--

Tilt Left
--MISSING--

Tilt Right
--MISSING--

Level
--MISSING--

Upside Down
--MISSING--

x
--MISSING--

y
--MISSING--

z
--MISSING--

strength
--MISSING--

####
# Ultrasound distance library

distance (cm) trigger _ echo _
--MISSING--

####
# Infrared remote library

IR Remote
--MISSING--

receive IR code
--MISSING--

receive IR code from device _
ØªÙÙÙ Ø±ÙØ² Ø§ÙØ£Ø´Ø¹Ø© ØªØ­Øª Ø§ÙØ­ÙØ±Ø§Ø¡ ÙÙ Ø§ÙØ¬ÙØ§Ø² _

test IR
Ø§Ø®ØªØ¨Ø§Ø± Ø§ÙØ£Ø´Ø¹Ø© ØªØ­Øª Ø§ÙØ­ÙØ±Ø§Ø¡

attach IR receiver to pin _
--MISSING--

####
# Radio comm library
# Allows micro:bit boards to exchange messages
# All of its blocks are primitive (see "Primitives" section)

Radio
--MISSING--

####
# Text scrolling library
# Scrolls text on 5x5 LED displays and simulated ones

Scrolling
--MISSING--

scroll text _
--MISSING--

scroll number _
--MISSING--

pausing _ ms
--MISSING--

stop scrolling
ØªÙÙÙ Ø¹Ù Ø§ÙØªÙØ±ÙØ±

####
# Servo motor library

Servo
--MISSING--

set servo _ to _ degrees (-90 to 90)
--MISSING--

set servo _ to speed _ (-100 to 100)
--MISSING--

stop servo _
--MISSING--

####
# 5x5 LED display library
# Supports the micro:bit display, but also simulated 5x5 displays on boards
# with differently sized LED arrays, NeoPixel arrays or TFT displays

LED Display
--MISSING--

display _
Ø´Ø§Ø´Ø© _

clear display
ÙØ³Ø­ Ø§ÙØ´Ø§Ø´Ø©

plot x _ y _
Ø±Ø³Ù Ø³ _ Øµ _

unplot x _ y _
 ÙØ­Ù Ø±Ø³Ù Ø³ _ Øµ _

display character _
--MISSING--

####
# TFT display library

enable TFT _
ÙÙÙ TFT _

TFT width
--MISSING--

TFT height
--MISSING--

set TFT pixel x _ y _ to _
set TFT pixel x _ y _ to _

draw line on TFT from x _ y _ to x _ y _ color _
--MISSING--

draw rectangle on TFT at x _ y _ width _ height _ color _
--MISSING--

draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _
--MISSING--

draw circle on TFT at x _ y _ radius _ color _
--MISSING--

draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _
--MISSING--

filled _
--MISSING--

write _ on TFT at x _ y _ color _
--MISSING--

scale _ wrap _
--MISSING--

####
# Tone library
# Generates music tones on buzzers

Tone
--MISSING--

attach buzzer to pin _
attach buzzer to pin _

play note _ octave _ for _ ms
ØªÙØ¹Ø¨ ÙÙØªØ§ _ Ø§ÙÙØªØ§Ù _ Ø®ÙØ§Ù _ ÙÙÙÙ Ø«Ø§ÙÙØ©

play frequency _ for _ ms
--MISSING--

play midi key _ for _ ms
--MISSING--

####
# Turtle geometry library

Turtle
--MISSING--

home
--MISSING--

move _
--MISSING--

turn _ degrees
--MISSING--

turn _ / _ of circle
--MISSING--

pen down
--MISSING--

pen up
--MISSING--

set pen color to _
--MISSING--

set pen to random color
--MISSING--

fill display with _
--MISSING--

go to x _ y _
--MISSING--

point in direction _
--MISSING--

####
# File system library

Files
--MISSING--

open file _
--MISSING--

close file _
--MISSING--

delete file _
--MISSING--

append line _ to file _
--MISSING--

append bytes _ to file _
--MISSING--

end of file _
--MISSING--

next line of file _
--MISSING--

next _ bytes of file _
--MISSING--

starting at _
--MISSING--

file names
--MISSING--

size of file _
--MISSING--

file system info
--MISSING--

####
# WiFi library

WiFi
--MISSING--

wifi connect to _ password _ try _ times
--MISSING--

wifi create hotspot _ password _
--MISSING--

IP address
--MISSING--

####
# Motion library
# Counts steps and detects motion via the internal accelerometer

Motion
--MISSING--

motion
--MISSING--

start step counter
--MISSING--

step count
--MISSING--

clear step count
--MISSING--

set step threshold _ (0-50)
--MISSING--

####
# Button Events library

Button Events
--MISSING--

button _ double pressed
--MISSING--

button _ long pressed
--MISSING--

button _ pressed
--MISSING--

####
# Calliope board library

Calliope set LED red _ green _ blue _
--MISSING--

Calliope set speaker _
--MISSING--

Calliope loudness
--MISSING--

####
# Circuit Playground Express board library

Circuit Playground set speaker _
--MISSING--

Circuit Playground slide switch
--MISSING--

####
# DotStar LED library

attach _ DotStar LEDs to data pin _ clock pin _
--MISSING--

set all DotStar LEDs to r _ g _ b _
--MISSING--

set DotStar LED _ to r _ g _ b _
--MISSING--

set DotStar brightness _
--MISSING--

####
# BME280 environmental sensor

bme280 connected
--MISSING--

bmp280 connected
--MISSING--

bmx280 temperature
--MISSING--

bmx280 pressure
--MISSING--

bme280 humidity
--MISSING--

####
# TCS34725 color sensor

TCS34725 connected
--MISSING--

TCS34725 rgb
--MISSING--

color _ name
--MISSING--

####
# DHT11 environmental sensor

temperature (Celsius) DHT11 pin _
--MISSING--

humidity DHT11 pin _
--MISSING--

temperature (Celsius) DHT22 pin _
--MISSING--

humidity DHT22 pin _
--MISSING--

####
# PN532 RFID reader

read PN532 RFID
--MISSING--

RFID _ = _
--MISSING--

get PN532 firmware version
--MISSING--

####
# HTTP libraries

HTTP client
--MISSING--

_ data _ to httpÜ// _
--MISSING--

HTTP server
--MISSING--

start HTTP server
--MISSING--

HTTP server request
--MISSING--

respond _ to HTTP request
--MISSING--

with body _
--MISSING--

and headers _
--MISSING--

body of request _
--MISSING--

path of request _
--MISSING--

method of request _
--MISSING--

####
# Web Things library

Web Thing
--MISSING--

set thing name to _
--MISSING--

set thing capability to _
--MISSING--

set boolean property _ title _ @Type _
--MISSING--

set string property _ title _ @Type _
--MISSING--

set number property _ title _ @Type _
--MISSING--

set number property _ title _ min _ max _ @Type _
--MISSING--

read only _
--MISSING--

register event _ type _
--MISSING--

start WebThing server
--MISSING--

trigger event _
--MISSING--

thing description JSON
--MISSING--

properties JSON
--MISSING--

event definitions JSON
--MISSING--

events JSON
--MISSING--

##################
# MicroBlocks UI #
##################

# buttons, error & info messages, dialog boxes, etc

New
Ø¬Ø¯ÙØ¯

Open
ÙØªØ­

Open from board
--MISSING--

Information
--MISSING--

Plug in the board.
--MISSING--

Reading project from board...
--MISSING--

Loading project...
--MISSING--

Found a newer version of
--MISSING--

Do you want me to update the one in the project?
--MISSING--

Save
Ø­ÙØ¸

Connect
ÙØµÙ

disconnect
ÙØ·Ø¹ Ø§ÙØ§ØªØµØ§Ù

Serial port:
ÙÙÙØ° ØªØ³ÙØ³ÙÙ:

other...
ØºÙØ±...

none
ÙØ§ Ø´ÙØ¡

Port name?
Ø¥Ø³Ù Ø§ÙÙÙÙØ°Ø

Board type:
ÙÙØ¹ Ø§ÙÙÙØ­Ø©:

Select board:
Ø§Ø®ØªØ± Ø§ÙÙØ­Ø©:

Could not read:
--MISSING--

by
ÙÙ ÙØ¨Ù

Created with GP
--MISSING--

More info at http://microblocks.fun
More info at http://microblocks.fun

Function "
--MISSING--

" is too large to send to board.
" ÙØ¨ÙØ±Ø© Ø¬Ø¯Ø§ ÙØ¥Ø±Ø³Ø§ÙÙØ§ Ø¥ÙÙ Ø§ÙÙÙØ­Ø©

Script is too large to send to board.
Ø§ÙØ¨Ø±ÙØ§ÙØ¬ Ø§ÙÙØµÙ ÙØ¨ÙØ± Ø¬Ø¯ÙØ§ Ø¨Ø­ÙØ« ÙØ§ ÙÙÙÙ Ø¥Ø±Ø³Ø§ÙÙ Ø¥ÙÙ Ø§ÙÙÙØ­Ø©

Use "Connect" button to connect to a MicroBlocks device.
Ø§Ø³ØªØ®Ø¯Ù Ø²Ø± "ÙØµÙ" ÙÙØ§ØªØµØ§Ù Ø¨Ø¬ÙØ§Ø² MicroBlocks.

No boards found; is your board plugged in?
ÙÙ ÙØªÙ Ø§ÙØ¹Ø«ÙØ± Ø¹ÙÙ ÙÙØ­Ø§Øªâª.â¬ ÙÙ ØªÙ ØªÙØµÙÙ Ø§ÙÙÙØ­Ø© Ø§ÙØ®Ø§ØµØ© Ø¨ÙØ

For AdaFruit boards, double-click reset button and try again.
--MISSING--

The board is not responding.
Ø§ÙÙÙØ­Ø© ÙØ§ ØªØ³ØªØ¬ÙØ¨.

Try to Install MicroBlocks on the board?
ÙØ­Ø§ÙÙØ© ØªØ«Ø¨ÙØª MicroBlocks Ø¹ÙÙ Ø§ÙÙÙØ­Ø©Ø

The MicroBlocks in your board is not current
--MISSING--

Try to update MicroBlocks on the board?
--MISSING--

Stop
ØªÙÙÙ

Start
Ø¨Ø¯Ø§ÙØ©

Quit MicroBlocks?
Ø§ÙØ®Ø±ÙØ¬ ÙÙ MicroBlocksØ

Discard current project?
ØªØ¬Ø§ÙÙ Ø§ÙÙØ´Ø±ÙØ¹ Ø§ÙØ­Ø§ÙÙØ

clean up
ØªÙØ¸ÙÙ

arrange scripts
ØªØ±ØªÙØ¨ Ø§ÙØ¨Ø±Ø§ÙØ¬ Ø§ÙÙØµÙØ©

undrop (ctrl-Z)
--MISSING--

copy all scripts to clipboard
--MISSING--

paste all scripts
ÙØµÙ Ø¬ÙÙØ¹ Ø§ÙØ¨Ø±Ø§ÙØ¬ Ø§ÙÙØµÙØ©

paste script
ÙØµÙ Ø§ÙØ¨Ø±ÙØ§ÙØ¬ Ø§ÙÙØµÙ

save a picture of all scripts
--MISSING--

about...
Ø­ÙÙ...

virtual machine version
ÙØ³Ø®Ø© Ø§ÙØ¬ÙØ§Ø² Ø§ÙØ¸Ø§ÙØ±Ù

update firmware on board
--MISSING--

show data graph
--MISSING--

set serial delay
--MISSING--

firmware version
--MISSING--

start WebThing server
--MISSING--

stop WebThing server
--MISSING--

HTTP Server
--MISSING--

MicroBlocks HTTP Server listening on port 6473
--MISSING--

disable autoloading board libraries
--MISSING--

enable autoloading board libraries
--MISSING--

enable PlugShare when project empty
--MISSING--

disable PlugShare when project empty
--MISSING--

erase flash and update firmware on ESP board
--MISSING--

Use board type
--MISSING--

Wiping board...
--MISSING--

(press ESC to cancel)
--MISSING--

Done!
--MISSING--

download and install latest VM
--MISSING--

Select board type:
--MISSING--

Uploading MicroBlocks to board...
--MISSING--

copy data to clipboard
ÙØ³Ø® Ø§ÙØ¨ÙØ§ÙØ§Øª Ø¥ÙÙ Ø§ÙØ­Ø§ÙØ¸Ø©

clear data
ÙØ³Ø­ Ø§ÙØ¨ÙØ§ÙØ§Øª

clear memory and variables
ÙØ³Ø­ Ø§ÙØ°Ø§ÙØ±Ø© ÙØ§ÙÙØªØºÙØ±Ø§Øª

show advanced blocks
Ø¥Ø¸ÙØ§Ø± Ø§ÙÙØªÙ Ø§ÙÙØªÙØ¯ÙØ©

export functions as library
ØªØµØ¯ÙØ± Ø¯ÙØ§Ù ÙÙÙØªØ¨Ø©

hide advanced blocks
Ø¥Ø®ÙØ§Ø¡ Ø§ÙÙØªÙ Ø§ÙÙØªÙØ¯ÙØ©

Data Graph
Ø§ÙØ±Ø³Ù Ø§ÙØ¨ÙØ§ÙÙ

show instructions
Ø¹Ø±Ø¶ Ø§ÙØªØ¹ÙÙÙØ§Øª

show compiled bytes
Ø¹Ø±Ø¶ Ø¨Ø§ÙØª Ø§ÙÙØªØ±Ø¬ÙØ©

expand
ÙØ³Ø¹

collapse
Ø¥Ø®ÙØ§Ø¡

rename...
Ø¥Ø¹Ø§Ø¯Ø© ØªØ³ÙÙØ© ...

show block definition...
--MISSING--

show the definition of this block
--MISSING--

delete block definition...
--MISSING--

delete the definition of this block
--MISSING--

duplicate
ÙØ±Ø±

duplicate this block
--MISSING--

delete block
--MISSING--

delete this block
--MISSING--

just this one block
ÙÙØ· ÙØ°Ù Ø§ÙÙØªÙØ©

copy to clipboard
--MISSING--

copy these blocks to the clipboard
--MISSING--

duplicate all
--MISSING--

duplicate these blocks
--MISSING--

extract block
--MISSING--

pull out this block
--MISSING--

save picture of script
Ø­ÙØ¸ ØµÙØ±Ø© ÙÙØ¨Ø±ÙØ§ÙØ¬ Ø§ÙÙØµÙ

save a picture of this block definition as a PNG file
--MISSING--

save a picture of these blocks as a PNG file
--MISSING--

copy script
ÙØ³Ø® Ø§ÙØ¨Ø±ÙØ§ÙØ¬ Ø§ÙÙØµÙ

delete
Ø­Ø°Ù

Input type:
--MISSING--

string only
--MISSING--

string or number
--MISSING--

number only
--MISSING--

define
--MISSING--

number/string
--MISSING--

editable number or string
--MISSING--

label
--MISSING--

input
--MISSING--

hide block definition
--MISSING--

Are you sure you want to remove this block definition?
ÙÙ Ø£ÙØª ÙØªØ£ÙØ¯ ÙÙ Ø£ÙÙ ØªØ±ÙØ¯ Ø¥Ø²Ø§ÙØ© ØªØ¹Ø±ÙÙ Ø§ÙÙØªÙØ©Ø

Language
--MISSING--

Custom...
--MISSING--

Obsolete
ÙØ¯ÙÙ

OK
--MISSING--

Ok
ÙØ§ÙÙ

Yes
ÙØ¹Ù

No
ÙØ§

Cancel
Ø¥ÙØºØ§Ø¡

Okay
ÙØ§ÙÙ

Confirm
Ø£ÙØ¯

# File picker and library dialogs

Libraries
Ø§ÙÙÙØªØ¨Ø§Øª

Examples
--MISSING--

Desktop
--MISSING--

Computer
--MISSING--

Cloud
--MISSING--

File
--MISSING--

File Open
ÙØªØ­ Ø§ÙÙÙÙ

File Save
Ø­ÙØ¸ Ø§ÙÙÙÙ

File name:
Ø§Ø³Ù Ø§ÙÙÙÙ:

New Folder
--MISSING--

by
ÙÙ ÙØ¨Ù

Depends:
--MISSING--

Tags:
--MISSING--

Path, name or URL for library?
--MISSING--

Invalid URL
--MISSING--

Could not fetch library.
--MISSING--

Host does not exist or is currently down.
--MISSING--

File not found in server.
--MISSING--

Server expects HTTPS, and MicroBlocks doesn't currently support it.
--MISSING--

library information
--MISSING--

built-in library
--MISSING--

Dependency path, name or URL?
--MISSING--

Tag name?
--MISSING--

# MicroBlocks translation file
# Last updated: July 07 2020

#########################
# Blocks and categories #
#########################

Output
åºå

set user LED _
LEDè¨­å® _

say _
è©±ã _

graph _
ã°ã©ã _

Input
å¥å

button A
ãã¿ã³ A

button B
ãã¿ã³ B

microseconds
ãã¤ã¯ã­ç§

milliseconds
ããªç§

board type
ãã¼ãã¿ã¤ã

Pins
ãã³

read digital pin _
ãã¸ã¿ã«ãã³ãèª­ã _

read analog pin _
ã¢ãã­ã°ãã³ãèª­ã _

set digital pin _ to _
ãã¸ã¿ã«ãã³è¨­å® _ ã _

set pin _ to _
ãã³è¨­å® _ ã _

analog pins
ã¢ãã­ã°ãã³

digital pins
ãã¸ã¿ã«ãã³

Control
æä½

when started
ã¹ã¿ã¼ãããã

when button _ pressed
ãã¿ã³ _ ãæ¼ãããã 

forever _
ãã£ã¨ _

repeat _ _
ç¹°ãè¿ã _ å _

wait _ millisecs
å¾ã¤ _ ããªç§

if _ _
ãã _ _

else if _ _
ã§ãªããã°,ãã _ _

if _ _ else _
ãã _ _ ã§ãªããã° _

else
ã§ãªããã°

when _
ã¨ã _

wait until _
å¾ã¤ _ ã¾ã§

wait _ microsecs
å¾ã¤ _ ããªç§

return _
è¿ã _

when _ received
åä¿¡ããã¨ã _

broadcast _
åºãéä¿¡ãã _

comment _
ã³ã¡ã³ã _

for _ in _ _
ç¹°ãè¿ã å¤æ° _ ä»¥å _ _

repeat until _ _
ã¾ã§ ç¹°ãè¿ã _ _

stop this task
ãã®å¦çãæ­¢ãã

stop other tasks
ä»ã®å¦çãæ­¢ãã

stop all
ãã¹ã¦åæ­¢

last message
ææ°ã®ã¡ãã»ã¼ã¸

Operators
æ¼ç®

_ mod _
_ å²ã _ ã®ä½ã

abs _
çµ¶å¯¾å¤ _

random _ to _
ãã _ ã¾ã§ _ ã©ã³ãã ã®å¤

not _
_ ã§ãªããã°

_ and _
_ ãã¤ _

and _
ãã¤ _

_ or _
_ ã¾ãã¯ _

or _
ã¾ãã¯ _

_ is a _
_ ã¯ _ ã§ãã

boolean
ãã¼ã«

number
æ°å­

string
æå­å

list
ãªã¹ã

Advanced:
--MISSING--

hex _
16é²æ° _

Variables
å¤æ°

# Buttons on top of "Variables" category

Add a variable
å¤æ°è¿½å 

Delete a variable
å¤æ°åé¤

# New variable dialog

New variable name?
æ°ããå¤æ°ã®ååã¯?ï¼

set _ to _
è¨­å® _ ã« _ ã

change _ by _
å¤æ´ _ ã _ ã«

initialize local _ to _
--MISSING--

Data
ãã¼ã¿

list
ãªã¹ã

length of _
_ ã®é·ã

item _ of _
ã¢ã¤ãã  _  _ ã®

replace item _ of list _ with _
ç½®æ ã¢ã¤ãã  _ ãªã¹ã _ å¤ _

delete item _ of list _
åé¤ ã¢ã¤ãã  _ ãªã¹ã _

add _ to list _
è¿½å  _ ããªã¹ã _ ã«

join _ _
é£çµ _ _

copy _ from _
ã³ãã¼ _ ã _ ãã

to _
ã« _

find _ in _
æ¤ç´¢ _ ã _ ã®ä¸­

starting at _
ã¹ã¿ã¼ãä½ç½® _

join items of list _
ãªã¹ãã®ã¢ã¤ãã ãé£çµ _

separator _
åå²å­ _

unicode _ of _
Unicode _ ã® _

string from unicode _
Unicode _ ã®æå­å

new list length _
æ°ãããªã¹ãã®é·ã _

new byte array _
--MISSING--

free memory
ã¡ã¢ãªè§£æ¾

My Blocks
ç§ã®ãã­ãã¯

# Buttons on top of "My Blocks" category

Add a command block
ã³ãã³ããã­ãã¯ãè¿½å 

Add a reporter block
ãªãã¼ã¿ã¼ãã­ãã¯ãè¿½å 

# Make a block dialog

Enter function name:
æ©è½åãå¥å:

Comm
éä¿¡

i2c get device _ register _
i2c ããã¤ã¹åå¾ _ ã¢ãã¬ã¹ _

i2c set device _ register _ to _
i2c ããã¤ã¹è¨­å® _ ã¢ãã¬ã¹ _ ã¾ã§ _

i2c device _ read list _
i2c ããã¤ã¹ _ ãªã¹ãèª­ã¿è¾¼ã¿ _

i2c device _ write list _
i2c ããã¤ã¹ _ ãªã¹ãæ¸ãè¾¼ã¿ _

spi send _
spi éä¿¡ _

spi receive
spi åä¿¡

print _
è¡¨ç¤ºãã _

no op
ä½ãããªã

ignore
ç¡è¦ãã

##############
# Primitives #
##############

# These are all mostly hidden from end users

draw shape _ at x _ y _
å½¢ãæã _ ä½ç½® x _ y _

shape for letter _
æå­ã®å½¢ _

send NeoPixel rgb _
éä¿¡ NeoPixel RGB _

has tone support
é³ããµãã¼ã

play tone pin _ frequency _
é³åçãã³ _ å¨æ³¢æ° _

has WiFi support
WiFiããµãã¼ã

start WiFi _ password _
WiFiã®éå§ _ ãã¹ã¯ã¼ã _

stop WiFi
WiFiã®åæ­¢

WiFi status
WiFiã®ç¶æ

my IP address
ç§ã®IPã¢ãã¬ã¹

radio send number _
éä¿¡ãããæ°å­ _

radio send string _
éä¿¡ãããæå­å _

radio send pair _ = _
éä¿¡ããããã¢ _ = _

radio message received?
éä¿¡ã¡ãã»ã¼ã¸ãåä¿¡ããã?

radio last number
éä¿¡ãããææ°ã®æ°å­

radio last string
éä¿¡ãããææ°ã®æå­å

radio last message type
--MISSING--

radio set group _
éä¿¡ãããè¨­å®ã°ã«ã¼ã _

radio set channel (0-83) _
--MISSING--

radio set power (0-7) _
éä¿¡ãããè¨­å®å¼·åº¦ (0-7) _

radio last signal strength
--MISSING--

radio receive packet _
--MISSING--

radio send packet _
--MISSING--

disable radio
éä¿¡ãç¡å¹å

#############
# Libraries #
#############

Basic Sensors
åºæ¬ã®ã»ã³ãµã¼

tilt x
ä»°è§ x

tilt y
ä»°è§ y

tilt z
ä»°è§ z

acceleration
å éåº¦

light level
åå¼·åº¦

temperature (Â°C)
æ¸©åº¦ (Â°C)

####
# NeoPixel library

NeoPixel
ããªãã¯ã»ã«

set NeoPixels _ _ _ _ _ _ _ _ _ _
ããªãã¯ã»ã«ãè¨­å® _ _ _ _ _ _ _ _ _ _

clear NeoPixels
ããªãã¯ã»ã«ãã¯ãªã¢

set NeoPixel _ color _
ããªãã¯ã»ã«ãè¨­å® _ è² _

set all NeoPixels color _
ãã¹ã¦ã®ããªãã¯ã»ã«ãè¨­å® è² _

rotate NeoPixels by _
ããªãã¯ã»ã«ãåè»¢ è§åº¦ _

color r _ g _ b _ (0-255)
è² R _ G _ B _ (0-255)

random color
ã©ã³ãã ã®è²

attach _ LED NeoPixel strip to pin _
ä»ãã _ LEDåæ° ããªãã¯ã»ã« ãã³ _

has white _
ç½è² _

PIR
äººæèµ¤å¤ç·ã»ã³ãµã¼

PIR at pin _ detected movement
äººæèµ¤å¤ç·ã»ã³ãµã¼ ãã³ _ åããæ¤ç¥

####
# Citilab ED1 board libraries

ED1 Stepper Motor
ED1ã¹ãããã¢ã¼ã¿ã¼

move motor _ _ steps _
ã¢ã¼ã¿ã¼ãåãã _ _ ã¹ããã _

move motor 1 _ and motor 2 _ _ steps
ã¢ã¼ã¿ã¼1ãåãã _ ã¹ããã,ã¢ã¼ã¿ã¼2 _ _ ã¹ããã

move motor _ angle _ Â°
ã¢ã¼ã¿ã¼ãåãã _ è§åº¦ _ Â°

move motor _ _ complete turns
ã¢ã¼ã¿ã¼ãåãã _ _ åè»¢

stop steppers
ã¹ããããåæ­¢ãã

clockwise
æè¨åã

counter-clockwise
éæè¨åã

ED1 Buttons
ED1ãã¿ã³

button OK
OKãã¿ã³

button X
Xãã¿ã³

button up
ä¸ãã¿ã³

button down
ä¸ãã¿ã³

button left
å·¦ãã¿ã³

button right
å³ãã¿ã³

capacitive sensor _
éé»å®¹éã»ã³ãµã¼ _

set capacitive threshold to _
éé»å®¹éã»ã³ãµã¼ãè¨­å®ãã é¾å¤ _ 

####
# BirdBrain Technologies libraries

Hummingbird LED _ _ %
Hummingbird LED _ _ %

Hummingbird Tri-LED _ R _ % G _ % B _ %
Hummingbird ä¸è²LED _ R _ % G _ % B _ %

Hummingbird Position Servo _ _ Â°
Hummingbird ä½ç½®ãµã¼ã _ _ Â°

Hummingbird Rotation Servo _ _ %
Hummingbird åè»¢ãµã¼ã _ _ %

Hummingbird _ _
Hummingbird _ _

Hummingbird Battery (mV)
Hummingbird é»æ± å®¹é (mV)

Light
åé

Distance (cm)
è·é¢ (cm)

Dial
ç®çã

Sound
é³é

Other
ãã®ä»

Finch Beak Red _ Green _ Blue _
Finch ãã¡ã°ã èµ¤ _ ç· _ é _

Finch Tail _ Red _ Green _ Blue _
Finch ãã£ã½ èµ¤ _ ç· _ é _

Finch Move _ _ cm at _ %
Finch ç§»å _ _ cm ä½ç½® _ %

Finch Turn _ _ Â° at _ %
Finch åè»¢ _ _ Â° ä½ç½® _ %

Finch Wheels L _ % R _ %
Finch ãã¤ã¼ã« å·¦ _ % å³ _ %

Finch Stop
Finch åæ­¢

Finch Distance (cm)
Finch è·é¢ (cm)

Finch _ Light
Finch _ åé

Finch _ Line
Finch _ ç·

Finch Reset Encoders
Finch ã¨ã³ã³ã¼ãããªã»ãã

Finch _ Encoder
Finch _ ã¨ã³ã³ã¼ã

Finch Accelerometer _
Finch å éåº¦ _

Finch Battery
Finch é»æ± å®¹é

All
å¨é¨

Forward
åé²

Backward
å¾é

Right
å³æ

Left
å·¦æ

Beak Up
ãã¡ã°ããä¸ãã

Beak Down
ãã¡ã°ããä¸ãã

Tilt Left
å·¦ã¸åã

Tilt Right
å³ã¸åã

Level
ã¬ãã«

Upside Down
éãã¾

x
x

y
y

z
z

strength
å¼·åº¦

####
# Ultrasound distance library

distance (cm) trigger _ echo _
è·é¢ (cm) ããªã¬ã¼ _ ã¨ã³ã¼ _

####
# Infrared remote library

IR Remote
IR è·é¢

receive IR code
IR ã³ã¼ãåä¿¡

receive IR code from device _
IR ã³ã¼ãåä¿¡ ããã¤ã¹ _

test IR
IR ãã¹ã

attach IR receiver to pin _
IR åä¿¡æ©ãæ¥ç¶ ãã³ _

####
# Radio comm library
# Allows micro:bit boards to exchange messages
# All of its blocks are primitive (see "Primitives" section)

Radio
é»æ³¢

####
# Text scrolling library
# Scrolls text on 5x5 LED displays and simulated ones

Scrolling
ã¹ã¯ã­ã¼ã«è¡¨ç¤º

scroll text _
ã¹ã¯ã­ã¼ã«æå­ _

scroll number _
ã¹ã¯ã­ã¼ã«æ°å­ _

pausing _ ms
ä¸æåæ­¢ _ ããªç§

stop scrolling
ã¹ã¯ã­ã¼ã«åæ­¢

####
# Servo motor library

Servo
ãµã¼ã

set servo _ to _ degrees (-90 to 90)
ãµã¼ãè¨­å® _ ã _ åº¦ (-90 - 90)

set servo _ to speed _ (-100 to 100)
ãµã¼ãè¨­å® _ ã®éåº¦ _ (-100 - 100)

stop servo _
ãµã¼ãåæ­¢ _

####
# 5x5 LED display library
# Supports the micro:bit display, but also simulated 5x5 displays on boards
# with differently sized LED arrays, NeoPixel arrays or TFT displays

LED Display
LEDè¡¨ç¤º

display _
è¡¨ç¤º _

clear display
è¡¨ç¤ºã¯ãªã¢

plot x _ y _
ãã­ãããã x _ y _

unplot x _ y _
ãã­ãããæ¶ã x _ y _

display character _
æå­ãè¡¨ç¤º _

####
# TFT display library

enable TFT _
TFT æå¹å

TFT width
TFT å¹

TFT height
TFT é«ã

set TFT pixel x _ y _ to _
TFT ç»ç´ è¨­å® x _ y _ ã« _ ã

draw line on TFT from x _ y _ to x _ y _ color _
TFTä¸ã«ç·ãæã ä½ç½® x _ y _ ãã x _ y _ ã¾ã§ è² _

draw rectangle on TFT at x _ y _ width _ height _ color _
TFTä¸ã«åè§å½¢ãæã ä½ç½® x _ y _ å¹ _ é«ã _ è² _

draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _
TFTä¸ã«ä¸¸è§åè§å½¢ãæã ä½ç½® x _ y _ å¹ _ é«ã _ åå¾ _ è² _

draw circle on TFT at x _ y _ radius _ color _
TFTä¸ã«åãæã, ä½ç½® x _ y _ åå¾ _ è² _

draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _
TFTä¸ã«ä¸è§å½¢ãæã ä½ç½® x _ y _ , x _ y _ , x _ y _ è² _

filled _
åãã _

write _ on TFT at x _ y _ color _
TFTä¸ã«æã _ ä½ç½® x _ y _ è² _

scale _ wrap _
æ¡å¤§ _ ã©ãã _

####
# Tone library
# Generates music tones on buzzers

Tone
é³

attach buzzer to pin _
ãã¶ã¼ãã¤ãã ãã³ _

play note _ octave _ for _ ms
é³ç¬¦ãåç _ é³é _ é·ã _ ããªç§

play frequency _ for _ ms
å¨æ³¢æ°ãåç _ é·ã _ ããªç§

play midi key _ for _ ms
midiã­ã¼ãåç _ é·ã _ ããªç§

####
# Turtle geometry library

Turtle
ã¦ãã¬ã¡

home
ãã¼ã 

move _
ç§»å _

turn _ degrees
åã _ åº¦

turn _ / _ of circle
åã _ / _ å

pen down
ãã³ãä¸ãã

pen up
ãã³ãä¸ãã

set pen color to _
ãã³ã®è²ãè¨­å® _

set pen to random color
ãã³ã®è²ãã©ã³ãã ã«è¨­å®

fill display with _
è¡¨ç¤ºãåãã _

go to x _ y _
ç§»åãã x _ y _

point in direction _
ç¹ã®æ¹å _

####
# File system library

Files
ãã¡ã¤ã«

open file _
ãã¡ã¤ã«ãéã _

close file _
ãã¡ã¤ã«ãéãã _

delete file _
ãã¡ã¤ã«ãåé¤ _

append line _ to file _
è¡ãè¿½å  _ ãã¡ã¤ã« _

append bytes _ to file _
ãã¤ãåãè¿½å  _ ãã¡ã¤ã« _

end of file _
ãã¡ã¤ã«ã®æå¾ _

next line of file _
æ¬¡ã®è¡ ãã¡ã¤ã« _

next _ bytes of file _
æ¬¡ã®ãã¤ãå _ ãã¡ã¤ã« _

starting at _
ã¹ã¿ã¼ãä½ç½® _

file names
ãã¡ã¤ã«å

size of file _
ãã¡ã¤ã«ãµã¤ãº _

file system info
ãã¡ã¤ã«ã·ã¹ãã ã®æå ±

####
# WiFi library

WiFi
WiFi

wifi connect to _ password _ try _ times
WiFiã«æ¥ç¶ _ ãã¹ã¯ã¼ã _ ç¹°ãè¿ã _ å

wifi create hotspot _ password _
WiFiã¹ããããä½æ _ ãã¹ã¯ã¼ã _

IP address
IPã¢ãã¬ã¹

####
# Motion library
# Counts steps and detects motion via the internal accelerometer

Motion
ã¢ã¼ã·ã§ã³

motion
ã¢ã¼ã·ã§ã³

start step counter
ã¹ãããã«ã¦ã³ã¿ã¼ãå§ãã

step count
ã¹ãããã«ã¦ã³ã

clear step count
ã¹ãããã«ã¦ã³ããã¯ãªã¢

set step threshold _ (0-50)
ã¹ãããé¾å¤ãè¨­å® _ (0-50)

####
# Button Events library

Button Events
ãã¿ã³ã¤ãã³ã

button _ double pressed
ãã¿ã³ _ 2åæ¼ã

button _ long pressed
ãã¿ã³ _ é·ãæ¼ã

button _ pressed
ãã¿ã³ _ æ¼ã

####
# Calliope board library

Calliope set LED red _ green _ blue _
Calliope LEDã®è¨­å® èµ¤ _ ç· _ é _

Calliope set speaker _
Calliope ã¹ãã¼ã«ã®è¨­å® _

Calliope loudness
Calliope é³ã®å¤§ãã

####
# Circuit Playground Express board library

Circuit Playground set speaker _
Circuit Playground ã¹ãã¼ã«ã®è¨­å® _

Circuit Playground slide switch
Circuit Playground ã¹ã©ã¤ãã¹ã¤ãã

####
# DotStar LED library

attach _ DotStar LEDs to data pin _ clock pin _
æ¥ç¶ _ DotStar LEDs ãã¼ã¿ãã³ _ ã¯ã­ãã¯ãã³ _

set all DotStar LEDs to r _ g _ b _
è¨­å® ãã¹ã¦ã®DotStar LEDs ã r _ g _ b _

set DotStar LED _ to r _ g _ b _
è¨­å® DotStar LED _ ã r _ g _ b _

set DotStar brightness _
è¨­å® DotStar è¼åº¦ _

####
# BME280 environmental sensor

bme280 connected
bme280 æ¥ç¶ããã

bmp280 connected
bmp280 æ¥ç¶ããã

bmx280 temperature
bmx280 æ¸©åº¦

bmx280 pressure
bmx280 æ°å§

bme280 humidity
bme280 æ¹¿åº¦

####
# TCS34725 color sensor

TCS34725 connected
TCS34725 æ¥ç¶ããã

TCS34725 rgb
TCS34725 RGB

color _ name
è² _ åå

####
# DHT11 environmental sensor

temperature (Celsius) DHT11 pin _
æ¸©åº¦ (Celsius) DHT11 ãã³ _

humidity DHT11 pin _
æ¹¿åº¦ DHT11 ãã³ _

temperature (Celsius) DHT22 pin _
æ¸©åº¦ (Celsius) DHT22 ãã³ _

humidity DHT22 pin _
æ¹¿åº¦ DHT22 ãã³ _

####
# PN532 RFID reader

read PN532 RFID
èª­ã¿åã PN532 RFID

RFID _ = _
RFID _ = _

get PN532 firmware version
PN532 ãã¡ã¼ã ã¦ã§ã¢ãã¼ã¸ã§ã³åå¾

####
# HTTP libraries

HTTP client
HTTPã¯ã©ã¤ã¢ã³ã

_ data _ to httpÜ// _
_ ãã¼ã¿ã _ ã¸ http// _

HTTP server
HTTPãµã¼ãã¼

start HTTP server
HTTPãµã¼ãã¼ãéå§

HTTP server request
HTTPãµã¼ãã¼ã®è¦æ±

respond _ to HTTP request
HTTPãªã¯ã¨ã¹ãã®å¿ç­ _

with body _
with ããã£ _

and headers _
and ãããã¼ _

body of request _
ãªã¯ã¨ã¹ãã®ããã£ _

path of request _
ãªã¯ã¨ã¹ãã®ãã¹ _

method of request _
ãªã¯ã¨ã¹ãã®ã¡ã½ãã _

####
# Web Things library

Web Thing
Web Thing

set thing name to _
Thing ã®ååãè¨­å® _

set thing capability to _
Thing ã®ã±ã¼ãããªãã£ãè¨­å® _

set boolean property _ title _ @Type _
ãã¼ã«å±æ§ãè¨­å® _ ã¿ã¤ãã« _ @ã¿ã¤ã _

set string property _ title _ @Type _
æå­åå±æ§ãè¨­å® _ ã¿ã¤ãã« _ @ã¿ã¤ã _

set number property _ title _ @Type _
æ°å¤å±æ§ãè¨­å® _ ã¿ã¤ãã« _ @ã¿ã¤ã _

set number property _ title _ min _ max _ @Type _
æ°å¤å±æ§ãè¨­å® _ ã¿ã¤ãã« _ æå° _ æå¤§ _ @ã¿ã¤ã _

read only _
èª­ã¿åºãå°ç¨ _

register event _ type _
ç»é²ã¤ãã³ã _ ã¿ã¤ã _

start WebThing server
WebThingãµã¼ãã¼ãéå§

trigger event _
ããªã¬ã¼ã¤ãã³ã _

thing description JSON
Thing ã®èª¬æ JSON

properties JSON
JSON å±æ§

event definitions JSON
ã¤ãã³ãå®ç¾© JSON

events JSON
ã¤ãã³ã JSON

##################
# MicroBlocks UI #
##################

# buttons, error & info messages, dialog boxes, etc

New
æ°è¦

Open
éã

Open from board
--MISSING--

Information
--MISSING--

Plug in the board.
--MISSING--

Reading project from board...
--MISSING--

Loading project...
--MISSING--

Found a newer version of
--MISSING--

Do you want me to update the one in the project?
--MISSING--

Save
ä¿å­

Connect
æ¥ç¶

disconnect
åæ­

Serial port:
ã·ãªã¢ã«ãã¼ã:

other...
ãã®ä»...

none
ãªã

Port name?
ãã¼ãå?

Board type:
ãã¼ãã¿ã¤ã:

Select board:
ãã¼ãé¸æ:

Could not read:
èª­ããªãã£ã:

by
ã¾ã§

Created with GP
GPã«ãã£ã¦ä½æ

More info at http://microblocks.fun
ããå¤ãã®æå ±ã¯ http://microblocks.fun

Function "
é¢æ° "

" is too large to send to board.
" ãã¼ãã«éä¿¡ããã«ã¯å¤§ãéãã¾ã.

Script is too large to send to board.
ãã¼ãã«éä¿¡ããã«ã¯ã¹ã¯ãªãããå¤§ãéãã¾ã.

Use "Connect" button to connect to a MicroBlocks device.
MicroBlocksããã¤ã¹ã«æ¥ç¶ããã«ã¯,"æ¥ç¶"ãã¿ã³ãä½¿ç¨ãã¦ãã ãã.

No boards found; is your board plugged in?
ãã¼ããè¦ã¤ããã¾ããï¼ãã¼ããæ¥ç¶ããã¦ãã¾ãã?

For AdaFruit boards, double-click reset button and try again.
AdaFruitãã¼ãã®å ´åï¼resetãã¿ã³ãããã«ã¯ãªãã¯ãã¦ååº¦å®æ½ãã¦ãã ãã.

The board is not responding.
ãã¼ããå¿ç­ãã¦ãã¾ãã.

Try to Install MicroBlocks on the board?
ãã¼ãã¸MicroBlocksã®ã¤ã³ã¹ãã¼ã«ãè©¦ãã¦ããã¾ãã?

The MicroBlocks in your board is not current
ãã¼ãã®MicroBlocksãææ°ã§ã¯ããã¾ãã

Try to update MicroBlocks on the board?
ãã¼ãã®MicroBlocksã®æ´æ°ãè©¦ãã¦ããã¾ãã?

Stop
åæ­¢

Start
éå§

Quit MicroBlocks?
MicroBlocksãæ­¢ãã¾ãã?

Discard current project?
ç¾å¨ã®ãã­ã¸ã§ã¯ããç ´æ£ãã¾ãã?

clean up
ã¯ãªã¢ãã

arrange scripts
ã¹ã¯ãªãããç·¨éãã

undrop (ctrl-Z)
åã«æ»ã (ctrl-Z)

copy all scripts to clipboard
ãã¹ã¦ã®ã¹ã¯ãªãããã¯ãªãããã¼ãã¸ã³ãã¼ãã

paste all scripts
ãã¹ã¦ã®ã¹ã¯ãªãããè²¼ãä»ãã

paste script
ã¹ã¯ãªãããè²¼ãä»ãã

save a picture of all scripts
ããºã¦ã®ã¹ã¯ãªããã®ç»é¢ãä¿å­ãã

about...
...ã«ã¤ãã¦

virtual machine version
ä»®æ³ãã·ã³ã®ãã¼ã¸ã§ã³

update firmware on board
ãã¼ãä¸ã®ãã¡ã¼ã ã¦ã§ã¢ãæ´æ°

show data graph
ã°ã©ããè¡¨ç¤º

set serial delay
ã·ãªã¢ã«éåº¦ãè¨­å®

firmware version
ãã¡ã¼ã ã¦ã§ã¢ãã¼ã¸ã§ã³

start WebThing server
WebThingãµã¼ãã¼ãéå§

stop WebThing server
WebThingãµã¼ãã¼ãåæ­¢

HTTP Server
--MISSING--

MicroBlocks HTTP Server listening on port 6473
MicroBlocks HTTPãµã¼ãã¼ã®ãã¼ãçªå· 6473

disable autoloading board libraries
ãã¼ãã©ã¤ãã©ãªã®èªåèª­ã¿è¾¼ã¿ãç¡å¹å

enable autoloading board libraries
ãã¼ãã©ã¤ãã©ãªã®èªåèª­ã¿è¾¼ã¿ãæå¹å

enable PlugShare when project empty
--MISSING--

disable PlugShare when project empty
--MISSING--

erase flash and update firmware on ESP board
ESPãã¼ãä¸ã®ãã¡ã¼ã ã¦ã§ã¢ãæ¶å»ãã¦æ´æ°

Use board type
ä½¿ç¨ãããã¼ãã¿ã¤ã

Wiping board...
ãã¼ããæ¶å»ä¸­...

(press ESC to cancel)
(ESCãæ¼ãã¦åæ¶)

Done!
å®æ!

download and install latest VM
ææ°ã®VMããã¦ã³ã­ã¼ããã¦ã¤ã³ã¹ãã¼ã«

Select board type:
ãã¼ãã¿ã¤ããé¸æ:

Uploading MicroBlocks to board...
ãã¼ãã¸MicroBlocksãã¢ããã­ã¼ãä¸­...

copy data to clipboard
ãã¼ã¿ãã¯ãªãããã¼ãã¸ã³ãã¼

clear data
ãã¼ã¿ãã¯ãªã¢

clear memory and variables
ã¡ã¢ãªã¼ã¨å¤æ°ãã¯ãªã¢

show advanced blocks
é«åº¦ãªãã­ãã¯ãè¡¨ç¤º

export functions as library
é¢æ°ãã©ã¤ãã©ãªã¨ãã¦åºå

hide advanced blocks
é«åº¦ãªãã­ãã¯ãé ã

Data Graph
ãã¼ã¿ã°ã©ã

show instructions
æé ãè¡¨ç¤º

show compiled bytes
ã³ã³ãã¤ã«ããããã¤ããè¡¨ç¤º

expand
å±é

collapse
ç¸®å°

rename...
ååãå¤æ´...

show block definition...
ãã­ãã¯å®ç¾©ãè¡¨ç¤º...

show the definition of this block
ãã®ãã­ãã¯ã®å®ç¾©ãè¡¨ç¤º

delete block definition...
ãã­ãã¯å®ç¾©ãåé¤...

delete the definition of this block
ãã®ãã­ãã¯ã®å®ç¾©ãåé¤

duplicate
è¤è£½

duplicate this block
ãã®ãã­ãã¯ãè¤è£½

delete block
ãã­ãã¯ãåé¤

delete this block
ãã®ãã­ãã¯ãåé¤

just this one block
ãã®1ã¤ã®ãã­ãã¯

copy to clipboard
ã¯ãªãããã¼ãã«ã³ãã¼

copy these blocks to the clipboard
ãããã®ãã­ãããã¯ãªãããã¼ãã«ã³ãã¼

duplicate all
ãã¹ã¦ãè¤è£½

duplicate these blocks
ãããã®ãã­ãã¯ãè¤è£½

extract block
ãã­ãã¯ãå±é

pull out this block
ãã®ãã­ãã¯ãæãããã

save picture of script
ã¹ã¯ãªããã®ç»é¢ãä¿å­

save a picture of this block definition as a PNG file
ãã®ãã­ãã¯å®ç¾©ã®ç»é¢ãPNGãã¡ã¤ã«ã§ä¿å­

save a picture of these blocks as a PNG file
ãããã®ãã­ãã¯ã®ç»é¢ãPNGãã¡ã¤ã«ã§ä¿å­

copy script
ã¹ã¯ãªãããã³ãã¼

delete
åé¤

Input type:
å¥åã¿ã¤ã:

string only
æå­åã®ã¿

string or number
æå­åã¾ãã¯æ°å­

number only
æ°å­ã®ã¿

define
å®ç¾©

number/string
æ°å­/æå­å

editable number or string
ç·¨éå¯è½ãªæ°å­ã¾ãã¯æå­å

label
ã©ãã«

input
å¥å

hide block definition
ãã­ãã¯å®ç¾©ãé ã

Are you sure you want to remove this block definition?
ãã®ãã­ãã¯å®ç¾©ãåé¤ãã¦ãããã§ãã?

Language
è¨èª

Custom...
ã«ã¹ã¿ã ...

Obsolete
å»æ­¢

OK
ç¢ºå®

Ok
ç¢ºå®

Yes
ã¯ã

No
ããã

Cancel
åæ¶

Okay
ç¢ºå®

Confirm
ç¢ºèª

# File picker and library dialogs

Libraries
ã©ã¤ãã©ãª

Examples
ä¾

Desktop
ãã¹ã¯ããã

Computer
ã³ã³ãã¥ã¼ã¿

Cloud
ã¯ã©ã¦ã

File
ãã¡ã¤ã«

File Open
ãã¡ã¤ã«ãéã

File Save
ãã¡ã¤ã«ä¿å­

File name:
ãã¡ã¤ã«å:

New Folder
æ°ãããã©ã«ã

by
ã¾ã§

Depends:
ä¾å­:

Tags:
ã¿ã°:

Path, name or URL for library?
ã©ã¤ãã©ãªã®å ´æ,ååã¾ãã¯URLã¯?

Invalid URL
ééã£ãURL

Could not fetch library.
ã©ã¤ãã©ãªãåå¾ã§ããªãã£ã.

Host does not exist or is currently down.
ãã¹ããå­å¨ããªã,ã¾ãã¯ç¾å¨ãã¦ã³ãã¦ãã.

File not found in server.
ãµã¼ãã«ãã¡ã¤ã«ãè¦ã¤ãããªã.

Server expects HTTPS, and MicroBlocks doesn't currently support it.
ãµã¼ãã¼ã¯HTTPSãæå¾ãã¦ãããï¼MicroBlocksã¯ç¾å¨ãµãã¼ãããã¦ããªã.

library information
ã©ã¤ãã©ãªã®æå ±

built-in library
çµã¿è¾¼ã¿ã©ã¤ãã©ãª

Dependency path, name or URL?
ä¾å­ããå ´æ,ååã¾ãã¯URLã¯?

Tag name?
ã¿ã°ã®ååã¯?

# MicroBlocks translation file
# Last updated: November 29 2022

#########################
# Blocks and categories #
#########################

Output
è¾åº

set user LED _
è®¾ç½®ç¨æ· LED _

say _
è¯´ _

graph _
ç»å¾ _

Input
è¾å¥

button A
æé® A

button B
æé® B

timer
è®¡æ¶å¨

reset timer
è®¡æ¶å¨å½é¶

microseconds
å¾®ç§

milliseconds
æ¯«ç§

board type
ä¸»æ¿ç±»å

Pins
å¼è

read digital pin _
è¯»åæ°å­å¼è _

read analog pin _
è¯»åæ¨¡æå¼è _

pullup _
ä¸æ _

set digital pin _ to _
è®¾ç½®æ°å­å¼è _ ä¸º _

set pin _ to _
è®¾ç½®å¼è _ ä¸º _

analog pins
æ¨¡æå¼è

digital pins
æ°å­å¼è

Control
æ§å¶

when started
å½å¯å¨æ¶

when button _ pressed
å½æé® _ è¢«æä¸

forever _
éå¤æ§è¡ _

repeat _ _
éå¤ _ æ¬¡ _

wait _ millisecs
ç­å¾ _ æ¯«ç§

if _ _
å¦æ _ _

if _ _ else _
å¦æ _ _ å¦å _

else if _ _
å¦å,å¦æ _ _

else
å¦å

when _
å½ _

wait until _
ç´å° _ åé½ç­å¾

wait _ microsecs
ç­å¾ _ å¾®ç§

return _
è¿å _

when _ received
å½æ¥æ¶å° _

broadcast _
å¹¿æ­ _

comment _
æ³¨é _

How this works...
...

range _ to _
ä» _ å° _ çæ°å­åè¡¨ 

by _
é´é _

rescale _ from ( _ , _ ) to ( _ , _ )
æ å° _ ä» ( _ , _ ) å° ( _ , _ )

for _ in _ _
éå¤æ§è¡ ååå å­ _ èå´ _ _

repeat until _ _
éå¤æ§è¡ ç´å° _ _

stop this task
åæ­¢å½åä»»å¡

stop other tasks
åæ­¢å¶ä»ä»»å¡

stop all
åæ­¢å¨é¨

last message
æåæ¶æ¯

call _
è°ç¨ _

with _
åæ° _

Operators
è¿ç®

_ mod _
_ é¤ä»¥ _ çä½æ°

abs _
ç»å¯¹å¼ _

min _ _
æå°å¼ _ _

max _ _
æå¤§å¼ _ _

random _ to _
å¨ _ å° _ ä¹é´éåéæºæ°

not _
_ ä¸æç«

_ and _
_ ä¸ _

and _
ä¸ _

_ or _
_ æ _

or _
æ _

_ is a _
_ çç±»åæ¯ _

convert _ to _
æ _ è½¬åä¸º _

boolean
å¸å°

number
æ°å­

string
å­ç¬¦ä¸²

list
åè¡¨

byte array
å­èæ°ç»

Advanced:
é«çº§

hex _
åå­è¿å¶ _

Variables
åé

# Buttons on top of "Variables" category

Add a variable
æ°å»ºä¸ä¸ªåé

Delete a variable
å é¤ä¸ä¸ªåé

# New variable dialog

New variable name?
æ°åéçåå­æ¯ï¼

set _ to _
æ _ è®¾å®ä¸º _

change _ by _
æ _ å¢å  _

initialize local _ to _
å°æ¬å°ç _ åå§åä¸º _

Data
æ°æ®

list
åè¡¨

length of _
_ çé¿åº¦

item _ of _
ç¬¬ _ é¡¹ _

replace item _ of list _ with _
æç¬¬ _ é¡¹ _ æ¿æ¢ä¸º _

delete item _ of list _
å é¤ç¬¬ _ é¡¹ _

add _ to list _
æ·»å  _ è³åè¡¨ _

join _ _
è¿æ¥ _ _

copy _ from _
å¤å¶ _ ä» _

to _
å° _

find _ in _
æ¥æ¾ _ å¨ _ ä¸­

starting at _
å¼å§äº _

join items of list _
è¿æ¥åè¡¨ä¸­çé¡¹ç® _

separator _
åéç¬¦ _

unicode _ of _
Unicode ç¬¬ _ ä¸ªå­ç¬¦æ¥èª _

string from unicode _
unicodeä¸º _ çå­ç¬¦

new list length _
æ°å»ºé¿åº¦ä¸º _ çåè¡¨

new byte array _
æ°å»ºå­èæ°ç» _

as byte array _
ä½ä¸ºå­èæ°ç» _

with all _
å¡«å _

free memory
é²ç½®åå­

all
ææ

last
æå

random
éæº

split _ by _
åå² _ éè¿ _

My Blocks
æçç§¯æ¨

Generic
éç¨

# Buttons on top of "My Blocks" category

Add a command block
æ°å»ºå½ä»¤ç§¯æ¨

Add a reporter block
æ°å»ºæ¥åç§¯æ¨

# Make a block dialog

Enter function name:
è¾å¥ç§¯æ¨åç§°:

Comm
éä¿¡

i2c get device _ register _
i2c è¯»åè®¾å¤ _ å¯å­å¨ _

i2c set device _ register _ to _
i2c è®¾ç½®è®¾å¤ _ å¯å­å¨ _ ä¸º _

i2c device _ read list _
i2c è®¾å¤ _ è¯»ååè¡¨ _

i2c device _ write list _
i2c è®¾å¤ _ åå¥åè¡¨ _

spi send _
spi åé _

spi receive
spi æ¥æ¶

spi setup speed _
spi è®¾ç½®éç _

mode _
æ¨¡å¼ _

rpi channel _
rpi éé _

spi exchange bytes _
spi äº¤æ¢ å­è _

serial open _ baud
ä¸²å£æå¼ _ æ³¢ç¹ç

serial close
ä¸²å£å³é­

serial read
ä¸²å£è¯»å

serial write _
ä¸²å£åå¥ _

serial write _ starting at _
ä¸²å£åå¥ _ å¼å§äº _

soft serial write byte _ pin _ baud _
è½¯ä¸²å£åå¥ å­è _ å¼è _ éç _

print _
æå° _

no op
no op

ignore
å¿½ç¥

##############
# Primitives #
##############

# These are all mostly hidden from end users

draw shape _ at x _ y _
ç»å¶å½¢ç¶ _ äº x _ y _

shape for letter _
å­æ¯ _ çå½¢ç¶

send NeoPixel rgb _
å NeoPixel åé RGB _

has tone support
å·æé³è°æ¯æ

play tone pin _ frequency _
æ­æ¾é³è°äºå¼è _ é¢ç _

has WiFi support
å·æ WiFi æ¯æ

start WiFi _ password _
å¼å¯ WiFi _ å¯ç  _

stop WiFi
åæ­¢ WiFi

WiFi status
WiFi ç¶æ

my IP address
æç IP å°å

radio send number _
å¹¿æ­åéæ°å­ _

radio send string _
å¹¿æ­åéå­ç¬¦ä¸² _

radio send pair _ = _
å¹¿æ­åééå¯¹ä¿¡æ¯ _ = _

radio message received?
å¹¿æ­æ¶æ¯å·²æ¶å°?

radio last number
æåå¹¿æ­çæ°å­

radio last string
æåå¹¿æ­çå­ç¬¦ä¸²

radio last message type
æåå¹¿æ­çæ¶æ¯ç±»å

radio set group _ (0-255)
è®¾ç½®å¹¿æ­åç» _ (0-255)

radio set channel (0-83) _
è®¾ç½®å¹¿æ­ä¿¡é (0-83) _

radio set power (0-7) _
è®¾ç½®å¹¿æ­ä¿¡å·å¼ºåº¦ (0-7) _

radio last signal strength
æåå¹¿æ­çä¿¡å·å¼ºåº¦

radio receive packet _
å¹¿æ­æ¶å°å _

radio send packet _
å¹¿æ­åéå _

disable radio
ç¦æ­¢å¹¿æ­

#############
# Libraries #
#############

Basic Sensors
åºç¡ä¼ æå¨

tilt x
å¾è§ x

tilt y
å¾è§ y

tilt z
å¾è§ z

acceleration
å éåº¦

light level
åçº¿å¼ºåº¦

temperature (Â°C)
æ¸©åº¦ (Â°C)

magnetic field
ç£åº

set acceleration range _ g = 100
è®¾ç½®å éåº¦èå´ _ g = 100

####
# NeoPixel library

NeoPixel
NeoPixel

set NeoPixels _ _ _ _ _ _ _ _ _ _
è®¾ç½® NeoPixels _ _ _ _ _ _ _ _ _ _

clear NeoPixels
å³é­ NeoPixels

set NeoPixel _ color _
è®¾ç½® NeoPixel _ é¢è² _

set all NeoPixels color _
è®¾ç½®ææ NeoPixels çé¢è²ä¸º _

rotate NeoPixels by _
è½®è½¬ NeoPixel é´è· _

brighten NeoPixel _ by _
NeoPixel _ äº®åº¦å¢å  _

brighten all NeoPixels by _
ææ NeoPixels äº®åº¦å¢å  _

color r _ g _ b _ (0-255)
é¢è² R _ G _ B _ (0-255)

random color
éæºé¢è²

attach _ LED NeoPixel strip to pin _
å° _ ä¸ª LED NeoPixel ç¯å¸¦ è¿æ¥å°å¼è _

has white _
å·æç½å _

PIR
äººä½çº¢å¤ä¼ æå¨

PIR at pin _ detected movement
ä½äºå¼è _ çäººä½çº¢å¤ä¼ æå¨æ¢æµå°è¿å¨


#### NeoPanel library

NeoPanel
åç´ å±

attach NeoPixel panel width _ height _ at pin _
å°å®½åº¦ _ é«åº¦ _ çåç´ å±è¿æ¥å°å¼è _

NeoPanel set x _ y _ color _
åç´ å±è®¾ç½® x _ y _ é¢è² _

NeoPanel fill column _ color _
åç´ å±ç»å¶ å _ é¢è² _

NeoPanel fill row _ color _
åç´ å±ç»å¶ è¡ _ é¢è² _

NeoPanel fill rectangle x _ y _ width _ height _ color _
åç´ å±ç»å¶é¿æ¹å½¢ x _ y _ å®½åº¦ _ é«åº¦ _ é¢è² _

NeoPanel draw text _ at x _ y _ color _
åç´ å±ç»å¶ææ¬ _ äº x _ y _ é¢è² _

NeoPanel draw BMP file _ at x _ y _
åç´ å±ç»å¶BMPå¾ç _ äº x _ y _

####
# Microphone library

Microphone
éº¦åé£

microphone
éº¦åé£

turn on microphone
æå¼éº¦åé£

loudness
é³éå¤§å°

clap count
æææ¬¡æ°

set clap threshold _
è®¾ç½®ææéå¼ _

estimate clap threshold
ä¼°è®¡ææéå¼

####
# Citilab ED1 board libraries

ED1 Stepper Motor
ED1 æ­¥è¿çµæº

move motor _ _ steps _
é©¬è¾¾è¿å¨ _ _ æ­¥ _

move motor 1 _ and motor 2 _ _ steps
é©¬è¾¾1è¿å¨ _ æ­¥,åæ¶é©¬è¾¾2è¿å¨ _ _ æ­¥

move motor _ angle _ Â°
è½¬å¨é©¬è¾¾ _ è§åº¦ _ Â°

move motor _ _ complete turns
è½¬å¨é©¬è¾¾_ _ æ´å

stop steppers
åæ­¢æ­¥è¿çµæº

clockwise
é¡ºæ¶é

counter-clockwise
éæ¶é

ED1 Buttons
ED1æé®

button OK
OKæé®

button X
Xæé®

button up
åä¸é®

button down
åä¸é®

button left
åå·¦é®

button right
åå³é®

capacitive sensor _
çµå®¹å¼ä¼ æå¨ _

set capacitive threshold to _
å°çµå®¹é¨éå¼è®¾ä¸º _

####
# BirdBrain Technologies libraries

Hummingbird LED _ _ %
Hummingbird LED _ _ %

Hummingbird Tri-LED _ R _ % G _ % B _ %
Hummingbird å½©è²LED _ R _ % G _ % B _ %

Hummingbird Position Servo _ _ Â°
Hummingbird ä½ç½®ä¼ºæ _ _ Â°

Hummingbird Rotation Servo _ _ %
Hummingbird æè½¬ä¼ºæ _ _ %

Hummingbird _ _
Hummingbird _ _

Hummingbird Battery (mV)
Hummingbird çµæ±  (mV)

Light
äº®åº¦

Distance (cm)
è·ç¦» (cm)

Dial
Dial

Sound
å£°é³

Other
å¶ä»

Finch Beak Red _ Green _ Blue _
Finch åé¨ çº¢ _ ç»¿ _ è _

Finch Tail _ Red _ Green _ Blue _
Finch å°¾é¨ çº¢ _ ç»¿ _ è _

Finch Move _ _ cm at _ %
Finch ç§»å¨ _ _ åç±³ ä½äº _ %

Finch Turn _ _ Â° at _ %
Finch æè½¬ _ _ Â° ä½äº _ %

Finch Wheels L _ % R _ %
Finch è½®å­ å·¦ _ % å³ _ %

Finch Stop
åæ­¢ Finch

Finch Distance (cm)
Finch è·ç¦» (åç±³)

Finch _ Light
Finch _ åçº¿

Finch _ Line
Finch _ ç»çº¿

Finch Reset Encoders
Finch éç½®ç¼ç å¨

Finch _ Encoder
Finch _ ç¼ç å¨

Finch Accelerometer _
Finch å éåº¦ _

Finch Battery
Finch çµæ± é

All
å¨é¨

Forward
åè¿

Backward
åé

Right
å³è½¬

Left
å·¦è½¬

Beak Up
åé¨ä¸æ¹

Beak Down
åé¨ä¸æ¹

Tilt Left
å·¦ä¾§å¾è§

Tilt Right
å³ä¾§å¾è§

Level
çº§å«

Upside Down
é¢ å

x
x

y
y

z
z

strength
å¼ºåº¦

####
# Ultrasound distance library

distance (cm) trigger _ echo _
è·ç¦» (cm) è§¦å _ åå£° _

####
# Infrared remote library

IR Remote
çº¢å¤çº¿

receive IR code
æ¥æ¶çº¢å¤ç¼ç 

receive IR code from device _
ä»è®¾å¤ _ æ¥æ¶çº¢å¤ç¼ç 

test IR
æµè¯çº¢å¤

attach IR receiver to pin _
è¿æ¥çº¢å¤æ¥æ¶å¨è³å¼è _

IR transmit device _ command _
çº¢å¤åå° è®¾å¤ _ æä»¤ _

#### 
# Keyboard and Mouse

Keyboard and Mouse
é®çä¸é¼ æ 

press key _
æä¸ _ é®

while holding _
åæ¶æä½ _ é®

hold key _
æç»­æä½ _ é®

release key _
æ¾å¼ _ é®

release all keys
æ¾å¼æææé®

_ mouse click
ç¹å»é¼ æ  _ é®

move mouse pointer by _ , _
ç§»å¨é¼ æ ç®­å¤´ ååé _ , _

scroll mouse by _
æ»å¨é¼ æ  ååé _

hold _ mouse button
æç»­æä½é¼ æ  _ é®

release mouse buttons
æ¾å¼é¼ æ æé®

####
# Radio comm library
# Allows micro:bit boards to exchange messages
# All of its blocks are primitive (see "Primitives" section)

Radio
å¹¿æ­

####
# Text scrolling library
# Scrolls text on 5x5 LED displays and simulated ones

Scrolling
æ»å¨æ¾ç¤º

scroll text _
æ»å¨æ¾ç¤ºæå­ _

scroll number _
æ»å¨æ¾ç¤ºæ°å­ _

pausing _ ms
æå _ æ¯«ç§

stop scrolling
åæ­¢æ»å¨

####
# Servo motor library

Servo
èµæº

set servo _ to _ degrees (-90 to 90)
è®¾ç½®èµæº _ çè§åº¦ä¸º _ åº¦ (-90 å° 90)

set servo _ to speed _ (-100 to 100)
è®¾ç½®360åº¦èµæº _ çéåº¦ä¸º _ (-100 å° 100)

stop servo _
åæ­¢èµæº _

####
# 5x5 LED display library
# Supports the micro:bit display, but also simulated 5x5 displays on boards
# with differently sized LED arrays, NeoPixel arrays or TFT displays

LED Display
LED æ¾ç¤º

display _
æ¾ç¤º _

clear display
æ¸é¤æ¾ç¤º

plot x _ y _
ç¹äº® x _ y _

unplot x _ y _
çç­ x _ y _

display character _
æ¾ç¤ºå­ç¬¦ _

####
# TFT display library

enable TFT _
å¯ç¨ TFT _

TFT width
TFTå®½åº¦

TFT height
TFTé«åº¦

set TFT pixel x _ y _ to _
è®¾ç½® TFT-åç´  x _ y _ ä¸º _

draw line on TFT from x _ y _ to x _ y _ color _
å¨TFTä¸ç»å¶ç´çº¿ä» x _ y _ è³ x _ y _ é¢è² _

draw rectangle on TFT at x _ y _ width _ height _ color _
å¨TFTä¸ç»å¶é¿æ¹å½¢,ä½ç½® x _ y _ å®½åº¦ _ é«åº¦ _ é¢è² _

draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _
å¨TFTä¸ç»å¶åè§é¿æ¹å½¢, ä½ç½® x _ y _ å®½åº¦ _ é«åº¦ _ åå¾ _ é¢è² _

draw circle on TFT at x _ y _ radius _ color _
å¨TFTä¸ç»å¶åå½¢, ä½ç½® x _ y _ åå¾ _ é¢è² _

draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _
å¨TFTä¸ç»å¶ä¸è§å½¢, ä½ç½® x _ y _ , x _ y _ , x _ y _ é¢è² _

filled _
å¡«å _

write _ on TFT at x _ y _ color _
å¨TFTä¸å _ ä½ç½® x _ y _ é¢è² _

scale _ wrap _
scale _ wrap _

####
# BMP library
# Can display BMP image files on a TFT display

display BMP file _
æ¾ç¤º BMP æä»¶ _

####
# HSV color library

HSV Colors
HSV é¢è²

RGB of hue _ saturation _ brightness _ (0-100)
è²ç¸ _ é¥±ååº¦ _ äº®åº¦ _ (0-100) ç RGB

####
# Fractions library

Fractions
åæ°

fract _ / _
åæ° _ / _

fract _ + _
åæ° _ + _

fract _ â _
åæ° _ - _

fract _ Ã _
åæ° _ Ã _

fract _ = _
åæ° _ = _

fract _ < _
åæ° _ < _

fract _ > _
åæ° _ > _

simplify fraction _
ç®ååæ° _

integer part of fraction _
åæ°çæ´æ°é¨å _

numerator of fraction _
åæ°çåå­ _

denominator of fraction _
åæ°çåæ¯ _

gcd _ _
æå¤§å¬çº¦æ° _ _

lcm _ _
æå°å¬åæ° _ _


####
# Tone library
# Generates music tones on buzzers

Tone
é³è°

attach buzzer to pin _
è¿æ¥èé¸£å¨è³å¼è _

play note _ octave _ for _ ms
å¼¹å¥é³ç¬¦ _ é³é¶ _ æç»­ _ æ¯«ç§

play frequency _ for _ ms
å¼¹å¥é¢ç _ æç»­ _ æ¯«ç§

play midi key _ for _ ms
å¼¹å¥midié® _ æç»­ _ æ¯«ç§

start tone _ Hz
å¼¹å¥é³è° _ èµ«å¹

stop tone
åæ­¢é³è°

####
# Ringtone library
# Can play Nokring-formatted music. Also known as RTTTL.

Ringtone
éå£°

play ringtone _
æ­æ¾éå£° _

current song name
å½åæ­æ²å

####
# Pluck
# Generate music with plucked-string resembling sounds

Pluck
Pluck

pluck note _ octave _ for _ ms
pluck note _ octave _ for _ ms

pluck MIDI key _ for _ msecs
pluck MIDI key _ for _ msecs

set pluck pin _
set pluck pin _

####
# WAV
# Play WAV sound files

play WAV file _
æ­æ¾ WAV æä»¶ _

####
# Turtle geometry library

Turtle
æµ·é¾

home
åå°èµ·ç¹

move _
åè¿ _

turn _ degrees
æè½¬ _ åº¦

turn _ / _ of circle
æè½¬ _ / _ ä¸ªå

pen down
è½ç¬

pen up
æ¬ç¬

set pen color to _
å°ç»ç¬é¢è²è®¾ç½®ä¸º _

set pen to random color
å°ç»ç¬è®¾ç½®ä¸ºéæºé¢è²

fill display with _
ç¨ _ å¡«åè§åº

go to x _ y _
ç§»å¨å° x _ y _

point in direction _
é¢å _

####
# File system library

Files
æä»¶

open file _
æå¼æä»¶ _

close file _
å³é­æä»¶ _

delete file _
å é¤æä»¶ _

append line _ to file _
å°è¡ _ æ·»å è³æä»¶ _

append bytes _ to file _
å°å­è _ æ·»å è³æä»¶ _

end of file _
æä»¶ _ ç»æ

next line of file _
æä»¶ _ çä¸ä¸è¡

next _ bytes of file _
æ¥ä¸æ¥ç _ å­è ä»æä»¶ _

starting at _
å¼å§äº _

file names
æä»¶å

size of file _
æä»¶ _ çå¤§å°

file system info
æä»¶ç³»ç»ä¿¡æ¯

####
# Strings
# string (text) processing functions

Strings
å­ç¬¦ä¸²

_ is a digit
_ æ¯æ°å­

_ is lowercase
_ æ¯å°åå­æ¯

_ is uppercase
_ æ¯å¤§åå­æ¯

_ begins with _
_ ä»¥ _ å¼å¤´

_ ends with _
_ ä»¥ _ ç»å°¾

_ contains _
_ åå« _

lowercase _
å°å _

uppercase _
å¤§å _

_ without white space
_ ç§»é¤ç©ºæ ¼

join string list _ separator _
è¿æ¥æå­ç¬¦ä¸² åè¡¨ _ åéç¬¦ _

unicodes _
unicodes _

string from unicodes _
å° unicodes _ è½¬ä¸ºå­ç¬¦ä¸²

num2str _
æ°å­ _ è½¬ä¸ºå­ç¬¦ä¸²

str2num _
å­ç¬¦ä¸² _ è½¬ä¸ºæ°å­

####
# WiFi library

WiFi
WiFi

wifi connect to _ password _
è¿æ¥ wifi è³ _ å¯ç  _

IP _ gateway _ subnet _
IP å°å _ ç½å³ _ å­ç½æ©ç  _

wifi create hotspot _ password _
åå»º wifi ç­ç¹ _ å¯ç  _

IP address
IP å°å

MAC address
MAC å°å

####
# Motion library
# Counts steps and detects motion via the internal accelerometer

Motion
è¿å¨

motion
è¿å¨

start step counter
å¯å¨è®¡æ­¥å¨

step count
æ­¥æ°

clear step count
æ¸é¤æ­¥æ°

set step threshold _ (0-50)
è®¾ç½®è®¡æ­¥éå¼ _ (0-50)

####
# Button Events library

Button Events
æé®äºä»¶

button _ double pressed
æé® _ è¢«åå»

button _ long pressed
æé® _ è¢«é¿æ

button _ pressed
æé® _ è¢«ç¹å»

####
# Calliope board library

Calliope set LED red _ green _ blue _
Calliope è®¾ç½® LED çº¢ _ ç»¿ _ è _

Calliope set speaker _
Calliope è®¾ç½®æ¬å£°å¨ _

Calliope loudness
Calliope ååº¦

####
# Circuit Playground Express board library

Circuit Playground set speaker _
Circuit Playground è®¾ç½®æ¬å£°å¨ _

Circuit Playground slide switch
Circuit Playground æ»å¨å¼å³

####
# DotStar LED library

attach _ DotStar LEDs to data pin _ clock pin _
è¿æ¥ _ DotStar LEDs è³æ°æ®å¼è _ æ¶éå¼è _

set all DotStar LEDs to r _ g _ b _
è®¾ç½®ææ DotStar LEDs ä¸º r _ g _ b _

set DotStar LED _ to r _ g _ b _
è®¾ç½® DotStar LED _ ä¸º r _ g _ b _

set DotStar brightness _
è®¾ç½® DotStar äº®åº¦ _

####
# BME280 environmental sensor

bme280 connected
bme280 å·²è¿æ¥

bmp280 connected
bmp280 å·²è¿æ¥

bmx280 temperature
bmx280 æ¸©åº¦

bmx280 pressure
bmx280 åå

bme280 humidity
bme280 æ¹¿åº¦

####
# TCS34725 color sensor

TCS34725 connected
TCS34725 å·²è¿æ¥

TCS34725 rgb
TCS34725 RGB

color _ name
é¢è² _ åå­

####
# DHT11 environmental sensor

temperature (Celsius) DHT11 pin _
æ¸©åº¦ (Celsius) DHT11 å¼è _

humidity DHT11 pin _
æ¹¿åº¦ DHT11 å¼è _

temperature (Celsius) DHT22 pin _
æ¸©åº¦ (Celsius) DHT22 å¼è _

humidity DHT22 pin _
æ¹¿åº¦ DHT22 å¼è _

####
# PN532 RFID reader

read PN532 RFID
è¯»å PN532 RFID

RFID _ = _
RFID _ = _

get PN532 firmware version
PN532 åºä»¶çæ¬

####
# HTTP Client

HTTP client
HTTP å®¢æ·ç«¯

_ data _ to httpÜ// _ 
_ æ°æ® _ å° httpÜ// _ 

port _
ç«¯å£ _

####
# HTTP Server

HTTP server
HTTP æå¡å¨

start HTTP server
å¯å¨ HTTP æå¡å¨

HTTP server request
HTTP æå¡å¨è¯·æ±

respond _ to HTTP request
ååº _ è³HTTPè¯·æ±

with body _
with body _

and headers _
and headers _

body of request _
è¯·æ±ä½ _

path of request _
è¯·æ±è·¯å¾ _

headers of request _
è¯·æ±å¤´ _

method of request _
è¯·æ±æ¹æ³ _

content length of request _
è¯·æ±åå®¹é¿åº¦ _

####
# WebSocket server

WebSocket server
WebSocket æå¡å¨

start WebSocket server
å¯å¨ WebSocket æå¡å¨

last WebSocket event
æåç WebSocket äºä»¶

client ID for WebSocket event _
WebSocket äºä»¶ _ çå®¢æ·ç«¯ ID

payload for WebSocket event _
WebSocket äºä»¶ _ çè½½è·

type of WebSocket event _
WebSocket äºä»¶ _ çç±»å

send _ to WebSocket client _
åé _ å° WebSocket å®¢æ·ç«¯ _

####
# Web Things library

Web Thing
Web Thing

set thing name to _
è®¾ç½® Thing çåå­ä¸º _

set thing capability to _
è®¾ç½® thing çè½åä¸º _

set boolean property _ title _ @Type _
è®¾ç½®é»è¾å±æ§ _ åå­ _ @ç±»å _

set string property _ title _ @Type _
è®¾ç½®å­ç¬¦ä¸²å±æ§ _ åå­ _ @ç±»å _

set number property _ title _ @Type _
è®¾ç½®æ°å­å±æ§ _ åå­ _ @ç±»å _

set number property _ title _ min _ max _ @Type _
è®¾ç½®æ°å­å±æ§ _ åå­ _ æå° _ æå¤§ _ @ç±»å _

read only _
åªè¯» _

register event _ type _
æ³¨åäºä»¶ _ ç±»å _

start WebThing server
å¯å¨ WebThing æå¡å¨

trigger event _
è§¦åäºä»¶ _

thing description JSON
Thing ç JSON æè¿°

properties JSON
å±æ§ JSON

event definitions JSON
äºä»¶å®ä¹ JSON

events JSON
äºä»¶ JSON

####
# MQTT

MQTT connect to broker _
è¿æ¥å° MQTT æå¡å¨ _

buffer sizes _ client id _
ç¼å­å¤§å° _ å®¢æ·ç«¯ id _

username _ password _
ç¨æ·å _ å¯ç  _

MQTT connected
MQTT æå¡å¨å·²è¿æ¥

MQTT disconnect
æ­å¼ MQTT æå¡å¨è¿æ¥

MQTT sub _
è®¢éä¸»é¢ _

MQTT unsub _
åæ¶è®¢éä¸»é¢ _

MQTT pub topic _ payload _
åä¸»é¢ _ åå¸è½½è· _

retain _ QoS _
ä¿ç _ QoS _

MQTT event
MQTT äºä»¶

binary _
äºè¿å¶ _

topic for MQTT event _
MQTT äºä»¶çä¸»é¢ _

payload for MQTT event _
MQTT äºä»¶çè½½è· _

MQTT set will topic _ payload _
MQTT è®¾ç½®éå± ä¸»é¢ _ è½½è· _

buffer sizes _
ç¼å­å¤§å° _

####
# UDP

UDP start port _
UDP å¯å¨æå¡å¨ ç«¯å£ _ 

UDP stop
UDP åæ­¢æå¡å¨

UDP send packet _ to ip _ port _
UDP åéæ°æ®å _ å° ip _ ç«¯å£ _

UDP receive packet
UDP æ¥æ¶æ°æ®å 

binary data _
äºè¿å¶æ°æ® _

UDP remote IP address
UDP è¿ç¨ IP å°å

UDP remote port
UDP è¿ç¨ç«¯å£

####
# WiFi Radio

WiFi Radio
WiFi å¹¿æ­

wifi send number _
wifi å¹¿æ­åéæ°å­ _

wifi send string _
wifi å¹¿æ­åéå­ç¬¦ä¸² _

wifi send pair _ = _
wifi å¹¿æ­åééå¯¹ä¿¡æ¯ _ = _

wifi message received?
wifi å¹¿æ­æ¶æ¯å·²æ¶å°?

wifi last number
wifi æåå¹¿æ­çæ°å­

wifi last string
wifi æåå¹¿æ­çå­ç¬¦ä¸²

wifi set group _ (0-255)
wifi è®¾ç½®å¹¿æ­åç» _ (0-255)

####
# Cutebot

Cutebot
é·æ¯ç¹å°è½¦

Cutebot set wheel left _ right _ (-100 to 100)
é·æ¯ç¹ è®¾ç½®å·¦è½®éåº¦ä¸º _ å³è½®éåº¦ä¸º _ (-100 ... 100)

Cutebot stop wheels
é·æ¯ç¹ åè½¦

Cutebot set servo _ to _ degrees (-90 to 90)
é·æ¯ç¹ è®¾ç½®èµæº _ çè§åº¦ä¸º _ (-90 ... 90)

Cutebot set servo _ to speed _ (-100 to 100)
é·æ¯ç¹ è®¾ç½®èµæº _ çéåº¦ä¸º _ (-100 to 100)

Cutebot set headlight _ to _
é·æ¯ç¹ å° _ LED è½¦å¤´ç¯ è®¾ä¸º _

Cutebot set NeoPixel _ to _
é·æ¯ç¹ è®¾ç½® NeoPixel _ é¢è² _

Cutebot _ line sensor
é·æ¯ç¹ _ å·¡çº¿ä¼ æå¨ ç¶æä¸º

Cutebot sees line on left _ right _
é·æ¯ç¹ å·¡çº¿ä¼ æå¨ç¶æä¸º _ _

Cutebot distance (cm)
é·æ¯ç¹ è¶å£°æ³¢è¿åè·ç¦»å¼

left
å·¦

right
å³

both
å¨é¨


# Wukong

Wukong
æç©ºæ©å±æ¿

Wukong set motor _ to _ (-100 to 100)
æç©º è®¾ç½®çµæº _ éåº¦ä¸º _ (-100 ... 100)

Wukong stop motor _
æç©º åæ­¢çµæº _ 

Wukong stop all
æç©º åæ­¢ææçµæº

Wukong set servo _ to _ degrees (-90 to 90)
æç©º è®¾ç½® èµæº _ è§åº¦ä¸º _ (-90 ... 90)

Wukong set servo _ to speed _ (-100 to 100)
æç©º è®¾ç½® èµæº _ éåº¦ä¸º _ (-100 ... 100)

Wukong set NeoPixels _ _ _ _
æç©º è®¾ç½® NeoPixel _ _ _ _

Wukong set LED brightness to _
æç©º è®¾ç½®æ°å´ç¯äº®åº¦ä¸º _

####
# Sphero-RVR

wake
å¤é

sleep
ä¼ç 

reset the yaw
éç½®åèª

drive with speed _ and heading _
ä»¥éåº¦ _ åæå _ è¡é©¶

set raw motors with left mode _ left speed _ right mode _ right speed _
ä½¿ç¨ å·¦æ¨¡å¼ _ å·¦éåº¦ _ å³æ¨¡å¼ _ å³éåº¦ _ è®¾ç½®åå§çµæº

stop with heading _
ä»¥æå _ åæ­¢

set RGB LED _ to red _ green _ blue _
å° RGB LED _ è®¾ç½®ä¸º çº¢è² _ ç»¿è² _ èè² _

set all LEDs to red _ green _ blue _
å°ææ LED è®¾ä¸º çº¢è² _ ç»¿è² _ èè² _

####
# Joystick:bit

button _ is pressed
æé® _ è¢«æä¸

rocker value of _
ææ _ çæ°å¼

motor vibrate for _ ms
éå¨ _ æ¯«ç§

####
# NeZha

NeZha
åªåæ©å±æ¿

NeZha set motor _ speed to _ %
åªå è®¾ç½®çµæº _ éåº¦ä¸º _ %

NeZha stop motor _
åªå åæ­¢çµæº _

NeZha stop all motors
åªå åæ­¢ææçµæº

NeZha set _ servo _ angle to _
åªå è®¾ç½® _ èµæº _ è§åº¦ä¸º _

NeZha set continuous rotation servo _ speed to _ %
åªå è®¾ç½® è¿ç»­è½¬å¨èµæº _ éåº¦ä¸º _ %

#### 
# HuskyLens

HuskyLens
äºåè¯å¾

HL init & set I2Caddr (hex) _
äºå åå§åå¹¶è®¾ç½® I2C å°å _

HL change algorithm _
äºå åæ¢ç®æ³ _

Color Recog
é¢è²è¯å«

Face Recog
äººè¸è¯å«

Line Track
å·¡çº¿

Obj Classify
ç©ä½åç±»

Obj Recog
ç©ä½è¯å«

Obj Track
ç©ä½è¿½è¸ª

Tag Recog
æ ç­¾è¯å«

HL do _
äºå è§¦å _

Knock
æ²å»

Save Picture
ä¿å­å¾ç

Save Screenshot
ä¿å­æªå¾

Forget Learned Objects
éå¿å­¦ä¹ æ°æ®

Clear Screen
æ¸ç©ºæªå¾

is pro
pro ç

firmware version
åºä»¶çæ¬

HL request _
äºå è¯·æ± _

Blocks
æ¹æ¡

Arrows
ç®­å¤´

Learned Blocks
å­¦ä¹ å°çæ¹æ¡

Learned Arrows
å­¦ä¹ å°çç®­å¤´

HL request by ID _ Object _
äºå è¯·æ± ID _ å¯¹è±¡ _

Blocks
æ¹æ¡

Arrows
ç®­å¤´

HL get info _
äºå è·åä¿¡æ¯ _

Object Count
å¯¹è±¡è®¡æ°

Learned Count
å­¦ä¼çè®¡æ°

Frame Number
å¸§æ°

HL get block _ block index _
äºå è·åæ¹æ¡ _ ç´¢å¼æ¹æ¡ _

X center
X ä¸­å¿

Y center
Y ä¸­å¿

Width
å®½åº¦

Height
é«åº¦

id
id

HL get arrow _ arrow index _
äºå è·åæ¹æ¡ _ ç´¢å¼ç®­å¤´ _

X origin
X èµ·ç¹

Y origin
Y èµ·ç¹

X target
X ç»ç¹

Y target
Y ç»ç¹

id
id

HL learn current object with ID _
äºå å½åå­¦ä¹ å¯¹è±¡ç ID _

HL learn object with ID _ Name _
äºå å­¦ä¹ å¯¹è±¡ç ID _ åç§° _

HL set CustomName _ for a learned object with ID _
äºå è®¾ç½®èªå®ä¹åç§° _ ç»å·²å­¦ä¹ å¯¹è±¡ ID _

HL write _ at x _ y _
äºå æ¾ç¤ºæå­ _ å¨ x _ y _

HL file _ file# _
äºå å­æ¡£ _ æä»¶ _

Save Model
ä¿å­æ¨¡å

Load Model
å è½½æ¨¡å

####
# WuKong2040

WuKong2040
æç©º2040

WuKong2040 rainbowLED _ color to _
æç©º2040 å½©è¹ç¯ _ é¢è² _

WuKong2040 rainbowLED _ R _ G _ B _ (0~255)
æç©º2040 å½©è¹ç¯ _ R _ G _ B _ (0~255)

WuKong2040 clear all rainbowLED
æç©º2040 å³é­ææå½©è¹ç¯

WuKong2040 motor _ speed to _ (-100~100)
æç©º2040 è®¾ç½®çµæº _ éåº¦ä¸º _ (-100~100)

WuKong2040 stop motor _
æç©º2040 åæ­¢çµæº _

WuKong2040 stop all motors
æç©º2040 åæ­¢ææçµæº

WuKong2040 buzzer beep _ ms
æç©º2040 èé¸£å¨é¸£å« _ æ¯«ç§

####
# Octopus
Octopus
å«çªé±¼ç³»åä¼ æå¨

Octopus LED pin _ toggle to _
å«çªé±¼ LEDå¼è _ åæ¢ä¸º _

Octopus LED pin _ brightness _ %
å«çªé±¼ LEDå¼è _ è®¾ç½®äº®åº¦ _ %

Octopus motor fan pin _ speed to _ %
å«çªé±¼ çµæºé£æå¼è _ è®¾ç½®éåº¦ _ %

Octopus 180Â° servo pin _ angle to _ Â° (0~180)
å«çªé±¼ 180Â°èµæºå¼è _ è®¾ç½®è§åº¦ _ Â° (0~180)

Octopus sonar trig _ echo _ distance (cm)
å«çªé±¼ è¶å£°æ³¢æµè·(åç±³) è§¦å _ åå£° _

Octopus value of light intensity (Lux) at pin _
å«çªé±¼ åç§å¼ºåº¦å¼ï¼Luxï¼å¼è _

Octopus value of DHT11 temperature (Â°C) at pin _
å«çªé±¼ DHT11 æ¸©åº¦(Â°C) å¼è _

Octopus value of DHT11 humidity (0~100) at pin _
å«çªé±¼ DHT11 æ¹¿åº¦(0~100) å¼è _

Octopus value of water level (0~40mm) at pin _
å«çªé±¼ æ°´ä½å¼(0~40mm) å¼è _

Octopus value of trimpot (0~1023) at pin _
å«çªé±¼ çµä½å¨æ°å¼(0~1023) å¼è _

Octopus value of noise (dB) at pin _
å«çªé±¼ åªå£°å¼(åè´) å¼è _

Octopus OLED show _ at x _ y _
å«çªé±¼ OLED æ¾ç¤º _ äº x _ y _

Octopus OLED clear
å«çªé±¼ OLED æ¸é¤å±å¹

Octopus OLED draw pixel x _ y _
å«çªé±¼ OLED ç»å¶åç´  x _ y _

Octopus OLED draw line from x _ y _ to x _ y _
å«çªé±¼ OLED ç»å¶ç´çº¿ ä» x _ y _ å° x _ y _

Octopus OLED draw rectangle x _ y _ w _ h _ rounding _ (3~15)
å«çªé±¼ OLED ç»å¶é¿æ¹å½¢ x _ y _ w _ h _  åè§ _ (3~15)

Octopus OLED fill rectangle x _ y _ w _ h _
å«çªé±¼ OLED å¡«åé¿æ¹å½¢ x _ y _ w _ h _

Octopus OLED draw circle x _ y _ radius _
å«çªé±¼ OLED ç»å¶åå½¢ x _ y _ åå¾ _

Octopus OLED fill circle x _ y _ radius _
å«çªé±¼ OLED å¡«ååå½¢ x _ y _ åå¾ _

####
# OctoStudio

Octo start
Octo å¯å¨

Octo beam to phones _
Octo ç»ææºåä¿¡å· _

duration _ ms
æç»­ _ æ¯«ç§

Octo receive beam
Octo æ¶å°çä¿¡å·

Octo stop
Octo åæ­¢

##################
# MicroBlocks UI #
##################

# buttons, error & info messages, dialog boxes, etc

New
æ°å»º

Open
æå¼

Open from board
ä»ä¸»æ¿ä¸æå¼

Copy project URL to clipboard
å¤å¶é¡¹ç® URL å°åªè´´æ¿

Information
ä¿¡æ¯

Plug in the board.
è¿æ¥ä¸»æ¿

Plug in the board and click the USB icon to connect.
æ¥ä¸ä¸»æ¿å¹¶åå» USB å¾æ è¿è¡è¿æ¥ã

Reading project from board...
ä»ä¸»æ¿è¯»åé¡¹ç®...

Loading project...
å è½½é¡¹ç®

Found a newer version of 
åç°æ°çæ¬

Do you want me to update the one in the project?
ä½ å¸æå¨é¡¹ç®ä¸­è¿è¡åçº§åï¼

Save
ä¿å­

Connect
è¿æ¥

connect
è¿æ¥ä¸»æ¿

open Boardie
è¿æ¥æ¨¡æå¨

disconnect
æ­å¼è¿æ¥

Serial port:
ä¸²å£:

Connect board and try again
è¿æ¥æ¿å­å¹¶éè¯

other...
å¶ä»...

none
æ 

Port name?
ç«¯å£å?

Board type:
ä¸»æ¿ç±»å:

Select board:
éæ©ä¸»æ¿:

Could not read:
æ æ³è¯»å:

by
ç±

Created with GP
ä½¿ç¨GPå¼å

More info at http://microblocks.fun
è®¿é® http://microblocks.fun è·åæ´å¤ä¿¡æ¯

Function "
å½æ° "

" is too large to send to board.
" å ä¸ºå¤ªå¤§èæ æ³åéè³ä¸»æ¿.

Script is too large to send to board.
èæ¬å¤ªå¤§ï¼æ æ³åéè³ä¸»æ¿.

Use "Connect" button to connect to a MicroBlocks device.
ä½¿ç¨"è¿æ¥"æé®è¿æ¥è³ä¸ä¸ª MicroBlocks è®¾å¤.

No boards found; is your board plugged in?
æ æ³æ¾å°ä¸»æ¿ï¼æ¨çä¸»æ¿å·²ç»è¿æ¥å¥½äºä¹?

For AdaFruit boards, double-click reset button and try again.
å¦ææ¯AdaFruitä¸»æ¿ï¼åå»reseté®å¹¶åæ¬¡å°è¯.

Only recent Chrome and Edge browsers support WebSerial.
è¯·ä½¿ç¨æ¯æ WebSerial çæµè§å¨(Chrome å Edge æµè§å¨)

The board is not responding.
ä¸»æ¿æªååº.

Try to Install MicroBlocks on the board?
å° MicroBlocks å®è£å°è¿åä¸»æ¿ä¸ä¹?

The MicroBlocks in your board is not current
ä¸»æ¿ä¸­ç MicroBlocks ä¸æ¯ææ°çæ¬

Try to update MicroBlocks on the board?
æ¯å¦åçº§ä¸»æ¿ä¸ç MicroBlocks?

MicroBlocks
è®¾ç½®

Stop
åæ­¢

Start
å¼å§

Quit MicroBlocks?
éåº MicroBlocks?

Discard current project?
æ¾å¼å½åé¡¹ç®?

# Scripting area right-click context menu


set block size...
è®¾ç½®ç§¯æ¨åå¤§å°

make blocks bigger or smaller
å°ç§¯æ¨ååå¤§æåå°

clean up
æ´çç§¯æ¨

arrange scripts
æåèæ¬

undrop (ctrl-Z)
æ¤é (ctrl-Z)

undo the last block drop
æ¤éä¸æ¬¡ææ½

copy all scripts to clipboard
å°ææèæ¬å¤å¶å°åªè´´æ¿

copy all scripts to clipboard as URL
å°ææèæ¬ä½ä¸º URL å¤å¶å°åªè´´æ¿

paste all scripts
ç²è´´ææèæ¬

paste script
ç²è´´èæ¬

paste script from clipboard
ä»åªè´´æ¿ç²è´´èæ¬

save a picture of all visible scripts
å°ææå¯è§èæ¬ä¿å­ä¸ºå¾ç

set exported script scale
è®¾ç½®å¯¼åºèæ¬çæ¯ä¾

small (50%)
å° (50%)

normal (65%)
æ­£å¸¸ (65%)

large (100%)
å¤§ (100%)

printable (200%)
å¯æå° (200%)

about...
å³äº...

About MicroBlocks
å³äº MicroBlocks

virtual machine version
èææºçæ¬

update firmware on board
åçº§ä¸»æ¿åºä»¶

show data graph
æ¾ç¤ºæ°æ®å¾è¡¨

set serial delay
è®¾ç½®ä¸²å£å»¶è¿

firmware version
åºä»¶çæ¬

start WebThing server
å¯å¨WebThingæå¡å¨

stop WebThing server
åæ­¢WebThingæå¡å¨

HTTP Server
HTTP æå¡å¨

MicroBlocks HTTP Server listening on port 6473
MicroBlocks HTTP æå¡å¨æ­£å¨çå¬ç«¯å£ 6473

disable autoloading board libraries
ç¦æ­¢èªå¨å è½½åä¸»æ¿ç¸å³çç§¯æ¨åº

enable autoloading board libraries
åè®¸èªå¨å è½½åä¸»æ¿ç¸å³çç§¯æ¨åº

enable PlugShare when project empty
åè®¸é¡¹ç®ä¸ºç©ºæ¶ä»ä¸»æ¿éè·åä»£ç 

disable PlugShare when project empty
ç¦æ­¢é¡¹ç®ä¸ºç©ºæ¶ä»ä¸»æ¿éè·åä»£ç 

hide implementation blocks
éèå®ç°å

do not show blocks and variables that are internal to libraries (i.e. those whose name begins with underscore)
ä¸æ¾ç¤ºç§¯æ¨åºç§æçç§¯æ¨åååéï¼å³é£äºåç§°ä»¥ä¸åçº¿å¼å¤´çåéï¼

show implementation blocks
æ¾ç¤ºå®ç°å

show blocks and variables that are internal to libraries (i.e. those whose name begins with underscore)
æ¾ç¤ºç§¯æ¨åºç§æçç§¯æ¨åååéï¼å³é£äºåç§°ä»¥ä¸åçº¿å¼å¤´çåéï¼

when plugging a board, do not automatically read its contents into the IDE even if the current project is empty
è¿æ¥ä¸»æ¿æ¶ï¼å³ä½¿å½åé¡¹ç®ä¸ºç©ºï¼ä¹ä¸è¦èªå¨å°ä¸»æ¿éçä»£ç è¯»å¥ IDE

when plugging a board, automatically read its contents into the IDE if the current project is empty
è¿æ¥ä¸»æ¿æ¶ï¼å¦æå½åé¡¹ç®ä¸ºç©ºï¼åèªå¨å°ä¸»æ¿éçä»£ç è¯»å¥IDE

erase flash and update firmware on ESP board
æ¦é¤ä¿¡æ¯å¹¶åçº§ ESP åºä»¶

install ESP firmware from URL
ä» URL å®è£ ESP åºä»¶

Use board type
ä½¿ç¨ä¸»æ¿ç±»åä¿¡æ¯

connected to IDE
å·²è¿æ¥å° IDE?

Firmware Installed
å®æåºä»¶å®è£

Reconnect to the board by clicking the "Connect" button (USB icon).
ç¹å» 'è¿æ¥' æé® (USB å¾æ ) éæ°è¿æ¥ä¸»æ¿ã

Connect USB cable while holding down the white BOOTSEL button before proceeding.
æä½ç½è² BOOTSEL æé®çåæ¶è¿æ¥ USB çº¿ã

You will be asked to save the firmware file.
ä½ å°è¢«è¦æ±ä¿å­åºä»¶æä»¶ã

Select
éæ©

as the destination drive, then click Save.
ä½ä¸ºç®æ é©±å¨å¨ï¼ç¶åç¹å»ä¿å­ã

Installing firmware...
æ­£å¨å®è£åºä»¶...

Plug in the board.
æä¸ä¸»æ¿ã

Board not connected
æªè¿æ¥ä¸»æ¿

Wiping board...
æ¦é¤ä¸»æ¿...

(press ESC to cancel)
(æä¸ESCé®åæ¶)

Done!
å®æ!

download and install latest VM
ä¸è½½å¹¶ä¸å®è£ææ°çç VM

Select board type:
éæ©ä¸»æ¿ç±»å:

Uploading MicroBlocks to board...
å° MicroBlocks ä¸ä¼ è³ä¸»æ¿...

copy data to clipboard
å°æ°æ®å¤å¶è³åªè´´æ¿

clear data
æ¸é¤æ°æ®

clear memory and variables
æ¸é¤åå­ååé

show advanced blocks
æ¾ç¤ºé«çº§ç§¯æ¨

export functions as library
å°ç§¯æ¨å¯¼åºä¸ºåº

hide advanced blocks
éèé«çº§ç§¯æ¨

put file on board
ææä»¶ä¸ä¼ å°ä¸»æ¿

get file from board
ä»ä¸»æ¿è·åæä»¶

uploaded
å·²ä¸ä¼ 

downloaded
å·²ä¸è½½

Data Graph
æ°æ®å¾è¡¨

Graph
å¾è¡¨

clear graph
æ¸é¤å¾è¡¨

zero at bottom
åºé¨ä¸ºé¶

zero in middle
ä¸­é¨ä¸ºé¶


export data to CSV file
å°æ°æ®å¯¼åºå° CSV æä»¶

import data from CSV file
ä» CSV æä»¶å¯¼å¥æ°æ®

copy graph data to clipboard
å°å¾å½¢æ°æ®å¤å¶å°åªè´´æ¿

show instructions
æ¾ç¤ºæä»¤

show compiled bytes
æ¾ç¤ºå­èä»£ç 

show call tree
æ¾ç¤ºè°ç¨æ 

expand
æ©å±

collapse
æå 

rename...
éå½å...

find variable accessors
æ¥æ¾åéè®¿é®å¨

find scripts or block definitions where this variable is being read
æ¥æ¾å°æ­£å¨è¯»åè¯¥åéçèæ¬æç§¯æ¨å®ä¹

find variable modifiers
æ¥æ¾åéä¿®æ¹å¨

find scripts or block definitions where this variable is being set or changed
æ¥æ¾æ­£å¨è®¾ç½®æä¿®æ¹è¯¥åéçèæ¬æç§¯æ¨å®ä¹

find uses of this block
å¯»æ¾å½åç§¯æ¨å¨åªéè¢«ä½¿ç¨

find scripts or block definitions using this block
å¯»æ¾ä½¿ç¨å½åç§¯æ¨çèæ¬æç§¯æ¨å®ä¹

show block definition...
æ¾ç¤ºç§¯æ¨å®ä¹...

show the definition of this block
æ¾ç¤ºç§¯æ¨å®ä¹

delete block definition...
å é¤ç§¯æ¨å®ä¹...

delete the definition of this block
å é¤å¯¹è¿åç§¯æ¨çå®ä¹

duplicate
å¤å¶

help
å¸®å©

duplicate this block
å¤å¶è¿åç§¯æ¨

delete block
å é¤ç§¯æ¨

delete this block
å é¤è¿åç§¯æ¨

just this one block
ä»è¿åç§¯æ¨

copy to clipboard
å¤å¶è³åªè´´æ¿

copy to clipboard as URL
ä½ä¸º URL å¤å¶å°åªè´´æ¿

copy these blocks to the clipboard as a URL
å°è¿äºç§¯æ¨ä½ä¸º URL å¤å¶å°åªè´´æ¿

copy these blocks to the clipboard
å°è¿äºç§¯æ¨å¤å¶è³åªè´´æ¿

duplicate all
å¤å¶å¨é¨

duplicate these blocks
å¤å¶è¿äºç§¯æ¨

extract block
ååºç§¯æ¨

pull out this block
æ¤åºç§¯æ¨

show help for this block in a browser
å¨æµè§å¨ä¸­æ¾ç¤ºç§¯æ¨çå¸®å©ä¿¡æ¯

save picture of script
ä¿å­èæ¬å¾ç

save picture of script with result
ä¿å­å¸¦ç»æçèæ¬å¾ç

save a picture of this block definition as a PNG file
å°è¿åç§¯æ¨çå®ä¹ä¿å­ä¸ºä¸ä¸ª PNG æä»¶

save a picture of these blocks as a PNG file
å°è¿äºç§¯æ¨çå¾çä¿å­ä¸ºä¸ä¸ª PNG æä»¶

save a picture of these blocks and their result as a PNG file
å°è¿äºç§¯æ¨çå¾çåä»ä»¬çç»æä¿å­ä¸ºä¸ä¸ª PNG æä»¶

copy script
å¤å¶èæ¬

delete
å é¤

Input type:
è¾å¥ç±»å:

string only
ä»å­ç¬¦ä¸²

string or number
å­ç¬¦ä¸²ææ°å­

number only
ä»æ°å­

stop editing
åæ­¢ç¼è¾

cut
åªå

copy
å¤å¶

paste
ç²è´´

accept
æ¥å

revert
è¿å

select all
éæ©å¨é¨

define
å®ä¹

number/string
æ°å­/å­ç¬¦ä¸²

editable number or string
å¯ç¼è¾çæ°å­æå­ç¬¦ä¸²

boolean switch
å¸å°å¼å³

color patch
é¢è²

label
æ ç­¾

input
è¾å¥

hide block definition
éèç§¯æ¨å®ä¹

Are you sure you want to remove this block definition?
æ¨ç¡®å®è¦å é¤è¿ä¸ªç§¯æ¨å®ä¹ä¹?

Language
è¯­è¨

Custom...
å®å¶...

Obsolete
åºå¼

OK
ç¡®å®

Ok
ç¡®å®

Yes
æ¯

No
å¦

Cancel
åæ¶

Okay
ç¡®å®

Confirm
ç¡®è®¤

# Library folders

Libraries
ç§¯æ¨åº

AI
äººå·¥æºè½

Graphics and Displays
å¾å½¢ä¸æ¾ç¤º

Kits and Boards
å¥ä»¶ä¸æ©å±æ¿

Network
ç½ç»

Other
å¶ä»

Robots
æºå¨äºº

Sensing
ä¾¦æµ

Sound
å£°é³

System
ç³»ç»

ELECFREAKS
æ©å­

# File picker and library dialogs

Libraries
ç§¯æ¨åº

New library name?
ç§¯æ¨åºçåå­?

show all block definitions
æ¾ç¤ºææç§¯æ¨å®ä¹

hide all block definitions
éèææç§¯æ¨å®ä¹

export this library
å¯¼åºè¿ä¸ªåº

delete library
å é¤è¿ä¸ªåº

Examples
ç¤ºä¾

Desktop
æ¡é¢

Computer
è®¡ç®æº

Cloud
äº

File
æä»¶

File Open
æä»¶ æå¼

File Save
æä»¶ ä¿å­

File name:
æä»¶åç§°:

New Folder
æ°å»ºæä»¶å¤¹

by
ä½è

Depends:
ä¾èµäº:

Tags:
æ ç­¾:

Path, name or URL for library?
ç§¯æ¨åºçè·¯å¾,åç§°æURLå°å?

Invalid URL
æ æçé¾æ¥å°å

Could not fetch library.
æ æ³è¯»åç§¯æ¨åº.

Host does not exist or is currently down.
ä¸»æºä¸å­å¨æå¤äºå³é­ç¶æ.

File not found in server.
æ æ³å¨æå¡å¨ä¸æ¾å°è¯¥æä»¶.

Server expects HTTPS, and MicroBlocks doesn't currently support it.
æå¡å¨è¯·æ± HTTPS åè®®ï¼ä½ MicroBlocks ç®åè¿ä¸æ¯æ.

library information
ç§¯æ¨åºä¿¡æ¯

built-in library
åç½®ç§¯æ¨åº

Dependency path, name or URL?
ä¾èµçè·¯å¾,åå­æ URL?

If you are adding a library that's built into MicroBlocks, you can just enter its name.
å¦æè¦æ·»å çåºï¼å·²ç»åç½®å¨ MicroBlocksï¼åªéè¾å¥å®çåç§°(è±æ)å³å¯ï¼å¦ NeoPixel ã

If your library is in the Libraries folder in your local MicroBlocks project folder, you need to prefix it with a slash (/).
å¦æè¦æ·»å çåºï¼ä½äºç§¯æ¨åºæä»¶å¤¹ä¸­ï¼éè¦å¨å¶åé¢å ä¸ææ  (/)ï¼å¦ Network/MQTT ã

If the library is hosted online, please input its full URL.
å¦æè¦æ·»å çåºæ¯å¨çº¿æç®¡çï¼è¯·è¾å¥å®æ´ URLã

Tag name?
æ ç­¾åç§°?

user library
ç¨æ·åº

Add Library
æ·»å ç§¯æ¨åº

seconds remaining
å©ä½ç§æ°

Decrease block size
ç¼©å°ç§¯æ¨

Restore block size to 100%
å°ç§¯æ¨å¤§å°æ¢å¤å°100%

Increase block size
æ¾å¤§ç§¯æ¨

############
# Tips Bar #
############

Button
æé®

Boolean Input
å¸å°å¼è¾å¥

[l] toggle value, or drop a reporter into it.
[l] åæ¢å¸å°å¼ï¼æåµå¥æ¥åç±»ç§¯æ¨

Color Input
é¢è²è¾å¥

[l] change the color, or drop a reporter into it.
[l] æ¹åé¢è²ï¼æåµå¥æ¥åç±»ç§¯æ¨

Input
è¾å¥

[l] edit its value, or drop a reporter into it.
[l] ä¿®æ¹æ°å¼ï¼æåµå¥æ¥åç±»ç§¯æ¨

Block Extension
ç§¯æ¨æ©å±

[l] right arrow to show optional inputs, left arrow to hide.
[l] ç¹å»å³ç®­å¤´æ·»å é¢å¤çè¾å¥æ¡ï¼ç¹å»å·¦ç®­å¤´å é¤

Command Block
æä»¤ç±»ç§¯æ¨

[l] to run, or drag to build scripts. [r] menu.
[l] ç¹å»è¿è¡ï¼æç¨é¼ æ ææ½åºæ¥æ­å»ºç§¯æ¨èæ¬ã [r] æå¼èå

Hat Block
å¸½å­ç±»ç§¯æ¨

[l] to run, or drag to build scripts. [r] menu.
[l] ç¹å»è¿è¡ï¼æç¨é¼ æ ææ½åºæ¥æ­å»ºèæ¬ã [r] æå¼èå

Reporter Block
æ¥åç±»ç§¯æ¨

[l] to see value, or drop into an input slot. [r] menu.
[l] ç¹å»æ¥çæ°å¼ï¼æç¨é¼ æ ææ½åºæ¥åµå¥è¾åºæ¡åã [r] æå¼èå

Script
èæ¬

[l] to run. [r] menu.
[l] è¿è¡ã [r] æå¼èå

Pane Divider
çªæ ¼åå²çº¿

Drag to change pane width.
ææ½å¯ä¿®æ¹çªæ ¼å®½åº¦

Library
ç§¯æ¨åº

[l] to show the blocks in this library. [r] menu.
[l] æ¾ç¤ºæ­¤ç§¯æ¨åºä¸­çç§¯æ¨ä»£ç ã [r] æå¼èå

Block Category
ç§¯æ¨åç±»

[l] to show the blocks in this category.
[l] æ¾ç¤ºæ­¤åç±»ä¸­çç§¯æ¨

Palette
ç§¯æ¨åº

Drag blocks from here to build scripts. Drop scripts here to delete them.
ä»æ­¤å¤æåºç§¯æ¨æ­å»ºèæ¬ãå°ç§¯æ¨ææ½å°æ­¤å¤å¯å é¤ã

Scripts Pane
èæ¬åº

Drag blocks here to build scripts. [r] menu.
å°ç§¯æ¨ææ½å°æ­¤å¤æ­å»ºèæ¬ã [r] æå¼èå

#################################
# Block Descriptions for TipBar #
#################################

Turn the user LED on or off.
æå¼æå³é­ LED ç¯

Display a bubble showing the value.
ç¨æ°æ³¡å¯¹è¯æ¡æ¾ç¤ºå¼

Graph the value.
ä¸ºæ°å¼ç»å¶å¾è¡¨

Report the state of button A ( (-o) or (o-) ).
æ¥åæé® A çç¶æï¼ (-o) æ (o-) ï¼

Report the state of button B ( (-o) or (o-) ).
æ¥åæé® B çç¶æï¼ (-o) æ (o-) ï¼

Report the milliseconds since the timer was last reset.
æ¥åä¸ä¸æ¬¡è®¡æ¶å¨å½é¶åçæ¯«ç§æ¶é¿

Reset the timer.
éç½®è®¡æ¶å¨

Report the milliseconds since power up.
æ¥åéçµåçæ¯«ç§è®¡æ¶

Report the microseconds since power up.
æ¥åéçµåçå¾®ç§è®¡æ¶

Report the board type.
æ¥åå½åä¸»æ¿ç±»å

Report the electrical logic level on a digital pin ( (-o) or (o-) ).
æ¥åä¸ä¸ªæ°å­å¼èççµæ°é»è¾çµå¹³ï¼ (-o) æ (o-) ï¼

Report a number proportional to the voltage on an analog pin (0 = ground, 1023 = supply voltage).
æ¥åä¸ä¸ªä¸æ¨¡æå¼èä¸ççµåææ¯ä¾çæ°å­ï¼0=æ¥å°ï¼1023=çµæºçµåï¼

Turn a pin on or off ( (-o) or (o-) ).
æå¼ (-o) æå³é­ (o-) å¼è

Pulse width modulate (PWM) a pin with the given duty cycle (0 - 1023).
ä»¥è¾å¥çå ç©ºæ¯ï¼0-1023ï¼å¯¹ä¸ä¸ªå¼èè¿è¡èå²å®½åº¦è°å¶ï¼PWM)

Report number of analog pins on this device.
æ¥åå½åè®¾å¤ä¸çæ¨¡æå¼èæ°é

Report number of digital pins on this device.
æ¥åå½åè®¾å¤ä¸çæ°å­å¼èæ°é

Report the value of a register (0-255) of an I2C device (0-127).
æ¥åä¸ä¸ª I2C è®¾å¤ï¼0-127ï¼ä¸çå¯å­å¨ï¼0-255ï¼æ°å¼

Set an I2C device and register to given value (0-255).
è®¾ç½®ä¸ä¸ª I2C è®¾å¤ä¸çå¯å­å¨ï¼0-255ï¼æ°å¼

Receive multiple bytes from an I2C device.
ä»ä¸ä¸ª I2C è®¾å¤ä¸è¯»åå¤ä¸ªå­è

Send multiple bytes to an I2C device.
åä¸ä¸ª I2C è®¾å¤åéå¤ä¸ªå­è

Send a byte (0-255) to an SPI device.
åä¸ä¸ª SPI è®¾å¤åéä¸ä¸ªå­èï¼0-255ï¼

Read a byte from an SPI device while sending a zero byte. Report the byte received.
ä»ä¸ä¸ª SPI è®¾å¤ä¸è¯»åå­èçåæ¶åé 0 å­èãæ¥åè¯»åå°çå­è

Set the SPI clock speed and mode.
è®¾ç½® SPI æ¶éé¢çåæ¨¡å¼

Send a byte array via SPI, replacing its contents with the bytes received.
éè¿ SPI åéä¸ä¸ªå­èæ°ç»ï¼å°å¶åå®¹æ¿æ¢ä¸ºè¯»åå°çå­è

Open the serial port at the given baud rate.
ä»¥è¾å¥çæ³¢ç¹çæå¼ä¸²è¡ç«¯å£

Close the serial port.
å³é­ä¸²è¡ç«¯å£

Report data received from the serial port (a byte array).
æ¥åä¸²è¡ç«¯å£ä¸è¯»åå°çæ°æ®ï¼ä¸ä¸ªå­èæ°ç»ï¼

Send a byte array to the serial port.
åä¸²è¡ç«¯å£åéä¸ä¸ªå­èæ°ç»

Run when the board powers up or when the IDE start button is clicked.
å½ä¸»æ¿éçµåæèæä¸ IDE å¼å§æé®æ¶è¿è¡

Run when buttons A, B, or A+B are pressed.
å½æé® Aï¼B æ A+B è¢«æä¸æ¶è¿è¡

Repeat the enclosed blocks indefinitely.
éå¤æ§è¡ååµçç§¯æ¨ä»£ç 

Repeat the enclosed blocks the given number of times.
ä»¥è¾å¥çæ¬¡æ°æ¥éå¤æ§è¡ååµçç§¯æ¨ä»£ç 

Wait the given number of milliseconds.
ç­å¾è¾å¥çæ¯«ç§æ¶é¿

Run the first set of blocks whose test condition is (-o) .
å½æ¡ä»¶æ»¡è¶³æ¶ (-o) è¿è¡ç¬¬ä¸è¡ç§¯æ¨ä»£ç 

Run when the condition becomes (-o) .
å½æ¡ä»¶æ»¡è¶³æ¶ (-o) è¿è¡

Wait until the condition becomes (-o) .
ä¸ç´ç­å¾ç´å°å°æ¡ä»¶æ»¡è¶³ (-o)

Return (report) the given value from a function or script.
æ¥åä¸ä¸ªå½æ°æèæ¬çæ°å¼

Run when the given message is broadcast.
å½æ¥æ¶å°è¾å¥çå¹¿æ­ä¿¡æ¯æ¶è¿è¡

Broadcast the given message.
å¹¿æ­è¾å¥çä¿¡æ¯

Do nothing. Used to add notes and documentation.
æ²¡æå®éåè½ï¼å¯ç¨æ¥æ·»å æ³¨éåæå­è¯´æ

Repeat the enclosed blocks with the variable set to the current iteration number or item.
ä»¥å½åè¿­ä»£æ¬¡æ°æåç´ çåéæ¥éå¤æ§è¡ååµçç§¯æ¨

Repeat the enclosed blocks until the condition becomes (-o) .
éå¤æ§è¡ååµç§¯æ¨ä»£ç ç´å°æ¡ä»¶æ»¡è¶³ (-o)

Stop this task.
åæ­¢å½åèæ¬

Stop all tasks except this one.
åæ­¢å¶ä»èæ¬

Wait the given number of microseconds.
ç­å¾è¾å¥çå¾®ç§æ¶é¿

Report the last broadcast message received.
æ¥åæ¥åå°çæåå¹¿æ­æ¶æ¯

Call the function with the given name and optional parameter list.
è°ç¨è¾å¥çå½æ°æå¯éåè¡¨ä¸­çå½æ°

Call the function with the given name and optional parameter list and report its return value.
è°ç¨è¾å¥çå½æ°æå¯éåè¡¨ä¸­çå½æ°ï¼å¹¶æ¥åå¶æ°å¼

Report the sum of the given numbers.
æ¥åè¾å¥çæ°å­æ»å

Report the first number minus the second.
æ¥åç¬¬ä¸ä¸ªæ°å­åå»ç¬¬äºä¸ªæ°å­çå¼

Report the product of the given numbers.
æ¥åè¾å¥çæ°å­çä¹ç§¯

Report the first number divided by the second.
æ¥åç¬¬ä¸ä¸ªæ°å­é¤ä»¥ç¬¬äºä¸ªæ°å­çå¼

Report the remainder of dividing the first number by the second.
æ¥åç¬¬ä¸ä¸ªæ°å­é¤ä»¥ç¬¬äºä¸ªæ°å­çä½æ°

Report the absolute value of the given number (always >= 0).
æ¥åè¾å¥æ°å­çç»å¯¹å¼ï¼æ°¸è¿å¤§äºæç­äº0ï¼

Report the minimum of the values.
æ¥åè¾å¥æ°å­ä¸­çæå°å¼

Report the maximum of the values.
æ¥åè¾å¥æ°å­ä¸­çæå¤§å¼

Report a randomly chosen number in the given range.
æ¥åè¾å¥çæ°å­èå´ä¸­çä¸ä¸ªä»»æéæºæ°

Report (-o) if the first value is less than the second one.
æ¥åç¬¬ä¸ä¸ªæ°å¼æ¯å¦å°äºç¬¬äºä¸ªæ°å¼ (-o)

Report (-o) if the first value is less than or equal to the second one.
æ¥åç¬¬ä¸ä¸ªæ°å¼æ¯å¦å°äºæç­äºç¬¬äºä¸ªæ°å¼ (-o)

Report (-o) if the two values are equal.
æ¥åä¸¤ä¸ªæ°å¼æ¯å¦ç¸ç­ (-o)

Report (-o) if the two values are not equal.
æ¥åä¸¤ä¸ªæ°å¼æ¯å¦ä¸ç¸ç­ (-o)

Report (-o) if the first value is greater than or equal to the second one.
æ¥åç¬¬ä¸ä¸ªæ°å¼æ¯å¦å¤§äºæç­äºç¬¬äºä¸ªæ°å¼ (-o)

Report (-o) if the first value is greater than the second one.
æ¥åç¬¬ä¸ä¸ªæ°å¼æ¯å¦å¤§äºç¬¬äºä¸ªæ°å¼ (-o)

Boolean constant ( (-o) or (o-) ).
å¸å°å¼å¸¸éï¼ (-o) æ (o-) ï¼

Report the logical inverse of a Boolean ( (-o) or (o-) ) value.
æ¥åä¸ä¸ªå¸å°å¼ï¼ (-o) æ (o-) ï¼çé»è¾éæ°å¼

Report (-o) if both values are (-o)
æ¥åä¸¤ä¸ªå¸å°å¼æ¯å¦é½ä¸ºç (-o)

Report (-o) if either value is (-o)
æ¥åä¸¤ä¸ªå¸å°å¼ä¸­æ¯å¦æä¸ä¸ªä¸ºç (-o)

Report (-o) if first input is a value of the given data type.
æ¥åè¾å¥çåå®¹æ¯å¦å±äºéä¸­çæ°æ®ç±»å (-o)

Report the numerical value of a hexadecimal string (range: -0x1FFFFFFF to 0x1FFFFFFF)
æ¥åä¸ä¸ªåå­è¿å¶æ°çåè¿å¶æ°å¼ï¼å¯è¾å¥èå´ï¼-0x1FFFFFFF ~ 0x1FFFFFFFï¼

Report bitwise AND of two numbers.
æ¥åä¸¤ä¸ªæ°å­çæä½ä¸è¿ç®ç»æ

Report bitwise OR of two numbers.
æ¥åä¸¤ä¸ªæ°å­çæä½æè¿ç®ç»æ

Report bitwise XOR (exclusive OR) of two numbers.
æ¥åä¸¤ä¸ªæ°å­çæä½å¼æè¿ç®ç»æ

Report bitwise inverse of the given number.
æ¥åè¾å¥æ°å­çæä½ååè¿ç®ç»æ

Report the given number shifted left by the given number of bits.
æ¥åè¾å¥æ°å­åå·¦å¹³ç§»è¥å¹²ä½åçç»æ

Report the given number shifted right by the given number of bits (arithmetic shift; sign is maintained).
æ¥åè¾å¥æ°å­åå³å¹³ç§»è¥å¹²ä½åçç»æï¼ç®æ¯ä½ç§»ï¼ç¬¦å·ä¿æä¸åï¼

Set a variable to the given value.
å°åéè®¾ä¸ºè¾å¥çæ°å¼

Change a variable by the given amount.
å°è¾å¥çæ°å­ä¸åéç¸å 

Create a variable local to the containing script with the given initial value.
ä»¥è¾å¥çåå§å¼åå»ºä¸ä¸ªåå«èæ¬çå±é¨åé

Report the Nth item of a list, string, or byte array.
æ¥ååè¡¨ãå­ç¬¦æå­èæ°ç»ä¸­çç¬¬ N é¡¹åç´ 

Report the number of items in a list, string, or byte array.
æ¥ååè¡¨ãå­ç¬¦æå­èæ°å­ä¸­çåç´ çæ°é

Join (concatenate) the given lists, strings, or byte arrays and report the result.
å°è¾å¥çåè¡¨ãå­ç¬¦æå­èæ°ç»ç»åèµ·æ¥å¹¶æ¥åç»æ

Create and report a short list containing the given items. Length limited by available stack space.
åå»ºå¹¶æ¥åä¸ä¸ªåå«è¾å¥åç´ çç­åè¡¨ãé¿åº¦åéäºå¯ç¨çå æ ç©ºé´

Add an item to the end of a list.
å¨åè¡¨çæ«å°¾æ·»å ä¸é¡¹åç´ 

Replace the Nth item (or all items) of a list or byte array with the given value.
ç¨è¾å¥çæ°å¼æ¿æ¢åè¡¨æå­èæ°ç»ä¸­çç¬¬ N é¡¹åç´ ï¼æææåç´ ï¼

Delete the Nth item (or all items) of a list.
å é¤åè¡¨ä¸­çç¬¬ N é¡¹åç´ ï¼æææåç´ ï¼

Find and report the index of an item in a list or a substring within a string. Report -1 if not found.
æ¥æ¾å¹¶æ¥ååè¡¨ä¸­æä¸åç´ æå­ç¬¦ä¸²ä¸­æä¸å­ä¸²çç´¢å¼ãå¦ææ²¡ææ¾å°åæ¥å -1

Report a copy from the given index through the end (or optional stop index) of the given list, string, or byte array.
æ¥åä»è¾å¥çç´¢å¼å¨è¾å¥çåè¡¨ãå­ç¬¦ä¸²æå­èæ°ç»ä¸­ï¼æå¯éçåæ­¢ç´¢å¼ï¼çæ·è´

Split the given string with the given delimiter and report the result (a list of strings).
ç¨è¾å¥çåéç¬¦åå²è¾å¥çå­ç¬¦ä¸²ï¼å¹¶æ¥åç»æï¼ä¸ä¸ªå­ç¬¦ä¸²çåè¡¨ï¼

Combine the items of a list into a string, optionally separated by a delimiter (e.g. comma).
å°ä¸ä¸ªåè¡¨ä¸­çåç´ åå¹¶æä¸ä¸ªå­ç¬¦ä¸²ï¼å¯éæ©ç¨åçç¬¦ï¼å¦éå·ï¼åé

Report the Unicode value ("code point") of the Nth character of the given string.
æ¥åè¾å¥å­ç¬¦ä¸²çç¬¬ N ä¸ªå­ç¬¦ç Unicode å¼ï¼ä»£ç ç¹ï¼

Report a string containing the given Unicode value ("code point") or list of values.
æ¥åä¸ä¸ªåå«è¾å¥ç Unicode å¼ï¼ä»£ç ç¹ï¼æå¼åè¡¨çå­ç¬¦ä¸²

Report a new list of the given length filled with zero or the optional value.
æ¥åä¸ä¸ªæ°çåè¡¨ï¼å¶é¿åº¦ä¸ºè¾å¥å¼ï¼åè¡¨åç´ ä¸º 0 æå¯éæ°å¼

Report a new byte array of the given length filled with zero or the optional value.
æ¥åä¸ä¸ªæ°çå­èæ°ç»ï¼å¶é¿åº¦ä¸ºè¾å¥å¼ï¼æ°ç»åç´ ä¸º 0 æå¯éæ°å¼

Report a byte array containing the UTF-8 bytes of the given string.
æ¥åä¸ä¸ªå­èæ°ç»ï¼è¯¥æ°ç»åå«è¾å¥å­ç¬¦ä¸²ç UTF-8 å­è

Report the number of words of memory available. Stop button frees up memory.
æ¥åå¯ç¨åå­çå­æ°ãåæ­¢æé®éæ¾åå­

